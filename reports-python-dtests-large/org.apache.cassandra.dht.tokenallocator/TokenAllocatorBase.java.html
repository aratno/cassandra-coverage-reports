<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TokenAllocatorBase.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.dht.tokenallocator</a> &gt; <span class="el_source">TokenAllocatorBase.java</span></div><h1>TokenAllocatorBase.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.dht.tokenallocator;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.NavigableMap;
import java.util.Random;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

import org.apache.cassandra.dht.IPartitioner;
import org.apache.cassandra.dht.Token;

public abstract class TokenAllocatorBase&lt;Unit&gt; implements TokenAllocator&lt;Unit&gt;
{
<span class="fc" id="L35">    static final double MIN_INITIAL_SPLITS_RATIO = 1.0 - 1.0 / Math.sqrt(5.0);</span>
<span class="fc" id="L36">    static final double MAX_INITIAL_SPLITS_RATIO = MIN_INITIAL_SPLITS_RATIO + 0.075;</span>

    final NavigableMap&lt;Token, Unit&gt; sortedTokens;
    final ReplicationStrategy&lt;Unit&gt; strategy;
    final IPartitioner partitioner;

    protected TokenAllocatorBase(NavigableMap&lt;Token, Unit&gt; sortedTokens,
                             ReplicationStrategy&lt;Unit&gt; strategy,
                             IPartitioner partitioner)
<span class="fc" id="L45">    {</span>
<span class="fc" id="L46">        this.sortedTokens = sortedTokens;</span>
<span class="fc" id="L47">        this.strategy = strategy;</span>
<span class="fc" id="L48">        this.partitioner = partitioner;</span>
<span class="fc" id="L49">    }</span>

    public abstract int getReplicas();

    protected Map&lt;Unit, UnitInfo&lt;Unit&gt;&gt; createUnitInfos(Map&lt;Object, GroupInfo&gt; groups)
    {
<span class="fc" id="L55">        Map&lt;Unit, UnitInfo&lt;Unit&gt;&gt; map = Maps.newHashMap();</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">        for (Unit n : sortedTokens.values())</span>
        {
<span class="fc" id="L58">            UnitInfo&lt;Unit&gt; ni = map.get(n);</span>
<span class="fc bfc" id="L59" title="All 2 branches covered.">            if (ni == null)</span>
<span class="fc" id="L60">                map.put(n, ni = new UnitInfo&lt;&gt;(n, 0, groups, strategy));</span>
<span class="fc" id="L61">            ni.tokenCount++;</span>
<span class="fc" id="L62">        }</span>
<span class="fc" id="L63">        return map;</span>
    }

    private Map.Entry&lt;Token, Unit&gt; mapEntryFor(Token t)
    {
<span class="nc" id="L68">        Map.Entry&lt;Token, Unit&gt; en = sortedTokens.floorEntry(t);</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">        if (en == null)</span>
<span class="nc" id="L70">            en = sortedTokens.lastEntry();</span>
<span class="nc" id="L71">        return en;</span>
    }

    Unit unitFor(Token t)
    {
<span class="nc" id="L76">        return mapEntryFor(t).getValue();</span>
    }

    // get or initialise the shared GroupInfo associated with the unit
    private static &lt;Unit&gt; GroupInfo getGroup(Unit unit, Map&lt;Object, GroupInfo&gt; groupMap, ReplicationStrategy&lt;Unit&gt; strategy)
    {
<span class="fc" id="L82">        Object groupClass = strategy.getGroup(unit);</span>
<span class="fc" id="L83">        GroupInfo group = groupMap.get(groupClass);</span>
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">        if (group == null)</span>
<span class="fc" id="L85">            groupMap.put(groupClass, group = new GroupInfo(groupClass));</span>
<span class="fc" id="L86">        return group;</span>
    }

    Collection&lt;Token&gt; generateSplits(Unit newUnit, int numTokens)
    {
<span class="fc" id="L91">        return generateSplits(newUnit, numTokens, MIN_INITIAL_SPLITS_RATIO, MAX_INITIAL_SPLITS_RATIO);</span>
    }
    /**
     * Selects tokens by repeatedly splitting the largest range in the ring at the given ratio.
     *
     * This is used to choose tokens for the first nodes in the ring where the algorithm cannot be applied (e.g. when
     * number of nodes &lt; RF). It generates a reasonably chaotic initial token split, after which the algorithm behaves
     * well for an unbounded number of nodes.
     */
    Collection&lt;Token&gt; generateSplits(Unit newUnit, int numTokens, double minRatio, double maxRatio)
    {
<span class="fc" id="L102">        Random random = new Random(sortedTokens.size());</span>

<span class="fc" id="L104">        double potentialRatioGrowth = maxRatio - minRatio;</span>

<span class="fc" id="L106">        List&lt;Token&gt; tokens = Lists.newArrayListWithExpectedSize(numTokens);</span>

<span class="fc bfc" id="L108" title="All 2 branches covered.">        if (sortedTokens.isEmpty())</span>
        {
            // Select a random start token. This has no effect on distribution, only on where the local ring is &quot;centered&quot;.
            // Using a random start decreases the chances of clash with the tokens of other datacenters in the ring.
<span class="fc" id="L112">            Token t = partitioner.getRandomToken();</span>
<span class="fc" id="L113">            tokens.add(t);</span>
<span class="fc" id="L114">            sortedTokens.put(t, newUnit);</span>
        }

<span class="fc bfc" id="L117" title="All 2 branches covered.">        while (tokens.size() &lt; numTokens)</span>
        {
            // split max span using given ratio
<span class="fc" id="L120">            Token prev = sortedTokens.lastKey();</span>
<span class="fc" id="L121">            double maxsz = 0;</span>
<span class="fc" id="L122">            Token t1 = null;</span>
<span class="fc" id="L123">            Token t2 = null;</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">            for (Token curr : sortedTokens.keySet())</span>
            {
<span class="fc" id="L126">                double sz = prev.size(curr);</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">                if (sz &gt; maxsz)</span>
                {
<span class="fc" id="L129">                    maxsz = sz;</span>
<span class="fc" id="L130">                    t1 = prev; t2 = curr;</span>
                }
<span class="fc" id="L132">                prev = curr;</span>
<span class="fc" id="L133">            }</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">            assert t1 != null;</span>
<span class="fc" id="L135">            Token t = partitioner.split(t1, t2, minRatio + potentialRatioGrowth * random.nextDouble());</span>
<span class="fc" id="L136">            tokens.add(t);</span>
<span class="fc" id="L137">            sortedTokens.put(t, newUnit);</span>
<span class="fc" id="L138">        }</span>
<span class="fc" id="L139">        return tokens;</span>
    }

    /**
     * Unique group object that one or more UnitInfo objects link to.
     */
    static class GroupInfo
    {
        /**
         * Group identifier given by ReplicationStrategy.getGroup(Unit).
         */
        final Object group;

        /**
         * Seen marker. When non-null, the group is already seen in replication walks.
         * Also points to previous seen group to enable walking the seen groups and clearing the seen markers.
         */
<span class="fc" id="L156">        GroupInfo prevSeen = null;</span>
        /**
         * Same marker/chain used by populateTokenInfo.
         */
<span class="fc" id="L160">        GroupInfo prevPopulate = null;</span>

        /**
         * Value used as terminator for seen chains.
         */
<span class="fc" id="L165">        static GroupInfo TERMINATOR = new GroupInfo(null);</span>

        public GroupInfo(Object group)
<span class="fc" id="L168">        {</span>
<span class="fc" id="L169">            this.group = group;</span>
<span class="fc" id="L170">        }</span>

        public String toString()
        {
<span class="nc bnc" id="L174" title="All 2 branches missed.">            return group.toString() + (prevSeen != null ? &quot;*&quot; : &quot;&quot;);</span>
        }
    }

    /**
     * Unit information created and used by ReplicationAwareTokenDistributor. Contained vnodes all point to the same
     * instance.
     */
    static class UnitInfo&lt;Unit&gt;
    {
        final Unit unit;
        final GroupInfo group;
        double ownership;
        int tokenCount;

        /**
         * During evaluateImprovement this is used to form a chain of units affected by the candidate insertion.
         */
        UnitInfo&lt;Unit&gt; prevUsed;
        /**
         * During evaluateImprovement this holds the ownership after the candidate insertion.
         */
        double adjustedOwnership;

        private UnitInfo(Unit unit, GroupInfo group)
<span class="fc" id="L199">        {</span>
<span class="fc" id="L200">            this.unit = unit;</span>
<span class="fc" id="L201">            this.group = group;</span>
<span class="fc" id="L202">            this.tokenCount = 0;</span>
<span class="fc" id="L203">        }</span>

        public UnitInfo(Unit unit, double ownership, Map&lt;Object, GroupInfo&gt; groupMap, ReplicationStrategy&lt;Unit&gt; strategy)
        {
<span class="fc" id="L207">            this(unit, getGroup(unit, groupMap, strategy));</span>
<span class="fc" id="L208">            this.ownership = ownership;</span>
<span class="fc" id="L209">        }</span>

        public String toString()
        {
<span class="nc" id="L213">            return String.format(&quot;%s%s(%.2e)%s&quot;,</span>
<span class="nc bnc" id="L214" title="All 4 branches missed.">                                 unit, unit == group.group ? (group.prevSeen != null ? &quot;*&quot; : &quot;&quot;) : &quot;:&quot; + group.toString(),</span>
<span class="nc bnc" id="L215" title="All 4 branches missed.">                                 ownership, prevUsed != null ? (prevUsed == this ? &quot;#&quot; : &quot;-&gt;&quot; + prevUsed.toString()) : &quot;&quot;);</span>
        }
    }

<span class="fc" id="L219">    private static class CircularList&lt;T extends CircularList&lt;T&gt;&gt;</span>
    {
        T prev;
        T next;

        /**
         * Inserts this after unit in the circular list which starts at head. Returns the new head of the list, which
         * only changes if head was null.
         */
        @SuppressWarnings(&quot;unchecked&quot;)
        T insertAfter(T head, T unit)
        {
<span class="fc bfc" id="L231" title="All 2 branches covered.">            if (head == null)</span>
            {
<span class="fc" id="L233">                return prev = next = (T) this;</span>
            }
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">            assert unit != null;</span>
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">            assert unit.next != null;</span>
<span class="fc" id="L237">            prev = unit;</span>
<span class="fc" id="L238">            next = unit.next;</span>
<span class="fc" id="L239">            prev.next = (T) this;</span>
<span class="fc" id="L240">            next.prev = (T) this;</span>
<span class="fc" id="L241">            return head;</span>
        }

        /**
         * Removes this from the list that starts at head. Returns the new head of the list, which only changes if the
         * head was removed.
         */
        T removeFrom(T head)
        {
<span class="fc" id="L250">            next.prev = prev;</span>
<span class="fc" id="L251">            prev.next = next;</span>
<span class="pc bpc" id="L252" title="1 of 4 branches missed.">            return this == head ? (this == next ? null : next) : head;</span>
        }
    }

    static class BaseTokenInfo&lt;Unit, T extends BaseTokenInfo&lt;Unit, T&gt;&gt; extends CircularList&lt;T&gt;
    {
        final Token token;
        final UnitInfo&lt;Unit&gt; owningUnit;

        /**
         * Start of the replication span for the vnode, i.e. the first token of the RF'th group seen before the token.
         * The replicated ownership of the unit is the range between {@code replicationStart} and {@code token}.
         */
        Token replicationStart;
        /**
         * The closest position that the new candidate can take to become the new replication start. If candidate is
         * closer, the start moves to this position. Used to determine replicationStart after insertion of new token.
         *
         * Usually the RF minus one boundary, i.e. the first token of the RF-1'th group seen before the token.
         */
        Token replicationThreshold;
        /**
         * Current replicated ownership. This number is reflected in the owning unit's ownership.
         */
<span class="fc" id="L276">        double replicatedOwnership = 0;</span>

        public BaseTokenInfo(Token token, UnitInfo&lt;Unit&gt; owningUnit)
<span class="fc" id="L279">        {</span>
<span class="fc" id="L280">            this.token = token;</span>
<span class="fc" id="L281">            this.owningUnit = owningUnit;</span>
<span class="fc" id="L282">        }</span>

        public String toString()
        {
<span class="nc" id="L286">            return String.format(&quot;%s(%s)&quot;, token, owningUnit);</span>
        }

        /**
         * Previous unit in the token ring. For existing tokens this is prev,
         * for candidates it's &quot;split&quot;.
         */
        TokenInfo&lt;Unit&gt; prevInRing()
        {
<span class="nc" id="L295">            return null;</span>
        }
    }

    /**
     * TokenInfo about existing tokens/vnodes.
     */
    static class TokenInfo&lt;Unit&gt; extends BaseTokenInfo&lt;Unit, TokenInfo&lt;Unit&gt;&gt;
    {
        public TokenInfo(Token token, UnitInfo&lt;Unit&gt; owningUnit)
        {
<span class="fc" id="L306">            super(token, owningUnit);</span>
<span class="fc" id="L307">        }</span>

        TokenInfo&lt;Unit&gt; prevInRing()
        {
<span class="fc" id="L311">            return prev;</span>
        }
    }

    static class Weighted&lt;T&gt; implements Comparable&lt;Weighted&lt;T&gt;&gt;
    {
        final double weight;
        final T value;

        public Weighted(double weight, T value)
<span class="fc" id="L321">        {</span>
<span class="fc" id="L322">            this.weight = weight;</span>
<span class="fc" id="L323">            this.value = value;</span>
<span class="fc" id="L324">        }</span>

        @Override
        public int compareTo(Weighted&lt;T&gt; o)
        {
<span class="fc" id="L329">            int cmp = Double.compare(o.weight, this.weight);</span>
<span class="fc" id="L330">            return cmp;</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L336">            return String.format(&quot;%s&lt;%s&gt;&quot;, value, weight);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>