<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ColumnCondition.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.conditions</a> &gt; <span class="el_source">ColumnCondition.java</span></div><h1>ColumnCondition.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3.conditions;

import java.nio.ByteBuffer;
import java.util.*;

import com.google.common.collect.Iterators;

import org.apache.cassandra.cql3.*;
import org.apache.cassandra.cql3.Term.Terminal;
import org.apache.cassandra.cql3.functions.Function;
import org.apache.cassandra.db.rows.*;
import org.apache.cassandra.db.marshal.*;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.transport.ProtocolVersion;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;

import static org.apache.cassandra.cql3.statements.RequestValidations.*;

/**
 * A CQL3 condition on the value of a column or collection element.  For example, &quot;UPDATE .. IF a = 0&quot;.
 */
public abstract class ColumnCondition
{
    public final ColumnMetadata column;
    public final Operator operator;
    private final Terms terms;

    private ColumnCondition(ColumnMetadata column, Operator op, Terms terms)
<span class="fc" id="L49">    {</span>
<span class="fc" id="L50">        this.column = column;</span>
<span class="fc" id="L51">        this.operator = op;</span>
<span class="fc" id="L52">        this.terms = terms;</span>
<span class="fc" id="L53">    }</span>

    /**
     * Adds functions for the bind variables of this operation.
     *
     * @param functions the list of functions to get add
     */
    public void addFunctionsTo(List&lt;Function&gt; functions)
    {
<span class="fc" id="L62">        terms.addFunctionsTo(functions);</span>
<span class="fc" id="L63">    }</span>

    /**
     * Collects the column specification for the bind variables of this operation.
     *
     * @param boundNames the list of column specification where to collect the
     * bind variables of this term in.
     */
    public void collectMarkerSpecification(VariableSpecifications boundNames)
    {
<span class="fc" id="L73">        terms.collectMarkerSpecification(boundNames);</span>
<span class="fc" id="L74">    }</span>

    public abstract ColumnCondition.Bound bind(QueryOptions options);

    protected final List&lt;ByteBuffer&gt; bindAndGetTerms(QueryOptions options)
    {
<span class="fc" id="L80">        return filterUnsetValuesIfNeeded(checkValues(terms.bindAndGet(options)));</span>
    }

    protected final List&lt;Terminal&gt; bindTerms(QueryOptions options)
    {
<span class="nc" id="L85">        return filterUnsetValuesIfNeeded(checkValues(terms.bind(options)));</span>
    }

    /**
     * Checks that the output of a bind operations on {@code Terms} is a valid one.
     * @param values the list to check
     * @return the input list
     */
    private &lt;T&gt; List&lt;T&gt; checkValues(List&lt;T&gt; values)
    {
<span class="pc bpc" id="L95" title="3 of 4 branches missed.">        checkFalse(values == null &amp;&amp; operator.isIN(), &quot;Invalid null list in IN condition&quot;);</span>
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">        checkFalse(values == Terms.UNSET_LIST, &quot;Invalid 'unset' value in condition&quot;);</span>
<span class="fc" id="L97">        return values;</span>
    }

    private &lt;T&gt; List&lt;T&gt; filterUnsetValuesIfNeeded(List&lt;T&gt; values)
    {
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">        if (!operator.isIN())</span>
<span class="fc" id="L103">            return values;</span>

<span class="nc" id="L105">        List&lt;T&gt; filtered = new ArrayList&lt;&gt;(values.size());</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">        for (int i = 0, m = values.size(); i &lt; m; i++)</span>
        {
<span class="nc" id="L108">            T value = values.get(i);</span>
            // The value can be ByteBuffer or Constants.Value so we need to check the 2 type of UNSET
<span class="nc bnc" id="L110" title="All 4 branches missed.">            if (value != ByteBufferUtil.UNSET_BYTE_BUFFER &amp;&amp; value != Constants.UNSET_VALUE)</span>
<span class="nc" id="L111">                filtered.add(value);</span>
        }
<span class="nc" id="L113">        return filtered;</span>
    }

    /**
     * Simple condition (e.g. &lt;pre&gt;IF v = 1&lt;/pre&gt;).
     */
    private static final class SimpleColumnCondition extends ColumnCondition
    {
        public SimpleColumnCondition(ColumnMetadata column, Operator op, Terms values)
        {
<span class="fc" id="L123">            super(column, op, values);</span>
<span class="fc" id="L124">        }</span>

        public Bound bind(QueryOptions options)
        {
<span class="pc bpc" id="L128" title="3 of 4 branches missed.">            if (column.type.isCollection() &amp;&amp; column.type.isMultiCell())</span>
<span class="nc" id="L129">                return new MultiCellCollectionBound(column, operator, bindTerms(options));</span>

<span class="pc bpc" id="L131" title="3 of 4 branches missed.">            if (column.type.isUDT() &amp;&amp; column.type.isMultiCell())</span>
<span class="nc" id="L132">                return new MultiCellUdtBound(column, operator, bindAndGetTerms(options), options.getProtocolVersion());</span>

<span class="fc" id="L134">            return new SimpleBound(column, operator, bindAndGetTerms(options));</span>
        }
    }

    /**
     * A condition on a collection element (e.g. &lt;pre&gt;IF l[1] = 1&lt;/pre&gt;).
     */
    private static class CollectionElementCondition extends ColumnCondition
    {
        private final Term collectionElement;

        public CollectionElementCondition(ColumnMetadata column, Term collectionElement, Operator op, Terms values)
        {
<span class="nc" id="L147">            super(column, op, values);</span>
<span class="nc" id="L148">            this.collectionElement = collectionElement;</span>
<span class="nc" id="L149">        }</span>

        public void addFunctionsTo(List&lt;Function&gt; functions)
        {
<span class="nc" id="L153">            collectionElement.addFunctionsTo(functions);</span>
<span class="nc" id="L154">            super.addFunctionsTo(functions);</span>
<span class="nc" id="L155">        }</span>

        public void collectMarkerSpecification(VariableSpecifications boundNames)
        {
<span class="nc" id="L159">            collectionElement.collectMarkerSpecification(boundNames);</span>
<span class="nc" id="L160">            super.collectMarkerSpecification(boundNames);</span>
<span class="nc" id="L161">        }</span>

        public Bound bind(QueryOptions options)
        {
<span class="nc" id="L165">            return new ElementAccessBound(column, collectionElement.bindAndGet(options), operator, bindAndGetTerms(options));</span>
        }
    }

    /**
     *  A condition on a UDT field (e.g. &lt;pre&gt;IF v.a = 1&lt;/pre&gt;).
     */
<span class="nc" id="L172">    private final static class UDTFieldCondition extends ColumnCondition</span>
    {
        private final FieldIdentifier udtField;

        public UDTFieldCondition(ColumnMetadata column, FieldIdentifier udtField, Operator op, Terms values)
        {
<span class="nc" id="L178">            super(column, op, values);</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">            assert udtField != null;</span>
<span class="nc" id="L180">            this.udtField = udtField;</span>
<span class="nc" id="L181">        }</span>

        public Bound bind(QueryOptions options)
        {
<span class="nc" id="L185">            return new UDTFieldAccessBound(column, udtField, operator, bindAndGetTerms(options));</span>
        }
    }

    /**
     *  A regular column, simple condition.
     */
    public static ColumnCondition condition(ColumnMetadata column, Operator op, Terms terms)
    {
<span class="fc" id="L194">        return new SimpleColumnCondition(column, op, terms);</span>
    }

    /**
     * A collection column, simple condition.
     */
    public static ColumnCondition condition(ColumnMetadata column, Term collectionElement, Operator op, Terms terms)
    {
<span class="nc" id="L202">        return new CollectionElementCondition(column, collectionElement, op, terms);</span>
    }

    /**
     * A UDT column, simple condition.
     */
    public static ColumnCondition condition(ColumnMetadata column, FieldIdentifier udtField, Operator op, Terms terms)
    {
<span class="nc" id="L210">        return new UDTFieldCondition(column, udtField, op, terms);</span>
    }

    public static abstract class Bound
    {
        public final ColumnMetadata column;
        public final Operator comparisonOperator;

        protected Bound(ColumnMetadata column, Operator operator)
<span class="fc" id="L219">        {</span>
<span class="fc" id="L220">            this.column = column;</span>
            // If the operator is an IN we want to compare the value using an EQ.
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">            this.comparisonOperator = operator.isIN() ? Operator.EQ : operator;</span>
<span class="fc" id="L223">        }</span>

        /**
         * Validates whether this condition applies to {@code current}.
         */
        public abstract boolean appliesTo(Row row);

        public ByteBuffer getCollectionElementValue()
        {
<span class="fc" id="L232">            return null;</span>
        }

        /** Returns true if the operator is satisfied (i.e. &quot;otherValue operator value == true&quot;), false otherwise. */
        protected static boolean compareWithOperator(Operator operator, AbstractType&lt;?&gt; type, ByteBuffer value, ByteBuffer otherValue)
        {
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">            if (value == ByteBufferUtil.UNSET_BYTE_BUFFER)</span>
<span class="nc" id="L239">                throw invalidRequest(&quot;Invalid 'unset' value in condition&quot;);</span>

<span class="pc bpc" id="L241" title="1 of 2 branches missed.">            if (value == null)</span>
            {
<span class="nc bnc" id="L243" title="All 3 branches missed.">                switch (operator)</span>
                {
                    case EQ:
<span class="nc bnc" id="L246" title="All 2 branches missed.">                        return otherValue == null;</span>
                    case NEQ:
<span class="nc bnc" id="L248" title="All 2 branches missed.">                        return otherValue != null;</span>
                    default:
<span class="nc" id="L250">                        throw invalidRequest(&quot;Invalid comparison with null for operator \&quot;%s\&quot;&quot;, operator);</span>
                }
            }
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">            else if (otherValue == null)</span>
            {
                // the condition value is not null, so only NEQ can return true
<span class="nc bnc" id="L256" title="All 2 branches missed.">                return operator == Operator.NEQ;</span>
            }
<span class="fc" id="L258">            return operator.isSatisfiedBy(type, otherValue, value);</span>
        }
    }

    protected static final Cell&lt;?&gt; getCell(Row row, ColumnMetadata column)
    {
        // If we're asking for a given cell, and we didn't got any row from our read, it's
        // the same as not having said cell.
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">        return row == null ? null : row.getCell(column);</span>
    }

    protected static final Cell&lt;?&gt; getCell(Row row, ColumnMetadata column, CellPath path)
    {
        // If we're asking for a given cell, and we didn't got any row from our read, it's
        // the same as not having said cell.
<span class="nc bnc" id="L273" title="All 2 branches missed.">        return row == null ? null : row.getCell(column, path);</span>
    }

    protected static final Iterator&lt;Cell&lt;?&gt;&gt; getCells(Row row, ColumnMetadata column)
    {
        // If we're asking for a complex cells, and we didn't got any row from our read, it's
        // the same as not having any cells for that column.
<span class="nc bnc" id="L280" title="All 2 branches missed.">        if (row == null)</span>
<span class="nc" id="L281">            return Collections.emptyIterator();</span>

<span class="nc" id="L283">        ComplexColumnData complexData = row.getComplexColumnData(column);</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">        return complexData == null ? Collections.&lt;Cell&lt;?&gt;&gt;emptyIterator() : complexData.iterator();</span>
    }

    protected static final boolean evaluateComparisonWithOperator(int comparison, Operator operator)
    {
        // called when comparison != 0
<span class="nc bnc" id="L290" title="All 5 branches missed.">        switch (operator)</span>
        {
            case EQ:
<span class="nc" id="L293">                return false;</span>
            case LT:
            case LTE:
<span class="nc bnc" id="L296" title="All 2 branches missed.">                return comparison &lt; 0;</span>
            case GT:
            case GTE:
<span class="nc bnc" id="L299" title="All 2 branches missed.">                return comparison &gt; 0;</span>
            case NEQ:
<span class="nc" id="L301">                return true;</span>
            default:
<span class="nc" id="L303">                throw new AssertionError();</span>
        }
    }

    /**
     * A condition on a single non-collection column.
     */
    private static final class SimpleBound extends Bound
    {
        /**
         * The condition values
         */
        private final List&lt;ByteBuffer&gt; values;

        private SimpleBound(ColumnMetadata column, Operator operator, List&lt;ByteBuffer&gt; values)
        {
<span class="fc" id="L319">            super(column, operator);</span>
<span class="fc" id="L320">            this.values = values;</span>
<span class="fc" id="L321">        }</span>

        @Override
        public boolean appliesTo(Row row)
        {
<span class="fc" id="L326">            return isSatisfiedBy(rowValue(row));</span>
        }

        private ByteBuffer rowValue(Row row)
        {
<span class="fc" id="L331">            Cell&lt;?&gt; c = getCell(row, column);</span>
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">            return c == null ? null : c.buffer();</span>
        }

        private boolean isSatisfiedBy(ByteBuffer rowValue)
        {
<span class="fc bfc" id="L337" title="All 2 branches covered.">            for (ByteBuffer value : values)</span>
            {
<span class="fc bfc" id="L339" title="All 2 branches covered.">                if (compareWithOperator(comparisonOperator, column.type, value, rowValue))</span>
<span class="fc" id="L340">                    return true;</span>
<span class="fc" id="L341">            }</span>
<span class="fc" id="L342">            return false;</span>
        }
    }

    /**
     * A condition on an element of a collection column.
     */
    private static final class ElementAccessBound extends Bound
    {
        /**
         * The collection element
         */
        private final ByteBuffer collectionElement;

        /**
         * The conditions values.
         */
        private final List&lt;ByteBuffer&gt; values;

        private ElementAccessBound(ColumnMetadata column,
                                   ByteBuffer collectionElement,
                                   Operator operator,
                                   List&lt;ByteBuffer&gt; values)
        {
<span class="nc" id="L366">            super(column, operator);</span>

<span class="nc" id="L368">            this.collectionElement = collectionElement;</span>
<span class="nc" id="L369">            this.values = values;</span>
<span class="nc" id="L370">        }</span>

        @Override
        public boolean appliesTo(Row row)
        {
<span class="nc" id="L375">            boolean isMap = column.type instanceof MapType;</span>

<span class="nc bnc" id="L377" title="All 2 branches missed.">            if (collectionElement == null)</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">                throw invalidRequest(&quot;Invalid null value for %s element access&quot;, isMap ? &quot;map&quot; : &quot;list&quot;);</span>

<span class="nc bnc" id="L380" title="All 2 branches missed.">            if (isMap)</span>
            {
<span class="nc" id="L382">                MapType&lt;?, ?&gt; mapType = (MapType&lt;?, ?&gt;) column.type;</span>
<span class="nc" id="L383">                ByteBuffer rowValue = rowMapValue(mapType, row);</span>
<span class="nc" id="L384">                return isSatisfiedBy(mapType.getKeysType(), rowValue);</span>
            }

<span class="nc" id="L387">            ListType&lt;?&gt; listType = (ListType&lt;?&gt;) column.type;</span>
<span class="nc" id="L388">            ByteBuffer rowValue = rowListValue(listType, row);</span>
<span class="nc" id="L389">            return isSatisfiedBy(listType.getElementsType(), rowValue);</span>
        }

        private ByteBuffer rowMapValue(MapType&lt;?, ?&gt; type, Row row)
        {
<span class="nc bnc" id="L394" title="All 2 branches missed.">            if (column.type.isMultiCell())</span>
            {
<span class="nc" id="L396">                Cell&lt;?&gt; cell = getCell(row, column, CellPath.create(collectionElement));</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">                return cell == null ? null : cell.buffer();</span>
            }

<span class="nc" id="L400">            Cell&lt;?&gt; cell = getCell(row, column);</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">            return cell == null</span>
<span class="nc" id="L402">                    ? null</span>
<span class="nc" id="L403">                    : type.getSerializer().getSerializedValue(cell.buffer(), collectionElement, type.getKeysType());</span>
        }

        private ByteBuffer rowListValue(ListType&lt;?&gt; type, Row row)
        {
<span class="nc bnc" id="L408" title="All 2 branches missed.">            if (column.type.isMultiCell())</span>
<span class="nc" id="L409">                return cellValueAtIndex(getCells(row, column), getListIndex(collectionElement));</span>

<span class="nc" id="L411">            Cell&lt;?&gt; cell = getCell(row, column);</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">            return cell == null</span>
<span class="nc" id="L413">                    ? null</span>
<span class="nc" id="L414">                    : type.getSerializer().getElement(cell.buffer(), getListIndex(collectionElement));</span>
        }

        private static ByteBuffer cellValueAtIndex(Iterator&lt;Cell&lt;?&gt;&gt; iter, int index)
        {
<span class="nc" id="L419">            int adv = Iterators.advance(iter, index);</span>
<span class="nc bnc" id="L420" title="All 4 branches missed.">            if (adv == index &amp;&amp; iter.hasNext())</span>
<span class="nc" id="L421">                return iter.next().buffer();</span>

<span class="nc" id="L423">            return null;</span>
        }

        private boolean isSatisfiedBy(AbstractType&lt;?&gt; valueType, ByteBuffer rowValue)
        {
<span class="nc bnc" id="L428" title="All 2 branches missed.">            for (ByteBuffer value : values)</span>
            {
<span class="nc bnc" id="L430" title="All 2 branches missed.">                if (compareWithOperator(comparisonOperator, valueType, value, rowValue))</span>
<span class="nc" id="L431">                    return true;</span>
<span class="nc" id="L432">            }</span>
<span class="nc" id="L433">            return false;</span>
        }

        @Override
        public ByteBuffer getCollectionElementValue()
        {
<span class="nc" id="L439">            return collectionElement;</span>
        }

        private static int getListIndex(ByteBuffer collectionElement)
        {
<span class="nc" id="L444">            int idx = ByteBufferUtil.toInt(collectionElement);</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">            checkFalse(idx &lt; 0, &quot;Invalid negative list index %d&quot;, idx);</span>
<span class="nc" id="L446">            return idx;</span>
        }
    }

    /**
     * A condition on an entire collection column.
     */
<span class="nc" id="L453">    private static final class MultiCellCollectionBound extends Bound</span>
    {
        private final List&lt;Term.Terminal&gt; values;

        public MultiCellCollectionBound(ColumnMetadata column, Operator operator, List&lt;Term.Terminal&gt; values)
        {
<span class="nc" id="L459">            super(column, operator);</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">            assert column.type.isMultiCell();</span>
<span class="nc" id="L461">            this.values = values;</span>
<span class="nc" id="L462">        }</span>

        public boolean appliesTo(Row row)
        {
<span class="nc" id="L466">            CollectionType&lt;?&gt; type = (CollectionType&lt;?&gt;)column.type;</span>

            // copy iterator contents so that we can properly reuse them for each comparison with an IN value
<span class="nc bnc" id="L469" title="All 2 branches missed.">            for (Term.Terminal value : values)</span>
            {
<span class="nc" id="L471">                Iterator&lt;Cell&lt;?&gt;&gt; iter = getCells(row, column);</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">                if (value == null)</span>
                {
<span class="nc bnc" id="L474" title="All 2 branches missed.">                    if (comparisonOperator == Operator.EQ)</span>
                    {
<span class="nc bnc" id="L476" title="All 2 branches missed.">                        if (!iter.hasNext())</span>
<span class="nc" id="L477">                            return true;</span>
                        continue;
                    }

<span class="nc bnc" id="L481" title="All 2 branches missed.">                    if (comparisonOperator == Operator.NEQ)</span>
<span class="nc" id="L482">                        return iter.hasNext();</span>

<span class="nc" id="L484">                    throw invalidRequest(&quot;Invalid comparison with null for operator \&quot;%s\&quot;&quot;, comparisonOperator);</span>
                }

<span class="nc bnc" id="L487" title="All 2 branches missed.">                if (valueAppliesTo(type, iter, value, comparisonOperator))</span>
<span class="nc" id="L488">                    return true;</span>
<span class="nc" id="L489">            }</span>
<span class="nc" id="L490">            return false;</span>
        }

        private static boolean valueAppliesTo(CollectionType&lt;?&gt; type, Iterator&lt;Cell&lt;?&gt;&gt; iter, Term.Terminal value, Operator operator)
        {
<span class="nc bnc" id="L495" title="All 2 branches missed.">            if (value == null)</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">                return !iter.hasNext();</span>

<span class="nc bnc" id="L498" title="All 4 branches missed.">            if(operator.isContains() || operator.isContainsKey())</span>
<span class="nc" id="L499">                return containsAppliesTo(type, iter, value.get(ProtocolVersion.CURRENT), operator);</span>

<span class="nc bnc" id="L501" title="All 4 branches missed.">            switch (type.kind)</span>
            {
                case LIST:
<span class="nc" id="L504">                    List&lt;ByteBuffer&gt; valueList = ((Lists.Value) value).elements;</span>
<span class="nc" id="L505">                    return listAppliesTo((ListType&lt;?&gt;)type, iter, valueList, operator);</span>
                case SET:
<span class="nc" id="L507">                    Set&lt;ByteBuffer&gt; valueSet = ((Sets.Value) value).elements;</span>
<span class="nc" id="L508">                    return setAppliesTo((SetType&lt;?&gt;)type, iter, valueSet, operator);</span>
                case MAP:
<span class="nc" id="L510">                    Map&lt;ByteBuffer, ByteBuffer&gt; valueMap = ((Maps.Value) value).map;</span>
<span class="nc" id="L511">                    return mapAppliesTo((MapType&lt;?, ?&gt;)type, iter, valueMap, operator);</span>
            }
<span class="nc" id="L513">            throw new AssertionError();</span>
        }

        private static boolean setOrListAppliesTo(AbstractType&lt;?&gt; type, Iterator&lt;Cell&lt;?&gt;&gt; iter, Iterator&lt;ByteBuffer&gt; conditionIter, Operator operator, boolean isSet)
        {
<span class="nc bnc" id="L518" title="All 2 branches missed.">            while(iter.hasNext())</span>
            {
<span class="nc bnc" id="L520" title="All 2 branches missed.">                if (!conditionIter.hasNext())</span>
<span class="nc bnc" id="L521" title="All 6 branches missed.">                    return (operator == Operator.GT) || (operator == Operator.GTE) || (operator == Operator.NEQ);</span>

                // for lists we use the cell value; for sets we use the cell name
<span class="nc bnc" id="L524" title="All 2 branches missed.">                ByteBuffer cellValue = isSet ? iter.next().path().get(0) : iter.next().buffer();</span>
<span class="nc" id="L525">                int comparison = type.compare(cellValue, conditionIter.next());</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">                if (comparison != 0)</span>
<span class="nc" id="L527">                    return evaluateComparisonWithOperator(comparison, operator);</span>
<span class="nc" id="L528">            }</span>

<span class="nc bnc" id="L530" title="All 2 branches missed.">            if (conditionIter.hasNext())</span>
<span class="nc bnc" id="L531" title="All 6 branches missed.">                return (operator == Operator.LT) || (operator == Operator.LTE) || (operator == Operator.NEQ);</span>

            // they're equal
<span class="nc bnc" id="L534" title="All 6 branches missed.">            return operator == Operator.EQ || operator == Operator.LTE || operator == Operator.GTE;</span>
        }

        private static boolean listAppliesTo(ListType&lt;?&gt; type, Iterator&lt;Cell&lt;?&gt;&gt; iter, List&lt;ByteBuffer&gt; elements, Operator operator)
        {
<span class="nc" id="L539">            return setOrListAppliesTo(type.getElementsType(), iter, elements.iterator(), operator, false);</span>
        }

        private static boolean setAppliesTo(SetType&lt;?&gt; type, Iterator&lt;Cell&lt;?&gt;&gt; iter, Set&lt;ByteBuffer&gt; elements, Operator operator)
        {
<span class="nc" id="L544">            ArrayList&lt;ByteBuffer&gt; sortedElements = new ArrayList&lt;&gt;(elements);</span>
<span class="nc" id="L545">            Collections.sort(sortedElements, type.getElementsType());</span>
<span class="nc" id="L546">            return setOrListAppliesTo(type.getElementsType(), iter, sortedElements.iterator(), operator, true);</span>
        }

        private static boolean mapAppliesTo(MapType&lt;?, ?&gt; type, Iterator&lt;Cell&lt;?&gt;&gt; iter, Map&lt;ByteBuffer, ByteBuffer&gt; elements, Operator operator)
        {
<span class="nc" id="L551">            Iterator&lt;Map.Entry&lt;ByteBuffer, ByteBuffer&gt;&gt; conditionIter = elements.entrySet().iterator();</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">            while(iter.hasNext())</span>
            {
<span class="nc bnc" id="L554" title="All 2 branches missed.">                if (!conditionIter.hasNext())</span>
<span class="nc bnc" id="L555" title="All 6 branches missed.">                    return (operator == Operator.GT) || (operator == Operator.GTE) || (operator == Operator.NEQ);</span>

<span class="nc" id="L557">                Map.Entry&lt;ByteBuffer, ByteBuffer&gt; conditionEntry = conditionIter.next();</span>
<span class="nc" id="L558">                Cell&lt;?&gt; c = iter.next();</span>

                // compare the keys
<span class="nc" id="L561">                int comparison = type.getKeysType().compare(c.path().get(0), conditionEntry.getKey());</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">                if (comparison != 0)</span>
<span class="nc" id="L563">                    return evaluateComparisonWithOperator(comparison, operator);</span>

                // compare the values
<span class="nc" id="L566">                comparison = type.getValuesType().compare(c.buffer(), conditionEntry.getValue());</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">                if (comparison != 0)</span>
<span class="nc" id="L568">                    return evaluateComparisonWithOperator(comparison, operator);</span>
<span class="nc" id="L569">            }</span>

<span class="nc bnc" id="L571" title="All 2 branches missed.">            if (conditionIter.hasNext())</span>
<span class="nc bnc" id="L572" title="All 6 branches missed.">                return (operator == Operator.LT) || (operator == Operator.LTE) || (operator == Operator.NEQ);</span>

            // they're equal
<span class="nc bnc" id="L575" title="All 6 branches missed.">            return operator == Operator.EQ || operator == Operator.LTE || operator == Operator.GTE;</span>
        }
    }

    private static boolean containsAppliesTo(CollectionType&lt;?&gt; type, Iterator&lt;Cell&lt;?&gt;&gt; iter, ByteBuffer value, Operator operator)
    {
        AbstractType&lt;?&gt; compareType;
<span class="nc bnc" id="L582" title="All 4 branches missed.">        switch (type.kind)</span>
        {
            case LIST:
<span class="nc" id="L585">                compareType = ((ListType&lt;?&gt;)type).getElementsType();</span>
<span class="nc" id="L586">                break;</span>
            case SET:
<span class="nc" id="L588">                compareType = ((SetType&lt;?&gt;)type).getElementsType();</span>
<span class="nc" id="L589">                break;</span>
            case MAP:
<span class="nc bnc" id="L591" title="All 2 branches missed.">                compareType = operator.isContainsKey() ? ((MapType&lt;?, ?&gt;)type).getKeysType() : ((MapType&lt;?, ?&gt;)type).getValuesType();</span>
<span class="nc" id="L592">                break;</span>
            default:
<span class="nc" id="L594">                throw new AssertionError();</span>
        }
<span class="nc bnc" id="L596" title="All 6 branches missed.">        boolean appliesToSetOrMapKeys = (type.kind == CollectionType.Kind.SET || type.kind == CollectionType.Kind.MAP &amp;&amp; operator.isContainsKey());</span>
<span class="nc" id="L597">        return containsAppliesTo(compareType, iter, value, appliesToSetOrMapKeys);</span>
    }

    private static boolean containsAppliesTo(AbstractType&lt;?&gt; type, Iterator&lt;Cell&lt;?&gt;&gt; iter, ByteBuffer value, Boolean appliesToSetOrMapKeys)
    {
<span class="nc bnc" id="L602" title="All 2 branches missed.">        while(iter.hasNext())</span>
        {
            // for lists and map values we use the cell value; for sets and map keys we use the cell name
<span class="nc bnc" id="L605" title="All 2 branches missed.">            ByteBuffer cellValue = appliesToSetOrMapKeys ? iter.next().path().get(0) : iter.next().buffer();</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">            if(type.compare(cellValue, value) == 0)</span>
<span class="nc" id="L607">                return true;</span>
<span class="nc" id="L608">        }</span>
<span class="nc" id="L609">        return false;</span>
    }

    /**
     * A condition on a UDT field
     */
<span class="nc" id="L615">    private static final class UDTFieldAccessBound extends Bound</span>
    {
        /**
         * The UDT field.
         */
        private final FieldIdentifier field;

        /**
         * The conditions values.
         */
        private final List&lt;ByteBuffer&gt; values;

        private UDTFieldAccessBound(ColumnMetadata column, FieldIdentifier field, Operator operator, List&lt;ByteBuffer&gt; values)
        {
<span class="nc" id="L629">            super(column, operator);</span>
<span class="nc bnc" id="L630" title="All 4 branches missed.">            assert column.type.isUDT() &amp;&amp; field != null;</span>
<span class="nc" id="L631">            this.field = field;</span>
<span class="nc" id="L632">            this.values = values;</span>
<span class="nc" id="L633">        }</span>

        @Override
        public boolean appliesTo(Row row)
        {
<span class="nc" id="L638">            return isSatisfiedBy(rowValue(row));</span>
        }

        private ByteBuffer rowValue(Row row)
        {
<span class="nc" id="L643">            UserType userType = (UserType) column.type;</span>

<span class="nc bnc" id="L645" title="All 2 branches missed.">            if (column.type.isMultiCell())</span>
            {
<span class="nc" id="L647">                Cell&lt;?&gt; cell = getCell(row, column, userType.cellPathForField(field));</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">                return cell == null ? null : cell.buffer();</span>
            }

<span class="nc" id="L651">            Cell&lt;?&gt; cell = getCell(row, column);</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">            return cell == null</span>
<span class="nc" id="L653">                   ? null</span>
<span class="nc" id="L654">                   : userType.split(ByteBufferAccessor.instance, cell.buffer())[userType.fieldPosition(field)];</span>
        }

        private boolean isSatisfiedBy(ByteBuffer rowValue)
        {
<span class="nc" id="L659">            UserType userType = (UserType) column.type;</span>
<span class="nc" id="L660">            int fieldPosition = userType.fieldPosition(field);</span>
<span class="nc" id="L661">            AbstractType&lt;?&gt; valueType = userType.fieldType(fieldPosition);</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">            for (ByteBuffer value : values)</span>
            {
<span class="nc bnc" id="L664" title="All 2 branches missed.">                if (compareWithOperator(comparisonOperator, valueType, value, rowValue))</span>
<span class="nc" id="L665">                    return true;</span>
<span class="nc" id="L666">            }</span>
<span class="nc" id="L667">            return false;</span>
        }
        
        @Override
        public String toString()
        {
<span class="nc" id="L673">            return ToStringBuilder.reflectionToString(this, ToStringStyle.SHORT_PREFIX_STYLE);</span>
        }
    }

    /**
     * A condition on an entire UDT.
     */
<span class="nc" id="L680">    private static final class MultiCellUdtBound extends Bound</span>
    {
        /**
         * The conditions values.
         */
        private final List&lt;ByteBuffer&gt; values;

        /**
         * The protocol version
         */
        private final ProtocolVersion protocolVersion;

        private MultiCellUdtBound(ColumnMetadata column, Operator op, List&lt;ByteBuffer&gt; values, ProtocolVersion protocolVersion)
        {
<span class="nc" id="L694">            super(column, op);</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">            assert column.type.isMultiCell();</span>
<span class="nc" id="L696">            this.values = values;</span>
<span class="nc" id="L697">            this.protocolVersion = protocolVersion;</span>
<span class="nc" id="L698">        }</span>

        @Override
        public boolean appliesTo(Row row)
        {
<span class="nc" id="L703">            return isSatisfiedBy(rowValue(row));</span>
        }

        private final ByteBuffer rowValue(Row row)
        {
<span class="nc" id="L708">            UserType userType = (UserType) column.type;</span>
<span class="nc" id="L709">            Iterator&lt;Cell&lt;?&gt;&gt; iter = getCells(row, column);</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">            return iter.hasNext() ? userType.serializeForNativeProtocol(iter, protocolVersion) : null;</span>
        }

        private boolean isSatisfiedBy(ByteBuffer rowValue)
        {
<span class="nc bnc" id="L715" title="All 2 branches missed.">            for (ByteBuffer value : values)</span>
            {
<span class="nc bnc" id="L717" title="All 2 branches missed.">                if (compareWithOperator(comparisonOperator, column.type, value, rowValue))</span>
<span class="nc" id="L718">                    return true;</span>
<span class="nc" id="L719">            }</span>
<span class="nc" id="L720">            return false;</span>
        }
        
        @Override
        public String toString()
        {
<span class="nc" id="L726">            return ToStringBuilder.reflectionToString(this, ToStringStyle.SHORT_PREFIX_STYLE);</span>
        }
    }

    public static class Raw
    {
        private final Term.Raw value;
        private final List&lt;Term.Raw&gt; inValues;
        private final AbstractMarker.INRaw inMarker;

        // Can be null, only used with the syntax &quot;IF m[e] = ...&quot; (in which case it's 'e')
        private final Term.Raw collectionElement;

        // Can be null, only used with the syntax &quot;IF udt.field = ...&quot; (in which case it's 'field')
        private final FieldIdentifier udtField;

        private final Operator operator;

        private Raw(Term.Raw value, List&lt;Term.Raw&gt; inValues, AbstractMarker.INRaw inMarker, Term.Raw collectionElement,
                    FieldIdentifier udtField, Operator op)
<span class="fc" id="L746">        {</span>
<span class="fc" id="L747">            this.value = value;</span>
<span class="fc" id="L748">            this.inValues = inValues;</span>
<span class="fc" id="L749">            this.inMarker = inMarker;</span>
<span class="fc" id="L750">            this.collectionElement = collectionElement;</span>
<span class="fc" id="L751">            this.udtField = udtField;</span>
<span class="fc" id="L752">            this.operator = op;</span>
<span class="fc" id="L753">        }</span>

        /** A condition on a column. For example: &quot;IF col = 'foo'&quot; */
        public static Raw simpleCondition(Term.Raw value, Operator op)
        {
<span class="fc" id="L758">            return new Raw(value, null, null, null, null, op);</span>
        }

        /** An IN condition on a column. For example: &quot;IF col IN ('foo', 'bar', ...)&quot; */
        public static Raw simpleInCondition(List&lt;Term.Raw&gt; inValues)
        {
<span class="nc" id="L764">            return new Raw(null, inValues, null, null, null, Operator.IN);</span>
        }

        /** An IN condition on a column with a single marker. For example: &quot;IF col IN ?&quot; */
        public static Raw simpleInCondition(AbstractMarker.INRaw inMarker)
        {
<span class="nc" id="L770">            return new Raw(null, null, inMarker, null, null, Operator.IN);</span>
        }

        /** A condition on a collection element. For example: &quot;IF col['key'] = 'foo'&quot; */
        public static Raw collectionCondition(Term.Raw value, Term.Raw collectionElement, Operator op)
        {
<span class="nc" id="L776">            return new Raw(value, null, null, collectionElement, null, op);</span>
        }

        /** An IN condition on a collection element. For example: &quot;IF col['key'] IN ('foo', 'bar', ...)&quot; */
        public static Raw collectionInCondition(Term.Raw collectionElement, List&lt;Term.Raw&gt; inValues)
        {
<span class="nc" id="L782">            return new Raw(null, inValues, null, collectionElement, null, Operator.IN);</span>
        }

        /** An IN condition on a collection element with a single marker. For example: &quot;IF col['key'] IN ?&quot; */
        public static Raw collectionInCondition(Term.Raw collectionElement, AbstractMarker.INRaw inMarker)
        {
<span class="nc" id="L788">            return new Raw(null, null, inMarker, collectionElement, null, Operator.IN);</span>
        }

        /** A condition on a UDT field. For example: &quot;IF col.field = 'foo'&quot; */
        public static Raw udtFieldCondition(Term.Raw value, FieldIdentifier udtField, Operator op)
        {
<span class="nc" id="L794">            return new Raw(value, null, null, null, udtField, op);</span>
        }

        /** An IN condition on a collection element. For example: &quot;IF col.field IN ('foo', 'bar', ...)&quot; */
        public static Raw udtFieldInCondition(FieldIdentifier udtField, List&lt;Term.Raw&gt; inValues)
        {
<span class="nc" id="L800">            return new Raw(null, inValues, null, null, udtField, Operator.IN);</span>
        }

        /** An IN condition on a collection element with a single marker. For example: &quot;IF col.field IN ?&quot; */
        public static Raw udtFieldInCondition(FieldIdentifier udtField, AbstractMarker.INRaw inMarker)
        {
<span class="nc" id="L806">            return new Raw(null, null, inMarker, null, udtField, Operator.IN);</span>
        }

        public ColumnCondition prepare(String keyspace, ColumnMetadata receiver, TableMetadata cfm)
        {
<span class="pc bpc" id="L811" title="1 of 2 branches missed.">            if (receiver.type instanceof CounterColumnType)</span>
<span class="nc" id="L812">                throw invalidRequest(&quot;Conditions on counters are not supported&quot;);</span>

<span class="pc bpc" id="L814" title="1 of 2 branches missed.">            if (collectionElement != null)</span>
            {
<span class="nc bnc" id="L816" title="All 2 branches missed.">                if (!(receiver.type.isCollection()))</span>
<span class="nc" id="L817">                    throw invalidRequest(&quot;Invalid element access syntax for non-collection column %s&quot;, receiver.name);</span>

                ColumnSpecification elementSpec, valueSpec;
<span class="nc bnc" id="L820" title="All 4 branches missed.">                switch ((((CollectionType&lt;?&gt;) receiver.type).kind))</span>
                {
                    case LIST:
<span class="nc" id="L823">                        elementSpec = Lists.indexSpecOf(receiver);</span>
<span class="nc" id="L824">                        valueSpec = Lists.valueSpecOf(receiver);</span>
<span class="nc" id="L825">                        break;</span>
                    case MAP:
<span class="nc" id="L827">                        elementSpec = Maps.keySpecOf(receiver);</span>
<span class="nc" id="L828">                        valueSpec = Maps.valueSpecOf(receiver);</span>
<span class="nc" id="L829">                        break;</span>
                    case SET:
<span class="nc" id="L831">                        throw invalidRequest(&quot;Invalid element access syntax for set column %s&quot;, receiver.name);</span>
                    default:
<span class="nc" id="L833">                        throw new AssertionError();</span>
                }

<span class="nc" id="L836">                validateOperationOnDurations(valueSpec.type);</span>
<span class="nc" id="L837">                return condition(receiver, collectionElement.prepare(keyspace, elementSpec), operator, prepareTerms(keyspace, valueSpec));</span>
            }

<span class="pc bpc" id="L840" title="1 of 2 branches missed.">            if (udtField != null)</span>
            {
<span class="nc" id="L842">                UserType userType = (UserType) receiver.type;</span>
<span class="nc" id="L843">                int fieldPosition = userType.fieldPosition(udtField);</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">                if (fieldPosition == -1)</span>
<span class="nc" id="L845">                    throw invalidRequest(&quot;Unknown field %s for column %s&quot;, udtField, receiver.name);</span>

<span class="nc" id="L847">                ColumnSpecification fieldReceiver = UserTypes.fieldSpecOf(receiver, fieldPosition);</span>
<span class="nc" id="L848">                validateOperationOnDurations(fieldReceiver.type);</span>
<span class="nc" id="L849">                return condition(receiver, udtField, operator, prepareTerms(keyspace, fieldReceiver));</span>
            }

<span class="fc" id="L852">            validateOperationOnDurations(receiver.type);</span>
<span class="fc" id="L853">            return condition(receiver, operator, prepareTerms(keyspace, receiver));</span>
        }

        private Terms prepareTerms(String keyspace, ColumnSpecification receiver)
        {
<span class="pc bpc" id="L858" title="3 of 4 branches missed.">            checkFalse(operator.isContainsKey() &amp;&amp; !(receiver.type instanceof MapType), &quot;Cannot use CONTAINS KEY on non-map column %s&quot;, receiver.name);</span>
<span class="pc bpc" id="L859" title="3 of 4 branches missed.">            checkFalse(operator.isContains() &amp;&amp; !(receiver.type.isCollection()), &quot;Cannot use CONTAINS on non-collection column %s&quot;, receiver.name);</span>

<span class="pc bpc" id="L861" title="1 of 2 branches missed.">            if (operator.isIN())</span>
            {
<span class="nc bnc" id="L863" title="All 2 branches missed.">                return inValues == null ? Terms.ofListMarker(inMarker.prepare(keyspace, receiver), receiver.type)</span>
<span class="nc" id="L864">                                        : Terms.of(prepareTerms(keyspace, receiver, inValues));</span>
            }

<span class="pc bpc" id="L867" title="2 of 4 branches missed.">            if (operator.isContains() || operator.isContainsKey())</span>
<span class="nc" id="L868">                receiver = ((CollectionType&lt;?&gt;) receiver.type).makeCollectionReceiver(receiver, operator.isContainsKey());</span>

<span class="fc" id="L870">            return Terms.of(value.prepare(keyspace, receiver));</span>
        }

        private static List&lt;Term&gt; prepareTerms(String keyspace, ColumnSpecification receiver, List&lt;Term.Raw&gt; raws)
        {
<span class="nc" id="L875">            List&lt;Term&gt; terms = new ArrayList&lt;&gt;(raws.size());</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">            for (int i = 0, m = raws.size(); i &lt; m; i++)</span>
            {
<span class="nc" id="L878">                Term.Raw raw = raws.get(i);</span>
<span class="nc" id="L879">                terms.add(raw.prepare(keyspace, receiver));</span>
            }
<span class="nc" id="L881">            return terms;</span>
        }

        private void validateOperationOnDurations(AbstractType&lt;?&gt; type)
        {
<span class="pc bpc" id="L886" title="3 of 4 branches missed.">            if (type.referencesDuration() &amp;&amp; operator.isSlice())</span>
            {
<span class="nc" id="L888">                checkFalse(type.isCollection(), &quot;Slice conditions are not supported on collections containing durations&quot;);</span>
<span class="nc" id="L889">                checkFalse(type.isTuple(), &quot;Slice conditions are not supported on tuples containing durations&quot;);</span>
<span class="nc" id="L890">                checkFalse(type.isUDT(), &quot;Slice conditions are not supported on UDTs containing durations&quot;);</span>
<span class="nc" id="L891">                throw invalidRequest(&quot;Slice conditions ( %s ) are not supported on durations&quot;, operator);</span>
            }
<span class="fc" id="L893">        }</span>

        public Term.Raw getValue()
        {
<span class="nc" id="L897">            return value;</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L903">            return ToStringBuilder.reflectionToString(this, ToStringStyle.SHORT_PREFIX_STYLE);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>