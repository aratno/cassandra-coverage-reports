<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NodeProbe.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.tools</a> &gt; <span class="el_source">NodeProbe.java</span></div><h1>NodeProbe.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.tools;

import java.io.IOException;
import java.io.PrintStream;
import java.lang.management.ManagementFactory;
import java.lang.management.MemoryMXBean;
import java.lang.management.MemoryUsage;
import java.lang.management.RuntimeMXBean;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.rmi.ConnectException;
import java.rmi.server.RMIClientSocketFactory;
import java.rmi.server.RMISocketFactory;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import javax.annotation.Nullable;
import javax.management.JMX;
import javax.management.MBeanServerConnection;
import javax.management.MalformedObjectNameException;
import javax.management.ObjectName;
import javax.management.openmbean.CompositeData;
import javax.management.openmbean.OpenDataException;
import javax.management.openmbean.TabularData;
import javax.management.remote.JMXConnector;
import javax.management.remote.JMXConnectorFactory;
import javax.management.remote.JMXServiceURL;
import javax.rmi.ssl.SslRMIClientSocketFactory;

import org.apache.cassandra.audit.AuditLogManager;
import org.apache.cassandra.audit.AuditLogManagerMBean;
import org.apache.cassandra.audit.AuditLogOptions;
import org.apache.cassandra.audit.AuditLogOptionsCompositeData;

import com.google.common.collect.ImmutableMap;
import org.apache.cassandra.auth.AuthCache;
import org.apache.cassandra.auth.AuthCacheMBean;
import org.apache.cassandra.auth.CIDRGroupsMappingManager;
import org.apache.cassandra.auth.CIDRGroupsMappingManagerMBean;
import org.apache.cassandra.auth.CIDRPermissionsManager;
import org.apache.cassandra.auth.CIDRPermissionsManagerMBean;
import org.apache.cassandra.auth.NetworkPermissionsCache;
import org.apache.cassandra.auth.NetworkPermissionsCacheMBean;
import org.apache.cassandra.auth.PasswordAuthenticator;
import org.apache.cassandra.auth.PermissionsCache;
import org.apache.cassandra.auth.PermissionsCacheMBean;
import org.apache.cassandra.auth.RolesCache;
import org.apache.cassandra.auth.RolesCacheMBean;
import org.apache.cassandra.auth.jmx.AuthorizationProxy;
import org.apache.cassandra.batchlog.BatchlogManager;
import org.apache.cassandra.batchlog.BatchlogManagerMBean;
import org.apache.cassandra.db.ColumnFamilyStoreMBean;
import org.apache.cassandra.db.compaction.CompactionManager;
import org.apache.cassandra.db.compaction.CompactionManagerMBean;
import org.apache.cassandra.db.virtual.CIDRFilteringMetricsTable;
import org.apache.cassandra.db.virtual.CIDRFilteringMetricsTableMBean;
import org.apache.cassandra.fql.FullQueryLoggerOptions;
import org.apache.cassandra.fql.FullQueryLoggerOptionsCompositeData;
import org.apache.cassandra.gms.FailureDetector;
import org.apache.cassandra.gms.FailureDetectorMBean;
import org.apache.cassandra.gms.Gossiper;
import org.apache.cassandra.gms.GossiperMBean;
import org.apache.cassandra.hints.HintsService;
import org.apache.cassandra.hints.HintsServiceMBean;
import org.apache.cassandra.locator.DynamicEndpointSnitchMBean;
import org.apache.cassandra.locator.EndpointSnitchInfoMBean;
import org.apache.cassandra.metrics.CIDRAuthorizerMetrics;
import org.apache.cassandra.metrics.CassandraMetricsRegistry;
import org.apache.cassandra.metrics.StorageMetrics;
import org.apache.cassandra.metrics.TableMetrics;
import org.apache.cassandra.metrics.ThreadPoolMetrics;
import org.apache.cassandra.net.MessagingService;
import org.apache.cassandra.net.MessagingServiceMBean;
import org.apache.cassandra.service.ActiveRepairServiceMBean;
import org.apache.cassandra.service.CacheService;
import org.apache.cassandra.service.CacheServiceMBean;
import org.apache.cassandra.service.GCInspector;
import org.apache.cassandra.service.GCInspectorMXBean;
import org.apache.cassandra.service.StorageProxy;
import org.apache.cassandra.service.StorageProxyMBean;
import org.apache.cassandra.service.StorageServiceMBean;
import org.apache.cassandra.streaming.StreamManagerMBean;
import org.apache.cassandra.streaming.StreamState;
import org.apache.cassandra.streaming.management.StreamStateCompositeData;
import org.apache.cassandra.tools.nodetool.formatter.TableBuilder;

import com.codahale.metrics.JmxReporter;
import com.google.common.base.Function;
import com.google.common.base.Strings;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.Iterables;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;
import com.google.common.collect.Sets;
import com.google.common.util.concurrent.Uninterruptibles;
import org.apache.cassandra.tools.nodetool.GetTimeout;
import org.apache.cassandra.utils.NativeLibrary;

import static org.apache.cassandra.config.CassandraRelevantProperties.NODETOOL_JMX_NOTIFICATION_POLL_INTERVAL_SECONDS;
import static org.apache.cassandra.config.CassandraRelevantProperties.SSL_ENABLE;

/**
 * JMX client operations for Cassandra.
 */
public class NodeProbe implements AutoCloseable
{
    private static final String fmtUrl = &quot;service:jmx:rmi:///jndi/rmi://%s:%d/jmxrmi&quot;;
    private static final String ssObjName = &quot;org.apache.cassandra.db:type=StorageService&quot;;
    private static final int defaultPort = 7199;

<span class="fc" id="L139">    static long JMX_NOTIFICATION_POLL_INTERVAL_SECONDS = NODETOOL_JMX_NOTIFICATION_POLL_INTERVAL_SECONDS.getLong();</span>

    final String host;
    final int port;
    private String username;
    private String password;


    protected JMXConnector jmxc;
    protected MBeanServerConnection mbeanServerConn;
    protected CompactionManagerMBean compactionProxy;
    protected StorageServiceMBean ssProxy;
    protected GossiperMBean gossProxy;
    protected MemoryMXBean memProxy;
    protected GCInspectorMXBean gcProxy;
    protected RuntimeMXBean runtimeProxy;
    protected StreamManagerMBean streamProxy;
    protected MessagingServiceMBean msProxy;
    protected FailureDetectorMBean fdProxy;
    protected CacheServiceMBean cacheService;
    protected StorageProxyMBean spProxy;
    protected HintsServiceMBean hsProxy;
    protected BatchlogManagerMBean bmProxy;
    protected ActiveRepairServiceMBean arsProxy;
    protected AuditLogManagerMBean almProxy;
    protected PasswordAuthenticator.CredentialsCacheMBean ccProxy;
    protected AuthorizationProxy.JmxPermissionsCacheMBean jpcProxy;
    protected NetworkPermissionsCacheMBean npcProxy;
    protected CIDRPermissionsManagerMBean cpbProxy;
    protected CIDRGroupsMappingManagerMBean cmbProxy;
    protected PermissionsCacheMBean pcProxy;
    protected RolesCacheMBean rcProxy;
    protected Output output;
    private boolean failed;

    protected CIDRFilteringMetricsTableMBean cfmProxy;

    /**
     * Creates a NodeProbe using the specified JMX host, port, username, and password.
     *
     * @param host hostname or IP address of the JMX agent
     * @param port TCP port of the remote JMX agent
     * @throws IOException on connection failures
     */
    public NodeProbe(String host, int port, String username, String password) throws IOException
<span class="nc" id="L184">    {</span>
<span class="nc bnc" id="L185" title="All 8 branches missed.">        assert username != null &amp;&amp; !username.isEmpty() &amp;&amp; password != null &amp;&amp; !password.isEmpty()</span>
               : &quot;neither username nor password can be blank&quot;;

<span class="nc" id="L188">        this.host = host;</span>
<span class="nc" id="L189">        this.port = port;</span>
<span class="nc" id="L190">        this.username = username;</span>
<span class="nc" id="L191">        this.password = password;</span>
<span class="nc" id="L192">        this.output = Output.CONSOLE;</span>
<span class="nc" id="L193">        connect();</span>
<span class="nc" id="L194">    }</span>

    /**
     * Creates a NodeProbe using the specified JMX host and port.
     *
     * @param host hostname or IP address of the JMX agent
     * @param port TCP port of the remote JMX agent
     * @throws IOException on connection failures
     */
    public NodeProbe(String host, int port) throws IOException
<span class="fc" id="L204">    {</span>
<span class="fc" id="L205">        this.host = host;</span>
<span class="fc" id="L206">        this.port = port;</span>
<span class="fc" id="L207">        this.output = Output.CONSOLE;</span>
<span class="fc" id="L208">        connect();</span>
<span class="fc" id="L209">    }</span>

    /**
     * Creates a NodeProbe using the specified JMX host and default port.
     *
     * @param host hostname or IP address of the JMX agent
     * @throws IOException on connection failures
     */
    public NodeProbe(String host) throws IOException
<span class="nc" id="L218">    {</span>
<span class="nc" id="L219">        this.host = host;</span>
<span class="nc" id="L220">        this.port = defaultPort;</span>
<span class="nc" id="L221">        this.output = Output.CONSOLE;</span>
<span class="nc" id="L222">        connect();</span>
<span class="nc" id="L223">    }</span>

    protected NodeProbe()
<span class="nc" id="L226">    {</span>
        // this constructor is only used for extensions to rewrite their own connect method
<span class="nc" id="L228">        this.host = &quot;&quot;;</span>
<span class="nc" id="L229">        this.port = 0;</span>
<span class="nc" id="L230">        this.output = Output.CONSOLE;</span>
<span class="nc" id="L231">    }</span>

    /**
     * Create a connection to the JMX agent and setup the M[X]Bean proxies.
     *
     * @throws IOException on connection failures
     */
    protected void connect() throws IOException
    {
<span class="fc" id="L240">        String host = this.host;</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">        if (host.contains(&quot;:&quot;))</span>
        {
            // Use square brackets to surround IPv6 addresses to fix CASSANDRA-7669 and CASSANDRA-17581
<span class="nc" id="L244">            host = &quot;[&quot; + host + &quot;]&quot;;</span>
        }
<span class="fc" id="L246">        JMXServiceURL jmxUrl = new JMXServiceURL(String.format(fmtUrl, host, port));</span>
<span class="fc" id="L247">        Map&lt;String, Object&gt; env = new HashMap&lt;String, Object&gt;();</span>
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        if (username != null)</span>
        {
<span class="nc" id="L250">            String[] creds = { username, password };</span>
<span class="nc" id="L251">            env.put(JMXConnector.CREDENTIALS, creds);</span>
        }

<span class="fc" id="L254">        env.put(&quot;com.sun.jndi.rmi.factory.socket&quot;, getRMIClientSocketFactory());</span>

<span class="fc" id="L256">        jmxc = JMXConnectorFactory.connect(jmxUrl, env);</span>
<span class="fc" id="L257">        mbeanServerConn = jmxc.getMBeanServerConnection();</span>

        try
        {
<span class="fc" id="L261">            ObjectName name = new ObjectName(ssObjName);</span>
<span class="fc" id="L262">            ssProxy = JMX.newMBeanProxy(mbeanServerConn, name, StorageServiceMBean.class);</span>
<span class="fc" id="L263">            name = new ObjectName(MessagingService.MBEAN_NAME);</span>
<span class="fc" id="L264">            msProxy = JMX.newMBeanProxy(mbeanServerConn, name, MessagingServiceMBean.class);</span>
<span class="fc" id="L265">            name = new ObjectName(StreamManagerMBean.OBJECT_NAME);</span>
<span class="fc" id="L266">            streamProxy = JMX.newMBeanProxy(mbeanServerConn, name, StreamManagerMBean.class);</span>
<span class="fc" id="L267">            name = new ObjectName(CompactionManager.MBEAN_OBJECT_NAME);</span>
<span class="fc" id="L268">            compactionProxy = JMX.newMBeanProxy(mbeanServerConn, name, CompactionManagerMBean.class);</span>
<span class="fc" id="L269">            name = new ObjectName(FailureDetector.MBEAN_NAME);</span>
<span class="fc" id="L270">            fdProxy = JMX.newMBeanProxy(mbeanServerConn, name, FailureDetectorMBean.class);</span>
<span class="fc" id="L271">            name = new ObjectName(CacheService.MBEAN_NAME);</span>
<span class="fc" id="L272">            cacheService = JMX.newMBeanProxy(mbeanServerConn, name, CacheServiceMBean.class);</span>
<span class="fc" id="L273">            name = new ObjectName(StorageProxy.MBEAN_NAME);</span>
<span class="fc" id="L274">            spProxy = JMX.newMBeanProxy(mbeanServerConn, name, StorageProxyMBean.class);</span>
<span class="fc" id="L275">            name = new ObjectName(HintsService.MBEAN_NAME);</span>
<span class="fc" id="L276">            hsProxy = JMX.newMBeanProxy(mbeanServerConn, name, HintsServiceMBean.class);</span>
<span class="fc" id="L277">            name = new ObjectName(GCInspector.MBEAN_NAME);</span>
<span class="fc" id="L278">            gcProxy = JMX.newMBeanProxy(mbeanServerConn, name, GCInspectorMXBean.class);</span>
<span class="fc" id="L279">            name = new ObjectName(Gossiper.MBEAN_NAME);</span>
<span class="fc" id="L280">            gossProxy = JMX.newMBeanProxy(mbeanServerConn, name, GossiperMBean.class);</span>
<span class="fc" id="L281">            name = new ObjectName(BatchlogManager.MBEAN_NAME);</span>
<span class="fc" id="L282">            bmProxy = JMX.newMBeanProxy(mbeanServerConn, name, BatchlogManagerMBean.class);</span>
<span class="fc" id="L283">            name = new ObjectName(ActiveRepairServiceMBean.MBEAN_NAME);</span>
<span class="fc" id="L284">            arsProxy = JMX.newMBeanProxy(mbeanServerConn, name, ActiveRepairServiceMBean.class);</span>
<span class="fc" id="L285">            name = new ObjectName(AuditLogManager.MBEAN_NAME);</span>
<span class="fc" id="L286">            almProxy = JMX.newMBeanProxy(mbeanServerConn, name, AuditLogManagerMBean.class);</span>
<span class="fc" id="L287">            name = new ObjectName(AuthCache.MBEAN_NAME_BASE + PasswordAuthenticator.CredentialsCacheMBean.CACHE_NAME);</span>
<span class="fc" id="L288">            ccProxy = JMX.newMBeanProxy(mbeanServerConn, name, PasswordAuthenticator.CredentialsCacheMBean.class);</span>
<span class="fc" id="L289">            name = new ObjectName(AuthCache.MBEAN_NAME_BASE + AuthorizationProxy.JmxPermissionsCacheMBean.CACHE_NAME);</span>
<span class="fc" id="L290">            jpcProxy = JMX.newMBeanProxy(mbeanServerConn, name, AuthorizationProxy.JmxPermissionsCacheMBean.class);</span>

<span class="fc" id="L292">            name = new ObjectName(AuthCache.MBEAN_NAME_BASE + NetworkPermissionsCache.CACHE_NAME);</span>
<span class="fc" id="L293">            npcProxy = JMX.newMBeanProxy(mbeanServerConn, name, NetworkPermissionsCacheMBean.class);</span>

<span class="fc" id="L295">            name = new ObjectName(AuthCache.MBEAN_NAME_BASE + PermissionsCache.CACHE_NAME);</span>
<span class="fc" id="L296">            pcProxy = JMX.newMBeanProxy(mbeanServerConn, name, PermissionsCacheMBean.class);</span>

<span class="fc" id="L298">            name = new ObjectName(AuthCache.MBEAN_NAME_BASE + RolesCache.CACHE_NAME);</span>
<span class="fc" id="L299">            rcProxy = JMX.newMBeanProxy(mbeanServerConn, name, RolesCacheMBean.class);</span>

<span class="fc" id="L301">            name = new ObjectName(CIDRPermissionsManager.MBEAN_NAME);</span>
<span class="fc" id="L302">            cpbProxy = JMX.newMBeanProxy(mbeanServerConn, name, CIDRPermissionsManagerMBean.class);</span>

<span class="fc" id="L304">            name = new ObjectName(CIDRGroupsMappingManager.MBEAN_NAME);</span>
<span class="fc" id="L305">            cmbProxy = JMX.newMBeanProxy(mbeanServerConn, name, CIDRGroupsMappingManagerMBean.class);</span>

<span class="fc" id="L307">            name = new ObjectName(CIDRFilteringMetricsTable.MBEAN_NAME);</span>
<span class="fc" id="L308">            cfmProxy = JMX.newMBeanProxy(mbeanServerConn, name, CIDRFilteringMetricsTableMBean.class);</span>
        }
<span class="nc" id="L310">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L312">            throw new RuntimeException(</span>
                    &quot;Invalid ObjectName? Please report this as a bug.&quot;, e);
<span class="fc" id="L314">        }</span>

<span class="fc" id="L316">        memProxy = ManagementFactory.newPlatformMXBeanProxy(mbeanServerConn,</span>
                ManagementFactory.MEMORY_MXBEAN_NAME, MemoryMXBean.class);
<span class="fc" id="L318">        runtimeProxy = ManagementFactory.newPlatformMXBeanProxy(</span>
                mbeanServerConn, ManagementFactory.RUNTIME_MXBEAN_NAME, RuntimeMXBean.class);
<span class="fc" id="L320">    }</span>

    private RMIClientSocketFactory getRMIClientSocketFactory()
    {
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">        if (SSL_ENABLE.getBoolean())</span>
<span class="nc" id="L325">            return new SslRMIClientSocketFactory();</span>
        else
<span class="fc" id="L327">            return RMISocketFactory.getDefaultSocketFactory();</span>
    }

    public void close() throws IOException
    {
        try
        {
<span class="fc" id="L334">            jmxc.close();</span>
        }
<span class="nc" id="L336">        catch (ConnectException e)</span>
        {
            // result of 'stopdaemon' command - i.e. if close() call fails, the daemon is shutdown
<span class="nc" id="L339">            System.out.println(&quot;Cassandra has shutdown.&quot;);</span>
<span class="fc" id="L340">        }</span>
<span class="fc" id="L341">    }</span>

    public void setOutput(Output output)
    {
<span class="fc" id="L345">        this.output = output;</span>
<span class="fc" id="L346">    }</span>

    public Output output()
    {
<span class="fc" id="L350">        return output;</span>
    }

    public int forceKeyspaceCleanup(int jobs, String keyspaceName, String... tables) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L355">        return ssProxy.forceKeyspaceCleanup(jobs, keyspaceName, tables);</span>
    }

    public int scrub(boolean disableSnapshot, boolean skipCorrupted, boolean checkData, boolean reinsertOverflowedTTL, int jobs, String keyspaceName, String... tables) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L360">        return ssProxy.scrub(disableSnapshot, skipCorrupted, checkData, reinsertOverflowedTTL, jobs, keyspaceName, tables);</span>
    }

    public int verify(boolean extendedVerify, boolean checkVersion, boolean diskFailurePolicy, boolean mutateRepairStatus, boolean checkOwnsTokens, boolean quick, String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L365">        return ssProxy.verify(extendedVerify, checkVersion, diskFailurePolicy, mutateRepairStatus, checkOwnsTokens, quick, keyspaceName, tableNames);</span>
    }

    public int upgradeSSTables(String keyspaceName, boolean excludeCurrentVersion, long maxSSTableTimestamp, int jobs, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L370">        return ssProxy.upgradeSSTables(keyspaceName, excludeCurrentVersion, maxSSTableTimestamp, jobs, tableNames);</span>
    }

    public int garbageCollect(String tombstoneOption, int jobs, String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L375">        return ssProxy.garbageCollect(tombstoneOption, jobs, keyspaceName, tableNames);</span>
    }

    public int recompressSSTables(String keyspaceName, int jobs, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L380">        return ssProxy.recompressSSTables(keyspaceName, jobs, tableNames);</span>
    }

    private void checkJobs(PrintStream out, int jobs)
    {
<span class="nc" id="L385">        int compactors = ssProxy.getConcurrentCompactors();</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">        if (jobs &gt; compactors)</span>
<span class="nc" id="L387">            out.println(String.format(&quot;jobs (%d) is bigger than configured concurrent_compactors (%d) on the host, using at most %d threads&quot;, jobs, compactors, compactors));</span>
<span class="nc" id="L388">    }</span>

    public void forceKeyspaceCleanup(PrintStream out, int jobs, String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L392">        checkJobs(out, jobs);</span>
<span class="nc" id="L393">        perform(out, keyspaceName,</span>
<span class="nc" id="L394">                () -&gt; forceKeyspaceCleanup(jobs, keyspaceName, tableNames),</span>
                &quot;cleaning up&quot;);
<span class="nc" id="L396">    }</span>

    public void scrub(PrintStream out, boolean disableSnapshot, boolean skipCorrupted, boolean checkData, boolean reinsertOverflowedTTL, int jobs, String keyspaceName, String... tables) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L400">        checkJobs(out, jobs);</span>
<span class="nc" id="L401">        perform(out, keyspaceName,</span>
<span class="nc" id="L402">                () -&gt; scrub(disableSnapshot, skipCorrupted, checkData, reinsertOverflowedTTL, jobs, keyspaceName, tables),</span>
                &quot;scrubbing&quot;);
<span class="nc" id="L404">    }</span>

    public void verify(PrintStream out, boolean extendedVerify, boolean checkVersion, boolean diskFailurePolicy, boolean mutateRepairStatus, boolean checkOwnsTokens, boolean quick, String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L408">        perform(out, keyspaceName,</span>
<span class="nc" id="L409">                () -&gt; verify(extendedVerify, checkVersion, diskFailurePolicy, mutateRepairStatus, checkOwnsTokens, quick, keyspaceName, tableNames),</span>
                &quot;verifying&quot;);
<span class="nc" id="L411">    }</span>

    public void recompressSSTables(PrintStream out, String keyspaceName, int jobs, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L415">        checkJobs(out, jobs);</span>
<span class="nc" id="L416">        perform(out, keyspaceName,</span>
<span class="nc" id="L417">                () -&gt; recompressSSTables(keyspaceName, jobs, tableNames),</span>
                &quot;recompressing sstables&quot;);
<span class="nc" id="L419">    }</span>

    public void upgradeSSTables(PrintStream out, String keyspaceName, boolean excludeCurrentVersion, long maxSSTableTimestamp, int jobs, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L423">        checkJobs(out, jobs);</span>
<span class="nc" id="L424">        perform(out, keyspaceName,</span>
<span class="nc" id="L425">                () -&gt; upgradeSSTables(keyspaceName, excludeCurrentVersion, maxSSTableTimestamp, jobs, tableNames),</span>
                &quot;upgrading sstables&quot;);
<span class="nc" id="L427">    }</span>

    private static interface Job
    {
        int perform() throws IOException, ExecutionException, InterruptedException;
    }

    private void perform(PrintStream out, String ks, Job job, String jobName) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc bnc" id="L436" title="All 3 branches missed.">        switch (job.perform())</span>
        {
            case 1:
<span class="nc" id="L439">                out.printf(&quot;Aborted %s for at least one table in keyspace %s, check server logs for more information.\n&quot;,</span>
                           jobName, ks);
<span class="nc" id="L441">                break;</span>
            case 2:
<span class="nc" id="L443">                failed = true;</span>
<span class="nc" id="L444">                out.printf(&quot;Failed marking some sstables compacting in keyspace %s, check server logs for more information.\n&quot;,</span>
                           ks);
        }
<span class="nc" id="L447">    }</span>

    public void garbageCollect(PrintStream out, String tombstoneOption, int jobs, String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc bnc" id="L451" title="All 2 branches missed.">        if (garbageCollect(tombstoneOption, jobs, keyspaceName, tableNames) != 0)</span>
        {
<span class="nc" id="L453">            failed = true;</span>
<span class="nc" id="L454">            out.println(&quot;Aborted garbage collection for at least one table in keyspace &quot; + keyspaceName + &quot;, check server logs for more information.&quot;);</span>
        }
<span class="nc" id="L456">    }</span>

    public void forceUserDefinedCompaction(String datafiles) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L460">        compactionProxy.forceUserDefinedCompaction(datafiles);</span>
<span class="nc" id="L461">    }</span>

    public void forceKeyspaceCompaction(boolean splitOutput, String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="fc" id="L465">        ssProxy.forceKeyspaceCompaction(splitOutput, keyspaceName, tableNames);</span>
<span class="fc" id="L466">    }</span>

    public void relocateSSTables(int jobs, String keyspace, String[] cfnames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L470">        ssProxy.relocateSSTables(jobs, keyspace, cfnames);</span>
<span class="nc" id="L471">    }</span>

    /**
     * Forces major compaction of specified token range in a single keyspace.
     *
     * @param keyspaceName the name of the keyspace to be compacted
     * @param startToken the token at which the compaction range starts (inclusive)
     * @param endToken the token at which compaction range ends (inclusive)
     * @param tableNames the names of the tables to be compacted
     */
    public void forceKeyspaceCompactionForTokenRange(String keyspaceName, final String startToken, final String endToken, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L483">        ssProxy.forceKeyspaceCompactionForTokenRange(keyspaceName, startToken, endToken, tableNames);</span>
<span class="nc" id="L484">    }</span>

    public void forceKeyspaceCompactionForPartitionKey(String keyspaceName, String partitionKey, String... tableNames) throws InterruptedException, ExecutionException, IOException
    {
<span class="nc" id="L488">        ssProxy.forceKeyspaceCompactionForPartitionKey(keyspaceName, partitionKey, tableNames);</span>
<span class="nc" id="L489">    }</span>

    public void forceCompactionKeysIgnoringGcGrace(String keyspaceName, String tableName, String... partitionKeysIgnoreGcGrace) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L493">        ssProxy.forceCompactionKeysIgnoringGcGrace(keyspaceName, tableName, partitionKeysIgnoreGcGrace);</span>
<span class="nc" id="L494">    }</span>

    public void forceKeyspaceFlush(String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="fc" id="L498">        ssProxy.forceKeyspaceFlush(keyspaceName, tableNames);</span>
<span class="fc" id="L499">    }</span>

    public String getKeyspaceReplicationInfo(String keyspaceName)
    {
<span class="nc" id="L503">        return ssProxy.getKeyspaceReplicationInfo(keyspaceName);</span>
    }

    public void repairAsync(final PrintStream out, final String keyspace, Map&lt;String, String&gt; options) throws IOException
    {
<span class="fc" id="L508">        RepairRunner runner = new RepairRunner(out, ssProxy, keyspace, options);</span>
        try
        {
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">            if (jmxc != null)</span>
<span class="fc" id="L512">                jmxc.addConnectionNotificationListener(runner, null, null);</span>
<span class="fc" id="L513">            ssProxy.addNotificationListener(runner, null, null);</span>
<span class="fc" id="L514">            runner.run();</span>
        }
<span class="nc" id="L516">        catch (Exception e)</span>
        {
<span class="nc" id="L518">            throw new IOException(e);</span>
        }
        finally
        {
            try
            {
<span class="fc" id="L524">                ssProxy.removeNotificationListener(runner);</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">                if (jmxc != null)</span>
<span class="fc" id="L526">                    jmxc.removeConnectionNotificationListener(runner);</span>
            }
<span class="nc" id="L528">            catch (Throwable e)</span>
            {
<span class="nc" id="L530">                out.println(&quot;Exception occurred during clean-up. &quot; + e);</span>
<span class="fc" id="L531">            }</span>
        }
<span class="fc" id="L533">    }</span>

    public boolean handleScheduledSampling(String ks,
                                           String table,
                                           int capacity,
                                           int count,
                                           int durationMillis,
                                           int intervalMillis,
                                           List&lt;String&gt; samplers,
                                           boolean shouldStop) throws OpenDataException
    {
<span class="nc bnc" id="L544" title="All 2 branches missed.">        return shouldStop ?</span>
<span class="nc" id="L545">               ssProxy.stopSamplingPartitions(ks, table) :</span>
<span class="nc" id="L546">               ssProxy.startSamplingPartitions(ks, table, durationMillis, intervalMillis, capacity, count, samplers);</span>
    }

    public List&lt;String&gt; getSampleTasks()
    {
<span class="nc" id="L551">        return ssProxy.getSampleTasks();</span>
    }

    public Map&lt;String, List&lt;CompositeData&gt;&gt; getPartitionSample(String ks, int capacity, int durationMillis, int count, List&lt;String&gt; samplers) throws OpenDataException
    {
<span class="nc" id="L556">        return ssProxy.samplePartitions(ks, durationMillis, capacity, count, samplers);</span>
    }

    public Map&lt;String, List&lt;CompositeData&gt;&gt; getPartitionSample(String ks, String cf, int capacity, int durationMillis, int count, List&lt;String&gt; samplers) throws OpenDataException
    {
<span class="nc" id="L561">        ColumnFamilyStoreMBean cfsProxy = getCfsProxy(ks, cf);</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">        for(String sampler : samplers)</span>
        {
<span class="nc" id="L564">            cfsProxy.beginLocalSampling(sampler, capacity, durationMillis);</span>
<span class="nc" id="L565">        }</span>
<span class="nc" id="L566">        Uninterruptibles.sleepUninterruptibly(durationMillis, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L567">        Map&lt;String, List&lt;CompositeData&gt;&gt; result = Maps.newHashMap();</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">        for(String sampler : samplers)</span>
        {
<span class="nc" id="L570">            result.put(sampler, cfsProxy.finishLocalSampling(sampler, count));</span>
<span class="nc" id="L571">        }</span>
<span class="nc" id="L572">        return result;</span>
    }

    public double getDroppableTombstoneRatio(String keyspace, String table) {
<span class="nc" id="L576">        ColumnFamilyStoreMBean cfsProxy = getCfsProxy(keyspace, table);</span>
<span class="nc" id="L577">        return cfsProxy.getDroppableTombstoneRatio();</span>
    }

    public void invalidateCounterCache()
    {
<span class="nc" id="L582">        cacheService.invalidateCounterCache();</span>
<span class="nc" id="L583">    }</span>

    public void invalidateCredentialsCache()
    {
<span class="nc" id="L587">        ccProxy.invalidate();</span>
<span class="nc" id="L588">    }</span>

    public void invalidateCredentialsCache(String roleName)
    {
<span class="nc" id="L592">        ccProxy.invalidateCredentials(roleName);</span>
<span class="nc" id="L593">    }</span>

    public void invalidateJmxPermissionsCache()
    {
<span class="nc" id="L597">        jpcProxy.invalidate();</span>
<span class="nc" id="L598">    }</span>

    public void invalidateJmxPermissionsCache(String roleName)
    {
<span class="nc" id="L602">        jpcProxy.invalidatePermissions(roleName);</span>
<span class="nc" id="L603">    }</span>

    public void invalidateKeyCache()
    {
<span class="nc" id="L607">        cacheService.invalidateKeyCache();</span>
<span class="nc" id="L608">    }</span>

    public void invalidateNetworkPermissionsCache()
    {
<span class="nc" id="L612">        npcProxy.invalidate();</span>
<span class="nc" id="L613">    }</span>

    public void invalidateNetworkPermissionsCache(String roleName)
    {
<span class="nc" id="L617">        npcProxy.invalidateNetworkPermissions(roleName);</span>
<span class="nc" id="L618">    }</span>

    public boolean invalidateCidrPermissionsCache(String roleName)
    {
<span class="nc" id="L622">        return cpbProxy.invalidateCidrPermissionsCache(roleName);</span>
    }

    public void reloadCidrGroupsCache()
    {
<span class="nc" id="L627">        cmbProxy.loadCidrGroupsCache();</span>
<span class="nc" id="L628">    }</span>

    public Set&lt;String&gt; listAvailableCidrGroups()
    {
<span class="nc" id="L632">        return cmbProxy.getAvailableCidrGroups();</span>
    }

    public Set&lt;String&gt; listCidrsOfCidrGroup(String cidrGroup)
    {
<span class="nc" id="L637">        return cmbProxy.getCidrsOfCidrGroupAsStrings(cidrGroup);</span>
    }

    public void updateCidrGroup(String cidrGroupName, List&lt;String&gt; cidrs)
    {
<span class="nc" id="L642">        cmbProxy.updateCidrGroup(cidrGroupName, cidrs);</span>
<span class="nc" id="L643">    }</span>

    public void dropCidrGroup(String cidrGroupName)
    {
<span class="nc" id="L647">        cmbProxy.dropCidrGroup(cidrGroupName);</span>
<span class="nc" id="L648">    }</span>

    public Set&lt;String&gt; getCidrGroupsOfIp(String ipStr)
    {
<span class="nc" id="L652">        return cmbProxy.getCidrGroupsOfIP(ipStr);</span>
    }

    public void invalidatePermissionsCache()
    {
<span class="nc" id="L657">        pcProxy.invalidate();</span>
<span class="nc" id="L658">    }</span>

    public void invalidatePermissionsCache(String roleName, String resourceName)
    {
<span class="nc" id="L662">        pcProxy.invalidatePermissions(roleName, resourceName);</span>
<span class="nc" id="L663">    }</span>

    public void invalidateRolesCache()
    {
<span class="nc" id="L667">        rcProxy.invalidate();</span>
<span class="nc" id="L668">    }</span>

    public void invalidateRolesCache(String roleName)
    {
<span class="nc" id="L672">        rcProxy.invalidateRoles(roleName);</span>
<span class="nc" id="L673">    }</span>

    public void invalidateRowCache()
    {
<span class="nc" id="L677">        cacheService.invalidateRowCache();</span>
<span class="nc" id="L678">    }</span>

    public AuthCacheMBean getAuthCacheMBean(String cacheName)
    {
<span class="nc bnc" id="L682" title="All 6 branches missed.">        switch (cacheName)</span>
        {
            case PasswordAuthenticator.CredentialsCacheMBean.CACHE_NAME:
<span class="nc" id="L685">                return ccProxy;</span>
            case AuthorizationProxy.JmxPermissionsCacheMBean.CACHE_NAME:
<span class="nc" id="L687">                return jpcProxy;</span>
            case NetworkPermissionsCacheMBean.CACHE_NAME:
<span class="nc" id="L689">                return npcProxy;</span>
            case PermissionsCacheMBean.CACHE_NAME:
<span class="nc" id="L691">                return pcProxy;</span>
            case RolesCacheMBean.CACHE_NAME:
<span class="nc" id="L693">                return rcProxy;</span>
            default:
<span class="nc" id="L695">                throw new IllegalArgumentException(&quot;Unknown cache name: &quot; + cacheName);</span>
        }
    }

    public void drain() throws IOException, InterruptedException, ExecutionException
    {
<span class="nc" id="L701">        ssProxy.drain();</span>
<span class="nc" id="L702">    }</span>

    public Map&lt;String, String&gt; getTokenToEndpointMap(boolean withPort)
    {
<span class="nc bnc" id="L706" title="All 2 branches missed.">        return withPort ? ssProxy.getTokenToEndpointWithPortMap() : ssProxy.getTokenToEndpointMap();</span>
    }

    public List&lt;String&gt; getLiveNodes(boolean withPort)
    {
<span class="nc bnc" id="L711" title="All 2 branches missed.">        return withPort ? ssProxy.getLiveNodesWithPort() : ssProxy.getLiveNodes();</span>
    }

    public List&lt;String&gt; getJoiningNodes(boolean withPort)
    {
<span class="nc bnc" id="L716" title="All 2 branches missed.">        return withPort ? ssProxy.getJoiningNodesWithPort() : ssProxy.getJoiningNodes();</span>
    }

    public List&lt;String&gt; getLeavingNodes(boolean withPort)
    {
<span class="nc bnc" id="L721" title="All 2 branches missed.">        return withPort ? ssProxy.getLeavingNodesWithPort() : ssProxy.getLeavingNodes();</span>
    }

    public List&lt;String&gt; getMovingNodes(boolean withPort)
    {
<span class="nc bnc" id="L726" title="All 2 branches missed.">        return withPort ? ssProxy.getMovingNodesWithPort() : ssProxy.getMovingNodes();</span>
    }

    public List&lt;String&gt; getUnreachableNodes(boolean withPort)
    {
<span class="nc bnc" id="L731" title="All 2 branches missed.">        return withPort ? ssProxy.getUnreachableNodesWithPort() : ssProxy.getUnreachableNodes();</span>
    }

    public Map&lt;String, String&gt; getLoadMap(boolean withPort)
    {
<span class="nc bnc" id="L736" title="All 2 branches missed.">        return withPort ? ssProxy.getLoadMapWithPort() : ssProxy.getLoadMap();</span>
    }

    public Map&lt;InetAddress, Float&gt; getOwnership()
    {
<span class="nc" id="L741">        return ssProxy.getOwnership();</span>
    }

    public Map&lt;String, Float&gt; getOwnershipWithPort()
    {
<span class="nc" id="L746">        return ssProxy.getOwnershipWithPort();</span>
    }

    public Map&lt;InetAddress, Float&gt; effectiveOwnership(String keyspace) throws IllegalStateException
    {
<span class="nc" id="L751">        return ssProxy.effectiveOwnership(keyspace);</span>
    }

    public Map&lt;String, Float&gt; effectiveOwnershipWithPort(String keyspace) throws IllegalStateException
    {
<span class="nc" id="L756">        return ssProxy.effectiveOwnershipWithPort(keyspace);</span>
    }

    public MBeanServerConnection getMbeanServerConn()
    {
<span class="nc" id="L761">        return mbeanServerConn;</span>
    }

    public CacheServiceMBean getCacheServiceMBean()
    {
<span class="nc" id="L766">        String cachePath = &quot;org.apache.cassandra.db:type=Caches&quot;;</span>

        try
        {
<span class="nc" id="L770">            return JMX.newMBeanProxy(mbeanServerConn, new ObjectName(cachePath), CacheServiceMBean.class);</span>
        }
<span class="nc" id="L772">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L774">            throw new RuntimeException(e);</span>
        }
    }

    public double[] getAndResetGCStats()
    {
<span class="nc" id="L780">        return gcProxy.getAndResetStats();</span>
    }

    public Iterator&lt;Map.Entry&lt;String, ColumnFamilyStoreMBean&gt;&gt; getColumnFamilyStoreMBeanProxies()
    {
        try
        {
<span class="nc" id="L787">            return new ColumnFamilyStoreMBeanIterator(mbeanServerConn);</span>
        }
<span class="nc" id="L789">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L791">            throw new RuntimeException(&quot;Invalid ObjectName? Please report this as a bug.&quot;, e);</span>
        }
<span class="nc" id="L793">        catch (IOException e)</span>
        {
<span class="nc" id="L795">            throw new RuntimeException(&quot;Could not retrieve list of stat mbeans.&quot;, e);</span>
        }
    }

    public CompactionManagerMBean getCompactionManagerProxy()
    {
<span class="nc" id="L801">      return compactionProxy;</span>
    }

    public List&lt;String&gt; getTokens()
    {
<span class="nc" id="L806">        return ssProxy.getTokens();</span>
    }

    public List&lt;String&gt; getTokens(String endpoint)
    {
        try
        {
<span class="nc" id="L813">            return ssProxy.getTokens(endpoint);</span>
        }
<span class="nc" id="L815">        catch (UnknownHostException e)</span>
        {
<span class="nc" id="L817">            throw new RuntimeException(e);</span>
        }
    }

    public Map&lt;String, String&gt; getHostIdToEndpointWithPort()
    {
<span class="nc" id="L823">        return ssProxy.getHostIdToEndpointWithPort();</span>
    }

    public String getLocalHostId()
    {
<span class="nc" id="L828">        return ssProxy.getLocalHostId();</span>
    }

    public Map&lt;String, String&gt; getHostIdMap(boolean withPort)
    {
<span class="nc bnc" id="L833" title="All 2 branches missed.">        return withPort ? ssProxy.getEndpointWithPortToHostId() : ssProxy.getEndpointToHostId();</span>
    }

    public String getLoadString()
    {
<span class="nc" id="L838">        return ssProxy.getLoadString();</span>
    }

    public String getUncompressedLoadString()
    {
<span class="nc" id="L843">        return ssProxy.getUncompressedLoadString();</span>
    }

    public String getReleaseVersion()
    {
<span class="nc" id="L848">        return ssProxy.getReleaseVersion();</span>
    }

    public String getGitSHA()
    {
<span class="nc" id="L853">        return ssProxy.getGitSHA();</span>
    }

    public int getCurrentGenerationNumber()
    {
<span class="nc" id="L858">        return ssProxy.getCurrentGenerationNumber();</span>
    }

    public long getUptime()
    {
<span class="nc" id="L863">        return runtimeProxy.getUptime();</span>
    }

    public MemoryUsage getHeapMemoryUsage()
    {
<span class="nc" id="L868">        return memProxy.getHeapMemoryUsage();</span>
    }

    public long getSnapshotLinksPerSecond()
    {
<span class="nc" id="L873">        return ssProxy.getSnapshotLinksPerSecond();</span>
    }

    public void setSnapshotLinksPerSecond(long throttle)
    {
<span class="nc" id="L878">        ssProxy.setSnapshotLinksPerSecond(throttle);</span>
<span class="nc" id="L879">    }</span>

    /**
     * Take a snapshot of all the keyspaces, optionally specifying only a specific column family.
     *
     * @param snapshotName the name of the snapshot.
     * @param table the table to snapshot or all on null
     * @param options Options (skipFlush for now)
     * @param keyspaces the keyspaces to snapshot
     */
    public void takeSnapshot(String snapshotName, String table, Map&lt;String, String&gt; options, String... keyspaces) throws IOException
    {
<span class="nc bnc" id="L891" title="All 2 branches missed.">        if (table != null)</span>
        {
<span class="nc bnc" id="L893" title="All 2 branches missed.">            if (keyspaces.length != 1)</span>
            {
<span class="nc" id="L895">                throw new IOException(&quot;When specifying the table for a snapshot, you must specify one and only one keyspace&quot;);</span>
            }

<span class="nc" id="L898">            ssProxy.takeSnapshot(snapshotName, options, keyspaces[0] + &quot;.&quot; + table);</span>
        }
        else
<span class="nc" id="L901">            ssProxy.takeSnapshot(snapshotName, options, keyspaces);</span>
<span class="nc" id="L902">    }</span>

    /**
     * Take a snapshot of all column family from different keyspaces.
     *
     * @param snapshotName
     *            the name of the snapshot.
     * @param options
     *            Options (skipFlush for now)
     * @param tableList
     *            list of columnfamily from different keyspace in the form of ks1.cf1 ks2.cf2
     */
    public void takeMultipleTableSnapshot(String snapshotName, Map&lt;String, String&gt; options, String... tableList)
            throws IOException
    {
<span class="nc bnc" id="L917" title="All 4 branches missed.">        if (null != tableList &amp;&amp; tableList.length != 0)</span>
        {
<span class="nc" id="L919">            ssProxy.takeSnapshot(snapshotName, options, tableList);</span>
        }
        else
        {
<span class="nc" id="L923">            throw new IOException(&quot;The column family List  for a snapshot should not be empty or null&quot;);</span>
        }
<span class="nc" id="L925">    }</span>

    /**
     * Remove all the existing snapshots of given tag for provided keyspaces.
     * When no keyspaces are specified, take all keyspaces into account. When tag is not specified (null or empty string),
     * take all tags into account.
     *
     * @param tag tag of snapshot to clear
     * @param keyspaces keyspaces to clear snapshots for
     */
    @Deprecated
    public void clearSnapshot(String tag, String... keyspaces) throws IOException
    {
<span class="nc" id="L938">        clearSnapshot(Collections.emptyMap(), tag, keyspaces);</span>
<span class="nc" id="L939">    }</span>

    /**
     * Remove all the existing snapshots of given tag for provided keyspaces.
     * When no keyspaces are specified, take all keyspaces into account. When tag is not specified (null or empty string),
     * take all tags into account.
     *
     * @param options options to supply for snapshot clearing
     * @param tag tag of snapshot to clear
     * @param keyspaces keyspaces to clear snapshots for
     */
    public void clearSnapshot(Map&lt;String, Object&gt; options, String tag, String... keyspaces) throws IOException
    {
<span class="nc" id="L952">        ssProxy.clearSnapshot(options, tag, keyspaces);</span>
<span class="nc" id="L953">    }</span>

    public Map&lt;String, TabularData&gt; getSnapshotDetails(Map&lt;String, String&gt; options)
    {
<span class="nc" id="L957">        return ssProxy.getSnapshotDetails(options);</span>
    }

    @Deprecated
    public Map&lt;String, TabularData&gt; getSnapshotDetails()
    {
<span class="nc" id="L963">        return getSnapshotDetails(ImmutableMap.of());</span>
    }

    public long trueSnapshotsSize()
    {
<span class="nc" id="L968">        return ssProxy.trueSnapshotsSize();</span>
    }

    public boolean isJoined()
    {
<span class="nc" id="L973">        return ssProxy.isJoined();</span>
    }

    public boolean isDrained()
    {
<span class="nc" id="L978">        return ssProxy.isDrained();</span>
    }

    public boolean isDraining()
    {
<span class="nc" id="L983">        return ssProxy.isDraining();</span>
    }

    public boolean isBootstrapMode()
    {
<span class="nc" id="L988">        return ssProxy.isBootstrapMode();</span>
    }

    public void joinRing() throws IOException
    {
<span class="nc" id="L993">        ssProxy.joinRing();</span>
<span class="nc" id="L994">    }</span>

    public void decommission(boolean force) throws InterruptedException
    {
<span class="fc" id="L998">        ssProxy.decommission(force);</span>
<span class="fc" id="L999">    }</span>

    public void move(String newToken) throws IOException
    {
<span class="nc" id="L1003">        ssProxy.move(newToken);</span>
<span class="nc" id="L1004">    }</span>

    public void removeNode(String token)
    {
<span class="nc" id="L1008">        ssProxy.removeNode(token);</span>
<span class="nc" id="L1009">    }</span>

    public String getRemovalStatus(boolean withPort)
    {
<span class="nc bnc" id="L1013" title="All 2 branches missed.">        return withPort ? ssProxy.getRemovalStatusWithPort() : ssProxy.getRemovalStatus();</span>
    }

    public void forceRemoveCompletion()
    {
<span class="nc" id="L1018">        ssProxy.forceRemoveCompletion();</span>
<span class="nc" id="L1019">    }</span>

    public void assassinateEndpoint(String address) throws UnknownHostException
    {
<span class="nc" id="L1023">        gossProxy.assassinateEndpoint(address);</span>
<span class="nc" id="L1024">    }</span>

    public List&lt;String&gt; reloadSeeds()
    {
<span class="nc" id="L1028">        return gossProxy.reloadSeeds();</span>
    }

    public List&lt;String&gt; getSeeds()
    {
<span class="nc" id="L1033">        return gossProxy.getSeeds();</span>
    }

    /**
     * Set the compaction threshold
     *
     * @param minimumCompactionThreshold minimum compaction threshold
     * @param maximumCompactionThreshold maximum compaction threshold
     */
    public void setCompactionThreshold(String ks, String cf, int minimumCompactionThreshold, int maximumCompactionThreshold)
    {
<span class="nc" id="L1044">        ColumnFamilyStoreMBean cfsProxy = getCfsProxy(ks, cf);</span>
<span class="nc" id="L1045">        cfsProxy.setCompactionThresholds(minimumCompactionThreshold, maximumCompactionThreshold);</span>
<span class="nc" id="L1046">    }</span>

    public void disableAutoCompaction(String ks, String ... tables) throws IOException
    {
<span class="fc" id="L1050">        ssProxy.disableAutoCompaction(ks, tables);</span>
<span class="fc" id="L1051">    }</span>

    public void enableAutoCompaction(String ks, String ... tableNames) throws IOException
    {
<span class="nc" id="L1055">        ssProxy.enableAutoCompaction(ks, tableNames);</span>
<span class="nc" id="L1056">    }</span>

    public Map&lt;String, Boolean&gt; getAutoCompactionDisabled(String ks, String ... tableNames) throws IOException
    {
<span class="nc" id="L1060">        return ssProxy.getAutoCompactionStatus(ks, tableNames);</span>
    }

    public void setIncrementalBackupsEnabled(boolean enabled)
    {
<span class="nc" id="L1065">        ssProxy.setIncrementalBackupsEnabled(enabled);</span>
<span class="nc" id="L1066">    }</span>

    public boolean isIncrementalBackupsEnabled()
    {
<span class="nc" id="L1070">        return ssProxy.isIncrementalBackupsEnabled();</span>
    }

    public void setCacheCapacities(int keyCacheCapacity, int rowCacheCapacity, int counterCacheCapacity)
    {
<span class="nc" id="L1075">        CacheServiceMBean cacheMBean = getCacheServiceMBean();</span>
<span class="nc" id="L1076">        cacheMBean.setKeyCacheCapacityInMB(keyCacheCapacity);</span>
<span class="nc" id="L1077">        cacheMBean.setRowCacheCapacityInMB(rowCacheCapacity);</span>
<span class="nc" id="L1078">        cacheMBean.setCounterCacheCapacityInMB(counterCacheCapacity);</span>
<span class="nc" id="L1079">    }</span>

    public void setCacheKeysToSave(int keyCacheKeysToSave, int rowCacheKeysToSave, int counterCacheKeysToSave)
    {
<span class="nc" id="L1083">        CacheServiceMBean cacheMBean = getCacheServiceMBean();</span>
<span class="nc" id="L1084">        cacheMBean.setKeyCacheKeysToSave(keyCacheKeysToSave);</span>
<span class="nc" id="L1085">        cacheMBean.setRowCacheKeysToSave(rowCacheKeysToSave);</span>
<span class="nc" id="L1086">        cacheMBean.setCounterCacheKeysToSave(counterCacheKeysToSave);</span>
<span class="nc" id="L1087">    }</span>

    public void setHintedHandoffThrottleInKB(int throttleInKB)
    {
<span class="nc" id="L1091">        ssProxy.setHintedHandoffThrottleInKB(throttleInKB);</span>
<span class="nc" id="L1092">    }</span>

    public List&lt;String&gt; getEndpointsWithPort(String keyspace, String cf, String key)
    {
<span class="nc" id="L1096">        return ssProxy.getNaturalEndpointsWithPort(keyspace, cf, key);</span>
    }

    public List&lt;InetAddress&gt; getEndpoints(String keyspace, String cf, String key)
    {
<span class="nc" id="L1101">        return ssProxy.getNaturalEndpoints(keyspace, cf, key);</span>
    }

    public List&lt;String&gt; getSSTables(String keyspace, String cf, String key, boolean hexFormat)
    {
<span class="nc" id="L1106">        ColumnFamilyStoreMBean cfsProxy = getCfsProxy(keyspace, cf);</span>
<span class="nc" id="L1107">        return cfsProxy.getSSTablesForKey(key, hexFormat);</span>
    }

    public Map&lt;Integer, Set&lt;String&gt;&gt; getSSTablesWithLevel(String keyspace, String cf, String key, boolean hexFormat)
    {
<span class="nc" id="L1112">        ColumnFamilyStoreMBean cfsProxy = getCfsProxy(keyspace, cf);</span>
<span class="nc" id="L1113">        return cfsProxy.getSSTablesForKeyWithLevel(key, hexFormat);</span>
    }

    public boolean isLeveledCompaction(String keyspace, String cf)
    {
<span class="nc" id="L1118">        ColumnFamilyStoreMBean cfsProxy = getCfsProxy(keyspace, cf);</span>
<span class="nc" id="L1119">        return cfsProxy.isLeveledCompaction();</span>
    }

    public Set&lt;StreamState&gt; getStreamStatus()
    {
<span class="nc" id="L1124">        return Sets.newHashSet(Iterables.transform(streamProxy.getCurrentStreams(), new Function&lt;CompositeData, StreamState&gt;()</span>
<span class="nc" id="L1125">        {</span>
            public StreamState apply(CompositeData input)
            {
<span class="nc" id="L1128">                return StreamStateCompositeData.fromCompositeData(input);</span>
            }
        }));
    }

    public String getOperationMode()
    {
<span class="nc" id="L1135">        return ssProxy.getOperationMode();</span>
    }

    public boolean isStarting()
    {
<span class="nc" id="L1140">        return ssProxy.isStarting();</span>
    }

    public void truncate(String keyspaceName, String tableName)
    {
        try
        {
<span class="nc" id="L1147">            ssProxy.truncate(keyspaceName, tableName);</span>
        }
<span class="nc" id="L1149">        catch (TimeoutException e)</span>
        {
<span class="nc" id="L1151">            throw new RuntimeException(&quot;Error while executing truncate&quot;, e);</span>
        }
<span class="nc" id="L1153">        catch (IOException e)</span>
        {
<span class="nc" id="L1155">            throw new RuntimeException(&quot;Error while executing truncate&quot;, e);</span>
<span class="nc" id="L1156">        }</span>
<span class="nc" id="L1157">    }</span>

    public EndpointSnitchInfoMBean getEndpointSnitchInfoProxy()
    {
        try
        {
<span class="nc" id="L1163">            return JMX.newMBeanProxy(mbeanServerConn, new ObjectName(&quot;org.apache.cassandra.db:type=EndpointSnitchInfo&quot;), EndpointSnitchInfoMBean.class);</span>
        }
<span class="nc" id="L1165">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L1167">            throw new RuntimeException(e);</span>
        }
    }

    public DynamicEndpointSnitchMBean getDynamicEndpointSnitchInfoProxy()
    {
        try
        {
<span class="nc" id="L1175">            return JMX.newMBeanProxy(mbeanServerConn, new ObjectName(&quot;org.apache.cassandra.db:type=DynamicEndpointSnitch&quot;), DynamicEndpointSnitchMBean.class);</span>
        }
<span class="nc" id="L1177">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L1179">            throw new RuntimeException(e);</span>
        }
    }

    public ColumnFamilyStoreMBean getCfsProxy(String ks, String cf)
    {
<span class="nc" id="L1185">        ColumnFamilyStoreMBean cfsProxy = null;</span>
        try
        {
<span class="nc bnc" id="L1188" title="All 2 branches missed.">            String type = cf.contains(&quot;.&quot;) ? &quot;IndexColumnFamilies&quot; : &quot;ColumnFamilies&quot;;</span>
<span class="nc" id="L1189">            Set&lt;ObjectName&gt; beans = mbeanServerConn.queryNames(</span>
                    new ObjectName(&quot;org.apache.cassandra.db:type=*&quot; + type +&quot;,keyspace=&quot; + ks + &quot;,columnfamily=&quot; + cf), null);

<span class="nc bnc" id="L1192" title="All 2 branches missed.">            if (beans.isEmpty())</span>
<span class="nc" id="L1193">                throw new MalformedObjectNameException(&quot;couldn't find that bean&quot;);</span>
<span class="nc bnc" id="L1194" title="All 2 branches missed.">            assert beans.size() == 1;</span>
<span class="nc bnc" id="L1195" title="All 2 branches missed.">            for (ObjectName bean : beans)</span>
<span class="nc" id="L1196">                cfsProxy = JMX.newMBeanProxy(mbeanServerConn, bean, ColumnFamilyStoreMBean.class);</span>
        }
<span class="nc" id="L1198">        catch (MalformedObjectNameException mone)</span>
        {
<span class="nc" id="L1200">            System.err.println(&quot;ColumnFamilyStore for &quot; + ks + &quot;/&quot; + cf + &quot; not found.&quot;);</span>
<span class="nc" id="L1201">            System.exit(1);</span>
        }
<span class="nc" id="L1203">        catch (IOException e)</span>
        {
<span class="nc" id="L1205">            System.err.println(&quot;ColumnFamilyStore for &quot; + ks + &quot;/&quot; + cf + &quot; not found: &quot; + e);</span>
<span class="nc" id="L1206">            System.exit(1);</span>
<span class="nc" id="L1207">        }</span>

<span class="nc" id="L1209">        return cfsProxy;</span>
    }

    public StorageProxyMBean getSpProxy()
    {
<span class="nc" id="L1214">        return spProxy;</span>
    }

    public StorageServiceMBean getStorageService() {
<span class="fc" id="L1218">        return ssProxy;</span>
    }

    public GossiperMBean getGossProxy()
    {
<span class="nc" id="L1223">        return gossProxy;</span>
    }

    public String getEndpoint()
    {
<span class="nc" id="L1228">        Map&lt;String, String&gt; hostIdToEndpoint = ssProxy.getHostIdToEndpoint();</span>
<span class="nc" id="L1229">        return hostIdToEndpoint.get(ssProxy.getLocalHostId());</span>
    }

    public String getDataCenter()
    {
<span class="nc" id="L1234">        return getEndpointSnitchInfoProxy().getDatacenter();</span>
    }

    public String getRack()
    {
<span class="nc" id="L1239">        return getEndpointSnitchInfoProxy().getRack();</span>
    }

    public List&lt;String&gt; getKeyspaces()
    {
<span class="fc" id="L1244">        return ssProxy.getKeyspaces();</span>
    }

    public List&lt;String&gt; getNonSystemKeyspaces()
    {
<span class="nc" id="L1249">        return ssProxy.getNonSystemKeyspaces();</span>
    }

    public List&lt;String&gt; getNonLocalStrategyKeyspaces()
    {
<span class="fc" id="L1254">        return ssProxy.getNonLocalStrategyKeyspaces();</span>
    }

    public String getClusterName()
    {
<span class="nc" id="L1259">        return ssProxy.getClusterName();</span>
    }

    public String getPartitioner()
    {
<span class="nc" id="L1264">        return ssProxy.getPartitionerName();</span>
    }

    public void disableHintedHandoff()
    {
<span class="nc" id="L1269">        spProxy.setHintedHandoffEnabled(false);</span>
<span class="nc" id="L1270">    }</span>

    public void enableHintedHandoff()
    {
<span class="nc" id="L1274">        spProxy.setHintedHandoffEnabled(true);</span>
<span class="nc" id="L1275">    }</span>

    public boolean isHandoffEnabled()
    {
<span class="nc" id="L1279">        return spProxy.getHintedHandoffEnabled();</span>
    }

    public void enableHintsForDC(String dc)
    {
<span class="nc" id="L1284">        spProxy.enableHintsForDC(dc);</span>
<span class="nc" id="L1285">    }</span>

    public void disableHintsForDC(String dc)
    {
<span class="nc" id="L1289">        spProxy.disableHintsForDC(dc);</span>
<span class="nc" id="L1290">    }</span>

    public Set&lt;String&gt; getHintedHandoffDisabledDCs()
    {
<span class="nc" id="L1294">        return spProxy.getHintedHandoffDisabledDCs();</span>
    }

    public Map&lt;String, String&gt; getViewBuildStatuses(String keyspace, String view)
    {
<span class="nc" id="L1299">        return ssProxy.getViewBuildStatuses(keyspace, view);</span>
    }

    public void pauseHintsDelivery()
    {
<span class="nc" id="L1304">        hsProxy.pauseDispatch();</span>
<span class="nc" id="L1305">    }</span>

    public void resumeHintsDelivery()
    {
<span class="nc" id="L1309">        hsProxy.resumeDispatch();</span>
<span class="nc" id="L1310">    }</span>

    public void truncateHints(final String host)
    {
<span class="nc" id="L1314">        hsProxy.deleteAllHintsForEndpoint(host);</span>
<span class="nc" id="L1315">    }</span>

    public void truncateHints()
    {
<span class="nc" id="L1319">        hsProxy.deleteAllHints();</span>
<span class="nc" id="L1320">    }</span>

    public List&lt;Map&lt;String, String&gt;&gt; listPendingHints()
    {
<span class="nc" id="L1324">        return hsProxy.getPendingHints();</span>
    }

    public void refreshSizeEstimates()
    {
        try
        {
<span class="nc" id="L1331">            ssProxy.refreshSizeEstimates();</span>
        }
<span class="nc" id="L1333">        catch (ExecutionException e)</span>
        {
<span class="nc" id="L1335">            throw new RuntimeException(&quot;Error while refreshing system.size_estimates&quot;, e);</span>
<span class="nc" id="L1336">        }</span>
<span class="nc" id="L1337">    }</span>

    public void stopNativeTransport()
    {
<span class="nc" id="L1341">        ssProxy.stopNativeTransport();</span>
<span class="nc" id="L1342">    }</span>

    public void startNativeTransport()
    {
<span class="nc" id="L1346">        ssProxy.startNativeTransport();</span>
<span class="nc" id="L1347">    }</span>

    public boolean isNativeTransportRunning()
    {
<span class="nc" id="L1351">        return ssProxy.isNativeTransportRunning();</span>
    }

    public void stopGossiping()
    {
<span class="nc" id="L1356">        ssProxy.stopGossiping();</span>
<span class="nc" id="L1357">    }</span>

    public void startGossiping()
    {
<span class="nc" id="L1361">        ssProxy.startGossiping();</span>
<span class="nc" id="L1362">    }</span>

    public boolean isGossipRunning()
    {
<span class="nc" id="L1366">        return ssProxy.isGossipRunning();</span>
    }

    public void stopCassandraDaemon()
    {
<span class="nc" id="L1371">        ssProxy.stopDaemon();</span>
<span class="nc" id="L1372">    }</span>

    public boolean isInitialized()
    {
<span class="nc" id="L1376">        return ssProxy.isInitialized();</span>
    }

    public void setColumnIndexSize(int columnIndexSizeInKiB)
    {
<span class="nc" id="L1381">        ssProxy.setColumnIndexSize(columnIndexSizeInKiB);</span>
<span class="nc" id="L1382">    }</span>

    public int getColumnIndexSizeInKB()
    {
<span class="nc" id="L1386">        return ssProxy.getColumnIndexSizeInKiB();</span>
    }

    public void setCompactionThroughput(int value)
    {
<span class="nc" id="L1391">        ssProxy.setCompactionThroughputMbPerSec(value);</span>
<span class="nc" id="L1392">    }</span>

    @Deprecated
    public int getCompactionThroughput()
    {
<span class="nc" id="L1397">        return ssProxy.getCompactionThroughputMbPerSec();</span>
    }

    public double getCompactionThroughputMebibytesAsDouble()
    {
<span class="nc" id="L1402">        return ssProxy.getCompactionThroughtputMibPerSecAsDouble();</span>
    }

    public long getCompactionThroughputBytes()
    {
<span class="nc" id="L1407">        return ssProxy.getCompactionThroughtputBytesPerSec();</span>
    }

    public void setBatchlogReplayThrottle(int value)
    {
<span class="nc" id="L1412">        ssProxy.setBatchlogReplayThrottleInKB(value);</span>
<span class="nc" id="L1413">    }</span>

    public int getBatchlogReplayThrottle()
    {
<span class="nc" id="L1417">        return ssProxy.getBatchlogReplayThrottleInKB();</span>
    }

    public void setConcurrentCompactors(int value)
    {
<span class="nc" id="L1422">        ssProxy.setConcurrentCompactors(value);</span>
<span class="nc" id="L1423">    }</span>

    public int getConcurrentCompactors()
    {
<span class="nc" id="L1427">        return ssProxy.getConcurrentCompactors();</span>
    }

    public void setConcurrentViewBuilders(int value)
    {
<span class="nc" id="L1432">        ssProxy.setConcurrentViewBuilders(value);</span>
<span class="nc" id="L1433">    }</span>

    public int getConcurrentViewBuilders()
    {
<span class="nc" id="L1437">        return ssProxy.getConcurrentViewBuilders();</span>
    }

    public void setMaxHintWindow(int value)
    {
<span class="nc" id="L1442">        spProxy.setMaxHintWindow(value);</span>
<span class="nc" id="L1443">    }</span>

    public int getMaxHintWindow()
    {
<span class="nc" id="L1447">        return spProxy.getMaxHintWindow();</span>
    }

    public long getTimeout(String type)
    {
<span class="nc bnc" id="L1452" title="All 11 branches missed.">        switch (type)</span>
        {
            case &quot;misc&quot;:
<span class="nc" id="L1455">                return ssProxy.getRpcTimeout();</span>
            case &quot;read&quot;:
<span class="nc" id="L1457">                return ssProxy.getReadRpcTimeout();</span>
            case &quot;range&quot;:
<span class="nc" id="L1459">                return ssProxy.getRangeRpcTimeout();</span>
            case &quot;write&quot;:
<span class="nc" id="L1461">                return ssProxy.getWriteRpcTimeout();</span>
            case &quot;counterwrite&quot;:
<span class="nc" id="L1463">                return ssProxy.getCounterWriteRpcTimeout();</span>
            case &quot;cascontention&quot;:
<span class="nc" id="L1465">                return ssProxy.getCasContentionTimeout();</span>
            case &quot;truncate&quot;:
<span class="nc" id="L1467">                return ssProxy.getTruncateRpcTimeout();</span>
            case &quot;internodeconnect&quot;:
<span class="nc" id="L1469">                return ssProxy.getInternodeTcpConnectTimeoutInMS();</span>
            case &quot;internodeuser&quot;:
<span class="nc" id="L1471">                return ssProxy.getInternodeTcpUserTimeoutInMS();</span>
            case &quot;internodestreaminguser&quot;:
<span class="nc" id="L1473">                return ssProxy.getInternodeStreamingTcpUserTimeoutInMS();</span>
            default:
<span class="nc" id="L1475">                throw new RuntimeException(&quot;Timeout type requires one of (&quot; + GetTimeout.TIMEOUT_TYPES + &quot;)&quot;);</span>
        }
    }

    @Deprecated
    public int getStreamThroughput()
    {
<span class="nc" id="L1482">        return ssProxy.getStreamThroughputMbitPerSec();</span>
    }

    public double getStreamThroughputAsDouble()
    {
<span class="nc" id="L1487">        return ssProxy.getStreamThroughputMbitPerSecAsDouble();</span>
    }

    @Deprecated
    public int getInterDCStreamThroughput()
    {
<span class="nc" id="L1493">        return ssProxy.getInterDCStreamThroughputMbitPerSec();</span>
    }

    public double getInterDCStreamThroughputAsDouble()
    {
<span class="nc" id="L1498">        return ssProxy.getInterDCStreamThroughputMbitPerSecAsDouble();</span>
    }

    public double getStreamThroughputMibAsDouble()
    {
<span class="nc" id="L1503">        return ssProxy.getStreamThroughputMebibytesPerSecAsDouble();</span>
    }

    public double getInterDCStreamThroughputMibAsDouble()
    {
<span class="nc" id="L1508">        return ssProxy.getInterDCStreamThroughputMebibytesPerSecAsDouble();</span>
    }

    public double getEntireSSTableStreamThroughput()
    {
<span class="nc" id="L1513">        return ssProxy.getEntireSSTableStreamThroughputMebibytesPerSecAsDouble();</span>
    }

    public double getEntireSSTableInterDCStreamThroughput()
    {
<span class="nc" id="L1518">        return ssProxy.getEntireSSTableInterDCStreamThroughputMebibytesPerSecAsDouble();</span>
    }

    public double getTraceProbability()
    {
<span class="nc" id="L1523">        return ssProxy.getTraceProbability();</span>
    }

    public int getExceptionCount()
    {
<span class="nc" id="L1528">        return (int)StorageMetrics.uncaughtExceptions.getCount();</span>
    }

    public Map&lt;String, Integer&gt; getDroppedMessages()
    {
<span class="nc" id="L1533">        return msProxy.getDroppedMessages();</span>
    }

    @Deprecated
    public void loadNewSSTables(String ksName, String cfName)
    {
<span class="nc" id="L1539">        ssProxy.loadNewSSTables(ksName, cfName);</span>
<span class="nc" id="L1540">    }</span>

    public List&lt;String&gt; importNewSSTables(String ksName, String cfName, Set&lt;String&gt; srcPaths, boolean resetLevel, boolean clearRepaired, boolean verifySSTables, boolean verifyTokens, boolean invalidateCaches, boolean extendedVerify, boolean copyData)
    {
<span class="nc" id="L1544">        return getCfsProxy(ksName, cfName).importNewSSTables(srcPaths, resetLevel, clearRepaired, verifySSTables, verifyTokens, invalidateCaches, extendedVerify, copyData);</span>
    }

    public void rebuildIndex(String ksName, String cfName, String... idxNames)
    {
<span class="nc" id="L1549">        ssProxy.rebuildSecondaryIndex(ksName, cfName, idxNames);</span>
<span class="nc" id="L1550">    }</span>

    public Map&lt;String, String&gt; getSimpleStatesWithPort()
    {
<span class="nc" id="L1554">        return fdProxy.getSimpleStatesWithPort();</span>
    }

    public String getGossipInfo(boolean withPort)
    {
<span class="nc" id="L1559">        return getGossipInfo(withPort, false);</span>
    }

    public String getGossipInfo(boolean withPort, boolean resolveIp)
    {
<span class="nc bnc" id="L1564" title="All 2 branches missed.">        if (resolveIp)</span>
<span class="nc bnc" id="L1565" title="All 2 branches missed.">            return withPort ? fdProxy.getAllEndpointStatesWithPortAndResolveIp() : fdProxy.getAllEndpointStatesWithResolveIp();</span>
        else
<span class="nc bnc" id="L1567" title="All 2 branches missed.">            return withPort ? fdProxy.getAllEndpointStatesWithPort() : fdProxy.getAllEndpointStates();</span>
    }

    public void stop(String string)
    {
<span class="nc" id="L1572">        compactionProxy.stopCompaction(string);</span>
<span class="nc" id="L1573">    }</span>

    public void setTimeout(String type, long value)
    {
<span class="nc bnc" id="L1577" title="All 2 branches missed.">        if (value &lt; 0)</span>
<span class="nc" id="L1578">            throw new RuntimeException(&quot;timeout must be non-negative&quot;);</span>

<span class="nc bnc" id="L1580" title="All 11 branches missed.">        switch (type)</span>
        {
            case &quot;misc&quot;:
<span class="nc" id="L1583">                ssProxy.setRpcTimeout(value);</span>
<span class="nc" id="L1584">                break;</span>
            case &quot;read&quot;:
<span class="nc" id="L1586">                ssProxy.setReadRpcTimeout(value);</span>
<span class="nc" id="L1587">                break;</span>
            case &quot;range&quot;:
<span class="nc" id="L1589">                ssProxy.setRangeRpcTimeout(value);</span>
<span class="nc" id="L1590">                break;</span>
            case &quot;write&quot;:
<span class="nc" id="L1592">                ssProxy.setWriteRpcTimeout(value);</span>
<span class="nc" id="L1593">                break;</span>
            case &quot;counterwrite&quot;:
<span class="nc" id="L1595">                ssProxy.setCounterWriteRpcTimeout(value);</span>
<span class="nc" id="L1596">                break;</span>
            case &quot;cascontention&quot;:
<span class="nc" id="L1598">                ssProxy.setCasContentionTimeout(value);</span>
<span class="nc" id="L1599">                break;</span>
            case &quot;truncate&quot;:
<span class="nc" id="L1601">                ssProxy.setTruncateRpcTimeout(value);</span>
<span class="nc" id="L1602">                break;</span>
            case &quot;internodeconnect&quot;:
<span class="nc" id="L1604">                ssProxy.setInternodeTcpConnectTimeoutInMS((int) value);</span>
<span class="nc" id="L1605">                break;</span>
            case &quot;internodeuser&quot;:
<span class="nc" id="L1607">                ssProxy.setInternodeTcpUserTimeoutInMS((int) value);</span>
<span class="nc" id="L1608">                break;</span>
            case &quot;internodestreaminguser&quot;:
<span class="nc" id="L1610">                ssProxy.setInternodeStreamingTcpUserTimeoutInMS((int) value);</span>
<span class="nc" id="L1611">                break;</span>
            default:
<span class="nc" id="L1613">                throw new RuntimeException(&quot;Timeout type requires one of (&quot; + GetTimeout.TIMEOUT_TYPES + &quot;)&quot;);</span>
        }
<span class="nc" id="L1615">    }</span>

    public void stopById(String compactionId)
    {
<span class="nc" id="L1619">        compactionProxy.stopCompactionById(compactionId);</span>
<span class="nc" id="L1620">    }</span>

    public void setStreamThroughput(int value)
    {
<span class="nc" id="L1624">        ssProxy.setStreamThroughputMbitPerSec(value);</span>
<span class="nc" id="L1625">    }</span>

    public void setStreamThroughputMiB(int value)
    {
<span class="nc" id="L1629">        ssProxy.setStreamThroughputMebibytesPerSec(value);</span>
<span class="nc" id="L1630">    }</span>

    public void setInterDCStreamThroughput(int value)
    {
<span class="nc" id="L1634">        ssProxy.setInterDCStreamThroughputMbitPerSec(value);</span>
<span class="nc" id="L1635">    }</span>

    public void setInterDCStreamThroughputMiB(int value)
    {
<span class="nc" id="L1639">        ssProxy.setInterDCStreamThroughputMebibytesPerSec(value);</span>
<span class="nc" id="L1640">    }</span>

    public void setEntireSSTableStreamThroughput(int value)
    {
<span class="nc" id="L1644">        ssProxy.setEntireSSTableStreamThroughputMebibytesPerSec(value);</span>
<span class="nc" id="L1645">    }</span>

    public void setEntireSSTableInterDCStreamThroughput(int value)
    {
<span class="nc" id="L1649">        ssProxy.setEntireSSTableInterDCStreamThroughputMebibytesPerSec(value);</span>
<span class="nc" id="L1650">    }</span>

    public void setTraceProbability(double value)
    {
<span class="nc" id="L1654">        ssProxy.setTraceProbability(value);</span>
<span class="nc" id="L1655">    }</span>

    public String getSchemaVersion()
    {
<span class="nc" id="L1659">        return ssProxy.getSchemaVersion();</span>
    }

    public List&lt;String&gt; describeRing(String keyspaceName, boolean withPort) throws IOException
    {
<span class="nc bnc" id="L1664" title="All 2 branches missed.">        return withPort ? ssProxy.describeRingWithPortJMX(keyspaceName) : ssProxy.describeRingJMX(keyspaceName);</span>
    }

    public void rebuild(String sourceDc, String keyspace, String tokens, String specificSources, boolean excludeLocalDatacenterNodes)
    {
<span class="fc" id="L1669">        ssProxy.rebuild(sourceDc, keyspace, tokens, specificSources, excludeLocalDatacenterNodes);</span>
<span class="fc" id="L1670">    }</span>

    public List&lt;String&gt; sampleKeyRange()
    {
<span class="nc" id="L1674">        return ssProxy.sampleKeyRange();</span>
    }

    public void resetLocalSchema() throws IOException
    {
<span class="nc" id="L1679">        ssProxy.resetLocalSchema();</span>
<span class="nc" id="L1680">    }</span>

    public void reloadLocalSchema()
    {
<span class="nc" id="L1684">        ssProxy.reloadLocalSchema();</span>
<span class="nc" id="L1685">    }</span>

    public boolean isFailed()
    {
<span class="fc" id="L1689">        return failed;</span>
    }

    public void failed()
    {
<span class="nc" id="L1694">        this.failed = true;</span>
<span class="nc" id="L1695">    }</span>

    public long getReadRepairAttempted()
    {
<span class="nc" id="L1699">        return spProxy.getReadRepairAttempted();</span>
    }

    public long getReadRepairRepairedBlocking()
    {
<span class="nc" id="L1704">        return spProxy.getReadRepairRepairedBlocking();</span>
    }

    public long getReadRepairRepairedBackground()
    {
<span class="nc" id="L1709">        return spProxy.getReadRepairRepairedBackground();</span>
    }

    // JMX getters for the o.a.c.metrics API below.
    /**
     * Retrieve cache metrics based on the cache type (KeyCache, RowCache, or CounterCache)
     * @param cacheType KeyCach, RowCache, or CounterCache
     * @param metricName Capacity, Entries, HitRate, Size, Requests or Hits.
     */
    public Object getCacheMetric(String cacheType, String metricName)
    {
        try
        {
<span class="nc bnc" id="L1722" title="All 5 branches missed.">            switch(metricName)</span>
            {
                case &quot;Capacity&quot;:
                case &quot;Entries&quot;:
                case &quot;HitRate&quot;:
                case &quot;Size&quot;:
<span class="nc" id="L1728">                    return JMX.newMBeanProxy(mbeanServerConn,</span>
                            new ObjectName(&quot;org.apache.cassandra.metrics:type=Cache,scope=&quot; + cacheType + &quot;,name=&quot; + metricName),
<span class="nc" id="L1730">                            CassandraMetricsRegistry.JmxGaugeMBean.class).getValue();</span>
                case &quot;Requests&quot;:
                case &quot;Hits&quot;:
                case &quot;Misses&quot;:
<span class="nc" id="L1734">                    return JMX.newMBeanProxy(mbeanServerConn,</span>
                            new ObjectName(&quot;org.apache.cassandra.metrics:type=Cache,scope=&quot; + cacheType + &quot;,name=&quot; + metricName),
<span class="nc" id="L1736">                            CassandraMetricsRegistry.JmxMeterMBean.class).getCount();</span>
                case &quot;MissLatency&quot;:
<span class="nc" id="L1738">                    return JMX.newMBeanProxy(mbeanServerConn,</span>
                            new ObjectName(&quot;org.apache.cassandra.metrics:type=Cache,scope=&quot; + cacheType + &quot;,name=&quot; + metricName),
<span class="nc" id="L1740">                            CassandraMetricsRegistry.JmxTimerMBean.class).getMean();</span>
                case &quot;MissLatencyUnit&quot;:
<span class="nc" id="L1742">                    return JMX.newMBeanProxy(mbeanServerConn,</span>
                            new ObjectName(&quot;org.apache.cassandra.metrics:type=Cache,scope=&quot; + cacheType + &quot;,name=MissLatency&quot;),
<span class="nc" id="L1744">                            CassandraMetricsRegistry.JmxTimerMBean.class).getDurationUnit();</span>
                default:
<span class="nc" id="L1746">                    throw new RuntimeException(&quot;Unknown Cache metric name &quot; + metricName);</span>

            }
        }
<span class="nc" id="L1750">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L1752">            throw new RuntimeException(e);</span>
        }
    }

    /**
     * Retrieve buffer pool metrics based on the buffer pool type
     * @param poolType networking chunk-cache
     * @param metricName UsedSize Size
     * @return
     */
    public Object getBufferPoolMetric(String poolType, String metricName)
    {
        try
        {
<span class="nc bnc" id="L1766" title="All 3 branches missed.">            switch (metricName)</span>
            {
                case &quot;UsedSize&quot;:
                case &quot;OverflowSize&quot;:
                case &quot;Capacity&quot;:
                case &quot;Size&quot;:
<span class="nc" id="L1772">                    return JMX.newMBeanProxy(mbeanServerConn,</span>
                           new ObjectName(&quot;org.apache.cassandra.metrics:type=BufferPool,scope=&quot; + poolType + &quot;,name=&quot; + metricName),
<span class="nc" id="L1774">                           CassandraMetricsRegistry.JmxGaugeMBean.class).getValue();</span>
                case &quot;Hits&quot;:
                case &quot;Misses&quot;:
<span class="nc" id="L1777">                    return JMX.newMBeanProxy(mbeanServerConn,</span>
                    new ObjectName(&quot;org.apache.cassandra.metrics:type=BufferPool,scope=&quot; + poolType + &quot;,name=&quot; + metricName),
<span class="nc" id="L1779">                    CassandraMetricsRegistry.JmxMeterMBean.class).getCount();</span>
                default:
<span class="nc" id="L1781">                    throw new RuntimeException(&quot;Unknown BufferPool metric name &quot; + metricName);</span>
            }
        }
<span class="nc" id="L1784">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L1786">            throw new RuntimeException(e);</span>
        }
    }

    private static Multimap&lt;String, String&gt; getJmxThreadPools(MBeanServerConnection mbeanServerConn)
    {
        try
        {
<span class="nc" id="L1794">            Multimap&lt;String, String&gt; threadPools = HashMultimap.create();</span>

<span class="nc" id="L1796">            Set&lt;ObjectName&gt; threadPoolObjectNames = mbeanServerConn.queryNames(</span>
                    new ObjectName(&quot;org.apache.cassandra.metrics:type=ThreadPools,*&quot;),
                    null);

<span class="nc bnc" id="L1800" title="All 2 branches missed.">            for (ObjectName oName : threadPoolObjectNames)</span>
            {
<span class="nc" id="L1802">                threadPools.put(oName.getKeyProperty(&quot;path&quot;), oName.getKeyProperty(&quot;scope&quot;));</span>
<span class="nc" id="L1803">            }</span>

<span class="nc" id="L1805">            return threadPools;</span>
        }
<span class="nc" id="L1807">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L1809">            throw new RuntimeException(&quot;Bad query to JMX server: &quot;, e);</span>
        }
<span class="nc" id="L1811">        catch (IOException e)</span>
        {
<span class="nc" id="L1813">            throw new RuntimeException(&quot;Error getting threadpool names from JMX&quot;, e);</span>
        }
    }

    public Object getThreadPoolMetric(String pathName, String poolName, String metricName)
    {
<span class="nc" id="L1819">      String name = String.format(&quot;org.apache.cassandra.metrics:type=ThreadPools,path=%s,scope=%s,name=%s&quot;,</span>
              pathName, poolName, metricName);

      try
      {
<span class="nc" id="L1824">          ObjectName oName = new ObjectName(name);</span>
<span class="nc bnc" id="L1825" title="All 2 branches missed.">          if (!mbeanServerConn.isRegistered(oName))</span>
          {
<span class="nc" id="L1827">              return &quot;N/A&quot;;</span>
          }

<span class="nc bnc" id="L1830" title="All 3 branches missed.">          switch (metricName)</span>
          {
              case ThreadPoolMetrics.ACTIVE_TASKS:
              case ThreadPoolMetrics.PENDING_TASKS:
              case ThreadPoolMetrics.COMPLETED_TASKS:
              case ThreadPoolMetrics.MAX_POOL_SIZE:
<span class="nc" id="L1836">                  return JMX.newMBeanProxy(mbeanServerConn, oName, JmxReporter.JmxGaugeMBean.class).getValue();</span>
              case ThreadPoolMetrics.TOTAL_BLOCKED_TASKS:
              case ThreadPoolMetrics.CURRENTLY_BLOCKED_TASKS:
<span class="nc" id="L1839">                  return JMX.newMBeanProxy(mbeanServerConn, oName, JmxReporter.JmxCounterMBean.class).getCount();</span>
              default:
<span class="nc" id="L1841">                  throw new AssertionError(&quot;Unknown ThreadPools metric name &quot; + metricName);</span>
          }
      }
<span class="nc" id="L1844">      catch (Exception e)</span>
      {
<span class="nc" id="L1846">          throw new RuntimeException(&quot;Error reading: &quot; + name, e);</span>
      }
    }

    /**
     * Retrieve threadpool paths and names for threadpools with metrics.
     * @return Multimap from path (internal, request, etc.) to name
     */
    public Multimap&lt;String, String&gt; getThreadPools()
    {
<span class="nc" id="L1856">        return getJmxThreadPools(mbeanServerConn);</span>
    }

    public int getNumberOfTables()
    {
<span class="nc" id="L1861">        return spProxy.getNumberOfTables();</span>
    }

    /**
     * Retrieve ColumnFamily metrics
     * @param ks Keyspace for which stats are to be displayed or null for the global value
     * @param cf ColumnFamily for which stats are to be displayed or null for the keyspace value (if ks supplied)
     * @param metricName View {@link TableMetrics}.
     */
    public Object getColumnFamilyMetric(String ks, String cf, String metricName)
    {
        try
        {
<span class="nc" id="L1874">            ObjectName oName = null;</span>
<span class="nc bnc" id="L1875" title="All 4 branches missed.">            if (!Strings.isNullOrEmpty(ks) &amp;&amp; !Strings.isNullOrEmpty(cf))</span>
            {
<span class="nc bnc" id="L1877" title="All 2 branches missed.">                String type = cf.contains(&quot;.&quot;) ? &quot;IndexTable&quot; : &quot;Table&quot;;</span>
<span class="nc" id="L1878">                oName = new ObjectName(String.format(&quot;org.apache.cassandra.metrics:type=%s,keyspace=%s,scope=%s,name=%s&quot;, type, ks, cf, metricName));</span>
<span class="nc" id="L1879">            }</span>
<span class="nc bnc" id="L1880" title="All 2 branches missed.">            else if (!Strings.isNullOrEmpty(ks))</span>
            {
<span class="nc" id="L1882">                oName = new ObjectName(String.format(&quot;org.apache.cassandra.metrics:type=Keyspace,keyspace=%s,name=%s&quot;, ks, metricName));</span>
            }
            else
            {
<span class="nc" id="L1886">                oName = new ObjectName(String.format(&quot;org.apache.cassandra.metrics:type=Table,name=%s&quot;, metricName));</span>
            }
<span class="nc bnc" id="L1888" title="All 5 branches missed.">            switch(metricName)</span>
            {
                case &quot;BloomFilterDiskSpaceUsed&quot;:
                case &quot;BloomFilterFalsePositives&quot;:
                case &quot;BloomFilterFalseRatio&quot;:
                case &quot;BloomFilterOffHeapMemoryUsed&quot;:
                case &quot;IndexSummaryOffHeapMemoryUsed&quot;:
                case &quot;CompressionMetadataOffHeapMemoryUsed&quot;:
                case &quot;CompressionRatio&quot;:
                case &quot;EstimatedColumnCountHistogram&quot;:
                case &quot;EstimatedPartitionSizeHistogram&quot;:
                case &quot;EstimatedPartitionCount&quot;:
                case &quot;KeyCacheHitRate&quot;:
                case &quot;LiveSSTableCount&quot;:
                case &quot;MaxSSTableDuration&quot;:
                case &quot;MaxSSTableSize&quot;:
                case &quot;OldVersionSSTableCount&quot;:
                case &quot;MaxPartitionSize&quot;:
                case &quot;MeanPartitionSize&quot;:
                case &quot;MemtableColumnsCount&quot;:
                case &quot;MemtableLiveDataSize&quot;:
                case &quot;MemtableOffHeapSize&quot;:
                case &quot;MinPartitionSize&quot;:
                case &quot;PercentRepaired&quot;:
                case &quot;BytesRepaired&quot;:
                case &quot;BytesUnrepaired&quot;:
                case &quot;BytesPendingRepair&quot;:
                case &quot;RecentBloomFilterFalsePositives&quot;:
                case &quot;RecentBloomFilterFalseRatio&quot;:
                case &quot;SnapshotsSize&quot;:
<span class="nc" id="L1918">                    return JMX.newMBeanProxy(mbeanServerConn, oName, CassandraMetricsRegistry.JmxGaugeMBean.class).getValue();</span>
                case &quot;LiveDiskSpaceUsed&quot;:
                case &quot;MemtableSwitchCount&quot;:
                case &quot;SpeculativeRetries&quot;:
                case &quot;TotalDiskSpaceUsed&quot;:
                case &quot;WriteTotalLatency&quot;:
                case &quot;ReadTotalLatency&quot;:
                case &quot;PendingFlushes&quot;:
<span class="nc" id="L1926">                    return JMX.newMBeanProxy(mbeanServerConn, oName, CassandraMetricsRegistry.JmxCounterMBean.class).getCount();</span>
                case &quot;CoordinatorReadLatency&quot;:
                case &quot;CoordinatorScanLatency&quot;:
                case &quot;ReadLatency&quot;:
                case &quot;WriteLatency&quot;:
<span class="nc" id="L1931">                    return JMX.newMBeanProxy(mbeanServerConn, oName, CassandraMetricsRegistry.JmxTimerMBean.class);</span>
                case &quot;LiveScannedHistogram&quot;:
                case &quot;SSTablesPerReadHistogram&quot;:
                case &quot;TombstoneScannedHistogram&quot;:
<span class="nc" id="L1935">                    return JMX.newMBeanProxy(mbeanServerConn, oName, CassandraMetricsRegistry.JmxHistogramMBean.class);</span>
                default:
<span class="nc" id="L1937">                    throw new RuntimeException(&quot;Unknown table metric &quot; + metricName);</span>
            }
        }
<span class="nc" id="L1940">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L1942">            throw new RuntimeException(e);</span>
        }
    }

    /**
     * Retrieve Proxy metrics
     * @param scope RangeSlice, Read or Write
     */
    public CassandraMetricsRegistry.JmxTimerMBean getProxyMetric(String scope)
    {
        try
        {
<span class="nc" id="L1954">            return JMX.newMBeanProxy(mbeanServerConn,</span>
                    new ObjectName(&quot;org.apache.cassandra.metrics:type=ClientRequest,scope=&quot; + scope + &quot;,name=Latency&quot;),
                    CassandraMetricsRegistry.JmxTimerMBean.class);
        }
<span class="nc" id="L1958">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L1960">            throw new RuntimeException(e);</span>
        }
    }

    public CassandraMetricsRegistry.JmxTimerMBean getMessagingQueueWaitMetrics(String verb)
    {
        try
        {
<span class="nc" id="L1968">            return JMX.newMBeanProxy(mbeanServerConn,</span>
                                     new ObjectName(&quot;org.apache.cassandra.metrics:name=&quot; + verb + &quot;-WaitLatency,type=Messaging&quot;),
                                     CassandraMetricsRegistry.JmxTimerMBean.class);
        }
<span class="nc" id="L1972">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L1974">            throw new RuntimeException(e);</span>
        }
    }

    /**
     * Retrieve Proxy metrics
     * @param metricName BytesCompacted, CompactionsAborted, CompactionsReduced,
     *                   SSTablesDroppedFromCompaction, CompletedTasks, PendingTasks, PendingTasksByTableName
     *                   or TotalCompactionsCompleted.
     */
    public Object getCompactionMetric(String metricName)
    {
        try
        {
<span class="nc bnc" id="L1988" title="All 4 branches missed.">            switch(metricName)</span>
            {
                case &quot;BytesCompacted&quot;:
                case &quot;CompactionsAborted&quot;:
                case &quot;CompactionsReduced&quot;:
                case &quot;SSTablesDroppedFromCompaction&quot;:
<span class="nc" id="L1994">                    return JMX.newMBeanProxy(mbeanServerConn,</span>
                            new ObjectName(&quot;org.apache.cassandra.metrics:type=Compaction,name=&quot; + metricName),
                            CassandraMetricsRegistry.JmxCounterMBean.class);
                case &quot;CompletedTasks&quot;:
                case &quot;PendingTasks&quot;:
                case &quot;PendingTasksByTableName&quot;:
<span class="nc" id="L2000">                    return JMX.newMBeanProxy(mbeanServerConn,</span>
                            new ObjectName(&quot;org.apache.cassandra.metrics:type=Compaction,name=&quot; + metricName),
<span class="nc" id="L2002">                            CassandraMetricsRegistry.JmxGaugeMBean.class).getValue();</span>
                case &quot;TotalCompactionsCompleted&quot;:
<span class="nc" id="L2004">                    return JMX.newMBeanProxy(mbeanServerConn,</span>
                            new ObjectName(&quot;org.apache.cassandra.metrics:type=Compaction,name=&quot; + metricName),
                            CassandraMetricsRegistry.JmxMeterMBean.class);
                default:
<span class="nc" id="L2008">                    throw new RuntimeException(&quot;Unknown compaction metric &quot; + metricName);</span>
            }
        }
<span class="nc" id="L2011">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L2013">            throw new RuntimeException(e);</span>
        }
    }

    /**
     * Retrieve Proxy metrics
     * @param metricName
     */
    public Object getClientMetric(String metricName)
    {
        try
        {
<span class="nc bnc" id="L2025" title="All 2 branches missed.">            switch(metricName)</span>
            {
                case &quot;connections&quot;: // List&lt;Map&lt;String,String&gt;&gt; - list of all native connections and their properties
                case &quot;connectedNativeClients&quot;: // number of connected native clients
                case &quot;connectedNativeClientsByUser&quot;: // number of native clients by username
                case &quot;clientsByProtocolVersion&quot;: // number of native clients by username
<span class="nc" id="L2031">                    return JMX.newMBeanProxy(mbeanServerConn,</span>
                            new ObjectName(&quot;org.apache.cassandra.metrics:type=Client,name=&quot; + metricName),
<span class="nc" id="L2033">                            CassandraMetricsRegistry.JmxGaugeMBean.class).getValue();</span>
                default:
<span class="nc" id="L2035">                    throw new RuntimeException(&quot;Unknown client metric &quot; + metricName);</span>
            }
        }
<span class="nc" id="L2038">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L2040">            throw new RuntimeException(e);</span>
        }
    }

    public Object getCidrFilteringMetric(String metricName)
    {
        try
        {
<span class="nc bnc" id="L2048" title="All 4 branches missed.">            switch(metricName)</span>
            {
                case CIDRAuthorizerMetrics.CIDR_CHECKS_LATENCY:
<span class="nc" id="L2051">                    return JMX.newMBeanProxy(mbeanServerConn,</span>
                                             new ObjectName(&quot;org.apache.cassandra.metrics:type=CIDRAuthorization,name=&quot;
                                                            + metricName),
<span class="nc" id="L2054">                                             CassandraMetricsRegistry.JmxTimerMBean.class).getMean();</span>
                case CIDRAuthorizerMetrics.CIDR_GROUPS_CACHE_RELOAD_COUNT:
<span class="nc" id="L2056">                    return JMX.newMBeanProxy(</span>
                        mbeanServerConn,
                        new ObjectName(&quot;org.apache.cassandra.metrics:type=CIDRGroupsMappingCache,name=&quot; + metricName),
<span class="nc" id="L2059">                        CassandraMetricsRegistry.JmxCounterMBean.class).getCount();</span>
                case CIDRAuthorizerMetrics.CIDR_GROUPS_CACHE_RELOAD_LATENCY:
                case CIDRAuthorizerMetrics.LOOKUP_CIDR_GROUPS_FOR_IP_LATENCY:
<span class="nc" id="L2062">                    return JMX.newMBeanProxy(</span>
                        mbeanServerConn,
                        new ObjectName(&quot;org.apache.cassandra.metrics:type=CIDRGroupsMappingCache,name=&quot; + metricName),
<span class="nc" id="L2065">                        CassandraMetricsRegistry.JmxTimerMBean.class).getMean();</span>
                default:
<span class="nc bnc" id="L2067" title="All 2 branches missed.">                    if (metricName.contains(CIDRAuthorizerMetrics.CIDR_ACCESSES_REJECTED_COUNT_PREFIX) ||</span>
<span class="nc bnc" id="L2068" title="All 2 branches missed.">                        metricName.contains(CIDRAuthorizerMetrics.CIDR_ACCESSES_ACCEPTED_COUNT_PREFIX))</span>
                    {
<span class="nc" id="L2070">                        return JMX.newMBeanProxy(</span>
                            mbeanServerConn,
                            new ObjectName(&quot;org.apache.cassandra.metrics:type=mymetricname,name=&quot; + metricName),
<span class="nc" id="L2073">                            CassandraMetricsRegistry.JmxCounterMBean.class).getCount();</span>
                    }

<span class="nc" id="L2076">                    throw new RuntimeException(&quot;Unknown metric &quot; + metricName);</span>
            }
        }
<span class="nc" id="L2079">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L2081">            throw new RuntimeException(e);</span>
        }
    }

    public Map&lt;String, Long&gt; getCountsMetricsFromVtable()
    {
<span class="nc" id="L2087">        return cfmProxy.getCountsMetricsFromVtable();</span>
    }

    public Map&lt;String, List&lt;Double&gt;&gt; getLatenciesMetricsFromVtable()
    {
<span class="nc" id="L2092">        return cfmProxy.getLatenciesMetricsFromVtable();</span>
    }

    /**
     * Retrieve Proxy metrics
     * @param metricName Exceptions, Load, TotalHints or TotalHintsInProgress.
     */
    public long getStorageMetric(String metricName)
    {
        try
        {
<span class="nc" id="L2103">            return JMX.newMBeanProxy(mbeanServerConn,</span>
                    new ObjectName(&quot;org.apache.cassandra.metrics:type=Storage,name=&quot; + metricName),
<span class="nc" id="L2105">                    CassandraMetricsRegistry.JmxCounterMBean.class).getCount();</span>
        }
<span class="nc" id="L2107">        catch (MalformedObjectNameException e)</span>
        {
<span class="nc" id="L2109">            throw new RuntimeException(e);</span>
        }
    }

    public Double[] metricPercentilesAsArray(CassandraMetricsRegistry.JmxHistogramMBean metric)
    {
<span class="nc" id="L2115">        return new Double[]{ metric.get50thPercentile(),</span>
<span class="nc" id="L2116">                Double.valueOf(metric.get75thPercentile()),</span>
<span class="nc" id="L2117">                Double.valueOf(metric.get95thPercentile()),</span>
<span class="nc" id="L2118">                Double.valueOf(metric.get98thPercentile()),</span>
<span class="nc" id="L2119">                Double.valueOf(metric.get99thPercentile()),</span>
<span class="nc" id="L2120">                Double.valueOf(metric.getMin()),</span>
<span class="nc" id="L2121">                Double.valueOf(metric.getMax())};</span>
    }

    public Double[] metricPercentilesAsArray(CassandraMetricsRegistry.JmxTimerMBean metric)
    {
<span class="nc" id="L2126">        return new Double[]{ Double.valueOf(metric.get50thPercentile()),</span>
<span class="nc" id="L2127">                             Double.valueOf(metric.get75thPercentile()),</span>
<span class="nc" id="L2128">                             Double.valueOf(metric.get95thPercentile()),</span>
<span class="nc" id="L2129">                             Double.valueOf(metric.get98thPercentile()),</span>
<span class="nc" id="L2130">                             Double.valueOf(metric.get99thPercentile()),</span>
<span class="nc" id="L2131">                             Double.valueOf(metric.getMin()),</span>
<span class="nc" id="L2132">                             Double.valueOf(metric.getMax())};</span>
    }

    public TabularData getCompactionHistory()
    {
<span class="nc" id="L2137">        return compactionProxy.getCompactionHistory();</span>
    }

    public void reloadTriggers()
    {
<span class="nc" id="L2142">        spProxy.reloadTriggerClasses();</span>
<span class="nc" id="L2143">    }</span>

    public void setLoggingLevel(String classQualifier, String level)
    {
        try
        {
<span class="nc" id="L2149">            ssProxy.setLoggingLevel(classQualifier, level);</span>
        }
<span class="nc" id="L2151">        catch (Exception e)</span>
        {
<span class="nc" id="L2153">            throw new RuntimeException(&quot;Error setting log for &quot; + classQualifier + &quot; on level &quot; + level + &quot;. Please check logback configuration and ensure to have &lt;jmxConfigurator /&gt; set&quot;, e);</span>
<span class="nc" id="L2154">        }</span>
<span class="nc" id="L2155">    }</span>

    public Map&lt;String, String&gt; getLoggingLevels()
    {
<span class="nc" id="L2159">        return ssProxy.getLoggingLevels();</span>
    }

    public long getPid()
    {
<span class="nc" id="L2164">        return NativeLibrary.getProcessID();</span>
    }

    public void resumeBootstrap(PrintStream out) throws IOException
    {
<span class="fc" id="L2169">        BootstrapMonitor monitor = new BootstrapMonitor(out);</span>
        try
        {
<span class="pc bpc" id="L2172" title="1 of 2 branches missed.">            if (jmxc != null)</span>
<span class="fc" id="L2173">                jmxc.addConnectionNotificationListener(monitor, null, null);</span>
<span class="fc" id="L2174">            ssProxy.addNotificationListener(monitor, null, null);</span>
<span class="pc bpc" id="L2175" title="1 of 2 branches missed.">            if (ssProxy.resumeBootstrap())</span>
            {
<span class="fc" id="L2177">                out.println(&quot;Resuming bootstrap&quot;);</span>
<span class="fc" id="L2178">                monitor.awaitCompletion();</span>
<span class="pc bpc" id="L2179" title="1 of 2 branches missed.">                if (monitor.getError() != null)</span>
<span class="nc" id="L2180">                    throw monitor.getError();</span>
            }
            else
            {
<span class="nc" id="L2184">                out.println(&quot;Node is already bootstrapped.&quot;);</span>
            }
        }
<span class="nc" id="L2187">        catch (Exception e)</span>
        {
<span class="nc" id="L2189">            throw new IOException(e);</span>
        }
        finally
        {
            try
            {
<span class="fc" id="L2195">                ssProxy.removeNotificationListener(monitor);</span>
<span class="pc bpc" id="L2196" title="1 of 2 branches missed.">                if (jmxc != null)</span>
<span class="fc" id="L2197">                    jmxc.removeConnectionNotificationListener(monitor);</span>
            }
<span class="nc" id="L2199">            catch (Throwable e)</span>
            {
<span class="nc" id="L2201">                out.println(&quot;Exception occurred during clean-up. &quot; + e);</span>
<span class="fc" id="L2202">            }</span>
        }
<span class="fc" id="L2204">    }</span>

    public Map&lt;String, List&lt;Integer&gt;&gt; getMaximumPoolSizes(List&lt;String&gt; stageNames)
    {
<span class="nc" id="L2208">        return ssProxy.getConcurrency(stageNames);</span>
    }

    public void setConcurrency(String stageName, int coreThreads, int maxConcurrency)
    {
<span class="nc" id="L2213">        ssProxy.setConcurrency(stageName, coreThreads, maxConcurrency);</span>
<span class="nc" id="L2214">    }</span>

    public void replayBatchlog() throws IOException
    {
        try
        {
<span class="fc" id="L2220">            bmProxy.forceBatchlogReplay();</span>
        }
<span class="nc" id="L2222">        catch (Exception e)</span>
        {
<span class="nc" id="L2224">            throw new IOException(e);</span>
<span class="fc" id="L2225">        }</span>
<span class="fc" id="L2226">    }</span>

    public TabularData getFailureDetectorPhilValues(boolean withPort)
    {
        try
        {
<span class="nc bnc" id="L2232" title="All 2 branches missed.">            return withPort ? fdProxy.getPhiValuesWithPort() : fdProxy.getPhiValues();</span>
        }
<span class="nc" id="L2234">        catch (OpenDataException e)</span>
        {
<span class="nc" id="L2236">            throw new RuntimeException(e);</span>
        }
    }

    public ActiveRepairServiceMBean getRepairServiceProxy()
    {
<span class="nc" id="L2242">        return arsProxy;</span>
    }

    public void reloadSslCerts() throws IOException
    {
<span class="nc" id="L2247">        msProxy.reloadSslCertificates();</span>
<span class="nc" id="L2248">    }</span>

    public void clearConnectionHistory()
    {
<span class="nc" id="L2252">        ssProxy.clearConnectionHistory();</span>
<span class="nc" id="L2253">    }</span>

    public void disableAuditLog()
    {
<span class="nc" id="L2257">        ssProxy.disableAuditLog();</span>
<span class="nc" id="L2258">    }</span>

    public void enableAuditLog(String loggerName, Map&lt;String, String&gt; parameters, String includedKeyspaces, String excludedKeyspaces,
                               String includedCategories, String excludedCategories, String includedUsers, String excludedUsers)
    {
<span class="nc" id="L2263">        ssProxy.enableAuditLog(loggerName, parameters, includedKeyspaces, excludedKeyspaces, includedCategories, excludedCategories, includedUsers, excludedUsers);</span>
<span class="nc" id="L2264">    }</span>

    public void enableAuditLog(String loggerName, String includedKeyspaces, String excludedKeyspaces, String includedCategories,
                               String excludedCategories, String includedUsers, String excludedUsers)
    {
<span class="nc" id="L2269">        this.enableAuditLog(loggerName, Collections.emptyMap(), includedKeyspaces, excludedKeyspaces, includedCategories, excludedCategories, includedUsers, excludedUsers);</span>
<span class="nc" id="L2270">    }</span>

    public void enableAuditLog(String loggerName, Map&lt;String, String&gt; parameters, String includedKeyspaces, String excludedKeyspaces, String includedCategories, String excludedCategories,
                               String includedUsers, String excludedUsers, Integer maxArchiveRetries, Boolean block, String rollCycle,
                               Long maxLogSize, Integer maxQueueWeight, String archiveCommand)
    {
<span class="nc" id="L2276">        ssProxy.enableAuditLog(loggerName, parameters, includedKeyspaces, excludedKeyspaces, includedCategories, excludedCategories, includedUsers, excludedUsers,</span>
                               maxArchiveRetries, block, rollCycle, maxLogSize, maxQueueWeight, archiveCommand);
<span class="nc" id="L2278">    }</span>

    public void enableOldProtocolVersions()
    {
<span class="nc" id="L2282">        ssProxy.enableNativeTransportOldProtocolVersions();</span>
<span class="nc" id="L2283">    }</span>

    public void disableOldProtocolVersions()
    {
<span class="nc" id="L2287">        ssProxy.disableNativeTransportOldProtocolVersions();</span>
<span class="nc" id="L2288">	}</span>

    public MessagingServiceMBean getMessagingServiceProxy()
    {
<span class="nc" id="L2292">        return msProxy;</span>
    }

    public void enableFullQueryLogger(String path, String rollCycle, Boolean blocking, int maxQueueWeight, long maxLogSize, @Nullable String archiveCommand, int maxArchiveRetries)
    {
<span class="nc" id="L2297">        ssProxy.enableFullQueryLogger(path, rollCycle, blocking, maxQueueWeight, maxLogSize, archiveCommand, maxArchiveRetries);</span>
<span class="nc" id="L2298">    }</span>

    public void stopFullQueryLogger()
    {
<span class="nc" id="L2302">        ssProxy.stopFullQueryLogger();</span>
<span class="nc" id="L2303">    }</span>

    public void resetFullQueryLogger()
    {
<span class="nc" id="L2307">        ssProxy.resetFullQueryLogger();</span>
<span class="nc" id="L2308">    }</span>

    public FullQueryLoggerOptions getFullQueryLoggerOptions()
    {
<span class="nc" id="L2312">        return FullQueryLoggerOptionsCompositeData.fromCompositeData(ssProxy.getFullQueryLoggerOptions());</span>
    }

    public AuditLogOptions getAuditLogOptions()
    {
<span class="nc" id="L2317">        return AuditLogOptionsCompositeData.fromCompositeData(almProxy.getAuditLogOptionsData());</span>
    }

    public void setDefaultKeyspaceReplicationFactor(int value)
    {
<span class="nc" id="L2322">        ssProxy.setDefaultKeyspaceReplicationFactor(value);</span>
<span class="nc" id="L2323">    }</span>

    public int getDefaultKeyspaceReplicationFactor()
    {
<span class="nc" id="L2327">        return ssProxy.getDefaultKeyspaceReplicationFactor();</span>
    }

    public void printSet(PrintStream out, String colName, Set&lt;String&gt; values)
    {
<span class="nc bnc" id="L2332" title="All 4 branches missed.">        if (values == null || values.isEmpty())</span>
<span class="nc" id="L2333">            return;</span>

<span class="nc" id="L2335">        TableBuilder table = new TableBuilder();</span>

<span class="nc" id="L2337">        table.add(colName + &quot;: &quot;);</span>

<span class="nc bnc" id="L2339" title="All 2 branches missed.">        for (String value : values)</span>
<span class="nc" id="L2340">            table.add(value);</span>

<span class="nc" id="L2342">        table.printTo(out);</span>
<span class="nc" id="L2343">    }</span>
}

class ColumnFamilyStoreMBeanIterator implements Iterator&lt;Map.Entry&lt;String, ColumnFamilyStoreMBean&gt;&gt;
{
    private MBeanServerConnection mbeanServerConn;
    Iterator&lt;Entry&lt;String, ColumnFamilyStoreMBean&gt;&gt; mbeans;

    public ColumnFamilyStoreMBeanIterator(MBeanServerConnection mbeanServerConn)
        throws MalformedObjectNameException, NullPointerException, IOException
<span class="nc" id="L2353">    {</span>
<span class="nc" id="L2354">        this.mbeanServerConn = mbeanServerConn;</span>
<span class="nc" id="L2355">        List&lt;Entry&lt;String, ColumnFamilyStoreMBean&gt;&gt; cfMbeans = getCFSMBeans(mbeanServerConn, &quot;ColumnFamilies&quot;);</span>
<span class="nc" id="L2356">        cfMbeans.addAll(getCFSMBeans(mbeanServerConn, &quot;IndexColumnFamilies&quot;));</span>
<span class="nc" id="L2357">        Collections.sort(cfMbeans, new Comparator&lt;Entry&lt;String, ColumnFamilyStoreMBean&gt;&gt;()</span>
<span class="nc" id="L2358">        {</span>
            public int compare(Entry&lt;String, ColumnFamilyStoreMBean&gt; e1, Entry&lt;String, ColumnFamilyStoreMBean&gt; e2)
            {
                //compare keyspace, then CF name, then normal vs. index
<span class="nc" id="L2362">                int keyspaceNameCmp = e1.getKey().compareTo(e2.getKey());</span>
<span class="nc bnc" id="L2363" title="All 2 branches missed.">                if(keyspaceNameCmp != 0)</span>
<span class="nc" id="L2364">                    return keyspaceNameCmp;</span>

                // get CF name and split it for index name
<span class="nc" id="L2367">                String e1CF[] = e1.getValue().getTableName().split(&quot;\\.&quot;);</span>
<span class="nc" id="L2368">                String e2CF[] = e2.getValue().getTableName().split(&quot;\\.&quot;);</span>
<span class="nc bnc" id="L2369" title="All 4 branches missed.">                assert e1CF.length &lt;= 2 &amp;&amp; e2CF.length &lt;= 2 : &quot;unexpected split count for table name&quot;;</span>

                //if neither are indexes, just compare CF names
<span class="nc bnc" id="L2372" title="All 4 branches missed.">                if(e1CF.length == 1 &amp;&amp; e2CF.length == 1)</span>
<span class="nc" id="L2373">                    return e1CF[0].compareTo(e2CF[0]);</span>

                //check if it's the same CF
<span class="nc" id="L2376">                int cfNameCmp = e1CF[0].compareTo(e2CF[0]);</span>
<span class="nc bnc" id="L2377" title="All 2 branches missed.">                if(cfNameCmp != 0)</span>
<span class="nc" id="L2378">                    return cfNameCmp;</span>

                // if both are indexes (for the same CF), compare them
<span class="nc bnc" id="L2381" title="All 4 branches missed.">                if(e1CF.length == 2 &amp;&amp; e2CF.length == 2)</span>
<span class="nc" id="L2382">                    return e1CF[1].compareTo(e2CF[1]);</span>

                //if length of e1CF is 1, it's not an index, so sort it higher
<span class="nc bnc" id="L2385" title="All 2 branches missed.">                return e1CF.length == 1 ? 1 : -1;</span>
            }
        });
<span class="nc" id="L2388">        mbeans = cfMbeans.iterator();</span>
<span class="nc" id="L2389">    }</span>

    private List&lt;Entry&lt;String, ColumnFamilyStoreMBean&gt;&gt; getCFSMBeans(MBeanServerConnection mbeanServerConn, String type)
            throws MalformedObjectNameException, IOException
    {
<span class="nc" id="L2394">        ObjectName query = new ObjectName(&quot;org.apache.cassandra.db:type=&quot; + type +&quot;,*&quot;);</span>
<span class="nc" id="L2395">        Set&lt;ObjectName&gt; cfObjects = mbeanServerConn.queryNames(query, null);</span>
<span class="nc" id="L2396">        List&lt;Entry&lt;String, ColumnFamilyStoreMBean&gt;&gt; mbeans = new ArrayList&lt;Entry&lt;String, ColumnFamilyStoreMBean&gt;&gt;(cfObjects.size());</span>
<span class="nc bnc" id="L2397" title="All 2 branches missed.">        for(ObjectName n : cfObjects)</span>
        {
<span class="nc" id="L2399">            String keyspaceName = n.getKeyProperty(&quot;keyspace&quot;);</span>
<span class="nc" id="L2400">            ColumnFamilyStoreMBean cfsProxy = JMX.newMBeanProxy(mbeanServerConn, n, ColumnFamilyStoreMBean.class);</span>
<span class="nc" id="L2401">            mbeans.add(new AbstractMap.SimpleImmutableEntry&lt;String, ColumnFamilyStoreMBean&gt;(keyspaceName, cfsProxy));</span>
<span class="nc" id="L2402">        }</span>
<span class="nc" id="L2403">        return mbeans;</span>
    }

    public boolean hasNext()
    {
<span class="nc" id="L2408">        return mbeans.hasNext();</span>
    }

    public Entry&lt;String, ColumnFamilyStoreMBean&gt; next()
    {
<span class="nc" id="L2413">        return mbeans.next();</span>
    }

    public void remove()
    {
<span class="nc" id="L2418">        throw new UnsupportedOperationException();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>