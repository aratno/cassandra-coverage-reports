<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PaxosStateTracker.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.service.paxos.uncommitted</a> &gt; <span class="el_source">PaxosStateTracker.java</span></div><h1>PaxosStateTracker.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.service.paxos.uncommitted;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.List;
import java.util.NoSuchElementException;

import com.google.common.base.Preconditions;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.cql3.QueryOptions;
import org.apache.cassandra.cql3.QueryProcessor;
import org.apache.cassandra.cql3.statements.SelectStatement;
import org.apache.cassandra.db.Clustering;
import org.apache.cassandra.db.Directories;
import org.apache.cassandra.db.Keyspace;
import org.apache.cassandra.db.ReadExecutionController;
import org.apache.cassandra.db.ReadQuery;
import org.apache.cassandra.db.SystemKeyspace;
import org.apache.cassandra.db.marshal.BytesType;
import org.apache.cassandra.db.marshal.ListType;
import org.apache.cassandra.db.marshal.UTF8Type;
import org.apache.cassandra.db.partitions.PartitionIterator;
import org.apache.cassandra.db.rows.Cell;
import org.apache.cassandra.db.rows.Row;
import org.apache.cassandra.db.rows.RowIterator;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.Schema;
import org.apache.cassandra.service.ClientState;
import org.apache.cassandra.service.paxos.Ballot;
import org.apache.cassandra.service.paxos.Commit;
import org.apache.cassandra.service.paxos.PaxosRepairHistory;
import org.apache.cassandra.utils.CloseableIterator;
import org.apache.cassandra.utils.FBUtilities;

import static org.apache.cassandra.config.CassandraRelevantProperties.FORCE_PAXOS_STATE_REBUILD;
import static org.apache.cassandra.config.CassandraRelevantProperties.SKIP_PAXOS_STATE_REBUILD;
import static org.apache.cassandra.config.CassandraRelevantProperties.TRUNCATE_BALLOT_METADATA;
import static org.apache.cassandra.db.SystemKeyspace.PAXOS_REPAIR_HISTORY;
import static org.apache.cassandra.schema.SchemaConstants.SYSTEM_KEYSPACE_NAME;

/**
 * Tracks uncommitted and ballot high/low bounds
 */
public class PaxosStateTracker
{
<span class="fc" id="L67">    private static final Logger logger = LoggerFactory.getLogger(PaxosStateTracker.class);</span>

    /** when starting with no data, skip rebuilding uncommitted data from the paxos table. */
    private static boolean skipRebuild()
    {
<span class="fc" id="L72">        return SKIP_PAXOS_STATE_REBUILD.getBoolean();</span>
    }

    private static boolean forceRebuild()
    {
<span class="fc" id="L77">        return FORCE_PAXOS_STATE_REBUILD.getBoolean();</span>
    }

    private static boolean truncateBallotMetadata()
    {
<span class="fc" id="L82">        return TRUNCATE_BALLOT_METADATA.getBoolean();</span>
    }

    private static final String DIRECTORY = &quot;system/&quot; + SystemKeyspace.PAXOS_REPAIR_STATE;

    private final PaxosUncommittedTracker uncommitted;
    private final PaxosBallotTracker ballots;
    private boolean rebuildNeeded;

    public PaxosStateTracker(PaxosUncommittedTracker uncommitted, PaxosBallotTracker ballots, boolean rebuildNeeded)
<span class="fc" id="L92">    {</span>
<span class="fc" id="L93">        this.uncommitted = uncommitted;</span>
<span class="fc" id="L94">        this.ballots = ballots;</span>
<span class="fc" id="L95">        this.rebuildNeeded = rebuildNeeded;</span>
<span class="fc" id="L96">    }</span>

    public boolean isRebuildNeeded()
    {
<span class="nc" id="L100">        return rebuildNeeded;</span>
    }

    static File stateDirectory(File dataDirectory)
    {
<span class="fc" id="L105">        return new File(dataDirectory, DIRECTORY);</span>
    }

    public static PaxosStateTracker create(File[] directories) throws IOException
    {
<span class="fc" id="L110">        File stateDirectory = null;</span>
<span class="fc" id="L111">        boolean hasExistingData = false;</span>

<span class="fc bfc" id="L113" title="All 2 branches covered.">        for (File directory : directories)</span>
        {
<span class="fc" id="L115">            File candidate = stateDirectory(directory);</span>
<span class="pc bpc" id="L116" title="1 of 4 branches missed.">            if (candidate.exists() &amp;&amp; new File(candidate, PaxosBallotTracker.FNAME).exists())</span>
            {
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">                Preconditions.checkState(!hasExistingData,</span>
                                         &quot;Multiple paxos repair metadata directories found (%s, %s), remove the older directory and restart.&quot;,
                                         stateDirectory, candidate);
<span class="fc" id="L121">                hasExistingData = true;</span>
<span class="fc" id="L122">                stateDirectory = candidate;</span>
            }
        }

<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (stateDirectory == null)</span>
<span class="fc" id="L127">            stateDirectory = stateDirectory(directories[0]);</span>

<span class="pc bpc" id="L129" title="1 of 4 branches missed.">        boolean rebuildNeeded = !hasExistingData || forceRebuild();</span>

<span class="pc bpc" id="L131" title="3 of 4 branches missed.">        if (truncateBallotMetadata() &amp;&amp; !rebuildNeeded)</span>
<span class="nc" id="L132">            logger.warn(&quot;{} was set to true, but {} was not and no rebuild is required. Ballot data will not be truncated&quot;,</span>
<span class="nc" id="L133">                        TRUNCATE_BALLOT_METADATA.getKey(), FORCE_PAXOS_STATE_REBUILD.getKey());</span>

<span class="fc bfc" id="L135" title="All 2 branches covered.">        if (rebuildNeeded)</span>
        {
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">            if (stateDirectory.exists())</span>
            {
<span class="nc" id="L139">                PaxosUncommittedTracker.truncate(stateDirectory);</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">                if (truncateBallotMetadata())</span>
<span class="nc" id="L141">                    PaxosBallotTracker.truncate(stateDirectory);</span>
            }
            else
            {
<span class="fc" id="L145">                stateDirectory.createDirectoriesIfNotExists();</span>
            }
        }

<span class="fc" id="L149">        PaxosUncommittedTracker uncommitted = PaxosUncommittedTracker.load(stateDirectory);</span>
<span class="fc" id="L150">        PaxosBallotTracker ballots = PaxosBallotTracker.load(stateDirectory);</span>

<span class="fc bfc" id="L152" title="All 2 branches covered.">        if (!rebuildNeeded)</span>
<span class="fc" id="L153">            uncommitted.start();</span>

<span class="fc" id="L155">        return new PaxosStateTracker(uncommitted, ballots, rebuildNeeded);</span>
    }

    public static PaxosStateTracker create(Directories.DataDirectories dataDirectories) throws IOException
    {
<span class="fc" id="L160">        return create(dataDirectories.getAllDirectories().stream().map(d -&gt; d.location).toArray(File[]::new));</span>
    }

    @SuppressWarnings(&quot;resource&quot;)
    private void rebuildUncommittedData() throws IOException
    {
<span class="fc" id="L166">        logger.info(&quot;Beginning uncommitted paxos data rebuild. Set -D{}=true and restart to skip&quot;, SKIP_PAXOS_STATE_REBUILD.getKey());</span>

<span class="fc" id="L168">        String queryStr = &quot;SELECT * FROM &quot; + SYSTEM_KEYSPACE_NAME + '.' + SystemKeyspace.PAXOS;</span>
<span class="fc" id="L169">        SelectStatement stmt = (SelectStatement) QueryProcessor.parseStatement(queryStr).prepare(ClientState.forInternalCalls());</span>
<span class="fc" id="L170">        ReadQuery query = stmt.getQuery(QueryOptions.DEFAULT, FBUtilities.nowInSeconds());</span>
<span class="fc" id="L171">        try (ReadExecutionController controller = query.executionController();</span>
<span class="fc" id="L172">             PartitionIterator partitions = query.executeInternal(controller);</span>
<span class="fc" id="L173">             PaxosKeyStateRowsIterator rows = new PaxosKeyStateRowsIterator(partitions))</span>
        {
<span class="fc" id="L175">            uncommitted.rebuild(rows);</span>
        }
<span class="fc" id="L177">    }</span>

    class PaxosKeyStateRowsIterator implements CloseableIterator&lt;PaxosKeyState&gt;
    {
        // note: this is not closed by this iterator
        final PartitionIterator partitions;

<span class="fc" id="L184">        RowIterator partition = null;</span>
<span class="fc" id="L185">        PaxosKeyState next = null;</span>

        PaxosKeyStateRowsIterator(PartitionIterator partitions)
<span class="fc" id="L188">        {</span>
<span class="fc" id="L189">            this.partitions = partitions;</span>
<span class="fc" id="L190">        }</span>

        @Override
        public boolean hasNext()
        {
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">            if (next != null)</span>
<span class="nc" id="L196">                return true;</span>

            while (true)
            {
<span class="pc bpc" id="L200" title="3 of 4 branches missed.">                if (partition != null &amp;&amp; partition.hasNext())</span>
                {
<span class="nc" id="L202">                    PaxosKeyState commitState = PaxosRows.getCommitState(partition.partitionKey(), partition.next(), null);</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">                    if (commitState == null)</span>
<span class="nc" id="L204">                        continue;</span>
<span class="nc" id="L205">                    ballots.updateHighBound(commitState.ballot);</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">                    if (!commitState.committed)</span>
                    {
<span class="nc" id="L208">                        next = commitState;</span>
<span class="nc" id="L209">                        return true;</span>
                    }
<span class="nc" id="L211">                }</span>
                else
                {
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">                    if (partition != null)</span>
                    {
<span class="nc" id="L216">                        partition.close();</span>
<span class="nc" id="L217">                        partition = null;</span>
                    }

<span class="pc bpc" id="L220" title="1 of 2 branches missed.">                    if (!partitions.hasNext())</span>
<span class="fc" id="L221">                        return false;</span>

<span class="nc" id="L223">                    partition = partitions.next();</span>
                }
            }
        }

        @Override
        public PaxosKeyState next()
        {
<span class="nc bnc" id="L231" title="All 4 branches missed.">            if (next == null &amp;&amp; !hasNext())</span>
<span class="nc" id="L232">                throw new NoSuchElementException();</span>
<span class="nc" id="L233">            PaxosKeyState next = this.next;</span>
<span class="nc" id="L234">            this.next = null;</span>
<span class="nc" id="L235">            return next;</span>
        }

        @Override
        public void close()
        {
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">            if (partition != null)</span>
            {
<span class="nc" id="L243">                partition.close();</span>
<span class="nc" id="L244">                partition = null;</span>
            }
<span class="fc" id="L246">        }</span>
    }

    private void updateLowBoundFromRepairHistory() throws IOException
    {
<span class="fc" id="L251">        String queryStr = &quot;SELECT * FROM &quot; + SYSTEM_KEYSPACE_NAME + '.' + PAXOS_REPAIR_HISTORY;</span>
<span class="fc" id="L252">        SelectStatement stmt = (SelectStatement) QueryProcessor.parseStatement(queryStr).prepare(ClientState.forInternalCalls());</span>
<span class="fc" id="L253">        ReadQuery query = stmt.getQuery(QueryOptions.DEFAULT, FBUtilities.nowInSeconds());</span>

<span class="fc" id="L255">        Ballot lowBound = null;</span>
<span class="fc" id="L256">        ListType&lt;ByteBuffer&gt; listType = ListType.getInstance(BytesType.instance, false);</span>
<span class="fc" id="L257">        ColumnMetadata pointsColumn = ColumnMetadata.regularColumn(SYSTEM_KEYSPACE_NAME, PAXOS_REPAIR_HISTORY, &quot;points&quot;, listType);</span>
<span class="fc" id="L258">        try (ReadExecutionController controller = query.executionController(); PartitionIterator partitions = query.executeInternal(controller))</span>
        {
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">            while (partitions.hasNext())</span>
            {
<span class="nc" id="L262">                try (RowIterator partition = partitions.next())</span>
                {
<span class="nc" id="L264">                    String keyspaceName = UTF8Type.instance.compose(partition.partitionKey().getKey());</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">                    if (Schema.instance.getKeyspaceMetadata(keyspaceName) == null)</span>
                        continue;

<span class="nc" id="L268">                    Keyspace.open(keyspaceName);</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">                    while (partition.hasNext())</span>
                    {
<span class="nc" id="L271">                        Row row = partition.next();</span>
<span class="nc" id="L272">                        Clustering clustering = row.clustering();</span>
<span class="nc" id="L273">                        String tableName = UTF8Type.instance.compose(clustering.get(0), clustering.accessor());</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">                        if (Schema.instance.getTableMetadata(keyspaceName, tableName) == null)</span>
<span class="nc" id="L275">                            continue;</span>

<span class="nc" id="L277">                        Cell pointsCell = row.getCell(pointsColumn);</span>
<span class="nc" id="L278">                        List&lt;ByteBuffer&gt; points = listType.compose(pointsCell.value(), pointsCell.accessor());</span>
<span class="nc" id="L279">                        PaxosRepairHistory history = PaxosRepairHistory.fromTupleBufferList(points);</span>
<span class="nc" id="L280">                        lowBound = Commit.latest(lowBound, history.maxLowBound());</span>
<span class="nc" id="L281">                    }</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">                }</span>
            }
        }
<span class="fc" id="L285">        ballots.updateLowBound(lowBound);</span>
<span class="fc" id="L286">    }</span>

    public void maybeRebuild() throws IOException
    {
<span class="fc bfc" id="L290" title="All 2 branches covered.">        if (!rebuildNeeded)</span>
<span class="fc" id="L291">            return;</span>

<span class="pc bpc" id="L293" title="1 of 2 branches missed.">        if (truncateBallotMetadata())</span>
        {
<span class="nc" id="L295">            logger.info(&quot;Truncating {}.{}&quot;, SYSTEM_KEYSPACE_NAME, PAXOS_REPAIR_HISTORY);</span>
<span class="nc" id="L296">            Keyspace.open(SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(PAXOS_REPAIR_HISTORY).truncateBlocking();</span>
        }

<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        if (!skipRebuild())</span>
        {
<span class="fc" id="L301">            rebuildUncommittedData();</span>

<span class="pc bpc" id="L303" title="1 of 2 branches missed.">            if (!truncateBallotMetadata()) // no point doing this if we just truncated the repair history table</span>
<span class="fc" id="L304">                updateLowBoundFromRepairHistory();</span>
<span class="fc" id="L305">            logger.info(&quot;Uncommitted paxos data rebuild completed&quot;);</span>
        }
<span class="fc" id="L307">        uncommitted.start();</span>
<span class="fc" id="L308">        ballots.flush();   // explicitly flush since a missing ballot file on startup indicates a rebuild is needed</span>
<span class="fc" id="L309">        rebuildNeeded = false;</span>
<span class="fc" id="L310">    }</span>

    public PaxosUncommittedTracker uncommitted()
    {
<span class="fc" id="L314">        return uncommitted;</span>
    }

    public PaxosBallotTracker ballots()
    {
<span class="fc" id="L319">        return ballots;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>