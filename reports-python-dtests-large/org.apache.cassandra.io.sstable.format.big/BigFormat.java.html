<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BigFormat.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.io.sstable.format.big</a> &gt; <span class="el_source">BigFormat.java</span></div><h1>BigFormat.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.io.sstable.format.big;

import java.io.IOException;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.cache.KeyCacheKey;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
import org.apache.cassandra.db.memtable.Flushing;
import org.apache.cassandra.dht.IPartitioner;
import org.apache.cassandra.io.sstable.Component;
import org.apache.cassandra.io.sstable.Descriptor;
import org.apache.cassandra.io.sstable.GaugeProvider;
import org.apache.cassandra.io.sstable.IScrubber;
import org.apache.cassandra.io.sstable.MetricsProviders;
import org.apache.cassandra.io.sstable.SSTable;
import org.apache.cassandra.io.sstable.filter.BloomFilterMetrics;
import org.apache.cassandra.io.sstable.format.AbstractSSTableFormat;
import org.apache.cassandra.io.sstable.format.SSTableFormat;
import org.apache.cassandra.io.sstable.format.SSTableReaderLoadingBuilder;
import org.apache.cassandra.io.sstable.format.SSTableWriter;
import org.apache.cassandra.io.sstable.format.SortedTableScrubber;
import org.apache.cassandra.io.sstable.format.Version;
import org.apache.cassandra.io.sstable.indexsummary.IndexSummaryMetrics;
import org.apache.cassandra.io.sstable.keycache.KeyCacheMetrics;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.net.MessagingService;
import org.apache.cassandra.schema.TableMetadataRef;
import org.apache.cassandra.service.CacheService;
import org.apache.cassandra.utils.JVMStabilityInspector;
import org.apache.cassandra.utils.OutputHandler;
import org.apache.cassandra.utils.Pair;

import static org.apache.cassandra.io.sstable.format.SSTableFormat.Components.DATA;

/**
 * Legacy bigtable format. Components and approximate lifecycle:
 * &lt;br&gt;
 * {@link SSTableFormat.Components}
 * &lt;br&gt;
 * {@link Components#ALL_COMPONENTS}
 *  &lt;ul&gt;
 *     &lt;li&gt;
 *       {@link Components#SUMMARY}: When searching for a PK we go here for a first approximation on where to look in the index file. It is
 *       a small sampling of the Index entries intended for a first fast search in-memory.
 *       &lt;p&gt;&lt;/p&gt;
 *       {@link org.apache.cassandra.io.sstable.indexsummary.IndexSummary}
 *       &lt;br&gt;
 *       {@link IndexSummaryComponent}
 *       &lt;p&gt;&lt;/p&gt;
 *     &lt;/li&gt;
 *     &lt;li&gt;
 *       {@link Components#PRIMARY_INDEX}: We'll land here in the approximate area where to look for the PK thanks to the Summary. Now we'll search for
 *       the exact PK to get it's exact position in the data file.
 *       &lt;p&gt;&lt;/p&gt;
 *       {@link BigTableWriter#indexWriter}
 *       &lt;br&gt;
 *       {@link RowIndexEntry}
 *       &lt;br&gt;
 *       {@link org.apache.cassandra.io.sstable.IndexInfo}
 *       &lt;br&gt;
 *       {@link org.apache.cassandra.io.sstable.format.IndexComponent}
 *       &lt;p&gt;&lt;/p&gt;
 *     &lt;/li&gt;
 *     &lt;li&gt;
 *       {@link Components#DATA}: The actual data/partitions file as an array or partitions. Each partition has the form:
 *       &lt;ul&gt;
 *       &lt;li&gt;A partition header&lt;/li&gt;
 *       &lt;li&gt;Maybe a static row&lt;/li&gt;
 *       &lt;li&gt;Rows or range tombstone&lt;/li&gt;
 *       &lt;/ul&gt;
 *       I.e. upon flush {@link Flushing.FlushRunnable#writeSortedContents}
 *       &lt;br&gt;
 *       Down to {@link org.apache.cassandra.io.sstable.format.SortedTableWriter#startPartition}
 *       &lt;br&gt;
 *       Down to {@link org.apache.cassandra.io.sstable.format.SortedTablePartitionWriter#start}
 *       &lt;br&gt;
 *       {@link org.apache.cassandra.io.sstable.format.DataComponent}
 *       &lt;p&gt;&lt;/p&gt;
 *     &lt;/li&gt;
 *     &lt;li&gt;
 *       {@link Components#STATS}: Stats on the data such as min timestamps to later vint encode TTL, markForDeleteAt, etc
 *       &lt;p&gt;&lt;/p&gt;
 *       {@link org.apache.cassandra.db.rows.EncodingStats}
 *       &lt;br&gt;
 *       {@link org.apache.cassandra.io.sstable.format.StatsComponent}
 *       &lt;p&gt;&lt;/p&gt;
 *     &lt;/li&gt;
 *     &lt;li&gt;
 *       {@link Components#COMPRESSION_INFO}: Contains compresion metadata
 *       &lt;p&gt;&lt;/p&gt;
 *       {@link org.apache.cassandra.io.compress.CompressedSequentialWriter}
 *       &lt;br&gt;
 *       {@link org.apache.cassandra.io.compress.CompressionMetadata}
 *       &lt;br&gt;
 *       {@link org.apache.cassandra.io.sstable.format.CompressionInfoComponent}
 *       &lt;p&gt;&lt;/p&gt;
 *     &lt;/li&gt;
 *     &lt;li&gt;
 *       {@link Components#DIGEST}: The digest supporting the compression
 *       &lt;p&gt;&lt;/p&gt;
 *       {@link org.apache.cassandra.io.compress.CompressedSequentialWriter}
 *       &lt;br&gt;
 *       {@link org.apache.cassandra.io.util.ChecksumWriter}
 *       &lt;p&gt;&lt;/p&gt;
 *     &lt;/li&gt;
 *     &lt;li&gt;
 *       {@link Components#FILTER}: Bloom filter for data files
 *       &lt;p&gt;&lt;/p&gt;
 *       {@link org.apache.cassandra.io.sstable.format.FilterComponent}
 *       &lt;br&gt;
 *       {@link org.apache.cassandra.utils.BloomFilterSerializer}
 *       &lt;p&gt;&lt;/p&gt;
 *     &lt;/li&gt;
 *     &lt;li&gt;
 *       {@link Components#CRC}: CRC for the data
 *       &lt;p&gt;&lt;/p&gt;
 *       {@link org.apache.cassandra.io.util.ChecksummedSequentialWriter}
 *       &lt;br&gt;
 *       {@link org.apache.cassandra.io.util.ChecksumWriter}
 *       &lt;p&gt;&lt;/p&gt;
 *     &lt;/li&gt;
 *     &lt;li&gt;
 *       {@link Components#TOC}: List of all the components for the SSTable
 *       &lt;p&gt;&lt;/p&gt;
 *       {@link org.apache.cassandra.io.sstable.format.TOCComponent}
 *     &lt;/li&gt;
 *   &lt;/ul&gt;
 *
 */
public class BigFormat extends AbstractSSTableFormat&lt;BigTableReader, BigTableWriter&gt;
{
<span class="fc" id="L166">    private final static Logger logger = LoggerFactory.getLogger(BigFormat.class);</span>

    public static final String NAME = &quot;big&quot;;

<span class="fc" id="L170">    private final Version latestVersion = new BigVersion(this, BigVersion.current_version);</span>
<span class="fc" id="L171">    private final BigTableReaderFactory readerFactory = new BigTableReaderFactory();</span>
<span class="fc" id="L172">    private final BigTableWriterFactory writerFactory = new BigTableWriterFactory();</span>

<span class="nc" id="L174">    public static class Components extends SSTableFormat.Components</span>
    {
<span class="nc" id="L176">        public static class Types extends SSTableFormat.Components.Types</span>
        {
            // index of the row keys with pointers to their positions in the data file
<span class="fc" id="L179">            public static final Component.Type PRIMARY_INDEX = Component.Type.createSingleton(&quot;PRIMARY_INDEX&quot;, &quot;Index.db&quot;, true, BigFormat.class);</span>
            // holds SSTable Index Summary (sampling of Index component)
<span class="fc" id="L181">            public static final Component.Type SUMMARY = Component.Type.createSingleton(&quot;SUMMARY&quot;, &quot;Summary.db&quot;, true, BigFormat.class);</span>
        }

<span class="fc" id="L184">        public final static Component PRIMARY_INDEX = Types.PRIMARY_INDEX.getSingleton();</span>
<span class="fc" id="L185">        public final static Component SUMMARY = Types.SUMMARY.getSingleton();</span>

<span class="fc" id="L187">        private static final Set&lt;Component&gt; BATCH_COMPONENTS = ImmutableSet.of(DATA,</span>
                                                                               PRIMARY_INDEX,
                                                                               COMPRESSION_INFO,
                                                                               FILTER,
                                                                               STATS);

<span class="fc" id="L193">        private static final Set&lt;Component&gt; PRIMARY_COMPONENTS = ImmutableSet.of(DATA,</span>
                                                                                 PRIMARY_INDEX);

<span class="fc" id="L196">        private static final Set&lt;Component&gt; GENERATED_ON_LOAD_COMPONENTS = ImmutableSet.of(FILTER, SUMMARY);</span>

<span class="fc" id="L198">        private static final Set&lt;Component&gt; MUTABLE_COMPONENTS = ImmutableSet.of(STATS,</span>
                                                                                 SUMMARY);

<span class="fc" id="L201">        private static final Set&lt;Component&gt; UPLOAD_COMPONENTS = ImmutableSet.of(DATA,</span>
                                                                                PRIMARY_INDEX,
                                                                                SUMMARY,
                                                                                COMPRESSION_INFO,
                                                                                STATS);
<span class="fc" id="L206">        private static final Set&lt;Component&gt; ALL_COMPONENTS = ImmutableSet.of(DATA,</span>
                                                                             PRIMARY_INDEX,
                                                                             STATS,
                                                                             COMPRESSION_INFO,
                                                                             FILTER,
                                                                             SUMMARY,
                                                                             DIGEST,
                                                                             CRC,
                                                                             TOC);
    }

    public BigFormat(Map&lt;String, String&gt; options)
    {
<span class="fc" id="L219">        super(NAME, options);</span>
<span class="fc" id="L220">    }</span>

    public static boolean is(SSTableFormat&lt;?, ?&gt; format)
    {
<span class="fc" id="L224">        return format.name().equals(NAME);</span>
    }

    public static BigFormat getInstance()
    {
<span class="fc" id="L229">        return (BigFormat) Objects.requireNonNull(DatabaseDescriptor.getSSTableFormats().get(NAME), &quot;Unknown SSTable format: &quot; + NAME);</span>
    }

    public static boolean isSelected()
    {
<span class="nc" id="L234">        return is(DatabaseDescriptor.getSelectedSSTableFormat());</span>
    }

    @Override
    public Version getLatestVersion()
    {
<span class="fc" id="L240">        return latestVersion;</span>
    }

    @Override
    public Version getVersion(String version)
    {
<span class="fc" id="L246">        return new BigVersion(this, version);</span>
    }

    @Override
    public BigTableWriterFactory getWriterFactory()
    {
<span class="fc" id="L252">        return writerFactory;</span>
    }

    @Override
    public BigTableReaderFactory getReaderFactory()
    {
<span class="fc" id="L258">        return readerFactory;</span>
    }

    @Override
    public Set&lt;Component&gt; allComponents()
    {
<span class="fc" id="L264">        return Components.ALL_COMPONENTS;</span>
    }

    @Override
    public Set&lt;Component&gt; primaryComponents()
    {
<span class="fc" id="L270">        return Components.PRIMARY_COMPONENTS;</span>
    }

    @Override
    public Set&lt;Component&gt; batchComponents()
    {
<span class="nc" id="L276">        return Components.BATCH_COMPONENTS;</span>
    }

    @Override
    public Set&lt;Component&gt; uploadComponents()
    {
<span class="nc" id="L282">        return Components.UPLOAD_COMPONENTS;</span>
    }

    @Override
    public Set&lt;Component&gt; mutableComponents()
    {
<span class="fc" id="L288">        return Components.MUTABLE_COMPONENTS;</span>
    }

    @Override
    public Set&lt;Component&gt; generatedOnLoadComponents()
    {
<span class="nc" id="L294">        return Components.GENERATED_ON_LOAD_COMPONENTS;</span>
    }

    @Override
    public SSTableFormat.KeyCacheValueSerializer&lt;BigTableReader, RowIndexEntry&gt; getKeyCacheValueSerializer()
    {
<span class="nc" id="L300">        return KeyCacheValueSerializer.instance;</span>
    }

    @Override
    public IScrubber getScrubber(ColumnFamilyStore cfs, LifecycleTransaction transaction, OutputHandler outputHandler, IScrubber.Options options)
    {
<span class="nc" id="L306">        Preconditions.checkArgument(cfs.metadata().equals(transaction.onlyOne().metadata()), &quot;SSTable metadata does not match current definition&quot;);</span>
<span class="nc" id="L307">        return new BigTableScrubber(cfs, transaction, outputHandler, options);</span>
    }

    @Override
    public MetricsProviders getFormatSpecificMetricsProviders()
    {
<span class="fc" id="L313">        return BigTableSpecificMetricsProviders.instance;</span>
    }

    @Override
    public void deleteOrphanedComponents(Descriptor descriptor, Set&lt;Component&gt; components)
    {
<span class="fc" id="L319">        SortedTableScrubber.deleteOrphanedComponents(descriptor, components);</span>
<span class="fc" id="L320">    }</span>

    private void delete(Descriptor desc, List&lt;Component&gt; components)
    {
<span class="fc" id="L324">        logger.info(&quot;Deleting sstable: {}&quot;, desc);</span>

<span class="pc bpc" id="L326" title="1 of 2 branches missed.">        if (components.remove(DATA))</span>
<span class="fc" id="L327">            components.add(0, DATA); // DATA component should be first</span>
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">        if (components.remove(Components.SUMMARY))</span>
<span class="fc" id="L329">            components.add(Components.SUMMARY); // SUMMARY component should be last (IDK why)</span>

<span class="fc bfc" id="L331" title="All 2 branches covered.">        for (Component component : components)</span>
        {
<span class="fc" id="L333">            logger.trace(&quot;Deleting component {} of {}&quot;, component, desc);</span>
<span class="fc" id="L334">            desc.fileFor(component).deleteIfExists();</span>
<span class="fc" id="L335">        }</span>
<span class="fc" id="L336">    }</span>

    @Override
    public void delete(Descriptor desc)
    {
        try
        {
            // remove key cache entries for the sstable being deleted
<span class="fc" id="L344">            Iterator&lt;KeyCacheKey&gt; it = CacheService.instance.keyCache.keyIterator();</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">            while (it.hasNext())</span>
            {
<span class="fc" id="L347">                KeyCacheKey key = it.next();</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">                if (key.desc.equals(desc))</span>
<span class="fc" id="L349">                    it.remove();</span>
<span class="fc" id="L350">            }</span>

<span class="fc" id="L352">            delete(desc, Lists.newArrayList(Sets.intersection(allComponents(), desc.discoverComponents())));</span>
        }
<span class="nc" id="L354">        catch (Throwable t)</span>
        {
<span class="nc" id="L356">            JVMStabilityInspector.inspectThrowable(t);</span>
<span class="fc" id="L357">        }</span>
<span class="fc" id="L358">    }</span>

<span class="nc" id="L360">    static class KeyCacheValueSerializer implements SSTableFormat.KeyCacheValueSerializer&lt;BigTableReader, RowIndexEntry&gt;</span>
    {
<span class="nc" id="L362">        private final static KeyCacheValueSerializer instance = new KeyCacheValueSerializer();</span>

        @Override
        public void skip(DataInputPlus input) throws IOException
        {
<span class="nc" id="L367">            RowIndexEntry.Serializer.skipForCache(input, getInstance().latestVersion);</span>
<span class="nc" id="L368">        }</span>

        @Override
        public RowIndexEntry deserialize(BigTableReader reader, DataInputPlus input) throws IOException
        {
<span class="nc" id="L373">            return reader.deserializeKeyCacheValue(input);</span>
        }

        @Override
        public void serialize(RowIndexEntry entry, DataOutputPlus output) throws IOException
        {
<span class="nc" id="L379">            entry.serializeForCache(output);</span>
<span class="nc" id="L380">        }</span>
    }

<span class="fc" id="L383">    static class BigTableReaderFactory implements SSTableReaderFactory&lt;BigTableReader, BigTableReader.Builder&gt;</span>
    {
        @Override
        public BigTableReader.Builder builder(Descriptor descriptor)
        {
<span class="fc" id="L388">            return new BigTableReader.Builder(descriptor);</span>
        }

        @Override
        public SSTableReaderLoadingBuilder&lt;BigTableReader, BigTableReader.Builder&gt; loadingBuilder(Descriptor descriptor,
                                                                                                  TableMetadataRef tableMetadataRef,
                                                                                                  Set&lt;Component&gt; components)
        {
<span class="fc" id="L396">            return new BigSSTableReaderLoadingBuilder(new SSTable.Builder&lt;&gt;(descriptor).setTableMetadataRef(tableMetadataRef)</span>
<span class="fc" id="L397">                                                                                       .setComponents(components));</span>
        }

        @Override
        public Pair&lt;DecoratedKey, DecoratedKey&gt; readKeyRange(Descriptor descriptor, IPartitioner partitioner) throws IOException
        {
<span class="nc" id="L403">            return IndexSummaryComponent.loadFirstAndLastKey(descriptor.fileFor(Components.SUMMARY), partitioner);</span>
        }

        @Override
        public Class&lt;BigTableReader&gt; getReaderClass()
        {
<span class="nc" id="L409">            return BigTableReader.class;</span>
        }
    }

<span class="fc" id="L413">    static class BigTableWriterFactory implements SSTableWriterFactory&lt;BigTableWriter, BigTableWriter.Builder&gt;</span>
    {
        @Override
        public long estimateSize(SSTableWriter.SSTableSizeParameters parameters)
        {
<span class="fc" id="L418">            return (long) ((parameters.partitionKeysSize() // index entries</span>
<span class="fc" id="L419">                            + parameters.partitionKeysSize() // keys in data file</span>
<span class="fc" id="L420">                            + parameters.dataSize()) // data</span>
                           * 1.2); // bloom filter and row index overhead
        }

        @Override
        public BigTableWriter.Builder builder(Descriptor descriptor)
        {
<span class="fc" id="L427">            return new BigTableWriter.Builder(descriptor);</span>
        }
    }

    static class BigVersion extends Version
    {
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">        public static final String current_version = DatabaseDescriptor.getStorageCompatibilityMode().isBefore(5) ? &quot;nc&quot; : &quot;oa&quot;;</span>
        public static final String earliest_supported_version = &quot;ma&quot;;

        // ma (3.0.0): swap bf hash order
        //             store rows natively
        // mb (3.0.7, 3.7): commit log lower bound included
        // mc (3.0.8, 3.9): commit log intervals included
        // md (3.0.18, 3.11.4): corrected sstable min/max clustering
        // me (3.0.25, 3.11.11): added hostId of the node from which the sstable originated

        // na (4.0-rc1): uncompressed chunks, pending repair session, isTransient, checksummed sstable metadata file, new Bloomfilter format
        // nb (4.0.0): originating host id
        // nc (4.1): improved min/max, partition level deletion presence marker, key range (CASSANDRA-18134)
        // oa (5.0): Long deletionTime to prevent TTL overflow
        //           token space coverage
        //
        // NOTE: When adding a new version:
        //  - Please add it to LegacySSTableTest
        //  - Please maybe add it to hasOriginatingHostId's regexp

        private final boolean isLatestVersion;
        private final int correspondingMessagingVersion;
        private final boolean hasCommitLogLowerBound;
        private final boolean hasCommitLogIntervals;
        private final boolean hasAccurateMinMax;
        private final boolean hasLegacyMinMax;
        private final boolean hasOriginatingHostId;
        private final boolean hasMaxCompressedLength;
        private final boolean hasPendingRepair;
        private final boolean hasMetadataChecksum;
        private final boolean hasIsTransient;
        private final boolean hasImprovedMinMax;
        private final boolean hasPartitionLevelDeletionPresenceMarker;
        private final boolean hasKeyRange;
        private final boolean hasUintDeletionTime;
        private final boolean hasTokenSpaceCoverage;

        /**
         * CASSANDRA-9067: 4.0 bloom filter representation changed (two longs just swapped)
         * have no 'static' bits caused by using the same upper bits for both bloom filter and token distribution.
         */
        private final boolean hasOldBfFormat;

        BigVersion(BigFormat format, String version)
        {
<span class="fc" id="L478">            super(format, version);</span>

<span class="pc bpc" id="L480" title="1 of 2 branches missed.">            isLatestVersion = version.compareTo(current_version) == 0;</span>
<span class="fc" id="L481">            correspondingMessagingVersion = MessagingService.VERSION_30;</span>

<span class="pc bpc" id="L483" title="1 of 2 branches missed.">            hasCommitLogLowerBound = version.compareTo(&quot;mb&quot;) &gt;= 0;</span>
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">            hasCommitLogIntervals = version.compareTo(&quot;mc&quot;) &gt;= 0;</span>
<span class="fc" id="L485">            hasAccurateMinMax = version.matches(&quot;(m[d-z])|(n[a-z])&quot;); // deprecated in 'nc' and to be removed in 'oa'</span>
<span class="fc" id="L486">            hasLegacyMinMax = version.matches(&quot;(m[a-z])|(n[a-z])&quot;); // deprecated in 'nc' and to be removed in 'oa'</span>
            // When adding a new version you might need to add it here
<span class="pc bpc" id="L488" title="3 of 4 branches missed.">            hasOriginatingHostId = version.compareTo(&quot;nb&quot;) &gt;= 0 || version.matches(&quot;(m[e-z])&quot;);</span>
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">            hasMaxCompressedLength = version.compareTo(&quot;na&quot;) &gt;= 0;</span>
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">            hasPendingRepair = version.compareTo(&quot;na&quot;) &gt;= 0;</span>
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">            hasIsTransient = version.compareTo(&quot;na&quot;) &gt;= 0;</span>
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">            hasMetadataChecksum = version.compareTo(&quot;na&quot;) &gt;= 0;</span>
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">            hasOldBfFormat = version.compareTo(&quot;na&quot;) &lt; 0;</span>
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">            hasImprovedMinMax = version.compareTo(&quot;nc&quot;) &gt;= 0;</span>
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">            hasPartitionLevelDeletionPresenceMarker = version.compareTo(&quot;nc&quot;) &gt;= 0;</span>
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">            hasKeyRange = version.compareTo(&quot;nc&quot;) &gt;= 0;</span>
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">            hasUintDeletionTime = version.compareTo(&quot;oa&quot;) &gt;= 0;</span>
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">            hasTokenSpaceCoverage = version.compareTo(&quot;oa&quot;) &gt;= 0;</span>
<span class="fc" id="L499">        }</span>

        @Override
        public boolean isLatestVersion()
        {
<span class="nc" id="L504">            return isLatestVersion;</span>
        }

        @Override
        public int correspondingMessagingVersion()
        {
<span class="fc" id="L510">            return correspondingMessagingVersion;</span>
        }

        @Override
        public boolean hasCommitLogLowerBound()
        {
<span class="fc" id="L516">            return hasCommitLogLowerBound;</span>
        }

        @Override
        public boolean hasCommitLogIntervals()
        {
<span class="fc" id="L522">            return hasCommitLogIntervals;</span>
        }

        @Override
        public boolean hasMaxCompressedLength()
        {
<span class="fc" id="L528">            return hasMaxCompressedLength;</span>
        }

        @Override
        public boolean hasPendingRepair()
        {
<span class="fc" id="L534">            return hasPendingRepair;</span>
        }

        @Override
        public boolean hasIsTransient()
        {
<span class="fc" id="L540">            return hasIsTransient;</span>
        }

        @Override
        public boolean hasMetadataChecksum()
        {
<span class="fc" id="L546">            return hasMetadataChecksum;</span>
        }

        @Override
        public boolean hasOldBfFormat()
        {
<span class="fc" id="L552">            return hasOldBfFormat;</span>
        }

        @Override
        public boolean hasAccurateMinMax()
        {
<span class="fc" id="L558">            return hasAccurateMinMax;</span>
        }

        @Override
        public boolean hasLegacyMinMax()
        {
<span class="fc" id="L564">            return hasLegacyMinMax;</span>
        }

        @Override
        public boolean hasOriginatingHostId()
        {
<span class="fc" id="L570">            return hasOriginatingHostId;</span>
        }

        @Override
        public boolean hasImprovedMinMax()
        {
<span class="fc" id="L576">            return hasImprovedMinMax;</span>
        }

        @Override
        public boolean hasTokenSpaceCoverage()
        {
<span class="fc" id="L582">            return hasTokenSpaceCoverage;</span>
        }

        @Override
        public boolean hasPartitionLevelDeletionsPresenceMarker()
        {
<span class="fc" id="L588">            return hasPartitionLevelDeletionPresenceMarker;</span>
        }

        @Override
        public boolean hasUIntDeletionTime()
        {
<span class="fc" id="L594">            return hasUintDeletionTime;</span>
        }

        @Override
        public boolean hasKeyRange()
        {
<span class="fc" id="L600">            return hasKeyRange;</span>
        }

        @Override
        public boolean isCompatible()
        {
<span class="pc bpc" id="L606" title="2 of 4 branches missed.">            return version.compareTo(earliest_supported_version) &gt;= 0 &amp;&amp; version.charAt(0) &lt;= current_version.charAt(0);</span>
        }

        @Override
        public boolean isCompatibleForStreaming()
        {
<span class="nc bnc" id="L612" title="All 4 branches missed.">            return isCompatible() &amp;&amp; version.charAt(0) == current_version.charAt(0);</span>
        }
    }

<span class="fc" id="L616">    private static class BigTableSpecificMetricsProviders implements MetricsProviders</span>
    {
<span class="fc" id="L618">        private final static BigTableSpecificMetricsProviders instance = new BigTableSpecificMetricsProviders();</span>

<span class="fc" id="L620">        private final Iterable&lt;GaugeProvider&lt;?&gt;&gt; gaugeProviders = Iterables.concat(BloomFilterMetrics.instance.getGaugeProviders(),</span>
<span class="fc" id="L621">                                                                                   IndexSummaryMetrics.instance.getGaugeProviders(),</span>
<span class="fc" id="L622">                                                                                   KeyCacheMetrics.instance.getGaugeProviders());</span>

        @Override
        public Iterable&lt;GaugeProvider&lt;?&gt;&gt; getGaugeProviders()
        {
<span class="fc" id="L627">            return gaugeProviders;</span>
        }
    }

    @SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L632">    public static class BigFormatFactory implements Factory</span>
    {
        @Override
        public String name()
        {
<span class="fc" id="L637">            return NAME;</span>
        }

        @Override
        public SSTableFormat&lt;?, ?&gt; getInstance(Map&lt;String, String&gt; options)
        {
<span class="fc" id="L643">            return new BigFormat(options);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>