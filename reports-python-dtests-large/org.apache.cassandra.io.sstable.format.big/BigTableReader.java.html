<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BigTableReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.io.sstable.format.big</a> &gt; <span class="el_source">BigTableReader.java</span></div><h1>BigTableReader.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.io.sstable.format.big;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.db.ClusteringBound;
import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.DataRange;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.DeletionTime;
import org.apache.cassandra.db.PartitionPosition;
import org.apache.cassandra.db.Slices;
import org.apache.cassandra.db.filter.ColumnFilter;
import org.apache.cassandra.db.rows.Rows;
import org.apache.cassandra.db.rows.UnfilteredRowIterator;
import org.apache.cassandra.db.rows.UnfilteredRowIteratorWithLowerBound;
import org.apache.cassandra.db.rows.UnfilteredRowIterators;
import org.apache.cassandra.dht.AbstractBounds;
import org.apache.cassandra.dht.Range;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.io.sstable.AbstractRowIndexEntry;
import org.apache.cassandra.io.sstable.CorruptSSTableException;
import org.apache.cassandra.io.sstable.Descriptor;
import org.apache.cassandra.io.sstable.Downsampling;
import org.apache.cassandra.io.sstable.ISSTableScanner;
import org.apache.cassandra.io.sstable.IVerifier;
import org.apache.cassandra.io.sstable.IndexInfo;
import org.apache.cassandra.io.sstable.KeyReader;
import org.apache.cassandra.io.sstable.SSTable;
import org.apache.cassandra.io.sstable.SSTableReadsListener;
import org.apache.cassandra.io.sstable.SSTableReadsListener.SelectionReason;
import org.apache.cassandra.io.sstable.SSTableReadsListener.SkippingReason;
import org.apache.cassandra.io.sstable.format.SSTableReader;
import org.apache.cassandra.io.sstable.format.SSTableReaderWithFilter;
import org.apache.cassandra.io.sstable.format.big.BigFormat.Components;
import org.apache.cassandra.io.sstable.indexsummary.IndexSummary;
import org.apache.cassandra.io.sstable.indexsummary.IndexSummaryBuilder;
import org.apache.cassandra.io.sstable.indexsummary.IndexSummarySupport;
import org.apache.cassandra.io.sstable.keycache.KeyCache;
import org.apache.cassandra.io.sstable.keycache.KeyCacheSupport;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.FileDataInput;
import org.apache.cassandra.io.util.FileHandle;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.io.util.RandomAccessReader;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.IFilter;
import org.apache.cassandra.utils.OutputHandler;

import static org.apache.cassandra.utils.concurrent.SharedCloseable.sharedCopyOrNull;

/**
 * SSTableReaders are open()ed by Keyspace.onStart; after that they are created by SSTableWriter.renameAndOpen.
 * Do not re-call open() on existing SSTable files; use the references kept by ColumnFamilyStore post-start instead.
 */
public class BigTableReader extends SSTableReaderWithFilter implements IndexSummarySupport&lt;BigTableReader&gt;,
                                                                       KeyCacheSupport&lt;BigTableReader&gt;
{
<span class="fc" id="L90">    private static final Logger logger = LoggerFactory.getLogger(BigTableReader.class);</span>

    private final RowIndexEntry.IndexSerializer rowIndexEntrySerializer;
    private final IndexSummary indexSummary;
    private final FileHandle ifile;

    private final KeyCache keyCache;

    public BigTableReader(Builder builder, SSTable.Owner owner)
    {
<span class="fc" id="L100">        super(builder, owner);</span>
<span class="fc" id="L101">        this.ifile = builder.getIndexFile();</span>
<span class="fc" id="L102">        this.indexSummary = builder.getIndexSummary();</span>
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">        this.rowIndexEntrySerializer = new RowIndexEntry.Serializer(descriptor.version, header, owner != null ? owner.getMetrics() : null);</span>
<span class="fc" id="L104">        this.keyCache = Objects.requireNonNull(builder.getKeyCache());</span>
<span class="fc" id="L105">    }</span>

    @Override
    protected List&lt;AutoCloseable&gt; setupInstance(boolean trackHotness)
    {
<span class="fc" id="L110">        ArrayList&lt;AutoCloseable&gt; closeables = Lists.newArrayList(indexSummary, ifile);</span>
<span class="fc" id="L111">        closeables.addAll(super.setupInstance(trackHotness));</span>
<span class="fc" id="L112">        return closeables;</span>
    }

    @Override
    public void releaseInMemoryComponents()
    {
<span class="nc" id="L118">        closeInternalComponent(indexSummary);</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">        assert indexSummary.isCleanedUp();</span>
<span class="nc" id="L120">    }</span>

    @Override
    public IndexSummary getIndexSummary()
    {
<span class="nc" id="L125">        return indexSummary;</span>
    }

    public UnfilteredRowIterator rowIterator(DecoratedKey key,
                                             Slices slices,
                                             ColumnFilter selectedColumns,
                                             boolean reversed,
                                             SSTableReadsListener listener)
    {
<span class="fc" id="L134">        RowIndexEntry rie = getRowIndexEntry(key, SSTableReader.Operator.EQ, true, listener);</span>
<span class="fc" id="L135">        return rowIterator(null, key, rie, slices, selectedColumns, reversed);</span>
    }

    public UnfilteredRowIterator rowIterator(FileDataInput file, DecoratedKey key, RowIndexEntry indexEntry, Slices slices, ColumnFilter selectedColumns, boolean reversed)
    {
<span class="fc bfc" id="L140" title="All 2 branches covered.">        if (indexEntry == null)</span>
<span class="fc" id="L141">            return UnfilteredRowIterators.noRowsIterator(metadata(), key, Rows.EMPTY_STATIC_ROW, DeletionTime.LIVE, reversed);</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">        else if (reversed)</span>
<span class="nc" id="L143">            return new SSTableReversedIterator(this, file, key, indexEntry, slices, selectedColumns, ifile);</span>
        else
<span class="fc" id="L145">            return new SSTableIterator(this, file, key, indexEntry, slices, selectedColumns, ifile);</span>
    }

    @Override
    public ISSTableScanner partitionIterator(ColumnFilter columns, DataRange dataRange, SSTableReadsListener listener)
    {
<span class="fc" id="L151">        return BigTableScanner.getScanner(this, columns, dataRange, listener);</span>
    }

    @Override
    public KeyReader keyReader() throws IOException
    {
<span class="nc" id="L157">        return BigTableKeyReader.create(ifile, rowIndexEntrySerializer);</span>
    }

    /**
     * Direct I/O SSTableScanner over an iterator of bounds.
     *
     * @param boundsIterator the keys to cover
     * @return A Scanner for seeking over the rows of the SSTable.
     */
    public ISSTableScanner getScanner(Iterator&lt;AbstractBounds&lt;PartitionPosition&gt;&gt; boundsIterator)
    {
<span class="nc" id="L168">        return BigTableScanner.getScanner(this, boundsIterator);</span>
    }

    /**
     * Direct I/O SSTableScanner over the full sstable.
     *
     * @return A Scanner for reading the full SSTable.
     */
    public ISSTableScanner getScanner()
    {
<span class="fc" id="L178">        return BigTableScanner.getScanner(this);</span>
    }

    /**
     * Direct I/O SSTableScanner over a defined collection of ranges of tokens.
     *
     * @param ranges the range of keys to cover
     * @return A Scanner for seeking over the rows of the SSTable.
     */
    public ISSTableScanner getScanner(Collection&lt;Range&lt;Token&gt;&gt; ranges)
    {
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (ranges != null)</span>
<span class="fc" id="L190">            return BigTableScanner.getScanner(this, ranges);</span>
        else
<span class="fc" id="L192">            return getScanner();</span>
    }

    /**
     * Finds and returns the first key beyond a given token in this SSTable or null if no such key exists.
     */
    @Override
    public DecoratedKey firstKeyBeyond(PartitionPosition token)
    {
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (token.compareTo(getFirst()) &lt; 0)</span>
<span class="nc" id="L202">            return getFirst();</span>

<span class="nc" id="L204">        long sampledPosition = getIndexScanPosition(token);</span>

<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (ifile == null)</span>
<span class="nc" id="L207">            return null;</span>

<span class="nc" id="L209">        String path = null;</span>
<span class="nc" id="L210">        try (FileDataInput in = ifile.createReader(sampledPosition))</span>
        {
<span class="nc" id="L212">            path = in.getPath();</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">            while (!in.isEOF())</span>
            {
<span class="nc" id="L215">                ByteBuffer indexKey = ByteBufferUtil.readWithShortLength(in);</span>
<span class="nc" id="L216">                DecoratedKey indexDecoratedKey = decorateKey(indexKey);</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">                if (indexDecoratedKey.compareTo(token) &gt; 0)</span>
<span class="nc" id="L218">                    return indexDecoratedKey;</span>

<span class="nc" id="L220">                RowIndexEntry.Serializer.skip(in, descriptor.version);</span>
<span class="nc" id="L221">            }</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">        }</span>
<span class="nc" id="L223">        catch (IOException e)</span>
        {
<span class="nc" id="L225">            markSuspect();</span>
<span class="nc" id="L226">            throw new CorruptSSTableException(e, path);</span>
<span class="nc" id="L227">        }</span>

<span class="nc" id="L229">        return null;</span>
    }

    /**
     * Retrieves the position while updating the key cache and the stats.
     *
     * @param key The key to apply as the rhs to the given Operator. A 'fake' key is allowed to
     *            allow key selection by token bounds but only if op != * EQ
     * @param op  The Operator defining matching keys: the nearest key to the target matching the operator wins.
     */
    public final RowIndexEntry getRowIndexEntry(PartitionPosition key, Operator op)
    {
<span class="nc" id="L241">        return getRowIndexEntry(key, op, true, SSTableReadsListener.NOOP_LISTENER);</span>
    }

    /**
     * @param key         The key to apply as the rhs to the given Operator. A 'fake' key is allowed to
     *                    allow key selection by token bounds but only if op != * EQ
     * @param operator    The Operator defining matching keys: the nearest key to the target matching the operator wins.
     * @param updateStats true if updating stats and cache
     * @return The index entry corresponding to the key, or null if the key is not present
     */
    @Override
    public RowIndexEntry getRowIndexEntry(PartitionPosition key,
                                          Operator operator,
                                          boolean updateStats,
                                          SSTableReadsListener listener)
    {
        // Having no index file is impossible in a normal operation. The only way it might happen is running
        // Scrubber that does not really rely on this method.
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">        if (ifile == null)</span>
<span class="nc" id="L260">            return null;</span>

<span class="fc" id="L262">        Operator searchOp = operator;</span>

        // check the smallest and greatest keys in the sstable to see if it can't be present
<span class="fc" id="L265">        boolean skip = false;</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">        if (key.compareTo(getFirst()) &lt; 0)</span>
        {
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">            if (searchOp == Operator.EQ)</span>
            {
<span class="nc" id="L270">                skip = true;</span>
            }
            else
            {
<span class="fc" id="L274">                key = getFirst();</span>
<span class="fc" id="L275">                searchOp = Operator.GE; // since op != EQ, bloom filter will be skipped; first key is included so no reason to check bloom filter</span>
            }
        }
        else
        {
<span class="fc" id="L280">            int l = getLast().compareTo(key);</span>
<span class="pc bpc" id="L281" title="2 of 6 branches missed.">            skip = l &lt; 0 // out of range, skip</span>
                   || l == 0 &amp;&amp; searchOp == Operator.GT; // search entry &gt; key, but key is the last in range, so skip
<span class="fc bfc" id="L283" title="All 2 branches covered.">            if (l == 0)</span>
<span class="fc" id="L284">                searchOp = Operator.GE; // since op != EQ, bloom filter will be skipped, last key is included so no reason to check bloom filter</span>
        }
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">        if (skip)</span>
        {
<span class="nc" id="L288">            notifySkipped(SkippingReason.MIN_MAX_KEYS, listener, operator, updateStats);</span>
<span class="nc" id="L289">            return null;</span>
        }

<span class="fc bfc" id="L292" title="All 2 branches covered.">        if (searchOp == Operator.EQ)</span>
        {
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">            assert key instanceof DecoratedKey; // EQ only make sense if the key is a valid row key</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">            if (!isPresentInFilter((IFilter.FilterKey) key))</span>
            {
<span class="fc" id="L297">                notifySkipped(SkippingReason.BLOOM_FILTER, listener, operator, updateStats);</span>
<span class="fc" id="L298">                return null;</span>
            }
        }

        // next, the key cache (only make sense for valid row key)
<span class="pc bpc" id="L303" title="1 of 6 branches missed.">        if ((searchOp == Operator.EQ || searchOp == Operator.GE) &amp;&amp; (key instanceof DecoratedKey))</span>
        {
<span class="fc" id="L305">            DecoratedKey decoratedKey = (DecoratedKey) key;</span>
<span class="fc" id="L306">            AbstractRowIndexEntry cachedPosition = getCachedPosition(decoratedKey, updateStats);</span>
<span class="pc bpc" id="L307" title="1 of 4 branches missed.">            if (cachedPosition != null &amp;&amp; cachedPosition.getSSTableFormat() == descriptor.getFormat())</span>
            {
<span class="fc" id="L309">                notifySelected(SelectionReason.KEY_CACHE_HIT, listener, operator, updateStats, cachedPosition);</span>
<span class="fc" id="L310">                return (RowIndexEntry) cachedPosition;</span>
            }
        }

<span class="fc" id="L314">        int binarySearchResult = indexSummary.binarySearch(key);</span>
<span class="fc" id="L315">        long sampledPosition = indexSummary.getScanPositionFromBinarySearchResult(binarySearchResult);</span>
<span class="fc" id="L316">        int sampledIndex = IndexSummary.getIndexFromBinarySearchResult(binarySearchResult);</span>

<span class="fc" id="L318">        int effectiveInterval = indexSummary.getEffectiveIndexIntervalAfterIndex(sampledIndex);</span>

        // scan the on-disk index, starting at the nearest sampled position.
        // The check against IndexInterval is to be exited the loop in the EQ case when the key looked for is not present
        // (bloom filter false positive). But note that for non-EQ cases, we might need to check the first key of the
        // next index position because the searched key can be greater the last key of the index interval checked if it
        // is lesser than the first key of next interval (and in that case we must return the position of the first key
        // of the next interval).
<span class="fc" id="L326">        int i = 0;</span>
<span class="fc" id="L327">        String path = null;</span>
<span class="fc" id="L328">        try (FileDataInput in = ifile.createReader(sampledPosition))</span>
        {
<span class="fc" id="L330">            path = in.getPath();</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">            while (!in.isEOF())</span>
            {
<span class="fc" id="L333">                i++;</span>

<span class="fc" id="L335">                ByteBuffer indexKey = ByteBufferUtil.readWithShortLength(in);</span>

                boolean opSatisfied; // did we find an appropriate position for the op requested
                boolean exactMatch; // is the current position an exact match for the key, suitable for caching

                // Compare raw keys if possible for performance, otherwise compare decorated keys.
<span class="fc bfc" id="L341" title="All 4 branches covered.">                if (searchOp == Operator.EQ &amp;&amp; i &lt;= effectiveInterval)</span>
                {
<span class="fc" id="L343">                    opSatisfied = exactMatch = indexKey.equals(((DecoratedKey) key).getKey());</span>
                }
                else
                {
<span class="fc" id="L347">                    DecoratedKey indexDecoratedKey = decorateKey(indexKey);</span>
<span class="fc" id="L348">                    int comparison = indexDecoratedKey.compareTo(key);</span>
<span class="fc" id="L349">                    int v = searchOp.apply(comparison);</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">                    opSatisfied = (v == 0);</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">                    exactMatch = (comparison == 0);</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">                    if (v &lt; 0)</span>
                    {
<span class="fc" id="L354">                        notifySkipped(SkippingReason.PARTITION_INDEX_LOOKUP, listener, operator, updateStats);</span>
<span class="fc" id="L355">                        return null;</span>
                    }
                }

<span class="fc bfc" id="L359" title="All 2 branches covered.">                if (opSatisfied)</span>
                {
                    // read data position from index entry
<span class="fc" id="L362">                    RowIndexEntry indexEntry = rowIndexEntrySerializer.deserialize(in);</span>
<span class="pc bpc" id="L363" title="1 of 4 branches missed.">                    if (exactMatch &amp;&amp; updateStats)</span>
                    {
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">                        assert key instanceof DecoratedKey; // key can be == to the index key only if it's a true row key</span>
<span class="fc" id="L366">                        DecoratedKey decoratedKey = (DecoratedKey) key;</span>

<span class="pc bpc" id="L368" title="1 of 2 branches missed.">                        if (logger.isTraceEnabled())</span>
                        {
                            // expensive sanity check!  see CASSANDRA-4687
<span class="nc" id="L371">                            try (FileDataInput fdi = dfile.createReader(indexEntry.position))</span>
                            {
<span class="nc" id="L373">                                DecoratedKey keyInDisk = decorateKey(ByteBufferUtil.readWithShortLength(fdi));</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">                                if (!keyInDisk.equals(key))</span>
<span class="nc" id="L375">                                    throw new AssertionError(String.format(&quot;%s != %s in %s&quot;, keyInDisk, key, fdi.getPath()));</span>
                            }
                        }

                        // store exact match for the key
<span class="fc" id="L380">                        cacheKey(decoratedKey, indexEntry);</span>
                    }
<span class="fc" id="L382">                    notifySelected(SelectionReason.INDEX_ENTRY_FOUND, listener, operator, updateStats, indexEntry);</span>
<span class="fc" id="L383">                    return indexEntry;</span>
                }

<span class="fc" id="L386">                RowIndexEntry.Serializer.skip(in, descriptor.version);</span>
<span class="fc" id="L387">            }</span>
<span class="pc bpc" id="L388" title="2 of 4 branches missed.">        }</span>
<span class="nc" id="L389">        catch (IOException e)</span>
        {
<span class="nc" id="L391">            markSuspect();</span>
<span class="nc" id="L392">            throw new CorruptSSTableException(e, path);</span>
<span class="fc" id="L393">        }</span>

<span class="fc" id="L395">        notifySkipped(SkippingReason.INDEX_ENTRY_NOT_FOUND, listener, operator, updateStats);</span>
<span class="fc" id="L396">        return null;</span>
    }

    /**
     * @param key                 The key to apply as the rhs to the given Operator. A 'fake' key is allowed to
     *                            allow key selection by token bounds but only if op != * EQ
     * @param op                  The Operator defining matching keys: the nearest key to the target matching the operator wins.
     * @param updateCacheAndStats true if updating stats and cache
     * @return The index entry corresponding to the key, or null if the key is not present
     */
    @Override
    protected long getPosition(PartitionPosition key,
                               Operator op,
                               boolean updateCacheAndStats,
                               SSTableReadsListener listener)
    {
<span class="fc" id="L412">        RowIndexEntry rowIndexEntry = getRowIndexEntry(key, op, updateCacheAndStats, listener);</span>
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">        return rowIndexEntry != null ? rowIndexEntry.position : -1;</span>
    }

    @Override
    public DecoratedKey keyAtPositionFromSecondaryIndex(long keyPositionFromSecondaryIndex) throws IOException
    {
        DecoratedKey key;
<span class="nc" id="L420">        try (FileDataInput in = ifile.createReader(keyPositionFromSecondaryIndex))</span>
        {
<span class="nc bnc" id="L422" title="All 2 branches missed.">            if (in.isEOF())</span>
<span class="nc" id="L423">                return null;</span>

<span class="nc" id="L425">            key = decorateKey(ByteBufferUtil.readWithShortLength(in));</span>

            // hint read path about key location if caching is enabled
            // this saves index summary lookup and index file iteration which whould be pretty costly
            // especially in presence of promoted column indexes
<span class="nc" id="L430">            cacheKey(key, rowIndexEntrySerializer.deserialize(in));</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">        }</span>

<span class="nc" id="L433">        return key;</span>
    }

    @Override
    public RowIndexEntry deserializeKeyCacheValue(DataInputPlus input) throws IOException
    {
<span class="nc" id="L439">        return rowIndexEntrySerializer.deserializeForCache(input);</span>
    }

    @Override
    public ClusteringBound&lt;?&gt; getLowerBoundPrefixFromCache(DecoratedKey partitionKey, boolean isReversed)
    {
<span class="fc" id="L445">        AbstractRowIndexEntry rie = getCachedPosition(partitionKey, false);</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">        if (!(rie instanceof RowIndexEntry))</span>
<span class="fc" id="L447">            return null;</span>

<span class="fc" id="L449">        RowIndexEntry rowIndexEntry = (RowIndexEntry) rie;</span>
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">        if (!rowIndexEntry.indexOnHeap())</span>
<span class="fc" id="L451">            return null;</span>

<span class="nc" id="L453">        try (RowIndexEntry.IndexInfoRetriever onHeapRetriever = rowIndexEntry.openWithIndex(null))</span>
        {
<span class="nc bnc" id="L455" title="All 2 branches missed.">            IndexInfo columns = onHeapRetriever.columnsIndex(isReversed ? rowIndexEntry.blockCount() - 1 : 0);</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">            ClusteringBound&lt;?&gt; bound = isReversed ? columns.lastName.asEndBound() : columns.firstName.asStartBound();</span>
<span class="nc" id="L457">            UnfilteredRowIteratorWithLowerBound.assertBoundSize(bound, this);</span>
<span class="nc" id="L458">            return bound.artificialLowerBound(isReversed);</span>
        }
<span class="nc" id="L460">        catch (IOException e)</span>
        {
<span class="nc" id="L462">            throw new RuntimeException(&quot;should never occur&quot;, e);</span>
        }
    }

    /**
     * @return An estimate of the number of keys in this SSTable based on the index summary.
     */
    @Override
    public long estimatedKeys()
    {
<span class="fc" id="L472">        return indexSummary.getEstimatedKeyCount();</span>
    }

    /**
     * @return An estimate of the number of keys for given ranges in this SSTable.
     */
    @Override
    public long estimatedKeysForRanges(Collection&lt;Range&lt;Token&gt;&gt; ranges)
    {
<span class="fc" id="L481">        long sampleKeyCount = 0;</span>
<span class="fc" id="L482">        List&lt;IndexesBounds&gt; sampleIndexes = indexSummary.getSampleIndexesForRanges(ranges);</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">        for (IndexesBounds sampleIndexRange : sampleIndexes)</span>
<span class="fc" id="L484">            sampleKeyCount += (sampleIndexRange.upperPosition - sampleIndexRange.lowerPosition + 1);</span>

        // adjust for the current sampling level: (BSL / SL) * index_interval_at_full_sampling
<span class="fc" id="L487">        long estimatedKeys = sampleKeyCount * ((long) Downsampling.BASE_SAMPLING_LEVEL * indexSummary.getMinIndexInterval()) / indexSummary.getSamplingLevel();</span>
<span class="fc" id="L488">        return Math.max(1, estimatedKeys);</span>
    }

    /**
     * Returns whether the number of entries in the IndexSummary &gt; 2.  At full sampling, this is approximately
     * 1/INDEX_INTERVALth of the keys in this SSTable.
     */
    @Override
    public boolean isEstimationInformative()
    {
<span class="nc bnc" id="L498" title="All 2 branches missed.">        return indexSummary.size() &gt; 2;</span>
    }

    @Override
    public Iterable&lt;DecoratedKey&gt; getKeySamples(final Range&lt;Token&gt; range)
    {
<span class="nc" id="L504">        return Iterables.transform(indexSummary.getKeySamples(range), bytes -&gt; decorateKey(ByteBuffer.wrap(bytes)));</span>
    }

    public RandomAccessReader openIndexReader()
    {
<span class="pc bpc" id="L509" title="1 of 2 branches missed.">        if (ifile != null)</span>
<span class="fc" id="L510">            return ifile.createReader();</span>
<span class="nc" id="L511">        return null;</span>
    }

    public FileHandle getIndexFile()
    {
<span class="nc" id="L516">        return ifile;</span>
    }

    @Override
    public IVerifier getVerifier(ColumnFamilyStore cfs, OutputHandler outputHandler, boolean isOffline, IVerifier.Options options)
    {
<span class="nc" id="L522">        Preconditions.checkArgument(cfs.metadata().equals(metadata()));</span>
<span class="nc" id="L523">        return new BigTableVerifier(cfs, this, outputHandler, isOffline, options);</span>
    }

    /**
     * Gets the position with the index file to start scanning to find the given key (at most indexInterval keys away,
     * modulo downsampling of the index summary). Always returns a {@code value &gt;= 0}
     */
    long getIndexScanPosition(PartitionPosition key)
    {
<span class="pc bpc" id="L532" title="3 of 4 branches missed.">        if (openReason == OpenReason.MOVED_START &amp;&amp; key.compareTo(getFirst()) &lt; 0)</span>
<span class="nc" id="L533">            key = getFirst();</span>

<span class="fc" id="L535">        return indexSummary.getScanPosition(key);</span>
    }

    protected final Builder unbuildTo(Builder builder, boolean sharedCopy)
    {
<span class="nc" id="L540">        Builder b = super.unbuildTo(builder, sharedCopy);</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">        if (builder.getIndexFile() == null)</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">            b.setIndexFile(sharedCopy ? sharedCopyOrNull(ifile) : ifile);</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">        if (builder.getIndexSummary() == null)</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">            b.setIndexSummary(sharedCopy ? sharedCopyOrNull(indexSummary) : indexSummary);</span>

<span class="nc" id="L546">        b.setKeyCache(keyCache);</span>

<span class="nc" id="L548">        return b;</span>
    }

    @VisibleForTesting
    @Override
    public SSTableReaderWithFilter cloneAndReplace(IFilter filter)
    {
<span class="nc" id="L555">        return unbuildTo(new Builder(descriptor).setFilter(filter), true).build(owner().orElse(null), true, true);</span>
    }

    /**
     * Clone this reader with the provided start and open reason, and set the clone as replacement.
     *
     * @param newFirst the first key for the replacement (which can be different from the original due to the pre-emptive
     *                 opening of compaction results).
     * @param reason   the {@code OpenReason} for the replacement.
     * @return the cloned reader. That reader is set as a replacement by the method.
     */
    private SSTableReader cloneAndReplace(DecoratedKey newFirst, OpenReason reason)
    {
<span class="nc" id="L568">        return unbuildTo(new Builder(descriptor), true)</span>
<span class="nc" id="L569">               .setFirst(newFirst)</span>
<span class="nc" id="L570">               .setOpenReason(reason)</span>
<span class="nc" id="L571">               .build(owner().orElse(null), true, true);</span>
    }

    /**
     * Clone this reader with the new values and set the clone as replacement.
     *
     * @param newFirst   the first key for the replacement (which can be different from the original due to the pre-emptive
     *                   opening of compaction results).
     * @param reason     the {@code OpenReason} for the replacement.
     * @param newSummary the index summary for the replacement.
     * @return the cloned reader. That reader is set as a replacement by the method.
     */
    private BigTableReader cloneAndReplace(DecoratedKey newFirst, OpenReason reason, IndexSummary newSummary)
    {
<span class="nc" id="L585">        return unbuildTo(new Builder(descriptor).setIndexSummary(newSummary), true)</span>
<span class="nc" id="L586">                    .setIndexSummary(newSummary)</span>
<span class="nc" id="L587">                    .setFirst(newFirst)</span>
<span class="nc" id="L588">                    .setOpenReason(reason)</span>
<span class="nc" id="L589">                    .build(owner().orElse(null), true, true);</span>
    }

    public SSTableReader cloneWithRestoredStart(DecoratedKey restoredStart)
    {
<span class="nc" id="L594">        return runWithLock(ignored -&gt; cloneAndReplace(restoredStart, OpenReason.NORMAL));</span>
    }

    public SSTableReader cloneWithNewStart(DecoratedKey newStart)
    {
<span class="nc" id="L599">        return runWithLock(ignored -&gt; {</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">            assert openReason != OpenReason.EARLY;</span>
            // TODO: merge with caller's firstKeyBeyond() work,to save time
<span class="nc bnc" id="L602" title="All 2 branches missed.">            if (newStart.compareTo(getFirst()) &gt; 0)</span>
            {
<span class="nc" id="L604">                Map&lt;FileHandle, Long&gt; handleAndPositions = new LinkedHashMap&lt;&gt;(2);</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">                if (dfile != null)</span>
<span class="nc" id="L606">                    handleAndPositions.put(dfile, getPosition(newStart, Operator.EQ));</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">                if (ifile != null)</span>
<span class="nc" id="L608">                    handleAndPositions.put(ifile, getIndexScanPosition(newStart));</span>
<span class="nc" id="L609">                runOnClose(() -&gt; handleAndPositions.forEach(FileHandle::dropPageCache));</span>
            }

<span class="nc" id="L612">            return cloneAndReplace(newStart, OpenReason.MOVED_START);</span>
        });
    }

    /**
     * Returns a new SSTableReader with the same properties as this SSTableReader except that a new IndexSummary will
     * be built at the target samplingLevel.  This (original) SSTableReader instance will be marked as replaced, have
     * its DeletingTask removed, and have its periodic read-meter sync task cancelled.
     *
     * @param samplingLevel the desired sampling level for the index summary on the new SSTableReader
     * @return a new SSTableReader
     */
    @SuppressWarnings(&quot;resource&quot;)
    public BigTableReader cloneWithNewSummarySamplingLevel(ColumnFamilyStore parent, int samplingLevel) throws IOException
    {
<span class="nc bnc" id="L627" title="All 2 branches missed.">        assert openReason != OpenReason.EARLY;</span>

<span class="nc" id="L629">        int minIndexInterval = metadata().params.minIndexInterval;</span>
<span class="nc" id="L630">        int maxIndexInterval = metadata().params.maxIndexInterval;</span>
<span class="nc" id="L631">        double effectiveInterval = indexSummary.getEffectiveIndexInterval();</span>

        IndexSummary newSummary;

        // We have to rebuild the summary from the on-disk primary index in three cases:
        // 1. The sampling level went up, so we need to read more entries off disk
        // 2. The min_index_interval changed (in either direction); this changes what entries would be in the summary
        //    at full sampling (and consequently at any other sampling level)
        // 3. The max_index_interval was lowered, forcing us to raise the sampling level
<span class="nc bnc" id="L640" title="All 6 branches missed.">        if (samplingLevel &gt; indexSummary.getSamplingLevel() || indexSummary.getMinIndexInterval() != minIndexInterval || effectiveInterval &gt; maxIndexInterval)</span>
        {
<span class="nc" id="L642">            newSummary = buildSummaryAtLevel(samplingLevel);</span>
        }
<span class="nc bnc" id="L644" title="All 2 branches missed.">        else if (samplingLevel &lt; indexSummary.getSamplingLevel())</span>
        {
            // we can use the existing index summary to make a smaller one
<span class="nc" id="L647">            newSummary = IndexSummaryBuilder.downsample(indexSummary, samplingLevel, minIndexInterval, getPartitioner());</span>
        }
        else
        {
<span class="nc" id="L651">            throw new AssertionError(&quot;Attempted to clone SSTableReader with the same index summary sampling level and &quot; +</span>
                                     &quot;no adjustments to min/max_index_interval&quot;);
        }

        // Always save the resampled index with lock to avoid racing with entire-sstable streaming
<span class="nc" id="L656">        return runWithLock(ignored -&gt; {</span>
<span class="nc" id="L657">            new IndexSummaryComponent(newSummary, getFirst(), getLast()).save(descriptor.fileFor(Components.SUMMARY), true);</span>
<span class="nc" id="L658">            return cloneAndReplace(getFirst(), OpenReason.METADATA_CHANGE, newSummary);</span>
        });
    }

    private IndexSummary buildSummaryAtLevel(int newSamplingLevel) throws IOException
    {
        // we read the positions in a BRAF, so we don't have to worry about an entry spanning a mmap boundary.
<span class="nc" id="L665">        RandomAccessReader primaryIndex = RandomAccessReader.open(descriptor.fileFor(Components.PRIMARY_INDEX));</span>
        try
        {
<span class="nc" id="L668">            long indexSize = primaryIndex.length();</span>
<span class="nc" id="L669">            try (IndexSummaryBuilder summaryBuilder = new IndexSummaryBuilder(estimatedKeys(), metadata().params.minIndexInterval, newSamplingLevel))</span>
            {
                long indexPosition;
<span class="nc bnc" id="L672" title="All 2 branches missed.">                while ((indexPosition = primaryIndex.getFilePointer()) != indexSize)</span>
                {
<span class="nc" id="L674">                    summaryBuilder.maybeAddEntry(decorateKey(ByteBufferUtil.readWithShortLength(primaryIndex)), indexPosition);</span>
<span class="nc" id="L675">                    RowIndexEntry.Serializer.skip(primaryIndex, descriptor.version);</span>
                }

<span class="nc" id="L678">                return summaryBuilder.build(getPartitioner());</span>
            }
        }
        finally
        {
<span class="nc" id="L683">            FileUtils.closeQuietly(primaryIndex);</span>
        }
    }

    @Override
    public KeyCache getKeyCache()
    {
<span class="fc" id="L690">        return this.keyCache;</span>
    }

    public static class Builder extends SSTableReaderWithFilter.Builder&lt;BigTableReader, Builder&gt;
    {
<span class="fc" id="L695">        private static final Logger logger = LoggerFactory.getLogger(Builder.class);</span>

        private IndexSummary indexSummary;
        private FileHandle indexFile;
<span class="fc" id="L699">        private KeyCache keyCache = KeyCache.NO_CACHE;</span>

        public Builder(Descriptor descriptor)
        {
<span class="fc" id="L703">            super(descriptor);</span>
<span class="fc" id="L704">        }</span>

        public Builder setIndexFile(FileHandle indexFile)
        {
<span class="fc" id="L708">            this.indexFile = indexFile;</span>
<span class="fc" id="L709">            return this;</span>
        }

        public Builder setIndexSummary(IndexSummary indexSummary)
        {
<span class="fc" id="L714">            this.indexSummary = indexSummary;</span>
<span class="fc" id="L715">            return this;</span>
        }

        public Builder setKeyCache(KeyCache keyCache)
        {
<span class="fc" id="L720">            this.keyCache = keyCache;</span>
<span class="fc" id="L721">            return this;</span>
        }

        public IndexSummary getIndexSummary()
        {
<span class="fc" id="L726">            return indexSummary;</span>
        }

        public FileHandle getIndexFile()
        {
<span class="fc" id="L731">            return indexFile;</span>
        }

        public KeyCache getKeyCache()
        {
<span class="fc" id="L736">            return keyCache;</span>
        }

        @Override
        protected BigTableReader buildInternal(Owner owner)
        {
<span class="fc" id="L742">            return new BigTableReader(this, owner);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>