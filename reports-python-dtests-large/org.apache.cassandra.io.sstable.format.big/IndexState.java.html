<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IndexState.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.io.sstable.format.big</a> &gt; <span class="el_source">IndexState.java</span></div><h1>IndexState.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.io.sstable.format.big;

import java.io.IOException;
import java.util.Comparator;

import org.apache.cassandra.db.ClusteringBound;
import org.apache.cassandra.db.ClusteringComparator;
import org.apache.cassandra.db.ClusteringPrefix;
import org.apache.cassandra.io.sstable.AbstractSSTableIterator;
import org.apache.cassandra.io.sstable.IndexInfo;
import org.apache.cassandra.io.util.DataPosition;
import org.apache.cassandra.io.util.FileHandle;

// Used by indexed readers to store where they are of the index.
<span class="nc" id="L33">public class IndexState implements AutoCloseable</span>
{
    private final AbstractSSTableIterator&lt;RowIndexEntry&gt;.AbstractReader reader;
    private final ClusteringComparator comparator;

    private final RowIndexEntry indexEntry;
    private final RowIndexEntry.IndexInfoRetriever indexInfoRetriever;
    private final boolean reversed;

    private int currentIndexIdx;

    // Marks the beginning of the block corresponding to currentIndexIdx.
    private DataPosition mark;

    public IndexState(AbstractSSTableIterator&lt;RowIndexEntry&gt;.AbstractReader reader, ClusteringComparator comparator, RowIndexEntry indexEntry, boolean reversed, FileHandle indexFile)
<span class="nc" id="L48">    {</span>
<span class="nc" id="L49">        this.reader = reader;</span>
<span class="nc" id="L50">        this.comparator = comparator;</span>
<span class="nc" id="L51">        this.indexEntry = indexEntry;</span>
<span class="nc" id="L52">        this.indexInfoRetriever = indexEntry.openWithIndex(indexFile);</span>
<span class="nc" id="L53">        this.reversed = reversed;</span>
<span class="nc bnc" id="L54" title="All 2 branches missed.">        this.currentIndexIdx = reversed ? indexEntry.blockCount() : -1;</span>
<span class="nc" id="L55">    }</span>

    public boolean isDone()
    {
<span class="nc bnc" id="L59" title="All 6 branches missed.">        return reversed ? currentIndexIdx &lt; 0 : currentIndexIdx &gt;= indexEntry.blockCount();</span>
    }

    // Sets the reader to the beginning of blockIdx.
    public void setToBlock(int blockIdx) throws IOException
    {
<span class="nc bnc" id="L65" title="All 4 branches missed.">        if (blockIdx &gt;= 0 &amp;&amp; blockIdx &lt; indexEntry.blockCount())</span>
        {
<span class="nc" id="L67">            reader.seekToPosition(columnOffset(blockIdx));</span>
<span class="nc" id="L68">            mark = reader.file.mark();</span>
<span class="nc" id="L69">            reader.deserializer.clearState();</span>
        }

<span class="nc" id="L72">        currentIndexIdx = blockIdx;</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">        reader.openMarker = blockIdx &gt; 0 ? index(blockIdx - 1).endOpenMarker : null;</span>
<span class="nc" id="L74">    }</span>

    private long columnOffset(int i) throws IOException
    {
<span class="nc" id="L78">        return indexEntry.position + index(i).offset;</span>
    }

    public int blocksCount()
    {
<span class="nc" id="L83">        return indexEntry.blockCount();</span>
    }

    // Update the block idx based on the current reader position if we're past the current block.
    // This only makes sense for forward iteration (for reverse ones, when we reach the end of a block we
    // should seek to the previous one, not update the index state and continue).
    public void updateBlock() throws IOException
    {
<span class="nc bnc" id="L91" title="All 2 branches missed.">        assert !reversed;</span>

        // If we get here with currentBlockIdx &lt; 0, it means setToBlock() has never been called, so it means
        // we're about to read from the beginning of the partition, but haven't &quot;prepared&quot; the IndexState yet.
        // Do so by setting us on the first block.
<span class="nc bnc" id="L96" title="All 2 branches missed.">        if (currentIndexIdx &lt; 0)</span>
        {
<span class="nc" id="L98">            setToBlock(0);</span>
<span class="nc" id="L99">            return;</span>
        }

<span class="nc bnc" id="L102" title="All 4 branches missed.">        while (currentIndexIdx + 1 &lt; indexEntry.blockCount() &amp;&amp; isPastCurrentBlock())</span>
        {
<span class="nc" id="L104">            reader.openMarker = currentIndex().endOpenMarker;</span>
<span class="nc" id="L105">            ++currentIndexIdx;</span>

            // We have to set the mark, and we have to set it at the beginning of the block. So if we're not at the beginning of the block, this forces us to a weird seek dance.
            // This can only happen when reading old file however.
<span class="nc" id="L109">            long startOfBlock = columnOffset(currentIndexIdx);</span>
<span class="nc" id="L110">            long currentFilePointer = reader.file.getFilePointer();</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">            if (startOfBlock == currentFilePointer)</span>
            {
<span class="nc" id="L113">                mark = reader.file.mark();</span>
            }
            else
            {
<span class="nc" id="L117">                reader.seekToPosition(startOfBlock);</span>
<span class="nc" id="L118">                mark = reader.file.mark();</span>
<span class="nc" id="L119">                reader.seekToPosition(currentFilePointer);</span>
            }
<span class="nc" id="L121">        }</span>
<span class="nc" id="L122">    }</span>

    // Check if we've crossed an index boundary (based on the mark on the beginning of the index block).
    public boolean isPastCurrentBlock() throws IOException
    {
<span class="nc bnc" id="L127" title="All 2 branches missed.">        assert reader.deserializer != null;</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">        return reader.file.bytesPastMark(mark) &gt;= currentIndex().width;</span>
    }

    public int currentBlockIdx()
    {
<span class="nc" id="L133">        return currentIndexIdx;</span>
    }

    public IndexInfo currentIndex() throws IOException
    {
<span class="nc" id="L138">        return index(currentIndexIdx);</span>
    }

    public IndexInfo index(int i) throws IOException
    {
<span class="nc" id="L143">        return indexInfoRetriever.columnsIndex(i);</span>
    }

    // Finds the index of the first block containing the provided bound, starting at the provided index.
    // Will be -1 if the bound is before any block, and blocksCount() if it is after every block.
    public int findBlockIndex(ClusteringBound&lt;?&gt; bound, int fromIdx) throws IOException
    {
<span class="nc bnc" id="L150" title="All 2 branches missed.">        if (bound.isBottom())</span>
<span class="nc" id="L151">            return -1;</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">        if (bound.isTop())</span>
<span class="nc" id="L153">            return blocksCount();</span>

<span class="nc" id="L155">        return indexFor(bound, fromIdx);</span>
    }

    public int indexFor(ClusteringPrefix&lt;?&gt; name, int lastIndex) throws IOException
    {
<span class="nc" id="L160">        IndexInfo target = new IndexInfo(name, name, 0, 0, null);</span>
        /*
        Take the example from the unit test, and say your index looks like this:
        [0..5][10..15][20..25]
        and you look for the slice [13..17].

        When doing forward slice, we are doing a binary search comparing 13 (the start of the query)
        to the lastName part of the index slot. You'll end up with the &quot;first&quot; slot, going from left to right,
        that may contain the start.

        When doing a reverse slice, we do the same thing, only using as a start column the end of the query,
        i.e. 17 in this example, compared to the firstName part of the index slots.  bsearch will give us the
        first slot where firstName &gt; start ([20..25] here), so we subtract an extra one to get the slot just before.
        */
<span class="nc" id="L174">        int startIdx = 0;</span>
<span class="nc" id="L175">        int endIdx = indexEntry.blockCount() - 1;</span>

<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (reversed)</span>
        {
<span class="nc bnc" id="L179" title="All 2 branches missed.">            if (lastIndex &lt; endIdx)</span>
            {
<span class="nc" id="L181">                endIdx = lastIndex;</span>
            }
        }
        else
        {
<span class="nc bnc" id="L186" title="All 2 branches missed.">            if (lastIndex &gt; 0)</span>
            {
<span class="nc" id="L188">                startIdx = lastIndex;</span>
            }
        }

<span class="nc" id="L192">        int index = binarySearch(target, comparator.indexComparator(reversed), startIdx, endIdx);</span>
<span class="nc bnc" id="L193" title="All 4 branches missed.">        return (index &lt; 0 ? -index - (reversed ? 2 : 1) : index);</span>
    }

    private int binarySearch(IndexInfo key, Comparator&lt;IndexInfo&gt; c, int low, int high) throws IOException
    {
<span class="nc bnc" id="L198" title="All 2 branches missed.">        while (low &lt;= high)</span>
        {
<span class="nc" id="L200">            int mid = (low + high) &gt;&gt;&gt; 1;</span>
<span class="nc" id="L201">            IndexInfo midVal = index(mid);</span>
<span class="nc" id="L202">            int cmp = c.compare(midVal, key);</span>

<span class="nc bnc" id="L204" title="All 2 branches missed.">            if (cmp &lt; 0)</span>
<span class="nc" id="L205">                low = mid + 1;</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">            else if (cmp &gt; 0)</span>
<span class="nc" id="L207">                high = mid - 1;</span>
            else
<span class="nc" id="L209">                return mid;</span>
<span class="nc" id="L210">        }</span>
<span class="nc" id="L211">        return -(low + 1);</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L217">        return String.format(&quot;IndexState(indexSize=%d, currentBlock=%d, reversed=%b)&quot;, indexEntry.blockCount(), currentIndexIdx, reversed);</span>
    }

    @Override
    public void close() throws IOException
    {
<span class="nc" id="L223">        indexInfoRetriever.close();</span>
<span class="nc" id="L224">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>