<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ValueAccessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.marshal</a> &gt; <span class="el_source">ValueAccessor.java</span></div><h1>ValueAccessor.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.db.marshal;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.UUID;

import org.apache.cassandra.db.Clustering;
import org.apache.cassandra.db.ClusteringBound;
import org.apache.cassandra.db.ClusteringBoundOrBoundary;
import org.apache.cassandra.db.ClusteringBoundary;
import org.apache.cassandra.db.ClusteringPrefix;
import org.apache.cassandra.db.Digest;
import org.apache.cassandra.db.TypeSizes;
import org.apache.cassandra.db.rows.Cell;
import org.apache.cassandra.db.rows.CellPath;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.service.paxos.Ballot;
import org.apache.cassandra.utils.TimeUUID;
import org.apache.cassandra.utils.vint.VIntCoding;

import static org.apache.cassandra.db.ClusteringPrefix.Kind.*;

/**
 * ValueAccessor allows serializers and other code dealing with raw bytes to operate on different backing types
 * (ie: byte arrays, byte buffers, etc) without requiring that the supported backing types share a common type
 * ancestor and without incuring the allocation cost of a wrapper object.
 *
 * A note on byte buffers for implementors: the &quot;value&quot; of a byte buffer is always interpreted as beginning at
 * it's {@link ByteBuffer#position()} and having a length of {@link ByteBuffer#remaining()}. ValueAccessor
 * implementations need to maintain this internally. ValueAccessors should also never modify the state of the
 * byte buffers view (ie: offset, limit). This would also apply to value accessors for simlilar types
 * (ie: netty's ByteBuf}.
 *
 * @param &lt;V&gt; the backing type
 */
public interface ValueAccessor&lt;V&gt;
{

    /**
     * Creates db objects using the given accessors value type. ObjectFactory instances are meant to be returned
     * by the factory() method of a value accessor.
     * @param &lt;V&gt; the backing type
     */
    public interface ObjectFactory&lt;V&gt;
    {
        Cell&lt;V&gt; cell(ColumnMetadata column, long timestamp, int ttl, long localDeletionTime, V value, CellPath path);
        Clustering&lt;V&gt; clustering(V... values);
        Clustering&lt;V&gt; clustering();
        Clustering&lt;V&gt; staticClustering();
        ClusteringBound&lt;V&gt; bound(ClusteringPrefix.Kind kind, V... values);
        ClusteringBound&lt;V&gt; bound(ClusteringPrefix.Kind kind);
        ClusteringBoundary&lt;V&gt; boundary(ClusteringPrefix.Kind kind, V... values);
        default ClusteringBoundOrBoundary&lt;V&gt; boundOrBoundary(ClusteringPrefix.Kind kind, V... values)
        {
<span class="fc bfc" id="L78" title="All 2 branches covered.">            return kind.isBoundary() ? boundary(kind, values) : bound(kind, values);</span>
        }

        default ClusteringBound&lt;V&gt; inclusiveOpen(boolean reversed, V[] boundValues)
        {
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">            return bound(reversed ? INCL_END_BOUND : INCL_START_BOUND, boundValues);</span>
        }

        default ClusteringBound&lt;V&gt; exclusiveOpen(boolean reversed, V[] boundValues)
        {
<span class="nc bnc" id="L88" title="All 2 branches missed.">            return bound(reversed ? EXCL_END_BOUND : EXCL_START_BOUND, boundValues);</span>
        }

        default ClusteringBound&lt;V&gt; inclusiveClose(boolean reversed, V[] boundValues)
        {
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">            return bound(reversed ? INCL_START_BOUND : INCL_END_BOUND, boundValues);</span>
        }

        default ClusteringBound&lt;V&gt; exclusiveClose(boolean reversed, V[] boundValues)
        {
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">            return bound(reversed ? EXCL_START_BOUND : EXCL_END_BOUND, boundValues);</span>
        }

        default ClusteringBoundary&lt;V&gt; inclusiveCloseExclusiveOpen(boolean reversed, V[] boundValues)
        {
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">            return boundary(reversed ? EXCL_END_INCL_START_BOUNDARY : INCL_END_EXCL_START_BOUNDARY, boundValues);</span>
        }

        default ClusteringBoundary&lt;V&gt; exclusiveCloseInclusiveOpen(boolean reversed, V[] boundValues)
        {
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">            return boundary(reversed ? INCL_END_EXCL_START_BOUNDARY : EXCL_END_INCL_START_BOUNDARY, boundValues);</span>
        }
    }
    /**
     * @return the size of the given value
     */
    int size(V value);

    /** serializes size including a vint length prefix */
    default int sizeWithVIntLength(V value)
    {
<span class="fc" id="L119">        int size = size(value);</span>
<span class="fc" id="L120">        return TypeSizes.sizeofUnsignedVInt(size) + size;</span>
    }

    /** serialized size including a short length prefix */
    default int sizeWithShortLength(V value)
    {
<span class="nc" id="L126">        return 2 + size(value);</span>
    }

    default int remaining(V value, int offset)
    {
<span class="nc" id="L131">        int size = size(value);</span>
<span class="nc" id="L132">        int rem = size - offset;</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">        return rem &gt; 0 ? rem : 0;</span>
    }

    /**
     * @return true if the size of the given value is zero, false otherwise
     */
    default boolean isEmpty(V value)
    {
<span class="fc bfc" id="L141" title="All 2 branches covered.">        return size(value) == 0;</span>
    }

    /**
     * @return the number of bytes remaining in the value from the given offset
     */
    default int sizeFromOffset(V value, int offset)
    {
<span class="fc" id="L149">        return size(value) - offset;</span>
    }

    /**
     * @return true if there are no bytes present after the given offset, false otherwise
     */
    default boolean isEmptyFromOffset(V value, int offset)
    {
<span class="fc bfc" id="L157" title="All 2 branches covered.">        return sizeFromOffset(value, offset) == 0;</span>
    }

    /**
     * allocate an instance of the accessors backing type
     * @param length size of backing typ to allocate
     */
    V[] createArray(int length);

    /**
     * Write the contents of the given value into the a DataOutputPlus
     */
    void write(V value, DataOutputPlus out) throws IOException;

    default void writeWithVIntLength(V value, DataOutputPlus out) throws IOException
    {
<span class="fc" id="L173">        out.writeUnsignedVInt32(size(value));</span>
<span class="fc" id="L174">        write(value, out);</span>
<span class="fc" id="L175">    }</span>

    /**
     * Write the contents of the given value into the ByteBuffer
     */
    void write(V value, ByteBuffer out);

    /**
     * copy the {@param size} bytes from the {@param src} value, starting at the offset {@param srcOffset} into
     * the {@param dst} value, starting at the offset {@param dstOffset}, using the accessor {@param dstAccessor}
     * @param &lt;V2&gt; the destination value type
     * @return the number of bytes copied ({@param size})
     */
    &lt;V2&gt; int copyTo(V src, int srcOffset, V2 dst, ValueAccessor&lt;V2&gt; dstAccessor, int dstOffset, int size);

    /**
     * copies a byte array into this accessors value.
     */
    int copyByteArrayTo(byte[] src, int srcOffset, V dst, int dstOffset, int size);

    /**
     * copies a byte buffer into this accessors value.
     */
    int copyByteBufferTo(ByteBuffer src, int srcOffset, V dst, int dstOffset, int size);

    /**
     * updates {@param digest} with {@param size} bytes from the contents of {@param value} starting
     * at offset {@param offset}
     */
    void digest(V value, int offset, int size, Digest digest);

    /**
     * updates {@param digest} with te contents of {@param value}
     */
    default void digest(V value, Digest digest)
    {
<span class="fc" id="L211">        digest(value, 0, size(value), digest);</span>
<span class="fc" id="L212">    }</span>

    /**
     * Reads a value of {@param length} bytes from {@param in}
     */
    V read(DataInputPlus in, int length) throws IOException;

    /**
     * Returns a value with the contents of {@param input} from {@param offset} to {@param length}.
     *
     * Depending on the accessor implementation, this method may:
     *  * allocate a new {@param &lt;V&gt;} object of {@param length}, and copy data into it
     *  * return a view of {@param input} where changes to one will be reflected in the other
     */
    V slice(V input, int offset, int length);

    /**
     * same as {@link ValueAccessor#slice(Object, int, int)}, except the length is taken from the first
     * 2 bytes from the given offset (and not included in the return value)
     */
    default V sliceWithShortLength(V input, int offset)
    {
<span class="nc" id="L234">        int size = getUnsignedShort(input, offset);</span>
<span class="nc" id="L235">        return slice(input, offset + 2, size);</span>
    }

    /**
     * lexicographically compare {@param left} to {@param right}
     * @param &lt;VR&gt; backing type of
     */
    &lt;VR&gt; int compare(V left, VR right, ValueAccessor&lt;VR&gt; accessorR);

    /**
     * compare a byte array on the left with a {@param &lt;V&gt;} on the right}
     */
    int compareByteArrayTo(byte[] left, V right);

    /**
     * compare a byte buffer on the left with a {@param &lt;V&gt;} on the right}
     */
    int compareByteBufferTo(ByteBuffer left, V right);

    default int hashCode(V value)
    {
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">        if (value == null)</span>
<span class="nc" id="L257">            return 0;</span>

<span class="fc" id="L259">        int result = 1;</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">        for (int i=0, isize=size(value); i&lt;isize; i++)</span>
<span class="fc" id="L261">            result = 31 * result + (int) getByte(value, i);</span>

<span class="fc" id="L263">        return result;</span>
    }

    /**
     * returns a ByteBuffer with the contents of {@param value}
     *
     * Depending on the accessor implementation, this method may:
     *  * allocate a new ByteBuffer and copy data into it
     *  * return the value, if the backing type is a bytebuffer
     */
    ByteBuffer toBuffer(V value);

    /**
     * returns a byte[] with the contents of {@param value}
     *
     * Depending on the accessor implementation, this method may:
     *  * allocate a new byte[] object and copy data into it
     *  * return the value, if the backing type is byte[]
     */
    byte[] toArray(V value);

    /**
     * returns a byte[] with {@param length} bytes copied from the contents of {@param value}
     * starting at offset {@param offset}.
     *
     * Depending on the accessor implementation, this method may:
     *  * allocate a new byte[] object and copy data into it
     *  * return the value, if the backing type is byte[], offset is 0 and {@param length} == size(value)
     */
    byte[] toArray(V value, int offset, int length);
    String toString(V value, Charset charset) throws CharacterCodingException;

    default String toString(V value) throws CharacterCodingException
    {
<span class="nc" id="L297">        return toString(value, StandardCharsets.UTF_8);</span>
    }

    String toHex(V value);

    /** returns a boolean from offset {@param offset} */
    default boolean getBoolean(V value, int offset)
    {
<span class="nc bnc" id="L305" title="All 2 branches missed.">        return getByte(value, offset) != 0;</span>
    }

    /** returns a byte from offset 0 */
    byte toByte(V value);
    /** returns a byte from offset {@param offset} */
    byte getByte(V value, int offset);
    /** returns a short from offset 0 */
    short toShort(V value);
    /** returns a short from offset {@param offset} */
    short getShort(V value, int offset);
    /** returns an unsigned short from offset {@param offset} */
    int getUnsignedShort(V value, int offset);
    /** returns an int from offset 0 */
    int toInt(V value);
    /** returns an int from offset {@param offset} */
    int getInt(V value, int offset);

    default long getUnsignedVInt(V value, int offset)
    {
<span class="nc" id="L325">        return VIntCoding.getUnsignedVInt(value, this, offset);</span>
    }

    default int getUnsignedVInt32(V value, int offset)
    {
<span class="nc" id="L330">        return VIntCoding.getUnsignedVInt32(value, this, offset);</span>
    }

    default long getVInt(V value, int offset)
    {
<span class="nc" id="L335">        return VIntCoding.getVInt(value, this, offset);</span>
    }

    default int getVInt32(V value, int offset)
    {
<span class="nc" id="L340">        return VIntCoding.getVInt32(value, this, offset);</span>
    }

    float getFloat(V value, int offset);
    double getDouble(V value, int offset);
    /** returns a long from offset 0 */
    long toLong(V value);
    /** returns a long from offset {@param offset} */
    long getLong(V value, int offset);
    /** returns a float from offset 0 */
    float toFloat(V value);

    /** returns a double from offset 0 */
    double toDouble(V value);

    /** returns a UUID from offset 0 */
    UUID toUUID(V value);

    /** returns a TimeUUID from offset 0 */
    TimeUUID toTimeUUID(V value);

    /** returns a TimeUUID from offset 0 */
    Ballot toBallot(V value);

    /**
     * writes the byte value {@param value} to {@param dst} at offset {@param offset}
     * @return the number of bytes written to {@param value}
     */
    int putByte(V dst, int offset, byte value);

    /**
     * writes the short value {@param value} to {@param dst} at offset {@param offset}
     * @return the number of bytes written to {@param value}
     */
    int putShort(V dst, int offset, short value);

    /**
     * writes the int value {@param value} to {@param dst} at offset {@param offset}
     * @return the number of bytes written to {@param value}
     */
    int putInt(V dst, int offset, int value);

    /**
     * writes the long value {@param value} to {@param dst} at offset {@param offset}
     * @return the number of bytes written to {@param value}
     */
    int putLong(V dst, int offset, long value);

    /**
     * writes the float value {@param value} to {@param dst} at offset {@param offset}
     * @return the number of bytes written to {@param value}
     */
    int putFloat(V dst, int offset, float value);

    default int putBytes(V dst, int offset, byte[] src, int srcOffset, int length)
    {
<span class="nc" id="L396">        return ByteArrayAccessor.instance.copyTo(src, srcOffset, dst, this, offset, length);</span>
    }

    default int putBytes(V dst, int offset, byte[] src)
    {
<span class="nc" id="L401">        return putBytes(dst, offset, src, 0, src.length);</span>
    }

    default int putUnsignedVInt(V dst, int offset, long value)
    {
<span class="nc" id="L406">        return VIntCoding.writeUnsignedVInt(value, dst, offset, this);</span>
    }

    default int putUnsignedVInt32(V dst, int offset, int value)
    {
<span class="nc" id="L411">        return VIntCoding.writeUnsignedVInt32(value, dst, offset, this);</span>
    }

    default int putVInt(V dst, int offset, long value)
    {
<span class="nc" id="L416">        return VIntCoding.writeVInt(value, dst, offset, this);</span>
    }

    default int putVInt32(V dst, int offset, int value)
    {
<span class="nc" id="L421">        return VIntCoding.writeVInt32(value, dst, offset, this);</span>
    }

    /** return a value with a length of 0 */
    V empty();

    /**
     * return a value containing the {@param bytes}
     *
     * Caller should assume that modifying the returned value
     * will also modify the contents of {@param bytes}
     */
    V valueOf(byte[] bytes);

    /**
     * return a value containing the {@param bytes}
     *
     * {@param src} and the returned value may share a common byte array instance, so caller should
     * assume that modifying the returned value will also modify the contents of {@param src}
     */
    V valueOf(ByteBuffer bytes);

    /** return a value containing the bytes for the given string and charset */
    V valueOf(String s, Charset charset);

    /** return a value with the bytes from {@param v}*/
    V valueOf(UUID v);
    /** return a value with the bytes from {@param v}*/
    V valueOf(boolean v);
    /** return a value with the bytes from {@param v}*/
    V valueOf(byte v);
    /** return a value with the bytes from {@param v}*/
    V valueOf(short v);
    /** return a value with the bytes from {@param v}*/
    V valueOf(int v);
    /** return a value with the bytes from {@param v}*/
    V valueOf(long v);
    /** return a value with the bytes from {@param v}*/
    V valueOf(float v);
    /** return a value with the bytes from {@param v}*/
    V valueOf(double v);

    /**
     * Convert the data in {@param src} to {@param &lt;V&gt;}
     *
     * {@param src} and the returned value may share a common byte array instance, so caller should
     * assume that modifying the returned value will also modify the contents of {@param src}
     */
    &lt;V2&gt; V convert(V2 src, ValueAccessor&lt;V2&gt; accessor);

    /**
     * Allocate and return a {@param &lt;V&gt;} instance of {@param size} bytes on the heap.
     */
    V allocate(int size);

    /**
     * returns the {@link ValueAccessor.ObjectFactory} for the backing type {@param &lt;V&gt;}
     */
    ObjectFactory&lt;V&gt; factory();

    /**
     * lexicographically compare {@param left} to {@param right}
     */
    public static &lt;L, R&gt; int compare(L left, ValueAccessor&lt;L&gt; leftAccessor, R right, ValueAccessor&lt;R&gt; rightAccessor)
    {
<span class="fc" id="L486">        return leftAccessor.compare(left, right, rightAccessor);</span>
    }

    public static &lt;L, R&gt; boolean equals(L left, ValueAccessor&lt;L&gt; leftAccessor, R right, ValueAccessor&lt;R&gt; rightAccessor)
    {
<span class="fc bfc" id="L491" title="All 2 branches covered.">        return compare(left, leftAccessor, right, rightAccessor) == 0;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>