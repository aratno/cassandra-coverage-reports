<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NettyStreamingChannel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.streaming.async</a> &gt; <span class="el_source">NettyStreamingChannel.java</span></div><h1>NettyStreamingChannel.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.streaming.async;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.util.Collection;
import java.util.Collections;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.IntFunction;

import com.google.common.annotations.VisibleForTesting;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.netty.buffer.ByteBuf;
import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.util.AttributeKey;
import io.netty.util.ReferenceCountUtil;
import org.apache.cassandra.net.AsyncChannelPromise;
import org.apache.cassandra.net.AsyncStreamingInputPlus;
import org.apache.cassandra.net.AsyncStreamingOutputPlus;
import org.apache.cassandra.net.GlobalBufferPoolAllocator;
import org.apache.cassandra.streaming.StreamingChannel;
import org.apache.cassandra.streaming.StreamingDataInputPlus;
import org.apache.cassandra.streaming.StreamingDataOutputPlus;
import org.apache.cassandra.streaming.StreamingDataOutputPlusFixed;
import org.apache.cassandra.utils.concurrent.Future;
import org.apache.cassandra.utils.concurrent.ImmediateFuture;

import static io.netty.util.AttributeKey.valueOf;
import static java.lang.Boolean.FALSE;

public class NettyStreamingChannel extends ChannelInboundHandlerAdapter implements StreamingChannel
{
<span class="fc" id="L56">    private static final Logger logger = LoggerFactory.getLogger(NettyStreamingChannel.class);</span>
<span class="fc" id="L57">    private static volatile boolean trackInboundHandlers = false;</span>
    private static Collection&lt;NettyStreamingChannel&gt; inboundHandlers;

    @VisibleForTesting
<span class="fc" id="L61">    static final AttributeKey&lt;Boolean&gt; TRANSFERRING_FILE_ATTR = valueOf(&quot;transferringFile&quot;);</span>
    final Channel channel;

    /**
     * A collection of {@link ByteBuf}s that are yet to be processed. Incoming buffers are first dropped into this
     * structure, and then consumed.
     * &lt;p&gt;
     * For thread safety, this structure's resources are released on the consuming thread
     * (via {@link AsyncStreamingInputPlus#close()},
     * but the producing side calls {@link AsyncStreamingInputPlus#requestClosure()} to notify the input that it should close.
     */
    @VisibleForTesting
    final AsyncStreamingInputPlus in;

    private volatile boolean closed;

    public NettyStreamingChannel(Channel channel, Kind kind)
<span class="fc" id="L78">    {</span>
<span class="fc" id="L79">        this.channel = channel;</span>
<span class="fc" id="L80">        channel.attr(TRANSFERRING_FILE_ATTR).set(FALSE);</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">        if (kind == Kind.CONTROL)</span>
        {
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">            if (trackInboundHandlers)</span>
<span class="nc" id="L84">                inboundHandlers.add(this);</span>
<span class="fc" id="L85">            in = new AsyncStreamingInputPlus(channel);</span>
        }
<span class="fc" id="L87">        else in = null;</span>
<span class="fc" id="L88">    }</span>

    @Override
    public Object id()
    {
<span class="fc" id="L93">        return channel.id();</span>
    }

    @Override
    public String description()
    {
<span class="fc" id="L99">        return &quot;channel.remote &quot; + channel.remoteAddress() +</span>
<span class="fc" id="L100">               &quot; channel.local &quot; + channel.localAddress() +</span>
<span class="fc" id="L101">               &quot; channel.id &quot; + channel.id();</span>
    }

    @Override
    public InetSocketAddress peer()
    {
<span class="fc" id="L107">        return (InetSocketAddress) channel.remoteAddress();</span>
    }

    @Override
    public InetSocketAddress connectedTo()
    {
<span class="fc" id="L113">        return peer();</span>
    }

    @Override
    public boolean connected()
    {
<span class="fc" id="L119">        return channel.isOpen();</span>
    }

    public StreamingDataInputPlus in()
    {
<span class="fc" id="L124">        return in;</span>
    }

    public StreamingDataOutputPlus acquireOut()
    {
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">        if (!channel.attr(TRANSFERRING_FILE_ATTR).compareAndSet(false, true))</span>
<span class="nc" id="L130">            throw new IllegalStateException(&quot;channel's transferring state is currently set to true. refusing to start new stream&quot;);</span>

<span class="fc" id="L132">        return new AsyncStreamingOutputPlus(channel)</span>
<span class="fc" id="L133">        {</span>
            @Override
            public void close() throws IOException
            {
                try
                {
<span class="fc" id="L139">                    super.close();</span>
                }
                finally
                {
<span class="fc" id="L143">                    NettyStreamingChannel.this.channel.attr(TRANSFERRING_FILE_ATTR).set(FALSE);</span>
                }
<span class="fc" id="L145">            }</span>
        };
    }

    public Future&lt;?&gt; send(Send send)
    {
<span class="fc" id="L151">        class Factory implements IntFunction&lt;StreamingDataOutputPlus&gt;</span>
        {
            ByteBuf buf;
            ByteBuffer buffer;

            @Override
            public StreamingDataOutputPlus apply(int size)
            {
<span class="fc" id="L159">                buf = GlobalBufferPoolAllocator.instance.buffer(size);</span>
<span class="fc" id="L160">                buffer = buf.nioBuffer(buf.writerIndex(), size);</span>
<span class="fc" id="L161">                return new StreamingDataOutputPlusFixed(buffer);</span>
            }
        }

<span class="fc" id="L165">        Factory factory = new Factory();</span>
        try
        {
<span class="fc" id="L168">            send.send(factory);</span>
<span class="fc" id="L169">            ByteBuf buf = factory.buf;</span>
<span class="fc" id="L170">            ByteBuffer buffer = factory.buffer;</span>
            try
            {
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">                assert buffer.position() == buffer.limit();</span>
<span class="fc" id="L174">                buf.writerIndex(buffer.position());</span>
<span class="fc" id="L175">                AsyncChannelPromise promise = new AsyncChannelPromise(channel);</span>
<span class="fc" id="L176">                channel.writeAndFlush(buf, promise);</span>
<span class="fc" id="L177">                return promise;</span>
            }
<span class="nc" id="L179">            catch (Throwable t)</span>
            {
<span class="nc" id="L181">                buf.release();</span>
<span class="nc" id="L182">                throw t;</span>
            }
        }
<span class="nc" id="L185">        catch (Throwable t)</span>
        {
<span class="nc" id="L187">            return ImmediateFuture.failure(t);</span>
        }
    }

    @Override
    public synchronized io.netty.util.concurrent.Future&lt;?&gt; close()
    {
<span class="fc bfc" id="L194" title="All 2 branches covered.">        if (closed)</span>
<span class="fc" id="L195">            return channel.closeFuture();</span>

<span class="fc" id="L197">        closed = true;</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">        if (in != null)</span>
        {
<span class="fc" id="L200">            in.requestClosure();</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">            if (trackInboundHandlers)</span>
<span class="nc" id="L202">                inboundHandlers.remove(this);</span>
        }

<span class="fc" id="L205">        return channel.close();</span>
    }

    @Override
    public void onClose(Runnable runOnClose)
    {
<span class="fc" id="L211">        channel.closeFuture().addListener(ignore -&gt; runOnClose.run());</span>
<span class="fc" id="L212">    }</span>

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object message)
    {
<span class="pc bpc" id="L217" title="3 of 6 branches missed.">        if (closed || !(message instanceof ByteBuf) || !in.append((ByteBuf) message))</span>
<span class="nc" id="L218">            ReferenceCountUtil.release(message);</span>
<span class="fc" id="L219">    }</span>

    @Override
    public void channelInactive(ChannelHandlerContext ctx)
    {
<span class="fc" id="L224">        close();</span>
<span class="fc" id="L225">        ctx.fireChannelInactive();</span>
<span class="fc" id="L226">    }</span>

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)
    {
<span class="nc bnc" id="L231" title="All 2 branches missed.">        if (cause instanceof IOException)</span>
<span class="nc" id="L232">            logger.trace(&quot;connection problem while streaming&quot;, cause);</span>
        else
<span class="nc" id="L234">            logger.warn(&quot;exception occurred while in processing streaming data&quot;, cause);</span>
<span class="nc" id="L235">        close();</span>
<span class="nc" id="L236">    }</span>

    /** Shutdown for in-JVM tests. For any other usage, tracking of active inbound streaming handlers
     *  should be revisted first and in-JVM shutdown refactored with it.
     *  This does not prevent new inbound handlers being added after shutdown, nor is not thread-safe
     *  around new inbound handlers being opened during shutdown.
     */
    @VisibleForTesting
    public static void shutdown()
    {
<span class="nc bnc" id="L246" title="All 2 branches missed.">        assert trackInboundHandlers : &quot;in-JVM tests required tracking of inbound streaming handlers&quot;;</span>

<span class="nc" id="L248">        inboundHandlers.forEach(NettyStreamingChannel::close);</span>
<span class="nc" id="L249">        inboundHandlers.clear();</span>
<span class="nc" id="L250">    }</span>

    public static void trackInboundHandlers()
    {
<span class="nc" id="L254">        inboundHandlers = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;());</span>
<span class="nc" id="L255">        trackInboundHandlers = true;</span>
<span class="nc" id="L256">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>