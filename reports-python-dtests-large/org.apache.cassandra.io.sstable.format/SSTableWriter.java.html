<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SSTableWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.io.sstable.format</a> &gt; <span class="el_source">SSTableWriter.java</span></div><h1>SSTableWriter.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.io.sstable.format;

import java.io.IOError;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import java.util.function.Supplier;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.SerializationHeader;
import org.apache.cassandra.db.lifecycle.LifecycleNewTracker;
import org.apache.cassandra.db.rows.UnfilteredRowIterator;
import org.apache.cassandra.dht.AbstractBounds;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.index.Index;
import org.apache.cassandra.io.FSWriteError;
import org.apache.cassandra.io.sstable.AbstractRowIndexEntry;
import org.apache.cassandra.io.sstable.Component;
import org.apache.cassandra.io.sstable.Descriptor;
import org.apache.cassandra.io.sstable.SSTable;
import org.apache.cassandra.io.sstable.SSTableFlushObserver;
import org.apache.cassandra.io.sstable.SSTableZeroCopyWriter;
import org.apache.cassandra.io.sstable.format.SSTableFormat.Components;
import org.apache.cassandra.io.sstable.metadata.MetadataCollector;
import org.apache.cassandra.io.sstable.metadata.MetadataComponent;
import org.apache.cassandra.io.sstable.metadata.MetadataType;
import org.apache.cassandra.io.sstable.metadata.StatsMetadata;
import org.apache.cassandra.io.util.MmappedRegionsCache;
import org.apache.cassandra.utils.Throwables;
import org.apache.cassandra.utils.TimeUUID;
import org.apache.cassandra.utils.concurrent.Transactional;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * A root class for a writer implementation. A writer must be created by passing an implementation-specific
 * {@link Builder}, a {@link LifecycleNewTracker} and {@link SSTable.Owner} instances. Implementing classes should
 * not extend that list and all the additional properties should be included in the builder.
 */
public abstract class SSTableWriter extends SSTable implements Transactional
{
<span class="fc" id="L71">    private final static Logger logger = LoggerFactory.getLogger(SSTableWriter.class);</span>

    protected long repairedAt;
    protected TimeUUID pendingRepair;
    protected boolean isTransient;
<span class="fc" id="L76">    protected long maxDataAge = -1;</span>
    protected final long keyCount;
    protected final MetadataCollector metadataCollector;
    protected final SerializationHeader header;
    protected final List&lt;SSTableFlushObserver&gt; observers;
    protected final MmappedRegionsCache mmappedRegionsCache;
<span class="fc" id="L82">    protected final TransactionalProxy txnProxy = txnProxy();</span>
    protected final LifecycleNewTracker lifecycleNewTracker;
    protected DecoratedKey first;
    protected DecoratedKey last;

    /**
     * The implementing method should return an instance of {@link TransactionalProxy} initialized with a list of all
     * transactional resources included in this writer.
     */
    protected abstract TransactionalProxy txnProxy();

    protected SSTableWriter(Builder&lt;?, ?&gt; builder, LifecycleNewTracker lifecycleNewTracker, SSTable.Owner owner)
    {
<span class="fc" id="L95">        super(builder, owner);</span>
<span class="fc" id="L96">        checkNotNull(builder.getIndexGroups());</span>
<span class="fc" id="L97">        checkNotNull(builder.getMetadataCollector());</span>
<span class="fc" id="L98">        checkNotNull(builder.getSerializationHeader());</span>

<span class="fc" id="L100">        this.keyCount = builder.getKeyCount();</span>
<span class="fc" id="L101">        this.repairedAt = builder.getRepairedAt();</span>
<span class="fc" id="L102">        this.pendingRepair = builder.getPendingRepair();</span>
<span class="fc" id="L103">        this.isTransient = builder.isTransientSSTable();</span>
<span class="fc" id="L104">        this.metadataCollector = builder.getMetadataCollector();</span>
<span class="fc" id="L105">        this.header = builder.getSerializationHeader();</span>
<span class="fc" id="L106">        this.mmappedRegionsCache = builder.getMmappedRegionsCache();</span>
<span class="fc" id="L107">        this.lifecycleNewTracker = lifecycleNewTracker;</span>

        // We need to ensure that no sstable components exist before the lifecycle transaction starts tracking it.
        // Otherwise, it means that we either want to overwrite some existing sstable, which is not allowed, or some
        // sstable files were created before the sstable is registered in the lifecycle transaction, which may lead
        // to a race such that the sstable is listed as completed due to the lack of the transaction file before
        // anything is actually written to it.
<span class="fc" id="L114">        Set&lt;Component&gt; existingComponents = Sets.filter(components, c -&gt; descriptor.fileFor(c).exists());</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">        assert existingComponents.isEmpty() : String.format(&quot;Cannot create a new SSTable in directory %s as component files %s already exist there&quot;,</span>
                                                            descriptor.directory,
                                                            existingComponents);

<span class="fc" id="L119">        lifecycleNewTracker.trackNew(this);</span>

        try
        {
<span class="fc" id="L123">            ArrayList&lt;SSTableFlushObserver&gt; observers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L124">            this.observers = Collections.unmodifiableList(observers);</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">            for (Index.Group group : builder.getIndexGroups())</span>
            {
<span class="nc" id="L127">                SSTableFlushObserver observer = group.getFlushObserver(descriptor, lifecycleNewTracker, metadata.getLocal());</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">                if (observer != null)</span>
                {
<span class="nc" id="L130">                    observer.begin();</span>
<span class="nc" id="L131">                    observers.add(observer);</span>
                }
<span class="nc" id="L133">            }</span>
        }
<span class="nc" id="L135">        catch (RuntimeException | IOError ex)</span>
        {
<span class="nc" id="L137">            handleConstructionFailure(ex);</span>
<span class="nc" id="L138">            throw ex;</span>
<span class="fc" id="L139">        }</span>
<span class="fc" id="L140">    }</span>

    /**
     * Constructors of subclasses, if they open any resources, should wrap that in a try-catch block and call this
     * method in the 'catch' section after closing any resources opened in the constructor. This method would remove
     * the sstable from the transaction and delete the orphaned components, if any were created during the construction.
     * The caught exception should be then rethrown so the {@link Builder} can handle it and close any resources opened
     * implicitly by the builder.
     * &lt;p&gt;
     * See {@link SortedTableWriter#SortedTableWriter(SortedTableWriter.Builder, LifecycleNewTracker, Owner)} as of CASSANDRA-18737.
     *
     * @param ex the exception thrown during the construction
     */
    protected void handleConstructionFailure(Throwable ex)
    {
<span class="nc" id="L155">        logger.warn(&quot;Failed to open &quot; + descriptor + &quot; for writing&quot;, ex);</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">        for (int i = observers.size()-1; i &gt;= 0; i--)</span>
<span class="nc" id="L157">            observers.get(i).abort(ex);</span>
<span class="nc" id="L158">        descriptor.getFormat().deleteOrphanedComponents(descriptor, components);</span>
<span class="nc" id="L159">        lifecycleNewTracker.untrackNew(this);</span>
<span class="nc" id="L160">    }</span>

    @Override
    public DecoratedKey getFirst()
    {
<span class="nc" id="L165">        return first;</span>
    }

    @Override
    public DecoratedKey getLast()
    {
<span class="nc" id="L171">        return last;</span>
    }

    @Override
    public AbstractBounds&lt;Token&gt; getBounds()
    {
<span class="nc bnc" id="L177" title="All 4 branches missed.">        return (first != null &amp;&amp; last != null) ? AbstractBounds.bounds(first.getToken(), true, last.getToken(), true)</span>
<span class="nc" id="L178">                                               : null;</span>
    }

    public abstract void mark();

    /**
     * Appends partition data to this writer.
     *
     * @param iterator the partition to write
     * @return the created index entry if something was written, that is if {@code iterator}
     * wasn't empty, {@code null} otherwise.
     *
     * @throws FSWriteError if writing to the dataFile fails
     */
    public abstract AbstractRowIndexEntry append(UnfilteredRowIterator iterator);

    /**
     * Returns a position in the uncompressed data - for uncompressed files it is the same as {@link #getOnDiskFilePointer()}
     * but for compressed files it returns a position in the data rather than a position in the file on disk.
     */
    public abstract long getFilePointer();

    /**
     * Returns a position in the (compressed) data file on disk. See {@link #getFilePointer()}
     */
    public abstract long getOnDiskFilePointer();

    /**
     * Returns the amount of data already written to disk that may not be accurate (for example, the position after
     * the recently flushed chunk).
     */
    public long getEstimatedOnDiskBytesWritten()
    {
<span class="nc" id="L211">        return getOnDiskFilePointer();</span>
    }

    /**
     * Reset the data file to the marked position (see {@link #mark()}) and truncate the rest of the file.
     */
    public abstract void resetAndTruncate();

    public void setRepairedAt(long repairedAt)
    {
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">        if (repairedAt &gt; 0)</span>
<span class="nc" id="L222">            this.repairedAt = repairedAt;</span>
<span class="fc" id="L223">    }</span>

    public void setMaxDataAge(long maxDataAge)
    {
<span class="fc" id="L227">        this.maxDataAge = maxDataAge;</span>
<span class="fc" id="L228">    }</span>

    public SSTableWriter setTokenSpaceCoverage(double rangeSpanned)
    {
<span class="nc" id="L232">        metadataCollector.tokenSpaceCoverage(rangeSpanned);</span>
<span class="nc" id="L233">        return this;</span>
    }

    public void setOpenResult(boolean openResult)
    {
<span class="fc" id="L238">        txnProxy.openResult = openResult;</span>
<span class="fc" id="L239">    }</span>

    /**
     * Open the resultant SSTableReader before it has been fully written.
     * &lt;p&gt;
     * The passed consumer will be called when the necessary data has been flushed to disk/cache. This may never happen
     * (e.g. if the table was finished before the flushes materialized, or if this call returns false e.g. if a table
     * was already prepared but hasn't reached readiness yet).
     * &lt;p&gt;
     * Uses callback instead of future because preparation and callback happen on the same thread.
     */

    public abstract void openEarly(Consumer&lt;SSTableReader&gt; doWhenReady);

    /**
     * Open the resultant SSTableReader once it has been fully written, but before the
     * _set_ of tables that are being written together as one atomic operation are all ready
     */
    public abstract SSTableReader openFinalEarly();

    protected abstract SSTableReader openFinal(SSTableReader.OpenReason openReason);

    public SSTableReader finish(boolean openResult)
    {
<span class="fc" id="L263">        this.setOpenResult(openResult);</span>
<span class="fc" id="L264">        observers.forEach(SSTableFlushObserver::complete);</span>
<span class="fc" id="L265">        txnProxy.finish();</span>
<span class="fc" id="L266">        return finished();</span>
    }

    /**
     * Open the resultant SSTableReader once it has been fully written, and all related state
     * is ready to be finalised including other sstables being written involved in the same operation
     */
    public SSTableReader finished()
    {
<span class="fc" id="L275">        txnProxy.finalReaderAccessed = true;</span>
<span class="fc" id="L276">        return txnProxy.finalReader;</span>
    }

    // finalise our state on disk, including renaming
    public final void prepareToCommit()
    {
<span class="fc" id="L282">        txnProxy.prepareToCommit();</span>
<span class="fc" id="L283">    }</span>

    public final Throwable commit(Throwable accumulate)
    {
        try
        {
<span class="fc" id="L289">            observers.forEach(SSTableFlushObserver::complete);</span>
        }
<span class="nc" id="L291">        catch (Throwable t)</span>
        {
            // Return without advancing to COMMITTED, which will trigger abort() when the Transactional closes...
<span class="nc" id="L294">            return Throwables.merge(accumulate, t);</span>
<span class="fc" id="L295">        }</span>

<span class="fc" id="L297">        return txnProxy.commit(accumulate);</span>
    }

    public final Throwable abort(Throwable accumulate)
    {
        try
        {
<span class="fc" id="L304">            return txnProxy.abort(accumulate);</span>
        }
        finally
        {
<span class="pc" id="L308">            observers.forEach(observer -&gt; observer.abort(accumulate));</span>
        }
    }

    public final void close()
    {
<span class="nc" id="L314">        txnProxy.close();</span>
<span class="nc" id="L315">    }</span>

    public final void abort()
    {
        try
        {
<span class="fc" id="L321">            txnProxy.abort();</span>
        }
        finally
        {
<span class="pc" id="L325">            observers.forEach(observer -&gt; observer.abort(null));</span>
        }
<span class="fc" id="L327">    }</span>

    protected Map&lt;MetadataType, MetadataComponent&gt; finalizeMetadata()
    {
<span class="fc" id="L331">        return metadataCollector.finalizeMetadata(getPartitioner().getClass().getCanonicalName(),</span>
<span class="fc" id="L332">                                                  metadata().params.bloomFilterFpChance,</span>
                                                  repairedAt,
                                                  pendingRepair,
                                                  isTransient,
                                                  header,
<span class="fc" id="L337">                                                  first.retainable().getKey(),</span>
<span class="fc" id="L338">                                                  last.retainable().getKey());</span>
    }

    protected StatsMetadata statsMetadata()
    {
<span class="fc" id="L343">        return (StatsMetadata) finalizeMetadata().get(MetadataType.STATS);</span>
    }

    public void releaseMetadataOverhead()
    {
<span class="fc" id="L348">        metadataCollector.release();</span>
<span class="fc" id="L349">    }</span>

    /**
     * Parameters for calculating the expected size of an SSTable. Exposed on memtable flush sets (i.e. collected
     * subsets of a memtable that will be written to sstables).
     */
    public interface SSTableSizeParameters
    {
        long partitionCount();
        long partitionKeysSize();
        long dataSize();
    }

    // due to lack of multiple inheritance, we use an inner class to proxy our Transactional implementation details
    protected class TransactionalProxy extends AbstractTransactional
    {
        // should be set during doPrepare()
        private final Supplier&lt;ImmutableList&lt;Transactional&gt;&gt; transactionals;

        private SSTableReader finalReader;
        private boolean openResult;
        private boolean finalReaderAccessed;

        public TransactionalProxy(Supplier&lt;ImmutableList&lt;Transactional&gt;&gt; transactionals)
<span class="fc" id="L373">        {</span>
<span class="fc" id="L374">            this.transactionals = transactionals;</span>
<span class="fc" id="L375">        }</span>

        // finalise our state on disk, including renaming
        protected void doPrepare()
        {
<span class="fc" id="L380">            transactionals.get().forEach(Transactional::prepareToCommit);</span>
<span class="fc" id="L381">            new StatsComponent(finalizeMetadata()).save(descriptor);</span>

            // save the table of components
<span class="fc" id="L384">            TOCComponent.appendTOC(descriptor, components);</span>

<span class="pc bpc" id="L386" title="1 of 2 branches missed.">            if (openResult)</span>
<span class="fc" id="L387">                finalReader = openFinal(SSTableReader.OpenReason.NORMAL);</span>
<span class="fc" id="L388">        }</span>

        protected Throwable doCommit(Throwable accumulate)
        {
<span class="fc bfc" id="L392" title="All 2 branches covered.">            for (Transactional t : transactionals.get().reverse())</span>
<span class="fc" id="L393">                accumulate = t.commit(accumulate);</span>

<span class="fc" id="L395">            return accumulate;</span>
        }

        protected Throwable doAbort(Throwable accumulate)
        {
<span class="fc bfc" id="L400" title="All 2 branches covered.">            for (Transactional t : transactionals.get())</span>
<span class="fc" id="L401">                accumulate = t.abort(accumulate);</span>

<span class="pc bpc" id="L403" title="2 of 4 branches missed.">            if (!finalReaderAccessed &amp;&amp; finalReader != null)</span>
            {
<span class="nc" id="L405">                accumulate = Throwables.perform(accumulate, () -&gt; finalReader.selfRef().release());</span>
<span class="nc" id="L406">                finalReader = null;</span>
<span class="nc" id="L407">                finalReaderAccessed = false;</span>
            }

<span class="fc" id="L410">            return accumulate;</span>
        }

        @Override
        protected Throwable doPostCleanup(Throwable accumulate)
        {
<span class="fc" id="L416">            accumulate = super.doPostCleanup(accumulate);</span>
<span class="fc" id="L417">            accumulate = Throwables.close(accumulate, mmappedRegionsCache);</span>
<span class="fc" id="L418">            return accumulate;</span>
        }
    }

    /**
     * A builder of this sstable writer. It should be extended for each implementation with the specific fields.
     *
     * An implementation should open all the resources when {@link #build(LifecycleNewTracker, Owner)} and pass them
     * in builder fields to the writer, so that the writer can access them via getters.
     *
     * @param &lt;W&gt; type of the sstable writer to be build with this builder
     * @param &lt;B&gt; type of this builder
     */
    public abstract static class Builder&lt;W extends SSTableWriter, B extends Builder&lt;W, B&gt;&gt; extends SSTable.Builder&lt;W, B&gt;
    {
        private MetadataCollector metadataCollector;
        private long keyCount;
        private long repairedAt;
        private TimeUUID pendingRepair;
        private boolean transientSSTable;
        private SerializationHeader serializationHeader;
        private List&lt;Index.Group&gt; indexGroups;

        public B setMetadataCollector(MetadataCollector metadataCollector)
        {
<span class="fc" id="L443">            this.metadataCollector = metadataCollector;</span>
<span class="fc" id="L444">            return (B) this;</span>
        }

        public B setKeyCount(long keyCount)
        {
<span class="fc" id="L449">            this.keyCount = keyCount;</span>
<span class="fc" id="L450">            return (B) this;</span>
        }

        public B setRepairedAt(long repairedAt)
        {
<span class="fc" id="L455">            this.repairedAt = repairedAt;</span>
<span class="fc" id="L456">            return (B) this;</span>
        }

        public B setPendingRepair(TimeUUID pendingRepair)
        {
<span class="fc" id="L461">            this.pendingRepair = pendingRepair;</span>
<span class="fc" id="L462">            return (B) this;</span>
        }

        public B setTransientSSTable(boolean transientSSTable)
        {
<span class="fc" id="L467">            this.transientSSTable = transientSSTable;</span>
<span class="fc" id="L468">            return (B) this;</span>
        }

        public B setSerializationHeader(SerializationHeader serializationHeader)
        {
<span class="fc" id="L473">            this.serializationHeader = serializationHeader;</span>
<span class="fc" id="L474">            return (B) this;</span>
        }

        public B addDefaultComponents(Collection&lt;Index.Group&gt; indexGroups)
        {
<span class="fc" id="L479">            checkNotNull(getTableMetadataRef());</span>

<span class="fc" id="L481">            addComponents(ImmutableSet.of(Components.DATA, Components.STATS, Components.DIGEST, Components.TOC));</span>

<span class="fc bfc" id="L483" title="All 2 branches covered.">            if (getTableMetadataRef().getLocal().params.compression.isEnabled())</span>
            {
<span class="fc" id="L485">                addComponents(ImmutableSet.of(Components.COMPRESSION_INFO));</span>
            }
            else
            {
                // it would feel safer to actually add this component later in maybeWriteDigest(),
                // but the components are unmodifiable after construction
<span class="fc" id="L491">                addComponents(ImmutableSet.of(Components.CRC));</span>
            }

<span class="pc bpc" id="L494" title="1 of 2 branches missed.">            if (!indexGroups.isEmpty())</span>
<span class="nc" id="L495">                addComponents(indexComponents(indexGroups));</span>

<span class="fc" id="L497">            return (B) this;</span>
        }

        private static Set&lt;Component&gt; indexComponents(Collection&lt;Index.Group&gt; indexGroups)
        {
<span class="nc" id="L502">            Set&lt;Component&gt; components = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">            for (Index.Group group : indexGroups)</span>
            {
<span class="nc" id="L505">                components.addAll(group.getComponents());</span>
<span class="nc" id="L506">            }</span>

<span class="nc" id="L508">            return components;</span>
        }

        public B setSecondaryIndexGroups(Collection&lt;Index.Group&gt; indexGroups)
        {
<span class="fc" id="L513">            checkNotNull(indexGroups);</span>
<span class="fc" id="L514">            this.indexGroups = ImmutableList.copyOf(indexGroups);</span>
<span class="fc" id="L515">            return (B) this;</span>
        }

        public MetadataCollector getMetadataCollector()
        {
<span class="fc" id="L520">            return metadataCollector;</span>
        }

        public long getKeyCount()
        {
<span class="fc" id="L525">            return keyCount;</span>
        }

        public long getRepairedAt()
        {
<span class="fc" id="L530">            return repairedAt;</span>
        }

        public TimeUUID getPendingRepair()
        {
<span class="fc" id="L535">            return pendingRepair;</span>
        }

        public boolean isTransientSSTable()
        {
<span class="fc" id="L540">            return transientSSTable;</span>
        }

        public SerializationHeader getSerializationHeader()
        {
<span class="fc" id="L545">            return serializationHeader;</span>
        }

        public List&lt;Index.Group&gt; getIndexGroups()
        {
<span class="pc bpc" id="L550" title="1 of 2 branches missed.">            return indexGroups == null ? Collections.emptyList() : indexGroups;</span>
        }

        public abstract MmappedRegionsCache getMmappedRegionsCache();

        public Builder(Descriptor descriptor)
        {
<span class="fc" id="L557">            super(descriptor);</span>
<span class="fc" id="L558">        }</span>

        public W build(LifecycleNewTracker lifecycleNewTracker, Owner owner)
        {
<span class="fc" id="L562">            checkNotNull(getComponents());</span>

<span class="fc" id="L564">            validateRepairedMetadata(getRepairedAt(), getPendingRepair(), isTransientSSTable());</span>

<span class="fc" id="L566">            return buildInternal(lifecycleNewTracker, owner);</span>
        }

        protected abstract W buildInternal(LifecycleNewTracker lifecycleNewTracker, Owner owner);

        public SSTableZeroCopyWriter createZeroCopyWriter(LifecycleNewTracker lifecycleNewTracker, Owner owner)
        {
<span class="fc" id="L573">            return new SSTableZeroCopyWriter(this, lifecycleNewTracker, owner);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>