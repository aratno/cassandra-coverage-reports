<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>YamlConfigurationLoader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.config</a> &gt; <span class="el_source">YamlConfigurationLoader.java</span></div><h1>YamlConfigurationLoader.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.config;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Nullable;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.google.common.io.ByteStreams;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.io.util.File;
import org.yaml.snakeyaml.LoaderOptions;
import org.yaml.snakeyaml.TypeDescription;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.composer.Composer;
import org.yaml.snakeyaml.constructor.CustomClassLoaderConstructor;
import org.yaml.snakeyaml.constructor.SafeConstructor;
import org.yaml.snakeyaml.error.YAMLException;
import org.yaml.snakeyaml.introspector.MissingProperty;
import org.yaml.snakeyaml.introspector.Property;
import org.yaml.snakeyaml.introspector.PropertyUtils;
import org.yaml.snakeyaml.nodes.Node;

import static org.apache.cassandra.config.CassandraRelevantProperties.ALLOW_DUPLICATE_CONFIG_KEYS;
import static org.apache.cassandra.config.CassandraRelevantProperties.ALLOW_NEW_OLD_CONFIG_KEYS;
import static org.apache.cassandra.config.CassandraRelevantProperties.CASSANDRA_CONFIG;
import static org.apache.cassandra.config.Replacements.getNameReplacements;

<span class="fc" id="L61">public class YamlConfigurationLoader implements ConfigurationLoader</span>
{
<span class="fc" id="L63">    private static final Logger logger = LoggerFactory.getLogger(YamlConfigurationLoader.class);</span>

    /**
     * This is related to {@link Config#PROPERTY_PREFIX} but is different to make sure Config properties updated via
     * system properties do not conflict with other system properties; the name &quot;settings&quot; matches system_views.settings.
     */
    static final String SYSTEM_PROPERTY_PREFIX = &quot;cassandra.settings.&quot;;

    /**
     * Inspect the classpath to find storage configuration file
     */
    private static URL getStorageConfigURL() throws ConfigurationException
    {
<span class="fc" id="L76">        String configUrl = CASSANDRA_CONFIG.getString();</span>

        URL url;
        try
        {
<span class="nc" id="L81">            url = new URL(configUrl);</span>
<span class="nc" id="L82">            url.openStream().close(); // catches well-formed but bogus URLs</span>
        }
<span class="fc" id="L84">        catch (Exception e)</span>
        {
<span class="fc" id="L86">            ClassLoader loader = DatabaseDescriptor.class.getClassLoader();</span>
<span class="fc" id="L87">            url = loader.getResource(configUrl);</span>
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">            if (url == null)</span>
            {
<span class="nc" id="L90">                String required = &quot;file:&quot; + File.pathSeparator() + File.pathSeparator();</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">                if (!configUrl.startsWith(required))</span>
<span class="nc" id="L92">                    throw new ConfigurationException(String.format(</span>
                        &quot;Expecting URI in variable: [cassandra.config]. Found[%s]. Please prefix the file with [%s%s] for local &quot; +
                        &quot;files and [%s&lt;server&gt;%s] for remote files. If you are executing this from an external tool, it needs &quot; +
                        &quot;to set Config.setClientMode(true) to avoid loading configuration.&quot;,
<span class="nc" id="L96">                        configUrl, required, File.pathSeparator(), required, File.pathSeparator()));</span>
<span class="nc" id="L97">                throw new ConfigurationException(&quot;Cannot locate &quot; + configUrl + &quot;.  If this is a local file, please confirm you've provided &quot; + required + File.pathSeparator() + &quot; as a URI prefix.&quot;);</span>
            }
<span class="nc" id="L99">        }</span>

<span class="fc" id="L101">        logger.info(&quot;Configuration location: {}&quot;, url);</span>

<span class="fc" id="L103">        return url;</span>
    }

    private static URL storageConfigURL;

    @Override
    public Config loadConfig() throws ConfigurationException
    {
<span class="fc bfc" id="L111" title="All 2 branches covered.">        if (storageConfigURL == null)</span>
<span class="fc" id="L112">            storageConfigURL = getStorageConfigURL();</span>

<span class="fc" id="L114">        return loadConfig(storageConfigURL);</span>
    }

    public Config loadConfig(URL url) throws ConfigurationException
    {
        try
        {
<span class="fc" id="L121">            logger.debug(&quot;Loading settings from {}&quot;, url);</span>
            byte[] configBytes;
<span class="fc" id="L123">            try (InputStream is = url.openStream())</span>
            {
<span class="fc" id="L125">                configBytes = ByteStreams.toByteArray(is);</span>
            }
<span class="nc" id="L127">            catch (IOException e)</span>
            {
                // getStorageConfigURL should have ruled this out
<span class="nc" id="L130">                throw new AssertionError(e);</span>
<span class="fc" id="L131">            }</span>

<span class="fc" id="L133">            SafeConstructor constructor = new CustomConstructor(Config.class, Yaml.class.getClassLoader());</span>
<span class="fc" id="L134">            Map&lt;Class&lt;?&gt;, Map&lt;String, Replacement&gt;&gt; replacements = getNameReplacements(Config.class);</span>
<span class="fc" id="L135">            verifyReplacements(replacements, configBytes);</span>
<span class="fc" id="L136">            PropertiesChecker propertiesChecker = new PropertiesChecker(replacements);</span>
<span class="fc" id="L137">            constructor.setPropertyUtils(propertiesChecker);</span>
<span class="fc" id="L138">            Yaml yaml = new Yaml(constructor);</span>
<span class="fc" id="L139">            Config result = loadConfig(yaml, configBytes);</span>
<span class="fc" id="L140">            propertiesChecker.check();</span>
<span class="fc" id="L141">            maybeAddSystemProperties(result);</span>
<span class="fc" id="L142">            return result;</span>
        }
<span class="nc" id="L144">        catch (YAMLException e)</span>
        {
<span class="nc" id="L146">            throw new ConfigurationException(&quot;Invalid yaml: &quot; + url, e);</span>
        }
    }

    private static void maybeAddSystemProperties(Object obj)
    {
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">        if (CassandraRelevantProperties.CONFIG_ALLOW_SYSTEM_PROPERTIES.getBoolean())</span>
        {
<span class="nc" id="L154">            java.util.Properties props = System.getProperties();</span>
<span class="nc" id="L155">            Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">            for (String name : props.stringPropertyNames())</span>
            {
<span class="nc bnc" id="L158" title="All 2 branches missed.">                if (name.startsWith(SYSTEM_PROPERTY_PREFIX))</span>
                {
<span class="nc" id="L160">                    String value = props.getProperty(name);</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">                    if (value != null)</span>
<span class="nc" id="L162">                        map.put(name.replace(SYSTEM_PROPERTY_PREFIX, &quot;&quot;), value);</span>
                }
<span class="nc" id="L164">            }</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">            if (!map.isEmpty())</span>
<span class="nc" id="L166">                updateFromMap(map, false, obj);</span>
        }
<span class="fc" id="L168">    }</span>

    private static void verifyReplacements(Map&lt;Class&lt;?&gt;, Map&lt;String, Replacement&gt;&gt; replacements, Map&lt;String, ?&gt; rawConfig)
    {
<span class="fc" id="L172">        List&lt;String&gt; duplicates = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">        for (Map.Entry&lt;Class&lt;?&gt;, Map&lt;String, Replacement&gt;&gt; outerEntry : replacements.entrySet())</span>
        {
<span class="fc bfc" id="L175" title="All 2 branches covered.">            for (Map.Entry&lt;String, Replacement&gt; entry : outerEntry.getValue().entrySet())</span>
            {
<span class="fc" id="L177">                Replacement r = entry.getValue();</span>
<span class="pc bpc" id="L178" title="1 of 6 branches missed.">                if (!r.isValueFormatReplacement() &amp;&amp; rawConfig.containsKey(r.oldName) &amp;&amp; rawConfig.containsKey(r.newName))</span>
                {
<span class="nc" id="L180">                    String msg = String.format(&quot;[%s -&gt; %s]&quot;, r.oldName, r.newName);</span>
<span class="nc" id="L181">                    duplicates.add(msg);</span>
                }
<span class="fc" id="L183">            }</span>
<span class="fc" id="L184">        }</span>

<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        if (!duplicates.isEmpty())</span>
        {
<span class="nc" id="L188">            String msg = String.format(&quot;Config contains both old and new keys for the same configuration parameters, migrate old -&gt; new: %s&quot;, String.join(&quot;, &quot;, duplicates));</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">            if (!ALLOW_NEW_OLD_CONFIG_KEYS.getBoolean())</span>
<span class="nc" id="L190">                throw new ConfigurationException(msg);</span>
            else
<span class="nc" id="L192">                logger.warn(msg);</span>
        }
<span class="fc" id="L194">    }</span>

    private static void verifyReplacements(Map&lt;Class&lt;?&gt;, Map&lt;String, Replacement&gt;&gt; replacements, byte[] configBytes)
    {
<span class="fc" id="L198">        LoaderOptions loaderOptions = new LoaderOptions();</span>
<span class="fc" id="L199">        loaderOptions.setAllowDuplicateKeys(ALLOW_DUPLICATE_CONFIG_KEYS.getBoolean());</span>
<span class="fc" id="L200">        Yaml rawYaml = new Yaml(loaderOptions);</span>

<span class="fc" id="L202">        Map&lt;String, Object&gt; rawConfig = rawYaml.load(new ByteArrayInputStream(configBytes));</span>
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        if (rawConfig == null)</span>
<span class="nc" id="L204">            rawConfig = new HashMap&lt;&gt;();</span>
<span class="fc" id="L205">        verifyReplacements(replacements, rawConfig);</span>

<span class="fc" id="L207">    }</span>

    @VisibleForTesting
    public static &lt;T&gt; T fromMap(Map&lt;String,Object&gt; map, Class&lt;T&gt; klass)
    {
<span class="nc" id="L212">        return fromMap(map, true, klass);</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;) //getSingleData returns Object, not T
    public static &lt;T&gt; T fromMap(Map&lt;String,Object&gt; map, boolean shouldCheck, Class&lt;T&gt; klass)
    {
<span class="nc" id="L218">        SafeConstructor constructor = new YamlConfigurationLoader.CustomConstructor(klass, klass.getClassLoader());</span>
<span class="nc" id="L219">        Map&lt;Class&lt;?&gt;, Map&lt;String, Replacement&gt;&gt; replacements = getNameReplacements(Config.class);</span>
<span class="nc" id="L220">        verifyReplacements(replacements, map);</span>
<span class="nc" id="L221">        YamlConfigurationLoader.PropertiesChecker propertiesChecker = new YamlConfigurationLoader.PropertiesChecker(replacements);</span>
<span class="nc" id="L222">        constructor.setPropertyUtils(propertiesChecker);</span>
<span class="nc" id="L223">        Yaml yaml = new Yaml(constructor);</span>
<span class="nc" id="L224">        Node node = yaml.represent(map);</span>
<span class="nc" id="L225">        constructor.setComposer(new Composer(null, null)</span>
<span class="nc" id="L226">        {</span>
            @Override
            public Node getSingleNode()
            {
<span class="nc" id="L230">                return node;</span>
            }
        });
<span class="nc" id="L233">        T value = (T) constructor.getSingleData(klass);</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (shouldCheck)</span>
<span class="nc" id="L235">            propertiesChecker.check();</span>
<span class="nc" id="L236">        maybeAddSystemProperties(value);</span>
<span class="nc" id="L237">        return value;</span>
    }

    public static &lt;T&gt; T updateFromMap(Map&lt;String, ?&gt; map, boolean shouldCheck, T obj)
    {
<span class="nc" id="L242">        Class&lt;T&gt; klass = (Class&lt;T&gt;) obj.getClass();</span>
<span class="nc" id="L243">        SafeConstructor constructor = new YamlConfigurationLoader.CustomConstructor(klass, klass.getClassLoader())</span>
<span class="nc" id="L244">        {</span>
            @Override
            protected Object newInstance(Node node)
            {
<span class="nc bnc" id="L248" title="All 2 branches missed.">                if (node.getType() == obj.getClass())</span>
<span class="nc" id="L249">                    return obj;</span>
<span class="nc" id="L250">                return super.newInstance(node);</span>
            }
        };
<span class="nc" id="L253">        Map&lt;Class&lt;?&gt;, Map&lt;String, Replacement&gt;&gt; replacements = getNameReplacements(Config.class);</span>
<span class="nc" id="L254">        verifyReplacements(replacements, map);</span>
<span class="nc" id="L255">        YamlConfigurationLoader.PropertiesChecker propertiesChecker = new YamlConfigurationLoader.PropertiesChecker(replacements);</span>
<span class="nc" id="L256">        constructor.setPropertyUtils(propertiesChecker);</span>
<span class="nc" id="L257">        Yaml yaml = new Yaml(constructor);</span>
<span class="nc" id="L258">        Node node = yaml.represent(map);</span>
<span class="nc" id="L259">        constructor.setComposer(new Composer(null, null)</span>
<span class="nc" id="L260">        {</span>
            @Override
            public Node getSingleNode()
            {
<span class="nc" id="L264">                return node;</span>
            }
        });
<span class="nc" id="L267">        T value = (T) constructor.getSingleData(klass);</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">        if (shouldCheck)</span>
<span class="nc" id="L269">            propertiesChecker.check();</span>
<span class="nc" id="L270">        return value;</span>
    }

    @VisibleForTesting
    static class CustomConstructor extends CustomClassLoaderConstructor
    {
        CustomConstructor(Class&lt;?&gt; theRoot, ClassLoader classLoader)
        {
<span class="fc" id="L278">            super(theRoot, classLoader);</span>

<span class="fc" id="L280">            TypeDescription seedDesc = new TypeDescription(ParameterizedClass.class);</span>
<span class="fc" id="L281">            seedDesc.putMapPropertyType(&quot;parameters&quot;, String.class, String.class);</span>
<span class="fc" id="L282">            addTypeDescription(seedDesc);</span>

<span class="fc" id="L284">            TypeDescription memtableDesc = new TypeDescription(Config.MemtableOptions.class);</span>
<span class="fc" id="L285">            memtableDesc.addPropertyParameters(&quot;configurations&quot;, String.class, InheritingClass.class);</span>
<span class="fc" id="L286">            addTypeDescription(memtableDesc);</span>
<span class="fc" id="L287">        }</span>

        @Override
        protected List&lt;Object&gt; createDefaultList(int initSize)
        {
<span class="fc" id="L292">            return Lists.newCopyOnWriteArrayList();</span>
        }

        @Override
        protected Map&lt;Object, Object&gt; createDefaultMap(int initSize)
        {
<span class="fc" id="L298">            return Maps.newConcurrentMap();</span>
        }

        @Override
        protected Set&lt;Object&gt; createDefaultSet(int initSize)
        {
<span class="nc" id="L304">            return Sets.newConcurrentHashSet();</span>
        }
    }

    private static Config loadConfig(Yaml yaml, byte[] configBytes)
    {
<span class="fc" id="L310">        Config config = yaml.loadAs(new ByteArrayInputStream(configBytes), Config.class);</span>
        // If the configuration file is empty yaml will return null. In this case we should use the default
        // configuration to avoid hitting a NPE at a later stage.
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        return config == null ? new Config() : config;</span>
    }

    /**
     * Utility class to check that there are no extra properties and that properties that are not null by default
     * are not set to null.
     */
    @VisibleForTesting
    private static class PropertiesChecker extends PropertyUtils
    {
<span class="fc" id="L323">        private final Loader loader = Properties.defaultLoader();</span>
<span class="fc" id="L324">        private final Set&lt;String&gt; missingProperties = new HashSet&lt;&gt;();</span>

<span class="fc" id="L326">        private final Set&lt;String&gt; nullProperties = new HashSet&lt;&gt;();</span>

<span class="fc" id="L328">        private final Set&lt;String&gt; deprecationWarnings = new HashSet&lt;&gt;();</span>

        private final Map&lt;Class&lt;?&gt;, Map&lt;String, Replacement&gt;&gt; replacements;

        PropertiesChecker(Map&lt;Class&lt;?&gt;, Map&lt;String, Replacement&gt;&gt; replacements)
<span class="fc" id="L333">        {</span>
<span class="fc" id="L334">            this.replacements = Objects.requireNonNull(replacements, &quot;Replacements should not be null&quot;);</span>
<span class="fc" id="L335">            setSkipMissingProperties(true);</span>
<span class="fc" id="L336">        }</span>

        @Override
        public Property getProperty(Class&lt;?&gt; type, String name)
        {
            final Property result;
<span class="fc" id="L342">            Map&lt;String, Replacement&gt; typeReplacements = replacements.getOrDefault(type, Collections.emptyMap());</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">            if (typeReplacements.containsKey(name))</span>
            {
<span class="fc" id="L345">                Replacement replacement = typeReplacements.get(name);</span>
<span class="fc" id="L346">                result = replacement.toProperty(getProperty0(type, replacement.newName));</span>
                
<span class="fc bfc" id="L348" title="All 2 branches covered.">                if (replacement.deprecated)</span>
<span class="fc" id="L349">                    deprecationWarnings.add(replacement.oldName);</span>
<span class="fc" id="L350">            }</span>
            else
            {
<span class="fc" id="L353">                result = getProperty0(type, name);</span>
            }

<span class="pc bpc" id="L356" title="1 of 2 branches missed.">            if (result instanceof MissingProperty)</span>
            {
<span class="nc" id="L358">                missingProperties.add(result.getName());</span>
            }
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">            else if (result.getAnnotation(Deprecated.class) != null)</span>
            {
<span class="nc" id="L362">                deprecationWarnings.add(result.getName());</span>
            }

<span class="fc" id="L365">            return new ForwardingProperty(result.getName(), result)</span>
<span class="fc" id="L366">            {</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">                boolean allowsNull = result.getAnnotation(Nullable.class) != null;</span>

                @Override
                public void set(Object object, Object value) throws Exception
                {
                    // TODO: CASSANDRA-17785, add @Nullable to all nullable Config properties and remove value == null
<span class="pc bpc" id="L373" title="3 of 6 branches missed.">                    if (value == null &amp;&amp; get(object) != null &amp;&amp; !allowsNull)</span>
<span class="nc" id="L374">                        nullProperties.add(getName());</span>

<span class="fc" id="L376">                    result.set(object, value);</span>
<span class="fc" id="L377">                }</span>

                @Override
                public Object get(Object object)
                {
<span class="fc" id="L382">                    return result.get(object);</span>
                }
            };
        }

        private Property getProperty0(Class&lt;? extends Object&gt; type, String name)
        {
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">            if (name.contains(&quot;.&quot;))</span>
<span class="nc" id="L390">                return getNestedProperty(type, name);</span>
<span class="fc" id="L391">            return getFlatProperty(type, name);</span>
        }

        private Property getFlatProperty(Class&lt;?&gt; type, String name)
        {
<span class="fc" id="L396">            Property prop = loader.getProperties(type).get(name);</span>
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">            return prop == null ? new MissingProperty(name) : prop;</span>
        }

        private Property getNestedProperty(Class&lt;?&gt; type, String name)
        {
<span class="nc" id="L402">            Property root = null;</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">            for (String s : name.split(&quot;\\.&quot;))</span>
            {
<span class="nc" id="L405">                Property prop = getFlatProperty(type, s);</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">                if (prop instanceof MissingProperty)</span>
                {
<span class="nc" id="L408">                    root = null;</span>
<span class="nc" id="L409">                    break;</span>
                }
<span class="nc bnc" id="L411" title="All 2 branches missed.">                root = root == null ? prop : Properties.andThen(root, prop);</span>
<span class="nc" id="L412">                type = root.getType();</span>
            }
<span class="nc bnc" id="L414" title="All 2 branches missed.">            return root != null ? root : new MissingProperty(name);</span>
        }

        public void check() throws ConfigurationException
        {
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">            if (!nullProperties.isEmpty())</span>
<span class="nc" id="L420">                throw new ConfigurationException(&quot;Invalid yaml. Those properties &quot; + nullProperties + &quot; are not valid&quot;, false);</span>

<span class="pc bpc" id="L422" title="1 of 2 branches missed.">            if (!missingProperties.isEmpty())</span>
<span class="nc" id="L423">                throw new ConfigurationException(&quot;Invalid yaml. Please remove properties &quot; + missingProperties + &quot; from your cassandra.yaml&quot;, false);</span>

<span class="pc bpc" id="L425" title="1 of 2 branches missed.">            if (!deprecationWarnings.isEmpty())</span>
<span class="fc" id="L426">                logger.warn(&quot;{} parameters have been deprecated. They have new names and/or value format; For more information, please refer to NEWS.txt&quot;, deprecationWarnings);</span>
<span class="fc" id="L427">        }</span>
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>