<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PartitionDenylist.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.schema</a> &gt; <span class="el_source">PartitionDenylist.java</span></div><h1>PartitionDenylist.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.schema;

import java.nio.ByteBuffer;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.NavigableSet;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.github.benmanes.caffeine.cache.CacheLoader;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.benmanes.caffeine.cache.LoadingCache;
import org.apache.cassandra.concurrent.ScheduledExecutors;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.cql3.UntypedResultSet;
import org.apache.cassandra.db.PartitionPosition;
import org.apache.cassandra.dht.AbstractBounds;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.exceptions.RequestExecutionException;
import org.apache.cassandra.service.StorageService;
import org.apache.cassandra.service.reads.range.RangeCommands;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.NoSpamLogger;

import static org.apache.cassandra.concurrent.ExecutorFactory.Global.executorFactory;
import static org.apache.cassandra.cql3.QueryProcessor.process;
import static org.apache.cassandra.utils.Clock.Global.currentTimeMillis;

/**
 * PartitionDenylist uses the system_distributed.partition_denylist table to maintain a list of denylisted partition keys
 * for each keyspace/table.
 *
 * Keys can be entered manually into the partition_denylist table or via the JMX operation StorageProxyMBean.denylistKey
 *
 * The denylist is stored as one CQL partition per table, and the denylisted keys are column names in that partition. The denylisted
 * keys for each table are cached in memory, and reloaded from the partition_denylist table every 10 minutes (default) or when the
 * StorageProxyMBean.loadPartitionDenylist is called via JMX.
 *
 * Concurrency of the cache is provided by the concurrency semantics of the guava LoadingCache. All values (DenylistEntry) are
 * immutable collections of keys/tokens which are replaced in whole when the cache refreshes from disk.
 *
 * The CL for the denylist is used on initial node load as well as on timer instigated cache refreshes. A JMX call by the
 * operator to load the denylist cache will warn on CL unavailability but go through with the denylist load. This is to
 * allow operators flexibility in the face of degraded cluster state and still grant them the ability to mutate the denylist
 * cache and bring it up if there are things they need to block on startup.
 *
 * Notably, in the current design it's possible for a table *cache expiration instigated* reload to end up violating the
 * contract on total denylisted keys allowed in the case where it initially loads with a value less than the DBD
 * allowable max per table limit due to global constraint enforcement on initial load. Our load and reload function
 * simply enforce the *per table* limit without consideration to what that entails at the global key level. While we
 * could track the constrained state and count in DenylistEntry, for now the complexity doesn't seem to justify the
 * protection against that edge case. The enforcement should take place on a user-instigated full reload as well as
 * error messaging about count violations, so this only applies to situations in which someone adds a key and doesn't
 * actively tell the cache to fully reload to take that key into consideration, which one could reasonably expect to be
 * an antipattern.
 */
<span class="fc" id="L84">public class PartitionDenylist</span>
{
<span class="fc" id="L86">    private static final Logger logger = LoggerFactory.getLogger(PartitionDenylist.class);</span>
<span class="fc" id="L87">    private static final NoSpamLogger AVAILABILITY_LOGGER = NoSpamLogger.getLogger(logger, 1, TimeUnit.MINUTES);</span>

<span class="fc" id="L89">    private final ExecutorService executor = executorFactory().pooled(&quot;DenylistCache&quot;, 2);</span>

    /** We effectively don't use our initial empty cache to denylist until the {@link #load()} call which will replace it */
<span class="fc" id="L92">    private volatile LoadingCache&lt;TableId, DenylistEntry&gt; denylist = buildEmptyCache();</span>

    /** Denylist entry is never mutated once constructed, only replaced with a new entry when the cache is refreshed */
    private static class DenylistEntry
    {
        public final ImmutableSet&lt;ByteBuffer&gt; keys;
        public final ImmutableSortedSet&lt;Token&gt; tokens;

        public DenylistEntry()
<span class="nc" id="L101">        {</span>
<span class="nc" id="L102">            keys = ImmutableSet.of();</span>
<span class="nc" id="L103">            tokens = ImmutableSortedSet.of();</span>
<span class="nc" id="L104">        }</span>

        public DenylistEntry(final ImmutableSet&lt;ByteBuffer&gt; keys, final ImmutableSortedSet&lt;Token&gt; tokens)
<span class="nc" id="L107">        {</span>
<span class="nc" id="L108">            this.keys = keys;</span>
<span class="nc" id="L109">            this.tokens = tokens;</span>
<span class="nc" id="L110">        }</span>
    }

    /** synchronized on this */
<span class="fc" id="L114">    private int loadAttempts = 0;</span>

    /** synchronized on this */
<span class="fc" id="L117">    private int loadSuccesses = 0;</span>

    public synchronized int getLoadAttempts()
    {
<span class="nc" id="L121">        return loadAttempts;</span>
    }
    public synchronized int getLoadSuccesses()
    {
<span class="nc" id="L125">        return loadSuccesses;</span>
    }

    /**
     * Performs initial load of the partition denylist. Should be called at startup and only loads if the operation
     * is expected to succeed.  If it is not possible to load at call time, a timer is set to retry.
     */
    public void initialLoad()
    {
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (!DatabaseDescriptor.getPartitionDenylistEnabled())</span>
<span class="fc" id="L135">            return;</span>

<span class="nc" id="L137">        synchronized (this)</span>
        {
<span class="nc" id="L139">            loadAttempts++;</span>
<span class="nc" id="L140">        }</span>

        // Check if there are sufficient nodes to attempt reading all the denylist partitions before issuing the query.
        // The pre-check prevents definite range-slice unavailables being marked and triggering an alert.  Nodes may still change
        // state between the check and the query, but it should significantly reduce the alert volume.
<span class="nc" id="L145">        String retryReason = &quot;Insufficient nodes&quot;;</span>
        try
        {
<span class="nc bnc" id="L148" title="All 2 branches missed.">            if (checkDenylistNodeAvailability())</span>
            {
<span class="nc" id="L150">                load();</span>
<span class="nc" id="L151">                return;</span>
            }
        }
<span class="nc" id="L154">        catch (Throwable tr)</span>
        {
<span class="nc" id="L156">            logger.error(&quot;Failed to load partition denylist&quot;, tr);</span>
<span class="nc" id="L157">            retryReason = &quot;Exception&quot;;</span>
<span class="nc" id="L158">        }</span>

        // This path will also be taken on other failures other than UnavailableException,
        // but seems like a good idea to retry anyway.
<span class="nc" id="L162">        int retryInSeconds = DatabaseDescriptor.getDenylistInitialLoadRetrySeconds();</span>
<span class="nc" id="L163">        logger.info(&quot;{} while loading partition denylist cache. Scheduled retry in {} seconds.&quot;, retryReason, retryInSeconds);</span>
<span class="nc" id="L164">        ScheduledExecutors.optionalTasks.schedule(this::initialLoad, retryInSeconds, TimeUnit.SECONDS);</span>
<span class="nc" id="L165">    }</span>

    private boolean checkDenylistNodeAvailability()
    {
<span class="nc" id="L169">        boolean sufficientNodes = RangeCommands.sufficientLiveNodesForSelectStar(SystemDistributedKeyspace.PartitionDenylistTable,</span>
<span class="nc" id="L170">                                                                                 DatabaseDescriptor.getDenylistConsistencyLevel());</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">        if (!sufficientNodes)</span>
        {
<span class="nc" id="L173">            AVAILABILITY_LOGGER.warn(&quot;Attempting to load denylist and not enough nodes are available for a {} refresh. Reload the denylist when unavailable nodes are recovered to ensure your denylist remains in sync.&quot;,</span>
<span class="nc" id="L174">                                     DatabaseDescriptor.getDenylistConsistencyLevel());</span>
        }
<span class="nc" id="L176">        return sufficientNodes;</span>
    }

    /** Helper method as we need to both build cache on initial init but also on reload of cache contents and params */
    private LoadingCache&lt;TableId, DenylistEntry&gt; buildEmptyCache()
    {
        // We rely on details of .refreshAfterWrite to reload this async in the background when it's hit:
        // https://github.com/ben-manes/caffeine/wiki/Refresh
<span class="fc" id="L184">        return Caffeine.newBuilder()</span>
<span class="fc" id="L185">                       .refreshAfterWrite(DatabaseDescriptor.getDenylistRefreshSeconds(), TimeUnit.SECONDS)</span>
<span class="fc" id="L186">                       .executor(executor)</span>
<span class="fc" id="L187">                       .build(new CacheLoader&lt;TableId, DenylistEntry&gt;()</span>
<span class="fc" id="L188">                       {</span>
                           @Override
                           public DenylistEntry load(final TableId tid)
                           {
                               // We load whether or not the CL required count are available as the alternative is an
                               // empty denylist. This allows operators to intervene in the event they need to deny or
                               // undeny a specific partition key around a node recovery.
<span class="nc" id="L195">                               checkDenylistNodeAvailability();</span>
<span class="nc" id="L196">                               return getDenylistForTableFromCQL(tid);</span>
                           }

                           // The synchronous reload method defaults to being wrapped with a supplyAsync in CacheLoader.asyncReload
                           @Override
                           public DenylistEntry reload(final TableId tid, final DenylistEntry oldValue)
                           {
                               // Only process when we can hit the user specified CL for the denylist consistency on a timer prompted reload
<span class="nc bnc" id="L204" title="All 2 branches missed.">                               if (checkDenylistNodeAvailability())</span>
                               {
<span class="nc" id="L206">                                   final DenylistEntry newEntry = getDenylistForTableFromCQL(tid);</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">                                   if (newEntry != null)</span>
<span class="nc" id="L208">                                       return newEntry;</span>
                               }
<span class="nc bnc" id="L210" title="All 2 branches missed.">                               if (oldValue != null)</span>
<span class="nc" id="L211">                                   return oldValue;</span>
<span class="nc" id="L212">                               return new DenylistEntry();</span>
                           }
                       });
    }

    /**
     * We need to fully rebuild a new cache to accommodate deleting items from the denylist and potentially shrinking
     * the max allowable size in the list. We do not serve queries out of this denylist until it is populated
     * so as not to introduce a window of having a partially filled cache allow denylisted entries.
     */
    public void load()
    {
<span class="nc" id="L224">        final long start = currentTimeMillis();</span>

<span class="nc" id="L226">        final Map&lt;TableId, DenylistEntry&gt; allDenylists = getDenylistForAllTablesFromCQL();</span>

        // On initial load we have the slight overhead of GC'ing our initial empty cache
<span class="nc" id="L229">        LoadingCache&lt;TableId, DenylistEntry&gt; newDenylist = buildEmptyCache();</span>
<span class="nc" id="L230">        newDenylist.putAll(allDenylists);</span>

<span class="nc" id="L232">        synchronized (this)</span>
        {
<span class="nc" id="L234">            loadSuccesses++;</span>
<span class="nc" id="L235">        }</span>
<span class="nc" id="L236">        denylist = newDenylist;</span>
<span class="nc" id="L237">        logger.info(&quot;Loaded partition denylist cache in {}ms&quot;, currentTimeMillis() - start);</span>
<span class="nc" id="L238">    }</span>

    /**
     * We expect the caller to confirm that we are working with a valid keyspace and table. Further, we expect the usage
     * pattern of this to be one-off key by key, not in a bulk process, so we reload the entire table's deny list entry
     * on an addition or removal.
     */
    public boolean addKeyToDenylist(final String keyspace, final String table, final ByteBuffer key)
    {
<span class="nc bnc" id="L247" title="All 2 branches missed.">        if (!canDenylistKeyspace(keyspace))</span>
<span class="nc" id="L248">            return false;</span>

<span class="nc" id="L250">        final String insert = String.format(&quot;INSERT INTO system_distributed.partition_denylist (ks_name, table_name, key) VALUES ('%s', '%s', 0x%s)&quot;,</span>
<span class="nc" id="L251">                                            keyspace, table, ByteBufferUtil.bytesToHex(key));</span>

        try
        {
<span class="nc" id="L255">            process(insert, DatabaseDescriptor.getDenylistConsistencyLevel());</span>
<span class="nc" id="L256">            return refreshTableDenylist(keyspace, table);</span>
        }
<span class="nc" id="L258">        catch (final RequestExecutionException e)</span>
        {
<span class="nc" id="L260">            logger.error(&quot;Failed to denylist key [{}] in {}/{}&quot;, ByteBufferUtil.bytesToHex(key), keyspace, table, e);</span>
        }
<span class="nc" id="L262">        return false;</span>
    }

    /**
     * We expect the caller to confirm that we are working with a valid keyspace and table.
     */
    public boolean removeKeyFromDenylist(final String keyspace, final String table, final ByteBuffer key)
    {
<span class="nc" id="L270">        final String delete = String.format(&quot;DELETE FROM system_distributed.partition_denylist &quot; +</span>
                                            &quot;WHERE ks_name = '%s' &quot; +
                                            &quot;AND table_name = '%s' &quot; +
                                            &quot;AND key = 0x%s&quot;,
<span class="nc" id="L274">                                            keyspace, table, ByteBufferUtil.bytesToHex(key));</span>

        try
        {
<span class="nc" id="L278">            process(delete, DatabaseDescriptor.getDenylistConsistencyLevel());</span>
<span class="nc" id="L279">            return refreshTableDenylist(keyspace, table);</span>
        }
<span class="nc" id="L281">        catch (final RequestExecutionException e)</span>
        {
<span class="nc" id="L283">            logger.error(&quot;Failed to remove key from denylist: [{}] in {}/{}&quot;, ByteBufferUtil.bytesToHex(key), keyspace, table, e);</span>
        }
<span class="nc" id="L285">        return false;</span>
    }

    /**
     * We disallow denylisting partitions in certain critical keyspaces to prevent users from making their clusters
     * inoperable.
     */
    private boolean canDenylistKeyspace(final String keyspace)
    {
<span class="nc bnc" id="L294" title="All 2 branches missed.">        return !SchemaConstants.DISTRIBUTED_KEYSPACE_NAME.equals(keyspace) &amp;&amp;</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">               !SchemaConstants.SYSTEM_KEYSPACE_NAME.equals(keyspace) &amp;&amp;</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">               !SchemaConstants.TRACE_KEYSPACE_NAME.equals(keyspace) &amp;&amp;</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">               !SchemaConstants.VIRTUAL_SCHEMA.equals(keyspace) &amp;&amp;</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">               !SchemaConstants.VIRTUAL_VIEWS.equals(keyspace) &amp;&amp;</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">               !SchemaConstants.AUTH_KEYSPACE_NAME.equals(keyspace);</span>
    }

    public boolean isKeyPermitted(final String keyspace, final String table, final ByteBuffer key)
    {
<span class="nc" id="L304">        return isKeyPermitted(getTableId(keyspace, table), key);</span>
    }

    public boolean isKeyPermitted(final TableId tid, final ByteBuffer key)
    {
<span class="nc" id="L309">        final TableMetadata tmd = Schema.instance.getTableMetadata(tid);</span>

        // We have a few quick state checks to get out of the way first; this is hot path so we want to do these first if possible.
<span class="nc bnc" id="L312" title="All 8 branches missed.">        if (!DatabaseDescriptor.getPartitionDenylistEnabled() || tid == null || tmd == null || !canDenylistKeyspace(tmd.keyspace))</span>
<span class="nc" id="L313">            return true;</span>

        try
        {
            // If we don't have an entry for this table id, nothing in it is denylisted.
<span class="nc" id="L318">            DenylistEntry entry = denylist.get(tid);</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">            if (entry == null)</span>
<span class="nc" id="L320">                return true;</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">            return !entry.keys.contains(key);</span>
        }
<span class="nc" id="L323">        catch (final Exception e)</span>
        {
            // In the event of an error accessing or populating the cache, assume it's not denylisted
<span class="nc" id="L326">            logAccessFailure(tid, e);</span>
<span class="nc" id="L327">            return true;</span>
        }
    }

    private void logAccessFailure(final TableId tid, Throwable e)
    {
<span class="nc" id="L333">        final TableMetadata tmd = Schema.instance.getTableMetadata(tid);</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if (tmd == null)</span>
<span class="nc" id="L335">            logger.debug(&quot;Failed to access partition denylist cache for unknown table id {}&quot;, tid.toString(), e);</span>
        else
<span class="nc" id="L337">            logger.debug(&quot;Failed to access partition denylist cache for {}/{}&quot;, tmd.keyspace, tmd.name, e);</span>
<span class="nc" id="L338">    }</span>

    /**
     * @return number of denylisted keys in range
     */
    public int getDeniedKeysInRangeCount(final String keyspace, final String table, final AbstractBounds&lt;PartitionPosition&gt; range)
    {
<span class="nc" id="L345">        return getDeniedKeysInRangeCount(getTableId(keyspace, table), range);</span>
    }

    /**
     * @return number of denylisted keys in range
     */
    public int getDeniedKeysInRangeCount(final TableId tid, final AbstractBounds&lt;PartitionPosition&gt; range)
    {
<span class="nc" id="L353">        final TableMetadata tmd = Schema.instance.getTableMetadata(tid);</span>
<span class="nc bnc" id="L354" title="All 8 branches missed.">        if (!DatabaseDescriptor.getPartitionDenylistEnabled() || tid == null || tmd == null || !canDenylistKeyspace(tmd.keyspace))</span>
<span class="nc" id="L355">            return 0;</span>

        try
        {
<span class="nc" id="L359">            final DenylistEntry denylistEntry = denylist.get(tid);</span>
<span class="nc bnc" id="L360" title="All 4 branches missed.">            if (denylistEntry == null || denylistEntry.tokens.size() == 0)</span>
<span class="nc" id="L361">                return 0;</span>
<span class="nc" id="L362">            final Token startToken = range.left.getToken();</span>
<span class="nc" id="L363">            final Token endToken = range.right.getToken();</span>

            // Normal case
<span class="nc bnc" id="L366" title="All 4 branches missed.">            if (startToken.compareTo(endToken) &lt;= 0 || endToken.isMinimum())</span>
            {
<span class="nc bnc" id="L368" title="All 2 branches missed.">                NavigableSet&lt;Token&gt; subSet = denylistEntry.tokens.tailSet(startToken, PartitionPosition.Kind.MIN_BOUND == range.left.kind());</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">                if (!endToken.isMinimum())</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">                    subSet = subSet.headSet(endToken, PartitionPosition.Kind.MAX_BOUND == range.right.kind());</span>
<span class="nc" id="L371">                return subSet.size();</span>
            }

            // Wrap around case
<span class="nc bnc" id="L375" title="All 2 branches missed.">            return denylistEntry.tokens.tailSet(startToken, PartitionPosition.Kind.MIN_BOUND == range.left.kind()).size()</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">                   + denylistEntry.tokens.headSet(endToken, PartitionPosition.Kind.MAX_BOUND == range.right.kind()).size();</span>
        }
<span class="nc" id="L378">        catch (final Exception e)</span>
        {
<span class="nc" id="L380">            logAccessFailure(tid, e);</span>
<span class="nc" id="L381">            return 0;</span>
        }
    }

    /**
     * Get up to the configured allowable limit per table of denylisted keys
     */
    private DenylistEntry getDenylistForTableFromCQL(final TableId tid)
    {
<span class="nc" id="L390">        return getDenylistForTableFromCQL(tid, DatabaseDescriptor.getDenylistMaxKeysPerTable());</span>
    }

    /**
     * Attempts to reload the DenylistEntry data from CQL for the given TableId and key count.
     * @return empty denylist if we do not or cannot find the data, preserving the old value, otherwise the new value
     */
    private DenylistEntry getDenylistForTableFromCQL(final TableId tid, int limit)
    {
<span class="nc" id="L399">        final TableMetadata tmd = Schema.instance.getTableMetadata(tid);</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">        if (tmd == null)</span>
<span class="nc" id="L401">            return null;</span>

        // We attempt to query just over our allowable max keys in order to check whether we have configured data beyond that limit and alert the user if so
<span class="nc" id="L404">        final String readDenylist = String.format(&quot;SELECT * FROM %s.%s WHERE ks_name='%s' AND table_name='%s' LIMIT %d&quot;,</span>
                                                  SchemaConstants.DISTRIBUTED_KEYSPACE_NAME,
                                                  SystemDistributedKeyspace.PARTITION_DENYLIST_TABLE,
                                                  tmd.keyspace,
                                                  tmd.name,
<span class="nc" id="L409">                                                  limit + 1);</span>

        try
        {
<span class="nc" id="L413">            final UntypedResultSet results = process(readDenylist, DatabaseDescriptor.getDenylistConsistencyLevel());</span>

            // If there's no data in CQL we want to return an empty DenylistEntry so we don't continue using the old value in the cache
<span class="nc bnc" id="L416" title="All 4 branches missed.">            if (results == null || results.isEmpty())</span>
<span class="nc" id="L417">                return new DenylistEntry();</span>

<span class="nc bnc" id="L419" title="All 2 branches missed.">            if (results.size() &gt; limit)</span>
            {
                // If our limit is &lt; the standard per table we know we're at a global violation because we've constrained that request limit already.
<span class="nc bnc" id="L422" title="All 2 branches missed.">                boolean globalLimit = limit != DatabaseDescriptor.getDenylistMaxKeysPerTable();</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">                String violationType = globalLimit ? &quot;global&quot; : &quot;per-table&quot;;</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">                int errorLimit = globalLimit ? DatabaseDescriptor.getDenylistMaxKeysTotal() : limit;</span>
<span class="nc" id="L425">                logger.error(&quot;Partition denylist for {}/{} has exceeded the {} allowance of ({}). Remaining keys were ignored; &quot; +</span>
                             &quot;please reduce the total number of keys denied or increase the denylist_max_keys_per_table param in &quot; +
                             &quot;cassandra.yaml to avoid inconsistency in denied partitions across nodes.&quot;,
                             tmd.keyspace,
                             tmd.name,
                             violationType,
<span class="nc" id="L431">                             errorLimit);</span>
            }

<span class="nc" id="L434">            final Set&lt;ByteBuffer&gt; keys = new HashSet&lt;&gt;();</span>
<span class="nc" id="L435">            final NavigableSet&lt;Token&gt; tokens = new TreeSet&lt;&gt;();</span>

<span class="nc" id="L437">            int processed = 0;</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">            for (final UntypedResultSet.Row row : results)</span>
            {
<span class="nc" id="L440">                final ByteBuffer key = row.getBlob(&quot;key&quot;);</span>
<span class="nc" id="L441">                keys.add(key);</span>
<span class="nc" id="L442">                tokens.add(StorageService.instance.getTokenMetadata().partitioner.getToken(key));</span>

<span class="nc" id="L444">                processed++;</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">                if (processed &gt;= limit)</span>
<span class="nc" id="L446">                    break;</span>
<span class="nc" id="L447">            }</span>
<span class="nc" id="L448">            return new DenylistEntry(ImmutableSet.copyOf(keys), ImmutableSortedSet.copyOf(tokens));</span>
        }
<span class="nc" id="L450">        catch (final RequestExecutionException e)</span>
        {
<span class="nc" id="L452">            logger.error(&quot;Error reading partition_denylist table for {}/{}. Returning empty denylist.&quot;, tmd.keyspace, tmd.name, e);</span>
<span class="nc" id="L453">            return new DenylistEntry();</span>
        }
    }

    /**
     * This method relies on {@link #getDenylistForTableFromCQL(TableId, int)} to pull a limited amount of keys
     * on a per-table basis from CQL to load into the cache. We need to navigate both respecting the max cache size limit
     * as well as respecting the per-table limit.
     * @return non-null mapping of TableId to DenylistEntry
     */
    private Map&lt;TableId, DenylistEntry&gt; getDenylistForAllTablesFromCQL()
    {
        // While we warn the user in this case, we continue with the reload anyway.
<span class="nc" id="L466">        checkDenylistNodeAvailability();</span>

<span class="nc" id="L468">        final String allDeniedTables = String.format(&quot;SELECT DISTINCT ks_name, table_name FROM %s.%s&quot;,</span>
                                                     SchemaConstants.DISTRIBUTED_KEYSPACE_NAME,
                                                     SystemDistributedKeyspace.PARTITION_DENYLIST_TABLE);
        try
        {
<span class="nc" id="L473">            final UntypedResultSet deniedTableResults = process(allDeniedTables, DatabaseDescriptor.getDenylistConsistencyLevel());</span>
<span class="nc bnc" id="L474" title="All 4 branches missed.">            if (deniedTableResults == null || deniedTableResults.isEmpty())</span>
<span class="nc" id="L475">                return Collections.emptyMap();</span>

<span class="nc" id="L477">            int totalProcessed = 0 ;</span>
<span class="nc" id="L478">            final Map&lt;TableId, DenylistEntry&gt; results = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">            for (final UntypedResultSet.Row row : deniedTableResults)</span>
            {
<span class="nc" id="L481">                final String ks = row.getString(&quot;ks_name&quot;);</span>
<span class="nc" id="L482">                final String table = row.getString(&quot;table_name&quot;);</span>
<span class="nc" id="L483">                final TableId tid = getTableId(ks, table);</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">                if (DatabaseDescriptor.getDenylistMaxKeysTotal() - totalProcessed &lt;= 0)</span>
                {
<span class="nc" id="L486">                    logger.error(&quot;Hit limit on allowable denylisted keys in total. Processed {} total entries. Not adding all entries to denylist for {}/{}.&quot; +</span>
                                 &quot; Remove denylist entries in system_distributed.{} or increase your denylist_max_keys_total param in cassandra.yaml.&quot;,
<span class="nc" id="L488">                                 totalProcessed,</span>
                                 ks,
                                 table,
                                 SystemDistributedKeyspace.PARTITION_DENYLIST_TABLE);
<span class="nc" id="L492">                    results.put(tid, new DenylistEntry());</span>
                }
                else
                {
                    // Determine whether we can get up to table max or we need a subset at edge condition of max overflow.
<span class="nc" id="L497">                    int allowedTableRecords = Math.min(DatabaseDescriptor.getDenylistMaxKeysPerTable(), DatabaseDescriptor.getDenylistMaxKeysTotal() - totalProcessed);</span>
<span class="nc" id="L498">                    DenylistEntry tableDenylist = getDenylistForTableFromCQL(tid, allowedTableRecords);</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">                    if (tableDenylist != null)</span>
<span class="nc" id="L500">                        totalProcessed += tableDenylist.keys.size();</span>
<span class="nc" id="L501">                    results.put(tid, tableDenylist);</span>
                }
<span class="nc" id="L503">            }</span>
<span class="nc" id="L504">            return results;</span>
        }
<span class="nc" id="L506">        catch (final RequestExecutionException e)</span>
        {
<span class="nc" id="L508">            logger.error(&quot;Error reading full partition denylist from &quot;</span>
                         + SchemaConstants.DISTRIBUTED_KEYSPACE_NAME + &quot;.&quot; + SystemDistributedKeyspace.PARTITION_DENYLIST_TABLE +
                         &quot;. Partition Denylisting will be compromised. Exception: &quot; + e);
<span class="nc" id="L511">            return Collections.emptyMap();</span>
        }
    }

    private boolean refreshTableDenylist(String keyspace, String table)
    {
<span class="nc" id="L517">        checkDenylistNodeAvailability();</span>
<span class="nc" id="L518">        final TableId tid = getTableId(keyspace, table);</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">        if (tid == null)</span>
        {
<span class="nc" id="L521">            logger.warn(&quot;Got denylist mutation for unknown ks/cf: {}/{}. Skipping refresh.&quot;, keyspace, table);</span>
<span class="nc" id="L522">            return false;</span>
        }

<span class="nc" id="L525">        DenylistEntry newEntry = getDenylistForTableFromCQL(tid);</span>
<span class="nc" id="L526">        denylist.put(tid, newEntry);</span>
<span class="nc" id="L527">        return true;</span>
    }

    private TableId getTableId(final String keyspace, final String table)
    {
<span class="nc" id="L532">        TableMetadata tmd = Schema.instance.getTableMetadata(keyspace, table);</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">        return tmd == null ? null : tmd.id;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>