<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CBUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.transport</a> &gt; <span class="el_source">CBUtil.java</span></div><h1>CBUtil.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.transport;

import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CoderResult;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.ByteBufUtil;
import io.netty.buffer.PooledByteBufAllocator;
import io.netty.buffer.UnpooledByteBufAllocator;
import io.netty.util.concurrent.FastThreadLocal;
import org.apache.cassandra.db.ConsistencyLevel;
import org.apache.cassandra.db.TypeSizes;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.Pair;
import org.apache.cassandra.utils.TimeUUID;
import org.apache.cassandra.utils.UUIDGen;
import org.apache.cassandra.utils.memory.MemoryUtil;

import static org.apache.cassandra.config.CassandraRelevantProperties.CASSANDRA_NETTY_USE_HEAP_ALLOCATOR;

/**
 * ByteBuf utility methods.
 * Note that contrarily to ByteBufferUtil, these method do &quot;read&quot; the
 * ByteBuf advancing its (read) position. They also write by
 * advancing the write position. Functions are also provided to create
 * ByteBuf while avoiding copies.
 */
public abstract class CBUtil
{
<span class="fc" id="L60">    public static final boolean USE_HEAP_ALLOCATOR = CASSANDRA_NETTY_USE_HEAP_ALLOCATOR.getBoolean();</span>
<span class="pc bpc" id="L61" title="1 of 2 branches missed.">    public static final ByteBufAllocator allocator = USE_HEAP_ALLOCATOR ? new UnpooledByteBufAllocator(false) : new PooledByteBufAllocator(true);</span>
    private static final int UUID_SIZE = 16;

<span class="fc" id="L64">    private final static FastThreadLocal&lt;CharsetDecoder&gt; TL_UTF8_DECODER = new FastThreadLocal&lt;CharsetDecoder&gt;()</span>
<span class="fc" id="L65">    {</span>
        @Override
        protected CharsetDecoder initialValue()
        {
<span class="fc" id="L69">            return StandardCharsets.UTF_8.newDecoder();</span>
        }
    };

<span class="fc" id="L73">    private final static FastThreadLocal&lt;ByteBuffer&gt; localDirectBuffer = new FastThreadLocal&lt;ByteBuffer&gt;()</span>
<span class="fc" id="L74">    {</span>
        @Override
        protected ByteBuffer initialValue()
        {
<span class="nc" id="L78">            return MemoryUtil.getHollowDirectByteBuffer();</span>
        }
    };

<span class="fc" id="L82">    private final static FastThreadLocal&lt;CharBuffer&gt; TL_CHAR_BUFFER = new FastThreadLocal&lt;&gt;();</span>

    private CBUtil() {}


    // Taken from Netty's ChannelBuffers.decodeString(). We need to use our own decoder to properly handle invalid
    // UTF-8 sequences.  See CASSANDRA-8101 for more details.  This can be removed once https://github.com/netty/netty/pull/2999
    // is resolved in a release used by Cassandra.
    private static String decodeString(ByteBuffer src) throws CharacterCodingException
    {
        // the decoder needs to be reset every time we use it, hence the copy per thread
<span class="fc" id="L93">        CharsetDecoder theDecoder = TL_UTF8_DECODER.get();</span>
<span class="fc" id="L94">        theDecoder.reset();</span>
<span class="fc" id="L95">        CharBuffer dst = TL_CHAR_BUFFER.get();</span>
<span class="fc" id="L96">        int capacity = (int) ((double) src.remaining() * theDecoder.maxCharsPerByte());</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">        if (dst == null)</span>
        {
<span class="fc" id="L99">            capacity = Math.max(capacity, 4096);</span>
<span class="fc" id="L100">            dst = CharBuffer.allocate(capacity);</span>
<span class="fc" id="L101">            TL_CHAR_BUFFER.set(dst);</span>
        }
        else
        {
<span class="fc" id="L105">            dst.clear();</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">            if (dst.capacity() &lt; capacity)</span>
            {
<span class="nc" id="L108">                dst = CharBuffer.allocate(capacity);</span>
<span class="nc" id="L109">                TL_CHAR_BUFFER.set(dst);</span>
            }
        }
<span class="fc" id="L112">        CoderResult cr = theDecoder.decode(src, dst, true);</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        if (!cr.isUnderflow())</span>
<span class="nc" id="L114">            cr.throwException();</span>

<span class="fc" id="L116">        return dst.flip().toString();</span>
    }

    private static String readString(ByteBuf cb, int length)
    {
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">        if (length == 0)</span>
<span class="nc" id="L122">            return &quot;&quot;;</span>

<span class="fc" id="L124">        ByteBuffer buffer = cb.nioBuffer(cb.readerIndex(), length);</span>
        try
        {
<span class="fc" id="L127">            String str = decodeString(buffer);</span>
<span class="fc" id="L128">            cb.readerIndex(cb.readerIndex() + length);</span>
<span class="fc" id="L129">            return str;</span>
        }
<span class="nc" id="L131">        catch (IllegalStateException | CharacterCodingException e)</span>
        {
<span class="nc" id="L133">            throw new ProtocolException(&quot;Cannot decode string as UTF8: '&quot; + ByteBufferUtil.bytesToHex(buffer) + &quot;'; &quot; + e);</span>
        }
    }

    public static String readString(ByteBuf cb)
    {
        try
        {
<span class="fc" id="L141">            int length = cb.readUnsignedShort();</span>
<span class="fc" id="L142">            return readString(cb, length);</span>
        }
<span class="nc" id="L144">        catch (IndexOutOfBoundsException e)</span>
        {
<span class="nc" id="L146">            throw new ProtocolException(&quot;Not enough bytes to read an UTF8 serialized string preceded by its 2 bytes length&quot;);</span>
        }
    }

    /**
     * Write US-ASCII strings. It does not work if containing any char &gt; 0x007F (127)
     * @param str, satisfies {@link org.apache.cassandra.db.marshal.AsciiType},
     *             i.e. seven-bit ASCII, a.k.a. ISO646-US
     */
    public static void writeAsciiString(String str, ByteBuf cb)
    {
<span class="fc" id="L157">        cb.writeShort(str.length());</span>
<span class="fc" id="L158">        ByteBufUtil.writeAscii(cb, str);</span>
<span class="fc" id="L159">    }</span>

    public static void writeString(String str, ByteBuf cb)
    {
<span class="fc" id="L163">        int length = TypeSizes.encodedUTF8Length(str);</span>
<span class="fc" id="L164">        cb.writeShort(length);</span>
<span class="fc" id="L165">        ByteBufUtil.reserveAndWriteUtf8(cb, str, length);</span>
<span class="fc" id="L166">    }</span>

    public static int sizeOfString(String str)
    {
<span class="fc" id="L170">        return 2 + TypeSizes.encodedUTF8Length(str);</span>
    }

    /**
     * Returns the ecoding size of a US-ASCII string. It does not work if containing any char &gt; 0x007F (127)
     * @param str, satisfies {@link org.apache.cassandra.db.marshal.AsciiType},
     *             i.e. seven-bit ASCII, a.k.a. ISO646-US
     */
    public static int sizeOfAsciiString(String str)
    {
<span class="fc" id="L180">        return 2 + str.length();</span>
    }

    public static String readLongString(ByteBuf cb)
    {
        try
        {
<span class="fc" id="L187">            int length = cb.readInt();</span>
<span class="fc" id="L188">            return readString(cb, length);</span>
        }
<span class="nc" id="L190">        catch (IndexOutOfBoundsException e)</span>
        {
<span class="nc" id="L192">            throw new ProtocolException(&quot;Not enough bytes to read an UTF8 serialized string preceded by its 4 bytes length&quot;);</span>
        }
    }

    public static void writeLongString(String str, ByteBuf cb)
    {
<span class="nc" id="L198">        int length = TypeSizes.encodedUTF8Length(str);</span>
<span class="nc" id="L199">        cb.writeInt(length);</span>
<span class="nc" id="L200">        ByteBufUtil.reserveAndWriteUtf8(cb, str, length);</span>
<span class="nc" id="L201">    }</span>

    public static int sizeOfLongString(String str)
    {
<span class="nc" id="L205">        return 4 + TypeSizes.encodedUTF8Length(str);</span>
    }

    public static byte[] readBytes(ByteBuf cb)
    {
        try
        {
<span class="fc" id="L212">            int length = cb.readUnsignedShort();</span>
<span class="fc" id="L213">            byte[] bytes = new byte[length];</span>
<span class="fc" id="L214">            cb.readBytes(bytes);</span>
<span class="fc" id="L215">            return bytes;</span>
        }
<span class="nc" id="L217">        catch (IndexOutOfBoundsException e)</span>
        {
<span class="nc" id="L219">            throw new ProtocolException(&quot;Not enough bytes to read a byte array preceded by its 2 bytes length&quot;);</span>
        }
    }

    public static void writeBytes(byte[] bytes, ByteBuf cb)
    {
<span class="fc" id="L225">        cb.writeShort(bytes.length);</span>
<span class="fc" id="L226">        cb.writeBytes(bytes);</span>
<span class="fc" id="L227">    }</span>

    public static int sizeOfBytes(byte[] bytes)
    {
<span class="fc" id="L231">        return 2 + bytes.length;</span>
    }

    public static Map&lt;String, ByteBuffer&gt; readBytesMap(ByteBuf cb)
    {
<span class="nc" id="L236">        int length = cb.readUnsignedShort();</span>
<span class="nc" id="L237">        Map&lt;String, ByteBuffer&gt; m = new HashMap&lt;&gt;(length);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++)</span>
        {
<span class="nc" id="L240">            String k = readString(cb);</span>
<span class="nc" id="L241">            ByteBuffer v = readValue(cb);</span>
<span class="nc" id="L242">            m.put(k, v);</span>
        }
<span class="nc" id="L244">        return m;</span>
    }

    public static void writeBytesMap(Map&lt;String, ByteBuffer&gt; m, ByteBuf cb)
    {
<span class="nc" id="L249">        cb.writeShort(m.size());</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">        for (Map.Entry&lt;String, ByteBuffer&gt; entry : m.entrySet())</span>
        {
<span class="nc" id="L252">            writeString(entry.getKey(), cb);</span>
<span class="nc" id="L253">            writeValue(entry.getValue(), cb);</span>
<span class="nc" id="L254">        }</span>
<span class="nc" id="L255">    }</span>

    public static int sizeOfBytesMap(Map&lt;String, ByteBuffer&gt; m)
    {
<span class="nc" id="L259">        int size = 2;</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">        for (Map.Entry&lt;String, ByteBuffer&gt; entry : m.entrySet())</span>
        {
<span class="nc" id="L262">            size += sizeOfString(entry.getKey());</span>
<span class="nc" id="L263">            size += sizeOfValue(entry.getValue());</span>
<span class="nc" id="L264">        }</span>
<span class="nc" id="L265">        return size;</span>
    }

    public static ConsistencyLevel readConsistencyLevel(ByteBuf cb)
    {
<span class="fc" id="L270">        return ConsistencyLevel.fromCode(cb.readUnsignedShort());</span>
    }

    public static void writeConsistencyLevel(ConsistencyLevel consistency, ByteBuf cb)
    {
<span class="fc" id="L275">        cb.writeShort(consistency.code);</span>
<span class="fc" id="L276">    }</span>

    public static int sizeOfConsistencyLevel(ConsistencyLevel consistency)
    {
<span class="fc" id="L280">        return 2;</span>
    }

    public static &lt;T extends Enum&lt;T&gt;&gt; T readEnumValue(Class&lt;T&gt; enumType, ByteBuf cb)
    {
<span class="fc" id="L285">        String value = CBUtil.readString(cb);</span>
        try
        {
<span class="fc" id="L288">            return Enum.valueOf(enumType, value.toUpperCase());</span>
        }
<span class="nc" id="L290">        catch (IllegalArgumentException e)</span>
        {
<span class="nc" id="L292">            throw new ProtocolException(String.format(&quot;Invalid value '%s' for %s&quot;, value, enumType.getSimpleName()));</span>
        }
    }

    public static &lt;T extends Enum&lt;T&gt;&gt; void writeEnumValue(T enumValue, ByteBuf cb)
    {
        // UTF-8 (non-ascii) literals can be used for as a valid identifier in Java. It is possible for an enum to be named using those characters.
        // There is no such occurence in the code base.
<span class="fc" id="L300">        writeAsciiString(enumValue.toString(), cb);</span>
<span class="fc" id="L301">    }</span>

    public static &lt;T extends Enum&lt;T&gt;&gt; int sizeOfEnumValue(T enumValue)
    {
<span class="fc" id="L305">        return sizeOfAsciiString(enumValue.toString());</span>
    }

    public static UUID readUUID(ByteBuf cb)
    {
<span class="nc" id="L310">        ByteBuffer buffer = cb.nioBuffer(cb.readerIndex(), UUID_SIZE);</span>
<span class="nc" id="L311">        cb.skipBytes(buffer.remaining());</span>
<span class="nc" id="L312">        return UUIDGen.getUUID(buffer);</span>
    }

    public static TimeUUID readTimeUUID(ByteBuf cb)
    {
<span class="nc" id="L317">        long msb = cb.readLong();</span>
<span class="nc" id="L318">        long lsb = cb.readLong();</span>
<span class="nc" id="L319">        return TimeUUID.fromBytes(msb, lsb);</span>
    }

    public static void writeUUID(UUID uuid, ByteBuf cb)
    {
<span class="nc" id="L324">        cb.writeBytes(UUIDGen.decompose(uuid));</span>
<span class="nc" id="L325">    }</span>

    public static void writeUUID(TimeUUID uuid, ByteBuf cb)
    {
<span class="nc" id="L329">        cb.writeLong(uuid.msb());</span>
<span class="nc" id="L330">        cb.writeLong(uuid.lsb());</span>
<span class="nc" id="L331">    }</span>

    public static int sizeOfUUID(UUID uuid)
    {
<span class="nc" id="L335">        return UUID_SIZE;</span>
    }

    public static List&lt;String&gt; readStringList(ByteBuf cb)
    {
<span class="nc" id="L340">        int length = cb.readUnsignedShort();</span>
<span class="nc" id="L341">        List&lt;String&gt; l = new ArrayList&lt;String&gt;(length);</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++)</span>
<span class="nc" id="L343">            l.add(readString(cb));</span>
<span class="nc" id="L344">        return l;</span>
    }

    public static void writeStringList(List&lt;String&gt; l, ByteBuf cb)
    {
<span class="fc" id="L349">        cb.writeShort(l.size());</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">        for (String str : l)</span>
<span class="fc" id="L351">            writeString(str, cb);</span>
<span class="fc" id="L352">    }</span>

    public static int sizeOfStringList(List&lt;String&gt; l)
    {
<span class="fc" id="L356">        int size = 2;</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">        for (String str : l)</span>
<span class="fc" id="L358">            size += sizeOfString(str);</span>
<span class="fc" id="L359">        return size;</span>
    }

    public static Map&lt;String, String&gt; readStringMap(ByteBuf cb)
    {
<span class="fc" id="L364">        int length = cb.readUnsignedShort();</span>
<span class="fc" id="L365">        Map&lt;String, String&gt; m = new HashMap&lt;String, String&gt;(length);</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++)</span>
        {
<span class="fc" id="L368">            String k = readString(cb);</span>
<span class="fc" id="L369">            String v = readString(cb);</span>
<span class="fc" id="L370">            m.put(k, v);</span>
        }
<span class="fc" id="L372">        return m;</span>
    }

    public static void writeStringMap(Map&lt;String, String&gt; m, ByteBuf cb)
    {
<span class="nc" id="L377">        cb.writeShort(m.size());</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">        for (Map.Entry&lt;String, String&gt; entry : m.entrySet())</span>
        {
<span class="nc" id="L380">            writeString(entry.getKey(), cb);</span>
<span class="nc" id="L381">            writeString(entry.getValue(), cb);</span>
<span class="nc" id="L382">        }</span>
<span class="nc" id="L383">    }</span>

    public static int sizeOfStringMap(Map&lt;String, String&gt; m)
    {
<span class="nc" id="L387">        int size = 2;</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">        for (Map.Entry&lt;String, String&gt; entry : m.entrySet())</span>
        {
<span class="nc" id="L390">            size += sizeOfString(entry.getKey());</span>
<span class="nc" id="L391">            size += sizeOfString(entry.getValue());</span>
<span class="nc" id="L392">        }</span>
<span class="nc" id="L393">        return size;</span>
    }

    public static Map&lt;String, List&lt;String&gt;&gt; readStringToStringListMap(ByteBuf cb)
    {
<span class="nc" id="L398">        int length = cb.readUnsignedShort();</span>
<span class="nc" id="L399">        Map&lt;String, List&lt;String&gt;&gt; m = new HashMap&lt;String, List&lt;String&gt;&gt;(length);</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++)</span>
        {
<span class="nc" id="L402">            String k = readString(cb).toUpperCase();</span>
<span class="nc" id="L403">            List&lt;String&gt; v = readStringList(cb);</span>
<span class="nc" id="L404">            m.put(k, v);</span>
        }
<span class="nc" id="L406">        return m;</span>
    }

    public static void writeStringToStringListMap(Map&lt;String, List&lt;String&gt;&gt; m, ByteBuf cb)
    {
<span class="fc" id="L411">        cb.writeShort(m.size());</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">        for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : m.entrySet())</span>
        {
<span class="fc" id="L414">            writeString(entry.getKey(), cb);</span>
<span class="fc" id="L415">            writeStringList(entry.getValue(), cb);</span>
<span class="fc" id="L416">        }</span>
<span class="fc" id="L417">    }</span>

    public static int sizeOfStringToStringListMap(Map&lt;String, List&lt;String&gt;&gt; m)
    {
<span class="fc" id="L421">        int size = 2;</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">        for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : m.entrySet())</span>
        {
<span class="fc" id="L424">            size += sizeOfString(entry.getKey());</span>
<span class="fc" id="L425">            size += sizeOfStringList(entry.getValue());</span>
<span class="fc" id="L426">        }</span>
<span class="fc" id="L427">        return size;</span>
    }

    public static ByteBuffer readValue(ByteBuf cb)
    {
<span class="nc" id="L432">        int length = cb.readInt();</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">        if (length &lt; 0)</span>
<span class="nc" id="L434">            return null;</span>

<span class="nc" id="L436">        return ByteBuffer.wrap(readRawBytes(cb, length));</span>
    }

    public static ByteBuffer readValueNoCopy(ByteBuf cb)
    {
<span class="nc" id="L441">        int length = cb.readInt();</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">        if (length &lt; 0)</span>
<span class="nc" id="L443">            return null;</span>

<span class="nc" id="L445">        ByteBuffer buffer = cb.nioBuffer(cb.readerIndex(), length);</span>
<span class="nc" id="L446">        cb.skipBytes(length);</span>
<span class="nc" id="L447">        return buffer;</span>
    }

    public static ByteBuffer readBoundValue(ByteBuf cb, ProtocolVersion protocolVersion)
    {
<span class="fc" id="L452">        int length = cb.readInt();</span>
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">        if (length &lt; 0)</span>
        {
<span class="nc bnc" id="L455" title="All 2 branches missed.">            if (protocolVersion.isSmallerThan(ProtocolVersion.V4)) // backward compatibility for pre-version 4</span>
<span class="nc" id="L456">                return null;</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">            if (length == -1)</span>
<span class="nc" id="L458">                return null;</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">            else if (length == -2)</span>
<span class="nc" id="L460">                return ByteBufferUtil.UNSET_BYTE_BUFFER;</span>
            else
<span class="nc" id="L462">                throw new ProtocolException(&quot;Invalid ByteBuf length &quot; + length);</span>
        }
<span class="fc" id="L464">        return ByteBuffer.wrap(readRawBytes(cb, length));</span>
    }

    public static void writeValue(byte[] bytes, ByteBuf cb)
    {
<span class="nc bnc" id="L469" title="All 2 branches missed.">        if (bytes == null)</span>
        {
<span class="nc" id="L471">            cb.writeInt(-1);</span>
<span class="nc" id="L472">            return;</span>
        }

<span class="nc" id="L475">        cb.writeInt(bytes.length);</span>
<span class="nc" id="L476">        cb.writeBytes(bytes);</span>
<span class="nc" id="L477">    }</span>

    public static void writeValue(ByteBuffer bytes, ByteBuf cb)
    {
<span class="fc bfc" id="L481" title="All 2 branches covered.">        if (bytes == null)</span>
        {
<span class="fc" id="L483">            cb.writeInt(-1);</span>
<span class="fc" id="L484">            return;</span>
        }

<span class="fc" id="L487">        int remaining = bytes.remaining();</span>
<span class="fc" id="L488">        cb.writeInt(remaining);</span>

<span class="fc bfc" id="L490" title="All 2 branches covered.">        if (remaining &gt; 0)</span>
<span class="fc" id="L491">            addBytes(bytes, cb);</span>
<span class="fc" id="L492">    }</span>

    public static void addBytes(ByteBuffer src, ByteBuf dest)
    {
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">        if (src.remaining() == 0)</span>
<span class="nc" id="L497">            return;</span>

<span class="fc" id="L499">        int length = src.remaining();</span>

<span class="pc bpc" id="L501" title="1 of 2 branches missed.">        if (src.hasArray())</span>
        {
            // Heap buffers are copied using a raw array instead of shared heap buffer and MemoryUtil.unsafe to avoid a CMS bug, which causes the JVM to crash with the follwing:
            // # Problematic frame:
            // # V  [libjvm.dylib+0x63e858]  void ParScanClosure::do_oop_work&lt;unsigned int&gt;(unsigned int*, bool, bool)+0x94
            // More details can be found here: https://bugs.openjdk.org/browse/JDK-8222798
<span class="fc" id="L507">            byte[] array = src.array();</span>
<span class="fc" id="L508">            dest.writeBytes(array, src.arrayOffset() + src.position(), length);</span>
<span class="fc" id="L509">        }</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">        else if (src.isDirect())</span>
        {
<span class="nc" id="L512">            ByteBuffer local = getLocalDirectBuffer();</span>
<span class="nc" id="L513">            MemoryUtil.duplicateDirectByteBuffer(src, local);</span>
<span class="nc" id="L514">            dest.writeBytes(local);</span>
<span class="nc" id="L515">        }</span>
        else
        {
<span class="nc" id="L518">            dest.writeBytes(src.duplicate());</span>
        }
<span class="fc" id="L520">    }</span>

    public static int sizeOfValue(byte[] bytes)
    {
<span class="nc bnc" id="L524" title="All 2 branches missed.">        return 4 + (bytes == null ? 0 : bytes.length);</span>
    }

    public static int sizeOfValue(ByteBuffer bytes)
    {
<span class="fc bfc" id="L529" title="All 2 branches covered.">        return 4 + (bytes == null ? 0 : bytes.remaining());</span>
    }

    // The size of serializing a value given the size (in bytes) of said value. The provided size can be negative
    // to indicate that the value is null.
    public static int sizeOfValue(int valueSize)
    {
<span class="nc bnc" id="L536" title="All 2 branches missed.">        return 4 + (valueSize &lt; 0 ? 0 : valueSize);</span>
    }

    public static List&lt;ByteBuffer&gt; readValueList(ByteBuf cb, ProtocolVersion protocolVersion)
    {
<span class="fc" id="L541">        int size = cb.readUnsignedShort();</span>
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">        if (size == 0)</span>
<span class="nc" id="L543">            return Collections.&lt;ByteBuffer&gt;emptyList();</span>

<span class="fc" id="L545">        List&lt;ByteBuffer&gt; l = new ArrayList&lt;ByteBuffer&gt;(size);</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++)</span>
<span class="fc" id="L547">            l.add(readBoundValue(cb, protocolVersion));</span>
<span class="fc" id="L548">        return l;</span>
    }

    public static void writeValueList(List&lt;ByteBuffer&gt; values, ByteBuf cb)
    {
<span class="nc" id="L553">        cb.writeShort(values.size());</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">        for (ByteBuffer value : values)</span>
<span class="nc" id="L555">            CBUtil.writeValue(value, cb);</span>
<span class="nc" id="L556">    }</span>

    public static int sizeOfValueList(List&lt;ByteBuffer&gt; values)
    {
<span class="nc" id="L560">        int size = 2;</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">        for (ByteBuffer value : values)</span>
<span class="nc" id="L562">            size += CBUtil.sizeOfValue(value);</span>
<span class="nc" id="L563">        return size;</span>
    }

    public static Pair&lt;List&lt;String&gt;, List&lt;ByteBuffer&gt;&gt; readNameAndValueList(ByteBuf cb, ProtocolVersion protocolVersion)
    {
<span class="nc" id="L568">        int size = cb.readUnsignedShort();</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">        if (size == 0)</span>
<span class="nc" id="L570">            return Pair.create(Collections.&lt;String&gt;emptyList(), Collections.&lt;ByteBuffer&gt;emptyList());</span>

<span class="nc" id="L572">        List&lt;String&gt; s = new ArrayList&lt;&gt;(size);</span>
<span class="nc" id="L573">        List&lt;ByteBuffer&gt; l = new ArrayList&lt;&gt;(size);</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L576">            s.add(readString(cb));</span>
<span class="nc" id="L577">            l.add(readBoundValue(cb, protocolVersion));</span>
        }
<span class="nc" id="L579">        return Pair.create(s, l);</span>
    }

    public static InetSocketAddress readInet(ByteBuf cb)
    {
<span class="nc" id="L584">        int addrSize = cb.readByte() &amp; 0xFF;</span>
<span class="nc" id="L585">        byte[] address = new byte[addrSize];</span>
<span class="nc" id="L586">        cb.readBytes(address);</span>
<span class="nc" id="L587">        int port = cb.readInt();</span>
        try
        {
<span class="nc" id="L590">            return new InetSocketAddress(InetAddress.getByAddress(address), port);</span>
        }
<span class="nc" id="L592">        catch (UnknownHostException e)</span>
        {
<span class="nc" id="L594">            throw new ProtocolException(String.format(&quot;Invalid IP address (%d.%d.%d.%d) while deserializing inet address&quot;, address[0], address[1], address[2], address[3]));</span>
        }
    }

    public static void writeInet(InetSocketAddress inet, ByteBuf cb)
    {
<span class="fc" id="L600">        byte[] address = inet.getAddress().getAddress();</span>

<span class="fc" id="L602">        cb.writeByte(address.length);</span>
<span class="fc" id="L603">        cb.writeBytes(address);</span>
<span class="fc" id="L604">        cb.writeInt(inet.getPort());</span>
<span class="fc" id="L605">    }</span>

    public static int sizeOfInet(InetSocketAddress inet)
    {
<span class="fc" id="L609">        byte[] address = inet.getAddress().getAddress();</span>
<span class="fc" id="L610">        return 1 + address.length + 4;</span>
    }

    public static InetAddress readInetAddr(ByteBuf cb)
    {
<span class="nc" id="L615">        int addressSize = cb.readByte() &amp; 0xFF;</span>
<span class="nc" id="L616">        byte[] address = new byte[addressSize];</span>
<span class="nc" id="L617">        cb.readBytes(address);</span>
        try
        {
<span class="nc" id="L620">            return InetAddress.getByAddress(address);</span>
        }
<span class="nc" id="L622">        catch (UnknownHostException e)</span>
        {
<span class="nc" id="L624">            throw new ProtocolException(&quot;Invalid IP address while deserializing inet address&quot;);</span>
        }
    }

    public static void writeInetAddr(InetAddress inetAddr, ByteBuf cb)
    {
<span class="nc" id="L630">        byte[] address = inetAddr.getAddress();</span>
<span class="nc" id="L631">        cb.writeByte(address.length);</span>
<span class="nc" id="L632">        cb.writeBytes(address);</span>
<span class="nc" id="L633">    }</span>

    public static int sizeOfInetAddr(InetAddress inetAddr)
    {
<span class="nc" id="L637">        return 1 + inetAddr.getAddress().length;</span>
    }

    /*
     * Reads *all* readable bytes from {@code cb} and return them.
     */
    public static byte[] readRawBytes(ByteBuf cb)
    {
<span class="nc" id="L645">        return readRawBytes(cb, cb.readableBytes());</span>
    }

    private static byte[] readRawBytes(ByteBuf cb, int length)
    {
<span class="fc" id="L650">        byte[] bytes = new byte[length];</span>
<span class="fc" id="L651">        cb.readBytes(bytes);</span>
<span class="fc" id="L652">        return bytes;</span>
    }

    private static ByteBuffer getLocalDirectBuffer()
    {
<span class="nc" id="L657">        return localDirectBuffer.get();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>