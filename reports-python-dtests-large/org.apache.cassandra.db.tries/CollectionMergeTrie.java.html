<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CollectionMergeTrie.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.tries</a> &gt; <span class="el_source">CollectionMergeTrie.java</span></div><h1>CollectionMergeTrie.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.tries;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import com.google.common.collect.Iterables;

/**
 * A merged view of multiple tries.
 *
 * This is accomplished by walking the cursors in parallel; the merged cursor takes the position and features of the
 * smallest and advances with it; when multiple cursors are equal, all of them are advanced. The ordered view of the
 * cursors is maintained using a custom binary min-heap, built for efficiently reforming the heap when the top elements
 * are advanced (see {@link CollectionMergeCursor}).
 *
 * Crucial for the efficiency of this is the fact that when they are advanced like this, we can compare cursors'
 * positions by their depth descending and then incomingTransition ascending.
 *
 * See Trie.md for further details.
 */
class CollectionMergeTrie&lt;T&gt; extends Trie&lt;T&gt;
{
    private final CollectionMergeResolver&lt;T&gt; resolver;  // only called on more than one input
    protected final Collection&lt;? extends Trie&lt;T&gt;&gt; inputs;

    CollectionMergeTrie(Collection&lt;? extends Trie&lt;T&gt;&gt; inputs, CollectionMergeResolver&lt;T&gt; resolver)
<span class="nc" id="L45">    {</span>
<span class="nc" id="L46">        this.resolver = resolver;</span>
<span class="nc" id="L47">        this.inputs = inputs;</span>
<span class="nc" id="L48">    }</span>

    @Override
    protected Cursor&lt;T&gt; cursor()
    {
<span class="nc" id="L53">        return new CollectionMergeCursor&lt;&gt;(resolver, inputs);</span>
    }

    /**
     * Compare the positions of two cursors. One is before the other when
     * - its depth is greater, or
     * - its depth is equal, and the incoming transition is smaller.
     */
    static &lt;T&gt; boolean greaterCursor(Cursor&lt;T&gt; c1, Cursor&lt;T&gt; c2)
    {
<span class="nc" id="L63">        int c1depth = c1.depth();</span>
<span class="nc" id="L64">        int c2depth = c2.depth();</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">        if (c1depth != c2depth)</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">            return c1depth &lt; c2depth;</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">        return c1.incomingTransition() &gt; c2.incomingTransition();</span>
    }

    static &lt;T&gt; boolean equalCursor(Cursor&lt;T&gt; c1, Cursor&lt;T&gt; c2)
    {
<span class="nc bnc" id="L72" title="All 4 branches missed.">        return c1.depth() == c2.depth() &amp;&amp; c1.incomingTransition() == c2.incomingTransition();</span>
    }

    /*
     * The merge cursor is a variation of the idea of a merge iterator with one key observation: because we advance
     * the source iterators together, we can compare them just by depth and incoming transition.
     *
     * The most straightforward way to implement merging of iterators is to use a {@code PriorityQueue},
     * {@code poll} it to find the next item to consume, then {@code add} the iterator back after advancing.
     * This is not very efficient as {@code poll} and {@code add} in all cases require at least
     * {@code log(size)} comparisons and swaps (usually more than {@code 2*log(size)}) per consumed item, even
     * if the input is suitable for fast iteration.
     *
     * The implementation below makes use of the fact that replacing the top element in a binary heap can be
     * done much more efficiently than separately removing it and placing it back, especially in the cases where
     * the top iterator is to be used again very soon (e.g. when there are large sections of the output where
     * only a limited number of input iterators overlap, which is normally the case in many practically useful
     * situations, e.g. levelled compaction).
     *
     * The implementation builds and maintains a binary heap of sources (stored in an array), where we do not
     * add items after the initial construction. Instead we advance the smallest element (which is at the top
     * of the heap) and push it down to find its place for its new position. Should this source be exhausted,
     * we swap it with the last source in the heap and proceed by pushing that down in the heap.
     *
     * In the case where we have multiple sources with matching positions, the merging algorithm
     * must be able to merge all equal values. To achieve this {@code content} walks the heap to
     * find all equal cursors without advancing them, and separately {@code advance} advances
     * all equal sources and restores the heap structure.
     *
     * The latter is done equivalently to the process of initial construction of a min-heap using back-to-front
     * heapification as done in the classic heapsort algorithm. It only needs to heapify subheaps whose top item
     * is advanced (i.e. one whose position matches the current), and we can do that recursively from
     * bottom to top. Should a source be exhausted when advancing, it can be thrown away by swapping in the last
     * source in the heap (note: we must be careful to advance that source too if required).
     *
     * To make it easier to advance efficienty in single-sourced branches of tries, we extract the current smallest
     * cursor (the head) separately, and start any advance with comparing that to the heap's first. When the smallest
     * cursor remains the same (e.g. in branches coming from a single source) this makes it possible to advance with
     * just one comparison instead of two at the expense of increasing the number by one in the general case.
     *
     * Note: This is a simplification of the MergeIterator code from CASSANDRA-8915, without the leading ordered
     * section and equalParent flag since comparisons of cursor positions are cheap.
     */
<span class="nc" id="L115">    static class CollectionMergeCursor&lt;T&gt; implements Cursor&lt;T&gt;</span>
    {
        private final CollectionMergeResolver&lt;T&gt; resolver;

        /**
         * The smallest cursor, tracked separately to improve performance in single-source sections of the trie.
         */
        private Cursor&lt;T&gt; head;

        /**
         * Binary heap of the remaining cursors. The smallest element is at position 0.
         * Every element i is smaller than or equal to its two children, i.e.
         *     heap[i] &lt;= heap[i*2 + 1] &amp;&amp; heap[i] &lt;= heap[i*2 + 2]
         */
        private final Cursor&lt;T&gt;[] heap;

        /**
         * A list used to collect contents during content() calls.
         */
        private final List&lt;T&gt; contents;

        public CollectionMergeCursor(CollectionMergeResolver&lt;T&gt; resolver, Collection&lt;? extends Trie&lt;T&gt;&gt; inputs)
<span class="nc" id="L137">        {</span>
<span class="nc" id="L138">            this.resolver = resolver;</span>
<span class="nc" id="L139">            int count = inputs.size();</span>
            // Get cursors for all inputs. Put one of them in head and the rest in the heap.
<span class="nc" id="L141">            heap = new Cursor[count - 1];</span>
<span class="nc" id="L142">            contents = new ArrayList&lt;&gt;(count);</span>
<span class="nc" id="L143">            int i = -1;</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">            for (Trie&lt;T&gt; trie : inputs)</span>
            {
<span class="nc" id="L146">                Cursor&lt;T&gt; cursor = trie.cursor();</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">                assert cursor.depth() == 0;</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">                if (i &gt;= 0)</span>
<span class="nc" id="L149">                    heap[i] = cursor;</span>
                else
<span class="nc" id="L151">                    head = cursor;</span>
<span class="nc" id="L152">                ++i;</span>
<span class="nc" id="L153">            }</span>
            // The cursors are all currently positioned on the root and thus in valid heap order.
<span class="nc" id="L155">        }</span>

        /**
         * Interface for internal operations that can be applied to the equal top elements of the heap.
         */
        interface HeapOp&lt;T&gt;
        {
            void apply(CollectionMergeCursor&lt;T&gt; self, Cursor&lt;T&gt; cursor, int index);
        }

        /**
         * Apply a non-interfering operation, i.e. one that does not change the cursor state, to all inputs in the heap
         * that are on equal position to the head.
         * For interfering operations like advancing the cursors, use {@link #advanceEqualAndRestoreHeap(AdvancingHeapOp)}.
         */
        private void applyToEqualOnHeap(HeapOp&lt;T&gt; action)
        {
<span class="nc" id="L172">            applyToEqualElementsInHeap(action, 0);</span>
<span class="nc" id="L173">        }</span>

        /**
         * Interface for internal advancing operations that can be applied to the heap cursors. This interface provides
         * the code to restore the heap structure after advancing the cursors.
         */
        interface AdvancingHeapOp&lt;T&gt; extends HeapOp&lt;T&gt;
        {
            void apply(Cursor&lt;T&gt; cursor);

            default void apply(CollectionMergeCursor&lt;T&gt; self, Cursor&lt;T&gt; cursor, int index)
            {
                // Apply the operation, which should advance the position of the element.
<span class="nc" id="L186">                apply(cursor);</span>

                // This method is called on the back path of the recursion. At this point the heaps at both children are
                // advanced and well-formed.
                // Place current node in its proper position.
<span class="nc" id="L191">                self.heapifyDown(cursor, index);</span>
                // The heap rooted at index is now advanced and well-formed.
<span class="nc" id="L193">            }</span>
        }


        /**
         * Advance the state of all inputs in the heap that are on equal position as the head and restore the heap
         * invariant.
         */
        private void advanceEqualAndRestoreHeap(AdvancingHeapOp&lt;T&gt; action)
        {
<span class="nc" id="L203">            applyToEqualElementsInHeap(action, 0);</span>
<span class="nc" id="L204">        }</span>

        /**
         * Apply an operation to all elements on the heap that are equal to the head. Descends recursively in the heap
         * structure to all equal children and applies the operation on the way back.
         *
         * This operation can be something that does not change the cursor state (see {@link #content}) or an operation
         * that advances the cursor to a new state, wrapped in a {@link AdvancingHeapOp} ({@link #advance} or
         * {@link #skipChildren}). The latter interface takes care of pushing elements down in the heap after advancing
         * and restores the subheap state on return from each level of the recursion.
         */
        private void applyToEqualElementsInHeap(HeapOp&lt;T&gt; action, int index)
        {
<span class="nc bnc" id="L217" title="All 2 branches missed.">            if (index &gt;= heap.length)</span>
<span class="nc" id="L218">                return;</span>
<span class="nc" id="L219">            Cursor&lt;T&gt; item = heap[index];</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">            if (!equalCursor(item, head))</span>
<span class="nc" id="L221">                return;</span>

            // If the children are at the same position, they also need advancing and their subheap
            // invariant to be restored.
<span class="nc" id="L225">            applyToEqualElementsInHeap(action, index * 2 + 1);</span>
<span class="nc" id="L226">            applyToEqualElementsInHeap(action, index * 2 + 2);</span>

            // Apply the action. This is done on the reverse direction to give the action a chance to form proper
            // subheaps and combine them on processing the parent.
<span class="nc" id="L230">            action.apply(this, item, index);</span>
<span class="nc" id="L231">        }</span>

        /**
         * Push the given state down in the heap from the given index until it finds its proper place among
         * the subheap rooted at that position.
         */
        private void heapifyDown(Cursor&lt;T&gt; item, int index)
        {
            while (true)
            {
<span class="nc" id="L241">                int next = index * 2 + 1;</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">                if (next &gt;= heap.length)</span>
<span class="nc" id="L243">                    break;</span>
                // Select the smaller of the two children to push down to.
<span class="nc bnc" id="L245" title="All 4 branches missed.">                if (next + 1 &lt; heap.length &amp;&amp; greaterCursor(heap[next], heap[next + 1]))</span>
<span class="nc" id="L246">                    ++next;</span>
                // If the child is greater or equal, the invariant has been restored.
<span class="nc bnc" id="L248" title="All 2 branches missed.">                if (!greaterCursor(item, heap[next]))</span>
<span class="nc" id="L249">                    break;</span>
<span class="nc" id="L250">                heap[index] = heap[next];</span>
<span class="nc" id="L251">                index = next;</span>
<span class="nc" id="L252">            }</span>
<span class="nc" id="L253">            heap[index] = item;</span>
<span class="nc" id="L254">        }</span>

        /**
         * Check if the head is greater than the top element in the heap, and if so, swap them and push down the new
         * top until its proper place.
         * @param headDepth the depth of the head cursor (as returned by e.g. advance).
         * @return the new head element's depth
         */
        private int maybeSwapHead(int headDepth)
        {
<span class="nc" id="L264">            int heap0Depth = heap[0].depth();</span>
<span class="nc bnc" id="L265" title="All 4 branches missed.">            if (headDepth &gt; heap0Depth ||</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">                (headDepth == heap0Depth &amp;&amp; head.incomingTransition() &lt;= heap[0].incomingTransition()))</span>
<span class="nc" id="L267">                return headDepth;   // head is still smallest</span>

            // otherwise we need to swap heap and heap[0]
<span class="nc" id="L270">            Cursor&lt;T&gt; newHeap0 = head;</span>
<span class="nc" id="L271">            head = heap[0];</span>
<span class="nc" id="L272">            heapifyDown(newHeap0, 0);</span>
<span class="nc" id="L273">            return heap0Depth;</span>
        }

        @Override
        public int advance()
        {
<span class="nc" id="L279">            advanceEqualAndRestoreHeap(Cursor::advance);</span>
<span class="nc" id="L280">            return maybeSwapHead(head.advance());</span>
        }

        @Override
        public int advanceMultiple(TransitionsReceiver receiver)
        {
            // If the current position is present in just one cursor, we can safely descend multiple levels within
            // its branch as no one of the other tries has content for it.
<span class="nc bnc" id="L288" title="All 2 branches missed.">            if (equalCursor(heap[0], head))</span>
<span class="nc" id="L289">                return advance();   // More than one source at current position, do single-step advance.</span>

            // If there are no children, i.e. the cursor ascends, we have to check if it's become larger than some
            // other candidate.
<span class="nc" id="L293">            return maybeSwapHead(head.advanceMultiple(receiver));</span>
        }

        @Override
        public int skipChildren()
        {
<span class="nc" id="L299">            advanceEqualAndRestoreHeap(Cursor::skipChildren);</span>
<span class="nc" id="L300">            return maybeSwapHead(head.skipChildren());</span>
        }

        @Override
        public int depth()
        {
<span class="nc" id="L306">            return head.depth();</span>
        }

        @Override
        public int incomingTransition()
        {
<span class="nc" id="L312">            return head.incomingTransition();</span>
        }

        @Override
        public T content()
        {
<span class="nc" id="L318">            applyToEqualOnHeap(CollectionMergeCursor::collectContent);</span>
<span class="nc" id="L319">            collectContent(head, -1);</span>

            T toReturn;
<span class="nc bnc" id="L322" title="All 3 branches missed.">            switch (contents.size())</span>
            {
                case 0:
<span class="nc" id="L325">                    toReturn = null;</span>
<span class="nc" id="L326">                    break;</span>
                case 1:
<span class="nc" id="L328">                    toReturn = contents.get(0);</span>
<span class="nc" id="L329">                    break;</span>
                default:
<span class="nc" id="L331">                    toReturn = resolver.resolve(contents);</span>
                    break;
            }
<span class="nc" id="L334">            contents.clear();</span>
<span class="nc" id="L335">            return toReturn;</span>
        }

        private void collectContent(Cursor&lt;T&gt; item, int index)
        {
<span class="nc" id="L340">            T itemContent = item.content();</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">            if (itemContent != null)</span>
<span class="nc" id="L342">                contents.add(itemContent);</span>
<span class="nc" id="L343">        }</span>
    }

    /**
     * Special instance for sources that are guaranteed distinct. The main difference is that we can form unordered
     * value list by concatenating sources.
     */
    static class Distinct&lt;T&gt; extends CollectionMergeTrie&lt;T&gt;
    {
        Distinct(Collection&lt;? extends Trie&lt;T&gt;&gt; inputs)
        {
<span class="nc" id="L354">            super(inputs, throwingResolver());</span>
<span class="nc" id="L355">        }</span>

        @Override
        public Iterable&lt;T&gt; valuesUnordered()
        {
<span class="nc" id="L360">            return Iterables.concat(Iterables.transform(inputs, Trie::valuesUnordered));</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>