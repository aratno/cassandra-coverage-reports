<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UntypedResultSet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3</a> &gt; <span class="el_source">UntypedResultSet.java</span></div><h1>UntypedResultSet.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cassandra.cql3;

import java.net.InetAddress;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

import com.google.common.annotations.VisibleForTesting;

import com.datastax.driver.core.CodecUtils;
import org.apache.cassandra.cql3.functions.types.LocalDate;
import org.apache.cassandra.cql3.statements.SelectStatement;
import org.apache.cassandra.db.Clustering;
import org.apache.cassandra.db.ConsistencyLevel;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.ReadExecutionController;
import org.apache.cassandra.db.marshal.*;
import org.apache.cassandra.db.partitions.PartitionIterator;
import org.apache.cassandra.db.rows.Cell;
import org.apache.cassandra.db.rows.ComplexColumnData;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.service.ClientState;
import org.apache.cassandra.service.pager.QueryPager;
import org.apache.cassandra.utils.AbstractIterator;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.TimeUUID;

import static org.apache.cassandra.utils.Clock.Global.nanoTime;

/** a utility for doing internal cql-based queries */
<span class="fc" id="L56">public abstract class UntypedResultSet implements Iterable&lt;UntypedResultSet.Row&gt;</span>
{
    public static UntypedResultSet create(ResultSet rs)
    {
<span class="fc" id="L60">        return new FromResultSet(rs);</span>
    }

    public static UntypedResultSet create(List&lt;Map&lt;String, ByteBuffer&gt;&gt; results)
    {
<span class="nc" id="L65">        return new FromResultList(results);</span>
    }

    public static UntypedResultSet create(SelectStatement select, QueryPager pager, int pageSize)
    {
<span class="fc" id="L70">        return new FromPager(select, pager, pageSize);</span>
    }

    /**
     * This method is intended for testing purposes, since it executes query on cluster
     * and not on the local node only.
     */
    @VisibleForTesting
    public static UntypedResultSet create(SelectStatement select,
                                          ConsistencyLevel cl,
                                          ClientState clientState,
                                          QueryPager pager,
                                          int pageSize)
    {
<span class="nc" id="L84">        return new FromDistributedPager(select, cl, clientState, pager, pageSize);</span>
    }

    public boolean isEmpty()
    {
<span class="fc bfc" id="L89" title="All 2 branches covered.">        return size() == 0;</span>
    }

    public abstract int size();
    public abstract Row one();

    // No implemented by all subclasses, but we use it when we know it's there (for tests)
    public abstract List&lt;ColumnSpecification&gt; metadata();

    private static class FromResultSet extends UntypedResultSet
    {
        private final ResultSet cqlRows;

        private FromResultSet(ResultSet cqlRows)
<span class="fc" id="L103">        {</span>
<span class="fc" id="L104">            this.cqlRows = cqlRows;</span>
<span class="fc" id="L105">        }</span>

        public int size()
        {
<span class="fc" id="L109">            return cqlRows.size();</span>
        }

        public Row one()
        {
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">            if (cqlRows.size() != 1)</span>
<span class="nc" id="L115">                throw new IllegalStateException(&quot;One row required, &quot; + cqlRows.size() + &quot; found&quot;);</span>
<span class="fc" id="L116">            return new Row(cqlRows.metadata.requestNames(), cqlRows.rows.get(0));</span>
        }

        public Iterator&lt;Row&gt; iterator()
        {
<span class="fc" id="L121">            return new AbstractIterator&lt;Row&gt;()</span>
<span class="fc" id="L122">            {</span>
<span class="fc" id="L123">                final Iterator&lt;List&lt;ByteBuffer&gt;&gt; iter = cqlRows.rows.iterator();</span>

                protected Row computeNext()
                {
<span class="fc bfc" id="L127" title="All 2 branches covered.">                    if (!iter.hasNext())</span>
<span class="fc" id="L128">                        return endOfData();</span>
<span class="fc" id="L129">                    return new Row(cqlRows.metadata.requestNames(), iter.next());</span>
                }
            };
        }

        public List&lt;ColumnSpecification&gt; metadata()
        {
<span class="nc" id="L136">            return cqlRows.metadata.requestNames();</span>
        }
    }

    private static class FromResultList extends UntypedResultSet
    {
        private final List&lt;Map&lt;String, ByteBuffer&gt;&gt; cqlRows;

        private FromResultList(List&lt;Map&lt;String, ByteBuffer&gt;&gt; cqlRows)
<span class="nc" id="L145">        {</span>
<span class="nc" id="L146">            this.cqlRows = cqlRows;</span>
<span class="nc" id="L147">        }</span>

        public int size()
        {
<span class="nc" id="L151">            return cqlRows.size();</span>
        }

        public Row one()
        {
<span class="nc bnc" id="L156" title="All 2 branches missed.">            if (cqlRows.size() != 1)</span>
<span class="nc" id="L157">                throw new IllegalStateException(&quot;One row required, &quot; + cqlRows.size() + &quot; found&quot;);</span>
<span class="nc" id="L158">            return new Row(cqlRows.get(0));</span>
        }

        public Iterator&lt;Row&gt; iterator()
        {
<span class="nc" id="L163">            return new AbstractIterator&lt;Row&gt;()</span>
<span class="nc" id="L164">            {</span>
<span class="nc" id="L165">                final Iterator&lt;Map&lt;String, ByteBuffer&gt;&gt; iter = cqlRows.iterator();</span>

                protected Row computeNext()
                {
<span class="nc bnc" id="L169" title="All 2 branches missed.">                    if (!iter.hasNext())</span>
<span class="nc" id="L170">                        return endOfData();</span>
<span class="nc" id="L171">                    return new Row(iter.next());</span>
                }
            };
        }

        public List&lt;ColumnSpecification&gt; metadata()
        {
<span class="nc" id="L178">            throw new UnsupportedOperationException();</span>
        }
    }

    private static class FromPager extends UntypedResultSet
    {
        private final SelectStatement select;
        private final QueryPager pager;
        private final int pageSize;
        private final List&lt;ColumnSpecification&gt; metadata;

        private FromPager(SelectStatement select, QueryPager pager, int pageSize)
<span class="fc" id="L190">        {</span>
<span class="fc" id="L191">            this.select = select;</span>
<span class="fc" id="L192">            this.pager = pager;</span>
<span class="fc" id="L193">            this.pageSize = pageSize;</span>
<span class="fc" id="L194">            this.metadata = select.getResultMetadata().requestNames();</span>
<span class="fc" id="L195">        }</span>

        public int size()
        {
<span class="nc" id="L199">            throw new UnsupportedOperationException();</span>
        }

        public Row one()
        {
<span class="nc" id="L204">            throw new UnsupportedOperationException();</span>
        }

        public Iterator&lt;Row&gt; iterator()
        {
<span class="fc" id="L209">            return new AbstractIterator&lt;Row&gt;()</span>
<span class="fc" id="L210">            {</span>
                private Iterator&lt;List&lt;ByteBuffer&gt;&gt; currentPage;

                protected Row computeNext()
                {
<span class="fc" id="L215">                    long nowInSec = FBUtilities.nowInSeconds();</span>
<span class="fc bfc" id="L216" title="All 4 branches covered.">                    while (currentPage == null || !currentPage.hasNext())</span>
                    {
<span class="fc bfc" id="L218" title="All 2 branches covered.">                        if (pager.isExhausted())</span>
<span class="fc" id="L219">                            return endOfData();</span>

<span class="fc" id="L221">                        try (ReadExecutionController executionController = pager.executionController();</span>
<span class="fc" id="L222">                             PartitionIterator iter = pager.fetchPageInternal(pageSize, executionController))</span>
                        {
<span class="fc" id="L224">                            currentPage = select.process(iter, nowInSec, true).rows.iterator();</span>
                        }
                    }
<span class="fc" id="L227">                    return new Row(metadata, currentPage.next());</span>
                }
            };
        }

        public List&lt;ColumnSpecification&gt; metadata()
        {
<span class="nc" id="L234">            return metadata;</span>
        }
    }

    /**
     * Pager that calls `execute` rather than `executeInternal`
     */
    private static class FromDistributedPager extends UntypedResultSet
    {
        private final SelectStatement select;
        private final ConsistencyLevel cl;
        private final ClientState clientState;
        private final QueryPager pager;
        private final int pageSize;
        private final List&lt;ColumnSpecification&gt; metadata;

        private FromDistributedPager(SelectStatement select,
                                     ConsistencyLevel cl,
                                     ClientState clientState,
                                     QueryPager pager, int pageSize)
<span class="nc" id="L254">        {</span>
<span class="nc" id="L255">            this.select = select;</span>
<span class="nc" id="L256">            this.cl = cl;</span>
<span class="nc" id="L257">            this.clientState = clientState;</span>
<span class="nc" id="L258">            this.pager = pager;</span>
<span class="nc" id="L259">            this.pageSize = pageSize;</span>
<span class="nc" id="L260">            this.metadata = select.getResultMetadata().requestNames();</span>
<span class="nc" id="L261">        }</span>

        public int size()
        {
<span class="nc" id="L265">            throw new UnsupportedOperationException();</span>
        }

        public Row one()
        {
<span class="nc" id="L270">            throw new UnsupportedOperationException();</span>
        }

        public Iterator&lt;Row&gt; iterator()
        {
<span class="nc" id="L275">            return new AbstractIterator&lt;Row&gt;()</span>
<span class="nc" id="L276">            {</span>
                private Iterator&lt;List&lt;ByteBuffer&gt;&gt; currentPage;

                protected Row computeNext()
                {
<span class="nc" id="L281">                    long nowInSec = FBUtilities.nowInSeconds();</span>
<span class="nc bnc" id="L282" title="All 4 branches missed.">                    while (currentPage == null || !currentPage.hasNext())</span>
                    {
<span class="nc bnc" id="L284" title="All 2 branches missed.">                        if (pager.isExhausted())</span>
<span class="nc" id="L285">                            return endOfData();</span>

<span class="nc" id="L287">                        try (PartitionIterator iter = pager.fetchPage(pageSize, cl, clientState, nanoTime()))</span>
                        {
<span class="nc" id="L289">                            currentPage = select.process(iter, nowInSec, true).rows.iterator();</span>
                        }
                    }
<span class="nc" id="L292">                    return new Row(metadata, currentPage.next());</span>
                }
            };
        }

        public List&lt;ColumnSpecification&gt; metadata()
        {
<span class="nc" id="L299">            return metadata;</span>
        }
    }

    public static class Row
    {
<span class="pc" id="L305">        private final Map&lt;String, ByteBuffer&gt; data = new HashMap&lt;&gt;();</span>
<span class="pc" id="L306">        private final List&lt;ColumnSpecification&gt; columns = new ArrayList&lt;&gt;();</span>

        public Row(Map&lt;String, ByteBuffer&gt; data)
<span class="nc" id="L309">        {</span>
<span class="nc" id="L310">            this.data.putAll(data);</span>
<span class="nc" id="L311">        }</span>

        public Row(List&lt;ColumnSpecification&gt; names, List&lt;ByteBuffer&gt; columns)
<span class="fc" id="L314">        {</span>
<span class="fc" id="L315">            this.columns.addAll(names);</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">            for (int i = 0; i &lt; names.size(); i++)</span>
<span class="fc" id="L317">                data.put(names.get(i).name.toString(), columns.get(i));</span>
<span class="fc" id="L318">        }</span>

        public static Row fromInternalRow(TableMetadata metadata, DecoratedKey key, org.apache.cassandra.db.rows.Row row)
        {
<span class="nc" id="L322">            Map&lt;String, ByteBuffer&gt; data = new HashMap&lt;&gt;();</span>

<span class="nc" id="L324">            ByteBuffer[] keyComponents = SelectStatement.getComponents(metadata, key);</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">            for (ColumnMetadata def : metadata.partitionKeyColumns())</span>
<span class="nc" id="L326">                data.put(def.name.toString(), keyComponents[def.position()]);</span>

<span class="nc" id="L328">            Clustering&lt;?&gt; clustering = row.clustering();</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">            for (ColumnMetadata def : metadata.clusteringColumns())</span>
<span class="nc" id="L330">                data.put(def.name.toString(), clustering.bufferAt(def.position()));</span>

<span class="nc bnc" id="L332" title="All 2 branches missed.">            for (ColumnMetadata def : metadata.regularAndStaticColumns())</span>
            {
<span class="nc bnc" id="L334" title="All 2 branches missed.">                if (def.isSimple())</span>
                {
<span class="nc" id="L336">                    Cell&lt;?&gt; cell = row.getCell(def);</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">                    if (cell != null)</span>
<span class="nc" id="L338">                        data.put(def.name.toString(), cell.buffer());</span>
<span class="nc" id="L339">                }</span>
                else
                {
<span class="nc" id="L342">                    ComplexColumnData complexData = row.getComplexColumnData(def);</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">                    if (complexData != null)</span>
<span class="nc" id="L344">                        data.put(def.name.toString(), ((CollectionType&lt;?&gt;) def.type).serializeForNativeProtocol(complexData.iterator()));</span>
                }
<span class="nc" id="L346">            }</span>

<span class="nc" id="L348">            return new Row(data);</span>
        }

        public boolean has(String column)
        {
            // Note that containsKey won't work because we may have null values
<span class="fc bfc" id="L354" title="All 2 branches covered.">            return data.get(column) != null;</span>
        }

        public ByteBuffer getBlob(String column)
        {
<span class="nc" id="L359">            return data.get(column);</span>
        }

        public String getString(String column)
        {
<span class="fc" id="L364">            return UTF8Type.instance.compose(data.get(column));</span>
        }

        public boolean getBoolean(String column)
        {
<span class="fc" id="L369">            return BooleanType.instance.compose(data.get(column));</span>
        }

        public byte getByte(String column)
        {
<span class="nc" id="L374">            return ByteType.instance.compose(data.get(column));</span>
        }

        public short getShort(String column)
        {
<span class="nc" id="L379">            return ShortType.instance.compose(data.get(column));</span>
        }

        public int getInt(String column)
        {
<span class="fc" id="L384">            return Int32Type.instance.compose(data.get(column));</span>
        }

        public int getInt(String column, int ifNull)
        {
<span class="nc" id="L389">            ByteBuffer bytes = data.get(column);</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">            return bytes == null ? ifNull : Int32Type.instance.compose(bytes);</span>
        }

        public double getDouble(String column)
        {
<span class="fc" id="L395">            return DoubleType.instance.compose(data.get(column));</span>
        }

        public ByteBuffer getBytes(String column)
        {
<span class="fc" id="L400">            return data.get(column);</span>
        }

        public byte[] getByteArray(String column)
        {
<span class="nc" id="L405">            ByteBuffer buf = data.get(column);</span>
<span class="nc" id="L406">            byte[] arr = new byte[buf.remaining()];</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">            for (int i = 0; i &lt; arr.length; i++)</span>
<span class="nc" id="L408">                arr[i] = buf.get(buf.position() + i);</span>

<span class="nc" id="L410">            return arr;</span>
        }

        public InetAddress getInetAddress(String column)
        {
<span class="fc" id="L415">            return InetAddressType.instance.compose(data.get(column));</span>
        }

        public UUID getUUID(String column)
        {
<span class="fc" id="L420">            return UUIDType.instance.compose(data.get(column));</span>
        }

        public UUID getUUID(String column, UUID ifNull)
        {
<span class="nc" id="L425">            ByteBuffer bytes = data.get(column);</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">            return bytes == null ? ifNull : UUIDType.instance.compose(bytes);</span>
        }

        public TimeUUID getTimeUUID(String column)
        {
<span class="fc" id="L431">            return TimeUUID.deserialize(data.get(column));</span>
        }

        public Date getTimestamp(String column)
        {
<span class="fc" id="L436">            return TimestampType.instance.compose(data.get(column));</span>
        }

<span class="nc" id="L439">        public LocalDate getDate(String column) { return LocalDate.fromDaysSinceEpoch(CodecUtils.fromUnsignedToSignedInt(data.get(column).getInt()));}</span>

        public long getLong(String column)
        {
<span class="fc" id="L443">            return LongType.instance.compose(data.get(column));</span>
        }

        public &lt;T&gt; Set&lt;T&gt; getSet(String column, AbstractType&lt;T&gt; type)
        {
<span class="fc" id="L448">            ByteBuffer raw = data.get(column);</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">            return raw == null ? null : SetType.getInstance(type, true).compose(raw);</span>
        }

        public &lt;T&gt; List&lt;T&gt; getList(String column, AbstractType&lt;T&gt; type)
        {
<span class="fc" id="L454">            ByteBuffer raw = data.get(column);</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">            return raw == null ? null : ListType.getInstance(type, true).compose(raw);</span>
        }

        public &lt;K, V&gt; Map&lt;K, V&gt; getMap(String column, AbstractType&lt;K&gt; keyType, AbstractType&lt;V&gt; valueType)
        {
<span class="fc" id="L460">            ByteBuffer raw = data.get(column);</span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">            return raw == null ? null : MapType.getInstance(keyType, valueType, true).compose(raw);</span>
        }

        public &lt;T&gt; Set&lt;T&gt; getFrozenSet(String column, AbstractType&lt;T&gt; type)
        {
<span class="fc" id="L466">            ByteBuffer raw = data.get(column);</span>
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">            return raw == null ? null : SetType.getInstance(type, false).compose(raw);</span>
        }

        public &lt;T&gt; List&lt;T&gt; getFrozenList(String column, AbstractType&lt;T&gt; type)
        {
<span class="nc" id="L472">            ByteBuffer raw = data.get(column);</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">            return raw == null ? null : ListType.getInstance(type, false).compose(raw);</span>
        }

        public &lt;K, V&gt; Map&lt;K, V&gt; getFrozenMap(String column, AbstractType&lt;K&gt; keyType, AbstractType&lt;V&gt; valueType)
        {
<span class="fc" id="L478">            ByteBuffer raw = data.get(column);</span>
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">            return raw == null ? null : MapType.getInstance(keyType, valueType, false).compose(raw);</span>
        }

        public Map&lt;String, String&gt; getFrozenTextMap(String column)
        {
<span class="fc" id="L484">            return getFrozenMap(column, UTF8Type.instance, UTF8Type.instance);</span>
        }

        public &lt;T&gt; List&lt;T&gt; getVector(String column, AbstractType&lt;T&gt; elementType, int dimension)
        {
<span class="nc" id="L489">            ByteBuffer raw = data.get(column);</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">            return raw == null ? null : VectorType.getInstance(elementType, dimension).compose(raw);</span>
        }

        public List&lt;ColumnSpecification&gt; getColumns()
        {
<span class="nc" id="L495">            return columns;</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L501">            return data.toString();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>