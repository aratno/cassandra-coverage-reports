<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DecayingEstimatedHistogramReservoir.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.metrics</a> &gt; <span class="el_source">DecayingEstimatedHistogramReservoir.java</span></div><h1>DecayingEstimatedHistogramReservoir.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.metrics;

import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Objects;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLongArray;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.primitives.Ints;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.codahale.metrics.Reservoir;
import com.codahale.metrics.Snapshot;
import org.apache.cassandra.utils.EstimatedHistogram;
import org.apache.cassandra.utils.MonotonicClock;
import org.apache.cassandra.utils.NoSpamLogger;

import static java.lang.Math.max;
import static java.lang.Math.min;
import static org.apache.cassandra.config.CassandraRelevantProperties.DECAYING_ESTIMATED_HISTOGRAM_RESERVOIR_STRIPE_COUNT;

/**
 * A decaying histogram reservoir where values collected during each minute will be twice as significant as the values
 * collected in the previous minute. Measured values are collected in variable sized buckets, using small buckets in the
 * lower range and larger buckets in the upper range. Use this histogram when you want to know if the distribution of
 * the underlying data stream has changed recently and you want high resolution on values in the lower range.
 * &lt;p/&gt;
 * The histogram use forward decay [1] to make recent values more significant. The forward decay factor will be doubled
 * every minute (half-life time set to 60 seconds) [2]. The forward decay landmark is reset every 30 minutes (or at
 * first read/update after 30 minutes). During landmark reset, updates and reads in the reservoir will be blocked in a
 * fashion similar to the one used in the metrics library [3]. The 30 minute rescale interval is used based on the
 * assumption that in an extreme case we would have to collect a metric 1M times for a single bucket each second. By the
 * end of the 30:th minute all collected values will roughly add up to 1.000.000 * 60 * pow(2, 30) which can be
 * represented with 56 bits giving us some head room in a signed 64 bit long.
 * &lt;p/&gt;
 * Internally two reservoirs are maintained, one with decay and one without decay. All public getters in a {@link Snapshot}
 * will expose the decay functionality with the exception of the {@link Snapshot#getValues()} which will return values
 * from the reservoir without decay. This makes it possible for the caller to maintain precise deltas in an interval of
 * its choice.
 * &lt;p/&gt;
 * The bucket size starts at 1 and grows by 1.2 each time (rounding and removing duplicates). It goes from 1 to around
 * 18T by default (creating 164+1 buckets), which will give a timing resolution from microseconds to roughly 210 days,
 * with less precision as the numbers get larger.
 * &lt;p/&gt;
 * The series of values to which the counts in `decayingBuckets` correspond:
 * 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 17, 20, 24, 29, 35, 42, 50, 60, 72 etc.
 * Thus, a `decayingBuckets` of [0, 0, 1, 10] would mean we had seen 1 value of 3 and 10 values of 4.
 * &lt;p/&gt;
 * Each bucket represents values from (previous bucket offset, current offset].
 * &lt;p/&gt;
 * To reduce contention each logical bucket is striped accross a configurable number of stripes (default: 2). Threads are
 * assigned to specific stripes. In addition, logical buckets are distributed across the physical storage to reduce conention
 * when logically adjacent buckets are updated. See CASSANDRA-15213.
 * &lt;p/&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;[1]: http://dimacs.rutgers.edu/~graham/pubs/papers/fwddecay.pdf&lt;/li&gt;
 *   &lt;li&gt;[2]: https://en.wikipedia.org/wiki/Half-life&lt;/li&gt;
 *   &lt;li&gt;[3]: https://github.com/dropwizard/metrics/blob/v3.1.2/metrics-core/src/main/java/com/codahale/metrics/ExponentiallyDecayingReservoir.java&lt;/li&gt;
 * &lt;/ul&gt;
 */
public class DecayingEstimatedHistogramReservoir implements SnapshottingReservoir
{
<span class="fc" id="L88">    private static final Logger logger = LoggerFactory.getLogger(DecayingEstimatedHistogramReservoir.class);</span>
<span class="fc" id="L89">    private static final NoSpamLogger noSpamLogger = NoSpamLogger.getLogger(logger, 5L, TimeUnit.MINUTES);</span>
    /**
     * The default number of decayingBuckets. Use this bucket count to reduce memory allocation for bucket offsets.
     */
    public static final int DEFAULT_BUCKET_COUNT = 164;
    public static final int LOW_BUCKET_COUNT = 127;
<span class="fc" id="L95">    public static final int DEFAULT_STRIPE_COUNT = DECAYING_ESTIMATED_HISTOGRAM_RESERVOIR_STRIPE_COUNT.getInt();</span>
    public static final int MAX_BUCKET_COUNT = 237;
    public static final boolean DEFAULT_ZERO_CONSIDERATION = false;

<span class="fc" id="L99">    private static final int[] DISTRIBUTION_PRIMES = new int[] { 17, 19, 23, 29 };</span>

    // The offsets used with a default sized bucket array without a separate bucket for zero values.
<span class="fc" id="L102">    public static final long[] DEFAULT_WITHOUT_ZERO_BUCKET_OFFSETS = EstimatedHistogram.newOffsets(DEFAULT_BUCKET_COUNT, false);</span>

    // The offsets used with a default sized bucket array with a separate bucket for zero values.
<span class="fc" id="L105">    public static final long[] DEFAULT_WITH_ZERO_BUCKET_OFFSETS = EstimatedHistogram.newOffsets(DEFAULT_BUCKET_COUNT, true);</span>

    private static final int TABLE_BITS = 4;
    private static final int TABLE_MASK = -1 &gt;&gt;&gt; (32 - TABLE_BITS);
<span class="fc" id="L109">    private static final float[] LOG2_TABLE = computeTable(TABLE_BITS);</span>
<span class="fc" id="L110">    private static final float log2_12_recp = (float) (1d / slowLog2(1.2d));</span>

    private static float[] computeTable(int bits)
    {
<span class="fc" id="L114">        float[] table = new float[1 &lt;&lt; bits];</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">        for (int i = 1 ; i &lt; 1&lt;&lt;bits ; ++i)</span>
<span class="fc" id="L116">            table[i] = (float) slowLog2(ratio(i, bits));</span>
<span class="fc" id="L117">        return table;</span>
    }

    public static float fastLog12(long v)
    {
<span class="fc" id="L122">        return fastLog2(v) * log2_12_recp;</span>
    }

    // returns 0 for all inputs &lt;= 1
    private static float fastLog2(long v)
    {
<span class="fc" id="L128">        v = max(v, 1);</span>
<span class="fc" id="L129">        int highestBitPosition = 63 - Long.numberOfLeadingZeros(v);</span>
<span class="fc" id="L130">        v = Long.rotateRight(v, highestBitPosition - TABLE_BITS);</span>
<span class="fc" id="L131">        int index = (int) (v &amp; TABLE_MASK);</span>
<span class="fc" id="L132">        float result = LOG2_TABLE[index];</span>
<span class="fc" id="L133">        result += highestBitPosition;</span>
<span class="fc" id="L134">        return result;</span>
    }

    private static double slowLog2(double v)
    {
<span class="fc" id="L139">        return Math.log(v) / Math.log(2);</span>
    }

    private static double ratio(int i, int bits)
    {
<span class="fc" id="L144">        return Float.intBitsToFloat((127 &lt;&lt; 23) | (i &lt;&lt; (23 - bits)));</span>
    }

    // Represents the bucket offset as created by {@link EstimatedHistogram#newOffsets()}
    private final int nStripes;
    private final long[] bucketOffsets;
    private final int distributionPrime;

    // decayingBuckets and buckets are one element longer than bucketOffsets -- the last element is values greater than the last offset
    private final AtomicLongArray decayingBuckets;
    private final AtomicLongArray buckets;

    public static final long HALF_TIME_IN_S = 60L;
<span class="fc" id="L157">    public static final double MEAN_LIFETIME_IN_S = HALF_TIME_IN_S / Math.log(2.0);</span>
<span class="fc" id="L158">    public static final long LANDMARK_RESET_INTERVAL_IN_NS = TimeUnit.MINUTES.toNanos(30L);</span>

<span class="fc" id="L160">    private final AtomicBoolean rescaling = new AtomicBoolean(false);</span>
    private volatile long decayLandmark;

    // Wrapper around System.nanoTime() to simplify unit testing.
    private final MonotonicClock clock;

    /**
     * Construct a decaying histogram with default number of buckets and without considering zeroes.
     */
    public DecayingEstimatedHistogramReservoir()
    {
<span class="nc" id="L171">        this(DEFAULT_ZERO_CONSIDERATION, DEFAULT_BUCKET_COUNT, DEFAULT_STRIPE_COUNT, MonotonicClock.Global.approxTime);</span>
<span class="nc" id="L172">    }</span>

    /**
     * Construct a decaying histogram with default number of buckets.
     *
     * @param considerZeroes when true, 0-value measurements in a separate bucket, otherwise they will be collected in
     *                       same bucket as 1-value measurements
     */
    public DecayingEstimatedHistogramReservoir(boolean considerZeroes)
    {
<span class="fc" id="L182">        this(considerZeroes, DEFAULT_BUCKET_COUNT, DEFAULT_STRIPE_COUNT, MonotonicClock.Global.approxTime);</span>
<span class="fc" id="L183">    }</span>

    /**
     * Construct a decaying histogram.
     *
     * @param considerZeroes when true, 0-value measurements in a separate bucket, otherwise they will be collected in
     *                       same bucket as 1-value measurements
     * @param bucketCount number of buckets used to collect measured values
     */
    public DecayingEstimatedHistogramReservoir(boolean considerZeroes, int bucketCount, int stripes)
    {
<span class="fc" id="L194">        this(considerZeroes, bucketCount, stripes, MonotonicClock.Global.approxTime);</span>
<span class="fc" id="L195">    }</span>

    @VisibleForTesting
    public DecayingEstimatedHistogramReservoir(MonotonicClock clock)
    {
<span class="nc" id="L200">        this(DEFAULT_ZERO_CONSIDERATION, DEFAULT_BUCKET_COUNT, DEFAULT_STRIPE_COUNT, clock);</span>
<span class="nc" id="L201">    }</span>

    @VisibleForTesting
    DecayingEstimatedHistogramReservoir(boolean considerZeroes, int bucketCount, int stripes, MonotonicClock clock)
<span class="fc" id="L205">    {</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">        assert bucketCount &lt;= MAX_BUCKET_COUNT : &quot;bucket count cannot exceed: &quot; + MAX_BUCKET_COUNT;</span>

<span class="fc bfc" id="L208" title="All 2 branches covered.">        if (bucketCount == DEFAULT_BUCKET_COUNT)</span>
        {
<span class="fc bfc" id="L210" title="All 2 branches covered.">            if (considerZeroes == true)</span>
            {
<span class="fc" id="L212">                bucketOffsets = DEFAULT_WITH_ZERO_BUCKET_OFFSETS;</span>
            }
            else
            {
<span class="fc" id="L216">                bucketOffsets = DEFAULT_WITHOUT_ZERO_BUCKET_OFFSETS;</span>
            }
        }
        else
        {
<span class="fc" id="L221">            bucketOffsets = EstimatedHistogram.newOffsets(bucketCount, considerZeroes);</span>
        }

<span class="fc" id="L224">        nStripes = stripes;</span>
<span class="fc" id="L225">        decayingBuckets = new AtomicLongArray((bucketOffsets.length + 1) * nStripes);</span>
<span class="fc" id="L226">        buckets = new AtomicLongArray((bucketOffsets.length + 1) * nStripes);</span>
<span class="fc" id="L227">        this.clock = clock;</span>
<span class="fc" id="L228">        decayLandmark = clock.now();</span>
<span class="fc" id="L229">        int distributionPrime = 1;</span>
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">        for (int prime : DISTRIBUTION_PRIMES)</span>
        {
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">            if (buckets.length() % prime != 0)</span>
            {
<span class="fc" id="L234">                distributionPrime = prime;</span>
<span class="fc" id="L235">                break;</span>
            }
        }
<span class="fc" id="L238">        this.distributionPrime = distributionPrime;</span>
<span class="fc" id="L239">    }</span>

    /**
     * Increments the count of the bucket closest to n, rounding UP.
     *
     * @param value the data point to add to the histogram
     */
    public void update(long value)
    {
<span class="fc" id="L248">        long now = clock.now();</span>
<span class="fc" id="L249">        rescaleIfNeeded(now);</span>

<span class="fc" id="L251">        int index = findIndex(bucketOffsets, value);</span>

<span class="fc" id="L253">        updateBucket(decayingBuckets, index, Math.round(forwardDecayWeight(now)));</span>
<span class="fc" id="L254">        updateBucket(buckets, index, 1);</span>
<span class="fc" id="L255">    }</span>

    public void updateBucket(AtomicLongArray buckets, int index, long value)
    {
<span class="fc" id="L259">        int stripe = (int) (Thread.currentThread().getId() &amp; (nStripes - 1));</span>
<span class="fc" id="L260">        buckets.addAndGet(stripedIndex(index, stripe), value);</span>
<span class="fc" id="L261">    }</span>

    public int stripedIndex(int offsetIndex, int stripe)
    {
<span class="fc" id="L265">        return (((offsetIndex * nStripes + stripe) * distributionPrime) % buckets.length());</span>
    }

    @VisibleForTesting
    public static int findIndex(long[] bucketOffsets, long value)
    {
        // values below zero are nonsense, but we have never failed when presented them
<span class="fc" id="L272">        value = max(value, 0);</span>

        // The bucket index can be estimated using the equation Math.floor(Math.log(value) / Math.log(1.2))

        // By using an integer domain we effectively squeeze multiple exponents of 1.2 into the same bucket,
        // so for values &gt; 2, we must &quot;subtract&quot; these exponents from the logarithm to determine which two buckets
        // to consult (as our approximation otherwise produces a value that is within 1 of the true value)
<span class="fc bfc" id="L279" title="All 2 branches covered.">        int offset = (value &gt; 2 ? 3 : 1) + (int)bucketOffsets[0];</span>

        // See DecayingEstimatedHistogramResevoirTest#showEstimationWorks and DecayingEstimatedHistogramResevoirTest#testFindIndex()
        // for a runnable &quot;proof&quot;
        //
        // With this assumption, the estimate is calculated and the furthest offset from the estimation is checked
        // if this bucket does not contain the value then the next one will

<span class="fc" id="L287">        int firstCandidate = max(0, min(bucketOffsets.length - 1, ((int) fastLog12(value)) - offset));</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">        return value &lt;= bucketOffsets[firstCandidate] ? firstCandidate : firstCandidate + 1;</span>
    }

    private double forwardDecayWeight(long now)
    {
<span class="fc" id="L293">        return Math.exp(TimeUnit.NANOSECONDS.toSeconds(now - decayLandmark) / MEAN_LIFETIME_IN_S);</span>
    }

    /**
     * Returns the logical number of buckets where recorded values are stored. The actual number of physical buckets
     * is size() * stripeCount()
     *
     * This method does not return the number of recorded values as suggested by the {@link Reservoir} interface.
     *
     * @return the number of buckets
     * @see #stripeCount()
     */
    public int size()
    {
<span class="fc" id="L307">        return bucketOffsets.length + 1;</span>
    }


    public int stripeCount()
    {
<span class="nc" id="L313">        return nStripes;</span>
    }
    /**
     * Returns a snapshot of the decaying values in this reservoir.
     *
     * Non-decaying reservoir will not be included in the snapshot.
     *
     * @return the snapshot
     */
    @Override
    public Snapshot getSnapshot()
    {
<span class="fc" id="L325">        rescaleIfNeeded();</span>
<span class="fc" id="L326">        return new EstimatedHistogramReservoirSnapshot(this);</span>
    }

    @Override
    public Snapshot getPercentileSnapshot()
    {
<span class="fc" id="L332">        rescaleIfNeeded();</span>
<span class="fc" id="L333">        return new DecayingBucketsOnlySnapshot(this);</span>
    }

    /**
     * @return true if this histogram has overflowed -- that is, a value larger than our largest bucket could bound was added
     */
    @VisibleForTesting
    boolean isOverflowed()
    {
<span class="nc bnc" id="L342" title="All 2 branches missed.">        return bucketValue(bucketOffsets.length, true) &gt; 0;</span>
    }

    private long bucketValue(int index, boolean withDecay)
    {
<span class="fc" id="L347">        long val = 0;</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">        AtomicLongArray bs = withDecay ? decayingBuckets : buckets;</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">        for (int stripe = 0; stripe &lt; nStripes; stripe++)</span>
<span class="fc" id="L350">            val += bs.get(stripedIndex(index, stripe));</span>

<span class="fc" id="L352">        return val;</span>
    }

    @VisibleForTesting
    long stripedBucketValue(int i, boolean withDecay)
    {
<span class="nc bnc" id="L358" title="All 2 branches missed.">        return withDecay ? decayingBuckets.get(i) : buckets.get(i);</span>
    }

    private void rescaleIfNeeded()
    {
<span class="fc" id="L363">        rescaleIfNeeded(clock.now());</span>
<span class="fc" id="L364">    }</span>

    private void rescaleIfNeeded(long now)
    {
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">        if (needRescale(now))</span>
        {
<span class="nc bnc" id="L370" title="All 2 branches missed.">            if (rescaling.compareAndSet(false, true))</span>
            {
                try
                {
<span class="nc" id="L374">                    rescale(now);</span>
                }
                finally
                {
<span class="nc" id="L378">                    decayLandmark = now;</span>
<span class="nc" id="L379">                    rescaling.set(false);</span>
                }
            }
        }
<span class="fc" id="L383">    }</span>

    private void rescale(long now)
    {
        // despite striping its safe to rescale each bucket individually
<span class="nc" id="L388">        final double rescaleFactor = forwardDecayWeight(now);</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">        for (int i = 0; i &lt; decayingBuckets.length(); i++)</span>
        {
<span class="nc" id="L391">            long newValue = Math.round(decayingBuckets.get(i) / rescaleFactor);</span>
<span class="nc" id="L392">            decayingBuckets.set(i, newValue);</span>
        }
<span class="nc" id="L394">    }</span>

    private boolean needRescale(long now)
    {
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">        return (now - decayLandmark) &gt; LANDMARK_RESET_INTERVAL_IN_NS;</span>
    }

    @VisibleForTesting
    public void clear()
    {
<span class="nc" id="L404">        final int bucketCount = decayingBuckets.length();</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">        for (int i = 0; i &lt; bucketCount; i++)</span>
        {
<span class="nc" id="L407">            decayingBuckets.set(i, 0L);</span>
<span class="nc" id="L408">            buckets.set(i, 0L);</span>
        }
<span class="nc" id="L410">    }</span>

    /**
     * Replaces current internal values with the given one from a Snapshot. This method is NOT thread safe, values
     * added at the same time to this reservoir using methods such as update may lose their data
     */
    public void rebase(EstimatedHistogramReservoirSnapshot snapshot)
    {
        // Check bucket count (a snapshot always has one stripe so the logical bucket count is used
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">        if (size() != snapshot.decayingBuckets.length)</span>
        {
<span class="nc" id="L421">            throw new IllegalStateException(&quot;Unable to merge two DecayingEstimatedHistogramReservoirs with different bucket sizes&quot;);</span>
        }

        // Check bucketOffsets
<span class="fc bfc" id="L425" title="All 2 branches covered.">        for (int i = 0; i &lt; bucketOffsets.length; i++)</span>
        {
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">            if (bucketOffsets[i] != snapshot.bucketOffsets[i])</span>
            {
<span class="nc" id="L429">                throw new IllegalStateException(&quot;Merge is only supported with equal bucketOffsets&quot;);</span>
            }
        }

<span class="fc" id="L433">        this.decayLandmark = snapshot.snapshotLandmark;</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">        for (int i = 0; i &lt; size(); i++)</span>
        {
            // set rebased values in the first stripe and clear out all other data
<span class="fc" id="L437">            decayingBuckets.set(stripedIndex(i, 0), snapshot.decayingBuckets[i]);</span>
<span class="fc" id="L438">            buckets.set(stripedIndex(i, 0), snapshot.values[i]);</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">            for (int stripe = 1; stripe &lt; nStripes; stripe++)</span>
            {
<span class="fc" id="L441">                decayingBuckets.set(stripedIndex(i, stripe), 0);</span>
<span class="fc" id="L442">                buckets.set(stripedIndex(i, stripe), 0);</span>
            }
        }

<span class="fc" id="L446">    }</span>

<span class="fc" id="L448">    private static abstract class AbstractSnapshot extends Snapshot</span>
    {
        protected final long[] decayingBuckets;
        protected final long[] bucketOffsets;

        AbstractSnapshot(DecayingEstimatedHistogramReservoir reservoir)
<span class="fc" id="L454">        {</span>
<span class="fc" id="L455">            int length = reservoir.size();</span>
<span class="fc" id="L456">            this.decayingBuckets = new long[length];</span>
<span class="fc" id="L457">            this.bucketOffsets = reservoir.bucketOffsets; // No need to copy, these are immutable</span>
<span class="fc" id="L458">        }</span>

        /**
         * Get the estimated value at the specified quantile in the distribution.
         *
         * @param quantile the quantile specified as a value between 0.0 (zero) and 1.0 (one)
         * @return estimated value at given quantile
         * @throws IllegalStateException in case the histogram overflowed
         */
        @Override
        public double getValue(double quantile)
        {
<span class="pc bpc" id="L470" title="2 of 4 branches missed.">            assert quantile &gt;= 0 &amp;&amp; quantile &lt;= 1.0;</span>

<span class="fc" id="L472">            final int lastBucket = decayingBuckets.length - 1;</span>

<span class="pc bpc" id="L474" title="1 of 2 branches missed.">            if (decayingBuckets[lastBucket] &gt; 0)</span>
            {
<span class="nc" id="L476">                try { throw new IllegalStateException(&quot;EstimatedHistogram overflow: &quot; + Arrays.toString(decayingBuckets)); }</span>
<span class="nc" id="L477">                catch (IllegalStateException e) { noSpamLogger.warn(&quot;&quot;, e); }</span>
            }

<span class="fc" id="L480">            final long qcount = (long) Math.ceil(count() * quantile);</span>
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">            if (qcount == 0)</span>
<span class="nc" id="L482">                return 0;</span>

<span class="fc" id="L484">            long elements = 0;</span>
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">            for (int i = 0; i &lt; lastBucket; i++)</span>
            {
<span class="fc" id="L487">                elements += decayingBuckets[i];</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">                if (elements &gt;= qcount)</span>
<span class="fc" id="L489">                    return bucketOffsets[i];</span>
            }
<span class="nc" id="L491">            return 0;</span>
        }

        /**
         * Return the number of registered values taking forward decay into account.
         *
         * @return the sum of all bucket values
         */
        protected long count()
        {
<span class="fc" id="L501">            long sum = 0L;</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">            for (int i = 0; i &lt; decayingBuckets.length; i++)</span>
<span class="fc" id="L503">                sum += decayingBuckets[i];</span>
<span class="fc" id="L504">            return sum;</span>
        }

        /**
         * Get the estimated max-value that could have been added to this reservoir.
         *
         * As values are collected in variable sized buckets, the actual max value recorded in the reservoir may be less
         * than the value returned.
         *
         * @return the largest value that could have been added to this reservoir, or Long.MAX_VALUE if the reservoir
         * overflowed
         */
        @Override
        public long getMax()
        {
<span class="nc" id="L519">            final int lastBucket = decayingBuckets.length - 1;</span>

<span class="nc bnc" id="L521" title="All 2 branches missed.">            if (decayingBuckets[lastBucket] &gt; 0)</span>
<span class="nc" id="L522">                return Long.MAX_VALUE;</span>

<span class="nc bnc" id="L524" title="All 2 branches missed.">            for (int i = lastBucket - 1; i &gt;= 0; i--)</span>
            {
<span class="nc bnc" id="L526" title="All 2 branches missed.">                if (decayingBuckets[i] &gt; 0)</span>
<span class="nc" id="L527">                    return bucketOffsets[i];</span>
            }
<span class="nc" id="L529">            return 0;</span>
        }

        /**
         * Get the estimated mean value in the distribution.
         *
         * @return the mean histogram value (average of bucket offsets, weighted by count)
         * @throws IllegalStateException if any values were greater than the largest bucket threshold
         */
        @Override
        public double getMean()
        {
<span class="nc" id="L541">            final int lastBucket = decayingBuckets.length - 1;</span>

<span class="nc bnc" id="L543" title="All 2 branches missed.">            if (decayingBuckets[lastBucket] &gt; 0)</span>
<span class="nc" id="L544">                throw new IllegalStateException(&quot;Unable to compute when histogram overflowed&quot;);</span>

<span class="nc" id="L546">            long elements = 0;</span>
<span class="nc" id="L547">            long sum = 0;</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">            for (int i = 0; i &lt; lastBucket; i++)</span>
            {
<span class="nc" id="L550">                long bCount = decayingBuckets[i];</span>
<span class="nc" id="L551">                elements += bCount;</span>
<span class="nc" id="L552">                sum += bCount * bucketOffsets[i];</span>
            }

<span class="nc" id="L555">            return (double) sum / elements;</span>
        }

        /**
         * Get the estimated min-value that could have been added to this reservoir.
         *
         * As values are collected in variable sized buckets, the actual min value recorded in the reservoir may be
         * higher than the value returned.
         *
         * @return the smallest value that could have been added to this reservoir
         */
        @Override
        public long getMin()
        {
<span class="nc bnc" id="L569" title="All 2 branches missed.">            for (int i = 0; i &lt; decayingBuckets.length; i++)</span>
            {
<span class="nc bnc" id="L571" title="All 2 branches missed.">                if (decayingBuckets[i] &gt; 0)</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">                    return i == 0 ? 0 : 1 + bucketOffsets[i - 1];</span>
            }
<span class="nc" id="L574">            return 0;</span>
        }

        /**
         * Get the estimated standard deviation of the values added to this reservoir.
         *
         * As values are collected in variable sized buckets, the actual deviation may be more or less than the value
         * returned.
         *
         * @return an estimate of the standard deviation
         */
        @Override
        public double getStdDev()
        {
<span class="nc" id="L588">            final int lastBucket = decayingBuckets.length - 1;</span>

<span class="nc bnc" id="L590" title="All 2 branches missed.">            if (decayingBuckets[lastBucket] &gt; 0)</span>
<span class="nc" id="L591">                throw new IllegalStateException(&quot;Unable to compute when histogram overflowed&quot;);</span>

<span class="nc" id="L593">            final long count = count();</span>

<span class="nc bnc" id="L595" title="All 2 branches missed.">            if(count &lt;= 1)</span>
            {
<span class="nc" id="L597">                return 0.0D;</span>
            }
            else
            {
<span class="nc" id="L601">                double mean = this.getMean();</span>
<span class="nc" id="L602">                double sum = 0.0D;</span>

<span class="nc bnc" id="L604" title="All 2 branches missed.">                for(int i = 0; i &lt; lastBucket; ++i)</span>
                {
<span class="nc" id="L606">                    long value = bucketOffsets[i];</span>
<span class="nc" id="L607">                    double diff = value - mean;</span>
<span class="nc" id="L608">                    sum += diff * diff * decayingBuckets[i];</span>
                }

<span class="nc" id="L611">                return Math.sqrt(sum / (count - 1));</span>
            }
        }

        @Override
        public void dump(OutputStream output)
        {
<span class="nc" id="L618">            try (PrintWriter out = new PrintWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8)))</span>
            {
<span class="nc" id="L620">                int length = decayingBuckets.length;</span>

<span class="nc bnc" id="L622" title="All 2 branches missed.">                for(int i = 0; i &lt; length; ++i)</span>
                {
<span class="nc" id="L624">                    out.printf(&quot;%d%n&quot;, decayingBuckets[i]);</span>
                }
            }
<span class="nc" id="L627">        }</span>
    }

    /**
     * Represents a snapshot of the decaying histogram.
     *
     * The decaying buckets are copied into a snapshot array to give a consistent view for all getters. However, the
     * copy is made without a write-lock and so other threads may change the buckets while the array is copied,
     * probably causing a slight skew up in the quantiles and mean values.
     *
     * The decaying buckets will be used for quantile calculations and mean values, but the non decaying buckets will be
     * exposed for calls to {@link Snapshot#getValues()}.
     */
    static class EstimatedHistogramReservoirSnapshot extends AbstractSnapshot
    {
        private final long[] values;
        private long count;
        private long snapshotLandmark;
        private final DecayingEstimatedHistogramReservoir reservoir;

        public EstimatedHistogramReservoirSnapshot(DecayingEstimatedHistogramReservoir reservoir)
        {
<span class="fc" id="L649">            super(reservoir);</span>
            
<span class="fc" id="L651">            int length = reservoir.size();</span>
<span class="fc" id="L652">            double rescaleFactor = reservoir.forwardDecayWeight(reservoir.clock.now());</span>

<span class="fc" id="L654">            this.values = new long[length];</span>
<span class="fc" id="L655">            this.snapshotLandmark = reservoir.decayLandmark;</span>

<span class="fc bfc" id="L657" title="All 2 branches covered.">            for (int i = 0; i &lt; length; i++)</span>
            {
<span class="fc" id="L659">                this.decayingBuckets[i] = Math.round(reservoir.bucketValue(i, true) / rescaleFactor);</span>
<span class="fc" id="L660">                this.values[i] = reservoir.bucketValue(i, false);</span>
            }
<span class="fc" id="L662">            this.count = count();</span>
<span class="fc" id="L663">            this.reservoir = reservoir;</span>
<span class="fc" id="L664">        }</span>

        /**
         * Will return a snapshot of the non-decaying buckets.
         *
         * The values returned will not be consistent with the quantile and mean values. The caller must be aware of the
         * offsets created by {@link EstimatedHistogram#getBucketOffsets()} to make use of the values returned.
         *
         * @return a snapshot of the non-decaying buckets.
         */
        public long[] getValues()
        {
<span class="nc" id="L676">            return values;</span>
        }

        @Override
        public int size()
        {
<span class="nc" id="L682">            return Ints.saturatedCast(count);</span>
        }

        @VisibleForTesting
        public long getSnapshotLandmark()
        {
<span class="nc" id="L688">            return snapshotLandmark;</span>
        }

        @VisibleForTesting
        public Range getBucketingRangeForValue(long value)
        {
<span class="nc" id="L694">            int index = findIndex(bucketOffsets, value);</span>
<span class="nc" id="L695">            long max = bucketOffsets[index];</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">            long min = index == 0 ? 0 : 1 + bucketOffsets[index - 1];</span>
<span class="nc" id="L697">            return new Range(min, max);</span>
        }

        /**
         * Adds another DecayingEstimatedHistogramReservoir's Snapshot to this one. Both reservoirs must have same bucket definitions. This will rescale both snapshots if needed.
         *
         * @param other EstimatedHistogramReservoirSnapshot with identical bucket definition (offsets and length)
         */
        public void add(Snapshot other)
        {
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">            if (!(other instanceof EstimatedHistogramReservoirSnapshot))</span>
            {
<span class="nc" id="L709">                throw new IllegalStateException(&quot;Unable to add other types of Snapshot than another DecayingEstimatedHistogramReservoir&quot;);</span>
            }

<span class="fc" id="L712">            EstimatedHistogramReservoirSnapshot snapshot = (EstimatedHistogramReservoirSnapshot) other;</span>

<span class="pc bpc" id="L714" title="1 of 2 branches missed.">            if (decayingBuckets.length != snapshot.decayingBuckets.length)</span>
            {
<span class="nc" id="L716">                throw new IllegalStateException(&quot;Unable to merge two DecayingEstimatedHistogramReservoirs with different bucket sizes&quot;);</span>
            }

            // Check bucketOffsets
<span class="fc bfc" id="L720" title="All 2 branches covered.">            for (int i = 0; i &lt; bucketOffsets.length; i++)</span>
            {
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">                if (bucketOffsets[i] != snapshot.bucketOffsets[i])</span>
                {
<span class="nc" id="L724">                    throw new IllegalStateException(&quot;Merge is only supported with equal bucketOffsets&quot;);</span>
                }
            }

            // We need to rescale the reservoirs to the same landmark
<span class="fc bfc" id="L729" title="All 2 branches covered.">            if (snapshot.snapshotLandmark &lt; snapshotLandmark)</span>
            {
<span class="fc" id="L731">                rescaleArray(snapshot.decayingBuckets, (snapshotLandmark - snapshot.snapshotLandmark));</span>
            }
<span class="fc bfc" id="L733" title="All 2 branches covered.">            else if (snapshot.snapshotLandmark &gt; snapshotLandmark)</span>
            {
<span class="fc" id="L735">                rescaleArray(decayingBuckets, (snapshot.snapshotLandmark - snapshotLandmark));</span>
<span class="fc" id="L736">                this.snapshotLandmark = snapshot.snapshotLandmark;</span>
            }

            // Now merge the buckets
<span class="fc bfc" id="L740" title="All 2 branches covered.">            for (int i = 0; i &lt; snapshot.decayingBuckets.length; i++)</span>
            {
<span class="fc" id="L742">                decayingBuckets[i] += snapshot.decayingBuckets[i];</span>
<span class="fc" id="L743">                values[i] += snapshot.values[i];</span>
            }

<span class="fc" id="L746">            this.count += snapshot.count;</span>
<span class="fc" id="L747">        }</span>

        private void rescaleArray(long[] decayingBuckets, long landMarkDifference)
        {
<span class="fc" id="L751">            final double rescaleFactor = Math.exp((landMarkDifference / 1000.0) / MEAN_LIFETIME_IN_S);</span>
<span class="fc bfc" id="L752" title="All 2 branches covered.">            for (int i = 0; i &lt; decayingBuckets.length; i++)</span>
            {
<span class="fc" id="L754">                decayingBuckets[i] = Math.round(decayingBuckets[i] / rescaleFactor);</span>
            }
<span class="fc" id="L756">        }</span>

        public void rebaseReservoir()
        {
<span class="fc" id="L760">            this.reservoir.rebase(this);</span>
<span class="fc" id="L761">        }</span>
    }

    /**
     * Like {@link EstimatedHistogramReservoirSnapshot}, represents a snapshot of a given histogram reservoir.
     * 
     * Unlike {@link EstimatedHistogramReservoirSnapshot}, this only copies and supports operations based on the
     * decaying buckets from the source reservoir. (ex. percentiles, min, max) It also does not support snapshot 
     * merging or rebasing on the source reservoir.
     */
    private static class DecayingBucketsOnlySnapshot extends AbstractSnapshot
    {
        private final long count;

        public DecayingBucketsOnlySnapshot(DecayingEstimatedHistogramReservoir reservoir)
        {
<span class="fc" id="L777">            super(reservoir);</span>

<span class="fc" id="L779">            int length = reservoir.size();</span>
<span class="fc" id="L780">            double rescaleFactor = reservoir.forwardDecayWeight(reservoir.clock.now());</span>

<span class="fc bfc" id="L782" title="All 2 branches covered.">            for (int i = 0; i &lt; length; i++)</span>
            {
<span class="fc" id="L784">                this.decayingBuckets[i] = Math.round(reservoir.bucketValue(i, true) / rescaleFactor);</span>
            }

<span class="fc" id="L787">            this.count = count();</span>
<span class="fc" id="L788">        }</span>

        @Override
        public long[] getValues()
        {
<span class="nc" id="L793">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public int size()
        {
<span class="fc" id="L799">            return Ints.saturatedCast(count);</span>
        }
    }

    static class Range
    {
        public final long min;
        public final long max;

        public Range(long min, long max)
<span class="nc" id="L809">        {</span>
<span class="nc" id="L810">            this.min = min;</span>
<span class="nc" id="L811">            this.max = max;</span>
<span class="nc" id="L812">        }</span>

        public boolean equals(Object o)
        {
<span class="nc bnc" id="L816" title="All 2 branches missed.">            if (this == o) return true;</span>
<span class="nc bnc" id="L817" title="All 4 branches missed.">            if (o == null || getClass() != o.getClass()) return false;</span>
<span class="nc" id="L818">            Range that = (Range) o;</span>
<span class="nc bnc" id="L819" title="All 4 branches missed.">            return min == that.min &amp;&amp;</span>
                   max == that.max;
        }

        public int hashCode()
        {
<span class="nc" id="L825">            return Objects.hash(min, max);</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L831">            return &quot;[&quot; + min + ',' + max + ']';</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>