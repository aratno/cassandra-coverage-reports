<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractBTreePartition.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.partitions</a> &gt; <span class="el_source">AbstractBTreePartition.java</span></div><h1>AbstractBTreePartition.java</h1><pre class="source lang-java linenums">/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* &quot;License&quot;); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
package org.apache.cassandra.db.partitions;

import java.util.Collections;
import java.util.Iterator;
import java.util.NavigableSet;

import com.google.common.collect.Iterators;

import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.db.*;
import org.apache.cassandra.db.filter.ColumnFilter;
import org.apache.cassandra.db.rows.*;
import org.apache.cassandra.utils.SearchIterator;
import org.apache.cassandra.utils.btree.BTree;

import static org.apache.cassandra.utils.btree.BTree.Dir.desc;

public abstract class AbstractBTreePartition implements Partition, Iterable&lt;Row&gt;
{
    protected final DecoratedKey partitionKey;

    protected abstract BTreePartitionData holder();
    protected abstract boolean canHaveShadowedData();

    protected AbstractBTreePartition(DecoratedKey partitionKey)
<span class="fc" id="L44">    {</span>
<span class="fc" id="L45">        this.partitionKey = partitionKey;</span>
<span class="fc" id="L46">    }</span>

    public DeletionInfo deletionInfo()
    {
<span class="fc" id="L50">        return holder().deletionInfo;</span>
    }

    public Row staticRow()
    {
<span class="fc" id="L55">        return holder().staticRow;</span>
    }

    public boolean isEmpty()
    {
<span class="fc" id="L60">        BTreePartitionData holder = holder();</span>
<span class="fc bfc" id="L61" title="All 6 branches covered.">        return holder.deletionInfo.isLive() &amp;&amp; BTree.isEmpty(holder.tree) &amp;&amp; holder.staticRow.isEmpty();</span>
    }

    public boolean hasRows()
    {
<span class="fc" id="L66">        BTreePartitionData holder = holder();</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">        return !BTree.isEmpty(holder.tree);</span>
    }

    public abstract TableMetadata metadata();

    public DecoratedKey partitionKey()
    {
<span class="fc" id="L74">        return partitionKey;</span>
    }

    public DeletionTime partitionLevelDeletion()
    {
<span class="fc" id="L79">        return deletionInfo().getPartitionDeletion();</span>
    }

    public RegularAndStaticColumns columns()
    {
<span class="fc" id="L84">        return holder().columns;</span>
    }

    public EncodingStats stats()
    {
<span class="fc" id="L89">        return holder().stats;</span>
    }

    public Row getRow(Clustering&lt;?&gt; clustering)
    {
<span class="fc" id="L94">        ColumnFilter columns = ColumnFilter.selection(columns());</span>
<span class="fc" id="L95">        BTreePartitionData holder = holder();</span>

<span class="fc bfc" id="L97" title="All 2 branches covered.">        if (clustering == Clustering.STATIC_CLUSTERING)</span>
        {
            // Note that for statics, this will never return null, this will return an empty row. However,
            // it's more consistent for this method to return null if we don't really have a static row.
<span class="fc" id="L101">            Row staticRow = staticRow(holder, columns, true);</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">            return staticRow.isEmpty() ? null : staticRow;</span>
        }

<span class="fc" id="L105">        final Row row = (Row) BTree.find(holder.tree, metadata().comparator, clustering);</span>
<span class="fc" id="L106">        DeletionTime activeDeletion = holder.deletionInfo.getPartitionDeletion();</span>
<span class="fc" id="L107">        RangeTombstone rt = holder.deletionInfo.rangeCovering(clustering);</span>

<span class="pc bpc" id="L109" title="1 of 4 branches missed.">        if (rt != null &amp;&amp; rt.deletionTime().supersedes(activeDeletion))</span>
<span class="fc" id="L110">            activeDeletion = rt.deletionTime();</span>


<span class="fc bfc" id="L113" title="All 2 branches covered.">        if (row == null)</span>
        {
            // this means our partition level deletion supersedes all other deletions and we don't have to keep the row deletions
<span class="fc bfc" id="L116" title="All 2 branches covered.">            if (activeDeletion == holder.deletionInfo.getPartitionDeletion())</span>
<span class="fc" id="L117">                return null;</span>
            // no need to check activeDeletion.isLive here - if anything superseedes the partitionDeletion
            // it must be non-live
<span class="fc" id="L120">            return BTreeRow.emptyDeletedRow(clustering, Row.Deletion.regular(activeDeletion));</span>
        }
<span class="fc" id="L122">        return row.filter(columns, activeDeletion, true, metadata());</span>
    }

    private Row staticRow(BTreePartitionData current, ColumnFilter columns, boolean setActiveDeletionToRow)
    {
<span class="fc" id="L127">        DeletionTime partitionDeletion = current.deletionInfo.getPartitionDeletion();</span>
<span class="fc bfc" id="L128" title="All 6 branches covered.">        if (columns.fetchedColumns().statics.isEmpty() || (current.staticRow.isEmpty() &amp;&amp; partitionDeletion.isLive()))</span>
<span class="fc" id="L129">            return Rows.EMPTY_STATIC_ROW;</span>

<span class="fc" id="L131">        Row row = current.staticRow.filter(columns, partitionDeletion, setActiveDeletionToRow, metadata());</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">        return row == null ? Rows.EMPTY_STATIC_ROW : row;</span>
    }

    @Override
    public UnfilteredRowIterator unfilteredIterator(ColumnFilter selection, NavigableSet&lt;Clustering&lt;?&gt;&gt; clusteringsInQueryOrder, boolean reversed)
    {
<span class="fc" id="L138">        Row staticRow = staticRow(holder(), selection, false);</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">        if (clusteringsInQueryOrder.isEmpty())</span>
        {
<span class="fc" id="L141">            DeletionTime partitionDeletion = holder().deletionInfo.getPartitionDeletion();</span>
<span class="fc" id="L142">            return UnfilteredRowIterators.noRowsIterator(metadata(), partitionKey(), staticRow, partitionDeletion, reversed);</span>
        }

<span class="fc" id="L145">        return new ClusteringsIterator(selection, clusteringsInQueryOrder, reversed, holder(), staticRow);</span>
    }

    public UnfilteredRowIterator unfilteredIterator()
    {
<span class="fc" id="L150">        return unfilteredIterator(ColumnFilter.selection(columns()), Slices.ALL, false);</span>
    }

    public UnfilteredRowIterator unfilteredIterator(ColumnFilter selection, Slices slices, boolean reversed)
    {
<span class="fc" id="L155">        return unfilteredIterator(holder(), selection, slices, reversed);</span>
    }

    public UnfilteredRowIterator unfilteredIterator(BTreePartitionData current, ColumnFilter selection, Slices slices, boolean reversed)
    {
<span class="fc" id="L160">        Row staticRow = staticRow(current, selection, false);</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (slices.size() == 0)</span>
        {
<span class="fc" id="L163">            DeletionTime partitionDeletion = current.deletionInfo.getPartitionDeletion();</span>
<span class="fc" id="L164">            return UnfilteredRowIterators.noRowsIterator(metadata(), partitionKey(), staticRow, partitionDeletion, reversed);</span>
        }

<span class="fc bfc" id="L167" title="All 2 branches covered.">        return slices.size() == 1</span>
<span class="fc" id="L168">               ? sliceIterator(selection, slices.get(0), reversed, current, staticRow)</span>
<span class="fc" id="L169">               : new SlicesIterator(selection, slices, reversed, current, staticRow);</span>
    }

    private UnfilteredRowIterator sliceIterator(ColumnFilter selection, Slice slice, boolean reversed, BTreePartitionData current, Row staticRow)
    {
<span class="fc bfc" id="L174" title="All 2 branches covered.">        ClusteringBound&lt;?&gt; start = slice.start().isBottom() ? null : slice.start();</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">        ClusteringBound&lt;?&gt; end = slice.end().isTop() ? null : slice.end();</span>
<span class="fc" id="L176">        Iterator&lt;Row&gt; rowIter = BTree.slice(current.tree, metadata().comparator, start, true, end, true, desc(reversed));</span>
<span class="fc" id="L177">        Iterator&lt;RangeTombstone&gt; deleteIter = current.deletionInfo.rangeIterator(slice, reversed);</span>
<span class="fc" id="L178">        return merge(rowIter, deleteIter, selection, reversed, current, staticRow);</span>
    }

    private RowAndDeletionMergeIterator merge(Iterator&lt;Row&gt; rowIter, Iterator&lt;RangeTombstone&gt; deleteIter,
                                              ColumnFilter selection, boolean reversed, BTreePartitionData current, Row staticRow)
    {
<span class="fc" id="L184">        return new RowAndDeletionMergeIterator(metadata(), partitionKey(), current.deletionInfo.getPartitionDeletion(),</span>
                                               selection, staticRow, reversed, current.stats,
                                               rowIter, deleteIter,
<span class="fc" id="L187">                                               canHaveShadowedData());</span>
    }

    private abstract class AbstractIterator extends AbstractUnfilteredRowIterator
    {
        final BTreePartitionData current;
        final ColumnFilter selection;

        private AbstractIterator(BTreePartitionData current, Row staticRow, ColumnFilter selection, boolean isReversed)
<span class="fc" id="L196">        {</span>
<span class="fc" id="L197">            super(AbstractBTreePartition.this.metadata(),</span>
<span class="fc" id="L198">                  AbstractBTreePartition.this.partitionKey(),</span>
<span class="fc" id="L199">                  current.deletionInfo.getPartitionDeletion(),</span>
<span class="fc" id="L200">                  selection.fetchedColumns(), // non-selected columns will be filtered in subclasses by RowAndDeletionMergeIterator</span>
                  // it would also be more precise to return the intersection of the selection and current.columns,
                  // but its probably not worth spending time on computing that.
                  staticRow,
                  isReversed,
                  current.stats);
<span class="fc" id="L206">            this.current = current;</span>
<span class="fc" id="L207">            this.selection = selection;</span>
<span class="fc" id="L208">        }</span>
    }

    private class SlicesIterator extends AbstractIterator
    {
        private final Slices slices;

        private int idx;
        private Iterator&lt;Unfiltered&gt; currentSlice;

        private SlicesIterator(ColumnFilter selection, Slices slices, boolean isReversed, BTreePartitionData current, Row staticRow)
<span class="fc" id="L219">        {</span>
<span class="fc" id="L220">            super(current, staticRow, selection, isReversed);</span>
<span class="fc" id="L221">            this.slices = slices;</span>
<span class="fc" id="L222">        }</span>

        protected Unfiltered computeNext()
        {
            while (true)
            {
<span class="fc bfc" id="L228" title="All 2 branches covered.">                if (currentSlice == null)</span>
                {
<span class="fc bfc" id="L230" title="All 2 branches covered.">                    if (idx &gt;= slices.size())</span>
<span class="fc" id="L231">                        return endOfData();</span>

<span class="fc bfc" id="L233" title="All 2 branches covered.">                    int sliceIdx = isReverseOrder ? slices.size() - idx - 1 : idx;</span>
<span class="fc" id="L234">                    currentSlice = sliceIterator(selection, slices.get(sliceIdx), isReverseOrder, current, Rows.EMPTY_STATIC_ROW);</span>
<span class="fc" id="L235">                    idx++;</span>
                }

<span class="fc bfc" id="L238" title="All 2 branches covered.">                if (currentSlice.hasNext())</span>
<span class="fc" id="L239">                    return currentSlice.next();</span>

<span class="fc" id="L241">                currentSlice = null;</span>
            }
        }
    }

    private class ClusteringsIterator extends AbstractIterator
    {
        private final Iterator&lt;Clustering&lt;?&gt;&gt; clusteringsInQueryOrder;
        private final SearchIterator&lt;Clustering&lt;?&gt;, Row&gt; rowSearcher;

        private Iterator&lt;Unfiltered&gt; currentIterator;

        private ClusteringsIterator(ColumnFilter selection,
                                    NavigableSet&lt;Clustering&lt;?&gt;&gt; clusteringsInQueryOrder,
                                    boolean isReversed,
                                    BTreePartitionData current,
                                    Row staticRow)
<span class="fc" id="L258">        {</span>
<span class="fc" id="L259">            super(current, staticRow, selection, isReversed);</span>

<span class="fc" id="L261">            this.clusteringsInQueryOrder = clusteringsInQueryOrder.iterator();</span>
<span class="fc" id="L262">            this.rowSearcher = BTree.slice(current.tree, metadata().comparator, desc(isReversed));</span>
<span class="fc" id="L263">        }</span>

        protected Unfiltered computeNext()
        {
            while (true)
            {
<span class="fc bfc" id="L269" title="All 2 branches covered.">                if (currentIterator == null)</span>
                {
<span class="fc bfc" id="L271" title="All 2 branches covered.">                    if (!clusteringsInQueryOrder.hasNext())</span>
<span class="fc" id="L272">                        return endOfData();</span>

<span class="fc" id="L274">                    currentIterator = nextIterator(clusteringsInQueryOrder.next());</span>
                }

<span class="fc bfc" id="L277" title="All 4 branches covered.">                if (currentIterator != null &amp;&amp; currentIterator.hasNext())</span>
<span class="fc" id="L278">                    return currentIterator.next();</span>

<span class="fc" id="L280">                currentIterator = null;</span>
            }
        }

        private Iterator&lt;Unfiltered&gt; nextIterator(Clustering&lt;?&gt; next)
        {
<span class="fc" id="L286">            Row nextRow = rowSearcher.next(next);</span>
            // rangeCovering() will return original RT covering clustering key, but we want to generate fake RT with
            // given clustering bound to be consistent with fake RT generated from sstable read.
<span class="fc" id="L289">            Iterator&lt;RangeTombstone&gt; deleteIter = current.deletionInfo.rangeIterator(Slice.make(next), isReverseOrder());</span>

<span class="fc bfc" id="L291" title="All 4 branches covered.">            if (nextRow == null &amp;&amp; !deleteIter.hasNext())</span>
<span class="fc" id="L292">                return null;</span>

<span class="fc bfc" id="L294" title="All 2 branches covered.">            Iterator&lt;Row&gt; rowIterator = nextRow == null ? Collections.emptyIterator() : Iterators.singletonIterator(nextRow);</span>
<span class="fc" id="L295">            return merge(rowIterator, deleteIter, selection, isReverseOrder, current, staticRow);</span>
        }
    }

    protected static BTreePartitionData build(UnfilteredRowIterator iterator, int initialRowCapacity)
    {
<span class="fc" id="L301">        return build(iterator, initialRowCapacity, true);</span>
    }

    protected static BTreePartitionData build(UnfilteredRowIterator iterator, int initialRowCapacity, boolean ordered)
    {
<span class="fc" id="L306">        TableMetadata metadata = iterator.metadata();</span>
<span class="fc" id="L307">        RegularAndStaticColumns columns = iterator.columns();</span>
<span class="fc" id="L308">        boolean reversed = iterator.isReverseOrder();</span>

<span class="fc" id="L310">        BTree.Builder&lt;Row&gt; builder = BTree.builder(metadata.comparator, initialRowCapacity);</span>
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">        builder.auto(!ordered);</span>
<span class="fc" id="L312">        MutableDeletionInfo.Builder deletionBuilder = MutableDeletionInfo.builder(iterator.partitionLevelDeletion(), metadata.comparator, reversed);</span>

<span class="fc bfc" id="L314" title="All 2 branches covered.">        while (iterator.hasNext())</span>
        {
<span class="fc" id="L316">            Unfiltered unfiltered = iterator.next();</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">            if (unfiltered.kind() == Unfiltered.Kind.ROW)</span>
<span class="fc" id="L318">                builder.add((Row)unfiltered);</span>
            else
<span class="fc" id="L320">                deletionBuilder.add((RangeTombstoneMarker)unfiltered);</span>
<span class="fc" id="L321">        }</span>

<span class="fc bfc" id="L323" title="All 2 branches covered.">        if (reversed)</span>
<span class="fc" id="L324">            builder.reverse();</span>

<span class="fc" id="L326">        return new BTreePartitionData(columns, builder.build(), deletionBuilder.build(), iterator.staticRow(), iterator.stats());</span>
    }

    // Note that when building with a RowIterator, deletion will generally be LIVE, but we allow to pass it nonetheless because PartitionUpdate
    // passes a MutableDeletionInfo that it mutates later.
    protected static BTreePartitionData build(RowIterator rows, DeletionInfo deletion, boolean buildEncodingStats)
    {
<span class="fc" id="L333">        RegularAndStaticColumns columns = rows.columns();</span>
<span class="fc" id="L334">        boolean reversed = rows.isReverseOrder();</span>

<span class="fc" id="L336">        try (BTree.FastBuilder&lt;Row&gt; builder = BTree.fastBuilder())</span>
        {
<span class="fc bfc" id="L338" title="All 2 branches covered.">            while (rows.hasNext())</span>
<span class="fc" id="L339">                builder.add(rows.next());</span>


<span class="fc bfc" id="L342" title="All 2 branches covered.">            Object[] tree = reversed ? builder.buildReverse()</span>
<span class="fc" id="L343">                                     : builder.build();</span>

<span class="fc" id="L345">            Row staticRow = rows.staticRow();</span>
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">            EncodingStats stats = buildEncodingStats ? EncodingStats.Collector.collect(staticRow, BTree.iterator(tree), deletion)</span>
<span class="fc" id="L347">                                                     : EncodingStats.NO_STATS;</span>
<span class="fc" id="L348">            return new BTreePartitionData(columns, tree, deletion, staticRow, stats);</span>
        }
    }

    @Override
    public String toString()
    {
<span class="fc" id="L355">        return toString(true);</span>
    }

    public String toString(boolean includeFullDetails)
    {
<span class="fc" id="L360">        StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">        if (includeFullDetails)</span>
        {
<span class="fc" id="L363">            sb.append(String.format(&quot;[%s.%s] key=%s partition_deletion=%s columns=%s&quot;,</span>
<span class="fc" id="L364">                                    metadata().keyspace,</span>
<span class="fc" id="L365">                                    metadata().name,</span>
<span class="fc" id="L366">                                    metadata().partitionKeyType.getString(partitionKey().getKey()),</span>
<span class="fc" id="L367">                                    partitionLevelDeletion(),</span>
<span class="fc" id="L368">                                    columns()));</span>
        }
        else
        {
<span class="fc" id="L372">            sb.append(&quot;key=&quot;).append(metadata().partitionKeyType.getString(partitionKey().getKey()));</span>
        }

<span class="pc bpc" id="L375" title="1 of 2 branches missed.">        if (staticRow() != Rows.EMPTY_STATIC_ROW)</span>
<span class="nc" id="L376">            sb.append(&quot;\n    &quot;).append(staticRow().toString(metadata(), includeFullDetails));</span>

<span class="fc" id="L378">        try (UnfilteredRowIterator iter = unfilteredIterator())</span>
        {
<span class="fc bfc" id="L380" title="All 2 branches covered.">            while (iter.hasNext())</span>
<span class="fc" id="L381">                sb.append(&quot;\n    &quot;).append(iter.next().toString(metadata(), includeFullDetails));</span>
        }
<span class="fc" id="L383">        return sb.toString();</span>
    }

    @Override
    public boolean equals(Object obj)
    {
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        if (!(obj instanceof PartitionUpdate))</span>
<span class="nc" id="L390">            return false;</span>

<span class="fc" id="L392">        PartitionUpdate that = (PartitionUpdate) obj;</span>
<span class="fc" id="L393">        BTreePartitionData a = this.holder(), b = that.holder();</span>
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">        return partitionKey.equals(that.partitionKey)</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">               &amp;&amp; metadata().id.equals(that.metadata().id)</span>
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">               &amp;&amp; a.deletionInfo.equals(b.deletionInfo)</span>
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">               &amp;&amp; a.staticRow.equals(b.staticRow)</span>
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">               &amp;&amp; Iterators.elementsEqual(iterator(), that.iterator());</span>
    }

    public int rowCount()
    {
<span class="fc" id="L403">        return BTree.size(holder().tree);</span>
    }

    public Iterator&lt;Row&gt; iterator()
    {
<span class="fc" id="L408">        return BTree.&lt;Row&gt;iterator(holder().tree);</span>
    }

    public Row lastRow()
    {
<span class="fc" id="L413">        Object[] tree = holder().tree;</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">        if (BTree.isEmpty(tree))</span>
<span class="fc" id="L415">            return null;</span>

<span class="fc" id="L417">        return BTree.findByIndex(tree, BTree.size(tree) - 1);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>