<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Selectable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.selection</a> &gt; <span class="el_source">Selectable.java</span></div><h1>Selectable.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cassandra.cql3.selection;

import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import org.apache.cassandra.cql3.*;
import org.apache.cassandra.cql3.functions.*;
import org.apache.cassandra.cql3.selection.Selector.Factory;
import org.apache.cassandra.db.marshal.*;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.utils.Pair;

import static org.apache.cassandra.cql3.selection.SelectorFactories.createFactoriesAndCollectColumnDefinitions;
import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;

public interface Selectable extends AssignmentTestable
{
    public Selector.Factory newSelectorFactory(TableMetadata table, AbstractType&lt;?&gt; expectedType, List&lt;ColumnMetadata&gt; defs, VariableSpecifications boundNames);

    /**
     * The type of the {@code Selectable} if it can be infered.
     *
     * @param keyspace the keyspace on which the statement for which this is a
     * {@code Selectable} is on.
     * @return the type of this {@code Selectable} if inferrable, or {@code null}
     * otherwise (for instance, the type isn't inferable for a bind marker. Even for
     * literals, the exact type is not inferrable since they are valid for many
     * different types and so this will return {@code null} too).
     */
    public AbstractType&lt;?&gt; getExactTypeIfKnown(String keyspace);

    /**
     * Checks if this {@code Selectable} select columns matching the specified predicate.
     * @return {@code true} if this {@code Selectable} select columns matching the specified predicate,
     * {@code false} otherwise.
     */
    public boolean selectColumns(Predicate&lt;ColumnMetadata&gt; predicate);

    /**
     * Checks if the specified Selectables select columns matching the specified predicate.
     * @param selectables the selectables to check.
     * @return {@code true} if the specified Selectables select columns matching the specified predicate,
      {@code false} otherwise.
     */
    public static boolean selectColumns(List&lt;Selectable&gt; selectables, Predicate&lt;ColumnMetadata&gt; predicate)
    {
<span class="fc bfc" id="L68" title="All 2 branches covered.">        for (Selectable selectable : selectables)</span>
        {
<span class="fc bfc" id="L70" title="All 2 branches covered.">            if (selectable.selectColumns(predicate))</span>
<span class="fc" id="L71">                return true;</span>
<span class="fc" id="L72">        }</span>
<span class="fc" id="L73">        return false;</span>
    }

    /**
     * Checks if any processing is performed on the selected columns, {@code false} otherwise.
     * @return {@code true} if any processing is performed on the selected columns, {@code false} otherwise.
     */
    public default boolean processesSelection()
    {
        // ColumnMetadata is the only case that returns false (if the column is not masked) and overrides this
<span class="fc" id="L83">        return true;</span>
    }

    // Term.Raw overrides this since some literals can be WEAKLY_ASSIGNABLE
    default public TestResult testAssignment(String keyspace, ColumnSpecification receiver)
    {
<span class="fc" id="L89">        AbstractType&lt;?&gt; type = getExactTypeIfKnown(keyspace);</span>
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">        return type == null ? TestResult.NOT_ASSIGNABLE : type.testAssignment(keyspace, receiver);</span>
    }

    @Override
    public default AbstractType&lt;?&gt; getCompatibleTypeIfKnown(String keyspace)
    {
<span class="fc" id="L96">        return getExactTypeIfKnown(keyspace);</span>
    }

    default int addAndGetIndex(ColumnMetadata def, List&lt;ColumnMetadata&gt; l)
    {
<span class="fc" id="L101">        int idx = l.indexOf(def);</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">        if (idx &lt; 0)</span>
        {
<span class="fc" id="L104">            idx = l.size();</span>
<span class="fc" id="L105">            l.add(def);</span>
        }
<span class="fc" id="L107">        return idx;</span>
    }

    default ColumnSpecification specForElementOrSlice(Selectable selected, ColumnSpecification receiver, CollectionType.Kind kind, String selectionType)
    {
<span class="pc bpc" id="L112" title="1 of 4 branches missed.">        switch (kind)</span>
        {
<span class="fc" id="L114">            case LIST: throw new InvalidRequestException(String.format(&quot;%s selection is only allowed on sets and maps, but %s is a list&quot;, selectionType, selected));</span>
<span class="fc" id="L115">            case SET: return Sets.valueSpecOf(receiver);</span>
<span class="fc" id="L116">            case MAP: return Maps.keySpecOf(receiver);</span>
<span class="nc" id="L117">            default: throw new AssertionError();</span>
        }
    }

    public interface Raw
    {
        public Selectable prepare(TableMetadata table);
    }

    public static class WithTerm implements Selectable
    {
        /**
         * The names given to unamed bind markers found in selection. In selection clause, we often don't have a good
         * name for bind markers, typically if you have:
         *   SELECT (int)? FROM foo;
         * there isn't a good name for that marker. So we give the same name to all the markers. Note that we could try
         * to differenciate the names by using some increasing number in the name (so [selection_1], [selection_2], ...)
         * but it's actually not trivial to do in the current code and it's not really more helpful since if users wants
         * to bind by position (which they will have to in this case), they can do so at the driver level directly. And
         * so we don't bother.
         * Note that users should really be using named bind markers if they want to be able to bind by names.
         */
<span class="fc" id="L139">        private static final ColumnIdentifier bindMarkerNameInSelection = new ColumnIdentifier(&quot;[selection]&quot;, true);</span>

        private final Term.Raw rawTerm;

        public WithTerm(Term.Raw rawTerm)
<span class="fc" id="L144">        {</span>
<span class="fc" id="L145">            this.rawTerm = rawTerm;</span>
<span class="fc" id="L146">        }</span>

        @Override
        public TestResult testAssignment(String keyspace, ColumnSpecification receiver)
        {
<span class="fc" id="L151">            return rawTerm.testAssignment(keyspace, receiver);</span>
        }

        public Selector.Factory newSelectorFactory(TableMetadata table, AbstractType&lt;?&gt; expectedType, List&lt;ColumnMetadata&gt; defs, VariableSpecifications boundNames) throws InvalidRequestException
        {
            /*
             * expectedType will be null if we have no constraint on what the type should be. For instance, if this term is a bind marker:
             *   - it will be null if we do &quot;SELECT ? FROM foo&quot;
             *   - it won't be null (and be LongType) if we do &quot;SELECT bigint_as_blob(?) FROM foo&quot; because the function constrain it.
             *
             * In the first case, we have to error out: we need to infer the type of the metadata of a SELECT at preparation time, which we can't
             * here (users will have to do &quot;SELECT (varint)? FROM foo&quot; for instance).
             * But in the 2nd case, we're fine and can use the expectedType to &quot;prepare&quot; the bind marker/collect the bound type.
             *
             * Further, the term might not be a bind marker, in which case we sometimes can default to some most-general type. For instance, in
             *   SELECT 3 FROM foo
             * we'll just default the type to 'varint' as that's the most generic type for the literal '3' (this is mostly for convenience, the query
             * is not terribly useful in practice and use can force the type as for the bind marker case through &quot;SELECT (int)3 FROM foo&quot;).
             * But note that not all literals can have such default type. For instance, there is no way to infer the type of a UDT literal in a vacuum,
             * and so we simply error out if we have something like:
             *   SELECT { foo: 'bar' } FROM foo
             *
             * Lastly, note that if the term is a terminal literal, we don't have to check it's compatibility with 'expectedType' as any incompatibility
             * would have been found at preparation time.
             */
<span class="fc" id="L176">            AbstractType&lt;?&gt; type = getExactTypeIfKnown(table.keyspace);</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">            if (type == null)</span>
            {
<span class="fc" id="L179">                type = expectedType;</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">                if (type == null)</span>
<span class="fc" id="L181">                    throw new InvalidRequestException(&quot;Cannot infer type for term &quot; + this + &quot; in selection clause (try using a cast to force a type)&quot;);</span>
            }

            // The fact we default the name to &quot;[selection]&quot; inconditionally means that any bind marker in a
            // selection will have this name. Which isn't terribly helpful, but it's unclear how to provide
            // something a lot more helpful and in practice user can bind those markers by position or, even better,
            // use bind markers.
<span class="fc" id="L188">            Term term = rawTerm.prepare(table.keyspace, new ColumnSpecification(table.keyspace, table.name, bindMarkerNameInSelection, type));</span>
<span class="fc" id="L189">            term.collectMarkerSpecification(boundNames);</span>
<span class="fc" id="L190">            return TermSelector.newFactory(rawTerm.getText(), term, type);</span>
        }

        @Override
        public AbstractType&lt;?&gt; getExactTypeIfKnown(String keyspace)
        {
<span class="fc" id="L196">            return rawTerm.getExactTypeIfKnown(keyspace);</span>
        }

        @Override
        public AbstractType&lt;?&gt; getCompatibleTypeIfKnown(String keyspace)
        {
<span class="fc" id="L202">            return rawTerm.getCompatibleTypeIfKnown(keyspace);</span>
        }

        @Override
        public boolean selectColumns(Predicate&lt;ColumnMetadata&gt; predicate)
        {
<span class="fc" id="L208">            return false;</span>
        }

        @Override
        public String toString()
        {
<span class="fc" id="L214">            return rawTerm.getText();</span>
        }

        public static class Raw implements Selectable.Raw
        {
            private final Term.Raw term;

            public Raw(Term.Raw term)
<span class="fc" id="L222">            {</span>
<span class="fc" id="L223">                this.term = term;</span>
<span class="fc" id="L224">            }</span>

            public Selectable prepare(TableMetadata table)
            {
<span class="fc" id="L228">                return new WithTerm(term);</span>
            }
        }
    }

    public static class WritetimeOrTTL implements Selectable
    {
        // The order of the variants in the Kind enum matters as they are used in ser/deser
<span class="fc" id="L236">        public enum Kind</span>
        {
<span class="fc" id="L238">            TTL(&quot;ttl&quot;, Int32Type.instance),</span>
<span class="fc" id="L239">            WRITE_TIME(&quot;writetime&quot;, LongType.instance),</span>
<span class="fc" id="L240">            MAX_WRITE_TIME(&quot;maxwritetime&quot;, LongType.instance); // maxwritetime is available after Cassandra 4.1 (exclusive)</span>

            public final String name;
            public final AbstractType&lt;?&gt; returnType;

            public static Kind fromOrdinal(int ordinal)
            {
<span class="fc" id="L247">                return values()[ordinal];</span>
            }

            Kind(String name, AbstractType&lt;?&gt; returnType)
<span class="fc" id="L251">            {</span>
<span class="fc" id="L252">                this.name = name;</span>
<span class="fc" id="L253">                this.returnType = returnType;</span>
<span class="fc" id="L254">            }</span>

            public boolean aggregatesMultiCell()
            {
<span class="fc bfc" id="L258" title="All 2 branches covered.">                return this == MAX_WRITE_TIME;</span>
            }
        }

        public final ColumnMetadata column;
        public final Selectable selectable;
        public final Kind kind;

        public WritetimeOrTTL(ColumnMetadata column, Selectable selectable, Kind kind)
<span class="fc" id="L267">        {</span>
<span class="fc" id="L268">            this.column = column;</span>
<span class="fc" id="L269">            this.selectable = selectable;</span>
<span class="fc" id="L270">            this.kind = kind;</span>
<span class="fc" id="L271">        }</span>

        @Override
        public String toString()
        {
<span class="fc" id="L276">            return kind.name + &quot;(&quot; + selectable + &quot;)&quot;;</span>
        }

        public Selector.Factory newSelectorFactory(TableMetadata table,
                                                   AbstractType&lt;?&gt; expectedType,
                                                   List&lt;ColumnMetadata&gt; defs,
                                                   VariableSpecifications boundNames)
        {
<span class="fc bfc" id="L284" title="All 2 branches covered.">            if (column.isPrimaryKeyColumn())</span>
<span class="fc" id="L285">                throw new InvalidRequestException(</span>
<span class="fc" id="L286">                        String.format(&quot;Cannot use selection function %s on PRIMARY KEY part %s&quot;,</span>
                                      kind.name,
                                      column.name));

<span class="fc" id="L290">            Selector.Factory factory = selectable.newSelectorFactory(table, expectedType, defs, boundNames);</span>
<span class="fc" id="L291">            boolean isMultiCell = factory.getColumnSpecification(table).type.isMultiCell();</span>

<span class="fc" id="L293">            return WritetimeOrTTLSelector.newFactory(factory, addAndGetIndex(column, defs), kind, isMultiCell);</span>
        }

        @Override
        public AbstractType&lt;?&gt; getExactTypeIfKnown(String keyspace)
        {
<span class="fc" id="L299">            AbstractType&lt;?&gt; type = kind.returnType;</span>
<span class="fc bfc" id="L300" title="All 4 branches covered.">            return column.type.isMultiCell() &amp;&amp; !kind.aggregatesMultiCell() ? ListType.getInstance(type, false) : type;</span>
        }

        @Override
        public boolean selectColumns(Predicate&lt;ColumnMetadata&gt; predicate)
        {
<span class="fc" id="L306">            return selectable.selectColumns(predicate);</span>
        }

        public static class Raw implements Selectable.Raw
        {
            private final Selectable.RawIdentifier column;
            private final Selectable.Raw selected;
            private final Kind kind;

            public Raw(Selectable.RawIdentifier column, Selectable.Raw selected, Kind kind)
<span class="fc" id="L316">            {</span>
<span class="fc" id="L317">                this.column = column;</span>
<span class="fc" id="L318">                this.selected = selected;</span>
<span class="fc" id="L319">                this.kind = kind;</span>
<span class="fc" id="L320">            }</span>

            @Override
            public WritetimeOrTTL prepare(TableMetadata table)
            {
<span class="fc" id="L325">                return new WritetimeOrTTL((ColumnMetadata) column.prepare(table), selected.prepare(table), kind);</span>
            }
        }
    }

    public static class WithFunction implements Selectable
    {
        public final Function function;
        public final List&lt;Selectable&gt; args;

        public WithFunction(Function function, List&lt;Selectable&gt; args)
<span class="fc" id="L336">        {</span>
<span class="fc" id="L337">            this.function = function;</span>
<span class="fc" id="L338">            this.args = args;</span>
<span class="fc" id="L339">        }</span>

        @Override
        public String toString()
        {
<span class="fc" id="L344">            return function.columnName(args.stream().map(Object::toString).collect(Collectors.toList()));</span>
        }

        public Selector.Factory newSelectorFactory(TableMetadata table, AbstractType&lt;?&gt; expectedType, List&lt;ColumnMetadata&gt; defs, VariableSpecifications boundNames)
        {
<span class="fc" id="L349">            SelectorFactories factories = SelectorFactories.createFactoriesAndCollectColumnDefinitions(args, function.argTypes(), table, defs, boundNames);</span>
<span class="fc" id="L350">            return AbstractFunctionSelector.newFactory(function, factories);</span>
        }

        @Override
        public boolean selectColumns(Predicate&lt;ColumnMetadata&gt; predicate)
        {
<span class="fc" id="L356">            return Selectable.selectColumns(args, predicate);</span>
        }

        public AbstractType&lt;?&gt; getExactTypeIfKnown(String keyspace)
        {
<span class="fc" id="L361">            return function.returnType();</span>
        }

        public static class Raw implements Selectable.Raw
        {
            private final FunctionName functionName;
            private final List&lt;Selectable.Raw&gt; args;

            public Raw(FunctionName functionName, List&lt;Selectable.Raw&gt; args)
<span class="fc" id="L370">            {</span>
<span class="fc" id="L371">                this.functionName = functionName;</span>
<span class="fc" id="L372">                this.args = args;</span>
<span class="fc" id="L373">            }</span>

            public static Raw newCountRowsFunction()
            {
<span class="fc" id="L377">                return new Raw(AggregateFcts.countRowsFunction.name(),</span>
<span class="fc" id="L378">                               Collections.emptyList());</span>
            }

            public static Raw newOperation(char operator, Selectable.Raw left, Selectable.Raw right)
            {
<span class="fc" id="L383">                return new Raw(OperationFcts.getFunctionNameFromOperator(operator),</span>
<span class="fc" id="L384">                               Arrays.asList(left, right));</span>
            }

            public static Raw newNegation(Selectable.Raw arg)
            {
<span class="fc" id="L389">                return new Raw(FunctionName.nativeFunction(OperationFcts.NEGATION_FUNCTION_NAME),</span>
<span class="fc" id="L390">                               Collections.singletonList(arg));</span>
            }

            @Override
            public Selectable prepare(TableMetadata table)
            {
<span class="fc" id="L396">                List&lt;Selectable&gt; preparedArgs = new ArrayList&lt;&gt;(args.size());</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">                for (Selectable.Raw arg : args)</span>
<span class="fc" id="L398">                    preparedArgs.add(arg.prepare(table));</span>

<span class="fc" id="L400">                FunctionName name = functionName;</span>
                // COUNT(x) is equivalent to COUNT(*) for any non-null term x (since count(x) don't care about its
                // argument outside of check for nullness) and for backward compatibilty we want to support COUNT(1),
                // but we actually have COUNT(x) method for every existing (simple) input types so currently COUNT(1)
                // will throw as ambiguous (since 1 works for any type). So we have to special case COUNT.
<span class="fc bfc" id="L405" title="All 2 branches covered.">                if (functionName.equalsNativeFunction(FunctionName.nativeFunction(&quot;count&quot;))</span>
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">                        &amp;&amp; preparedArgs.size() == 1</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">                        &amp;&amp; (preparedArgs.get(0) instanceof WithTerm)</span>
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">                        &amp;&amp; (((WithTerm)preparedArgs.get(0)).rawTerm instanceof Constants.Literal))</span>
                {
                    // Note that 'null' isn't a Constants.Literal
<span class="fc" id="L411">                    name = AggregateFcts.countRowsFunction.name();</span>
<span class="fc" id="L412">                    preparedArgs = Collections.emptyList();</span>
                }

<span class="fc" id="L415">                Function fun = FunctionResolver.get(table.keyspace, name, preparedArgs, table.keyspace, table.name, null);</span>

<span class="fc bfc" id="L417" title="All 2 branches covered.">                if (fun == null)</span>
<span class="fc" id="L418">                    throw new InvalidRequestException(String.format(&quot;Unknown function '%s'&quot;, functionName));</span>

<span class="pc bpc" id="L420" title="1 of 2 branches missed.">                if (fun.returnType() == null)</span>
<span class="nc" id="L421">                    throw new InvalidRequestException(String.format(&quot;Unknown function %s called in selection clause&quot;, functionName));</span>

<span class="fc" id="L423">                return new WithFunction(fun, preparedArgs);</span>
            }
        }
    }

    public static class WithCast implements Selectable
    {
        private final CQL3Type type;
        private final Selectable arg;

        public WithCast(Selectable arg, CQL3Type type)
<span class="fc" id="L434">        {</span>
<span class="fc" id="L435">            this.arg = arg;</span>
<span class="fc" id="L436">            this.type = type;</span>
<span class="fc" id="L437">        }</span>

        @Override
        public String toString()
        {
<span class="fc" id="L442">            return String.format(&quot;cast(%s as %s)&quot;, arg, type.toString().toLowerCase());</span>
        }

        public Selector.Factory newSelectorFactory(TableMetadata table, AbstractType&lt;?&gt; expectedType, List&lt;ColumnMetadata&gt; defs, VariableSpecifications boundNames)
        {
<span class="fc" id="L447">            List&lt;Selectable&gt; args = Collections.singletonList(arg);</span>
<span class="fc" id="L448">            SelectorFactories factories = SelectorFactories.createFactoriesAndCollectColumnDefinitions(args, null, table, defs, boundNames);</span>

<span class="fc" id="L450">            Selector.Factory factory = factories.get(0);</span>

            // If the user is trying to cast a type on its own type we simply ignore it.
<span class="fc bfc" id="L453" title="All 2 branches covered.">            if (type.getType().equals(factory.getReturnType()))</span>
<span class="fc" id="L454">                return factory;</span>

<span class="fc" id="L456">            FunctionName name = FunctionName.nativeFunction(CastFcts.getFunctionName(type));</span>
<span class="fc" id="L457">            Function fun = FunctionResolver.get(table.keyspace, name, args, table.keyspace, table.name, null);</span>

<span class="fc bfc" id="L459" title="All 2 branches covered.">            if (fun == null)</span>
            {
<span class="fc" id="L461">                    throw new InvalidRequestException(String.format(&quot;%s cannot be cast to %s&quot;,</span>
<span class="fc" id="L462">                                                                    defs.get(0).name,</span>
                                                                    type));
            }
<span class="fc" id="L465">            return AbstractFunctionSelector.newFactory(fun, factories);</span>
        }

        public AbstractType&lt;?&gt; getExactTypeIfKnown(String keyspace)
        {
<span class="fc" id="L470">            return type.getType();</span>
        }

        @Override
        public boolean selectColumns(Predicate&lt;ColumnMetadata&gt; predicate)
        {
<span class="nc" id="L476">            return arg.selectColumns(predicate);</span>
        }

        public static class Raw implements Selectable.Raw
        {
            private final CQL3Type type;
            private final Selectable.Raw arg;

            public Raw(Selectable.Raw arg, CQL3Type type)
<span class="fc" id="L485">            {</span>
<span class="fc" id="L486">                this.arg = arg;</span>
<span class="fc" id="L487">                this.type = type;</span>
<span class="fc" id="L488">            }</span>

            public WithCast prepare(TableMetadata table)
            {
<span class="fc" id="L492">                return new WithCast(arg.prepare(table), type);</span>
            }
        }
    }

    /**
     * Represents the selection of the field of a UDT (eg. t.f).
     */
    public static class WithFieldSelection implements Selectable
    {
        public final Selectable selected;
        public final FieldIdentifier field;

        public WithFieldSelection(Selectable selected, FieldIdentifier field)
<span class="fc" id="L506">        {</span>
<span class="fc" id="L507">            this.selected = selected;</span>
<span class="fc" id="L508">            this.field = field;</span>
<span class="fc" id="L509">        }</span>

        @Override
        public String toString()
        {
<span class="fc" id="L514">            return String.format(&quot;%s.%s&quot;, selected, field);</span>
        }

        public Selector.Factory newSelectorFactory(TableMetadata table, AbstractType&lt;?&gt; expectedType, List&lt;ColumnMetadata&gt; defs, VariableSpecifications boundNames)
        {
<span class="fc" id="L519">            AbstractType&lt;?&gt; expectedUdtType = null;</span>

            // If the UDT is between parentheses, we know that it is not a tuple with a single element.
<span class="fc bfc" id="L522" title="All 2 branches covered.">            if (selected instanceof BetweenParenthesesOrWithTuple)</span>
            {
<span class="fc" id="L524">                BetweenParenthesesOrWithTuple betweenParentheses = (BetweenParenthesesOrWithTuple) selected;</span>
<span class="fc" id="L525">                expectedUdtType = betweenParentheses.selectables.get(0).getExactTypeIfKnown(table.keyspace);</span>
            }

<span class="fc" id="L528">            Selector.Factory factory = selected.newSelectorFactory(table, expectedUdtType, defs, boundNames);</span>
<span class="fc" id="L529">            AbstractType&lt;?&gt; type = factory.getReturnType();</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">            if (!type.isUDT())</span>
            {
<span class="fc" id="L532">                throw new InvalidRequestException(</span>
<span class="fc" id="L533">                        String.format(&quot;Invalid field selection: %s of type %s is not a user type&quot;,</span>
                                selected,
<span class="fc" id="L535">                                type.asCQL3Type()));</span>
            }

<span class="fc" id="L538">            UserType ut = (UserType) type;</span>
<span class="fc" id="L539">            int fieldIndex = ut.fieldPosition(field);</span>
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">            if (fieldIndex == -1)</span>
            {
<span class="nc" id="L542">                throw new InvalidRequestException(String.format(&quot;%s of type %s has no field %s&quot;,</span>
<span class="nc" id="L543">                        selected, type.asCQL3Type(), field));</span>
            }

<span class="fc" id="L546">            return FieldSelector.newFactory(ut, fieldIndex, factory);</span>
        }

        public AbstractType&lt;?&gt; getExactTypeIfKnown(String keyspace)
        {
<span class="fc" id="L551">            AbstractType&lt;?&gt; selectedType = selected.getExactTypeIfKnown(keyspace);</span>
<span class="pc bpc" id="L552" title="2 of 4 branches missed.">            if (selectedType == null || !(selectedType instanceof UserType))</span>
<span class="nc" id="L553">                return null;</span>

<span class="fc" id="L555">            UserType ut = (UserType) selectedType;</span>
<span class="fc" id="L556">            int fieldIndex = ut.fieldPosition(field);</span>
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">            if (fieldIndex == -1)</span>
<span class="nc" id="L558">                return null;</span>

<span class="fc" id="L560">            return ut.fieldType(fieldIndex);</span>
        }

        @Override
        public boolean selectColumns(Predicate&lt;ColumnMetadata&gt; predicate)
        {
<span class="fc" id="L566">            return selected.selectColumns(predicate);</span>
        }

        public static class Raw implements Selectable.Raw
        {
            private final Selectable.Raw selected;
            private final FieldIdentifier field;

            public Raw(Selectable.Raw selected, FieldIdentifier field)
<span class="fc" id="L575">            {</span>
<span class="fc" id="L576">                this.selected = selected;</span>
<span class="fc" id="L577">                this.field = field;</span>
<span class="fc" id="L578">            }</span>

            public WithFieldSelection prepare(TableMetadata table)
            {
<span class="fc" id="L582">                return new WithFieldSelection(selected.prepare(table), field);</span>
            }
        }
    }

    /**
     * {@code Selectable} for {@code Selectable} between parentheses or tuples.
     * &lt;p&gt;The parser cannot differentiate between a single element between parentheses or a single element tuple.
     * By consequence, we are forced to wait until the type is known to be able to differentiate them.&lt;/p&gt;
     */
    public static class BetweenParenthesesOrWithTuple implements Selectable
    {
        /**
         * The tuple elements or the element between the parentheses
         */
        private final List&lt;Selectable&gt; selectables;

        public BetweenParenthesesOrWithTuple(List&lt;Selectable&gt; selectables)
<span class="fc" id="L600">        {</span>
<span class="fc" id="L601">            this.selectables = selectables;</span>
<span class="fc" id="L602">        }</span>

        @Override
        public TestResult testAssignment(String keyspace, ColumnSpecification receiver)
        {
<span class="fc bfc" id="L607" title="All 4 branches covered.">            if (selectables.size() == 1 &amp;&amp; !receiver.type.isTuple())</span>
<span class="fc" id="L608">                return selectables.get(0).testAssignment(keyspace, receiver);</span>

<span class="fc" id="L610">            return Tuples.testTupleAssignment(receiver, selectables);</span>
        }

        @Override
        public Factory newSelectorFactory(TableMetadata cfm,
                                          AbstractType&lt;?&gt; expectedType,
                                          List&lt;ColumnMetadata&gt; defs,
                                          VariableSpecifications boundNames)
        {
<span class="fc" id="L619">            AbstractType&lt;?&gt; type = getExactTypeIfKnown(cfm.keyspace);</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">            if (type == null)</span>
            {
<span class="fc" id="L622">                type = expectedType;</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">                if (type == null)</span>
<span class="fc" id="L624">                    throw invalidRequest(&quot;Cannot infer type for term %s in selection clause (try using a cast to force a type)&quot;,</span>
                                         this);
            }

<span class="fc bfc" id="L628" title="All 4 branches covered.">            if (selectables.size() == 1 &amp;&amp; !type.isTuple())</span>
<span class="fc" id="L629">                return newBetweenParenthesesSelectorFactory(cfm, expectedType, defs, boundNames);</span>

<span class="fc" id="L631">            return newTupleSelectorFactory(cfm, (TupleType) type, defs, boundNames);</span>
        }

        private Factory newBetweenParenthesesSelectorFactory(TableMetadata cfm,
                                                             AbstractType&lt;?&gt; expectedType,
                                                             List&lt;ColumnMetadata&gt; defs,
                                                             VariableSpecifications boundNames)
        {
<span class="fc" id="L639">            Selectable selectable = selectables.get(0);</span>
<span class="fc" id="L640">            final Factory factory = selectable.newSelectorFactory(cfm, expectedType, defs, boundNames);</span>

<span class="fc" id="L642">            return new ForwardingFactory()</span>
<span class="fc" id="L643">            {</span>
                protected Factory delegate()
                {
<span class="fc" id="L646">                    return factory;</span>
                }

                protected String getColumnName()
                {
<span class="fc" id="L651">                    return String.format(&quot;(%s)&quot;, factory.getColumnName());</span>
                }
            };
        }

        private Factory newTupleSelectorFactory(TableMetadata cfm,
                                                TupleType tupleType,
                                                List&lt;ColumnMetadata&gt; defs,
                                                VariableSpecifications boundNames)
        {
<span class="fc" id="L661">            SelectorFactories factories = createFactoriesAndCollectColumnDefinitions(selectables,</span>
<span class="fc" id="L662">                                                                                     tupleType.allTypes(),</span>
                                                                                     cfm,
                                                                                     defs,
                                                                                     boundNames);

<span class="fc" id="L667">            return TupleSelector.newFactory(tupleType, factories);</span>
        }

        @Override
        public AbstractType&lt;?&gt; getExactTypeIfKnown(String keyspace)
        {
            // If there is only one element we cannot know if it is an element between parentheses or a tuple
            // with only one element. By consequence, we need to force the user to specify the type.
<span class="fc bfc" id="L675" title="All 2 branches covered.">            if (selectables.size() == 1)</span>
<span class="fc" id="L676">                return null;</span>

<span class="fc" id="L678">            return Tuples.getExactTupleTypeIfKnown(selectables, p -&gt; p.getExactTypeIfKnown(keyspace));</span>
        }

        @Override
        public AbstractType&lt;?&gt; getCompatibleTypeIfKnown(String keyspace)
        {
            // If there is only one element we cannot know if it is an element between parentheses or a tuple
            // with only one element. By consequence, we need to force the user to specify the type.
<span class="fc bfc" id="L686" title="All 2 branches covered.">            if (selectables.size() == 1)</span>
<span class="fc" id="L687">                return null;</span>

<span class="fc" id="L689">            return Tuples.getExactTupleTypeIfKnown(selectables, p -&gt; p.getCompatibleTypeIfKnown(keyspace));</span>
        }

        @Override
        public boolean selectColumns(Predicate&lt;ColumnMetadata&gt; predicate)
        {
<span class="nc" id="L695">            return Selectable.selectColumns(selectables, predicate);</span>
        }

        @Override
        public String toString()
        {
<span class="fc" id="L701">            return Tuples.tupleToString(selectables);</span>
        }

        public static class Raw implements Selectable.Raw
        {
            private final List&lt;Selectable.Raw&gt; raws;

            public Raw(List&lt;Selectable.Raw&gt; raws)
<span class="fc" id="L709">            {</span>
<span class="fc" id="L710">                this.raws = raws;</span>
<span class="fc" id="L711">            }</span>

            @Override
            public Selectable prepare(TableMetadata cfm)
            {
<span class="fc" id="L716">                return new BetweenParenthesesOrWithTuple(raws.stream().map(p -&gt; p.prepare(cfm)).collect(Collectors.toList()));</span>
            }
        }
    }

    /**
     * &lt;code&gt;Selectable&lt;/code&gt; for literal Lists.
     */
    public static class WithArrayLiteral implements Selectable
    {
        /**
         * The list elements
         */
        protected final List&lt;Selectable&gt; selectables;

        public WithArrayLiteral(List&lt;Selectable&gt; selectables)
<span class="fc" id="L732">        {</span>
<span class="fc" id="L733">            this.selectables = selectables;</span>
<span class="fc" id="L734">        }</span>

        private Selectable target(AbstractType&lt;?&gt; target)
        {
            // when the target isn't known, fallback to list; cases like &quot;SELECT [1, 2]&quot; can't be known, but used to be list type!
            // If a vector is actually desired, then can use type cast/hints: &quot;SELECT (vector&lt;int, 2&gt;) [k, v1]&quot;
<span class="fc bfc" id="L740" title="All 4 branches covered.">            if (target == null || target instanceof ListType)</span>
<span class="fc" id="L741">                return new WithList(selectables);</span>
<span class="pc bpc" id="L742" title="1 of 2 branches missed.">            else if (target.isVector())</span>
<span class="fc" id="L743">                return new WithVector(selectables);</span>
<span class="nc" id="L744">            throw new IllegalArgumentException(&quot;Unsupported target type: &quot; + target.asCQL3Type());</span>
        }

        @Override
        public TestResult testAssignment(String keyspace, ColumnSpecification receiver)
        {
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">            return target(receiver == null ? null : receiver.type).testAssignment(keyspace, receiver);</span>
        }

        @Override
        public Factory newSelectorFactory(TableMetadata cfm,
                                          AbstractType&lt;?&gt; expectedType,
                                          List&lt;ColumnMetadata&gt; defs,
                                          VariableSpecifications boundNames)
        {
<span class="fc" id="L759">            return target(expectedType).newSelectorFactory(cfm, expectedType, defs, boundNames);</span>
        }

        @Override
        public AbstractType&lt;?&gt; getExactTypeIfKnown(String keyspace)
        {
            // TODO try to pass in a target to this API
            // default to list when type is being infered
<span class="fc" id="L767">            return new WithList(selectables).getExactTypeIfKnown(keyspace);</span>
        }

        @Override
        public AbstractType&lt;?&gt; getCompatibleTypeIfKnown(String keyspace)
        {
            // TODO try to pass in a target to this API
            // default to list when type is being infered
<span class="fc" id="L775">            return new WithList(selectables).getCompatibleTypeIfKnown(keyspace);</span>
        }

        @Override
        public boolean selectColumns(Predicate&lt;ColumnMetadata&gt; predicate)
        {
<span class="nc" id="L781">            return Selectable.selectColumns(selectables, predicate);</span>
        }

        @Override
        public String toString()
        {
<span class="fc" id="L787">            return Lists.listToString(selectables);</span>
        }

        public int getSize()
        {
<span class="fc" id="L792">            return selectables.size();</span>
        }

        public static class Raw implements Selectable.Raw
        {
            private final List&lt;Selectable.Raw&gt; raws;

            public Raw(List&lt;Selectable.Raw&gt; raws)
<span class="fc" id="L800">            {</span>
<span class="fc" id="L801">                this.raws = raws;</span>
<span class="fc" id="L802">            }</span>

            @Override
            public Selectable prepare(TableMetadata cfm)
            {
<span class="fc" id="L807">                return new WithArrayLiteral(raws.stream().map(p -&gt; p.prepare(cfm)).collect(Collectors.toList()));</span>
            }
        }
    }

    public static class WithList extends WithArrayLiteral
    {
        public WithList(List&lt;Selectable&gt; selectables)
        {
<span class="fc" id="L816">            super(selectables);</span>
<span class="fc" id="L817">        }</span>

        @Override
        public TestResult testAssignment(String keyspace, ColumnSpecification receiver)
        {
<span class="fc" id="L822">            return Lists.testListAssignment(receiver, selectables);</span>
        }

        @Override
        public Factory newSelectorFactory(TableMetadata cfm,
                                          AbstractType&lt;?&gt; expectedType,
                                          List&lt;ColumnMetadata&gt; defs,
                                          VariableSpecifications boundNames)
        {
<span class="fc" id="L831">            AbstractType&lt;?&gt; type = getExactTypeIfKnown(cfm.keyspace);</span>
<span class="fc bfc" id="L832" title="All 2 branches covered.">            if (type == null)</span>
            {
<span class="fc" id="L834">                type = expectedType;</span>
<span class="fc bfc" id="L835" title="All 2 branches covered.">                if (type == null)</span>
<span class="fc" id="L836">                    throw invalidRequest(&quot;Cannot infer type for term %s in selection clause (try using a cast to force a type)&quot;,</span>
                                         this);
            }

<span class="fc" id="L840">            ListType&lt;?&gt; listType = (ListType&lt;?&gt;) type;</span>

<span class="fc" id="L842">            List&lt;AbstractType&lt;?&gt;&gt; expectedTypes = new ArrayList&lt;&gt;(selectables.size());</span>
<span class="fc bfc" id="L843" title="All 2 branches covered.">            for (int i = 0, m = selectables.size(); i &lt; m; i++)</span>
<span class="fc" id="L844">                expectedTypes.add(listType.getElementsType());</span>

<span class="fc" id="L846">            SelectorFactories factories = createFactoriesAndCollectColumnDefinitions(selectables,</span>
                                                                                     expectedTypes,
                                                                                     cfm,
                                                                                     defs,
                                                                                     boundNames);
<span class="fc" id="L851">            return ListSelector.newFactory(type, factories);</span>
        }

        @Override
        public AbstractType&lt;?&gt; getExactTypeIfKnown(String keyspace)
        {
<span class="fc" id="L857">            return Lists.getExactListTypeIfKnown(selectables, p -&gt; p.getExactTypeIfKnown(keyspace));</span>
        }

        @Override
        public AbstractType&lt;?&gt; getCompatibleTypeIfKnown(String keyspace)
        {
<span class="fc" id="L863">            return Lists.getPreferredCompatibleType(selectables, p -&gt; p.getCompatibleTypeIfKnown(keyspace));</span>
        }

        @Override
        public boolean selectColumns(Predicate&lt;ColumnMetadata&gt; predicate)
        {
<span class="nc" id="L869">            return Selectable.selectColumns(selectables, predicate);</span>
        }

        @Override
        public String toString()
        {
<span class="fc" id="L875">            return Lists.listToString(selectables);</span>
        }
    }

    public static class WithVector extends WithArrayLiteral
    {
        public WithVector(List&lt;Selectable&gt; selectables)
        {
<span class="fc" id="L883">            super(selectables);</span>
<span class="fc" id="L884">        }</span>

        @Override
        public TestResult testAssignment(String keyspace, ColumnSpecification receiver)
        {
<span class="fc" id="L889">            return Vectors.testVectorAssignment(receiver, selectables);</span>
        }

        @Override
        public Factory newSelectorFactory(TableMetadata cfm,
                                          AbstractType&lt;?&gt; expectedType,
                                          List&lt;ColumnMetadata&gt; defs,
                                          VariableSpecifications boundNames)
        {
<span class="fc" id="L898">            AbstractType&lt;?&gt; type = getExactTypeIfKnown(cfm.keyspace);</span>
<span class="pc bpc" id="L899" title="1 of 2 branches missed.">            if (type == null)</span>
            {
<span class="fc" id="L901">                type = expectedType;</span>
<span class="pc bpc" id="L902" title="1 of 2 branches missed.">                if (type == null)</span>
<span class="nc" id="L903">                    throw invalidRequest(&quot;Cannot infer type for term %s in selection clause (try using a cast to force a type)&quot;,</span>
                                         this);
            }

<span class="fc" id="L907">            VectorType&lt;?&gt; vectorType = (VectorType&lt;?&gt;) type;</span>
<span class="fc bfc" id="L908" title="All 2 branches covered.">            if (vectorType.dimension != selectables.size())</span>
<span class="fc" id="L909">                throw invalidRequest(&quot;Unable to create a vector selector of type %s from %d elements&quot;, vectorType.asCQL3Type(), selectables.size());</span>

<span class="fc" id="L911">            List&lt;AbstractType&lt;?&gt;&gt; expectedTypes = new ArrayList&lt;&gt;(selectables.size());</span>
<span class="fc bfc" id="L912" title="All 2 branches covered.">            for (int i = 0, m = selectables.size(); i &lt; m; i++)</span>
<span class="fc" id="L913">                expectedTypes.add(vectorType.getElementsType());</span>

<span class="fc" id="L915">            SelectorFactories factories = createFactoriesAndCollectColumnDefinitions(selectables,</span>
                                                                                     expectedTypes,
                                                                                     cfm,
                                                                                     defs,
                                                                                     boundNames);
<span class="fc" id="L920">            return VectorSelector.newFactory(type, factories);</span>
        }

        @Override
        public AbstractType&lt;?&gt; getExactTypeIfKnown(String keyspace)
        {
<span class="fc" id="L926">            return Vectors.getExactVectorTypeIfKnown(selectables, p -&gt; p.getExactTypeIfKnown(keyspace));</span>
        }

        @Override
        public AbstractType&lt;?&gt; getCompatibleTypeIfKnown(String keyspace)
        {
<span class="nc" id="L932">            return Vectors.getPreferredCompatibleType(selectables, p -&gt; p.getCompatibleTypeIfKnown(keyspace));</span>
        }

        @Override
        public boolean selectColumns(Predicate&lt;ColumnMetadata&gt; predicate)
        {
<span class="nc" id="L938">            return Selectable.selectColumns(selectables, predicate);</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L944">            return Lists.listToString(selectables);</span>
        }
    }

    /**
     * &lt;code&gt;Selectable&lt;/code&gt; for literal Sets.
     */
    public static class WithSet implements Selectable
    {
        /**
         * The set elements
         */
        private final List&lt;Selectable&gt; selectables;

        public WithSet(List&lt;Selectable&gt; selectables)
<span class="fc" id="L959">        {</span>
<span class="fc" id="L960">            this.selectables = selectables;</span>
<span class="fc" id="L961">        }</span>

        @Override
        public TestResult testAssignment(String keyspace, ColumnSpecification receiver)
        {
<span class="fc" id="L966">            return Sets.testSetAssignment(receiver, selectables);</span>
        }

        @Override
        public Factory newSelectorFactory(TableMetadata cfm,
                                          AbstractType&lt;?&gt; expectedType,
                                          List&lt;ColumnMetadata&gt; defs,
                                          VariableSpecifications boundNames)
        {
<span class="fc" id="L975">            AbstractType&lt;?&gt; type = getExactTypeIfKnown(cfm.keyspace);</span>
<span class="fc bfc" id="L976" title="All 2 branches covered.">            if (type == null)</span>
            {
<span class="fc" id="L978">                type = expectedType;</span>
<span class="fc bfc" id="L979" title="All 2 branches covered.">                if (type == null)</span>
<span class="fc" id="L980">                    throw invalidRequest(&quot;Cannot infer type for term %s in selection clause (try using a cast to force a type)&quot;,</span>
                                         this);
            }

            // The parser treats empty Maps as Sets so if the type is a MapType we know that the Map is empty
<span class="fc bfc" id="L985" title="All 2 branches covered.">            if (type instanceof MapType)</span>
<span class="fc" id="L986">                return MapSelector.newFactory(type, Collections.emptyList());</span>

<span class="fc" id="L988">            SetType&lt;?&gt; setType = (SetType&lt;?&gt;) type;</span>

<span class="fc bfc" id="L990" title="All 2 branches covered.">            if (setType.getElementsType() == DurationType.instance)</span>
<span class="fc" id="L991">                throw invalidRequest(&quot;Durations are not allowed inside sets: %s&quot;, setType.asCQL3Type());</span>

<span class="fc" id="L993">            List&lt;AbstractType&lt;?&gt;&gt; expectedTypes = new ArrayList&lt;&gt;(selectables.size());</span>
<span class="fc bfc" id="L994" title="All 2 branches covered.">            for (int i = 0, m = selectables.size(); i &lt; m; i++)</span>
<span class="fc" id="L995">                expectedTypes.add(setType.getElementsType());</span>

<span class="fc" id="L997">            SelectorFactories factories = createFactoriesAndCollectColumnDefinitions(selectables,</span>
                                                                                     expectedTypes,
                                                                                     cfm,
                                                                                     defs,
                                                                                     boundNames);

<span class="fc" id="L1003">            return SetSelector.newFactory(type, factories);</span>
        }

        @Override
        public AbstractType&lt;?&gt; getExactTypeIfKnown(String keyspace)
        {
<span class="fc" id="L1009">            return Sets.getExactSetTypeIfKnown(selectables, p -&gt; p.getExactTypeIfKnown(keyspace));</span>
        }

        @Override
        public AbstractType&lt;?&gt; getCompatibleTypeIfKnown(String keyspace)
        {
<span class="fc" id="L1015">            return Sets.getPreferredCompatibleType(selectables, p -&gt; p.getCompatibleTypeIfKnown(keyspace));</span>
        }

        @Override
        public boolean selectColumns(Predicate&lt;ColumnMetadata&gt; predicate)
        {
<span class="nc" id="L1021">            return Selectable.selectColumns(selectables, predicate);</span>
        }

        @Override
        public String toString()
        {
<span class="fc" id="L1027">            return Sets.setToString(selectables);</span>
        }

        public static class Raw implements Selectable.Raw
        {
            private final List&lt;Selectable.Raw&gt; raws;

            public Raw(List&lt;Selectable.Raw&gt; raws)
<span class="fc" id="L1035">            {</span>
<span class="fc" id="L1036">                this.raws = raws;</span>
<span class="fc" id="L1037">            }</span>

            @Override
            public Selectable prepare(TableMetadata cfm)
            {
<span class="fc" id="L1042">                return new WithSet(raws.stream().map(p -&gt; p.prepare(cfm)).collect(Collectors.toList()));</span>
            }
        }
    }

    /**
     * {@code Selectable} for literal Maps or UDTs.
     * &lt;p&gt;The parser cannot differentiate between a Map or a UDT in the selection cause because a
     * {@code ColumnIdentifier} is equivalent to a {@code FieldIdentifier} from a syntax point of view.
     * By consequence, we are forced to wait until the type is known to be able to differentiate them.&lt;/p&gt;
     */
    public static class WithMapOrUdt implements Selectable
    {
        /**
         * The column family metadata. We need to store them to be able to build the proper data once the type has been
         * identified.
         */
        private final TableMetadata cfm;

        /**
         * The Map or UDT raw elements.
         */
        private final List&lt;Pair&lt;Selectable.Raw, Selectable.Raw&gt;&gt; raws;

        public WithMapOrUdt(TableMetadata cfm, List&lt;Pair&lt;Selectable.Raw, Selectable.Raw&gt;&gt; raws)
<span class="fc" id="L1067">        {</span>
<span class="fc" id="L1068">            this.cfm = cfm;</span>
<span class="fc" id="L1069">            this.raws = raws;</span>
<span class="fc" id="L1070">        }</span>

        @Override
        public TestResult testAssignment(String keyspace, ColumnSpecification receiver)
        {
<span class="fc bfc" id="L1075" title="All 2 branches covered.">            return receiver.type.isUDT() ? UserTypes.testUserTypeAssignment(receiver, getUdtFields((UserType) receiver.type))</span>
<span class="fc" id="L1076">                                         : Maps.testMapAssignment(receiver, getMapEntries(cfm));</span>
        }

        @Override
        public Factory newSelectorFactory(TableMetadata cfm,
                                          AbstractType&lt;?&gt; expectedType,
                                          List&lt;ColumnMetadata&gt; defs,
                                          VariableSpecifications boundNames)
        {
<span class="fc" id="L1085">            AbstractType&lt;?&gt; type = getExactTypeIfKnown(cfm.keyspace);</span>
<span class="pc bpc" id="L1086" title="1 of 2 branches missed.">            if (type == null)</span>
            {
<span class="fc" id="L1088">                type = expectedType;</span>
<span class="fc bfc" id="L1089" title="All 2 branches covered.">                if (type == null)</span>
<span class="fc" id="L1090">                    throw invalidRequest(&quot;Cannot infer type for term %s in selection clause (try using a cast to force a type)&quot;,</span>
                                         this);
            }

<span class="fc bfc" id="L1094" title="All 2 branches covered.">            if (type.isUDT())</span>
<span class="fc" id="L1095">                return newUdtSelectorFactory(cfm, expectedType, defs, boundNames);</span>

<span class="fc" id="L1097">            return newMapSelectorFactory(cfm, defs, boundNames, type);</span>
        }

        private Factory newMapSelectorFactory(TableMetadata cfm,
                                              List&lt;ColumnMetadata&gt; defs,
                                              VariableSpecifications boundNames,
                                              AbstractType&lt;?&gt; type)
        {
<span class="fc" id="L1105">            MapType&lt;?, ?&gt; mapType = (MapType&lt;?, ?&gt;) type;</span>

<span class="pc bpc" id="L1107" title="1 of 2 branches missed.">            if (mapType.getKeysType() == DurationType.instance)</span>
<span class="nc" id="L1108">                throw invalidRequest(&quot;Durations are not allowed as map keys: %s&quot;, mapType.asCQL3Type());</span>

<span class="fc" id="L1110">            return MapSelector.newFactory(type, getMapEntries(cfm).stream()</span>
<span class="fc" id="L1111">                                                                  .map(p -&gt; Pair.create(p.left.newSelectorFactory(cfm, mapType.getKeysType(), defs, boundNames),</span>
<span class="fc" id="L1112">                                                                                        p.right.newSelectorFactory(cfm, mapType.getValuesType(), defs, boundNames)))</span>
<span class="fc" id="L1113">                                                                  .collect(Collectors.toList()));</span>
        }

        private Factory newUdtSelectorFactory(TableMetadata cfm,
                                              AbstractType&lt;?&gt; expectedType,
                                              List&lt;ColumnMetadata&gt; defs,
                                              VariableSpecifications boundNames)
        {
<span class="fc" id="L1121">            UserType ut = (UserType) expectedType;</span>
<span class="fc" id="L1122">            Map&lt;FieldIdentifier, Factory&gt; factories = new LinkedHashMap&lt;&gt;(ut.size());</span>

<span class="fc bfc" id="L1124" title="All 2 branches covered.">            for (Pair&lt;Selectable.Raw, Selectable.Raw&gt; raw : raws)</span>
            {
<span class="pc bpc" id="L1126" title="1 of 2 branches missed.">                if (!(raw.left instanceof RawIdentifier))</span>
<span class="nc" id="L1127">                    throw invalidRequest(&quot;%s is not a valid field identifier of type %s &quot;,</span>
                                         raw.left,
<span class="nc" id="L1129">                                         ut.getNameAsString());</span>

<span class="fc" id="L1131">                FieldIdentifier fieldName = ((RawIdentifier) raw.left).toFieldIdentifier();</span>
<span class="fc" id="L1132">                int fieldPosition = ut.fieldPosition(fieldName);</span>

<span class="pc bpc" id="L1134" title="1 of 2 branches missed.">                if (fieldPosition == -1)</span>
<span class="nc" id="L1135">                    throw invalidRequest(&quot;Unknown field '%s' in value of user defined type %s&quot;,</span>
                                         fieldName,
<span class="nc" id="L1137">                                         ut.getNameAsString());</span>

<span class="fc" id="L1139">                AbstractType&lt;?&gt; fieldType = ut.fieldType(fieldPosition);</span>
<span class="fc" id="L1140">                factories.put(fieldName,</span>
<span class="fc" id="L1141">                              raw.right.prepare(cfm).newSelectorFactory(cfm, fieldType, defs, boundNames));</span>
<span class="fc" id="L1142">            }</span>

<span class="fc" id="L1144">            return UserTypeSelector.newFactory(expectedType, factories);</span>
        }

        @Override
        public AbstractType&lt;?&gt; getExactTypeIfKnown(String keyspace)
        {
            // Let's force the user to specify the type.
<span class="fc" id="L1151">            return null;</span>
        }

        @Override
        public AbstractType&lt;?&gt; getCompatibleTypeIfKnown(String keyspace)
        {
            // Let's force the user to specify the type.
<span class="fc" id="L1158">            return null;</span>
        }

        @Override
        public boolean selectColumns(Predicate&lt;ColumnMetadata&gt; predicate)
        {
<span class="nc bnc" id="L1164" title="All 2 branches missed.">            for (Pair&lt;Selectable.Raw, Selectable.Raw&gt; raw : raws)</span>
            {
<span class="nc bnc" id="L1166" title="All 4 branches missed.">                if (!(raw.left instanceof RawIdentifier) &amp;&amp; raw.left.prepare(cfm).selectColumns(predicate))</span>
<span class="nc" id="L1167">                    return true;</span>

<span class="nc bnc" id="L1169" title="All 2 branches missed.">                if (!raw.right.prepare(cfm).selectColumns(predicate))</span>
<span class="nc" id="L1170">                    return true;</span>
<span class="nc" id="L1171">            }</span>
<span class="nc" id="L1172">            return false;</span>
        }

        @Override
        public String toString()
        {
<span class="fc" id="L1178">            return raws.stream()</span>
<span class="fc" id="L1179">                       .map(p -&gt; String.format(&quot;%s: %s&quot;,</span>
<span class="fc bfc" id="L1180" title="All 2 branches covered.">                                               p.left instanceof RawIdentifier ? p.left : p.left.prepare(cfm),</span>
<span class="fc" id="L1181">                                               p.right.prepare(cfm)))</span>
<span class="fc" id="L1182">                       .collect(Collectors.joining(&quot;, &quot;, &quot;{&quot;, &quot;}&quot;));</span>
        }

        private List&lt;Pair&lt;Selectable, Selectable&gt;&gt; getMapEntries(TableMetadata cfm)
        {
<span class="fc" id="L1187">            return raws.stream()</span>
<span class="fc" id="L1188">                       .map(p -&gt; Pair.create(p.left.prepare(cfm), p.right.prepare(cfm)))</span>
<span class="fc" id="L1189">                       .collect(Collectors.toList());</span>
        }

        private Map&lt;FieldIdentifier, Selectable&gt; getUdtFields(UserType ut)
        {
<span class="fc" id="L1194">            Map&lt;FieldIdentifier, Selectable&gt; fields = new LinkedHashMap&lt;&gt;(ut.size());</span>

<span class="fc bfc" id="L1196" title="All 2 branches covered.">            for (Pair&lt;Selectable.Raw, Selectable.Raw&gt; raw : raws)</span>
            {
<span class="pc bpc" id="L1198" title="1 of 2 branches missed.">                if (!(raw.left instanceof RawIdentifier))</span>
<span class="nc" id="L1199">                    throw invalidRequest(&quot;%s is not a valid field identifier of type %s &quot;,</span>
                                         raw.left,
<span class="nc" id="L1201">                                         ut.getNameAsString());</span>

<span class="fc" id="L1203">                FieldIdentifier fieldName = ((RawIdentifier) raw.left).toFieldIdentifier();</span>
<span class="fc" id="L1204">                int fieldPosition = ut.fieldPosition(fieldName);</span>

<span class="pc bpc" id="L1206" title="1 of 2 branches missed.">                if (fieldPosition == -1)</span>
<span class="nc" id="L1207">                    throw invalidRequest(&quot;Unknown field '%s' in value of user defined type %s&quot;,</span>
                                         fieldName,
<span class="nc" id="L1209">                                         ut.getNameAsString());</span>

<span class="fc" id="L1211">                fields.put(fieldName, raw.right.prepare(cfm));</span>
<span class="fc" id="L1212">            }</span>

<span class="fc" id="L1214">            return fields;</span>
        }

        public static class Raw implements Selectable.Raw
        {
            private final List&lt;Pair&lt;Selectable.Raw, Selectable.Raw&gt;&gt; raws;

            public Raw(List&lt;Pair&lt;Selectable.Raw, Selectable.Raw&gt;&gt; raws)
<span class="fc" id="L1222">            {</span>
<span class="fc" id="L1223">                this.raws = raws;</span>
<span class="fc" id="L1224">            }</span>

            @Override
            public Selectable prepare(TableMetadata cfm)
            {
<span class="fc" id="L1229">                return new WithMapOrUdt(cfm, raws);</span>
            }
        }
    }

    /**
     * &lt;code&gt;Selectable&lt;/code&gt; for type hints (e.g. (int) ?).
     */
    public static class WithTypeHint implements Selectable
    {

        /**
         * The name of the type as specified in the query.
         */
        private final String typeName;

        /**
         * The type specified by the hint.
         */
        private final AbstractType&lt;?&gt; type;

       /**
         * The selectable to which the hint should be applied.
         */
        private final Selectable selectable;

        public WithTypeHint(String typeName, AbstractType&lt;?&gt; type, Selectable selectable)
<span class="fc" id="L1256">        {</span>
<span class="fc" id="L1257">            this.typeName = typeName;</span>
<span class="fc" id="L1258">            this.type = type;</span>
<span class="fc" id="L1259">            this.selectable = selectable;</span>
<span class="fc" id="L1260">        }</span>

        @Override
        public TestResult testAssignment(String keyspace, ColumnSpecification receiver)
        {
<span class="fc bfc" id="L1265" title="All 2 branches covered.">            if (receiver.type.equals(type))</span>
<span class="fc" id="L1266">                return AssignmentTestable.TestResult.EXACT_MATCH;</span>
<span class="fc bfc" id="L1267" title="All 2 branches covered.">            else if (receiver.type.isValueCompatibleWith(type))</span>
<span class="fc" id="L1268">                return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;</span>
            else
<span class="fc" id="L1270">                return AssignmentTestable.TestResult.NOT_ASSIGNABLE;</span>
        }

        @Override
        public Factory newSelectorFactory(TableMetadata cfm,
                                          AbstractType&lt;?&gt; expectedType,
                                          List&lt;ColumnMetadata&gt; defs,
                                          VariableSpecifications boundNames)
        {
<span class="fc" id="L1279">            final ColumnSpecification receiver = new ColumnSpecification(cfm.keyspace, cfm.name, new ColumnIdentifier(toString(), true), type);</span>

<span class="pc bpc" id="L1281" title="1 of 2 branches missed.">            if (!selectable.testAssignment(cfm.keyspace, receiver).isAssignable())</span>
<span class="nc" id="L1282">                throw new InvalidRequestException(String.format(&quot;Cannot assign value %s to %s of type %s&quot;, this, receiver.name, receiver.type.asCQL3Type()));</span>

<span class="fc" id="L1284">            final Factory factory = selectable.newSelectorFactory(cfm, type, defs, boundNames);</span>

<span class="fc" id="L1286">            return new ForwardingFactory()</span>
<span class="fc" id="L1287">            {</span>
                protected Factory delegate()
                {
<span class="fc" id="L1290">                    return factory;</span>
                }

                protected AbstractType&lt;?&gt; getReturnType()
                {
<span class="fc" id="L1295">                    return type;</span>
                }

                protected String getColumnName()
                {
<span class="fc" id="L1300">                    return String.format(&quot;(%s)%s&quot;, typeName, factory.getColumnName());</span>
                }
            };
        }

        @Override
        public AbstractType&lt;?&gt; getExactTypeIfKnown(String keyspace)
        {
<span class="fc" id="L1308">            return type;</span>
        }

        @Override
        public boolean selectColumns(Predicate&lt;ColumnMetadata&gt; predicate)
        {
<span class="fc" id="L1314">            return selectable.selectColumns(predicate);</span>
        }

        @Override
        public String toString()
        {
<span class="fc" id="L1320">            return String.format(&quot;(%s)%s&quot;, typeName, selectable);</span>
        }

        public static class Raw implements Selectable.Raw
        {
            private final CQL3Type.Raw typeRaw;

            private final Selectable.Raw raw;

            public Raw( CQL3Type.Raw typeRaw, Selectable.Raw raw)
<span class="fc" id="L1330">            {</span>
<span class="fc" id="L1331">                this.typeRaw = typeRaw;</span>
<span class="fc" id="L1332">                this.raw = raw;</span>
<span class="fc" id="L1333">            }</span>

            public Selectable prepare(TableMetadata cfm)
            {
<span class="fc" id="L1337">                Selectable selectable = raw.prepare(cfm);</span>
<span class="fc" id="L1338">                AbstractType&lt;?&gt; type = this.typeRaw.prepare(cfm.keyspace).getType();</span>
<span class="fc bfc" id="L1339" title="All 2 branches covered.">                if (type.isFreezable())</span>
<span class="fc" id="L1340">                    type = type.freeze();</span>
<span class="fc" id="L1341">                return new WithTypeHint(typeRaw.toString(), type, selectable);</span>
            }
        }
    }

    /**
     * In the selection clause, the parser cannot differentiate between Maps and UDTs as a column identifier and field
     * identifier have the same syntax. By consequence, we need to wait until the type is known to create the proper
     * Object: {@code ColumnMetadata} or {@code FieldIdentifier}.
     */
    public static final class RawIdentifier implements Selectable.Raw
    {
        private final String text;

        private final boolean quoted;

        /**
         * Creates a {@code RawIdentifier} from an unquoted identifier string.
         */
        public static RawIdentifier forUnquoted(String text)
        {
<span class="fc" id="L1362">            return new RawIdentifier(text, false);</span>
        }

        /**
         * Creates a {@code RawIdentifier} from a quoted identifier string.
         */
        public static RawIdentifier forQuoted(String text)
        {
<span class="fc" id="L1370">            return new RawIdentifier(text, true);</span>
        }

        private RawIdentifier(String text, boolean quoted)
<span class="fc" id="L1374">        {</span>
<span class="fc" id="L1375">            this.text = text;</span>
<span class="fc" id="L1376">            this.quoted = quoted;</span>
<span class="fc" id="L1377">        }</span>

        public ColumnMetadata columnMetadata(TableMetadata cfm)
        {
<span class="fc" id="L1381">            return cfm.getExistingColumn(ColumnIdentifier.getInterned(text, quoted));</span>
        }

        @Override
        public Selectable prepare(TableMetadata cfm)
        {
<span class="fc" id="L1387">            return columnMetadata(cfm);</span>
        }

        public FieldIdentifier toFieldIdentifier()
        {
<span class="pc bpc" id="L1392" title="1 of 2 branches missed.">            return quoted ? FieldIdentifier.forQuoted(text)</span>
<span class="fc" id="L1393">                          : FieldIdentifier.forUnquoted(text);</span>
        }

        @Override
        public String toString()
        {
<span class="fc" id="L1399">            return text;</span>
        }
    }

    /**
     * Represents the selection of an element of a collection (eg. c[x]).
     */
<span class="fc" id="L1406">    public static class WithElementSelection implements Selectable</span>
    {
        public final Selectable selected;
        // Note that we can't yet prepare the Term.Raw yet as we need the ColumnSpecificiation corresponding to Selectable, which
        // we'll only know in newSelectorFactory due to functions (which needs the defs passed to newSelectorFactory to resolve which
        // function is called). Note that this doesn't really matter performance wise since the factories are still created during
        // preparation of the corresponding SelectStatement.
        public final Term.Raw element;

        private WithElementSelection(Selectable selected, Term.Raw element)
<span class="fc" id="L1416">        {</span>
<span class="pc bpc" id="L1417" title="1 of 2 branches missed.">            assert element != null;</span>
<span class="fc" id="L1418">            this.selected = selected;</span>
<span class="fc" id="L1419">            this.element = element;</span>
<span class="fc" id="L1420">        }</span>

        @Override
        public String toString()
        {
<span class="fc" id="L1425">            return String.format(&quot;%s[%s]&quot;, selected, element);</span>
        }

        public Selector.Factory newSelectorFactory(TableMetadata cfm, AbstractType&lt;?&gt; expectedType, List&lt;ColumnMetadata&gt; defs, VariableSpecifications boundNames)
        {
<span class="fc" id="L1430">            Selector.Factory factory = selected.newSelectorFactory(cfm, null, defs, boundNames);</span>
<span class="fc" id="L1431">            ColumnSpecification receiver = factory.getColumnSpecification(cfm);</span>

<span class="fc" id="L1433">            AbstractType&lt;?&gt; type = receiver.type;</span>
<span class="fc bfc" id="L1434" title="All 2 branches covered.">            if (receiver.isReversedType())</span>
            {
<span class="fc" id="L1436">                type = ((ReversedType&lt;?&gt;) type).baseType;</span>
            }
<span class="pc bpc" id="L1438" title="1 of 2 branches missed.">            if (!(type instanceof CollectionType))</span>
<span class="nc" id="L1439">                throw new InvalidRequestException(String.format(&quot;Invalid element selection: %s is of type %s is not a collection&quot;, selected, type.asCQL3Type()));</span>

<span class="fc" id="L1441">            ColumnSpecification boundSpec = specForElementOrSlice(selected, receiver, ((CollectionType) type).kind, &quot;Element&quot;);</span>

<span class="fc" id="L1443">            Term elt = element.prepare(cfm.keyspace, boundSpec);</span>
<span class="fc" id="L1444">            elt.collectMarkerSpecification(boundNames);</span>
<span class="fc" id="L1445">            return ElementsSelector.newElementFactory(toString(), factory, (CollectionType)type, elt);</span>
        }

        public AbstractType&lt;?&gt; getExactTypeIfKnown(String keyspace)
        {
<span class="fc" id="L1450">            AbstractType&lt;?&gt; selectedType = selected.getExactTypeIfKnown(keyspace);</span>
<span class="pc bpc" id="L1451" title="2 of 4 branches missed.">            if (selectedType == null || !(selectedType instanceof CollectionType))</span>
<span class="nc" id="L1452">                return null;</span>

<span class="fc" id="L1454">            return ElementsSelector.valueType((CollectionType) selectedType);</span>
        }

        @Override
        public boolean selectColumns(Predicate&lt;ColumnMetadata&gt; predicate)
        {
<span class="fc" id="L1460">            return selected.selectColumns(predicate);</span>
        }

        public static class Raw implements Selectable.Raw
        {
            private final Selectable.Raw selected;
            private final Term.Raw element;

            public Raw(Selectable.Raw selected, Term.Raw element)
<span class="fc" id="L1469">            {</span>
<span class="fc" id="L1470">                this.selected = selected;</span>
<span class="fc" id="L1471">                this.element = element;</span>
<span class="fc" id="L1472">            }</span>

            public WithElementSelection prepare(TableMetadata cfm)
            {
<span class="fc" id="L1476">                return new WithElementSelection(selected.prepare(cfm), element);</span>
            }

            @Override
            public String toString()
            {
<span class="fc" id="L1482">                return String.format(&quot;%s[%s]&quot;, selected, element);</span>
            }
        }
    }

    /**
     * Represents the selection of a slice of a collection (eg. c[x..y]).
     */
    public static class WithSliceSelection implements Selectable
    {
        public final Selectable selected;
        // Note that we can't yet prepare the Term.Raw yet as we need the ColumnSpecificiation corresponding to Selectable, which
        // we'll only know in newSelectorFactory due to functions (which needs the defs passed to newSelectorFactory to resolve which
        // function is called). Note that this doesn't really matter performance wise since the factories are still created during
        // preparation of the corresponding SelectStatement.
        // Both from and to can be null if they haven't been provided
        public final Term.Raw from;
        public final Term.Raw to;

        private WithSliceSelection(Selectable selected, Term.Raw from, Term.Raw to)
<span class="fc" id="L1502">        {</span>
<span class="fc" id="L1503">            this.selected = selected;</span>
<span class="fc" id="L1504">            this.from = from;</span>
<span class="fc" id="L1505">            this.to = to;</span>
<span class="fc" id="L1506">        }</span>

        @Override
        public String toString()
        {
<span class="fc bfc" id="L1511" title="All 4 branches covered.">            return String.format(&quot;%s[%s..%s]&quot;, selected, from == null ? &quot;&quot; : from, to == null ? &quot;&quot; : to);</span>
        }

        public Selector.Factory newSelectorFactory(TableMetadata cfm, AbstractType&lt;?&gt; expectedType, List&lt;ColumnMetadata&gt; defs, VariableSpecifications boundNames)
        {
            // Note that a slice gives you the same type as the collection you applied it to, so we can pass expectedType for selected directly
<span class="fc" id="L1517">            Selector.Factory factory = selected.newSelectorFactory(cfm, expectedType, defs, boundNames);</span>
<span class="fc" id="L1518">            ColumnSpecification receiver = factory.getColumnSpecification(cfm);</span>

<span class="fc" id="L1520">            AbstractType&lt;?&gt; type = receiver.type;</span>
<span class="fc bfc" id="L1521" title="All 2 branches covered.">            if (receiver.isReversedType())</span>
            {
<span class="fc" id="L1523">                type = ((ReversedType&lt;?&gt;) type).baseType;</span>
            }
<span class="pc bpc" id="L1525" title="1 of 2 branches missed.">            if (!(type instanceof CollectionType))</span>
<span class="nc" id="L1526">                throw new InvalidRequestException(String.format(&quot;Invalid slice selection: %s of type %s is not a collection&quot;, selected, type.asCQL3Type()));</span>

<span class="fc" id="L1528">            ColumnSpecification boundSpec = specForElementOrSlice(selected, receiver, ((CollectionType) type).kind, &quot;Slice&quot;);</span>

            // If from or to are null, this means the user didn't provide on in the syntax (we had c[x..] or c[..x]).
            // The equivalent of doing this when preparing values would be to use UNSET.
<span class="fc bfc" id="L1532" title="All 2 branches covered.">            Term f = from == null ? Constants.UNSET_VALUE : from.prepare(cfm.keyspace, boundSpec);</span>
<span class="fc bfc" id="L1533" title="All 2 branches covered.">            Term t = to == null ? Constants.UNSET_VALUE : to.prepare(cfm.keyspace, boundSpec);</span>
<span class="fc" id="L1534">            f.collectMarkerSpecification(boundNames);</span>
<span class="fc" id="L1535">            t.collectMarkerSpecification(boundNames);</span>
<span class="fc" id="L1536">            return ElementsSelector.newSliceFactory(toString(), factory, (CollectionType)type, f, t);</span>
        }

        public AbstractType&lt;?&gt; getExactTypeIfKnown(String keyspace)
        {
<span class="nc" id="L1541">            AbstractType&lt;?&gt; selectedType = selected.getExactTypeIfKnown(keyspace);</span>
<span class="nc bnc" id="L1542" title="All 4 branches missed.">            if (selectedType == null || !(selectedType instanceof CollectionType))</span>
<span class="nc" id="L1543">                return null;</span>

<span class="nc" id="L1545">            return selectedType;</span>
        }

        @Override
        public boolean selectColumns(Predicate&lt;ColumnMetadata&gt; predicate)
        {
<span class="fc" id="L1551">            return selected.selectColumns(predicate);</span>
        }

        public static class Raw implements Selectable.Raw
        {
            private final Selectable.Raw selected;
            // Both from and to can be null if they haven't been provided
            private final Term.Raw from;
            private final Term.Raw to;

            public Raw(Selectable.Raw selected, Term.Raw from, Term.Raw to)
<span class="fc" id="L1562">            {</span>
<span class="fc" id="L1563">                this.selected = selected;</span>
<span class="fc" id="L1564">                this.from = from;</span>
<span class="fc" id="L1565">                this.to = to;</span>
<span class="fc" id="L1566">            }</span>

            public WithSliceSelection prepare(TableMetadata cfm)
            {
<span class="fc" id="L1570">                return new WithSliceSelection(selected.prepare(cfm), from, to);</span>
            }

            @Override
            public String toString()
            {
<span class="pc bpc" id="L1576" title="2 of 4 branches missed.">                return String.format(&quot;%s[%s..%s]&quot;, selected, from == null ? &quot;&quot; : from, to == null ? &quot;&quot; : to);</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>