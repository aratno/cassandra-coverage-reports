<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SSTableImporter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db</a> &gt; <span class="el_source">SSTableImporter.java</span></div><h1>SSTableImporter.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.db;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

import com.google.common.annotations.VisibleForTesting;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.db.lifecycle.SSTableSet;
import org.apache.cassandra.io.sstable.Component;
import org.apache.cassandra.io.sstable.Descriptor;
import org.apache.cassandra.io.sstable.IVerifier;
import org.apache.cassandra.io.sstable.KeyIterator;
import org.apache.cassandra.io.sstable.SSTable;
import org.apache.cassandra.io.sstable.format.SSTableFormat.Components;
import org.apache.cassandra.io.sstable.format.SSTableReader;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.service.ActiveRepairService;
import org.apache.cassandra.service.StorageService;
import org.apache.cassandra.utils.OutputHandler;
import org.apache.cassandra.utils.Pair;
import org.apache.cassandra.utils.concurrent.Refs;

public class SSTableImporter
{
<span class="fc" id="L51">    private static final Logger logger = LoggerFactory.getLogger(ColumnFamilyStore.class);</span>

    private final ColumnFamilyStore cfs;

    public SSTableImporter(ColumnFamilyStore cfs)
<span class="fc" id="L56">    {</span>
<span class="fc" id="L57">        this.cfs = cfs;</span>
<span class="fc" id="L58">    }</span>

    /**
     * Imports sstables from the directories given in options.srcPaths
     *
     * If import fails in any of the directories, that directory is skipped and the failed directories
     * are returned so that the user can re-upload files or remove corrupt files.
     *
     * If one of the directories in srcPaths is not readable/does not exist, we exit immediately to let
     * the user change permissions or similar on the directory.
     *
     * @param options
     * @return list of failed directories
     */
    @VisibleForTesting
    synchronized List&lt;String&gt; importNewSSTables(Options options)
    {
<span class="fc" id="L75">        UUID importID = UUID.randomUUID();</span>
<span class="fc" id="L76">        logger.info(&quot;[{}] Loading new SSTables for {}/{}: {}&quot;, importID, cfs.getKeyspaceName(), cfs.getTableName(), options);</span>

<span class="fc" id="L78">        List&lt;Pair&lt;Directories.SSTableLister, String&gt;&gt; listers = getSSTableListers(options.srcPaths);</span>

<span class="fc" id="L80">        Set&lt;Descriptor&gt; currentDescriptors = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">        for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))</span>
<span class="fc" id="L82">            currentDescriptors.add(sstable.descriptor);</span>
<span class="fc" id="L83">        List&lt;String&gt; failedDirectories = new ArrayList&lt;&gt;();</span>

        // verify first to avoid starting to copy sstables to the data directories and then have to abort.
<span class="fc bfc" id="L86" title="All 4 branches covered.">        if (options.verifySSTables || options.verifyTokens)</span>
        {
<span class="fc bfc" id="L88" title="All 2 branches covered.">            for (Pair&lt;Directories.SSTableLister, String&gt; listerPair : listers)</span>
            {
<span class="fc" id="L90">                Directories.SSTableLister lister = listerPair.left;</span>
<span class="fc" id="L91">                String dir = listerPair.right;</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">                for (Map.Entry&lt;Descriptor, Set&lt;Component&gt;&gt; entry : lister.list().entrySet())</span>
                {
<span class="fc" id="L94">                    Descriptor descriptor = entry.getKey();</span>
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">                    if (!currentDescriptors.contains(entry.getKey()))</span>
                    {
                        try
                        {
<span class="fc" id="L99">                            abortIfDraining();</span>
<span class="fc" id="L100">                            verifySSTableForImport(descriptor, entry.getValue(), options.verifyTokens, options.verifySSTables, options.extendedVerify);</span>
                        }
<span class="fc" id="L102">                        catch (Throwable t)</span>
                        {
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">                            if (dir != null)</span>
                            {
<span class="fc" id="L106">                                logger.error(&quot;[{}] Failed verifying SSTable {} in directory {}&quot;, importID, descriptor, dir, t);</span>
<span class="fc" id="L107">                                failedDirectories.add(dir);</span>
                            }
                            else
                            {
<span class="nc" id="L111">                                logger.error(&quot;[{}] Failed verifying SSTable {}&quot;, importID, descriptor, t);</span>
<span class="nc" id="L112">                                throw new RuntimeException(&quot;Failed verifying SSTable &quot; + descriptor, t);</span>
                            }
<span class="fc" id="L114">                            break;</span>
<span class="fc" id="L115">                        }</span>
                    }
<span class="fc" id="L117">                }</span>
<span class="fc" id="L118">            }</span>
        }

<span class="fc" id="L121">        Set&lt;SSTableReader&gt; newSSTables = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">        for (Pair&lt;Directories.SSTableLister, String&gt; listerPair : listers)</span>
        {
<span class="fc" id="L124">            Directories.SSTableLister lister = listerPair.left;</span>
<span class="fc" id="L125">            String dir = listerPair.right;</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">            if (failedDirectories.contains(dir))</span>
<span class="fc" id="L127">                continue;</span>

<span class="fc" id="L129">            Set&lt;MovedSSTable&gt; movedSSTables = new HashSet&lt;&gt;();</span>
<span class="fc" id="L130">            Set&lt;SSTableReader&gt; newSSTablesPerDirectory = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">            for (Map.Entry&lt;Descriptor, Set&lt;Component&gt;&gt; entry : lister.list().entrySet())</span>
            {
                try
                {
<span class="fc" id="L135">                    abortIfDraining();</span>
<span class="fc" id="L136">                    Descriptor oldDescriptor = entry.getKey();</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">                    if (currentDescriptors.contains(oldDescriptor))</span>
<span class="fc" id="L138">                        continue;</span>

<span class="fc" id="L140">                    File targetDir = getTargetDirectory(dir, oldDescriptor, entry.getValue());</span>
<span class="fc" id="L141">                    Descriptor newDescriptor = cfs.getUniqueDescriptorFor(entry.getKey(), targetDir);</span>
<span class="fc" id="L142">                    maybeMutateMetadata(entry.getKey(), options);</span>
<span class="fc" id="L143">                    movedSSTables.add(new MovedSSTable(newDescriptor, entry.getKey(), entry.getValue()));</span>
<span class="fc" id="L144">                    SSTableReader sstable = SSTableReader.moveAndOpenSSTable(cfs, entry.getKey(), newDescriptor, entry.getValue(), options.copyData);</span>
<span class="fc" id="L145">                    newSSTablesPerDirectory.add(sstable);</span>
                }
<span class="fc" id="L147">                catch (Throwable t)</span>
                {
<span class="fc" id="L149">                    newSSTablesPerDirectory.forEach(s -&gt; s.selfRef().release());</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">                    if (dir != null)</span>
                    {
<span class="fc" id="L152">                        logger.error(&quot;[{}] Failed importing sstables in directory {}&quot;, importID, dir, t);</span>
<span class="fc" id="L153">                        failedDirectories.add(dir);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">                        if (options.copyData)</span>
                        {
<span class="fc" id="L156">                            removeCopiedSSTables(movedSSTables);</span>
                        }
                        else
                        {
<span class="fc" id="L160">                            moveSSTablesBack(movedSSTables);</span>
                        }
<span class="fc" id="L162">                        movedSSTables.clear();</span>
<span class="fc" id="L163">                        newSSTablesPerDirectory.clear();</span>
<span class="fc" id="L164">                        break;</span>
                    }
                    else
                    {
<span class="fc" id="L168">                        logger.error(&quot;[{}] Failed importing sstables from data directory - renamed SSTables are: {}&quot;, importID, movedSSTables, t);</span>
<span class="fc" id="L169">                        throw new RuntimeException(&quot;Failed importing SSTables&quot;, t);</span>
                    }
<span class="fc" id="L171">                }</span>
<span class="fc" id="L172">            }</span>
<span class="fc" id="L173">            newSSTables.addAll(newSSTablesPerDirectory);</span>
<span class="fc" id="L174">        }</span>

<span class="fc bfc" id="L176" title="All 2 branches covered.">        if (newSSTables.isEmpty())</span>
        {
<span class="fc" id="L178">            logger.info(&quot;[{}] No new SSTables were found for {}/{}&quot;, importID, cfs.getKeyspaceName(), cfs.getTableName());</span>
<span class="fc" id="L179">            return failedDirectories;</span>
        }

<span class="fc" id="L182">        logger.info(&quot;[{}] Loading new SSTables and building secondary indexes for {}/{}: {}&quot;, importID, cfs.getKeyspaceName(), cfs.getTableName(), newSSTables);</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">        if (logger.isTraceEnabled())</span>
<span class="nc" id="L184">            logLeveling(importID, newSSTables);</span>

<span class="fc" id="L186">        try (Refs&lt;SSTableReader&gt; refs = Refs.ref(newSSTables))</span>
        {
<span class="fc" id="L188">            abortIfDraining();</span>

            // Validate existing SSTable-attached indexes, and then build any that are missing:
<span class="fc bfc" id="L191" title="All 2 branches covered.">            if (!cfs.indexManager.validateSSTableAttachedIndexes(newSSTables, false))</span>
<span class="fc" id="L192">                cfs.indexManager.buildSSTableAttachedIndexesBlocking(newSSTables);</span>

<span class="fc" id="L194">            cfs.getTracker().addSSTables(newSSTables);</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">            for (SSTableReader reader : newSSTables)</span>
            {
<span class="fc bfc" id="L197" title="All 4 branches covered.">                if (options.invalidateCaches &amp;&amp; cfs.isRowCacheEnabled())</span>
<span class="fc" id="L198">                    invalidateCachesForSSTable(reader);</span>
<span class="fc" id="L199">            }</span>
        }
<span class="fc" id="L201">        catch (Throwable t)</span>
        {
<span class="fc" id="L203">            logger.error(&quot;[{}] Failed adding SSTables&quot;, importID, t);</span>
<span class="fc" id="L204">            throw new RuntimeException(&quot;Failed adding SSTables&quot;, t);</span>
<span class="fc" id="L205">        }</span>

<span class="fc" id="L207">        logger.info(&quot;[{}] Done loading load new SSTables for {}/{}&quot;, importID, cfs.getKeyspaceName(), cfs.getTableName());</span>
<span class="fc" id="L208">        return failedDirectories;</span>
    }

    /**
     * Check the state of this node and throws an {@link InterruptedException} if it is currently draining
     *
     * @throws InterruptedException if the node is draining
     */
    private static void abortIfDraining() throws InterruptedException
    {
<span class="fc bfc" id="L218" title="All 2 branches covered.">        if (StorageService.instance.isDraining())</span>
<span class="fc" id="L219">            throw new InterruptedException(&quot;SSTables import has been aborted&quot;);</span>
<span class="fc" id="L220">    }</span>

    private void logLeveling(UUID importID, Set&lt;SSTableReader&gt; newSSTables)
    {
<span class="nc" id="L224">        StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">        for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))</span>
<span class="nc" id="L226">            sb.append(formatMetadata(sstable));</span>
<span class="nc" id="L227">        logger.debug(&quot;[{}] Current sstables: {}&quot;, importID, sb);</span>
<span class="nc" id="L228">        sb = new StringBuilder();</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">        for (SSTableReader sstable : newSSTables)</span>
<span class="nc" id="L230">            sb.append(formatMetadata(sstable));</span>
<span class="nc" id="L231">        logger.debug(&quot;[{}] New sstables: {}&quot;, importID, sb);</span>
<span class="nc" id="L232">    }</span>

    private static String formatMetadata(SSTableReader sstable)
    {
<span class="nc" id="L236">        return String.format(&quot;{[%s, %s], %d, %s, %d}&quot;,</span>
<span class="nc" id="L237">                             sstable.getFirst().getToken(),</span>
<span class="nc" id="L238">                             sstable.getLast().getToken(),</span>
<span class="nc" id="L239">                             sstable.getSSTableLevel(),</span>
<span class="nc" id="L240">                             sstable.isRepaired(),</span>
<span class="nc" id="L241">                             sstable.onDiskLength());</span>
    }

    /**
     * Opens the sstablereader described by descriptor and figures out the correct directory for it based
     * on the first token
     *
     * srcPath == null means that the sstable is in a data directory and we can use that directly.
     *
     * If we fail figuring out the directory we will pick the one with the most available disk space.
     */
    private File getTargetDirectory(String srcPath, Descriptor descriptor, Set&lt;Component&gt; components)
    {
<span class="fc bfc" id="L254" title="All 2 branches covered.">        if (srcPath == null)</span>
<span class="fc" id="L255">            return descriptor.directory;</span>

<span class="fc" id="L257">        File targetDirectory = null;</span>
<span class="fc" id="L258">        SSTableReader sstable = null;</span>
        try
        {
<span class="fc" id="L261">            sstable = SSTableReader.open(cfs, descriptor, components, cfs.metadata);</span>
<span class="fc" id="L262">            targetDirectory = cfs.getDirectories().getLocationForDisk(cfs.diskBoundaryManager.getDiskBoundaries(cfs).getCorrectDiskForSSTable(sstable));</span>
        }
        finally
        {
<span class="fc bfc" id="L266" title="All 2 branches covered.">            if (sstable != null)</span>
<span class="fc" id="L267">                sstable.selfRef().release();</span>
        }
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">        return targetDirectory == null ? cfs.getDirectories().getWriteableLocationToLoadFile(descriptor.baseFile()) : targetDirectory;</span>
    }

    /**
     * Create SSTableListers based on srcPaths
     *
     * If srcPaths is empty, we create a lister that lists sstables in the data directories (deprecated use)
     */
    private List&lt;Pair&lt;Directories.SSTableLister, String&gt;&gt; getSSTableListers(Set&lt;String&gt; srcPaths)
    {
<span class="fc" id="L279">        List&lt;Pair&lt;Directories.SSTableLister, String&gt;&gt; listers = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L281" title="All 2 branches covered.">        if (!srcPaths.isEmpty())</span>
        {
<span class="fc bfc" id="L283" title="All 2 branches covered.">            for (String path : srcPaths)</span>
            {
<span class="fc" id="L285">                File dir = new File(path);</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">                if (!dir.exists())</span>
                {
<span class="fc" id="L288">                    throw new RuntimeException(String.format(&quot;Directory %s does not exist&quot;, path));</span>
                }
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">                if (!Directories.verifyFullPermissions(dir, path))</span>
                {
<span class="nc" id="L292">                    throw new RuntimeException(&quot;Insufficient permissions on directory &quot; + path);</span>
                }
<span class="fc" id="L294">                listers.add(Pair.create(cfs.getDirectories().sstableLister(dir, Directories.OnTxnErr.IGNORE).skipTemporary(true), path));</span>
<span class="fc" id="L295">            }</span>
        }
        else
        {
<span class="fc" id="L299">            listers.add(Pair.create(cfs.getDirectories().sstableLister(Directories.OnTxnErr.IGNORE).skipTemporary(true), null));</span>
        }

<span class="fc" id="L302">        return listers;</span>
    }

    private static class MovedSSTable
    {
        private final Descriptor newDescriptor;
        private final Descriptor oldDescriptor;
        private final Set&lt;Component&gt; components;

        private MovedSSTable(Descriptor newDescriptor, Descriptor oldDescriptor, Set&lt;Component&gt; components)
<span class="fc" id="L312">        {</span>
<span class="fc" id="L313">            this.newDescriptor = newDescriptor;</span>
<span class="fc" id="L314">            this.oldDescriptor = oldDescriptor;</span>
<span class="fc" id="L315">            this.components = components;</span>
<span class="fc" id="L316">        }</span>

        public String toString()
        {
<span class="fc" id="L320">            return String.format(&quot;%s moved to %s with components %s&quot;, oldDescriptor, newDescriptor, components);</span>
        }
    }

    /**
     * If we fail when opening the sstable (if for example the user passes in --no-verify and there are corrupt sstables)
     * we might have started copying sstables to the data directory, these need to be moved back to the original name/directory
     */
    private void moveSSTablesBack(Set&lt;MovedSSTable&gt; movedSSTables)
    {
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">        for (MovedSSTable movedSSTable : movedSSTables)</span>
        {
<span class="nc bnc" id="L332" title="All 2 branches missed.">            if (movedSSTable.newDescriptor.fileFor(Components.DATA).exists())</span>
            {
<span class="nc" id="L334">                logger.debug(&quot;Moving sstable {} back to {}&quot;, movedSSTable.newDescriptor.fileFor(Components.DATA)</span>
<span class="nc" id="L335">                                                          , movedSSTable.oldDescriptor.fileFor(Components.DATA));</span>
<span class="nc" id="L336">                SSTable.rename(movedSSTable.newDescriptor, movedSSTable.oldDescriptor, movedSSTable.components);</span>
            }
<span class="nc" id="L338">        }</span>
<span class="fc" id="L339">    }</span>

    /**
     * Similarly for moving case, we need to delete all SSTables which were copied already but the
     * copying as a whole has failed so we do not leave any traces behind such failed import.
     *
     * @param movedSSTables tables we have moved already (by copying) which need to be removed
     */
    private void removeCopiedSSTables(Set&lt;MovedSSTable&gt; movedSSTables)
    {
<span class="fc" id="L349">        logger.debug(&quot;Removing copied SSTables which were left in data directories after failed SSTable import.&quot;);</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">        for (MovedSSTable movedSSTable : movedSSTables)</span>
        {
            // no logging here as for moveSSTablesBack case above as logging is done in delete method
<span class="fc" id="L353">            movedSSTable.newDescriptor.getFormat().delete(movedSSTable.newDescriptor);</span>
<span class="fc" id="L354">        }</span>
<span class="fc" id="L355">    }</span>

    /**
     * Iterates over all keys in the sstable index and invalidates the row cache
     */
    @VisibleForTesting
    void invalidateCachesForSSTable(SSTableReader reader)
    {
<span class="fc" id="L363">        try (KeyIterator iter = reader.keyIterator())</span>
        {
<span class="fc bfc" id="L365" title="All 2 branches covered.">            while (iter.hasNext())</span>
            {
<span class="fc" id="L367">                DecoratedKey decoratedKey = iter.next();</span>
<span class="fc" id="L368">                cfs.invalidateCachedPartition(decoratedKey);</span>
<span class="fc" id="L369">            }</span>
        }
<span class="nc" id="L371">        catch (IOException ex)</span>
        {
<span class="nc" id="L373">            throw new RuntimeException(&quot;Failed to import sstable &quot; + reader.getFilename(), ex);</span>
<span class="fc" id="L374">        }</span>
<span class="fc" id="L375">    }</span>

    /**
     * Verify an sstable for import, throws exception if there is a failure verifying.
     *
     * @param verifyTokens to verify that the tokens are owned by the current node
     * @param verifySSTables to verify the sstables given. If this is false a &quot;quick&quot; verification will be run, just deserializing metadata
     * @param extendedVerify to validate the values in the sstables
     */
    private void verifySSTableForImport(Descriptor descriptor, Set&lt;Component&gt; components, boolean verifyTokens, boolean verifySSTables, boolean extendedVerify)
    {
<span class="fc" id="L386">        SSTableReader reader = null;</span>
        try
        {
<span class="fc" id="L389">            reader = SSTableReader.open(cfs, descriptor, components, cfs.metadata);</span>
<span class="fc" id="L390">            IVerifier.Options verifierOptions = IVerifier.options()</span>
<span class="fc" id="L391">                                                         .extendedVerification(extendedVerify)</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">                                                         .checkOwnsTokens(verifyTokens)</span>
<span class="fc" id="L393">                                                         .quick(!verifySSTables)</span>
<span class="fc" id="L394">                                                         .invokeDiskFailurePolicy(false)</span>
<span class="fc" id="L395">                                                         .mutateRepairStatus(false).build();</span>

<span class="fc" id="L397">            try (IVerifier verifier = reader.getVerifier(cfs, new OutputHandler.LogOutput(), false, verifierOptions))</span>
            {
<span class="fc" id="L399">                verifier.verify();</span>
            }
        }
<span class="fc" id="L402">        catch (Throwable t)</span>
        {
<span class="fc" id="L404">            throw new RuntimeException(&quot;Can't import sstable &quot; + descriptor, t);</span>
        }
        finally
        {
<span class="fc bfc" id="L408" title="All 2 branches covered.">            if (reader != null)</span>
<span class="fc" id="L409">                reader.selfRef().release();</span>
        }
<span class="fc" id="L411">    }</span>

    /**
     * Depending on the options passed in, this might reset level on the sstable to 0 and/or remove the repair information
     * from the sstable
     */
    private void maybeMutateMetadata(Descriptor descriptor, Options options) throws IOException
    {
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">        if (descriptor.fileFor(Components.STATS).exists())</span>
        {
<span class="fc bfc" id="L421" title="All 2 branches covered.">            if (options.resetLevel)</span>
            {
<span class="fc" id="L423">                descriptor.getMetadataSerializer().mutateLevel(descriptor, 0);</span>
            }
<span class="fc bfc" id="L425" title="All 2 branches covered.">            if (options.clearRepaired)</span>
            {
<span class="fc" id="L427">                descriptor.getMetadataSerializer().mutateRepairMetadata(descriptor, ActiveRepairService.UNREPAIRED_SSTABLE,</span>
                                                                        null,
                                                                        false);
            }
        }
<span class="fc" id="L432">    }</span>

    public static class Options
    {
        private final Set&lt;String&gt; srcPaths;
        private final boolean resetLevel;
        private final boolean clearRepaired;
        private final boolean verifySSTables;
        private final boolean verifyTokens;
        private final boolean invalidateCaches;
        private final boolean extendedVerify;
        private final boolean copyData;

        public Options(Set&lt;String&gt; srcPaths, boolean resetLevel, boolean clearRepaired, boolean verifySSTables, boolean verifyTokens, boolean invalidateCaches, boolean extendedVerify, boolean copyData)
<span class="fc" id="L446">        {</span>
<span class="fc" id="L447">            this.srcPaths = srcPaths;</span>
<span class="fc" id="L448">            this.resetLevel = resetLevel;</span>
<span class="fc" id="L449">            this.clearRepaired = clearRepaired;</span>
<span class="fc" id="L450">            this.verifySSTables = verifySSTables;</span>
<span class="fc" id="L451">            this.verifyTokens = verifyTokens;</span>
<span class="fc" id="L452">            this.invalidateCaches = invalidateCaches;</span>
<span class="fc" id="L453">            this.extendedVerify = extendedVerify;</span>
<span class="fc" id="L454">            this.copyData = copyData;</span>
<span class="fc" id="L455">        }</span>

        public static Builder options(String srcDir)
        {
<span class="fc" id="L459">            return new Builder(Collections.singleton(srcDir));</span>
        }

        public static Builder options(Set&lt;String&gt; srcDirs)
        {
<span class="fc" id="L464">            return new Builder(srcDirs);</span>
        }

        public static Builder options()
        {
<span class="fc" id="L469">            return options(Collections.emptySet());</span>
        }

        @Override
        public String toString()
        {
<span class="fc" id="L475">            return &quot;Options{&quot; +</span>
                   &quot;srcPaths='&quot; + srcPaths + '\'' +
                   &quot;, resetLevel=&quot; + resetLevel +
                   &quot;, clearRepaired=&quot; + clearRepaired +
                   &quot;, verifySSTables=&quot; + verifySSTables +
                   &quot;, verifyTokens=&quot; + verifyTokens +
                   &quot;, invalidateCaches=&quot; + invalidateCaches +
                   &quot;, extendedVerify=&quot; + extendedVerify +
                   &quot;, copyData= &quot; + copyData +
                   '}';
        }

<span class="fc" id="L487">        static class Builder</span>
        {
            private final Set&lt;String&gt; srcPaths;
<span class="fc" id="L490">            private boolean resetLevel = false;</span>
<span class="fc" id="L491">            private boolean clearRepaired = false;</span>
<span class="fc" id="L492">            private boolean verifySSTables = false;</span>
<span class="fc" id="L493">            private boolean verifyTokens = false;</span>
<span class="fc" id="L494">            private boolean invalidateCaches = false;</span>
<span class="fc" id="L495">            private boolean extendedVerify = false;</span>
<span class="fc" id="L496">            private boolean copyData = false;</span>

            private Builder(Set&lt;String&gt; srcPath)
<span class="fc" id="L499">            {</span>
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">                assert srcPath != null;</span>
<span class="fc" id="L501">                this.srcPaths = srcPath;</span>
<span class="fc" id="L502">            }</span>

            public Builder resetLevel(boolean value)
            {
<span class="fc" id="L506">                resetLevel = value;</span>
<span class="fc" id="L507">                return this;</span>
            }

            public Builder clearRepaired(boolean value)
            {
<span class="fc" id="L512">                clearRepaired = value;</span>
<span class="fc" id="L513">                return this;</span>
            }

            public Builder verifySSTables(boolean value)
            {
<span class="fc" id="L518">                verifySSTables = value;</span>
<span class="fc" id="L519">                return this;</span>
            }

            public Builder verifyTokens(boolean value)
            {
<span class="fc" id="L524">                verifyTokens = value;</span>
<span class="fc" id="L525">                return this;</span>
            }

            public Builder invalidateCaches(boolean value)
            {
<span class="fc" id="L530">                invalidateCaches = value;</span>
<span class="fc" id="L531">                return this;</span>
            }

            public Builder extendedVerify(boolean value)
            {
<span class="fc" id="L536">                extendedVerify = value;</span>
<span class="fc" id="L537">                return this;</span>
            }

            public Builder copyData(boolean value)
            {
<span class="fc" id="L542">                copyData = value;</span>
<span class="fc" id="L543">                return this;</span>
            }

            public Options build()
            {
<span class="fc" id="L548">                return new Options(srcPaths, resetLevel, clearRepaired, verifySSTables, verifyTokens, invalidateCaches, extendedVerify, copyData);</span>
            }
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>