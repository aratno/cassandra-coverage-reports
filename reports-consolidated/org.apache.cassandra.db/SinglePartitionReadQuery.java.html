<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SinglePartitionReadQuery.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db</a> &gt; <span class="el_source">SinglePartitionReadQuery.java</span></div><h1>SinglePartitionReadQuery.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import com.google.common.collect.Iterables;

import org.apache.commons.lang3.tuple.Pair;

import org.apache.cassandra.db.filter.ClusteringIndexFilter;
import org.apache.cassandra.db.filter.ColumnFilter;
import org.apache.cassandra.db.filter.DataLimits;
import org.apache.cassandra.db.filter.RowFilter;
import org.apache.cassandra.db.partitions.PartitionIterator;
import org.apache.cassandra.db.partitions.UnfilteredPartitionIterator;
import org.apache.cassandra.db.partitions.UnfilteredPartitionIterators;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.service.pager.MultiPartitionPager;
import org.apache.cassandra.service.pager.PagingState;
import org.apache.cassandra.service.pager.QueryPager;
import org.apache.cassandra.service.pager.SinglePartitionPager;
import org.apache.cassandra.transport.ProtocolVersion;

/**
 * A {@code ReadQuery} for a single partition.
 */
public interface SinglePartitionReadQuery extends ReadQuery
{
    public static Group&lt;? extends SinglePartitionReadQuery&gt; createGroup(TableMetadata metadata,
                                                                        long nowInSec,
                                                                        ColumnFilter columnFilter,
                                                                        RowFilter rowFilter,
                                                                        DataLimits limits,
                                                                        List&lt;DecoratedKey&gt; partitionKeys,
                                                                        ClusteringIndexFilter clusteringIndexFilter)
    {
<span class="fc" id="L56">        return SinglePartitionReadCommand.Group.create(metadata, nowInSec, columnFilter, rowFilter, limits, partitionKeys, clusteringIndexFilter);</span>
    }


    /**
     * Creates a new read query on a single partition.
     *
     * @param metadata the table to query.
     * @param nowInSec the time in seconds to use are &quot;now&quot; for this query.
     * @param key the partition key for the partition to query.
     * @param columnFilter the column filter to use for the query.
     * @param filter the clustering index filter to use for the query.
     *
     * @return a newly created read query. The returned query will use no row filter and have no limits.
     */
    public static SinglePartitionReadQuery create(TableMetadata metadata,
                                                  long nowInSec,
                                                  DecoratedKey key,
                                                  ColumnFilter columnFilter,
                                                  ClusteringIndexFilter filter)
    {
<span class="nc" id="L77">        return create(metadata, nowInSec, columnFilter, RowFilter.none(), DataLimits.NONE, key, filter);</span>
    }

    /**
     * Creates a new read query on a single partition.
     *
     * @param metadata the table to query.
     * @param nowInSec the time in seconds to use are &quot;now&quot; for this query.
     * @param columnFilter the column filter to use for the query.
     * @param rowFilter the row filter to use for the query.
     * @param limits the limits to use for the query.
     * @param partitionKey the partition key for the partition to query.
     * @param clusteringIndexFilter the clustering index filter to use for the query.
     *
     * @return a newly created read query.
     */
    public static SinglePartitionReadQuery create(TableMetadata metadata,
                                                  long nowInSec,
                                                  ColumnFilter columnFilter,
                                                  RowFilter rowFilter,
                                                  DataLimits limits,
                                                  DecoratedKey partitionKey,
                                                  ClusteringIndexFilter clusteringIndexFilter)
    {
<span class="nc" id="L101">        return SinglePartitionReadCommand.create(metadata, nowInSec, columnFilter, rowFilter, limits, partitionKey, clusteringIndexFilter);</span>
    }

    /**
     * Returns the key of the partition queried by this {@code ReadQuery}
     * @return the key of the partition queried
     */
    DecoratedKey partitionKey();

    /**
     * Creates a new {@code SinglePartitionReadQuery} with the specified limits.
     *
     * @param newLimits the new limits
     * @return the new {@code SinglePartitionReadQuery}
     */
    SinglePartitionReadQuery withUpdatedLimit(DataLimits newLimits);

    /**
     * Returns a new {@code SinglePartitionReadQuery} suitable to paging from the last returned row.
     *
     * @param lastReturned the last row returned by the previous page. The newly created query
     * will only query row that comes after this (in query order). This can be {@code null} if this
     * is the first page.
     * @param limits the limits to use for the page to query.
     *
     * @return the newly create query.
     */
    SinglePartitionReadQuery forPaging(Clustering&lt;?&gt; lastReturned, DataLimits limits);

    @Override
    default SinglePartitionPager getPager(PagingState pagingState, ProtocolVersion protocolVersion)
    {
<span class="fc" id="L133">        return new SinglePartitionPager(this, pagingState, protocolVersion);</span>
    }

    ClusteringIndexFilter clusteringIndexFilter();

    default boolean selectsKey(DecoratedKey key)
    {
<span class="fc bfc" id="L140" title="All 2 branches covered.">        if (!this.partitionKey().equals(key))</span>
<span class="fc" id="L141">            return false;</span>

<span class="fc" id="L143">        return rowFilter().partitionKeyRestrictionsAreSatisfiedBy(key, metadata().partitionKeyType);</span>
    }

    default boolean selectsClustering(DecoratedKey key, Clustering&lt;?&gt; clustering)
    {
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">        if (clustering == Clustering.STATIC_CLUSTERING)</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">            return !columnFilter().fetchedColumns().statics.isEmpty();</span>

<span class="pc bpc" id="L151" title="1 of 2 branches missed.">        if (!clusteringIndexFilter().selects(clustering))</span>
<span class="nc" id="L152">            return false;</span>

<span class="fc" id="L154">        return rowFilter().clusteringKeyRestrictionsAreSatisfiedBy(clustering);</span>
    }

    /**
     * Groups multiple single partition read queries.
     */
<span class="fc" id="L160">    abstract class Group&lt;T extends SinglePartitionReadQuery&gt; implements ReadQuery</span>
    {
        public final List&lt;T&gt; queries;
        private final DataLimits limits;
        private final long nowInSec;
        private final boolean selectsFullPartitions;

        public Group(List&lt;T&gt; queries, DataLimits limits)
<span class="fc" id="L168">        {</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">            assert !queries.isEmpty();</span>
<span class="fc" id="L170">            this.queries = queries;</span>
<span class="fc" id="L171">            this.limits = limits;</span>
<span class="fc" id="L172">            T firstQuery = queries.get(0);</span>
<span class="fc" id="L173">            this.nowInSec = firstQuery.nowInSec();</span>
<span class="fc" id="L174">            this.selectsFullPartitions = firstQuery.selectsFullPartition();</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">            for (int i = 1; i &lt; queries.size(); i++)</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">                assert queries.get(i).nowInSec() == nowInSec;</span>
<span class="fc" id="L177">        }</span>

        public long nowInSec()
        {
<span class="fc" id="L181">            return nowInSec;</span>
        }

        public DataLimits limits()
        {
<span class="fc" id="L186">            return limits;</span>
        }

        public TableMetadata metadata()
        {
<span class="fc" id="L191">            return queries.get(0).metadata();</span>
        }

        @Override
        public boolean selectsFullPartition()
        {
<span class="fc" id="L197">            return selectsFullPartitions;</span>
        }

        public ReadExecutionController executionController()
        {
            // Note that the only difference between the queries in a group must be the partition key on which
            // they applied. So as far as ReadOrderGroup is concerned, we can use any of the queries to start one.
<span class="fc" id="L204">            return queries.get(0).executionController();</span>
        }

        public PartitionIterator executeInternal(ReadExecutionController controller)
        {
            // Note that the only difference between the queries in a group must be the partition key on which
            // they applied.
<span class="fc" id="L211">            boolean enforceStrictLiveness = queries.get(0).metadata().enforceStrictLiveness();</span>
<span class="fc" id="L212">            return limits.filter(UnfilteredPartitionIterators.filter(executeLocally(controller, false), nowInSec),</span>
                                 nowInSec,
                                 selectsFullPartitions,
                                 enforceStrictLiveness);
        }

        public UnfilteredPartitionIterator executeLocally(ReadExecutionController executionController)
        {
<span class="fc" id="L220">            return executeLocally(executionController, true);</span>
        }

        /**
         * Implementation of {@link ReadQuery#executeLocally(ReadExecutionController)}.
         *
         * @param executionController - the {@code ReadExecutionController} protecting the read.
         * @param sort - whether to sort the inner queries by partition key, required for merging the iterator
         *               later on. This will be false when called by {@link ReadQuery#executeInternal(ReadExecutionController)}
         *               because in this case it is safe to do so as there is no merging involved and we don't want to
         *               change the old behavior which was to not sort by partition.
         *
         * @return - the iterator that can be used to retrieve the query result.
         */
        private UnfilteredPartitionIterator executeLocally(ReadExecutionController executionController, boolean sort)
        {
<span class="fc" id="L236">            List&lt;Pair&lt;DecoratedKey, UnfilteredPartitionIterator&gt;&gt; partitions = new ArrayList&lt;&gt;(queries.size());</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">            for (T query : queries)</span>
<span class="fc" id="L238">                partitions.add(Pair.of(query.partitionKey(), query.executeLocally(executionController)));</span>

<span class="fc bfc" id="L240" title="All 2 branches covered.">            if (sort)</span>
<span class="fc" id="L241">                Collections.sort(partitions, (p1, p2) -&gt; p1.getLeft().compareTo(p2.getLeft()));</span>

<span class="fc" id="L243">            return UnfilteredPartitionIterators.concat(partitions.stream().map(p -&gt; p.getRight()).collect(Collectors.toList()));</span>
        }

        public QueryPager getPager(PagingState pagingState, ProtocolVersion protocolVersion)
        {
<span class="fc bfc" id="L248" title="All 2 branches covered.">            if (queries.size() == 1)</span>
<span class="fc" id="L249">                return new SinglePartitionPager(queries.get(0), pagingState, protocolVersion);</span>

<span class="fc" id="L251">            return new MultiPartitionPager&lt;T&gt;(this, pagingState, protocolVersion);</span>
        }

        public boolean selectsKey(DecoratedKey key)
        {
<span class="fc" id="L256">            return Iterables.any(queries, c -&gt; c.selectsKey(key));</span>
        }

        public boolean selectsClustering(DecoratedKey key, Clustering&lt;?&gt; clustering)
        {
<span class="fc" id="L261">            return Iterables.any(queries, c -&gt; c.selectsClustering(key, clustering));</span>
        }

        @Override
        public RowFilter rowFilter()
        {
            // Note that the only difference between the query in a group must be the partition key on which
            // they applied.
<span class="nc" id="L269">            return queries.get(0).rowFilter();</span>
        }

        @Override
        public ColumnFilter columnFilter()
        {
            // Note that the only difference between the query in a group must be the partition key on which
            // they applied.
<span class="nc" id="L277">            return queries.get(0).columnFilter();</span>
        }

        @Override
        public void trackWarnings()
        {
<span class="fc" id="L283">            queries.forEach(ReadQuery::trackWarnings);</span>
<span class="fc" id="L284">        }</span>

        @Override
        public String toString()
        {
<span class="nc" id="L289">            return queries.toString();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>