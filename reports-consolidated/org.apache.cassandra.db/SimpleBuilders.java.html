<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SimpleBuilders.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db</a> &gt; <span class="el_source">SimpleBuilders.java</span></div><h1>SimpleBuilders.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db;

import java.nio.ByteBuffer;
import java.util.*;

import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.TableId;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.schema.Schema;
import org.apache.cassandra.cql3.ColumnIdentifier;
import org.apache.cassandra.db.context.CounterContext;
import org.apache.cassandra.db.partitions.PartitionUpdate;
import org.apache.cassandra.db.rows.BTreeRow;
import org.apache.cassandra.db.rows.BufferCell;
import org.apache.cassandra.db.rows.Cell;
import org.apache.cassandra.db.rows.CellPath;
import org.apache.cassandra.db.rows.Row;
import org.apache.cassandra.db.marshal.*;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.CounterId;
import org.apache.cassandra.utils.FBUtilities;

import static org.apache.cassandra.utils.TimeUUID.Generator.nextTimeUUIDAsBytes;

<span class="fc" id="L42">public abstract class SimpleBuilders</span>
{
    private SimpleBuilders()
    {
    }

    private static DecoratedKey makePartitonKey(TableMetadata metadata, Object... partitionKey)
    {
<span class="pc bpc" id="L50" title="1 of 4 branches missed.">        if (partitionKey.length == 1 &amp;&amp; partitionKey[0] instanceof DecoratedKey)</span>
<span class="fc" id="L51">            return (DecoratedKey)partitionKey[0];</span>

<span class="fc" id="L53">        ByteBuffer key = metadata.partitionKeyAsClusteringComparator().make(partitionKey).serializeAsPartitionKey();</span>
<span class="fc" id="L54">        return metadata.partitioner.decorateKey(key);</span>
    }

    private static Clustering&lt;?&gt; makeClustering(TableMetadata metadata, Object... clusteringColumns)
    {
<span class="fc bfc" id="L59" title="All 4 branches covered.">        if (clusteringColumns.length == 1 &amp;&amp; clusteringColumns[0] instanceof Clustering)</span>
<span class="fc" id="L60">            return (Clustering&lt;?&gt;)clusteringColumns[0];</span>

<span class="fc bfc" id="L62" title="All 2 branches covered.">        if (clusteringColumns.length == 0)</span>
        {
            // If the table has clustering columns, passing no values is for updating the static values, so check we
            // do have some static columns defined.
<span class="pc bpc" id="L66" title="1 of 4 branches missed.">            assert metadata.comparator.size() == 0 || !metadata.staticColumns().isEmpty();</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">            return metadata.comparator.size() == 0 ? Clustering.EMPTY : Clustering.STATIC_CLUSTERING;</span>
        }
        else
        {
<span class="fc" id="L71">            return metadata.comparator.make(clusteringColumns);</span>
        }
    }

<span class="fc" id="L75">    private static class AbstractBuilder&lt;T&gt;</span>
    {
<span class="fc" id="L77">        protected long timestamp = FBUtilities.timestampMicros();</span>
<span class="fc" id="L78">        protected int ttl = 0;</span>
<span class="fc" id="L79">        protected long nowInSec = FBUtilities.nowInSeconds();</span>

        protected void copyParams(AbstractBuilder&lt;?&gt; other)
        {
<span class="fc" id="L83">            other.timestamp = timestamp;</span>
<span class="fc" id="L84">            other.ttl = ttl;</span>
<span class="fc" id="L85">            other.nowInSec = nowInSec;</span>
<span class="fc" id="L86">        }</span>

        public T timestamp(long timestamp)
        {
<span class="fc" id="L90">            this.timestamp = timestamp;</span>
<span class="fc" id="L91">            return (T)this;</span>
        }

        public T ttl(int ttl)
        {
<span class="fc" id="L96">            this.ttl = ttl;</span>
<span class="fc" id="L97">            return (T)this;</span>
        }

        public T nowInSec(long nowInSec)
        {
<span class="fc" id="L102">            this.nowInSec = nowInSec;</span>
<span class="fc" id="L103">            return (T)this;</span>
        }
    }

<span class="fc" id="L107">    public static class MutationBuilder extends AbstractBuilder&lt;Mutation.SimpleBuilder&gt; implements Mutation.SimpleBuilder</span>
    {
        private final String keyspaceName;
        private final DecoratedKey key;

<span class="fc" id="L112">        private final Map&lt;TableId, PartitionUpdateBuilder&gt; updateBuilders = new HashMap&lt;&gt;();</span>

        public MutationBuilder(String keyspaceName, DecoratedKey key)
<span class="fc" id="L115">        {</span>
<span class="fc" id="L116">            this.keyspaceName = keyspaceName;</span>
<span class="fc" id="L117">            this.key = key;</span>
<span class="fc" id="L118">        }</span>

        public PartitionUpdate.SimpleBuilder update(TableMetadata metadata)
        {
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">            assert metadata.keyspace.equals(keyspaceName);</span>

<span class="fc" id="L124">            PartitionUpdateBuilder builder = updateBuilders.get(metadata.id);</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">            if (builder == null)</span>
            {
<span class="fc" id="L127">                builder = new PartitionUpdateBuilder(metadata, key);</span>
<span class="fc" id="L128">                updateBuilders.put(metadata.id, builder);</span>
            }

<span class="fc" id="L131">            copyParams(builder);</span>

<span class="fc" id="L133">            return builder;</span>
        }

        public PartitionUpdate.SimpleBuilder update(String tableName)
        {
<span class="fc" id="L138">            TableMetadata metadata = Schema.instance.getTableMetadata(keyspaceName, tableName);</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">            assert metadata != null : &quot;Unknown table &quot; + tableName + &quot; in keyspace &quot; + keyspaceName;</span>
<span class="fc" id="L140">            return update(metadata);</span>
        }

        public Mutation build()
        {
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">            assert !updateBuilders.isEmpty() : &quot;Cannot create empty mutation&quot;;</span>

<span class="fc bfc" id="L147" title="All 2 branches covered.">            if (updateBuilders.size() == 1)</span>
<span class="fc" id="L148">                return new Mutation(updateBuilders.values().iterator().next().build());</span>

<span class="fc" id="L150">            Mutation.PartitionUpdateCollector mutationBuilder = new Mutation.PartitionUpdateCollector(keyspaceName, key);</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">            for (PartitionUpdateBuilder builder : updateBuilders.values())</span>
<span class="fc" id="L152">                mutationBuilder.add(builder.build());</span>
<span class="fc" id="L153">            return mutationBuilder.build();</span>
        }
    }

    public static class PartitionUpdateBuilder extends AbstractBuilder&lt;PartitionUpdate.SimpleBuilder&gt; implements PartitionUpdate.SimpleBuilder
    {
        private final TableMetadata metadata;
        private final DecoratedKey key;
<span class="fc" id="L161">        private final Map&lt;Clustering&lt;?&gt;, RowBuilder&gt; rowBuilders = new HashMap&lt;&gt;();</span>
<span class="fc" id="L162">        private List&lt;RTBuilder&gt; rangeBuilders = null; // We use that rarely, so create lazily</span>
<span class="fc" id="L163">        private List&lt;RangeTombstone&gt; rangeTombstones = null;</span>

<span class="fc" id="L165">        private DeletionTime partitionDeletion = DeletionTime.LIVE;</span>

        public PartitionUpdateBuilder(TableMetadata metadata, Object... partitionKeyValues)
<span class="fc" id="L168">        {</span>
<span class="fc" id="L169">            this.metadata = metadata;</span>
<span class="fc" id="L170">            this.key = makePartitonKey(metadata, partitionKeyValues);</span>
<span class="fc" id="L171">        }</span>

        public TableMetadata metadata()
        {
<span class="fc" id="L175">            return metadata;</span>
        }

        public Row.SimpleBuilder row(Object... clusteringValues)
        {
<span class="fc" id="L180">            Clustering&lt;?&gt; clustering = makeClustering(metadata, clusteringValues);</span>
<span class="fc" id="L181">            RowBuilder builder = rowBuilders.get(clustering);</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">            if (builder == null)</span>
            {
<span class="fc" id="L184">                builder = new RowBuilder(metadata, clustering);</span>
<span class="fc" id="L185">                rowBuilders.put(clustering, builder);</span>
            }

<span class="fc" id="L188">            copyParams(builder);</span>

<span class="fc" id="L190">            return builder;</span>
        }

        public PartitionUpdate.SimpleBuilder delete()
        {
<span class="fc" id="L195">            this.partitionDeletion = DeletionTime.build(timestamp, nowInSec);</span>
<span class="fc" id="L196">            return this;</span>
        }

        public RangeTombstoneBuilder addRangeTombstone()
        {
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">            if (rangeBuilders == null)</span>
<span class="fc" id="L202">                rangeBuilders = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L204">            RTBuilder builder = new RTBuilder(metadata.comparator, DeletionTime.build(timestamp, nowInSec));</span>
<span class="fc" id="L205">            rangeBuilders.add(builder);</span>
<span class="fc" id="L206">            return builder;</span>
        }

        public PartitionUpdate.SimpleBuilder addRangeTombstone(RangeTombstone rt)
        {
<span class="fc bfc" id="L211" title="All 2 branches covered.">            if (rangeTombstones == null)</span>
<span class="fc" id="L212">                rangeTombstones = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L213">            rangeTombstones.add(rt);</span>
<span class="fc" id="L214">            return this;</span>
        }

        public PartitionUpdate build()
        {
            // Collect all updated columns
<span class="fc" id="L220">            RegularAndStaticColumns.Builder columns = RegularAndStaticColumns.builder();</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">            for (RowBuilder builder : rowBuilders.values())</span>
<span class="fc" id="L222">                columns.addAll(builder.columns());</span>

            // Note that rowBuilders.size() could include the static column so could be 1 off the really need capacity
            // of the final PartitionUpdate, but as that's just a sizing hint, we'll live.
<span class="fc" id="L226">            PartitionUpdate.Builder update = new PartitionUpdate.Builder(metadata, key, columns.build(), rowBuilders.size());</span>

<span class="fc" id="L228">            update.addPartitionDeletion(partitionDeletion);</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">            if (rangeBuilders != null)</span>
            {
<span class="fc bfc" id="L231" title="All 2 branches covered.">                for (RTBuilder builder : rangeBuilders)</span>
<span class="fc" id="L232">                    update.add(builder.build());</span>
            }

<span class="fc bfc" id="L235" title="All 2 branches covered.">            if (rangeTombstones != null)</span>
            {
<span class="fc bfc" id="L237" title="All 2 branches covered.">                for (RangeTombstone rt : rangeTombstones)</span>
<span class="fc" id="L238">                    update.add(rt);</span>
            }

<span class="fc bfc" id="L241" title="All 2 branches covered.">            for (RowBuilder builder : rowBuilders.values())</span>
<span class="fc" id="L242">                update.add(builder.build());</span>

<span class="fc" id="L244">            return update.build();</span>
        }

        public Mutation buildAsMutation()
        {
<span class="fc" id="L249">            return new Mutation(build());</span>
        }

        private static class RTBuilder implements RangeTombstoneBuilder
        {
            private final ClusteringComparator comparator;
            private final DeletionTime deletionTime;

            private Object[] start;
            private Object[] end;

<span class="fc" id="L260">            private boolean startInclusive = true;</span>
<span class="fc" id="L261">            private boolean endInclusive = true;</span>

            private RTBuilder(ClusteringComparator comparator, DeletionTime deletionTime)
<span class="fc" id="L264">            {</span>
<span class="fc" id="L265">                this.comparator = comparator;</span>
<span class="fc" id="L266">                this.deletionTime = deletionTime;</span>
<span class="fc" id="L267">            }</span>

            public RangeTombstoneBuilder start(Object... values)
            {
<span class="fc" id="L271">                this.start = values;</span>
<span class="fc" id="L272">                return this;</span>
            }

            public RangeTombstoneBuilder end(Object... values)
            {
<span class="fc" id="L277">                this.end = values;</span>
<span class="fc" id="L278">                return this;</span>
            }

            public RangeTombstoneBuilder inclStart()
            {
<span class="nc" id="L283">                this.startInclusive = true;</span>
<span class="nc" id="L284">                return this;</span>
            }

            public RangeTombstoneBuilder exclStart()
            {
<span class="nc" id="L289">                this.startInclusive = false;</span>
<span class="nc" id="L290">                return this;</span>
            }

            public RangeTombstoneBuilder inclEnd()
            {
<span class="nc" id="L295">                this.endInclusive = true;</span>
<span class="nc" id="L296">                return this;</span>
            }

            public RangeTombstoneBuilder exclEnd()
            {
<span class="nc" id="L301">                this.endInclusive = false;</span>
<span class="nc" id="L302">                return this;</span>
            }

            private RangeTombstone build()
            {
<span class="fc" id="L307">                ClusteringBound&lt;?&gt; startBound = ClusteringBound.create(comparator, true, startInclusive, start);</span>
<span class="fc" id="L308">                ClusteringBound&lt;?&gt; endBound = ClusteringBound.create(comparator, false, endInclusive, end);</span>
<span class="fc" id="L309">                return new RangeTombstone(Slice.make(startBound, endBound), deletionTime);</span>
            }
        }
    }

<span class="fc" id="L314">    public static class RowBuilder extends AbstractBuilder&lt;Row.SimpleBuilder&gt; implements Row.SimpleBuilder</span>
    {
        private final TableMetadata metadata;

<span class="fc" id="L318">        private final Set&lt;ColumnMetadata&gt; columns = new HashSet&lt;&gt;();</span>
        private final Row.Builder builder;

        private boolean initiated;
        private boolean noPrimaryKeyLivenessInfo;

        public RowBuilder(TableMetadata metadata, Object... clusteringColumns)
<span class="fc" id="L325">        {</span>
<span class="fc" id="L326">            this.metadata = metadata;</span>
<span class="fc" id="L327">            this.builder = BTreeRow.unsortedBuilder();</span>

<span class="fc" id="L329">            this.builder.newRow(makeClustering(metadata, clusteringColumns));</span>
<span class="fc" id="L330">        }</span>

        Set&lt;ColumnMetadata&gt; columns()
        {
<span class="fc" id="L334">            return columns;</span>
        }

        private void maybeInit()
        {
            // We're working around the fact that Row.Builder requires that addPrimaryKeyLivenessInfo() and
            // addRowDeletion() are called before any cell addition (which is done so the builder can more easily skip
            // shadowed cells).
<span class="fc bfc" id="L342" title="All 2 branches covered.">            if (initiated)</span>
<span class="fc" id="L343">                return;</span>

            // Adds the row liveness
<span class="fc bfc" id="L346" title="All 4 branches covered.">            if (!metadata.isCompactTable() &amp;&amp; !noPrimaryKeyLivenessInfo)</span>
<span class="fc" id="L347">                builder.addPrimaryKeyLivenessInfo(LivenessInfo.create(timestamp, ttl, nowInSec));</span>

<span class="fc" id="L349">            initiated = true;</span>
<span class="fc" id="L350">        }</span>

        public Row.SimpleBuilder add(String columnName, Object value)
        {
<span class="fc" id="L354">            return add(columnName, value, true);</span>
        }

        public Row.SimpleBuilder appendAll(String columnName, Object value)
        {
<span class="fc" id="L359">            return add(columnName, value, false);</span>
        }

        private Row.SimpleBuilder add(String columnName, Object value, boolean overwriteForCollection)
        {
<span class="fc" id="L364">            maybeInit();</span>
<span class="fc" id="L365">            ColumnMetadata column = getColumn(columnName);</span>

<span class="pc bpc" id="L367" title="2 of 6 branches missed.">            if (!overwriteForCollection &amp;&amp; !(column.type.isMultiCell() &amp;&amp; column.type.isCollection()))</span>
<span class="nc" id="L368">                throw new IllegalArgumentException(&quot;appendAll() can only be called on non-frozen collections&quot;);</span>

<span class="fc" id="L370">            columns.add(column);</span>

<span class="fc bfc" id="L372" title="All 2 branches covered.">            if (!column.type.isMultiCell())</span>
            {
<span class="fc" id="L374">                builder.addCell(cell(column, toByteBuffer(value, column.type), null));</span>
<span class="fc" id="L375">                return this;</span>
            }

<span class="pc bpc" id="L378" title="1 of 2 branches missed.">            assert column.type instanceof CollectionType : &quot;Collection are the only multi-cell types supported so far&quot;;</span>

<span class="pc bpc" id="L380" title="1 of 2 branches missed.">            if (value == null)</span>
            {
<span class="nc" id="L382">                builder.addComplexDeletion(column, DeletionTime.build(timestamp, nowInSec));</span>
<span class="nc" id="L383">                return this;</span>
            }

            // Erase previous entry if any.
<span class="fc bfc" id="L387" title="All 2 branches covered.">            if (overwriteForCollection)</span>
<span class="fc" id="L388">                builder.addComplexDeletion(column, DeletionTime.build(timestamp - 1, nowInSec));</span>
<span class="pc bpc" id="L389" title="1 of 4 branches missed.">            switch (((CollectionType)column.type).kind)</span>
            {
                case LIST:
<span class="fc" id="L392">                    ListType lt = (ListType)column.type;</span>
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">                    assert value instanceof List;</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">                    for (Object elt : (List)value)</span>
<span class="fc" id="L395">                        builder.addCell(cell(column, toByteBuffer(elt, lt.getElementsType()), CellPath.create(ByteBuffer.wrap(nextTimeUUIDAsBytes()))));</span>
<span class="fc" id="L396">                    break;</span>
                case SET:
<span class="fc" id="L398">                    SetType st = (SetType)column.type;</span>
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">                    assert value instanceof Set;</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">                    for (Object elt : (Set)value)</span>
<span class="fc" id="L401">                        builder.addCell(cell(column, ByteBufferUtil.EMPTY_BYTE_BUFFER, CellPath.create(toByteBuffer(elt, st.getElementsType()))));</span>
<span class="fc" id="L402">                    break;</span>
                case MAP:
<span class="fc" id="L404">                    MapType mt = (MapType)column.type;</span>
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">                    assert value instanceof Map;</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">                    for (Map.Entry entry : ((Map&lt;?, ?&gt;)value).entrySet())</span>
<span class="fc" id="L407">                        builder.addCell(cell(column,</span>
<span class="fc" id="L408">                                             toByteBuffer(entry.getValue(), mt.getValuesType()),</span>
<span class="fc" id="L409">                                             CellPath.create(toByteBuffer(entry.getKey(), mt.getKeysType()))));</span>
<span class="fc" id="L410">                    break;</span>
                default:
<span class="nc" id="L412">                    throw new AssertionError();</span>
            }
<span class="fc" id="L414">            return this;</span>
        }

        public Row.SimpleBuilder delete()
        {
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">            assert !initiated : &quot;If called, delete() should be called before any other column value addition&quot;;</span>
<span class="fc" id="L420">            builder.addRowDeletion(Row.Deletion.regular(DeletionTime.build(timestamp, nowInSec)));</span>
<span class="fc" id="L421">            return this;</span>
        }

        public Row.SimpleBuilder deletePrevious()
        {
<span class="fc" id="L426">            builder.addRowDeletion(Row.Deletion.regular(DeletionTime.build(timestamp - 1, nowInSec)));</span>
<span class="fc" id="L427">            return this;</span>
        }

        public Row.SimpleBuilder delete(String columnName)
        {
<span class="fc" id="L432">            return add(columnName, null);</span>
        }

        public Row.SimpleBuilder noPrimaryKeyLivenessInfo()
        {
<span class="fc" id="L437">            this.noPrimaryKeyLivenessInfo = true;</span>
<span class="fc" id="L438">            return this;</span>
        }

        public Row build()
        {
<span class="fc" id="L443">            maybeInit();</span>
<span class="fc" id="L444">            return builder.build();</span>
        }

        private ColumnMetadata getColumn(String columnName)
        {
<span class="fc" id="L449">            ColumnMetadata column = metadata.getColumn(new ColumnIdentifier(columnName, true));</span>
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">            assert column != null : &quot;Cannot find column &quot; + columnName;</span>
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">            assert !column.isPrimaryKeyColumn();</span>
<span class="pc bpc" id="L452" title="1 of 4 branches missed.">            assert !column.isStatic() || builder.clustering() == Clustering.STATIC_CLUSTERING : &quot;Cannot add non-static column to static-row&quot;;</span>
<span class="fc" id="L453">            return column;</span>
        }

        private Cell&lt;?&gt; cell(ColumnMetadata column, ByteBuffer value, CellPath path)
        {
<span class="fc bfc" id="L458" title="All 2 branches covered.">            if (value == null)</span>
<span class="fc" id="L459">                return BufferCell.tombstone(column, timestamp, nowInSec, path);</span>

<span class="fc bfc" id="L461" title="All 2 branches covered.">            return ttl == LivenessInfo.NO_TTL</span>
<span class="fc" id="L462">                 ? BufferCell.live(column, timestamp, value, path)</span>
<span class="fc" id="L463">                 : BufferCell.expiring(column, timestamp, ttl, nowInSec, value, path);</span>
        }

        private ByteBuffer toByteBuffer(Object value, AbstractType&lt;?&gt; type)
        {
<span class="fc bfc" id="L468" title="All 2 branches covered.">            if (value == null)</span>
<span class="fc" id="L469">                return null;</span>

<span class="fc bfc" id="L471" title="All 2 branches covered.">            if (value instanceof ByteBuffer)</span>
<span class="fc" id="L472">                return (ByteBuffer)value;</span>

<span class="fc bfc" id="L474" title="All 2 branches covered.">            if (type.isCounter())</span>
            {
                // See UpdateParameters.addCounter()
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">                assert value instanceof Long : &quot;Attempted to adjust Counter cell with non-long value.&quot;;</span>
<span class="fc" id="L478">                return CounterContext.instance().createGlobal(CounterId.getLocalId(), 1, (Long)value);</span>
            }

<span class="fc" id="L481">            return ((AbstractType)type).decompose(value);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>