<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RangeIntersectionIterator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.index.sasi.utils</a> &gt; <span class="el_source">RangeIntersectionIterator.java</span></div><h1>RangeIntersectionIterator.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.index.sasi.utils;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.PriorityQueue;

import com.google.common.collect.Iterators;
import org.apache.cassandra.io.util.FileUtils;

import com.google.common.annotations.VisibleForTesting;

@SuppressWarnings(&quot;resource&quot;)
<span class="nc" id="L32">public class RangeIntersectionIterator</span>
{
<span class="fc" id="L34">    protected enum Strategy</span>
    {
<span class="fc" id="L36">        BOUNCE, LOOKUP, ADAPTIVE</span>
    }

    public static &lt;K extends Comparable&lt;K&gt;, D extends CombinedValue&lt;K&gt;&gt; Builder&lt;K, D&gt; builder()
    {
<span class="fc" id="L41">        return builder(Strategy.ADAPTIVE);</span>
    }

    @VisibleForTesting
    protected static &lt;K extends Comparable&lt;K&gt;, D extends CombinedValue&lt;K&gt;&gt; Builder&lt;K, D&gt; builder(Strategy strategy)
    {
<span class="fc" id="L47">        return new Builder&lt;&gt;(strategy);</span>
    }

    public static class Builder&lt;K extends Comparable&lt;K&gt;, D extends CombinedValue&lt;K&gt;&gt; extends RangeIterator.Builder&lt;K, D&gt;
    {
        private final Strategy strategy;

        public Builder(Strategy strategy)
        {
<span class="fc" id="L56">            super(IteratorType.INTERSECTION);</span>
<span class="fc" id="L57">            this.strategy = strategy;</span>
<span class="fc" id="L58">        }</span>

        protected RangeIterator&lt;K, D&gt; buildIterator()
        {
            // if the range is disjoint or we have an intersection with an empty set,
            // we can simply return an empty iterator, because it's not going to produce any results.
<span class="fc bfc" id="L64" title="All 2 branches covered.">            if (statistics.isDisjoint())</span>
<span class="fc" id="L65">                return new EmptyRangeIterator&lt;&gt;();</span>

<span class="fc bfc" id="L67" title="All 2 branches covered.">            if (rangeCount() == 1)</span>
<span class="fc" id="L68">                return ranges.poll();</span>

<span class="pc bpc" id="L70" title="1 of 4 branches missed.">            switch (strategy)</span>
            {
                case LOOKUP:
<span class="fc" id="L73">                    return new LookupIntersectionIterator&lt;&gt;(statistics, ranges);</span>

                case BOUNCE:
<span class="fc" id="L76">                    return new BounceIntersectionIterator&lt;&gt;(statistics, ranges);</span>

                case ADAPTIVE:
<span class="fc bfc" id="L79" title="All 2 branches covered.">                    return statistics.sizeRatio() &lt;= 0.01d</span>
<span class="fc" id="L80">                            ? new LookupIntersectionIterator&lt;&gt;(statistics, ranges)</span>
<span class="fc" id="L81">                            : new BounceIntersectionIterator&lt;&gt;(statistics, ranges);</span>

                default:
<span class="nc" id="L84">                    throw new IllegalStateException(&quot;Unknown strategy: &quot; + strategy);</span>
            }
        }
    }

    private static abstract class AbstractIntersectionIterator&lt;K extends Comparable&lt;K&gt;, D extends CombinedValue&lt;K&gt;&gt; extends RangeIterator&lt;K, D&gt;
    {
        protected final PriorityQueue&lt;RangeIterator&lt;K, D&gt;&gt; ranges;

        private AbstractIntersectionIterator(Builder.Statistics&lt;K, D&gt; statistics, PriorityQueue&lt;RangeIterator&lt;K, D&gt;&gt; ranges)
        {
<span class="fc" id="L95">            super(statistics);</span>
<span class="fc" id="L96">            this.ranges = ranges;</span>
<span class="fc" id="L97">        }</span>

        public void close() throws IOException
        {
<span class="fc bfc" id="L101" title="All 2 branches covered.">            for (RangeIterator&lt;K, D&gt; range : ranges)</span>
<span class="fc" id="L102">                FileUtils.closeQuietly(range);</span>
<span class="fc" id="L103">        }</span>
    }

    /**
     * Iterator which performs intersection of multiple ranges by using bouncing (merge-join) technique to identify
     * common elements in the given ranges. Aforementioned &quot;bounce&quot; works as follows: range queue is poll'ed for the
     * range with the smallest current token (main loop), that token is used to {@link RangeIterator#skipTo(Comparable)}
     * other ranges, if token produced by {@link RangeIterator#skipTo(Comparable)} is equal to current &quot;candidate&quot; token,
     * both get merged together and the same operation is repeated for next range from the queue, if returned token
     * is not equal than candidate, candidate's range gets put back into the queue and the main loop gets repeated until
     * next intersection token is found or at least one iterator runs out of tokens.
     *
     * This technique is every efficient to jump over gaps in the ranges.
     *
     * @param &lt;K&gt; The type used to sort ranges.
     * @param &lt;D&gt; The container type which is going to be returned by {@link Iterator#next()}.
     */
    @VisibleForTesting
    protected static class BounceIntersectionIterator&lt;K extends Comparable&lt;K&gt;, D extends CombinedValue&lt;K&gt;&gt; extends AbstractIntersectionIterator&lt;K, D&gt;
    {
        private BounceIntersectionIterator(Builder.Statistics&lt;K, D&gt; statistics, PriorityQueue&lt;RangeIterator&lt;K, D&gt;&gt; ranges)
        {
<span class="fc" id="L125">            super(statistics, ranges);</span>
<span class="fc" id="L126">        }</span>

        protected D computeNext()
        {
<span class="fc" id="L130">            List&lt;RangeIterator&lt;K, D&gt;&gt; processed = null;</span>

<span class="pc bpc" id="L132" title="1 of 2 branches missed.">            while (!ranges.isEmpty())</span>
            {
<span class="fc" id="L134">                RangeIterator&lt;K, D&gt; head = ranges.poll();</span>

                // jump right to the beginning of the intersection or return next element
<span class="fc bfc" id="L137" title="All 2 branches covered.">                if (head.getCurrent().compareTo(getMinimum()) &lt; 0)</span>
<span class="fc" id="L138">                    head.skipTo(getMinimum());</span>

<span class="fc bfc" id="L140" title="All 2 branches covered.">                D candidate = head.hasNext() ? head.next() : null;</span>
<span class="fc bfc" id="L141" title="All 4 branches covered.">                if (candidate == null || candidate.get().compareTo(getMaximum()) &gt; 0)</span>
                {
<span class="fc" id="L143">                    ranges.add(head);</span>
<span class="fc" id="L144">                    return endOfData();</span>
                }

<span class="fc bfc" id="L147" title="All 2 branches covered.">                if (processed == null)</span>
<span class="fc" id="L148">                    processed = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L150">                boolean intersectsAll = true, exhausted = false;</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">                while (!ranges.isEmpty())</span>
                {
<span class="fc" id="L153">                    RangeIterator&lt;K, D&gt; range = ranges.poll();</span>

                    // found a range which doesn't overlap with one (or possibly more) other range(s)
<span class="fc bfc" id="L156" title="All 2 branches covered.">                    if (!isOverlapping(head, range))</span>
                    {
<span class="fc" id="L158">                        exhausted = true;</span>
<span class="fc" id="L159">                        intersectsAll = false;</span>
<span class="fc" id="L160">                        break;</span>
                    }

<span class="fc" id="L163">                    D point = range.skipTo(candidate.get());</span>

<span class="pc bpc" id="L165" title="1 of 2 branches missed.">                    if (point == null) // other range is exhausted</span>
                    {
<span class="nc" id="L167">                        exhausted = true;</span>
<span class="nc" id="L168">                        intersectsAll = false;</span>
<span class="nc" id="L169">                        break;</span>
                    }

<span class="fc" id="L172">                    processed.add(range);</span>

<span class="fc bfc" id="L174" title="All 2 branches covered.">                    if (candidate.get().equals(point.get()))</span>
                    {
<span class="fc" id="L176">                        candidate.merge(point);</span>
                        // advance skipped range to the next element if any
<span class="fc" id="L178">                        Iterators.getNext(range, null);</span>
                    }
                    else
                    {
<span class="fc" id="L182">                        intersectsAll = false;</span>
<span class="fc" id="L183">                        break;</span>
                    }
<span class="fc" id="L185">                }</span>

<span class="fc" id="L187">                ranges.add(head);</span>

<span class="fc" id="L189">                ranges.addAll(processed);</span>
<span class="fc" id="L190">                processed.clear();</span>

<span class="fc bfc" id="L192" title="All 2 branches covered.">                if (exhausted)</span>
<span class="fc" id="L193">                    return endOfData();</span>

<span class="fc bfc" id="L195" title="All 2 branches covered.">                if (intersectsAll)</span>
<span class="fc" id="L196">                    return candidate;</span>
<span class="fc" id="L197">            }</span>

<span class="nc" id="L199">            return endOfData();</span>
        }

        protected void performSkipTo(K nextToken)
        {
<span class="fc" id="L204">            List&lt;RangeIterator&lt;K, D&gt;&gt; skipped = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L206" title="All 2 branches covered.">            while (!ranges.isEmpty())</span>
            {
<span class="fc" id="L208">                RangeIterator&lt;K, D&gt; range = ranges.poll();</span>
<span class="fc" id="L209">                range.skipTo(nextToken);</span>
<span class="fc" id="L210">                skipped.add(range);</span>
<span class="fc" id="L211">            }</span>

<span class="fc bfc" id="L213" title="All 2 branches covered.">            for (RangeIterator&lt;K, D&gt; range : skipped)</span>
<span class="fc" id="L214">                ranges.add(range);</span>
<span class="fc" id="L215">        }</span>
    }

    /**
     * Iterator which performs a linear scan over a primary range (the smallest of the ranges)
     * and O(log(n)) lookup into secondary ranges using values from the primary iterator.
     * This technique is efficient when one of the intersection ranges is smaller than others
     * e.g. ratio 0.01d (default), in such situation scan + lookup is more efficient comparing
     * to &quot;bounce&quot; merge because &quot;bounce&quot; distance is never going to be big.
     *
     * @param &lt;K&gt; The type used to sort ranges.
     * @param &lt;D&gt; The container type which is going to be returned by {@link Iterator#next()}.
     */
    @VisibleForTesting
    protected static class LookupIntersectionIterator&lt;K extends Comparable&lt;K&gt;, D extends CombinedValue&lt;K&gt;&gt; extends AbstractIntersectionIterator&lt;K, D&gt;
    {
        private final RangeIterator&lt;K, D&gt; smallestIterator;

        private LookupIntersectionIterator(Builder.Statistics&lt;K, D&gt; statistics, PriorityQueue&lt;RangeIterator&lt;K, D&gt;&gt; ranges)
        {
<span class="fc" id="L235">            super(statistics, ranges);</span>

<span class="fc" id="L237">            smallestIterator = statistics.minRange;</span>

<span class="fc bfc" id="L239" title="All 2 branches covered.">            if (smallestIterator.getCurrent().compareTo(getMinimum()) &lt; 0)</span>
<span class="fc" id="L240">                smallestIterator.skipTo(getMinimum());</span>
<span class="fc" id="L241">        }</span>

        protected D computeNext()
        {
<span class="fc bfc" id="L245" title="All 2 branches covered.">            while (smallestIterator.hasNext())</span>
            {
<span class="fc" id="L247">                D candidate = smallestIterator.next();</span>
<span class="fc" id="L248">                K token = candidate.get();</span>

<span class="fc" id="L250">                boolean intersectsAll = true;</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">                for (RangeIterator&lt;K, D&gt; range : ranges)</span>
                {
                    // avoid checking against self, much cheaper than changing queue comparator
                    // to compare based on the size and re-populating such queue.
<span class="fc bfc" id="L255" title="All 2 branches covered.">                    if (range.equals(smallestIterator))</span>
<span class="fc" id="L256">                        continue;</span>

                    // found a range which doesn't overlap with one (or possibly more) other range(s)
<span class="fc bfc" id="L259" title="All 2 branches covered.">                    if (!isOverlapping(smallestIterator, range))</span>
<span class="fc" id="L260">                        return endOfData();</span>

<span class="fc" id="L262">                    D point = range.skipTo(token);</span>

<span class="pc bpc" id="L264" title="1 of 2 branches missed.">                    if (point == null) // one of the iterators is exhausted</span>
<span class="nc" id="L265">                        return endOfData();</span>

<span class="fc bfc" id="L267" title="All 2 branches covered.">                    if (!point.get().equals(token))</span>
                    {
<span class="fc" id="L269">                        intersectsAll = false;</span>
<span class="fc" id="L270">                        break;</span>
                    }

<span class="fc" id="L273">                    candidate.merge(point);</span>
<span class="fc" id="L274">                }</span>

<span class="fc bfc" id="L276" title="All 2 branches covered.">                if (intersectsAll)</span>
<span class="fc" id="L277">                    return candidate;</span>
<span class="fc" id="L278">            }</span>

<span class="fc" id="L280">            return endOfData();</span>
        }

        protected void performSkipTo(K nextToken)
        {
<span class="fc" id="L285">            smallestIterator.skipTo(nextToken);</span>
<span class="fc" id="L286">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>