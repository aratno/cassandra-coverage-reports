<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AlterTableStatement.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.statements.schema</a> &gt; <span class="el_source">AlterTableStatement.java</span></div><h1>AlterTableStatement.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3.statements.schema;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import javax.annotation.Nullable;

import com.google.common.base.Splitter;
import com.google.common.collect.ImmutableSet;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.audit.AuditLogContext;
import org.apache.cassandra.audit.AuditLogEntryType;
import org.apache.cassandra.auth.Permission;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.cql3.CQL3Type;
import org.apache.cassandra.cql3.CQLStatement;
import org.apache.cassandra.cql3.ColumnIdentifier;
import org.apache.cassandra.cql3.QualifiedName;
import org.apache.cassandra.cql3.functions.masking.ColumnMask;
import org.apache.cassandra.db.Keyspace;
import org.apache.cassandra.db.guardrails.Guardrails;
import org.apache.cassandra.db.marshal.AbstractType;

import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.gms.ApplicationState;
import org.apache.cassandra.gms.Gossiper;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.net.MessagingService;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.IndexMetadata;
import org.apache.cassandra.schema.KeyspaceMetadata;
import org.apache.cassandra.schema.Keyspaces;
import org.apache.cassandra.schema.Keyspaces.KeyspacesDiff;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.schema.TableParams;
import org.apache.cassandra.schema.ViewMetadata;
import org.apache.cassandra.schema.Views;
import org.apache.cassandra.service.ClientState;
import org.apache.cassandra.service.StorageService;
import org.apache.cassandra.service.reads.repair.ReadRepairStrategy;
import org.apache.cassandra.transport.Event.SchemaChange;
import org.apache.cassandra.transport.Event.SchemaChange.Change;
import org.apache.cassandra.transport.Event.SchemaChange.Target;
import org.apache.cassandra.utils.NoSpamLogger;

import static java.lang.String.format;
import static java.lang.String.join;

import static com.google.common.collect.Iterables.isEmpty;
import static com.google.common.collect.Iterables.transform;

import static org.apache.cassandra.schema.TableMetadata.Flag;

public abstract class AlterTableStatement extends AlterSchemaStatement
{
    protected final String tableName;
    private final boolean ifExists;
    protected ClientState state;

    public AlterTableStatement(String keyspaceName, String tableName, boolean ifExists)
    {
<span class="fc" id="L89">        super(keyspaceName);</span>
<span class="fc" id="L90">        this.tableName = tableName;</span>
<span class="fc" id="L91">        this.ifExists = ifExists;</span>
<span class="fc" id="L92">    }</span>

    @Override
    public void validate(ClientState state)
    {
<span class="fc" id="L97">        super.validate(state);</span>

        // save the query state to use it for guardrails validation in #apply
<span class="fc" id="L100">        this.state = state;</span>
<span class="fc" id="L101">    }</span>

    public Keyspaces apply(Keyspaces schema)
    {
<span class="fc" id="L105">        KeyspaceMetadata keyspace = schema.getNullable(keyspaceName);</span>

<span class="pc bpc" id="L107" title="1 of 2 branches missed.">        TableMetadata table = null == keyspace</span>
<span class="nc" id="L108">                            ? null</span>
<span class="fc" id="L109">                            : keyspace.getTableOrViewNullable(tableName);</span>

<span class="fc bfc" id="L111" title="All 2 branches covered.">        if (null == table)</span>
        {
<span class="fc bfc" id="L113" title="All 2 branches covered.">            if (!ifExists)</span>
<span class="fc" id="L114">                throw ire(&quot;Table '%s.%s' doesn't exist&quot;, keyspaceName, tableName);</span>
<span class="fc" id="L115">            return schema;</span>
        }

<span class="fc bfc" id="L118" title="All 2 branches covered.">        if (table.isView())</span>
<span class="fc" id="L119">            throw ire(&quot;Cannot use ALTER TABLE on a materialized view; use ALTER MATERIALIZED VIEW instead&quot;);</span>

<span class="fc" id="L121">        return schema.withAddedOrUpdated(apply(keyspace, table));</span>
    }

    SchemaChange schemaChangeEvent(KeyspacesDiff diff)
    {
<span class="fc" id="L126">        return new SchemaChange(Change.UPDATED, Target.TABLE, keyspaceName, tableName);</span>
    }

    public void authorize(ClientState client)
    {
<span class="fc" id="L131">        client.ensureTablePermission(keyspaceName, tableName, Permission.ALTER);</span>
<span class="fc" id="L132">    }</span>

    @Override
    public AuditLogContext getAuditLogContext()
    {
<span class="fc" id="L137">        return new AuditLogContext(AuditLogEntryType.ALTER_TABLE, keyspaceName, tableName);</span>
    }

    public String toString()
    {
<span class="nc" id="L142">        return format(&quot;%s (%s, %s)&quot;, getClass().getSimpleName(), keyspaceName, tableName);</span>
    }

    abstract KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table);

    /**
     * ALTER TABLE [IF EXISTS] &lt;table&gt; ALTER &lt;column&gt; TYPE &lt;newtype&gt;;
     *
     * No longer supported.
     */
    public static class AlterColumn extends AlterTableStatement
    {
        AlterColumn(String keyspaceName, String tableName, boolean ifTableExists)
        {
<span class="nc" id="L156">            super(keyspaceName, tableName, ifTableExists);</span>
<span class="nc" id="L157">        }</span>

        public KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table)
        {
<span class="nc" id="L161">            throw ire(&quot;Altering column types is no longer supported&quot;);</span>
        }
    }

    /**
     * ALTER TABLE [IF EXISTS] &lt;table&gt; ALTER [IF EXISTS] &lt;column&gt; ( MASKED WITH &lt;newMask&gt; | DROP MASKED )
     */
    public static class MaskColumn extends AlterTableStatement
    {
        private final ColumnIdentifier columnName;
        @Nullable
        private final ColumnMask.Raw rawMask;
        private final boolean ifColumnExists;

        MaskColumn(String keyspaceName,
                   String tableName,
                   ColumnIdentifier columnName,
                   @Nullable ColumnMask.Raw rawMask,
                   boolean ifTableExists,
                   boolean ifColumnExists)
        {
<span class="fc" id="L182">            super(keyspaceName, tableName, ifTableExists);</span>
<span class="fc" id="L183">            this.columnName = columnName;</span>
<span class="fc" id="L184">            this.rawMask = rawMask;</span>
<span class="fc" id="L185">            this.ifColumnExists = ifColumnExists;</span>
<span class="fc" id="L186">        }</span>

        @Override
        public void validate(ClientState state)
        {
<span class="fc" id="L191">            super.validate(state);</span>

            // we don't allow creating masks if they are disabled, but we still allow dropping them
<span class="fc bfc" id="L194" title="All 2 branches covered.">            if (rawMask != null)</span>
<span class="fc" id="L195">                ColumnMask.ensureEnabled();</span>
<span class="fc" id="L196">        }</span>

        @Override
        public KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table)
        {
<span class="fc" id="L201">            ColumnMetadata column = table.getColumn(columnName);</span>

<span class="fc bfc" id="L203" title="All 2 branches covered.">            if (column == null)</span>
            {
<span class="fc bfc" id="L205" title="All 2 branches covered.">                if (!ifColumnExists)</span>
<span class="fc" id="L206">                    throw ire(&quot;Column with name '%s' doesn't exist on table '%s'&quot;, columnName, tableName);</span>

<span class="fc" id="L208">                return keyspace;</span>
            }

<span class="fc" id="L211">            ColumnMask oldMask = table.getColumn(columnName).getMask();</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">            ColumnMask newMask = rawMask == null ? null : rawMask.prepare(keyspace.name, table.name, columnName, column.type);</span>

<span class="fc bfc" id="L214" title="All 2 branches covered.">            if (Objects.equals(oldMask, newMask))</span>
<span class="fc" id="L215">                return keyspace;</span>

<span class="fc" id="L217">            TableMetadata.Builder tableBuilder = table.unbuild();</span>
<span class="fc" id="L218">            tableBuilder.alterColumnMask(columnName, newMask);</span>
<span class="fc" id="L219">            TableMetadata newTable = tableBuilder.build();</span>
<span class="fc" id="L220">            newTable.validate();</span>

            // Update any reference on materialized views, so the mask is consistent among the base table and its views.
<span class="fc" id="L223">            Views.Builder viewsBuilder = keyspace.views.unbuild();</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">            for (ViewMetadata view : keyspace.views.forTable(table.id))</span>
            {
<span class="fc bfc" id="L226" title="All 2 branches covered.">                if (view.includes(columnName))</span>
                {
<span class="fc" id="L228">                    viewsBuilder.put(viewsBuilder.get(view.name()).withNewColumnMask(columnName, newMask));</span>
                }
<span class="fc" id="L230">            }</span>

<span class="fc" id="L232">            return keyspace.withSwapped(keyspace.tables.withSwapped(newTable))</span>
<span class="fc" id="L233">                           .withSwapped(viewsBuilder.build());</span>
        }
    }

    /**
     * ALTER TABLE [IF EXISTS] &lt;table&gt; ADD [IF NOT EXISTS] &lt;column&gt; &lt;newtype&gt;
     * ALTER TABLE [IF EXISTS] &lt;table&gt; ADD [IF NOT EXISTS] (&lt;column&gt; &lt;newtype&gt;, &lt;column1&gt; &lt;newtype1&gt;, ... &lt;columnn&gt; &lt;newtypen&gt;)
     */
    private static class AddColumns extends AlterTableStatement
    {
        private static class Column
        {
            private final ColumnIdentifier name;
            private final CQL3Type.Raw type;
            private final boolean isStatic;
            @Nullable
            private final ColumnMask.Raw mask;

            Column(ColumnIdentifier name, CQL3Type.Raw type, boolean isStatic, @Nullable ColumnMask.Raw mask)
<span class="fc" id="L252">            {</span>
<span class="fc" id="L253">                this.name = name;</span>
<span class="fc" id="L254">                this.type = type;</span>
<span class="fc" id="L255">                this.isStatic = isStatic;</span>
<span class="fc" id="L256">                this.mask = mask;</span>
<span class="fc" id="L257">            }</span>
        }

        private final Collection&lt;Column&gt; newColumns;
        private final boolean ifColumnNotExists;

        private AddColumns(String keyspaceName, String tableName, Collection&lt;Column&gt; newColumns, boolean ifTableExists, boolean ifColumnNotExists)
        {
<span class="fc" id="L265">            super(keyspaceName, tableName, ifTableExists);</span>
<span class="fc" id="L266">            this.newColumns = newColumns;</span>
<span class="fc" id="L267">            this.ifColumnNotExists = ifColumnNotExists;</span>
<span class="fc" id="L268">        }</span>

        @Override
        public void validate(ClientState state)
        {
<span class="fc" id="L273">            super.validate(state);</span>
<span class="fc" id="L274">            newColumns.forEach(c -&gt; c.type.validate(state, &quot;Column &quot; + c.name));</span>
<span class="fc" id="L275">        }</span>

        public KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table)
        {
<span class="fc" id="L279">            Guardrails.alterTableEnabled.ensureEnabled(&quot;ALTER TABLE changing columns&quot;, state);</span>
<span class="fc" id="L280">            TableMetadata.Builder tableBuilder = table.unbuild();</span>
<span class="fc" id="L281">            Views.Builder viewsBuilder = keyspace.views.unbuild();</span>
<span class="fc" id="L282">            newColumns.forEach(c -&gt; addColumn(keyspace, table, c, ifColumnNotExists, tableBuilder, viewsBuilder));</span>

<span class="fc" id="L284">            Guardrails.columnsPerTable.guard(tableBuilder.numColumns(), tableName, false, state);</span>

<span class="fc" id="L286">            TableMetadata tableMetadata = tableBuilder.build();</span>
<span class="fc" id="L287">            tableMetadata.validate();</span>

<span class="fc" id="L289">            return keyspace.withSwapped(keyspace.tables.withSwapped(tableMetadata))</span>
<span class="fc" id="L290">                           .withSwapped(viewsBuilder.build());</span>
        }

        private void addColumn(KeyspaceMetadata keyspace,
                               TableMetadata table,
                               Column column,
                               boolean ifColumnNotExists,
                               TableMetadata.Builder tableBuilder,
                               Views.Builder viewsBuilder)
        {
<span class="fc" id="L300">            ColumnIdentifier name = column.name;</span>
<span class="fc" id="L301">            AbstractType&lt;?&gt; type = column.type.prepare(keyspaceName, keyspace.types).getType();</span>
<span class="fc" id="L302">            boolean isStatic = column.isStatic;</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">            ColumnMask mask = column.mask == null ? null : column.mask.prepare(keyspaceName, tableName, name, type);</span>

<span class="fc bfc" id="L305" title="All 2 branches covered.">            if (null != tableBuilder.getColumn(name)) {</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">                if (!ifColumnNotExists)</span>
<span class="fc" id="L307">                    throw ire(&quot;Column with name '%s' already exists&quot;, name);</span>
<span class="fc" id="L308">                return;</span>
            }

<span class="fc bfc" id="L311" title="All 2 branches covered.">            if (table.isCompactTable())</span>
<span class="fc" id="L312">                throw ire(&quot;Cannot add new column to a COMPACT STORAGE table&quot;);</span>

<span class="fc bfc" id="L314" title="All 4 branches covered.">            if (isStatic &amp;&amp; table.clusteringColumns().isEmpty())</span>
<span class="fc" id="L315">                throw ire(&quot;Static columns are only useful (and thus allowed) if the table has at least one clustering column&quot;);</span>

<span class="fc" id="L317">            ColumnMetadata droppedColumn = table.getDroppedColumn(name.bytes);</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">            if (null != droppedColumn)</span>
            {
                // After #8099, not safe to re-add columns of incompatible types - until *maybe* deser logic with dropped
                // columns is pushed deeper down the line. The latter would still be problematic in cases of schema races.
<span class="fc bfc" id="L322" title="All 2 branches covered.">                if (!type.isSerializationCompatibleWith(droppedColumn.type))</span>
                {
<span class="fc" id="L324">                    throw ire(&quot;Cannot re-add previously dropped column '%s' of type %s, incompatible with previous type %s&quot;,</span>
                              name,
<span class="fc" id="L326">                              type.asCQL3Type(),</span>
<span class="fc" id="L327">                              droppedColumn.type.asCQL3Type());</span>
                }

<span class="fc bfc" id="L330" title="All 2 branches covered.">                if (droppedColumn.isStatic() != isStatic)</span>
                {
<span class="fc" id="L332">                    throw ire(&quot;Cannot re-add previously dropped column '%s' of kind %s, incompatible with previous kind %s&quot;,</span>
                              name,
<span class="fc bfc" id="L334" title="All 2 branches covered.">                              isStatic ? ColumnMetadata.Kind.STATIC : ColumnMetadata.Kind.REGULAR,</span>
                              droppedColumn.kind);
                }

                // Cannot re-add a dropped counter column. See #7831.
<span class="fc bfc" id="L339" title="All 2 branches covered.">                if (table.isCounter())</span>
<span class="fc" id="L340">                    throw ire(&quot;Cannot re-add previously dropped counter column %s&quot;, name);</span>
            }

<span class="fc bfc" id="L343" title="All 2 branches covered.">            if (isStatic)</span>
<span class="fc" id="L344">                tableBuilder.addStaticColumn(name, type, mask);</span>
            else
<span class="fc" id="L346">                tableBuilder.addRegularColumn(name, type, mask);</span>

<span class="fc bfc" id="L348" title="All 2 branches covered.">            if (!isStatic)</span>
            {
<span class="fc bfc" id="L350" title="All 2 branches covered.">                for (ViewMetadata view : keyspace.views.forTable(table.id))</span>
                {
<span class="fc bfc" id="L352" title="All 2 branches covered.">                    if (view.includeAllColumns)</span>
                    {
<span class="fc" id="L354">                        ColumnMetadata viewColumn = ColumnMetadata.regularColumn(view.metadata, name.bytes, type)</span>
<span class="fc" id="L355">                                                                  .withNewMask(mask);</span>
<span class="fc" id="L356">                        viewsBuilder.put(viewsBuilder.get(view.name()).withAddedRegularColumn(viewColumn));</span>
                    }
<span class="fc" id="L358">                }</span>
            }
<span class="fc" id="L360">        }</span>
    }

    /**
     * ALTER TABLE [IF EXISTS] &lt;table&gt; DROP [IF EXISTS] &lt;column&gt;
     * ALTER TABLE [IF EXISTS] &lt;table&gt; DROP [IF EXISTS] ( &lt;column&gt;, &lt;column1&gt;, ... &lt;columnn&gt;)
     */
    // TODO: swap UDT refs with expanded tuples on drop
    private static class DropColumns extends AlterTableStatement
    {
        private final Set&lt;ColumnIdentifier&gt; removedColumns;
        private final boolean ifColumnExists;
        private final Long timestamp;

        private DropColumns(String keyspaceName, String tableName, Set&lt;ColumnIdentifier&gt; removedColumns, boolean ifTableExists, boolean ifColumnExists, Long timestamp)
        {
<span class="fc" id="L376">            super(keyspaceName, tableName, ifTableExists);</span>
<span class="fc" id="L377">            this.removedColumns = removedColumns;</span>
<span class="fc" id="L378">            this.ifColumnExists = ifColumnExists;</span>
<span class="fc" id="L379">            this.timestamp = timestamp;</span>
<span class="fc" id="L380">        }</span>

        public KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table)
        {
<span class="fc" id="L384">            Guardrails.alterTableEnabled.ensureEnabled(&quot;ALTER TABLE changing columns&quot;, state);</span>
<span class="fc" id="L385">            TableMetadata.Builder builder = table.unbuild();</span>
<span class="fc" id="L386">            removedColumns.forEach(c -&gt; dropColumn(keyspace, table, c, ifColumnExists, builder));</span>
<span class="fc" id="L387">            return keyspace.withSwapped(keyspace.tables.withSwapped(builder.build()));</span>
        }

        private void dropColumn(KeyspaceMetadata keyspace, TableMetadata table, ColumnIdentifier column, boolean ifExists, TableMetadata.Builder builder)
        {
<span class="fc" id="L392">            ColumnMetadata currentColumn = table.getColumn(column);</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">            if (null == currentColumn) {</span>
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">                if (!ifExists)</span>
<span class="nc" id="L395">                    throw ire(&quot;Column %s was not found in table '%s'&quot;, column, table);</span>
<span class="fc" id="L396">                return;</span>
            }

<span class="pc bpc" id="L399" title="1 of 2 branches missed.">            if (currentColumn.isPrimaryKeyColumn())</span>
<span class="nc" id="L400">                throw ire(&quot;Cannot drop PRIMARY KEY column %s&quot;, column);</span>

            /*
             * Cannot allow dropping top-level columns of user defined types that aren't frozen because we cannot convert
             * the type into an equivalent tuple: we only support frozen tuples currently. And as such we cannot persist
             * the correct type in system_schema.dropped_columns.
             */
<span class="pc bpc" id="L407" title="3 of 4 branches missed.">            if (currentColumn.type.isUDT() &amp;&amp; currentColumn.type.isMultiCell())</span>
<span class="nc" id="L408">                throw ire(&quot;Cannot drop non-frozen column %s of user type %s&quot;, column, currentColumn.type.asCQL3Type());</span>

            // TODO: some day try and find a way to not rely on Keyspace/IndexManager/Index to find dependent indexes
<span class="fc" id="L411">            Set&lt;IndexMetadata&gt; dependentIndexes = Keyspace.openAndGetStore(table).indexManager.getDependentIndexes(currentColumn);</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">            if (!dependentIndexes.isEmpty())</span>
            {
<span class="nc" id="L414">                throw ire(&quot;Cannot drop column %s because it has dependent secondary indexes (%s)&quot;,</span>
                          currentColumn,
<span class="nc" id="L416">                          join(&quot;, &quot;, transform(dependentIndexes, i -&gt; i.name)));</span>
            }

<span class="fc bfc" id="L419" title="All 2 branches covered.">            if (!isEmpty(keyspace.views.forTable(table.id)))</span>
<span class="fc" id="L420">                throw ire(&quot;Cannot drop column %s on base table %s with materialized views&quot;, currentColumn, table.name);</span>

<span class="fc" id="L422">            builder.removeRegularOrStaticColumn(column);</span>
<span class="fc" id="L423">            builder.recordColumnDrop(currentColumn, getTimestamp());</span>
<span class="fc" id="L424">        }</span>

        /**
         * @return timestamp from query, otherwise return current time in micros
         */
        private long getTimestamp()
        {
<span class="fc bfc" id="L431" title="All 2 branches covered.">            return timestamp == null ? ClientState.getTimestamp() : timestamp;</span>
        }
    }

    /**
     * ALTER TABLE [IF EXISTS] &lt;table&gt; RENAME [IF EXISTS] &lt;column&gt; TO &lt;column&gt;;
     */
    private static class RenameColumns extends AlterTableStatement
    {
        private final Map&lt;ColumnIdentifier, ColumnIdentifier&gt; renamedColumns;
        private final boolean ifColumnsExists;

        private RenameColumns(String keyspaceName, String tableName, Map&lt;ColumnIdentifier, ColumnIdentifier&gt; renamedColumns, boolean ifTableExists, boolean ifColumnsExists)
        {
<span class="fc" id="L445">            super(keyspaceName, tableName, ifTableExists);</span>
<span class="fc" id="L446">            this.renamedColumns = renamedColumns;</span>
<span class="fc" id="L447">            this.ifColumnsExists = ifColumnsExists;</span>
<span class="fc" id="L448">        }</span>

        public KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table)
        {
<span class="fc" id="L452">            Guardrails.alterTableEnabled.ensureEnabled(&quot;ALTER TABLE changing columns&quot;, state);</span>
<span class="fc" id="L453">            TableMetadata.Builder tableBuilder = table.unbuild();</span>
<span class="fc" id="L454">            Views.Builder viewsBuilder = keyspace.views.unbuild();</span>
<span class="fc" id="L455">            renamedColumns.forEach((o, n) -&gt; renameColumn(keyspace, table, o, n, ifColumnsExists, tableBuilder, viewsBuilder));</span>

<span class="fc" id="L457">            return keyspace.withSwapped(keyspace.tables.withSwapped(tableBuilder.build()))</span>
<span class="fc" id="L458">                           .withSwapped(viewsBuilder.build());</span>
        }

        private void renameColumn(KeyspaceMetadata keyspace,
                                  TableMetadata table,
                                  ColumnIdentifier oldName,
                                  ColumnIdentifier newName,
                                  boolean ifColumnsExists,
                                  TableMetadata.Builder tableBuilder,
                                  Views.Builder viewsBuilder)
        {
<span class="fc" id="L469">            ColumnMetadata column = table.getExistingColumn(oldName);</span>
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">            if (null == column)</span>
            {
<span class="nc bnc" id="L472" title="All 2 branches missed.">                if (!ifColumnsExists)</span>
<span class="nc" id="L473">                    throw ire(&quot;Column %s was not found in table %s&quot;, oldName, table);</span>
<span class="nc" id="L474">                return;</span>
            }

<span class="pc bpc" id="L477" title="1 of 2 branches missed.">            if (!column.isPrimaryKeyColumn())</span>
<span class="nc" id="L478">                throw ire(&quot;Cannot rename non PRIMARY KEY column %s&quot;, oldName);</span>

<span class="pc bpc" id="L480" title="1 of 2 branches missed.">            if (null != table.getColumn(newName))</span>
            {
<span class="nc" id="L482">                throw ire(&quot;Cannot rename column %s to %s in table '%s'; another column with that name already exists&quot;,</span>
                          oldName,
                          newName,
                          table);
            }

            // TODO: some day try and find a way to not rely on Keyspace/IndexManager/Index to find dependent indexes
<span class="fc" id="L489">            Set&lt;IndexMetadata&gt; dependentIndexes = Keyspace.openAndGetStore(table).indexManager.getDependentIndexes(column);</span>
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">            if (!dependentIndexes.isEmpty())</span>
            {
<span class="nc" id="L492">                throw ire(&quot;Can't rename column %s because it has dependent secondary indexes (%s)&quot;,</span>
                          oldName,
<span class="nc" id="L494">                          join(&quot;, &quot;, transform(dependentIndexes, i -&gt; i.name)));</span>
            }

<span class="fc bfc" id="L497" title="All 2 branches covered.">            for (ViewMetadata view : keyspace.views.forTable(table.id))</span>
            {
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">                if (view.includes(oldName))</span>
                {
<span class="fc" id="L501">                    viewsBuilder.put(viewsBuilder.get(view.name()).withRenamedPrimaryKeyColumn(oldName, newName));</span>
                }
<span class="fc" id="L503">            }</span>

<span class="fc" id="L505">            tableBuilder.renamePrimaryKeyColumn(oldName, newName);</span>
<span class="fc" id="L506">        }</span>
    }

    /**
     * ALTER TABLE [IF EXISTS] &lt;table&gt; WITH &lt;property&gt; = &lt;value&gt;
     */
    private static class AlterOptions extends AlterTableStatement
    {
        private final TableAttributes attrs;

        private AlterOptions(String keyspaceName, String tableName, TableAttributes attrs, boolean ifTableExists)
        {
<span class="fc" id="L518">            super(keyspaceName, tableName, ifTableExists);</span>
<span class="fc" id="L519">            this.attrs = attrs;</span>
<span class="fc" id="L520">        }</span>

        @Override
        public void validate(ClientState state)
        {
<span class="fc" id="L525">            super.validate(state);</span>

<span class="fc" id="L527">            Guardrails.tableProperties.guard(attrs.updatedProperties(), attrs::removeProperty, state);</span>

<span class="fc" id="L529">            validateDefaultTimeToLive(attrs.asNewTableParams());</span>
<span class="fc" id="L530">        }</span>

        public KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table)
        {
<span class="fc" id="L534">            attrs.validate();</span>

<span class="fc" id="L536">            TableParams params = attrs.asAlteredTableParams(table.params);</span>

<span class="pc bpc" id="L538" title="3 of 4 branches missed.">            if (table.isCounter() &amp;&amp; params.defaultTimeToLive &gt; 0)</span>
<span class="nc" id="L539">                throw ire(&quot;Cannot set default_time_to_live on a table with counters&quot;);</span>

<span class="fc bfc" id="L541" title="All 4 branches covered.">            if (!isEmpty(keyspace.views.forTable(table.id)) &amp;&amp; params.gcGraceSeconds == 0)</span>
            {
<span class="fc" id="L543">                throw ire(&quot;Cannot alter gc_grace_seconds of the base table of a &quot; +</span>
                          &quot;materialized view to 0, since this value is used to TTL &quot; +
                          &quot;undelivered updates. Setting gc_grace_seconds too low might &quot; +
                          &quot;cause undelivered updates to expire &quot; +
                          &quot;before being replayed.&quot;);
            }

<span class="pc bpc" id="L550" title="3 of 4 branches missed.">            if (keyspace.createReplicationStrategy().hasTransientReplicas()</span>
                &amp;&amp; params.readRepair != ReadRepairStrategy.NONE)
            {
<span class="nc" id="L553">                throw ire(&quot;read_repair must be set to 'NONE' for transiently replicated keyspaces&quot;);</span>
            }

<span class="fc bfc" id="L556" title="All 2 branches covered.">            if (!params.compression.isEnabled())</span>
<span class="fc" id="L557">                Guardrails.uncompressedTablesEnabled.ensureEnabled(state);</span>

<span class="fc" id="L559">            return keyspace.withSwapped(keyspace.tables.withSwapped(table.withSwapped(params)));</span>
        }
    }


    /**
     * ALTER TABLE [IF EXISTS] &lt;table&gt; DROP COMPACT STORAGE
     */
    private static class DropCompactStorage extends AlterTableStatement
    {
<span class="fc" id="L569">        private static final Logger logger = LoggerFactory.getLogger(AlterTableStatement.class);</span>
<span class="fc" id="L570">        private static final NoSpamLogger noSpamLogger = NoSpamLogger.getLogger(logger, 5L, TimeUnit.MINUTES);</span>
        private DropCompactStorage(String keyspaceName, String tableName, boolean ifTableExists)
        {
<span class="fc" id="L573">            super(keyspaceName, tableName, ifTableExists);</span>
<span class="fc" id="L574">        }</span>

        public KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table)
        {
<span class="fc bfc" id="L578" title="All 2 branches covered.">            if (!DatabaseDescriptor.enableDropCompactStorage())</span>
<span class="fc" id="L579">                throw new InvalidRequestException(&quot;DROP COMPACT STORAGE is disabled. Enable in cassandra.yaml to use.&quot;);</span>

<span class="pc bpc" id="L581" title="1 of 2 branches missed.">            if (!table.isCompactTable())</span>
<span class="nc" id="L582">                throw AlterTableStatement.ire(&quot;Cannot DROP COMPACT STORAGE on table without COMPACT STORAGE&quot;);</span>

<span class="fc" id="L584">            validateCanDropCompactStorage();</span>

<span class="fc bfc" id="L586" title="All 2 branches covered.">            Set&lt;Flag&gt; flags = table.isCounter()</span>
<span class="fc" id="L587">                            ? ImmutableSet.of(Flag.COMPOUND, Flag.COUNTER)</span>
<span class="fc" id="L588">                            : ImmutableSet.of(Flag.COMPOUND);</span>

<span class="fc" id="L590">            return keyspace.withSwapped(keyspace.tables.withSwapped(table.withSwapped(flags)));</span>
        }

        /**
         * Throws if DROP COMPACT STORAGE cannot be used (yet) because the cluster is not sufficiently upgraded. To be able
         * to use DROP COMPACT STORAGE, we need to ensure that no pre-3.0 sstables exists in the cluster, as we won't be
         * able to read them anymore once COMPACT STORAGE is dropped (see CASSANDRA-15897). In practice, this method checks
         * 3 things:
         *   1) that all nodes are on 3.0+. We need this because 2.x nodes don't advertise their sstable versions.
         *   2) for 3.0+, we use the new (CASSANDRA-15897) sstables versions set gossiped by all nodes to ensure all
         *      sstables have been upgraded cluster-wise.
         *   3) if the cluster still has some 3.0 nodes that predate CASSANDRA-15897, we will not have the sstable versions
         *      for them. In that case, we also refuse DROP COMPACT (even though it may well be safe at this point) and ask
         *      the user to upgrade all nodes.
         */
        private void validateCanDropCompactStorage()
        {
<span class="fc" id="L607">            Set&lt;InetAddressAndPort&gt; before4 = new HashSet&lt;&gt;();</span>
<span class="fc" id="L608">            Set&lt;InetAddressAndPort&gt; preC15897nodes = new HashSet&lt;&gt;();</span>
<span class="fc" id="L609">            Set&lt;InetAddressAndPort&gt; with2xSStables = new HashSet&lt;&gt;();</span>
<span class="fc" id="L610">            Splitter onComma = Splitter.on(',').omitEmptyStrings().trimResults();</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">            for (InetAddressAndPort node : StorageService.instance.getTokenMetadata().getAllEndpoints())</span>
            {
<span class="fc bfc" id="L613" title="All 2 branches covered.">                if (MessagingService.instance().versions.knows(node) &amp;&amp;</span>
<span class="pc bpc" id="L614" title="1 of 2 branches missed.">                    MessagingService.instance().versions.getRaw(node) &lt; MessagingService.VERSION_40)</span>
                {
<span class="nc" id="L616">                    before4.add(node);</span>
<span class="nc" id="L617">                    continue;</span>
                }

<span class="fc" id="L620">                String sstableVersionsString = Gossiper.instance.getApplicationState(node, ApplicationState.SSTABLE_VERSIONS);</span>
<span class="pc bpc" id="L621" title="1 of 2 branches missed.">                if (sstableVersionsString == null)</span>
                {
<span class="nc" id="L623">                    preC15897nodes.add(node);</span>
<span class="nc" id="L624">                    continue;</span>
                }

                try
                {
<span class="fc" id="L629">                    boolean has2xSStables = onComma.splitToList(sstableVersionsString)</span>
<span class="fc" id="L630">                                                   .stream()</span>
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">                                                   .anyMatch(v -&gt; v.compareTo(&quot;big-ma&quot;)&lt;=0);</span>
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">                    if (has2xSStables)</span>
<span class="nc" id="L633">                        with2xSStables.add(node);</span>
                }
<span class="nc" id="L635">                catch (IllegalArgumentException e)</span>
                {
                    // Means VersionType::fromString didn't parse a version correctly. Which shouldn't happen, we shouldn't
                    // have garbage in Gossip. But crashing the request is not ideal, so we log the error but ignore the
                    // node otherwise.
<span class="nc" id="L640">                    noSpamLogger.error(&quot;Unexpected error parsing sstable versions from gossip for {} (gossiped value &quot; +</span>
                                       &quot;is '{}'). This is a bug and should be reported. Cannot ensure that {} has no &quot; +
                                       &quot;non-upgraded 2.x sstables anymore. If after this DROP COMPACT STORAGE some old &quot; +
                                       &quot;sstables cannot be read anymore, please use `upgradesstables` with the &quot; +
                                       &quot;`--force-compact-storage-on` option.&quot;, node, sstableVersionsString, node);
<span class="fc" id="L645">                }</span>
<span class="fc" id="L646">            }</span>

<span class="pc bpc" id="L648" title="1 of 2 branches missed.">            if (!before4.isEmpty())</span>
<span class="nc" id="L649">                throw new InvalidRequestException(format(&quot;Cannot DROP COMPACT STORAGE as some nodes in the cluster (%s) &quot; +</span>
                                                         &quot;are not on 4.0+ yet. Please upgrade those nodes and run &quot; +
                                                         &quot;`upgradesstables` before retrying.&quot;, before4));
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">            if (!preC15897nodes.isEmpty())</span>
<span class="nc" id="L653">                throw new InvalidRequestException(format(&quot;Cannot guarantee that DROP COMPACT STORAGE is safe as some nodes &quot; +</span>
                                                         &quot;in the cluster (%s) do not have https://issues.apache.org/jira/browse/CASSANDRA-15897. &quot; +
                                                         &quot;Please upgrade those nodes and retry.&quot;, preC15897nodes));
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">            if (!with2xSStables.isEmpty())</span>
<span class="nc" id="L657">                throw new InvalidRequestException(format(&quot;Cannot DROP COMPACT STORAGE as some nodes in the cluster (%s) &quot; +</span>
                                                         &quot;has some non-upgraded 2.x sstables. Please run `upgradesstables` &quot; +
                                                         &quot;on those nodes before retrying&quot;, with2xSStables));
<span class="fc" id="L660">        }</span>
    }

    public static final class Raw extends CQLStatement.Raw
    {
<span class="fc" id="L665">        private enum Kind</span>
        {
<span class="fc" id="L667">            ALTER_COLUMN,</span>
<span class="fc" id="L668">            MASK_COLUMN,</span>
<span class="fc" id="L669">            ADD_COLUMNS,</span>
<span class="fc" id="L670">            DROP_COLUMNS,</span>
<span class="fc" id="L671">            RENAME_COLUMNS,</span>
<span class="fc" id="L672">            ALTER_OPTIONS,</span>
<span class="fc" id="L673">            DROP_COMPACT_STORAGE</span>
        }

        private final QualifiedName name;
        private final boolean ifTableExists;
        private boolean ifColumnExists;
        private boolean ifColumnNotExists;

        private Kind kind;

        // ADD
<span class="fc" id="L684">        private final List&lt;AddColumns.Column&gt; addedColumns = new ArrayList&lt;&gt;();</span>

        // ALTER MASK
<span class="fc" id="L687">        private ColumnIdentifier maskedColumn = null;</span>
<span class="fc" id="L688">        private ColumnMask.Raw rawMask = null;</span>

        // DROP
<span class="fc" id="L691">        private final Set&lt;ColumnIdentifier&gt; droppedColumns = new HashSet&lt;&gt;();</span>
<span class="fc" id="L692">        private Long timestamp = null; // will use execution timestamp if not provided by query</span>

        // RENAME
<span class="fc" id="L695">        private final Map&lt;ColumnIdentifier, ColumnIdentifier&gt; renamedColumns = new HashMap&lt;&gt;();</span>

        // OPTIONS
<span class="fc" id="L698">        public final TableAttributes attrs = new TableAttributes();</span>

        public Raw(QualifiedName name, boolean ifTableExists)
<span class="fc" id="L701">        {</span>
<span class="fc" id="L702">            this.name = name;</span>
<span class="fc" id="L703">            this.ifTableExists = ifTableExists;</span>
<span class="fc" id="L704">        }</span>

        public AlterTableStatement prepare(ClientState state)
        {
<span class="fc bfc" id="L708" title="All 2 branches covered.">            String keyspaceName = name.hasKeyspace() ? name.getKeyspace() : state.getKeyspace();</span>
<span class="fc" id="L709">            String tableName = name.getName();</span>

<span class="pc bpc" id="L711" title="2 of 8 branches missed.">            switch (kind)</span>
            {
<span class="nc" id="L713">                case          ALTER_COLUMN: return new AlterColumn(keyspaceName, tableName, ifTableExists);</span>
<span class="fc" id="L714">                case           MASK_COLUMN: return new MaskColumn(keyspaceName, tableName, maskedColumn, rawMask, ifTableExists, ifColumnExists);</span>
<span class="fc" id="L715">                case           ADD_COLUMNS: return new AddColumns(keyspaceName, tableName, addedColumns, ifTableExists, ifColumnNotExists);</span>
<span class="fc" id="L716">                case          DROP_COLUMNS: return new DropColumns(keyspaceName, tableName, droppedColumns, ifTableExists, ifColumnExists, timestamp);</span>
<span class="fc" id="L717">                case        RENAME_COLUMNS: return new RenameColumns(keyspaceName, tableName, renamedColumns, ifTableExists, ifColumnExists);</span>
<span class="fc" id="L718">                case         ALTER_OPTIONS: return new AlterOptions(keyspaceName, tableName, attrs, ifTableExists);</span>
<span class="fc" id="L719">                case  DROP_COMPACT_STORAGE: return new DropCompactStorage(keyspaceName, tableName, ifTableExists);</span>
            }

<span class="nc" id="L722">            throw new AssertionError();</span>
        }

        public void alter(ColumnIdentifier name, CQL3Type.Raw type)
        {
<span class="nc" id="L727">            kind = Kind.ALTER_COLUMN;</span>
<span class="nc" id="L728">        }</span>

        public void mask(ColumnIdentifier name, ColumnMask.Raw mask)
        {
<span class="fc" id="L732">            kind = Kind.MASK_COLUMN;</span>
<span class="fc" id="L733">            maskedColumn = name;</span>
<span class="fc" id="L734">            rawMask = mask;</span>
<span class="fc" id="L735">        }</span>

        public void add(ColumnIdentifier name, CQL3Type.Raw type, boolean isStatic, @Nullable ColumnMask.Raw mask)
        {
<span class="fc" id="L739">            kind = Kind.ADD_COLUMNS;</span>
<span class="fc" id="L740">            addedColumns.add(new AddColumns.Column(name, type, isStatic, mask));</span>
<span class="fc" id="L741">        }</span>

        public void drop(ColumnIdentifier name)
        {
<span class="fc" id="L745">            kind = Kind.DROP_COLUMNS;</span>
<span class="fc" id="L746">            droppedColumns.add(name);</span>
<span class="fc" id="L747">        }</span>

        public void ifColumnNotExists(boolean ifNotExists)
        {
<span class="fc" id="L751">            ifColumnNotExists = ifNotExists;</span>
<span class="fc" id="L752">        }</span>

        public void ifColumnExists(boolean ifExists)
        {
<span class="fc" id="L756">            ifColumnExists = ifExists;</span>
<span class="fc" id="L757">        }</span>

        public void dropCompactStorage()
        {
<span class="fc" id="L761">            kind = Kind.DROP_COMPACT_STORAGE;</span>
<span class="fc" id="L762">        }</span>

        public void timestamp(long timestamp)
        {
<span class="fc" id="L766">            this.timestamp = timestamp;</span>
<span class="fc" id="L767">        }</span>

        public void rename(ColumnIdentifier from, ColumnIdentifier to)
        {
<span class="fc" id="L771">            kind = Kind.RENAME_COLUMNS;</span>
<span class="fc" id="L772">            renamedColumns.put(from, to);</span>
<span class="fc" id="L773">        }</span>

        public void attrs()
        {
<span class="fc" id="L777">            this.kind = Kind.ALTER_OPTIONS;</span>
<span class="fc" id="L778">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>