<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WarningsSnapshot.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.service.reads.thresholds</a> &gt; <span class="el_source">WarningsSnapshot.java</span></div><h1>WarningsSnapshot.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.service.reads.thresholds;

import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.atomic.AtomicLong;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableSet;

import org.apache.cassandra.db.ConsistencyLevel;
import org.apache.cassandra.db.ReadCommand;
import org.apache.cassandra.exceptions.ReadSizeAbortException;
import org.apache.cassandra.exceptions.RequestFailureReason;
import org.apache.cassandra.exceptions.TombstoneAbortException;
import org.apache.cassandra.locator.InetAddressAndPort;

public class WarningsSnapshot
{
<span class="fc" id="L37">    private static final WarningsSnapshot EMPTY = new WarningsSnapshot(Warnings.EMPTY, Warnings.EMPTY, Warnings.EMPTY);</span>

    public final Warnings tombstones, localReadSize, rowIndexReadSize;

    private WarningsSnapshot(Warnings tombstones, Warnings localReadSize, Warnings rowIndexReadSize)
<span class="fc" id="L42">    {</span>
<span class="fc" id="L43">        this.tombstones = tombstones;</span>
<span class="fc" id="L44">        this.localReadSize = localReadSize;</span>
<span class="fc" id="L45">        this.rowIndexReadSize = rowIndexReadSize;</span>
<span class="fc" id="L46">    }</span>

    public static WarningsSnapshot empty()
    {
<span class="fc" id="L50">        return EMPTY;</span>
    }

    public static WarningsSnapshot create(Warnings tombstones, Warnings localReadSize, Warnings rowIndexTooLarge)
    {
<span class="pc bpc" id="L55" title="1 of 6 branches missed.">        if (tombstones == localReadSize &amp;&amp; tombstones == rowIndexTooLarge &amp;&amp; tombstones == Warnings.EMPTY)</span>
<span class="fc" id="L56">            return EMPTY;</span>
<span class="fc" id="L57">        return new WarningsSnapshot(tombstones, localReadSize, rowIndexTooLarge);</span>
    }

    public static WarningsSnapshot merge(WarningsSnapshot... values)
    {
<span class="pc bpc" id="L62" title="2 of 4 branches missed.">        if (values == null || values.length == 0)</span>
<span class="nc" id="L63">            return null;</span>

<span class="fc" id="L65">        WarningsSnapshot accum = EMPTY;</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">        for (WarningsSnapshot a : values)</span>
<span class="fc" id="L67">            accum = accum.merge(a);</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">        return accum == EMPTY ? null : accum;</span>
    }

    public boolean isEmpty()
    {
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">        return this == EMPTY;</span>
    }

    public boolean isDefined()
    {
<span class="fc bfc" id="L78" title="All 2 branches covered.">        return this != EMPTY;</span>
    }

    @VisibleForTesting
    WarningsSnapshot merge(WarningsSnapshot other)
    {
<span class="fc bfc" id="L84" title="All 4 branches covered.">        if (other == null || other == EMPTY)</span>
<span class="fc" id="L85">            return this;</span>
<span class="fc" id="L86">        return WarningsSnapshot.create(tombstones.merge(other.tombstones), localReadSize.merge(other.localReadSize), rowIndexReadSize.merge(other.rowIndexReadSize));</span>
    }

    public void maybeAbort(ReadCommand command, ConsistencyLevel cl, int received, int blockFor, boolean isDataPresent, Map&lt;InetAddressAndPort, RequestFailureReason&gt; failureReasonByEndpoint)
    {
<span class="fc bfc" id="L91" title="All 2 branches covered.">        if (!tombstones.aborts.instances.isEmpty())</span>
<span class="fc" id="L92">            throw new TombstoneAbortException(tombstones.aborts.instances.size(), tombstones.aborts.maxValue, command.toCQLString(), isDataPresent,</span>
                                              cl, received, blockFor, failureReasonByEndpoint);

<span class="fc bfc" id="L95" title="All 2 branches covered.">        if (!localReadSize.aborts.instances.isEmpty())</span>
<span class="fc" id="L96">            throw new ReadSizeAbortException(localReadSizeAbortMessage(localReadSize.aborts.instances.size(), localReadSize.aborts.maxValue, command.toCQLString()),</span>
                                             cl, received, blockFor, isDataPresent, failureReasonByEndpoint);

<span class="pc bpc" id="L99" title="1 of 2 branches missed.">        if (!rowIndexReadSize.aborts.instances.isEmpty())</span>
<span class="fc" id="L100">            throw new ReadSizeAbortException(rowIndexReadSizeAbortMessage(rowIndexReadSize.aborts.instances.size(), rowIndexReadSize.aborts.maxValue, command.toCQLString()),</span>
                                             cl, received, blockFor, isDataPresent, failureReasonByEndpoint);
<span class="nc" id="L102">    }</span>

    @VisibleForTesting
    public static String tombstoneAbortMessage(int nodes, long tombstones, String cql)
    {
<span class="fc" id="L107">        return String.format(&quot;%s nodes scanned over %s tombstones and aborted the query %s (see tombstone_failure_threshold)&quot;, nodes, tombstones, cql);</span>
    }

    @VisibleForTesting
    public static String tombstoneWarnMessage(int nodes, long tombstones, String cql)
    {
<span class="fc" id="L113">        return String.format(&quot;%s nodes scanned up to %s tombstones and issued tombstone warnings for query %s  (see tombstone_warn_threshold)&quot;, nodes, tombstones, cql);</span>
    }

    @VisibleForTesting
    public static String localReadSizeAbortMessage(long nodes, long bytes, String cql)
    {
<span class="fc" id="L119">        return String.format(&quot;%s nodes loaded over %s bytes and aborted the query %s (see local_read_size_fail_threshold)&quot;, nodes, bytes, cql);</span>
    }

    @VisibleForTesting
    public static String localReadSizeWarnMessage(int nodes, long bytes, String cql)
    {
<span class="fc" id="L125">        return String.format(&quot;%s nodes loaded over %s bytes and issued local read size warnings for query %s  (see local_read_size_warn_threshold)&quot;, nodes, bytes, cql);</span>
    }

    @VisibleForTesting
    public static String rowIndexReadSizeAbortMessage(long nodes, long bytes, String cql)
    {
<span class="fc" id="L131">        return String.format(&quot;%s nodes loaded over %s bytes in RowIndexEntry and aborted the query %s (see row_index_size_fail_threshold)&quot;, nodes, bytes, cql);</span>
    }

    @VisibleForTesting
    public static String rowIndexSizeWarnMessage(int nodes, long bytes, String cql)
    {
<span class="fc" id="L137">        return String.format(&quot;%s nodes loaded over %s bytes in RowIndexEntry and issued warnings for query %s  (see row_index_size_warn_threshold)&quot;, nodes, bytes, cql);</span>
    }

    @Override
    public boolean equals(Object o)
    {
<span class="fc bfc" id="L143" title="All 2 branches covered.">        if (this == o) return true;</span>
<span class="pc bpc" id="L144" title="2 of 4 branches missed.">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L145">        WarningsSnapshot that = (WarningsSnapshot) o;</span>
<span class="pc bpc" id="L146" title="3 of 6 branches missed.">        return Objects.equals(tombstones, that.tombstones) &amp;&amp; Objects.equals(localReadSize, that.localReadSize) &amp;&amp; Objects.equals(rowIndexReadSize, that.rowIndexReadSize);</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L152">        return Objects.hash(tombstones, localReadSize, rowIndexReadSize);</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L158">        return &quot;(tombstones=&quot; + tombstones + &quot;, localReadSize=&quot; + localReadSize + &quot;, rowIndexTooLarge=&quot; + rowIndexReadSize + ')';</span>
    }

    public static final class Warnings
    {
<span class="fc" id="L163">        private static final Warnings EMPTY = new Warnings(Counter.EMPTY, Counter.EMPTY);</span>

        public final Counter warnings;
        public final Counter aborts;

        private Warnings(Counter warnings, Counter aborts)
<span class="fc" id="L169">        {</span>
<span class="fc" id="L170">            this.warnings = warnings;</span>
<span class="fc" id="L171">            this.aborts = aborts;</span>
<span class="fc" id="L172">        }</span>

        public static Warnings create(Counter warnings, Counter aborts)
        {
<span class="fc bfc" id="L176" title="All 4 branches covered.">            if (warnings == Counter.EMPTY &amp;&amp; aborts == Counter.EMPTY)</span>
<span class="fc" id="L177">                return EMPTY;</span>
<span class="fc" id="L178">            return new Warnings(warnings, aborts);</span>
        }

        public Warnings merge(Warnings other)
        {
<span class="fc bfc" id="L183" title="All 2 branches covered.">            if (other == EMPTY)</span>
<span class="fc" id="L184">                return this;</span>
<span class="fc" id="L185">            return Warnings.create(warnings.merge(other.warnings), aborts.merge(other.aborts));</span>
        }

        @Override
        public boolean equals(Object o)
        {
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">            if (this == o) return true;</span>
<span class="pc bpc" id="L192" title="2 of 4 branches missed.">            if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L193">            Warnings warnings1 = (Warnings) o;</span>
<span class="pc bpc" id="L194" title="2 of 4 branches missed.">            return Objects.equals(warnings, warnings1.warnings) &amp;&amp; Objects.equals(aborts, warnings1.aborts);</span>
        }

        @Override
        public int hashCode()
        {
<span class="nc" id="L200">            return Objects.hash(warnings, aborts);</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L206">            return &quot;(warnings=&quot; + warnings + &quot;, aborts=&quot; + aborts + ')';</span>
        }
    }

    public static final class Counter
    {
<span class="fc" id="L212">        private static final Counter EMPTY = new Counter(ImmutableSet.of(), 0);</span>

        public final ImmutableSet&lt;InetAddressAndPort&gt; instances;
        public final long maxValue;

        @VisibleForTesting
        Counter(ImmutableSet&lt;InetAddressAndPort&gt; instances, long maxValue)
<span class="fc" id="L219">        {</span>
<span class="fc" id="L220">            this.instances = instances;</span>
<span class="fc" id="L221">            this.maxValue = maxValue;</span>
<span class="fc" id="L222">        }</span>

        @VisibleForTesting
        static Counter empty()
        {
<span class="fc" id="L227">            return EMPTY;</span>
        }

        public static Counter create(Set&lt;InetAddressAndPort&gt; instances, AtomicLong maxValue)
        {
<span class="fc" id="L232">            ImmutableSet&lt;InetAddressAndPort&gt; copy = ImmutableSet.copyOf(instances);</span>
            // if instances is empty ignore value
            // writes and reads are concurrent (write = networking callback, read = coordinator thread), so there is
            // an edge case where instances is empty and maxValue &gt; 0; this is caused by the fact we update value first before count
            // we write: value then instance
            // we read: instance then value
<span class="fc bfc" id="L238" title="All 2 branches covered.">            if (copy.isEmpty())</span>
<span class="fc" id="L239">                return EMPTY;</span>
<span class="fc" id="L240">            return new Counter(copy, maxValue.get());</span>
        }

        public Counter merge(Counter other)
        {
<span class="fc bfc" id="L245" title="All 2 branches covered.">            if (other == EMPTY)</span>
<span class="fc" id="L246">                return this;</span>
<span class="fc" id="L247">            ImmutableSet&lt;InetAddressAndPort&gt; copy = ImmutableSet.&lt;InetAddressAndPort&gt;builder()</span>
<span class="fc" id="L248">                                                    .addAll(instances)</span>
<span class="fc" id="L249">                                                    .addAll(other.instances)</span>
<span class="fc" id="L250">                                                    .build();</span>
            // since other is NOT empty, then output can not be empty; so skip create method
<span class="fc" id="L252">            return new Counter(copy, Math.max(maxValue, other.maxValue));</span>
        }

        @Override
        public boolean equals(Object o)
        {
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">            if (this == o) return true;</span>
<span class="pc bpc" id="L259" title="2 of 4 branches missed.">            if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L260">            Counter counter = (Counter) o;</span>
<span class="pc bpc" id="L261" title="2 of 4 branches missed.">            return maxValue == counter.maxValue &amp;&amp; Objects.equals(instances, counter.instances);</span>
        }

        @Override
        public int hashCode()
        {
<span class="nc" id="L267">            return Objects.hash(instances, maxValue);</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L273">            return &quot;(&quot; + instances + &quot;, &quot; + maxValue + ')';</span>
        }
    }

    @VisibleForTesting
    static Builder builder()
    {
<span class="fc" id="L280">        return new Builder();</span>
    }

    @VisibleForTesting
<span class="fc" id="L284">    public static final class Builder</span>
    {
<span class="fc" id="L286">        private WarningsSnapshot snapshot = empty();</span>

        public Builder tombstonesWarning(ImmutableSet&lt;InetAddressAndPort&gt; instances, long maxValue)
        {
<span class="nc" id="L290">            return tombstonesWarning(new Counter(Objects.requireNonNull(instances), maxValue));</span>
        }

        public Builder tombstonesWarning(Counter counter)
        {
<span class="fc" id="L295">            Objects.requireNonNull(counter);</span>
<span class="fc" id="L296">            snapshot = snapshot.merge(new WarningsSnapshot(new Warnings(counter, Counter.EMPTY), Warnings.EMPTY, Warnings.EMPTY));</span>
<span class="fc" id="L297">            return this;</span>
        }

        public Builder tombstonesAbort(ImmutableSet&lt;InetAddressAndPort&gt; instances, long maxValue)
        {
<span class="fc" id="L302">            return tombstonesAbort(new Counter(Objects.requireNonNull(instances), maxValue));</span>
        }

        public Builder tombstonesAbort(Counter counter)
        {
<span class="fc" id="L307">            Objects.requireNonNull(counter);</span>
<span class="fc" id="L308">            snapshot = snapshot.merge(new WarningsSnapshot(new Warnings(Counter.EMPTY, counter), Warnings.EMPTY, Warnings.EMPTY));</span>
<span class="fc" id="L309">            return this;</span>
        }

        public Builder localReadSizeWarning(ImmutableSet&lt;InetAddressAndPort&gt; instances, long maxValue)
        {
<span class="fc" id="L314">            return localReadSizeWarning(new Counter(Objects.requireNonNull(instances), maxValue));</span>
        }

        public Builder localReadSizeWarning(Counter counter)
        {
<span class="fc" id="L319">            Objects.requireNonNull(counter);</span>
<span class="fc" id="L320">            snapshot = snapshot.merge(new WarningsSnapshot(Warnings.EMPTY, new Warnings(counter, Counter.EMPTY), Warnings.EMPTY));</span>
<span class="fc" id="L321">            return this;</span>
        }

        public Builder localReadSizeAbort(ImmutableSet&lt;InetAddressAndPort&gt; instances, long maxValue)
        {
<span class="nc" id="L326">            return localReadSizeAbort(new Counter(Objects.requireNonNull(instances), maxValue));</span>
        }

        public Builder localReadSizeAbort(Counter counter)
        {
<span class="fc" id="L331">            Objects.requireNonNull(counter);</span>
<span class="fc" id="L332">            snapshot = snapshot.merge(new WarningsSnapshot(Warnings.EMPTY, new Warnings(Counter.EMPTY, counter), Warnings.EMPTY));</span>
<span class="fc" id="L333">            return this;</span>
        }

        public Builder rowIndexSizeWarning(Counter counter)
        {
<span class="fc" id="L338">            Objects.requireNonNull(counter);</span>
<span class="fc" id="L339">            snapshot = snapshot.merge(new WarningsSnapshot(Warnings.EMPTY, Warnings.EMPTY, new Warnings(counter, Counter.EMPTY)));</span>
<span class="fc" id="L340">            return this;</span>
        }

        public Builder rowIndexSizeAbort(Counter counter)
        {
<span class="fc" id="L345">            Objects.requireNonNull(counter);</span>
<span class="fc" id="L346">            snapshot = snapshot.merge(new WarningsSnapshot(Warnings.EMPTY, Warnings.EMPTY, new Warnings(Counter.EMPTY, counter)));</span>
<span class="fc" id="L347">            return this;</span>
        }

        public WarningsSnapshot build()
        {
<span class="fc" id="L352">            return snapshot;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>