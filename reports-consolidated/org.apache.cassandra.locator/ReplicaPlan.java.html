<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReplicaPlan.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.locator</a> &gt; <span class="el_source">ReplicaPlan.java</span></div><h1>ReplicaPlan.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.locator;

import com.google.common.collect.Iterables;
import org.apache.cassandra.db.ConsistencyLevel;
import org.apache.cassandra.db.Keyspace;
import org.apache.cassandra.db.PartitionPosition;
import org.apache.cassandra.dht.AbstractBounds;

import java.util.function.Predicate;
import java.util.function.Supplier;

public interface ReplicaPlan&lt;E extends Endpoints&lt;E&gt;, P extends ReplicaPlan&lt;E, P&gt;&gt;
{
    Keyspace keyspace();
    AbstractReplicationStrategy replicationStrategy();
    ConsistencyLevel consistencyLevel();

    E contacts();

    Replica lookup(InetAddressAndPort endpoint);
    P withContacts(E contacts);

    interface ForRead&lt;E extends Endpoints&lt;E&gt;, P extends ReplicaPlan.ForRead&lt;E, P&gt;&gt; extends ReplicaPlan&lt;E, P&gt;
    {
        int readQuorum();
        E readCandidates();

        default Replica firstUncontactedCandidate(Predicate&lt;Replica&gt; extraPredicate)
        {
<span class="nc bnc" id="L48" title="All 4 branches missed.">            return Iterables.tryFind(readCandidates(), r -&gt; extraPredicate.test(r) &amp;&amp; !contacts().contains(r)).orNull();</span>
        }
    }

<span class="fc" id="L52">    abstract class AbstractReplicaPlan&lt;E extends Endpoints&lt;E&gt;, P extends ReplicaPlan&lt;E, P&gt;&gt; implements ReplicaPlan&lt;E, P&gt;</span>
    {
        protected final Keyspace keyspace;
        protected final ConsistencyLevel consistencyLevel;
        // The snapshot of the replication strategy when instantiating.
        // It could be different than the one fetched from Keyspace later, e.g. RS altered during the query.
        // Use the snapshot to calculate {@code blockFor} in order to have a consistent view of RS for the query.
        protected final AbstractReplicationStrategy replicationStrategy;

        // all nodes we will contact via any mechanism, including hints
        // i.e., for:
        //  - reads, only live natural replicas
        //      ==&gt; live.natural().subList(0, blockFor + initial speculate)
        //  - writes, includes all full, and any pending replicas, (and only any necessary transient ones to make up the difference)
        //      ==&gt; liveAndDown.natural().filter(isFull) ++ liveAndDown.pending() ++ live.natural.filter(isTransient, req)
        //  - paxos, includes all live replicas (natural+pending), for this DC if SERIAL_LOCAL
        //      ==&gt; live.all()  (if consistencyLevel.isDCLocal(), then .filter(consistencyLevel.isLocal))
        private final E contacts;

        AbstractReplicaPlan(Keyspace keyspace, AbstractReplicationStrategy replicationStrategy, ConsistencyLevel consistencyLevel, E contacts)
<span class="fc" id="L72">        {</span>
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">            assert contacts != null;</span>
<span class="fc" id="L74">            this.keyspace = keyspace;</span>
<span class="fc" id="L75">            this.replicationStrategy = replicationStrategy;</span>
<span class="fc" id="L76">            this.consistencyLevel = consistencyLevel;</span>
<span class="fc" id="L77">            this.contacts = contacts;</span>
<span class="fc" id="L78">        }</span>

<span class="fc" id="L80">        public E contacts() { return contacts; }</span>

<span class="fc" id="L82">        public Keyspace keyspace() { return keyspace; }</span>
<span class="fc" id="L83">        public AbstractReplicationStrategy replicationStrategy() { return replicationStrategy; }</span>
<span class="fc" id="L84">        public ConsistencyLevel consistencyLevel() { return consistencyLevel; }</span>
    }

    public static abstract class AbstractForRead&lt;E extends Endpoints&lt;E&gt;, P extends ForRead&lt;E, P&gt;&gt; extends AbstractReplicaPlan&lt;E, P&gt; implements ForRead&lt;E, P&gt;
    {
        // all nodes we *could* contacts; typically all natural replicas that are believed to be alive
        // we will consult this collection to find uncontacted nodes we might contact if we doubt we will meet consistency level
        final E candidates;

        AbstractForRead(Keyspace keyspace, AbstractReplicationStrategy replicationStrategy, ConsistencyLevel consistencyLevel, E candidates, E contacts)
        {
<span class="fc" id="L95">            super(keyspace, replicationStrategy, consistencyLevel, contacts);</span>
<span class="fc" id="L96">            this.candidates = candidates;</span>
<span class="fc" id="L97">        }</span>

<span class="fc" id="L99">        public int readQuorum() { return consistencyLevel.blockFor(replicationStrategy); }</span>

<span class="fc" id="L101">        public E readCandidates() { return candidates; }</span>

        public Replica firstUncontactedCandidate(Predicate&lt;Replica&gt; extraPredicate)
        {
<span class="pc bpc" id="L105" title="1 of 4 branches missed.">            return Iterables.tryFind(readCandidates(), r -&gt; extraPredicate.test(r) &amp;&amp; !contacts().contains(r)).orNull();</span>
        }

        public Replica lookup(InetAddressAndPort endpoint)
        {
<span class="fc" id="L110">            return readCandidates().byEndpoint().get(endpoint);</span>
        }

        public String toString()
        {
<span class="nc" id="L115">            return &quot;ReplicaPlan.ForRead [ CL: &quot; + consistencyLevel + &quot; keyspace: &quot; + keyspace + &quot; candidates: &quot; + candidates + &quot; contacts: &quot; + contacts() + &quot; ]&quot;;</span>
        }
    }

    public static class ForTokenRead extends AbstractForRead&lt;EndpointsForToken, ForTokenRead&gt;
    {
        public ForTokenRead(Keyspace keyspace,
                            AbstractReplicationStrategy replicationStrategy,
                            ConsistencyLevel consistencyLevel,
                            EndpointsForToken candidates,
                            EndpointsForToken contacts)
        {
<span class="fc" id="L127">            super(keyspace, replicationStrategy, consistencyLevel, candidates, contacts);</span>
<span class="fc" id="L128">        }</span>

        public ForTokenRead withContacts(EndpointsForToken newContact)
        {
<span class="fc" id="L132">            return new ForTokenRead(keyspace, replicationStrategy, consistencyLevel, candidates, newContact);</span>
        }
    }

    public static class ForRangeRead extends AbstractForRead&lt;EndpointsForRange, ForRangeRead&gt;
    {
        final AbstractBounds&lt;PartitionPosition&gt; range;
        final int vnodeCount;

        public ForRangeRead(Keyspace keyspace,
                            AbstractReplicationStrategy replicationStrategy,
                            ConsistencyLevel consistencyLevel,
                            AbstractBounds&lt;PartitionPosition&gt; range,
                            EndpointsForRange candidates,
                            EndpointsForRange contact,
                            int vnodeCount)
        {
<span class="fc" id="L149">            super(keyspace, replicationStrategy, consistencyLevel, candidates, contact);</span>
<span class="fc" id="L150">            this.range = range;</span>
<span class="fc" id="L151">            this.vnodeCount = vnodeCount;</span>
<span class="fc" id="L152">        }</span>

<span class="fc" id="L154">        public AbstractBounds&lt;PartitionPosition&gt; range() { return range; }</span>

        /**
         * @return number of vnode ranges covered by the range
         */
<span class="fc" id="L159">        public int vnodeCount() { return vnodeCount; }</span>

        public ForRangeRead withContacts(EndpointsForRange newContact)
        {
<span class="fc" id="L163">            return new ForRangeRead(keyspace, replicationStrategy, consistencyLevel, range, readCandidates(), newContact, vnodeCount);</span>
        }
    }

    public static class ForWrite extends AbstractReplicaPlan&lt;EndpointsForToken, ForWrite&gt;
    {
        // TODO: this is only needed because of poor isolation of concerns elsewhere - we can remove it soon, and will do so in a follow-up patch
        final EndpointsForToken pending;
        final EndpointsForToken liveAndDown;
        final EndpointsForToken live;

        public ForWrite(Keyspace keyspace, AbstractReplicationStrategy replicationStrategy, ConsistencyLevel consistencyLevel, EndpointsForToken pending, EndpointsForToken liveAndDown, EndpointsForToken live, EndpointsForToken contact)
        {
<span class="fc" id="L176">            super(keyspace, replicationStrategy, consistencyLevel, contact);</span>
<span class="fc" id="L177">            this.pending = pending;</span>
<span class="fc" id="L178">            this.liveAndDown = liveAndDown;</span>
<span class="fc" id="L179">            this.live = live;</span>
<span class="fc" id="L180">        }</span>

<span class="fc" id="L182">        public int writeQuorum() { return consistencyLevel.blockForWrite(replicationStrategy, pending()); }</span>

        /** Replicas that a region of the ring is moving to; not yet ready to serve reads, but should receive writes */
<span class="fc" id="L185">        public EndpointsForToken pending() { return pending; }</span>

        /** Replicas that can participate in the write - this always includes all nodes (pending and natural) in all DCs, except for paxos LOCAL_QUORUM (which is local DC only) */
<span class="fc" id="L188">        public EndpointsForToken liveAndDown() { return liveAndDown; }</span>

        /** The live replicas present in liveAndDown, usually derived from FailureDetector.isReplicaAlive */
<span class="fc" id="L191">        public EndpointsForToken live() { return live; }</span>

        /** Calculate which live endpoints we could have contacted, but chose not to */
<span class="fc bfc" id="L194" title="All 2 branches covered.">        public EndpointsForToken liveUncontacted() { return live().filter(r -&gt; !contacts().contains(r)); }</span>

        /** Test liveness, consistent with the upfront analysis done for this operation (i.e. test membership of live()) */
<span class="fc" id="L197">        public boolean isAlive(Replica replica) { return live.endpoints().contains(replica.endpoint()); }</span>

        public Replica lookup(InetAddressAndPort endpoint)
        {
<span class="fc" id="L201">            return liveAndDown().byEndpoint().get(endpoint);</span>
        }

        private ForWrite copy(ConsistencyLevel newConsistencyLevel, EndpointsForToken newContact)
        {
<span class="fc" id="L206">            return new ForWrite(keyspace, replicationStrategy, newConsistencyLevel, pending(), liveAndDown(), live(), newContact);</span>
        }

<span class="fc" id="L209">        ForWrite withConsistencyLevel(ConsistencyLevel newConsistencylevel) { return copy(newConsistencylevel, contacts()); }</span>
<span class="fc" id="L210">        public ForWrite withContacts(EndpointsForToken newContact) { return copy(consistencyLevel, newContact); }</span>

        public String toString()
        {
<span class="nc" id="L214">            return &quot;ReplicaPlan.ForWrite [ CL: &quot; + consistencyLevel + &quot; keyspace: &quot; + keyspace + &quot; liveAndDown: &quot; + liveAndDown + &quot; live: &quot; + live + &quot; contacts: &quot; + contacts() +  &quot; ]&quot;;</span>
        }
    }

    public static class ForPaxosWrite extends ForWrite
    {
        final int requiredParticipants;

        ForPaxosWrite(Keyspace keyspace, ConsistencyLevel consistencyLevel, EndpointsForToken pending, EndpointsForToken liveAndDown, EndpointsForToken live, EndpointsForToken contact, int requiredParticipants)
        {
<span class="fc" id="L224">            super(keyspace, keyspace.getReplicationStrategy(), consistencyLevel, pending, liveAndDown, live, contact);</span>
<span class="fc" id="L225">            this.requiredParticipants = requiredParticipants;</span>
<span class="fc" id="L226">        }</span>

<span class="fc" id="L228">        public int requiredParticipants() { return requiredParticipants; }</span>
    }

    /**
     * Used by AbstractReadExecutor, {Data,Digest}Resolver and ReadRepair to share a ReplicaPlan whose 'contacts' replicas
     * we progressively modify via various forms of speculation (initial speculation, rr-read and rr-write)
     *
     * The internal reference is not volatile, despite being shared between threads.  The initial reference provided to
     * the constructor should be visible by the normal process of sharing data between threads (i.e. executors, etc)
     * and any updates will either be seen or not seen, perhaps not promptly, but certainly not incompletely.
     * The contained ReplicaPlan has only final member properties, so it cannot be seen partially initialised.
     *
     * TODO: there's no reason this couldn't be achieved instead by a ReplicaPlan with mutable contacts,
     *       simplifying the hierarchy
     */
    public interface Shared&lt;E extends Endpoints&lt;E&gt;, P extends ReplicaPlan&lt;E, P&gt;&gt; extends Supplier&lt;P&gt;
    {
        /**
         * add the provided replica to this shared plan, by updating the internal reference
         */
        public void addToContacts(Replica replica);
        /**
         * get the shared replica plan, non-volatile (so maybe stale) but no risk of partially initialised
         */
        public P get();
    }

    public static class SharedForTokenRead implements Shared&lt;EndpointsForToken, ForTokenRead&gt;
    {
        private ForTokenRead replicaPlan;
<span class="fc" id="L258">        SharedForTokenRead(ForTokenRead replicaPlan) { this.replicaPlan = replicaPlan; }</span>
<span class="fc" id="L259">        public void addToContacts(Replica replica) { replicaPlan = replicaPlan.withContacts(Endpoints.append(replicaPlan.contacts(), replica)); }</span>
<span class="fc" id="L260">        public ForTokenRead get() { return replicaPlan; }</span>
    }

    public static class SharedForRangeRead implements Shared&lt;EndpointsForRange, ForRangeRead&gt;
    {
        private ForRangeRead replicaPlan;
<span class="fc" id="L266">        SharedForRangeRead(ForRangeRead replicaPlan) { this.replicaPlan = replicaPlan; }</span>
<span class="fc" id="L267">        public void addToContacts(Replica replica) { replicaPlan = replicaPlan.withContacts(Endpoints.append(replicaPlan.contacts(), replica)); }</span>
<span class="fc" id="L268">        public ForRangeRead get() { return replicaPlan; }</span>
    }

<span class="fc" id="L271">    public static SharedForTokenRead shared(ForTokenRead replicaPlan) { return new SharedForTokenRead(replicaPlan); }</span>
<span class="fc" id="L272">    public static SharedForRangeRead shared(ForRangeRead replicaPlan) { return new SharedForRangeRead(replicaPlan); }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>