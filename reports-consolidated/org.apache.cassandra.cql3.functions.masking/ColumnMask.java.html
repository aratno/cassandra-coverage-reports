<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ColumnMask.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.functions.masking</a> &gt; <span class="el_source">ColumnMask.java</span></div><h1>ColumnMask.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.cql3.functions.masking;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

import com.google.common.collect.ImmutableList;
import org.apache.commons.lang3.StringUtils;

import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.cql3.AssignmentTestable;
import org.apache.cassandra.cql3.CQL3Type;
import org.apache.cassandra.cql3.ColumnIdentifier;
import org.apache.cassandra.cql3.CqlBuilder;
import org.apache.cassandra.cql3.Term;
import org.apache.cassandra.cql3.Terms;
import org.apache.cassandra.cql3.functions.Arguments;
import org.apache.cassandra.cql3.functions.Function;
import org.apache.cassandra.cql3.functions.FunctionName;
import org.apache.cassandra.cql3.functions.FunctionResolver;
import org.apache.cassandra.cql3.functions.ScalarFunction;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.marshal.ReversedType;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.transport.ProtocolVersion;

import static java.lang.String.format;
import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;

/**
 * Dynamic data mask that can be applied to a schema column.
 * &lt;p&gt;
 * It consists on a partial application of a certain {@link MaskingFunction} to the values of a column, with the
 * precondition that the type of any masked column is compatible with the type of the first argument of the function.
 * &lt;p&gt;
 * This partial application is meant to be associated to specific columns in the schema, acting as a mask for the values
 * of those columns. It's associated to queries such as:
 * &lt;pre&gt;
 *    CREATE TABLE t (k int PRIMARY KEY, v int MASKED WITH mask_inner(1, 1));
 *    ALTER TABLE t ALTER v MASKED WITH mask_inner(2, 1);
 *    ALTER TABLE t ALTER v DROP MASKED;
 * &lt;/pre&gt;
 * Note that in the example above we are referencing the {@code mask_inner} function with two arguments. However, that
 * CQL function actually has three arguments. The first argument is always ommitted when attaching the function to a
 * schema column. The value of that first argument is always the value of the masked column, in this case an int.
 */
<span class="fc" id="L68">public class ColumnMask</span>
{
    public static final String DISABLED_ERROR_MESSAGE = &quot;Cannot mask columns because dynamic data masking is not &quot; +
                                                        &quot;enabled. You can enable it with the &quot; +
                                                        &quot;dynamic_data_masking_enabled property on cassandra.yaml&quot;;

    /** The CQL function used for masking. */
    public final ScalarFunction function;

    /** The values of the arguments of the partially applied masking function. */
    protected final ByteBuffer[] partialArgumentValues;

    public ColumnMask(ScalarFunction function, ByteBuffer... partialArgumentValues)
<span class="fc" id="L81">    {</span>
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">        assert function.argTypes().size() == partialArgumentValues.length + 1;</span>
<span class="fc" id="L83">        this.function = function;</span>
<span class="fc" id="L84">        this.partialArgumentValues = partialArgumentValues;</span>
<span class="fc" id="L85">    }</span>

    /**
     * @return The types of the arguments of the partially applied masking function, as an unmodifiable list.
     */
    public List&lt;AbstractType&lt;?&gt;&gt; partialArgumentTypes()
    {
<span class="fc" id="L92">        List&lt;AbstractType&lt;?&gt;&gt; argTypes = function.argTypes();</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">        return argTypes.size() == 1</span>
<span class="fc" id="L94">               ? Collections.emptyList()</span>
<span class="fc" id="L95">               : Collections.unmodifiableList(argTypes.subList(1, argTypes.size()));</span>
    }

    /**
     * @return The values of the arguments of the partially applied masking function, as an unmodifiable list that can
     * contain nulls.
     */
    public List&lt;ByteBuffer&gt; partialArgumentValues()
    {
<span class="fc" id="L104">        return Collections.unmodifiableList(Arrays.asList(partialArgumentValues));</span>
    }

    /**
     * @return A copy of this mask for a version of its masked column that has its type reversed.
     */
    public ColumnMask withReversedType()
    {
<span class="fc" id="L112">        AbstractType&lt;?&gt; reversed = ReversedType.getInstance(function.argTypes().get(0));</span>
<span class="fc" id="L113">        List&lt;AbstractType&lt;?&gt;&gt; args = ImmutableList.&lt;AbstractType&lt;?&gt;&gt;builder()</span>
<span class="fc" id="L114">                                                  .add(reversed)</span>
<span class="fc" id="L115">                                                  .addAll(partialArgumentTypes())</span>
<span class="fc" id="L116">                                                  .build();</span>
<span class="fc" id="L117">        Function newFunction = FunctionResolver.get(function.name().keyspace, function.name(), args, null, null, null);</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">        assert newFunction != null;</span>
<span class="fc" id="L119">        return new ColumnMask((ScalarFunction) newFunction, partialArgumentValues);</span>
    }

    /**
     * @param version the used version of the transport protocol
     * @return a masker instance that caches the terminal masking function arguments
     */
    public Masker masker(ProtocolVersion version)
    {
<span class="fc" id="L128">        return new Masker(version, function, partialArgumentValues);</span>
    }

    public static class Masker
    {
        private final ScalarFunction function;
        private final Arguments arguments;

        private Masker(ProtocolVersion version, ScalarFunction function, ByteBuffer[] partialArgumentValues)
<span class="fc" id="L137">        {</span>
<span class="fc" id="L138">            this.function = function;</span>
<span class="fc" id="L139">            arguments = function.newArguments(version);</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">            for (int i = 0; i &lt; partialArgumentValues.length; i++)</span>
<span class="fc" id="L141">                arguments.set(i + 1, partialArgumentValues[i]);</span>
<span class="fc" id="L142">        }</span>

        public ByteBuffer mask(ByteBuffer value)
        {
<span class="fc" id="L146">            arguments.set(0, value);</span>
<span class="fc" id="L147">            return function.execute(arguments);</span>
        }
    }

    public static void ensureEnabled()
    {
<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (!DatabaseDescriptor.getDynamicDataMaskingEnabled())</span>
<span class="fc" id="L154">            throw new InvalidRequestException(DISABLED_ERROR_MESSAGE);</span>
<span class="fc" id="L155">    }</span>

    @Override
    public boolean equals(Object o)
    {
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        if (this == o)</span>
<span class="nc" id="L161">            return true;</span>
<span class="pc bpc" id="L162" title="1 of 4 branches missed.">        if (o == null || getClass() != o.getClass())</span>
<span class="fc" id="L163">            return false;</span>
<span class="fc" id="L164">        ColumnMask mask = (ColumnMask) o;</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">        return function.name().equals(mask.function.name())</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">               &amp;&amp; Arrays.equals(partialArgumentValues, mask.partialArgumentValues);</span>
    }

    @Override
    public int hashCode()
    {
<span class="fc" id="L172">        return Objects.hash(function.name(), Arrays.hashCode(partialArgumentValues));</span>
    }

    @Override
    public String toString()
    {
<span class="fc" id="L178">        List&lt;AbstractType&lt;?&gt;&gt; types = partialArgumentTypes();</span>
<span class="fc" id="L179">        List&lt;String&gt; arguments = new ArrayList&lt;&gt;(types.size());</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">        for (int i = 0; i &lt; types.size(); i++)</span>
        {
<span class="fc" id="L182">            CQL3Type type = types.get(i).asCQL3Type();</span>
<span class="fc" id="L183">            ByteBuffer value = partialArgumentValues[i];</span>
<span class="fc" id="L184">            arguments.add(type.toCQLLiteral(value));</span>
        }
<span class="fc" id="L186">        return format(&quot;%s(%s)&quot;, function.name(), StringUtils.join(arguments, &quot;, &quot;));</span>
    }

    public void appendCqlTo(CqlBuilder builder)
    {
<span class="fc" id="L191">        builder.append(&quot; MASKED WITH &quot;).append(toString());</span>
<span class="fc" id="L192">    }</span>

    /**
     * A parsed but not prepared column mask.
     */
    public final static class Raw
    {
        public final FunctionName name;
        public final List&lt;Term.Raw&gt; rawPartialArguments;

        public Raw(FunctionName name, List&lt;Term.Raw&gt; rawPartialArguments)
<span class="fc" id="L203">        {</span>
<span class="fc" id="L204">            this.name = name;</span>
<span class="fc" id="L205">            this.rawPartialArguments = rawPartialArguments;</span>
<span class="fc" id="L206">        }</span>

        public ColumnMask prepare(String keyspace, String table, ColumnIdentifier column, AbstractType&lt;?&gt; type)
        {
<span class="fc" id="L210">            ScalarFunction function = findMaskingFunction(keyspace, table, column, type);</span>
<span class="fc" id="L211">            ByteBuffer[] partialArguments = preparePartialArguments(keyspace, function);</span>
<span class="fc" id="L212">            return new ColumnMask(function, partialArguments);</span>
        }

        private ScalarFunction findMaskingFunction(String keyspace, String table, ColumnIdentifier column, AbstractType&lt;?&gt; type)
        {
<span class="fc" id="L217">            List&lt;AssignmentTestable&gt; args = new ArrayList&lt;&gt;(rawPartialArguments.size() + 1);</span>
<span class="fc" id="L218">            args.add(type);</span>
<span class="fc" id="L219">            args.addAll(rawPartialArguments);</span>

<span class="fc" id="L221">            Function function = FunctionResolver.get(keyspace, name, args, keyspace, table, type);</span>

<span class="fc bfc" id="L223" title="All 2 branches covered.">            if (function == null)</span>
<span class="fc" id="L224">                throw invalidRequest(&quot;Unable to find masking function for %s, &quot; +</span>
                                     &quot;no declared function matches the signature %s&quot;,
                                     column, this);

<span class="fc bfc" id="L228" title="All 2 branches covered.">            if (function.isAggregate())</span>
<span class="fc" id="L229">                throw invalidRequest(&quot;Aggregate function %s cannot be used for masking table columns&quot;, this);</span>

<span class="fc bfc" id="L231" title="All 4 branches covered.">            if (function.isNative() &amp;&amp; !(function instanceof MaskingFunction))</span>
<span class="fc" id="L232">                throw invalidRequest(&quot;Not-masking function %s cannot be used for masking table columns&quot;, this);</span>

<span class="fc bfc" id="L234" title="All 4 branches covered.">            if (!function.isNative() &amp;&amp; !function.name().keyspace.equals(keyspace))</span>
<span class="fc" id="L235">                throw invalidRequest(&quot;Masking function %s doesn't belong to the same keyspace as the table %s.%s&quot;,</span>
                                     this, keyspace, table);

<span class="fc" id="L238">            CQL3Type returnType = function.returnType().asCQL3Type();</span>
<span class="fc" id="L239">            CQL3Type expectedType = type.asCQL3Type();</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">            if (!returnType.equals(expectedType))</span>
<span class="fc" id="L241">                throw invalidRequest(&quot;Masking function %s return type is %s. &quot; +</span>
                                     &quot;This is different to the type of the masked column %s of type %s. &quot; +
                                     &quot;Masking functions can only be attached to table columns &quot; +
                                     &quot;if they return the same data type as the masked column.&quot;,
                                     this, returnType, column, expectedType);

<span class="fc" id="L247">            return (ScalarFunction) function;</span>
        }

        private ByteBuffer[] preparePartialArguments(String keyspace, ScalarFunction function)
        {
            // Note that there could be null arguments
<span class="fc" id="L253">            ByteBuffer[] arguments = new ByteBuffer[rawPartialArguments.size()];</span>

<span class="fc bfc" id="L255" title="All 2 branches covered.">            for (int i = 0; i &lt; rawPartialArguments.size(); i++)</span>
            {
<span class="fc" id="L257">                String term = rawPartialArguments.get(i).toString();</span>
<span class="fc" id="L258">                AbstractType&lt;?&gt; type = function.argTypes().get(i + 1);</span>
<span class="fc" id="L259">                arguments[i] = Terms.asBytes(keyspace, term, type);</span>
            }

<span class="fc" id="L262">            return arguments;</span>
        }

        @Override
        public String toString()
        {
<span class="fc" id="L268">            return format(&quot;%s(%s)&quot;, name, StringUtils.join(rawPartialArguments, &quot;, &quot;));</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>