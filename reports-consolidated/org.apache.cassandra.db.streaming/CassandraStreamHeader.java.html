<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CassandraStreamHeader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.streaming</a> &gt; <span class="el_source">CassandraStreamHeader.java</span></div><h1>CassandraStreamHeader.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.streaming;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.function.Function;

import com.google.common.annotations.VisibleForTesting;

import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.SerializationHeader;
import org.apache.cassandra.db.TypeSizes;
import org.apache.cassandra.dht.IPartitioner;
import org.apache.cassandra.io.IVersionedSerializer;
import org.apache.cassandra.io.sstable.format.SSTableFormat;
import org.apache.cassandra.io.sstable.format.SSTableReader;
import org.apache.cassandra.io.sstable.format.Version;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.schema.TableId;
import org.apache.cassandra.utils.ByteBufferUtil;

import static com.google.common.base.Preconditions.checkNotNull;

public class CassandraStreamHeader
{
    /** SSTable version */
    public final Version version;

    public final long estimatedKeys;
    public final List&lt;SSTableReader.PartitionPositionBounds&gt; sections;
    public final CompressionInfo compressionInfo;
    public final int sstableLevel;
    public final SerializationHeader.Component serializationHeader;

    /* flag indicating whether this is a partial or entire sstable transfer */
    public final boolean isEntireSSTable;
    /* first token of the sstable required for faster streaming */
    public final DecoratedKey firstKey;
    public final TableId tableId;
    public final ComponentManifest componentManifest;

    /* cached size value */
    private final long size;

    private CassandraStreamHeader(Builder builder)
<span class="fc" id="L68">    {</span>
<span class="fc" id="L69">        version = builder.version;</span>
<span class="fc" id="L70">        estimatedKeys = builder.estimatedKeys;</span>
<span class="fc" id="L71">        sections = builder.sections;</span>
<span class="fc" id="L72">        compressionInfo = builder.compressionInfo;</span>
<span class="fc" id="L73">        sstableLevel = builder.sstableLevel;</span>
<span class="fc" id="L74">        serializationHeader = builder.serializationHeader;</span>
<span class="fc" id="L75">        tableId = builder.tableId;</span>
<span class="fc" id="L76">        isEntireSSTable = builder.isEntireSSTable;</span>
<span class="fc" id="L77">        componentManifest = builder.componentManifest;</span>
<span class="fc" id="L78">        firstKey = builder.firstKey;</span>
<span class="fc" id="L79">        size = calculateSize();</span>
<span class="fc" id="L80">    }</span>

    public static Builder builder()
    {
<span class="fc" id="L84">        return new Builder();</span>
    }

    public boolean isCompressed()
    {
<span class="fc bfc" id="L89" title="All 2 branches covered.">        return compressionInfo != null;</span>
    }

    /**
     * @return total file size to transfer in bytes
     */
    public long size()
    {
<span class="fc" id="L97">        return size;</span>
    }

    @VisibleForTesting
    public long calculateSize()
    {
<span class="fc bfc" id="L103" title="All 2 branches covered.">        if (isEntireSSTable)</span>
<span class="fc" id="L104">            return componentManifest.totalSize();</span>

<span class="fc bfc" id="L106" title="All 2 branches covered.">        if (compressionInfo != null)</span>
<span class="fc" id="L107">            return compressionInfo.getTotalSize();</span>

<span class="fc" id="L109">        long transferSize = 0;</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">        for (SSTableReader.PartitionPositionBounds section : sections)</span>
<span class="fc" id="L111">            transferSize += section.upperPosition - section.lowerPosition;</span>
<span class="fc" id="L112">        return transferSize;</span>
    }

    @Override
    public boolean equals(Object o)
    {
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">        if (this == o) return true;</span>
<span class="pc bpc" id="L119" title="2 of 4 branches missed.">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L120">        CassandraStreamHeader that = (CassandraStreamHeader) o;</span>
<span class="pc bpc" id="L121" title="3 of 6 branches missed.">        return estimatedKeys == that.estimatedKeys &amp;&amp;</span>
               sstableLevel == that.sstableLevel &amp;&amp;
               isEntireSSTable == that.isEntireSSTable &amp;&amp;
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">               Objects.equals(version, that.version) &amp;&amp;</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">               Objects.equals(sections, that.sections) &amp;&amp;</span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">               Objects.equals(compressionInfo, that.compressionInfo) &amp;&amp;</span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">               Objects.equals(serializationHeader, that.serializationHeader) &amp;&amp;</span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">               Objects.equals(componentManifest, that.componentManifest) &amp;&amp;</span>
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">               Objects.equals(firstKey, that.firstKey) &amp;&amp;</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">               Objects.equals(tableId, that.tableId);</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L136">        return Objects.hash(version, estimatedKeys, sections, compressionInfo, sstableLevel, serializationHeader, componentManifest,</span>
<span class="nc" id="L137">                            isEntireSSTable, firstKey, tableId);</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L143">        return &quot;CassandraStreamHeader{&quot; +</span>
               &quot;version=&quot; + version +
<span class="nc" id="L145">               &quot;, format=&quot; + version.format.name() +</span>
               &quot;, estimatedKeys=&quot; + estimatedKeys +
               &quot;, sections=&quot; + sections +
               &quot;, sstableLevel=&quot; + sstableLevel +
               &quot;, header=&quot; + serializationHeader +
               &quot;, isEntireSSTable=&quot; + isEntireSSTable +
               &quot;, firstKey=&quot; + firstKey +
               &quot;, tableId=&quot; + tableId +
               '}';
    }

<span class="fc" id="L156">    public static final IVersionedSerializer&lt;CassandraStreamHeader&gt; serializer = new CassandraStreamHeaderSerializer();</span>

<span class="fc" id="L158">    public static class CassandraStreamHeaderSerializer implements IVersionedSerializer&lt;CassandraStreamHeader&gt;</span>
    {
        public void serialize(CassandraStreamHeader header, DataOutputPlus out, int version) throws IOException
        {
<span class="fc" id="L162">            out.writeUTF(header.version.toString());</span>
<span class="fc" id="L163">            out.writeUTF(header.version.format.name());</span>

<span class="fc" id="L165">            out.writeLong(header.estimatedKeys);</span>
<span class="fc" id="L166">            out.writeInt(header.sections.size());</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">            for (SSTableReader.PartitionPositionBounds section : header.sections)</span>
            {
<span class="fc" id="L169">                out.writeLong(section.lowerPosition);</span>
<span class="fc" id="L170">                out.writeLong(section.upperPosition);</span>
<span class="fc" id="L171">            }</span>
<span class="fc" id="L172">            CompressionInfo.serializer.serialize(header.compressionInfo, out, version);</span>
<span class="fc" id="L173">            out.writeInt(header.sstableLevel);</span>

<span class="fc" id="L175">            SerializationHeader.serializer.serialize(header.version, header.serializationHeader, out);</span>

<span class="fc" id="L177">            header.tableId.serialize(out);</span>
<span class="fc" id="L178">            out.writeBoolean(header.isEntireSSTable);</span>

<span class="fc bfc" id="L180" title="All 2 branches covered.">            if (header.isEntireSSTable)</span>
            {
<span class="fc" id="L182">                ComponentManifest.serializers.get(header.version.format.name()).serialize(header.componentManifest, out, version);</span>
<span class="fc" id="L183">                ByteBufferUtil.writeWithVIntLength(header.firstKey.getKey(), out);</span>
            }
<span class="fc" id="L185">        }</span>

        public CassandraStreamHeader deserialize(DataInputPlus in, int version) throws IOException
        {
<span class="fc" id="L189">            return deserialize(in, version, tableId -&gt; {</span>
<span class="fc" id="L190">                ColumnFamilyStore cfs = ColumnFamilyStore.getIfExists(tableId);</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">                if (cfs != null)</span>
<span class="fc" id="L192">                    return cfs.getPartitioner();</span>

<span class="nc" id="L194">                return null;</span>
            });
        }

        @VisibleForTesting
        public CassandraStreamHeader deserialize(DataInputPlus in, int version, Function&lt;TableId, IPartitioner&gt; partitionerMapper) throws IOException
        {
<span class="fc" id="L201">            String sstableVersionString = in.readUTF();</span>
<span class="fc" id="L202">            String formatName = in.readUTF();</span>
<span class="fc" id="L203">            SSTableFormat&lt;?, ?&gt; format = Objects.requireNonNull(DatabaseDescriptor.getSSTableFormats().get(formatName),</span>
<span class="fc" id="L204">                                                                String.format(&quot;Unknown SSTable format '%s'&quot;, formatName));</span>
<span class="fc" id="L205">            Version sstableVersion = format.getVersion(sstableVersionString);</span>

<span class="fc" id="L207">            long estimatedKeys = in.readLong();</span>
<span class="fc" id="L208">            int count = in.readInt();</span>
<span class="fc" id="L209">            List&lt;SSTableReader.PartitionPositionBounds&gt; sections = new ArrayList&lt;&gt;(count);</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">            for (int k = 0; k &lt; count; k++)</span>
<span class="fc" id="L211">                sections.add(new SSTableReader.PartitionPositionBounds(in.readLong(), in.readLong()));</span>
<span class="fc" id="L212">            CompressionInfo compressionInfo = CompressionInfo.serializer.deserialize(in, version);</span>
<span class="fc" id="L213">            int sstableLevel = in.readInt();</span>

<span class="fc" id="L215">            SerializationHeader.Component header =  SerializationHeader.serializer.deserialize(sstableVersion, in);</span>

<span class="fc" id="L217">            TableId tableId = TableId.deserialize(in);</span>
<span class="fc" id="L218">            boolean isEntireSSTable = in.readBoolean();</span>
<span class="fc" id="L219">            ComponentManifest manifest = null;</span>
<span class="fc" id="L220">            DecoratedKey firstKey = null;</span>

<span class="fc bfc" id="L222" title="All 2 branches covered.">            if (isEntireSSTable)</span>
            {
<span class="fc" id="L224">                manifest = ComponentManifest.serializers.get(format.name()).deserialize(in, version);</span>
<span class="fc" id="L225">                ByteBuffer keyBuf = ByteBufferUtil.readWithVIntLength(in);</span>
<span class="fc" id="L226">                IPartitioner partitioner = partitionerMapper.apply(tableId);</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">                if (partitioner == null)</span>
<span class="nc" id="L228">                    throw new IllegalArgumentException(String.format(&quot;Could not determine partitioner for tableId %s&quot;, tableId));</span>
<span class="fc" id="L229">                firstKey = partitioner.decorateKey(keyBuf);</span>
            }

<span class="fc" id="L232">            return builder().withSSTableVersion(sstableVersion)</span>
<span class="fc" id="L233">                            .withSSTableLevel(sstableLevel)</span>
<span class="fc" id="L234">                            .withEstimatedKeys(estimatedKeys)</span>
<span class="fc" id="L235">                            .withSections(sections)</span>
<span class="fc" id="L236">                            .withCompressionInfo(compressionInfo)</span>
<span class="fc" id="L237">                            .withSerializationHeader(header)</span>
<span class="fc" id="L238">                            .withComponentManifest(manifest)</span>
<span class="fc" id="L239">                            .isEntireSSTable(isEntireSSTable)</span>
<span class="fc" id="L240">                            .withFirstKey(firstKey)</span>
<span class="fc" id="L241">                            .withTableId(tableId)</span>
<span class="fc" id="L242">                            .build();</span>
        }

        public long serializedSize(CassandraStreamHeader header, int version)
        {
<span class="fc" id="L247">            long size = 0;</span>
<span class="fc" id="L248">            size += TypeSizes.sizeof(header.version.toString());</span>
<span class="fc" id="L249">            size += TypeSizes.sizeof(header.version.format.name());</span>
<span class="fc" id="L250">            size += TypeSizes.sizeof(header.estimatedKeys);</span>

<span class="fc" id="L252">            size += TypeSizes.sizeof(header.sections.size());</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">            for (SSTableReader.PartitionPositionBounds section : header.sections)</span>
            {
<span class="fc" id="L255">                size += TypeSizes.sizeof(section.lowerPosition);</span>
<span class="fc" id="L256">                size += TypeSizes.sizeof(section.upperPosition);</span>
<span class="fc" id="L257">            }</span>

<span class="fc" id="L259">            size += CompressionInfo.serializer.serializedSize(header.compressionInfo, version);</span>
<span class="fc" id="L260">            size += TypeSizes.sizeof(header.sstableLevel);</span>

<span class="fc" id="L262">            size += SerializationHeader.serializer.serializedSize(header.version, header.serializationHeader);</span>

<span class="fc" id="L264">            size += header.tableId.serializedSize();</span>
<span class="fc" id="L265">            size += TypeSizes.sizeof(header.isEntireSSTable);</span>

<span class="fc bfc" id="L267" title="All 2 branches covered.">            if (header.isEntireSSTable)</span>
            {
<span class="fc" id="L269">                size += ComponentManifest.serializers.get(header.version.format.name()).serializedSize(header.componentManifest, version);</span>
<span class="fc" id="L270">                size += ByteBufferUtil.serializedSizeWithVIntLength(header.firstKey.getKey());</span>
            }
<span class="fc" id="L272">            return size;</span>
        }
    }

<span class="fc" id="L276">    public static final class Builder</span>
    {
        private Version version;
        private long estimatedKeys;
        private List&lt;SSTableReader.PartitionPositionBounds&gt; sections;
        private CompressionInfo compressionInfo;
        private int sstableLevel;
        private SerializationHeader.Component serializationHeader;
        private ComponentManifest componentManifest;
        private boolean isEntireSSTable;
        private DecoratedKey firstKey;
        private TableId tableId;

        public Builder withSSTableVersion(Version version)
        {
<span class="fc" id="L291">            this.version = version;</span>
<span class="fc" id="L292">            return this;</span>
        }

        public Builder withSSTableLevel(int sstableLevel)
        {
<span class="fc" id="L297">            this.sstableLevel = sstableLevel;</span>
<span class="fc" id="L298">            return this;</span>
        }

        public Builder withEstimatedKeys(long estimatedKeys)
        {
<span class="fc" id="L303">            this.estimatedKeys = estimatedKeys;</span>
<span class="fc" id="L304">            return this;</span>
        }

        public Builder withSections(List&lt;SSTableReader.PartitionPositionBounds&gt; sections)
        {
<span class="fc" id="L309">            this.sections = sections;</span>
<span class="fc" id="L310">            return this;</span>
        }

        public Builder withCompressionInfo(CompressionInfo compressionInfo)
        {
<span class="fc" id="L315">            this.compressionInfo = compressionInfo;</span>
<span class="fc" id="L316">            return this;</span>
        }

        public Builder withSerializationHeader(SerializationHeader.Component header)
        {
<span class="fc" id="L321">            this.serializationHeader = header;</span>
<span class="fc" id="L322">            return this;</span>
        }

        public Builder withTableId(TableId tableId)
        {
<span class="fc" id="L327">            this.tableId = tableId;</span>
<span class="fc" id="L328">            return this;</span>
        }

        public Builder isEntireSSTable(boolean isEntireSSTable)
        {
<span class="fc" id="L333">            this.isEntireSSTable = isEntireSSTable;</span>
<span class="fc" id="L334">            return this;</span>
        }

        public Builder withComponentManifest(ComponentManifest componentManifest)
        {
<span class="fc" id="L339">            this.componentManifest = componentManifest;</span>
<span class="fc" id="L340">            return this;</span>
        }

        public Builder withFirstKey(DecoratedKey firstKey)
        {
<span class="fc" id="L345">            this.firstKey = firstKey;</span>
<span class="fc" id="L346">            return this;</span>
        }

        public CassandraStreamHeader build()
        {
<span class="fc" id="L351">            checkNotNull(version);</span>
<span class="fc" id="L352">            checkNotNull(sections);</span>
<span class="fc" id="L353">            checkNotNull(serializationHeader);</span>
<span class="fc" id="L354">            checkNotNull(tableId);</span>

<span class="fc bfc" id="L356" title="All 2 branches covered.">            if (isEntireSSTable)</span>
            {
<span class="fc" id="L358">                checkNotNull(componentManifest);</span>
<span class="fc" id="L359">                checkNotNull(firstKey);</span>
            }

<span class="fc" id="L362">            return new CassandraStreamHeader(this);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>