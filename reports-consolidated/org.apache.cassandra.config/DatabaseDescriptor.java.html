<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DatabaseDescriptor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.config</a> &gt; <span class="el_source">DatabaseDescriptor.java</span></div><h1>DatabaseDescriptor.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.config;

import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;
import java.net.Inet4Address;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.nio.file.FileStore;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.OptionalDouble;
import java.util.ServiceLoader;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import javax.annotation.Nullable;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import com.google.common.primitives.Ints;
import com.google.common.primitives.Longs;
import com.google.common.util.concurrent.RateLimiter;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.googlecode.concurrenttrees.common.Iterables;
import org.apache.cassandra.audit.AuditLogOptions;
import org.apache.cassandra.auth.AllowAllInternodeAuthenticator;
import org.apache.cassandra.auth.AuthConfig;
import org.apache.cassandra.auth.IAuthenticator;
import org.apache.cassandra.auth.IAuthorizer;
import org.apache.cassandra.auth.ICIDRAuthorizer;
import org.apache.cassandra.auth.IInternodeAuthenticator;
import org.apache.cassandra.auth.INetworkAuthorizer;
import org.apache.cassandra.auth.IRoleManager;
import org.apache.cassandra.config.Config.CommitLogSync;
import org.apache.cassandra.config.Config.PaxosOnLinearizabilityViolation;
import org.apache.cassandra.config.Config.PaxosStatePurging;
import org.apache.cassandra.db.ConsistencyLevel;
import org.apache.cassandra.db.commitlog.AbstractCommitLogSegmentManager;
import org.apache.cassandra.db.commitlog.CommitLog;
import org.apache.cassandra.db.commitlog.CommitLogSegmentManagerCDC;
import org.apache.cassandra.db.commitlog.CommitLogSegmentManagerStandard;
import org.apache.cassandra.dht.IPartitioner;
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.fql.FullQueryLoggerOptions;
import org.apache.cassandra.gms.IFailureDetector;
import org.apache.cassandra.io.FSWriteError;
import org.apache.cassandra.io.sstable.format.SSTableFormat;
import org.apache.cassandra.io.sstable.format.big.BigFormat;
import org.apache.cassandra.io.util.DiskOptimizationStrategy;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.io.util.PathUtils;
import org.apache.cassandra.io.util.SpinningDiskOptimizationStrategy;
import org.apache.cassandra.io.util.SsdDiskOptimizationStrategy;
import org.apache.cassandra.locator.DynamicEndpointSnitch;
import org.apache.cassandra.locator.EndpointSnitchInfo;
import org.apache.cassandra.locator.IEndpointSnitch;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.locator.Replica;
import org.apache.cassandra.locator.SeedProvider;
import org.apache.cassandra.security.AbstractCryptoProvider;
import org.apache.cassandra.security.EncryptionContext;
import org.apache.cassandra.security.JREProvider;
import org.apache.cassandra.security.SSLFactory;
import org.apache.cassandra.service.CacheService.CacheType;
import org.apache.cassandra.service.paxos.Paxos;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.StorageCompatibilityMode;

import static org.apache.cassandra.config.CassandraRelevantProperties.ALLOCATE_TOKENS_FOR_KEYSPACE;
import static org.apache.cassandra.config.CassandraRelevantProperties.ALLOW_UNLIMITED_CONCURRENT_VALIDATIONS;
import static org.apache.cassandra.config.CassandraRelevantProperties.AUTO_BOOTSTRAP;
import static org.apache.cassandra.config.CassandraRelevantProperties.CONFIG_LOADER;
import static org.apache.cassandra.config.CassandraRelevantProperties.DISABLE_STCS_IN_L0;
import static org.apache.cassandra.config.CassandraRelevantProperties.INITIAL_TOKEN;
import static org.apache.cassandra.config.CassandraRelevantProperties.IO_NETTY_TRANSPORT_ESTIMATE_SIZE_ON_SUBMIT;
import static org.apache.cassandra.config.CassandraRelevantProperties.NATIVE_TRANSPORT_PORT;
import static org.apache.cassandra.config.CassandraRelevantProperties.OS_ARCH;
import static org.apache.cassandra.config.CassandraRelevantProperties.PARTITIONER;
import static org.apache.cassandra.config.CassandraRelevantProperties.REPLACE_ADDRESS;
import static org.apache.cassandra.config.CassandraRelevantProperties.REPLACE_ADDRESS_FIRST_BOOT;
import static org.apache.cassandra.config.CassandraRelevantProperties.REPLACE_NODE;
import static org.apache.cassandra.config.CassandraRelevantProperties.REPLACE_TOKEN;
import static org.apache.cassandra.config.CassandraRelevantProperties.SEARCH_CONCURRENCY_FACTOR;
import static org.apache.cassandra.config.CassandraRelevantProperties.SSL_STORAGE_PORT;
import static org.apache.cassandra.config.CassandraRelevantProperties.STORAGE_DIR;
import static org.apache.cassandra.config.CassandraRelevantProperties.STORAGE_PORT;
import static org.apache.cassandra.config.CassandraRelevantProperties.SUN_ARCH_DATA_MODEL;
import static org.apache.cassandra.config.CassandraRelevantProperties.TEST_FAIL_MV_LOCKS_COUNT;
import static org.apache.cassandra.config.CassandraRelevantProperties.TEST_JVM_DTEST_DISABLE_SSL;
import static org.apache.cassandra.config.CassandraRelevantProperties.TEST_SKIP_CRYPTO_PROVIDER_INSTALLATION;
import static org.apache.cassandra.config.CassandraRelevantProperties.TEST_STRICT_RUNTIME_CHECKS;
import static org.apache.cassandra.config.CassandraRelevantProperties.UNSAFE_SYSTEM;
import static org.apache.cassandra.config.DataRateSpec.DataRateUnit.BYTES_PER_SECOND;
import static org.apache.cassandra.config.DataRateSpec.DataRateUnit.MEBIBYTES_PER_SECOND;
import static org.apache.cassandra.config.DataStorageSpec.DataStorageUnit.MEBIBYTES;
import static org.apache.cassandra.io.util.FileUtils.ONE_GIB;
import static org.apache.cassandra.io.util.FileUtils.ONE_MIB;
import static org.apache.cassandra.utils.Clock.Global.logInitializationOutcome;

<span class="nc" id="L142">public class DatabaseDescriptor</span>
{
    static
    {
        // This static block covers most usages
<span class="fc" id="L147">        FBUtilities.preventIllegalAccessWarnings();</span>
<span class="fc" id="L148">        IO_NETTY_TRANSPORT_ESTIMATE_SIZE_ON_SUBMIT.setBoolean(false);</span>
    }

<span class="fc" id="L151">    private static final Logger logger = LoggerFactory.getLogger(DatabaseDescriptor.class);</span>

    /**
     * Tokens are serialized in a Gossip VersionedValue String.  VV are restricted to 64KiB
     * when we send them over the wire, which works out to about 1700 tokens.
     */
    private static final int MAX_NUM_TOKENS = 1536;

    private static Config conf;

    /**
     * Request timeouts can not be less than below defined value (see CASSANDRA-9375)
     */
<span class="fc" id="L164">    static final DurationSpec.LongMillisecondsBound LOWEST_ACCEPTED_TIMEOUT = new DurationSpec.LongMillisecondsBound(10L);</span>

    private static Supplier&lt;IFailureDetector&gt; newFailureDetector;
    private static IEndpointSnitch snitch;
    private static InetAddress listenAddress; // leave null so we can fall through to getLocalHost
    private static InetAddress broadcastAddress;
    private static InetAddress rpcAddress;
    private static InetAddress broadcastRpcAddress;
    private static SeedProvider seedProvider;
<span class="fc" id="L173">    private static IInternodeAuthenticator internodeAuthenticator = new AllowAllInternodeAuthenticator();</span>

    /* Hashing strategy Random or OPHF */
    private static IPartitioner partitioner;
    private static String paritionerName;

    private static Config.DiskAccessMode indexAccessMode;

    private static AbstractCryptoProvider cryptoProvider;
    private static IAuthenticator authenticator;
    private static IAuthorizer authorizer;
    private static INetworkAuthorizer networkAuthorizer;
    private static ICIDRAuthorizer cidrAuthorizer;

    // Don't initialize the role manager until applying config. The options supported by CassandraRoleManager
    // depend on the configured IAuthenticator, so defer creating it until that's been set.
    private static IRoleManager roleManager;

    private static long preparedStatementsCacheSizeInMiB;

    private static long keyCacheSizeInMiB;
    private static long paxosCacheSizeInMiB;
    private static long counterCacheSizeInMiB;
    private static long indexSummaryCapacityInMiB;

    private static String localDC;
    private static Comparator&lt;Replica&gt; localComparator;
    private static EncryptionContext encryptionContext;
    private static boolean hasLoggedConfig;

    private static DiskOptimizationStrategy diskOptimizationStrategy;

    private static boolean clientInitialized;
    private static boolean toolInitialized;
    private static boolean daemonInitialized;

<span class="fc" id="L209">    private static final int searchConcurrencyFactor = SEARCH_CONCURRENCY_FACTOR.getInt();</span>
    private static DurationSpec.IntSecondsBound autoSnapshoTtl;

<span class="fc" id="L212">    private static volatile boolean disableSTCSInL0 = DISABLE_STCS_IN_L0.getBoolean();</span>
<span class="fc" id="L213">    private static final boolean unsafeSystem = UNSAFE_SYSTEM.getBoolean();</span>

    // turns some warnings into exceptions for testing
<span class="fc" id="L216">    private static final boolean strictRuntimeChecks = TEST_STRICT_RUNTIME_CHECKS.getBoolean();</span>

<span class="fc" id="L218">    public static volatile boolean allowUnlimitedConcurrentValidations = ALLOW_UNLIMITED_CONCURRENT_VALIDATIONS.getBoolean();</span>

    /**
     * The configuration for guardrails.
     */
    private static GuardrailsOptions guardrails;
    private static StartupChecksOptions startupChecksOptions;

    private static ImmutableMap&lt;String, SSTableFormat&lt;?, ?&gt;&gt; sstableFormats;
    private static volatile SSTableFormat&lt;?, ?&gt; selectedSSTableFormat;

<span class="fc bfc" id="L229" title="All 2 branches covered.">    private static Function&lt;CommitLog, AbstractCommitLogSegmentManager&gt; commitLogSegmentMgrProvider = c -&gt; DatabaseDescriptor.isCDCEnabled()</span>
<span class="fc" id="L230">                                                                                                           ? new CommitLogSegmentManagerCDC(c, DatabaseDescriptor.getCommitLogLocation())</span>
<span class="fc" id="L231">                                                                                                           : new CommitLogSegmentManagerStandard(c, DatabaseDescriptor.getCommitLogLocation());</span>

    public static void daemonInitialization() throws ConfigurationException
    {
<span class="fc" id="L235">        daemonInitialization(DatabaseDescriptor::loadConfig);</span>
<span class="fc" id="L236">    }</span>

    public static void daemonInitialization(Supplier&lt;Config&gt; config) throws ConfigurationException
    {
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        if (toolInitialized)</span>
<span class="nc" id="L241">            throw new AssertionError(&quot;toolInitialization() already called&quot;);</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">        if (clientInitialized)</span>
<span class="nc" id="L243">            throw new AssertionError(&quot;clientInitialization() already called&quot;);</span>

        // Some unit tests require this :(
<span class="fc bfc" id="L246" title="All 2 branches covered.">        if (daemonInitialized)</span>
<span class="fc" id="L247">            return;</span>
<span class="fc" id="L248">        daemonInitialized = true;</span>

<span class="fc" id="L250">        setConfig(config.get());</span>
<span class="fc" id="L251">        applyAll();</span>
<span class="fc" id="L252">        AuthConfig.applyAuth();</span>
<span class="fc" id="L253">    }</span>

    /**
     * Equivalent to {@link #toolInitialization(boolean) toolInitialization(true)}.
     */
    public static void toolInitialization()
    {
<span class="fc" id="L260">        toolInitialization(true);</span>
<span class="fc" id="L261">    }</span>

    /**
     * Initializes this class as a tool, which means that the configuration is loaded
     * using {@link #loadConfig()} and all non-daemon configuration parts will be setup.
     *
     * @param failIfDaemonOrClient if {@code true} and a call to {@link #daemonInitialization()} or
     *                             {@link #clientInitialization()} has been performed before, an
     *                             {@link AssertionError} will be thrown.
     */
    public static void toolInitialization(boolean failIfDaemonOrClient)
    {
<span class="pc bpc" id="L273" title="3 of 6 branches missed.">        if (!failIfDaemonOrClient &amp;&amp; (daemonInitialized || clientInitialized))</span>
        {
<span class="fc" id="L275">            return;</span>
        }
        else
        {
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">            if (daemonInitialized)</span>
<span class="nc" id="L280">                throw new AssertionError(&quot;daemonInitialization() already called&quot;);</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">            if (clientInitialized)</span>
<span class="nc" id="L282">                throw new AssertionError(&quot;clientInitialization() already called&quot;);</span>
        }

<span class="fc bfc" id="L285" title="All 2 branches covered.">        if (toolInitialized)</span>
<span class="fc" id="L286">            return;</span>
<span class="fc" id="L287">        toolInitialized = true;</span>

<span class="fc" id="L289">        setConfig(loadConfig());</span>

<span class="fc" id="L291">        applySSTableFormats();</span>

<span class="fc" id="L293">        applySimpleConfig();</span>

<span class="fc" id="L295">        applyPartitioner();</span>

<span class="fc" id="L297">        applySnitch();</span>

<span class="fc" id="L299">        applyEncryptionContext();</span>
<span class="fc" id="L300">    }</span>

    /**
     * Equivalent to {@link #clientInitialization(boolean) clientInitialization(true)}.
     */
    public static void clientInitialization()
    {
<span class="fc" id="L307">        clientInitialization(true);</span>
<span class="fc" id="L308">    }</span>

    /**
     * Equivalent to {@link #clientInitialization(boolean) clientInitialization(true, Config::new)}.
     */
    public static void clientInitialization(boolean failIfDaemonOrTool)
    {
<span class="fc" id="L315">        clientInitialization(failIfDaemonOrTool, Config::new);</span>
<span class="fc" id="L316">    }</span>

    /**
     * Initializes this class as a client, which means that just an empty configuration will
     * be used.
     *
     * @param failIfDaemonOrTool if {@code true} and a call to {@link #daemonInitialization()} or
     *                           {@link #toolInitialization()} has been performed before, an
     *                           {@link AssertionError} will be thrown.
     */
    public static void clientInitialization(boolean failIfDaemonOrTool, Supplier&lt;Config&gt; configSupplier)
    {
<span class="pc bpc" id="L328" title="1 of 6 branches missed.">        if (!failIfDaemonOrTool &amp;&amp; (daemonInitialized || toolInitialized))</span>
        {
<span class="fc" id="L330">            return;</span>
        }
        else
        {
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">            if (daemonInitialized)</span>
<span class="nc" id="L335">                throw new AssertionError(&quot;daemonInitialization() already called&quot;);</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">            if (toolInitialized)</span>
<span class="nc" id="L337">                throw new AssertionError(&quot;toolInitialization() already called&quot;);</span>
        }

<span class="fc bfc" id="L340" title="All 2 branches covered.">        if (clientInitialized)</span>
<span class="fc" id="L341">            return;</span>
<span class="fc" id="L342">        clientInitialized = true;</span>
<span class="fc" id="L343">        setDefaultFailureDetector();</span>
<span class="fc" id="L344">        Config.setClientMode(true);</span>
<span class="fc" id="L345">        conf = configSupplier.get();</span>
<span class="fc" id="L346">        diskOptimizationStrategy = new SpinningDiskOptimizationStrategy();</span>
<span class="fc" id="L347">        applySSTableFormats();</span>
<span class="fc" id="L348">    }</span>

    public static boolean isClientInitialized()
    {
<span class="fc" id="L352">        return clientInitialized;</span>
    }

    public static boolean isToolInitialized()
    {
<span class="fc" id="L357">        return toolInitialized;</span>
    }

    public static boolean isClientOrToolInitialized()
    {
<span class="fc bfc" id="L362" title="All 4 branches covered.">        return clientInitialized || toolInitialized;</span>
    }

    public static boolean isDaemonInitialized()
    {
<span class="fc" id="L367">        return daemonInitialized;</span>
    }

    public static Config getRawConfig()
    {
<span class="fc" id="L372">        return conf;</span>
    }

    @VisibleForTesting
    public static Config loadConfig() throws ConfigurationException
    {
<span class="fc bfc" id="L378" title="All 2 branches covered.">        if (Config.getOverrideLoadConfig() != null)</span>
<span class="fc" id="L379">            return Config.getOverrideLoadConfig().get();</span>

<span class="fc" id="L381">        String loaderClass = CONFIG_LOADER.getString();</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">        ConfigurationLoader loader = loaderClass == null</span>
<span class="fc" id="L383">                                     ? new YamlConfigurationLoader()</span>
<span class="fc" id="L384">                                     : FBUtilities.construct(loaderClass, &quot;configuration loading&quot;);</span>
<span class="fc" id="L385">        Config config = loader.loadConfig();</span>

<span class="fc bfc" id="L387" title="All 2 branches covered.">        if (!hasLoggedConfig)</span>
        {
<span class="fc" id="L389">            hasLoggedConfig = true;</span>
<span class="fc" id="L390">            Config.log(config);</span>
        }

<span class="fc" id="L393">        return config;</span>
    }

    private static InetAddress getNetworkInterfaceAddress(String intf, String configName, boolean preferIPv6) throws ConfigurationException
    {
        try
        {
<span class="fc" id="L400">            NetworkInterface ni = NetworkInterface.getByName(intf);</span>
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">            if (ni == null)</span>
<span class="nc" id="L402">                throw new ConfigurationException(&quot;Configured &quot; + configName + &quot; \&quot;&quot; + intf + &quot;\&quot; could not be found&quot;, false);</span>
<span class="fc" id="L403">            Enumeration&lt;InetAddress&gt; addrs = ni.getInetAddresses();</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">            if (!addrs.hasMoreElements())</span>
<span class="nc" id="L405">                throw new ConfigurationException(&quot;Configured &quot; + configName + &quot; \&quot;&quot; + intf + &quot;\&quot; was found, but had no addresses&quot;, false);</span>

            /*
             * Try to return the first address of the preferred type, otherwise return the first address
             */
<span class="fc" id="L410">            InetAddress retval = null;</span>
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">            while (addrs.hasMoreElements())</span>
            {
<span class="fc" id="L413">                InetAddress temp = addrs.nextElement();</span>
<span class="pc bpc" id="L414" title="1 of 4 branches missed.">                if (preferIPv6 &amp;&amp; temp instanceof Inet6Address) return temp;</span>
<span class="pc bpc" id="L415" title="1 of 4 branches missed.">                if (!preferIPv6 &amp;&amp; temp instanceof Inet4Address) return temp;</span>
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">                if (retval == null) retval = temp;</span>
<span class="fc" id="L417">            }</span>
<span class="nc" id="L418">            return retval;</span>
        }
<span class="nc" id="L420">        catch (SocketException e)</span>
        {
<span class="nc" id="L422">            throw new ConfigurationException(&quot;Configured &quot; + configName + &quot; \&quot;&quot; + intf + &quot;\&quot; caused an exception&quot;, e);</span>
        }
    }

    @VisibleForTesting
    public static void setConfig(Config config)
    {
<span class="fc" id="L429">        conf = config;</span>
<span class="fc" id="L430">    }</span>

    private static void applyAll() throws ConfigurationException
    {
        //InetAddressAndPort cares that applySimpleConfig runs first
<span class="fc" id="L435">        applySSTableFormats();</span>

<span class="fc" id="L437">        applyCryptoProvider();</span>

<span class="fc" id="L439">        applySimpleConfig();</span>

<span class="fc" id="L441">        applyPartitioner();</span>

<span class="fc" id="L443">        applyAddressConfig();</span>

<span class="fc" id="L445">        applySnitch();</span>

<span class="fc" id="L447">        applyTokensConfig();</span>

<span class="fc" id="L449">        applySeedProvider();</span>

<span class="fc" id="L451">        applyEncryptionContext();</span>

<span class="fc" id="L453">        applySslContext();</span>

<span class="fc" id="L455">        applyGuardrails();</span>

<span class="fc" id="L457">        applyStartupChecks();</span>
<span class="fc" id="L458">    }</span>

    private static void applySimpleConfig()
    {
        //Doing this first before all other things in case other pieces of config want to construct
        //InetAddressAndPort and get the right defaults
<span class="fc" id="L464">        InetAddressAndPort.initializeDefaultPort(getStoragePort());</span>

<span class="fc" id="L466">        validateUpperBoundStreamingConfig();</span>

<span class="fc bfc" id="L468" title="All 2 branches covered.">        if (conf.auto_snapshot_ttl != null)</span>
        {
            try
            {
<span class="fc" id="L472">                autoSnapshoTtl = new DurationSpec.IntSecondsBound(conf.auto_snapshot_ttl);</span>
            }
<span class="nc" id="L474">            catch (IllegalArgumentException e)</span>
            {
<span class="nc" id="L476">                throw new ConfigurationException(&quot;Invalid value of auto_snapshot_ttl: &quot; + conf.auto_snapshot_ttl, false);</span>
<span class="fc" id="L477">            }</span>
        }

<span class="pc bpc" id="L480" title="1 of 2 branches missed.">        if (conf.commitlog_sync == null)</span>
        {
<span class="nc" id="L482">            throw new ConfigurationException(&quot;Missing required directive CommitLogSync&quot;, false);</span>
        }

<span class="fc bfc" id="L485" title="All 2 branches covered.">        if (conf.commitlog_sync == CommitLogSync.batch)</span>
        {
<span class="pc bpc" id="L487" title="1 of 2 branches missed.">            if (conf.commitlog_sync_period.toMilliseconds() != 0)</span>
            {
<span class="nc" id="L489">                throw new ConfigurationException(&quot;Batch sync specified, but commitlog_sync_period found.&quot;, false);</span>
            }
<span class="fc" id="L491">            logger.debug(&quot;Syncing log with batch mode&quot;);</span>
        }
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">        else if (conf.commitlog_sync == CommitLogSync.group)</span>
        {
<span class="nc bnc" id="L495" title="All 2 branches missed.">            if (conf.commitlog_sync_group_window.toMilliseconds() == 0)</span>
            {
<span class="nc" id="L497">                throw new ConfigurationException(&quot;Missing value for commitlog_sync_group_window.&quot;, false);</span>
            }
<span class="nc bnc" id="L499" title="All 2 branches missed.">            else if (conf.commitlog_sync_period.toMilliseconds() != 0)</span>
            {
<span class="nc" id="L501">                throw new ConfigurationException(&quot;Group sync specified, but commitlog_sync_period found. Only specify commitlog_sync_group_window when using group sync&quot;, false);</span>
            }
<span class="nc" id="L503">            logger.debug(&quot;Syncing log with a group window of {}&quot;, conf.commitlog_sync_period.toString());</span>
        }
        else
        {
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">            if (conf.commitlog_sync_period.toMilliseconds() == 0)</span>
            {
<span class="nc" id="L509">                throw new ConfigurationException(&quot;Missing value for commitlog_sync_period.&quot;, false);</span>
            }
<span class="fc" id="L511">            logger.debug(&quot;Syncing log with a period of {}&quot;, conf.commitlog_sync_period.toString());</span>
        }

        /* evaluate the DiskAccessMode Config directive, which also affects indexAccessMode selection */
<span class="fc bfc" id="L515" title="All 2 branches covered.">        if (conf.disk_access_mode == Config.DiskAccessMode.auto)</span>
        {
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">            conf.disk_access_mode = hasLargeAddressSpace() ? Config.DiskAccessMode.mmap : Config.DiskAccessMode.standard;</span>
<span class="fc" id="L518">            indexAccessMode = conf.disk_access_mode;</span>
<span class="fc" id="L519">            logger.info(&quot;DiskAccessMode 'auto' determined to be {}, indexAccessMode is {}&quot;, conf.disk_access_mode, indexAccessMode);</span>
        }
<span class="fc bfc" id="L521" title="All 2 branches covered.">        else if (conf.disk_access_mode == Config.DiskAccessMode.mmap_index_only)</span>
        {
<span class="fc" id="L523">            conf.disk_access_mode = Config.DiskAccessMode.standard;</span>
<span class="fc" id="L524">            indexAccessMode = Config.DiskAccessMode.mmap;</span>
<span class="fc" id="L525">            logger.info(&quot;DiskAccessMode is {}, indexAccessMode is {}&quot;, conf.disk_access_mode, indexAccessMode);</span>
        }
        else
        {
<span class="fc" id="L529">            indexAccessMode = conf.disk_access_mode;</span>
<span class="fc" id="L530">            logger.info(&quot;DiskAccessMode is {}, indexAccessMode is {}&quot;, conf.disk_access_mode, indexAccessMode);</span>
        }

        /* phi convict threshold for FailureDetector */
<span class="pc bpc" id="L534" title="2 of 4 branches missed.">        if (conf.phi_convict_threshold &lt; 5 || conf.phi_convict_threshold &gt; 16)</span>
        {
<span class="nc" id="L536">            throw new ConfigurationException(&quot;phi_convict_threshold must be between 5 and 16, but was &quot; + conf.phi_convict_threshold, false);</span>
        }

        /* Thread per pool */
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">        if (conf.concurrent_reads &lt; 2)</span>
        {
<span class="nc" id="L542">            throw new ConfigurationException(&quot;concurrent_reads must be at least 2, but was &quot; + conf.concurrent_reads, false);</span>
        }

<span class="pc bpc" id="L545" title="1 of 4 branches missed.">        if (conf.concurrent_writes &lt; 2 &amp;&amp; TEST_FAIL_MV_LOCKS_COUNT.getString(&quot;&quot;).isEmpty())</span>
        {
<span class="nc" id="L547">            throw new ConfigurationException(&quot;concurrent_writes must be at least 2, but was &quot; + conf.concurrent_writes, false);</span>
        }

<span class="pc bpc" id="L550" title="1 of 2 branches missed.">        if (conf.concurrent_counter_writes &lt; 2)</span>
<span class="nc" id="L551">            throw new ConfigurationException(&quot;concurrent_counter_writes must be at least 2, but was &quot; + conf.concurrent_counter_writes, false);</span>

<span class="pc bpc" id="L553" title="1 of 2 branches missed.">        if (conf.concurrent_replicates != null)</span>
<span class="nc" id="L554">            logger.warn(&quot;concurrent_replicates has been deprecated and should be removed from cassandra.yaml&quot;);</span>

<span class="pc bpc" id="L556" title="1 of 2 branches missed.">        if (conf.networking_cache_size == null)</span>
<span class="fc" id="L557">            conf.networking_cache_size = new DataStorageSpec.IntMebibytesBound(Math.min(128, (int) (Runtime.getRuntime().maxMemory() / (16 * 1048576))));</span>

<span class="pc bpc" id="L559" title="1 of 2 branches missed.">        if (conf.file_cache_size == null)</span>
<span class="fc" id="L560">            conf.file_cache_size = new DataStorageSpec.IntMebibytesBound(Math.min(512, (int) (Runtime.getRuntime().maxMemory() / (4 * 1048576))));</span>

        // round down for SSDs and round up for spinning disks
<span class="pc bpc" id="L563" title="1 of 2 branches missed.">        if (conf.file_cache_round_up == null)</span>
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">            conf.file_cache_round_up = conf.disk_optimization_strategy == Config.DiskOptimizationStrategy.spinning;</span>

<span class="pc bpc" id="L566" title="1 of 2 branches missed.">        if (conf.memtable_offheap_space == null)</span>
<span class="fc" id="L567">            conf.memtable_offheap_space = new DataStorageSpec.IntMebibytesBound((int) (Runtime.getRuntime().maxMemory() / (4 * 1048576)));</span>
        // for the moment, we default to twice as much on-heap space as off-heap, as heap overhead is very large
<span class="fc bfc" id="L569" title="All 2 branches covered.">        if (conf.memtable_heap_space == null)</span>
<span class="fc" id="L570">            conf.memtable_heap_space = new DataStorageSpec.IntMebibytesBound((int) (Runtime.getRuntime().maxMemory() / (4 * 1048576)));</span>
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">        if (conf.memtable_heap_space.toMebibytes() == 0)</span>
<span class="nc" id="L572">            throw new ConfigurationException(&quot;memtable_heap_space must be positive, but was &quot; + conf.memtable_heap_space, false);</span>
<span class="fc" id="L573">        logger.info(&quot;Global memtable on-heap threshold is enabled at {}&quot;, conf.memtable_heap_space);</span>
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">        if (conf.memtable_offheap_space.toMebibytes() == 0)</span>
<span class="nc" id="L575">            logger.info(&quot;Global memtable off-heap threshold is disabled, HeapAllocator will be used instead&quot;);</span>
        else
<span class="fc" id="L577">            logger.info(&quot;Global memtable off-heap threshold is enabled at {}&quot;, conf.memtable_offheap_space);</span>

<span class="pc bpc" id="L579" title="1 of 2 branches missed.">        if (conf.repair_session_max_tree_depth != null)</span>
        {
<span class="nc" id="L581">            logger.warn(&quot;repair_session_max_tree_depth has been deprecated and should be removed from cassandra.yaml. Use repair_session_space instead&quot;);</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">            if (conf.repair_session_max_tree_depth &lt; 10)</span>
<span class="nc" id="L583">                throw new ConfigurationException(&quot;repair_session_max_tree_depth should not be &lt; 10, but was &quot; + conf.repair_session_max_tree_depth);</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">            if (conf.repair_session_max_tree_depth &gt; 20)</span>
<span class="nc" id="L585">                logger.warn(&quot;repair_session_max_tree_depth of &quot; + conf.repair_session_max_tree_depth + &quot; &gt; 20 could lead to excessive memory usage&quot;);</span>
        }
        else
        {
<span class="fc" id="L589">            conf.repair_session_max_tree_depth = 20;</span>
        }

<span class="pc bpc" id="L592" title="1 of 2 branches missed.">        if (conf.repair_session_space == null)</span>
<span class="fc" id="L593">            conf.repair_session_space = new DataStorageSpec.IntMebibytesBound(Math.max(1, (int) (Runtime.getRuntime().maxMemory() / (16 * 1048576))));</span>

<span class="pc bpc" id="L595" title="1 of 2 branches missed.">        if (conf.repair_session_space.toMebibytes() &lt; 1)</span>
<span class="nc" id="L596">            throw new ConfigurationException(&quot;repair_session_space must be &gt; 0, but was &quot; + conf.repair_session_space);</span>
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">        else if (conf.repair_session_space.toMebibytes() &gt; (int) (Runtime.getRuntime().maxMemory() / (4 * 1048576)))</span>
<span class="nc" id="L598">            logger.warn(&quot;A repair_session_space of &quot; + conf.repair_session_space+ &quot; mebibytes is likely to cause heap pressure&quot;);</span>

<span class="fc" id="L600">        checkForLowestAcceptedTimeouts(conf);</span>

<span class="fc" id="L602">        long valueInBytes = conf.native_transport_max_frame_size.toBytes();</span>
<span class="pc bpc" id="L603" title="2 of 4 branches missed.">        if (valueInBytes &lt; 0 || valueInBytes &gt; Integer.MAX_VALUE-1)</span>
        {
<span class="nc" id="L605">            throw new ConfigurationException(String.format(&quot;native_transport_max_frame_size must be positive value &lt; %dB, but was %dB&quot;,</span>
<span class="nc" id="L606">                                                           Integer.MAX_VALUE,</span>
<span class="nc" id="L607">                                                           valueInBytes),</span>
                                             false);
        }

<span class="fc bfc" id="L611" title="All 2 branches covered.">        if (conf.column_index_size != null)</span>
<span class="fc" id="L612">            checkValidForByteConversion(conf.column_index_size, &quot;column_index_size&quot;);</span>
<span class="fc" id="L613">        checkValidForByteConversion(conf.column_index_cache_size, &quot;column_index_cache_size&quot;);</span>
<span class="fc" id="L614">        checkValidForByteConversion(conf.batch_size_warn_threshold, &quot;batch_size_warn_threshold&quot;);</span>

<span class="pc bpc" id="L616" title="1 of 2 branches missed.">        if (conf.native_transport_max_negotiable_protocol_version != null)</span>
<span class="nc" id="L617">            logger.warn(&quot;The configuration option native_transport_max_negotiable_protocol_version has been deprecated &quot; +</span>
                        &quot;and should be removed from cassandra.yaml as it has no longer has any effect.&quot;);

        // if data dirs, commitlog dir, or saved caches dir are set in cassandra.yaml, use that.  Otherwise,
        // use -Dcassandra.storagedir (set in cassandra-env.sh) as the parent dir for data/, commitlog/, and saved_caches/
<span class="pc bpc" id="L622" title="1 of 2 branches missed.">        if (conf.commitlog_directory == null)</span>
        {
<span class="nc" id="L624">            conf.commitlog_directory = storagedirFor(&quot;commitlog&quot;);</span>
        }

<span class="pc bpc" id="L627" title="1 of 2 branches missed.">        if (conf.hints_directory == null)</span>
        {
<span class="nc" id="L629">            conf.hints_directory = storagedirFor(&quot;hints&quot;);</span>
        }

<span class="pc bpc" id="L632" title="1 of 2 branches missed.">        if (conf.native_transport_max_request_data_in_flight == null)</span>
        {
<span class="fc" id="L634">            conf.native_transport_max_request_data_in_flight = new DataStorageSpec.LongBytesBound(Runtime.getRuntime().maxMemory() / 10);</span>
        }

<span class="pc bpc" id="L637" title="1 of 2 branches missed.">        if (conf.native_transport_max_request_data_in_flight_per_ip == null)</span>
        {
<span class="fc" id="L639">            conf.native_transport_max_request_data_in_flight_per_ip = new DataStorageSpec.LongBytesBound(Runtime.getRuntime().maxMemory() / 40);</span>
        }

<span class="pc bpc" id="L642" title="1 of 2 branches missed.">        if (conf.native_transport_rate_limiting_enabled)</span>
<span class="nc" id="L643">            logger.info(&quot;Native transport rate-limiting enabled at {} requests/second.&quot;, conf.native_transport_max_requests_per_second);</span>
        else
<span class="fc" id="L645">            logger.info(&quot;Native transport rate-limiting disabled.&quot;);</span>

<span class="pc bpc" id="L647" title="1 of 2 branches missed.">        if (conf.commitlog_total_space == null)</span>
        {
<span class="fc" id="L649">            final int preferredSizeInMiB = 8192;</span>
            // use 1/4 of available space.  See discussion on #10013 and #10199
<span class="fc" id="L651">            final long totalSpaceInBytes = tryGetSpace(conf.commitlog_directory, FileStore::getTotalSpace);</span>
<span class="fc" id="L652">            int defaultSpaceInMiB = calculateDefaultSpaceInMiB(&quot;commitlog&quot;,</span>
                                                               conf.commitlog_directory,
                                                               &quot;commitlog_total_space&quot;,
                                                               preferredSizeInMiB,
                                                               totalSpaceInBytes, 1, 4);
<span class="fc" id="L657">            conf.commitlog_total_space = new DataStorageSpec.IntMebibytesBound(defaultSpaceInMiB);</span>
        }

<span class="fc bfc" id="L660" title="All 2 branches covered.">        if (conf.cdc_enabled)</span>
        {
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">            if (conf.cdc_raw_directory == null)</span>
            {
<span class="nc" id="L664">                conf.cdc_raw_directory = storagedirFor(&quot;cdc_raw&quot;);</span>
            }

<span class="fc bfc" id="L667" title="All 2 branches covered.">            if (conf.cdc_total_space.toMebibytes() == 0)</span>
            {
<span class="fc" id="L669">                final int preferredSizeInMiB = 4096;</span>
                // use 1/8th of available space.  See discussion on #10013 and #10199 on the CL, taking half that for CDC
<span class="fc" id="L671">                final long totalSpaceInBytes = tryGetSpace(conf.cdc_raw_directory, FileStore::getTotalSpace);</span>
<span class="fc" id="L672">                int defaultSpaceInMiB = calculateDefaultSpaceInMiB(&quot;cdc&quot;,</span>
                                                                   conf.cdc_raw_directory,
                                                                   &quot;cdc_total_space&quot;,
                                                                   preferredSizeInMiB,
                                                                   totalSpaceInBytes, 1, 8);
<span class="fc" id="L677">                conf.cdc_total_space = new DataStorageSpec.IntMebibytesBound(defaultSpaceInMiB);</span>
            }

<span class="fc" id="L680">            logger.info(&quot;cdc_enabled is true. Starting casssandra node with Change-Data-Capture enabled.&quot;);</span>
        }

<span class="pc bpc" id="L683" title="1 of 2 branches missed.">        if (conf.saved_caches_directory == null)</span>
        {
<span class="nc" id="L685">            conf.saved_caches_directory = storagedirFor(&quot;saved_caches&quot;);</span>
        }
<span class="pc bpc" id="L687" title="2 of 4 branches missed.">        if (conf.data_file_directories == null || conf.data_file_directories.length == 0)</span>
        {
<span class="nc" id="L689">            conf.data_file_directories = new String[]{ storagedir(&quot;data_file_directories&quot;) + File.pathSeparator() + &quot;data&quot; };</span>
        }

<span class="fc" id="L692">        long dataFreeBytes = 0;</span>
        /* data file and commit log directories. they get created later, when they're needed. */
<span class="fc bfc" id="L694" title="All 2 branches covered.">        for (String datadir : conf.data_file_directories)</span>
        {
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">            if (datadir == null)</span>
<span class="nc" id="L697">                throw new ConfigurationException(&quot;data_file_directories must not contain empty entry&quot;, false);</span>
<span class="pc bpc" id="L698" title="1 of 2 branches missed.">            if (datadir.equals(conf.local_system_data_file_directory))</span>
<span class="nc" id="L699">                throw new ConfigurationException(&quot;local_system_data_file_directory must not be the same as any data_file_directories&quot;, false);</span>
<span class="pc bpc" id="L700" title="1 of 2 branches missed.">            if (datadir.equals(conf.commitlog_directory))</span>
<span class="nc" id="L701">                throw new ConfigurationException(&quot;commitlog_directory must not be the same as any data_file_directories&quot;, false);</span>
<span class="pc bpc" id="L702" title="1 of 2 branches missed.">            if (datadir.equals(conf.hints_directory))</span>
<span class="nc" id="L703">                throw new ConfigurationException(&quot;hints_directory must not be the same as any data_file_directories&quot;, false);</span>
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">            if (datadir.equals(conf.saved_caches_directory))</span>
<span class="nc" id="L705">                throw new ConfigurationException(&quot;saved_caches_directory must not be the same as any data_file_directories&quot;, false);</span>

<span class="fc" id="L707">            dataFreeBytes = saturatedSum(dataFreeBytes, tryGetSpace(datadir, FileStore::getUnallocatedSpace));</span>
        }
<span class="fc bfc" id="L709" title="All 2 branches covered.">        if (dataFreeBytes &lt; 64 * ONE_GIB) // 64 GB</span>
<span class="fc" id="L710">            logger.warn(&quot;Only {} free across all data volumes. Consider adding more capacity to your cluster or removing obsolete snapshots&quot;,</span>
<span class="fc" id="L711">                        FBUtilities.prettyPrintMemory(dataFreeBytes));</span>

<span class="pc bpc" id="L713" title="1 of 2 branches missed.">        if (conf.local_system_data_file_directory != null)</span>
        {
<span class="nc bnc" id="L715" title="All 2 branches missed.">            if (conf.local_system_data_file_directory.equals(conf.commitlog_directory))</span>
<span class="nc" id="L716">                throw new ConfigurationException(&quot;local_system_data_file_directory must not be the same as the commitlog_directory&quot;, false);</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">            if (conf.local_system_data_file_directory.equals(conf.saved_caches_directory))</span>
<span class="nc" id="L718">                throw new ConfigurationException(&quot;local_system_data_file_directory must not be the same as the saved_caches_directory&quot;, false);</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">            if (conf.local_system_data_file_directory.equals(conf.hints_directory))</span>
<span class="nc" id="L720">                throw new ConfigurationException(&quot;local_system_data_file_directory must not be the same as the hints_directory&quot;, false);</span>

<span class="nc" id="L722">            long freeBytes = tryGetSpace(conf.local_system_data_file_directory, FileStore::getUnallocatedSpace);</span>

<span class="nc bnc" id="L724" title="All 2 branches missed.">            if (freeBytes &lt; ONE_GIB)</span>
<span class="nc" id="L725">                logger.warn(&quot;Only {} free in the system data volume. Consider adding more capacity or removing obsolete snapshots&quot;,</span>
<span class="nc" id="L726">                            FBUtilities.prettyPrintMemory(freeBytes));</span>
        }

<span class="pc bpc" id="L729" title="1 of 2 branches missed.">        if (conf.commitlog_directory.equals(conf.saved_caches_directory))</span>
<span class="nc" id="L730">            throw new ConfigurationException(&quot;saved_caches_directory must not be the same as the commitlog_directory&quot;, false);</span>
<span class="pc bpc" id="L731" title="1 of 2 branches missed.">        if (conf.commitlog_directory.equals(conf.hints_directory))</span>
<span class="nc" id="L732">            throw new ConfigurationException(&quot;hints_directory must not be the same as the commitlog_directory&quot;, false);</span>
<span class="pc bpc" id="L733" title="1 of 2 branches missed.">        if (conf.hints_directory.equals(conf.saved_caches_directory))</span>
<span class="nc" id="L734">            throw new ConfigurationException(&quot;saved_caches_directory must not be the same as the hints_directory&quot;, false);</span>

<span class="fc bfc" id="L736" title="All 2 branches covered.">        if (conf.memtable_flush_writers == 0)</span>
        {
<span class="fc bfc" id="L738" title="All 2 branches covered.">            conf.memtable_flush_writers = conf.data_file_directories.length == 1 ? 2 : 1;</span>
        }

<span class="pc bpc" id="L741" title="1 of 2 branches missed.">        if (conf.memtable_flush_writers &lt; 1)</span>
<span class="nc" id="L742">            throw new ConfigurationException(&quot;memtable_flush_writers must be at least 1, but was &quot; + conf.memtable_flush_writers, false);</span>

<span class="pc bpc" id="L744" title="1 of 2 branches missed.">        if (conf.memtable_cleanup_threshold == null)</span>
        {
<span class="fc" id="L746">            conf.memtable_cleanup_threshold = (float) (1.0 / (1 + conf.memtable_flush_writers));</span>
        }
        else
        {
<span class="nc" id="L750">            logger.warn(&quot;memtable_cleanup_threshold has been deprecated and should be removed from cassandra.yaml&quot;);</span>
        }

<span class="pc bpc" id="L753" title="1 of 2 branches missed.">        if (conf.memtable_cleanup_threshold &lt; 0.01f)</span>
<span class="nc" id="L754">            throw new ConfigurationException(&quot;memtable_cleanup_threshold must be &gt;= 0.01, but was &quot; + conf.memtable_cleanup_threshold, false);</span>
<span class="pc bpc" id="L755" title="1 of 2 branches missed.">        if (conf.memtable_cleanup_threshold &gt; 0.99f)</span>
<span class="nc" id="L756">            throw new ConfigurationException(&quot;memtable_cleanup_threshold must be &lt;= 0.99, but was &quot; + conf.memtable_cleanup_threshold, false);</span>
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">        if (conf.memtable_cleanup_threshold &lt; 0.1f)</span>
<span class="nc" id="L758">            logger.warn(&quot;memtable_cleanup_threshold is set very low [{}], which may cause performance degradation&quot;, conf.memtable_cleanup_threshold);</span>

<span class="fc bfc" id="L760" title="All 2 branches covered.">        if (conf.concurrent_compactors == null)</span>
<span class="fc" id="L761">            conf.concurrent_compactors = Math.min(8, Math.max(2, Math.min(FBUtilities.getAvailableProcessors(), conf.data_file_directories.length)));</span>

<span class="pc bpc" id="L763" title="1 of 2 branches missed.">        if (conf.concurrent_compactors &lt;= 0)</span>
<span class="nc" id="L764">            throw new ConfigurationException(&quot;concurrent_compactors should be strictly greater than 0, but was &quot; + conf.concurrent_compactors, false);</span>

<span class="fc" id="L766">        applyConcurrentValidations(conf);</span>
<span class="fc" id="L767">        applyRepairCommandPoolSize(conf);</span>
<span class="fc" id="L768">        applyReadThresholdsValidations(conf);</span>

<span class="pc bpc" id="L770" title="1 of 2 branches missed.">        if (conf.concurrent_materialized_view_builders &lt;= 0)</span>
<span class="nc" id="L771">            throw new ConfigurationException(&quot;concurrent_materialized_view_builders should be strictly greater than 0, but was &quot; + conf.concurrent_materialized_view_builders, false);</span>

<span class="pc bpc" id="L773" title="1 of 4 branches missed.">        if (conf.num_tokens != null &amp;&amp; conf.num_tokens &gt; MAX_NUM_TOKENS)</span>
<span class="nc" id="L774">            throw new ConfigurationException(String.format(&quot;A maximum number of %d tokens per node is supported&quot;, MAX_NUM_TOKENS), false);</span>

        try
        {
            // if prepared_statements_cache_size option was set to &quot;auto&quot; then size of the cache should be &quot;max(1/256 of Heap (in MiB), 10MiB)&quot;
<span class="fc bfc" id="L779" title="All 2 branches covered.">            preparedStatementsCacheSizeInMiB = (conf.prepared_statements_cache_size == null)</span>
<span class="fc" id="L780">                                              ? Math.max(10, (int) (Runtime.getRuntime().maxMemory() / 1024 / 1024 / 256))</span>
<span class="fc" id="L781">                                              : conf.prepared_statements_cache_size.toMebibytes();</span>

<span class="pc bpc" id="L783" title="1 of 2 branches missed.">            if (preparedStatementsCacheSizeInMiB == 0)</span>
<span class="nc" id="L784">                throw new NumberFormatException(); // to escape duplicating error message</span>

            // we need this assignment for the Settings virtual table - CASSANDRA-17734
<span class="fc" id="L787">            conf.prepared_statements_cache_size = new DataStorageSpec.LongMebibytesBound(preparedStatementsCacheSizeInMiB);</span>
        }
<span class="nc" id="L789">        catch (NumberFormatException e)</span>
        {
<span class="nc" id="L791">            throw new ConfigurationException(&quot;prepared_statements_cache_size option was set incorrectly to '&quot;</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">                                             + (conf.prepared_statements_cache_size != null ? conf.prepared_statements_cache_size.toString() : null) + &quot;', supported values are &lt;integer&gt; &gt;= 0.&quot;, false);</span>
<span class="fc" id="L793">        }</span>

        try
        {
            // if key_cache_size option was set to &quot;auto&quot; then size of the cache should be &quot;min(5% of Heap (in MiB), 100MiB)
<span class="fc bfc" id="L798" title="All 2 branches covered.">            keyCacheSizeInMiB = (conf.key_cache_size == null)</span>
<span class="fc" id="L799">                               ? Math.min(Math.max(1, (int) (Runtime.getRuntime().totalMemory() * 0.05 / 1024 / 1024)), 100)</span>
<span class="fc" id="L800">                               : conf.key_cache_size.toMebibytes();</span>

<span class="pc bpc" id="L802" title="1 of 2 branches missed.">            if (keyCacheSizeInMiB &lt; 0)</span>
<span class="nc" id="L803">                throw new NumberFormatException(); // to escape duplicating error message</span>

            // we need this assignment for the Settings Virtual Table - CASSANDRA-17734
<span class="fc" id="L806">            conf.key_cache_size = new DataStorageSpec.LongMebibytesBound(keyCacheSizeInMiB);</span>
        }
<span class="nc" id="L808">        catch (NumberFormatException e)</span>
        {
<span class="nc" id="L810">            throw new ConfigurationException(&quot;key_cache_size option was set incorrectly to '&quot;</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">                                             + (conf.key_cache_size != null ? conf.key_cache_size.toString() : null) + &quot;', supported values are &lt;integer&gt; &gt;= 0.&quot;, false);</span>
<span class="fc" id="L812">        }</span>

        try
        {
            // if counter_cache_size option was set to &quot;auto&quot; then size of the cache should be &quot;min(2.5% of Heap (in MiB), 50MiB)
<span class="fc bfc" id="L817" title="All 2 branches covered.">            counterCacheSizeInMiB = (conf.counter_cache_size == null)</span>
<span class="fc" id="L818">                                   ? Math.min(Math.max(1, (int) (Runtime.getRuntime().totalMemory() * 0.025 / 1024 / 1024)), 50)</span>
<span class="fc" id="L819">                                   : conf.counter_cache_size.toMebibytes();</span>

<span class="pc bpc" id="L821" title="1 of 2 branches missed.">            if (counterCacheSizeInMiB &lt; 0)</span>
<span class="nc" id="L822">                throw new NumberFormatException(); // to escape duplicating error message</span>
        }
<span class="nc" id="L824">        catch (NumberFormatException e)</span>
        {
<span class="nc" id="L826">            throw new ConfigurationException(&quot;counter_cache_size option was set incorrectly to '&quot;</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">                                             + (conf.counter_cache_size !=null ?conf.counter_cache_size.toString() : null) + &quot;', supported values are &lt;integer&gt; &gt;= 0.&quot;, false);</span>
<span class="fc" id="L828">        }</span>

        try
        {
            // if paxosCacheSizeInMiB option was set to &quot;auto&quot; then size of the cache should be &quot;min(1% of Heap (in MB), 50MB)
<span class="fc bfc" id="L833" title="All 2 branches covered.">            paxosCacheSizeInMiB = (conf.paxos_cache_size == null)</span>
<span class="fc" id="L834">                    ? Math.min(Math.max(1, (int) (Runtime.getRuntime().totalMemory() * 0.01 / 1024 / 1024)), 50)</span>
<span class="fc" id="L835">                    : conf.paxos_cache_size.toMebibytes();</span>

<span class="pc bpc" id="L837" title="1 of 2 branches missed.">            if (paxosCacheSizeInMiB &lt; 0)</span>
<span class="nc" id="L838">                throw new NumberFormatException(); // to escape duplicating error message</span>
        }
<span class="nc" id="L840">        catch (NumberFormatException e)</span>
        {
<span class="nc" id="L842">            throw new ConfigurationException(&quot;paxos_cache_size option was set incorrectly to '&quot;</span>
                    + conf.paxos_cache_size + &quot;', supported values are &lt;integer&gt; &gt;= 0.&quot;, false);
<span class="fc" id="L844">        }</span>

        // we need this assignment for the Settings virtual table - CASSANDRA-17735
<span class="fc" id="L847">        conf.counter_cache_size = new DataStorageSpec.LongMebibytesBound(counterCacheSizeInMiB);</span>

        // if set to empty/&quot;auto&quot; then use 5% of Heap size
<span class="fc bfc" id="L850" title="All 2 branches covered.">        indexSummaryCapacityInMiB = (conf.index_summary_capacity == null)</span>
<span class="fc" id="L851">                                   ? Math.max(1, (int) (Runtime.getRuntime().totalMemory() * 0.05 / 1024 / 1024))</span>
<span class="fc" id="L852">                                   : conf.index_summary_capacity.toMebibytes();</span>

<span class="pc bpc" id="L854" title="1 of 2 branches missed.">        if (indexSummaryCapacityInMiB &lt; 0)</span>
<span class="nc" id="L855">            throw new ConfigurationException(&quot;index_summary_capacity option was set incorrectly to '&quot;</span>
<span class="nc" id="L856">                                             + conf.index_summary_capacity.toString() + &quot;', it should be a non-negative integer.&quot;, false);</span>

        // we need this assignment for the Settings virtual table - CASSANDRA-17735
<span class="fc" id="L859">        conf.index_summary_capacity = new DataStorageSpec.LongMebibytesBound(indexSummaryCapacityInMiB);</span>

<span class="pc bpc" id="L861" title="1 of 2 branches missed.">        if (conf.user_defined_functions_fail_timeout.toMilliseconds() &lt; conf.user_defined_functions_warn_timeout.toMilliseconds())</span>
<span class="nc" id="L862">            throw new ConfigurationException(&quot;user_defined_functions_warn_timeout must less than user_defined_function_fail_timeout&quot;, false);</span>

<span class="pc bpc" id="L864" title="2 of 4 branches missed.">        if (!conf.allow_insecure_udfs &amp;&amp; !conf.user_defined_functions_threads_enabled)</span>
<span class="nc" id="L865">            throw new ConfigurationException(&quot;To be able to set enable_user_defined_functions_threads: false you need to set allow_insecure_udfs: true - this is an unsafe configuration and is not recommended.&quot;);</span>

<span class="pc bpc" id="L867" title="1 of 2 branches missed.">        if (conf.allow_extra_insecure_udfs)</span>
<span class="nc" id="L868">            logger.warn(&quot;Allowing java.lang.System.* access in UDFs is dangerous and not recommended. Set allow_extra_insecure_udfs: false to disable.&quot;);</span>

<span class="pc bpc" id="L870" title="1 of 2 branches missed.">        if(conf.scripted_user_defined_functions_enabled)</span>
<span class="nc" id="L871">            throw new ConfigurationException(&quot;JavaScript user-defined functions were removed in CASSANDRA-18252. &quot; +</span>
                                             &quot;Hooks are planned to be introduced as part of CASSANDRA-17280&quot;);

<span class="pc bpc" id="L874" title="1 of 2 branches missed.">        if (conf.commitlog_segment_size.toMebibytes() == 0)</span>
<span class="nc" id="L875">            throw new ConfigurationException(&quot;commitlog_segment_size must be positive, but was &quot;</span>
<span class="nc" id="L876">                                             + conf.commitlog_segment_size.toString(), false);</span>
<span class="pc bpc" id="L877" title="1 of 2 branches missed.">        else if (conf.commitlog_segment_size.toMebibytes() &gt;= 2048)</span>
<span class="nc" id="L878">            throw new ConfigurationException(&quot;commitlog_segment_size must be smaller than 2048, but was &quot;</span>
<span class="nc" id="L879">                                             + conf.commitlog_segment_size.toString(), false);</span>

<span class="fc bfc" id="L881" title="All 2 branches covered.">        if (conf.max_mutation_size == null)</span>
<span class="fc" id="L882">            conf.max_mutation_size = new DataStorageSpec.IntKibibytesBound(conf.commitlog_segment_size.toKibibytes() / 2);</span>
<span class="pc bpc" id="L883" title="1 of 2 branches missed.">        else if (conf.commitlog_segment_size.toKibibytes() &lt; 2 * conf.max_mutation_size.toKibibytes())</span>
<span class="nc" id="L884">            throw new ConfigurationException(&quot;commitlog_segment_size must be at least twice the size of max_mutation_size / 1024&quot;, false);</span>

        // native transport encryption options
<span class="pc bpc" id="L887" title="1 of 2 branches missed.">        if (conf.client_encryption_options != null)</span>
        {
<span class="fc" id="L889">            conf.client_encryption_options.applyConfig();</span>

<span class="fc bfc" id="L891" title="All 2 branches covered.">            if (conf.native_transport_port_ssl != null</span>
<span class="pc bpc" id="L892" title="1 of 2 branches missed.">                &amp;&amp; conf.native_transport_port_ssl != conf.native_transport_port</span>
<span class="fc bfc" id="L893" title="All 2 branches covered.">                &amp;&amp; conf.client_encryption_options.tlsEncryptionPolicy() == EncryptionOptions.TlsEncryptionPolicy.UNENCRYPTED)</span>
            {
<span class="fc" id="L895">                throw new ConfigurationException(&quot;Encryption must be enabled in client_encryption_options for native_transport_port_ssl&quot;, false);</span>
            }
        }

<span class="pc bpc" id="L899" title="1 of 2 branches missed.">        if (conf.snapshot_links_per_second &lt; 0)</span>
<span class="nc" id="L900">            throw new ConfigurationException(&quot;snapshot_links_per_second must be &gt;= 0&quot;);</span>

<span class="pc bpc" id="L902" title="1 of 2 branches missed.">        if (conf.max_value_size.toMebibytes() == 0)</span>
<span class="nc" id="L903">            throw new ConfigurationException(&quot;max_value_size must be positive&quot;, false);</span>
<span class="pc bpc" id="L904" title="1 of 2 branches missed.">        else if (conf.max_value_size.toMebibytes() &gt;= 2048)</span>
<span class="nc" id="L905">            throw new ConfigurationException(&quot;max_value_size must be smaller than 2048, but was &quot;</span>
<span class="nc" id="L906">                    + conf.max_value_size.toString(), false);</span>

<span class="pc bpc" id="L908" title="2 of 3 branches missed.">        switch (conf.disk_optimization_strategy)</span>
        {
            case ssd:
<span class="fc" id="L911">                diskOptimizationStrategy = new SsdDiskOptimizationStrategy(conf.disk_optimization_page_cross_chance);</span>
<span class="fc" id="L912">                break;</span>
            case spinning:
<span class="nc" id="L914">                diskOptimizationStrategy = new SpinningDiskOptimizationStrategy();</span>
                break;
        }

<span class="pc bpc" id="L918" title="1 of 2 branches missed.">        if (conf.server_encryption_options != null)</span>
        {
<span class="fc" id="L920">            conf.server_encryption_options.applyConfig();</span>

<span class="fc bfc" id="L922" title="All 2 branches covered.">            if (conf.server_encryption_options.legacy_ssl_storage_port_enabled &amp;&amp;</span>
<span class="fc bfc" id="L923" title="All 2 branches covered.">                conf.server_encryption_options.tlsEncryptionPolicy() == EncryptionOptions.TlsEncryptionPolicy.UNENCRYPTED)</span>
            {
<span class="fc" id="L925">                throw new ConfigurationException(&quot;legacy_ssl_storage_port_enabled is true (enabled) with internode encryption disabled (none). Enable encryption or disable the legacy ssl storage port.&quot;);</span>
            }
        }

<span class="fc bfc" id="L929" title="All 2 branches covered.">        if (conf.internode_max_message_size != null)</span>
        {
<span class="fc" id="L931">            long maxMessageSize = conf.internode_max_message_size.toBytes();</span>

<span class="pc bpc" id="L933" title="1 of 2 branches missed.">            if (maxMessageSize &gt; conf.internode_application_receive_queue_reserve_endpoint_capacity.toBytes())</span>
<span class="nc" id="L934">                throw new ConfigurationException(&quot;internode_max_message_size must no exceed internode_application_receive_queue_reserve_endpoint_capacity&quot;, false);</span>

<span class="pc bpc" id="L936" title="1 of 2 branches missed.">            if (maxMessageSize &gt; conf.internode_application_receive_queue_reserve_global_capacity.toBytes())</span>
<span class="nc" id="L937">                throw new ConfigurationException(&quot;internode_max_message_size must no exceed internode_application_receive_queue_reserve_global_capacity&quot;, false);</span>

<span class="pc bpc" id="L939" title="1 of 2 branches missed.">            if (maxMessageSize &gt; conf.internode_application_send_queue_reserve_endpoint_capacity.toBytes())</span>
<span class="nc" id="L940">                throw new ConfigurationException(&quot;internode_max_message_size must no exceed internode_application_send_queue_reserve_endpoint_capacity&quot;, false);</span>

<span class="pc bpc" id="L942" title="1 of 2 branches missed.">            if (maxMessageSize &gt; conf.internode_application_send_queue_reserve_global_capacity.toBytes())</span>
<span class="nc" id="L943">                throw new ConfigurationException(&quot;internode_max_message_size must no exceed internode_application_send_queue_reserve_global_capacity&quot;, false);</span>
<span class="fc" id="L944">        }</span>
        else
        {
<span class="fc" id="L947">            long maxMessageSizeInBytes =</span>
<span class="fc" id="L948">            Math.min(conf.internode_application_receive_queue_reserve_endpoint_capacity.toBytes(),</span>
<span class="fc" id="L949">                     conf.internode_application_send_queue_reserve_endpoint_capacity.toBytes());</span>

<span class="fc" id="L951">            conf.internode_max_message_size = new DataStorageSpec.IntBytesBound(maxMessageSizeInBytes);</span>
        }

<span class="fc" id="L954">        validateMaxConcurrentAutoUpgradeTasksConf(conf.max_concurrent_automatic_sstable_upgrades);</span>

<span class="pc bpc" id="L956" title="1 of 2 branches missed.">        if (conf.default_keyspace_rf &lt; conf.minimum_replication_factor_fail_threshold)</span>
        {
<span class="nc" id="L958">            throw new ConfigurationException(String.format(&quot;default_keyspace_rf (%d) cannot be less than minimum_replication_factor_fail_threshold (%d)&quot;,</span>
<span class="nc" id="L959">                                                           conf.default_keyspace_rf, conf.minimum_replication_factor_fail_threshold));</span>
        }

<span class="pc bpc" id="L962" title="1 of 2 branches missed.">        if (conf.paxos_repair_parallelism &lt;= 0)</span>
<span class="fc" id="L963">            conf.paxos_repair_parallelism = Math.max(1, conf.concurrent_writes / 8);</span>

<span class="fc" id="L965">        Paxos.setPaxosVariant(conf.paxos_variant);</span>
<span class="fc bfc" id="L966" title="All 2 branches covered.">        if (conf.paxos_state_purging == null)</span>
<span class="fc" id="L967">            conf.paxos_state_purging = PaxosStatePurging.legacy;</span>

<span class="fc" id="L969">        logInitializationOutcome(logger);</span>

<span class="pc bpc" id="L971" title="2 of 4 branches missed.">        if (conf.max_space_usable_for_compactions_in_percentage &lt; 0 || conf.max_space_usable_for_compactions_in_percentage &gt; 1)</span>
<span class="nc" id="L972">            throw new ConfigurationException(&quot;max_space_usable_for_compactions_in_percentage must be between 0 and 1&quot;, false);</span>

<span class="pc bpc" id="L974" title="3 of 4 branches missed.">        if (conf.dump_heap_on_uncaught_exception &amp;&amp; DatabaseDescriptor.getHeapDumpPath() == null)</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">            throw new ConfigurationException(String.format(&quot;Invalid configuration. Heap dump is enabled but cannot create heap dump output path: %s.&quot;, conf.heap_dump_path != null ? conf.heap_dump_path : &quot;null&quot;));</span>

<span class="fc" id="L977">        conf.sai_options.validate();</span>
<span class="fc" id="L978">    }</span>

    @VisibleForTesting
    static void validateUpperBoundStreamingConfig() throws ConfigurationException
    {
        // below 2 checks are needed in order to match the pre-CASSANDRA-15234 upper bound for those parameters which were still in megabits per second
<span class="pc bpc" id="L984" title="1 of 2 branches missed.">        if (conf.stream_throughput_outbound.toMegabitsPerSecond() &gt;= Integer.MAX_VALUE)</span>
        {
<span class="nc" id="L986">            throw new ConfigurationException(&quot;Invalid value of stream_throughput_outbound: &quot; + conf.stream_throughput_outbound.toString(), false);</span>
        }

<span class="pc bpc" id="L989" title="1 of 2 branches missed.">        if (conf.inter_dc_stream_throughput_outbound.toMegabitsPerSecond() &gt;= Integer.MAX_VALUE)</span>
        {
<span class="nc" id="L991">            throw new ConfigurationException(&quot;Invalid value of inter_dc_stream_throughput_outbound: &quot; + conf.inter_dc_stream_throughput_outbound.toString(), false);</span>
        }

<span class="pc bpc" id="L994" title="1 of 2 branches missed.">        if (conf.entire_sstable_stream_throughput_outbound.toMebibytesPerSecond() &gt;= Integer.MAX_VALUE)</span>
        {
<span class="nc" id="L996">            throw new ConfigurationException(&quot;Invalid value of entire_sstable_stream_throughput_outbound: &quot; + conf.entire_sstable_stream_throughput_outbound.toString(), false);</span>
        }

<span class="pc bpc" id="L999" title="1 of 2 branches missed.">        if (conf.entire_sstable_inter_dc_stream_throughput_outbound.toMebibytesPerSecond() &gt;= Integer.MAX_VALUE)</span>
        {
<span class="nc" id="L1001">            throw new ConfigurationException(&quot;Invalid value of entire_sstable_inter_dc_stream_throughput_outbound: &quot; + conf.entire_sstable_inter_dc_stream_throughput_outbound.toString(), false);</span>
        }

<span class="pc bpc" id="L1004" title="1 of 2 branches missed.">        if (conf.compaction_throughput.toMebibytesPerSecond() &gt;= Integer.MAX_VALUE)</span>
        {
<span class="nc" id="L1006">            throw new ConfigurationException(&quot;Invalid value of compaction_throughput: &quot; + conf.compaction_throughput.toString(), false);</span>
        }
<span class="fc" id="L1008">    }</span>

    @VisibleForTesting
    static void applyConcurrentValidations(Config config)
    {
<span class="fc bfc" id="L1013" title="All 2 branches covered.">        if (config.concurrent_validations &lt; 1)</span>
        {
<span class="fc" id="L1015">            config.concurrent_validations = config.concurrent_compactors;</span>
        }
<span class="pc bpc" id="L1017" title="1 of 4 branches missed.">        else if (config.concurrent_validations &gt; config.concurrent_compactors &amp;&amp; !allowUnlimitedConcurrentValidations)</span>
        {
<span class="fc" id="L1019">            throw new ConfigurationException(&quot;To set concurrent_validations &gt; concurrent_compactors, &quot; +</span>
<span class="fc" id="L1020">                                             &quot;set the system property -D&quot; + ALLOW_UNLIMITED_CONCURRENT_VALIDATIONS.getKey() + &quot;=true&quot;);</span>
        }
<span class="fc" id="L1022">    }</span>

    @VisibleForTesting
    static void applyRepairCommandPoolSize(Config config)
    {
<span class="fc bfc" id="L1027" title="All 2 branches covered.">        if (config.repair_command_pool_size &lt; 1)</span>
<span class="fc" id="L1028">            config.repair_command_pool_size = config.concurrent_validations;</span>
<span class="fc" id="L1029">    }</span>

    @VisibleForTesting
    static void applyReadThresholdsValidations(Config config)
    {
<span class="fc" id="L1034">        validateReadThresholds(&quot;coordinator_read_size&quot;, config.coordinator_read_size_warn_threshold, config.coordinator_read_size_fail_threshold);</span>
<span class="fc" id="L1035">        validateReadThresholds(&quot;local_read_size&quot;, config.local_read_size_warn_threshold, config.local_read_size_fail_threshold);</span>
<span class="fc" id="L1036">        validateReadThresholds(&quot;row_index_read_size&quot;, config.row_index_read_size_warn_threshold, config.row_index_read_size_fail_threshold);</span>
<span class="fc" id="L1037">    }</span>

    private static void validateReadThresholds(String name, DataStorageSpec.LongBytesBound warn, DataStorageSpec.LongBytesBound fail)
    {
<span class="pc bpc" id="L1041" title="1 of 6 branches missed.">        if (fail != null &amp;&amp; warn != null &amp;&amp; fail.toBytes() &lt; warn.toBytes())</span>
<span class="fc" id="L1042">            throw new ConfigurationException(String.format(&quot;%s (%s) must be greater than or equal to %s (%s)&quot;,</span>
                                                           name + &quot;_fail_threshold&quot;, fail,
                                                           name + &quot;_warn_threshold&quot;, warn));
<span class="fc" id="L1045">    }</span>

    public static GuardrailsOptions getGuardrailsConfig()
    {
<span class="fc" id="L1049">        return guardrails;</span>
    }

    private static void applyGuardrails()
    {
        try
        {
<span class="fc" id="L1056">            guardrails = new GuardrailsOptions(conf);</span>
        }
<span class="nc" id="L1058">        catch (IllegalArgumentException e)</span>
        {
<span class="nc" id="L1060">            throw new ConfigurationException(&quot;Invalid guardrails configuration: &quot; + e.getMessage(), e);</span>
<span class="fc" id="L1061">        }</span>
<span class="fc" id="L1062">    }</span>

    public static StartupChecksOptions getStartupChecksOptions()
    {
<span class="fc" id="L1066">        return startupChecksOptions;</span>
    }

    private static void applyStartupChecks()
    {
<span class="fc" id="L1071">        startupChecksOptions = new StartupChecksOptions(conf.startup_checks);</span>
<span class="fc" id="L1072">    }</span>

    private static String storagedirFor(String type)
    {
<span class="nc" id="L1076">        return storagedir(type + &quot;_directory&quot;) + File.pathSeparator() + type;</span>
    }

    private static String storagedir(String errMsgType)
    {
<span class="nc" id="L1081">        String storagedir = STORAGE_DIR.getString();</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">        if (storagedir == null)</span>
<span class="nc" id="L1083">            throw new ConfigurationException(errMsgType + &quot; is missing and &quot; + STORAGE_DIR.getKey() + &quot; system property is not set&quot;, false);</span>
<span class="nc" id="L1084">        return storagedir;</span>
    }

    static int calculateDefaultSpaceInMiB(String type, String path, String setting, int preferredSizeInMiB, long totalSpaceInBytes, long totalSpaceNumerator, long totalSpaceDenominator)
    {
<span class="fc" id="L1089">        final long totalSizeInMiB = totalSpaceInBytes / ONE_MIB;</span>
<span class="fc" id="L1090">        final int minSizeInMiB = Ints.saturatedCast(totalSpaceNumerator * totalSizeInMiB / totalSpaceDenominator);</span>

<span class="fc bfc" id="L1092" title="All 2 branches covered.">        if (minSizeInMiB &lt; preferredSizeInMiB)</span>
        {
<span class="fc" id="L1094">            logger.warn(&quot;Small {} volume detected at '{}'; setting {} to {}.  You can override this in cassandra.yaml&quot;,</span>
<span class="fc" id="L1095">                        type, path, setting, minSizeInMiB);</span>
<span class="fc" id="L1096">            return minSizeInMiB;</span>
        }
        else
        {
<span class="fc" id="L1100">            return preferredSizeInMiB;</span>
        }
    }

    public static void applyAddressConfig() throws ConfigurationException
    {
<span class="fc" id="L1106">        applyAddressConfig(conf);</span>
<span class="fc" id="L1107">    }</span>

    public static void applyAddressConfig(Config config) throws ConfigurationException
    {
<span class="fc" id="L1111">        listenAddress = null;</span>
<span class="fc" id="L1112">        rpcAddress = null;</span>
<span class="fc" id="L1113">        broadcastAddress = null;</span>
<span class="fc" id="L1114">        broadcastRpcAddress = null;</span>

        /* Local IP, hostname or interface to bind services to */
<span class="pc bpc" id="L1117" title="1 of 4 branches missed.">        if (config.listen_address != null &amp;&amp; config.listen_interface != null)</span>
        {
<span class="nc" id="L1119">            throw new ConfigurationException(&quot;Set listen_address OR listen_interface, not both&quot;, false);</span>
        }
<span class="fc bfc" id="L1121" title="All 2 branches covered.">        else if (config.listen_address != null)</span>
        {
            try
            {
<span class="fc" id="L1125">                listenAddress = InetAddress.getByName(config.listen_address);</span>
            }
<span class="nc" id="L1127">            catch (UnknownHostException e)</span>
            {
<span class="nc" id="L1129">                throw new ConfigurationException(&quot;Unknown listen_address '&quot; + config.listen_address + '\'', false);</span>
<span class="fc" id="L1130">            }</span>

<span class="pc bpc" id="L1132" title="1 of 2 branches missed.">            if (listenAddress.isAnyLocalAddress())</span>
<span class="nc" id="L1133">                throw new ConfigurationException(&quot;listen_address cannot be a wildcard address (&quot; + config.listen_address + &quot;)!&quot;, false);</span>
        }
<span class="pc bpc" id="L1135" title="1 of 2 branches missed.">        else if (config.listen_interface != null)</span>
        {
<span class="fc" id="L1137">            listenAddress = getNetworkInterfaceAddress(config.listen_interface, &quot;listen_interface&quot;, config.listen_interface_prefer_ipv6);</span>
        }

        /* Gossip Address to broadcast */
<span class="fc bfc" id="L1141" title="All 2 branches covered.">        if (config.broadcast_address != null)</span>
        {
            try
            {
<span class="fc" id="L1145">                broadcastAddress = InetAddress.getByName(config.broadcast_address);</span>
            }
<span class="nc" id="L1147">            catch (UnknownHostException e)</span>
            {
<span class="nc" id="L1149">                throw new ConfigurationException(&quot;Unknown broadcast_address '&quot; + config.broadcast_address + '\'', false);</span>
<span class="fc" id="L1150">            }</span>

<span class="pc bpc" id="L1152" title="1 of 2 branches missed.">            if (broadcastAddress.isAnyLocalAddress())</span>
<span class="nc" id="L1153">                throw new ConfigurationException(&quot;broadcast_address cannot be a wildcard address (&quot; + config.broadcast_address + &quot;)!&quot;, false);</span>
        }

        /* Local IP, hostname or interface to bind RPC server to */
<span class="pc bpc" id="L1157" title="1 of 4 branches missed.">        if (config.rpc_address != null &amp;&amp; config.rpc_interface != null)</span>
        {
<span class="nc" id="L1159">            throw new ConfigurationException(&quot;Set rpc_address OR rpc_interface, not both&quot;, false);</span>
        }
<span class="fc bfc" id="L1161" title="All 2 branches covered.">        else if (config.rpc_address != null)</span>
        {
            try
            {
<span class="fc" id="L1165">                rpcAddress = InetAddress.getByName(config.rpc_address);</span>
            }
<span class="nc" id="L1167">            catch (UnknownHostException e)</span>
            {
<span class="nc" id="L1169">                throw new ConfigurationException(&quot;Unknown host in rpc_address &quot; + config.rpc_address, false);</span>
<span class="fc" id="L1170">            }</span>
        }
<span class="fc bfc" id="L1172" title="All 2 branches covered.">        else if (config.rpc_interface != null)</span>
        {
<span class="fc" id="L1174">            rpcAddress = getNetworkInterfaceAddress(config.rpc_interface, &quot;rpc_interface&quot;, config.rpc_interface_prefer_ipv6);</span>
        }
        else
        {
<span class="fc" id="L1178">            rpcAddress = FBUtilities.getJustLocalAddress();</span>
        }

        /* RPC address to broadcast */
<span class="fc bfc" id="L1182" title="All 2 branches covered.">        if (config.broadcast_rpc_address != null)</span>
        {
            try
            {
<span class="fc" id="L1186">                broadcastRpcAddress = InetAddress.getByName(config.broadcast_rpc_address);</span>
            }
<span class="nc" id="L1188">            catch (UnknownHostException e)</span>
            {
<span class="nc" id="L1190">                throw new ConfigurationException(&quot;Unknown broadcast_rpc_address '&quot; + config.broadcast_rpc_address + '\'', false);</span>
<span class="fc" id="L1191">            }</span>

<span class="pc bpc" id="L1193" title="1 of 2 branches missed.">            if (broadcastRpcAddress.isAnyLocalAddress())</span>
<span class="nc" id="L1194">                throw new ConfigurationException(&quot;broadcast_rpc_address cannot be a wildcard address (&quot; + config.broadcast_rpc_address + &quot;)!&quot;, false);</span>
        }
        else
        {
<span class="pc bpc" id="L1198" title="1 of 2 branches missed.">            if (rpcAddress.isAnyLocalAddress())</span>
<span class="nc" id="L1199">                throw new ConfigurationException(&quot;If rpc_address is set to a wildcard address (&quot; + config.rpc_address + &quot;), then &quot; +</span>
                                                 &quot;you must set broadcast_rpc_address to a value other than &quot; + config.rpc_address, false);
        }
<span class="fc" id="L1202">    }</span>

    public static void applyEncryptionContext()
    {
        // always attempt to load the cipher factory, as we could be in the situation where the user has disabled encryption,
        // but has existing commitlogs and sstables on disk that are still encrypted (and still need to be read)
<span class="fc" id="L1208">        encryptionContext = new EncryptionContext(conf.transparent_data_encryption_options);</span>
<span class="fc" id="L1209">    }</span>

    public static void applySslContext()
    {
<span class="pc bpc" id="L1213" title="1 of 2 branches missed.">        if (TEST_JVM_DTEST_DISABLE_SSL.getBoolean())</span>
<span class="nc" id="L1214">            return;</span>

        try
        {
<span class="fc" id="L1218">            SSLFactory.validateSslContext(&quot;Internode messaging&quot;, conf.server_encryption_options, true, true);</span>
<span class="fc" id="L1219">            SSLFactory.validateSslContext(&quot;Native transport&quot;, conf.client_encryption_options, conf.client_encryption_options.require_client_auth, true);</span>
<span class="fc" id="L1220">            SSLFactory.initHotReloading(conf.server_encryption_options, conf.client_encryption_options, false);</span>
        }
<span class="fc" id="L1222">        catch (IOException e)</span>
        {
<span class="fc" id="L1224">            throw new ConfigurationException(&quot;Failed to initialize SSL&quot;, e);</span>
<span class="fc" id="L1225">        }</span>
<span class="fc" id="L1226">    }</span>

    public static void applyCryptoProvider()
    {
<span class="fc bfc" id="L1230" title="All 2 branches covered.">        if (TEST_SKIP_CRYPTO_PROVIDER_INSTALLATION.getBoolean())</span>
<span class="fc" id="L1231">            return;</span>

<span class="fc bfc" id="L1233" title="All 2 branches covered.">        if (conf.crypto_provider == null)</span>
<span class="fc" id="L1234">            conf.crypto_provider = new ParameterizedClass(JREProvider.class.getName(), null);</span>

        // properties beat configuration
<span class="fc" id="L1237">        String classNameFromSystemProperties = CassandraRelevantProperties.CRYPTO_PROVIDER_CLASS_NAME.getString();</span>
<span class="fc bfc" id="L1238" title="All 2 branches covered.">        if (classNameFromSystemProperties != null)</span>
<span class="fc" id="L1239">            conf.crypto_provider.class_name = classNameFromSystemProperties;</span>

<span class="pc bpc" id="L1241" title="1 of 2 branches missed.">        if (conf.crypto_provider.class_name == null)</span>
<span class="nc" id="L1242">            throw new ConfigurationException(&quot;Failed to initialize crypto provider, class_name cannot be null&quot;);</span>

<span class="fc bfc" id="L1244" title="All 2 branches covered.">        if (conf.crypto_provider.parameters == null)</span>
<span class="fc" id="L1245">            conf.crypto_provider.parameters = new HashMap&lt;&gt;();</span>

<span class="fc" id="L1247">        Map&lt;String, String&gt; cryptoProviderParameters = new HashMap&lt;&gt;(conf.crypto_provider.parameters);</span>
<span class="fc" id="L1248">        cryptoProviderParameters.putIfAbsent(AbstractCryptoProvider.FAIL_ON_MISSING_PROVIDER_KEY, &quot;false&quot;);</span>

        try
        {
<span class="fc" id="L1252">            cryptoProvider = FBUtilities.newCryptoProvider(conf.crypto_provider.class_name, cryptoProviderParameters);</span>
<span class="fc" id="L1253">            cryptoProvider.install();</span>
        }
<span class="fc" id="L1255">        catch (Exception e)</span>
        {
<span class="pc bpc" id="L1257" title="1 of 2 branches missed.">            if (e instanceof ConfigurationException)</span>
<span class="fc" id="L1258">                throw (ConfigurationException) e;</span>
            else
<span class="nc" id="L1260">                throw new ConfigurationException(String.format(&quot;Failed to initialize crypto provider %s&quot;, conf.crypto_provider.class_name), e);</span>
<span class="fc" id="L1261">        }</span>
<span class="fc" id="L1262">    }</span>

    public static void applySeedProvider()
    {
        // load the seeds for node contact points
<span class="pc bpc" id="L1267" title="1 of 2 branches missed.">        if (conf.seed_provider == null)</span>
        {
<span class="nc" id="L1269">            throw new ConfigurationException(&quot;seeds configuration is missing; a minimum of one seed is required.&quot;, false);</span>
        }
        try
        {
<span class="fc" id="L1273">            Class&lt;?&gt; seedProviderClass = Class.forName(conf.seed_provider.class_name);</span>
<span class="fc" id="L1274">            seedProvider = (SeedProvider)seedProviderClass.getConstructor(Map.class).newInstance(conf.seed_provider.parameters);</span>
        }
        // there are about 5 checked exceptions that could be thrown here.
<span class="nc" id="L1277">        catch (Exception e)</span>
        {
<span class="nc" id="L1279">            throw new ConfigurationException(e.getMessage() + &quot;\nFatal configuration error; unable to start server.  See log for stacktrace.&quot;, true);</span>
<span class="fc" id="L1280">        }</span>
<span class="pc bpc" id="L1281" title="1 of 2 branches missed.">        if (seedProvider.getSeeds().size() == 0)</span>
<span class="nc" id="L1282">            throw new ConfigurationException(&quot;The seed provider lists no seeds.&quot;, false);</span>
<span class="fc" id="L1283">    }</span>

    @VisibleForTesting
    static void checkForLowestAcceptedTimeouts(Config conf)
    {
<span class="fc bfc" id="L1288" title="All 2 branches covered.">        if(conf.read_request_timeout.toMilliseconds() &lt; LOWEST_ACCEPTED_TIMEOUT.toMilliseconds())</span>
        {
<span class="fc" id="L1290">            logInfo(&quot;read_request_timeout&quot;, conf.read_request_timeout, LOWEST_ACCEPTED_TIMEOUT);</span>
<span class="fc" id="L1291">            conf.read_request_timeout = new DurationSpec.LongMillisecondsBound(&quot;10ms&quot;);</span>
        }

<span class="fc bfc" id="L1294" title="All 2 branches covered.">        if(conf.range_request_timeout.toMilliseconds() &lt; LOWEST_ACCEPTED_TIMEOUT.toMilliseconds())</span>
        {
<span class="fc" id="L1296">            logInfo(&quot;range_request_timeout&quot;, conf.range_request_timeout, LOWEST_ACCEPTED_TIMEOUT);</span>
<span class="fc" id="L1297">            conf.range_request_timeout = new DurationSpec.LongMillisecondsBound(&quot;10ms&quot;);</span>
        }

<span class="fc bfc" id="L1300" title="All 2 branches covered.">        if(conf.request_timeout.toMilliseconds() &lt; LOWEST_ACCEPTED_TIMEOUT.toMilliseconds())</span>
        {
<span class="fc" id="L1302">            logInfo(&quot;request_timeout&quot;, conf.request_timeout, LOWEST_ACCEPTED_TIMEOUT);</span>
<span class="fc" id="L1303">            conf.request_timeout = new DurationSpec.LongMillisecondsBound(&quot;10ms&quot;);</span>
        }

<span class="fc bfc" id="L1306" title="All 2 branches covered.">        if(conf.write_request_timeout.toMilliseconds() &lt; LOWEST_ACCEPTED_TIMEOUT.toMilliseconds())</span>
        {
<span class="fc" id="L1308">            logInfo(&quot;write_request_timeout&quot;, conf.write_request_timeout, LOWEST_ACCEPTED_TIMEOUT);</span>
<span class="fc" id="L1309">            conf.write_request_timeout = new DurationSpec.LongMillisecondsBound(&quot;10ms&quot;);</span>
        }

<span class="fc bfc" id="L1312" title="All 2 branches covered.">        if(conf.cas_contention_timeout.toMilliseconds() &lt; LOWEST_ACCEPTED_TIMEOUT.toMilliseconds())</span>
        {
<span class="fc" id="L1314">            logInfo(&quot;cas_contention_timeout&quot;, conf.cas_contention_timeout, LOWEST_ACCEPTED_TIMEOUT);</span>
<span class="fc" id="L1315">            conf.cas_contention_timeout = new DurationSpec.LongMillisecondsBound(&quot;10ms&quot;);</span>
        }

<span class="fc bfc" id="L1318" title="All 2 branches covered.">        if(conf.counter_write_request_timeout.toMilliseconds()&lt; LOWEST_ACCEPTED_TIMEOUT.toMilliseconds())</span>
        {
<span class="fc" id="L1320">            logInfo(&quot;counter_write_request_timeout&quot;, conf.counter_write_request_timeout, LOWEST_ACCEPTED_TIMEOUT);</span>
<span class="fc" id="L1321">            conf.counter_write_request_timeout = new DurationSpec.LongMillisecondsBound(&quot;10ms&quot;);</span>
        }
<span class="fc bfc" id="L1323" title="All 2 branches covered.">        if(conf.truncate_request_timeout.toMilliseconds() &lt; LOWEST_ACCEPTED_TIMEOUT.toMilliseconds())</span>
        {
<span class="fc" id="L1325">            logInfo(&quot;truncate_request_timeout&quot;, conf.truncate_request_timeout, LOWEST_ACCEPTED_TIMEOUT);</span>
<span class="fc" id="L1326">            conf.truncate_request_timeout = LOWEST_ACCEPTED_TIMEOUT;</span>
        }
<span class="fc" id="L1328">    }</span>

    private static void logInfo(String property, DurationSpec.LongMillisecondsBound actualValue, DurationSpec.LongMillisecondsBound lowestAcceptedValue)
    {
<span class="fc" id="L1332">        logger.info(&quot;found {}::{} less than lowest acceptable value {}, continuing with {}&quot;,</span>
                    property,
<span class="fc" id="L1334">                    actualValue.toString(),</span>
<span class="fc" id="L1335">                    lowestAcceptedValue.toString(),</span>
                    lowestAcceptedValue);
<span class="fc" id="L1337">    }</span>

    public static void applyTokensConfig()
    {
<span class="fc" id="L1341">        applyTokensConfig(conf);</span>
<span class="fc" id="L1342">    }</span>

    static void applyTokensConfig(Config conf)
    {
<span class="fc bfc" id="L1346" title="All 2 branches covered.">        if (conf.initial_token != null)</span>
        {
<span class="fc" id="L1348">            Collection&lt;String&gt; tokens = tokensFromString(conf.initial_token);</span>
<span class="fc bfc" id="L1349" title="All 2 branches covered.">            if (conf.num_tokens == null)</span>
            {
<span class="fc bfc" id="L1351" title="All 2 branches covered.">                if (tokens.size() == 1)</span>
<span class="fc" id="L1352">                    conf.num_tokens = 1;</span>
                else
<span class="fc" id="L1354">                    throw new ConfigurationException(&quot;initial_token was set but num_tokens is not!&quot;, false);</span>
            }

<span class="fc bfc" id="L1357" title="All 2 branches covered.">            if (tokens.size() != conf.num_tokens)</span>
            {
<span class="fc" id="L1359">                throw new ConfigurationException(String.format(&quot;The number of initial tokens (by initial_token) specified (%s) is different from num_tokens value (%s)&quot;,</span>
<span class="fc" id="L1360">                                                               tokens.size(),</span>
                                                               conf.num_tokens),
                                                 false);
            }

<span class="fc bfc" id="L1365" title="All 2 branches covered.">            for (String token : tokens)</span>
<span class="fc" id="L1366">                partitioner.getTokenFactory().validate(token);</span>
<span class="fc" id="L1367">        }</span>
<span class="fc bfc" id="L1368" title="All 2 branches covered.">        else if (conf.num_tokens == null)</span>
        {
<span class="fc" id="L1370">            conf.num_tokens = 1;</span>
        }
<span class="fc" id="L1372">    }</span>

    // definitely not safe for tools + clients - implicitly instantiates StorageService
    public static void applySnitch()
    {
        /* end point snitch */
<span class="pc bpc" id="L1378" title="1 of 2 branches missed.">        if (conf.endpoint_snitch == null)</span>
        {
<span class="nc" id="L1380">            throw new ConfigurationException(&quot;Missing endpoint_snitch directive&quot;, false);</span>
        }
<span class="fc" id="L1382">        snitch = createEndpointSnitch(conf.dynamic_snitch, conf.endpoint_snitch);</span>
<span class="fc" id="L1383">        EndpointSnitchInfo.create();</span>

<span class="fc" id="L1385">        localDC = snitch.getLocalDatacenter();</span>
<span class="fc" id="L1386">        localComparator = (replica1, replica2) -&gt; {</span>
<span class="nc" id="L1387">            boolean local1 = localDC.equals(snitch.getDatacenter(replica1));</span>
<span class="nc" id="L1388">            boolean local2 = localDC.equals(snitch.getDatacenter(replica2));</span>
<span class="nc bnc" id="L1389" title="All 4 branches missed.">            if (local1 &amp;&amp; !local2)</span>
<span class="nc" id="L1390">                return -1;</span>
<span class="nc bnc" id="L1391" title="All 4 branches missed.">            if (local2 &amp;&amp; !local1)</span>
<span class="nc" id="L1392">                return 1;</span>
<span class="nc" id="L1393">            return 0;</span>
        };
<span class="fc" id="L1395">        newFailureDetector = () -&gt; createFailureDetector(conf.failure_detector);</span>
<span class="fc" id="L1396">    }</span>

    // definitely not safe for tools + clients - implicitly instantiates schema
    public static void applyPartitioner()
    {
<span class="fc" id="L1401">        applyPartitioner(conf);</span>
<span class="fc" id="L1402">    }</span>

    public static void applyPartitioner(Config conf)
    {
        /* Hashing strategy */
<span class="pc bpc" id="L1407" title="1 of 2 branches missed.">        if (conf.partitioner == null)</span>
        {
<span class="nc" id="L1409">            throw new ConfigurationException(&quot;Missing directive: partitioner&quot;, false);</span>
        }
<span class="fc" id="L1411">        String name = conf.partitioner;</span>
        try
        {
<span class="fc" id="L1414">            name = PARTITIONER.getString(conf.partitioner);</span>
<span class="fc" id="L1415">            partitioner = FBUtilities.newPartitioner(name);</span>
        }
<span class="fc" id="L1417">        catch (Exception e)</span>
        {
<span class="fc" id="L1419">            throw new ConfigurationException(&quot;Invalid partitioner class &quot; + name, e);</span>
<span class="fc" id="L1420">        }</span>

<span class="fc" id="L1422">        paritionerName = partitioner.getClass().getCanonicalName();</span>
<span class="fc" id="L1423">    }</span>

    private static void validateSSTableFormatFactories(Iterable&lt;SSTableFormat.Factory&gt; factories)
    {
<span class="fc" id="L1427">        Map&lt;String, SSTableFormat.Factory&gt; factoryByName = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L1428" title="All 2 branches covered.">        for (SSTableFormat.Factory factory : factories)</span>
        {
<span class="fc bfc" id="L1430" title="All 2 branches covered.">            if (factory.name() == null)</span>
<span class="fc" id="L1431">                throw new ConfigurationException(String.format(&quot;SSTable format name in %s cannot be null&quot;, factory.getClass().getCanonicalName()));</span>

<span class="fc bfc" id="L1433" title="All 2 branches covered.">            if (!factory.name().matches(&quot;^[a-z]+$&quot;))</span>
<span class="fc" id="L1434">                throw new ConfigurationException(String.format(&quot;SSTable format name for %s must be non-empty, lower-case letters only string&quot;, factory.getClass().getCanonicalName()));</span>

<span class="fc" id="L1436">            SSTableFormat.Factory prev = factoryByName.put(factory.name(), factory);</span>
<span class="fc bfc" id="L1437" title="All 2 branches covered.">            if (prev != null)</span>
<span class="fc" id="L1438">                throw new ConfigurationException(String.format(&quot;Multiple sstable format implementations with the same name %s: %s and %s&quot;, factory.name(), factory.getClass().getCanonicalName(), prev.getClass().getCanonicalName()));</span>
<span class="fc" id="L1439">        }</span>
<span class="fc" id="L1440">    }</span>

    private static ImmutableMap&lt;String, Supplier&lt;SSTableFormat&lt;?, ?&gt;&gt;&gt; validateAndMatchSSTableFormatOptions(Iterable&lt;SSTableFormat.Factory&gt; factories, Map&lt;String, Map&lt;String, String&gt;&gt; options)
    {
<span class="fc" id="L1444">        ImmutableMap.Builder&lt;String, Supplier&lt;SSTableFormat&lt;?, ?&gt;&gt;&gt; providersBuilder = ImmutableMap.builder();</span>
<span class="pc bpc" id="L1445" title="1 of 2 branches missed.">        if (options == null)</span>
<span class="nc" id="L1446">            options = ImmutableMap.of();</span>
<span class="fc bfc" id="L1447" title="All 2 branches covered.">        for (SSTableFormat.Factory factory : factories)</span>
        {
<span class="fc" id="L1449">            Map&lt;String, String&gt; formatOptions = options.getOrDefault(factory.name(), ImmutableMap.of());</span>
<span class="fc" id="L1450">            providersBuilder.put(factory.name(), () -&gt; factory.getInstance(ImmutableMap.copyOf(formatOptions)));</span>
<span class="fc" id="L1451">        }</span>
<span class="fc" id="L1452">        ImmutableMap&lt;String, Supplier&lt;SSTableFormat&lt;?, ?&gt;&gt;&gt; providers = providersBuilder.build();</span>
<span class="pc bpc" id="L1453" title="1 of 2 branches missed.">        if (options != null)</span>
        {
<span class="fc" id="L1455">            Sets.SetView&lt;String&gt; unknownFormatNames = Sets.difference(options.keySet(), providers.keySet());</span>
<span class="fc bfc" id="L1456" title="All 2 branches covered.">            if (!unknownFormatNames.isEmpty())</span>
<span class="fc" id="L1457">                throw new ConfigurationException(String.format(&quot;Configuration contains options of unknown sstable formats: %s&quot;, unknownFormatNames));</span>
        }
<span class="fc" id="L1459">        return providers;</span>
    }

    private static SSTableFormat&lt;?, ?&gt; getAndValidateWriteFormat(Map&lt;String, SSTableFormat&lt;?, ?&gt;&gt; sstableFormats, String selectedFormatName)
    {
        SSTableFormat&lt;?, ?&gt; selectedFormat;
<span class="pc bpc" id="L1465" title="1 of 2 branches missed.">        if (StringUtils.isBlank(selectedFormatName))</span>
<span class="nc" id="L1466">            selectedFormatName = BigFormat.NAME;</span>
<span class="fc" id="L1467">        selectedFormat = sstableFormats.get(selectedFormatName);</span>
<span class="fc bfc" id="L1468" title="All 2 branches covered.">        if (selectedFormat == null)</span>
<span class="fc" id="L1469">            throw new ConfigurationException(String.format(&quot;Selected sstable format '%s' is not available.&quot;, selectedFormatName));</span>

<span class="fc" id="L1471">        getStorageCompatibilityMode().validateSstableFormat(selectedFormat);</span>

<span class="fc" id="L1473">        return selectedFormat;</span>
    }

    private static void applySSTableFormats()
    {
<span class="fc" id="L1478">        ServiceLoader&lt;SSTableFormat.Factory&gt; loader = ServiceLoader.load(SSTableFormat.Factory.class, DatabaseDescriptor.class.getClassLoader());</span>
<span class="fc" id="L1479">        List&lt;SSTableFormat.Factory&gt; factories = Iterables.toList(loader);</span>
<span class="pc bpc" id="L1480" title="1 of 2 branches missed.">        if (factories.isEmpty())</span>
<span class="nc" id="L1481">            factories = ImmutableList.of(new BigFormat.BigFormatFactory());</span>
<span class="fc" id="L1482">        applySSTableFormats(factories, conf.sstable);</span>
<span class="fc" id="L1483">    }</span>

    private static void applySSTableFormats(Iterable&lt;SSTableFormat.Factory&gt; factories, Config.SSTableConfig sstableFormatsConfig)
    {
<span class="fc bfc" id="L1487" title="All 2 branches covered.">        if (sstableFormats != null)</span>
<span class="fc" id="L1488">            return;</span>

<span class="fc" id="L1490">        validateSSTableFormatFactories(factories);</span>
<span class="fc" id="L1491">        ImmutableMap&lt;String, Supplier&lt;SSTableFormat&lt;?, ?&gt;&gt;&gt; providers = validateAndMatchSSTableFormatOptions(factories, sstableFormatsConfig.format);</span>

<span class="fc" id="L1493">        ImmutableMap.Builder&lt;String, SSTableFormat&lt;?, ?&gt;&gt; sstableFormatsBuilder = ImmutableMap.builder();</span>
<span class="fc" id="L1494">        providers.forEach((name, provider) -&gt; {</span>
            try
            {
<span class="fc" id="L1497">                sstableFormatsBuilder.put(name, provider.get());</span>
            }
<span class="nc" id="L1499">            catch (RuntimeException | Error ex)</span>
            {
<span class="nc" id="L1501">                throw new ConfigurationException(String.format(&quot;Failed to instantiate sstable format '%s'&quot;, name), ex);</span>
<span class="fc" id="L1502">            }</span>
<span class="fc" id="L1503">        });</span>
<span class="fc" id="L1504">        sstableFormats = sstableFormatsBuilder.build();</span>

<span class="fc" id="L1506">        selectedSSTableFormat = getAndValidateWriteFormat(sstableFormats, sstableFormatsConfig.selected_format);</span>

<span class="fc" id="L1508">        sstableFormats.values().forEach(SSTableFormat::allComponents); // make sure to reach all supported components for a type so that we know all of them are registered</span>
<span class="fc" id="L1509">        logger.info(&quot;Supported sstable formats are: {}&quot;, sstableFormats.values().stream().map(f -&gt; f.name() + &quot; -&gt; &quot; + f.getClass().getName() + &quot; with singleton components: &quot; + f.allComponents()).collect(Collectors.joining(&quot;, &quot;)));</span>
<span class="fc" id="L1510">    }</span>

    /**
     * Computes the sum of the 2 specified positive values returning {@code Long.MAX_VALUE} if the sum overflow.
     *
     * @param left  the left operand
     * @param right the right operand
     * @return the sum of the 2 specified positive values of {@code Long.MAX_VALUE} if the sum overflow.
     */
    private static long saturatedSum(long left, long right)
    {
<span class="pc bpc" id="L1521" title="2 of 4 branches missed.">        assert left &gt;= 0 &amp;&amp; right &gt;= 0;</span>
<span class="fc" id="L1522">        long sum = left + right;</span>
<span class="pc bpc" id="L1523" title="1 of 2 branches missed.">        return sum &lt; 0 ? Long.MAX_VALUE : sum;</span>
    }

    private static long tryGetSpace(String dir, PathUtils.IOToLongFunction&lt;FileStore&gt; getSpace)
    {
<span class="pc" id="L1528">        return PathUtils.tryGetSpace(new File(dir).toPath(), getSpace, e -&gt; { throw new ConfigurationException(&quot;Unable check disk space in '&quot; + dir + &quot;'. Perhaps the Cassandra user does not have the necessary permissions&quot;); });</span>
    }

    public static IEndpointSnitch createEndpointSnitch(boolean dynamic, String snitchClassName) throws ConfigurationException
    {
<span class="fc bfc" id="L1533" title="All 2 branches covered.">        if (!snitchClassName.contains(&quot;.&quot;))</span>
<span class="fc" id="L1534">            snitchClassName = &quot;org.apache.cassandra.locator.&quot; + snitchClassName;</span>
<span class="fc" id="L1535">        IEndpointSnitch snitch = FBUtilities.construct(snitchClassName, &quot;snitch&quot;);</span>
<span class="fc bfc" id="L1536" title="All 2 branches covered.">        return dynamic ? new DynamicEndpointSnitch(snitch) : snitch;</span>
    }

    private static IFailureDetector createFailureDetector(String detectorClassName) throws ConfigurationException
    {
<span class="pc bpc" id="L1541" title="1 of 2 branches missed.">        if (!detectorClassName.contains(&quot;.&quot;))</span>
<span class="fc" id="L1542">            detectorClassName = &quot;org.apache.cassandra.gms.&quot; + detectorClassName;</span>
<span class="fc" id="L1543">        IFailureDetector detector = FBUtilities.construct(detectorClassName, &quot;failure detector&quot;);</span>
<span class="fc" id="L1544">        return detector;</span>
    }

    public static AbstractCryptoProvider getCryptoProvider()
    {
<span class="fc" id="L1549">        return cryptoProvider;</span>
    }

    public static void setCryptoProvider(AbstractCryptoProvider cryptoProvider)
    {
<span class="fc" id="L1554">        DatabaseDescriptor.cryptoProvider = cryptoProvider;</span>
<span class="fc" id="L1555">    }</span>
    public static IAuthenticator getAuthenticator()
    {
<span class="fc" id="L1558">        return authenticator;</span>
    }

    public static void setAuthenticator(IAuthenticator authenticator)
    {
<span class="fc" id="L1563">        DatabaseDescriptor.authenticator = authenticator;</span>
<span class="fc" id="L1564">    }</span>

    public static IAuthorizer getAuthorizer()
    {
<span class="fc" id="L1568">        return authorizer;</span>
    }

    public static void setAuthorizer(IAuthorizer authorizer)
    {
<span class="fc" id="L1573">        DatabaseDescriptor.authorizer = authorizer;</span>
<span class="fc" id="L1574">    }</span>

    public static INetworkAuthorizer getNetworkAuthorizer()
    {
<span class="fc" id="L1578">        return networkAuthorizer;</span>
    }

    public static void setNetworkAuthorizer(INetworkAuthorizer networkAuthorizer)
    {
<span class="fc" id="L1583">        DatabaseDescriptor.networkAuthorizer = networkAuthorizer;</span>
<span class="fc" id="L1584">    }</span>

    public static ICIDRAuthorizer getCIDRAuthorizer()
    {
<span class="fc" id="L1588">        return cidrAuthorizer;</span>
    }

    public static void setCIDRAuthorizer(ICIDRAuthorizer cidrAuthorizer)
    {
<span class="fc" id="L1593">        DatabaseDescriptor.cidrAuthorizer = cidrAuthorizer;</span>
<span class="fc" id="L1594">    }</span>

    public static boolean getCidrChecksForSuperusers()
    {
<span class="fc" id="L1598">        boolean defaultCidrChecksForSuperusers = false;</span>

<span class="pc bpc" id="L1600" title="1 of 4 branches missed.">        if (conf.cidr_authorizer == null || conf.cidr_authorizer.parameters == null)</span>
<span class="fc" id="L1601">            return defaultCidrChecksForSuperusers;</span>

<span class="fc" id="L1603">        String value = conf.cidr_authorizer.parameters.get(&quot;cidr_checks_for_superusers&quot;);</span>
<span class="pc bpc" id="L1604" title="2 of 4 branches missed.">        if (value == null || value.isEmpty())</span>
<span class="nc" id="L1605">            return defaultCidrChecksForSuperusers;</span>

<span class="fc" id="L1607">        return Boolean.parseBoolean(value);</span>
    }

    public static ICIDRAuthorizer.CIDRAuthorizerMode getCidrAuthorizerMode()
    {
<span class="nc" id="L1612">        ICIDRAuthorizer.CIDRAuthorizerMode defaultCidrAuthorizerMode = ICIDRAuthorizer.CIDRAuthorizerMode.MONITOR;</span>

<span class="nc bnc" id="L1614" title="All 4 branches missed.">        if (conf.cidr_authorizer == null || conf.cidr_authorizer.parameters == null)</span>
<span class="nc" id="L1615">            return defaultCidrAuthorizerMode;</span>

<span class="nc" id="L1617">        String cidrAuthorizerMode = conf.cidr_authorizer.parameters.get(&quot;cidr_authorizer_mode&quot;);</span>
<span class="nc bnc" id="L1618" title="All 4 branches missed.">        if (cidrAuthorizerMode == null || cidrAuthorizerMode.isEmpty())</span>
<span class="nc" id="L1619">            return defaultCidrAuthorizerMode;</span>

<span class="nc" id="L1621">        return ICIDRAuthorizer.CIDRAuthorizerMode.valueOf(cidrAuthorizerMode.toUpperCase());</span>
    }

    public static int getCidrGroupsCacheRefreshInterval()
    {
<span class="fc" id="L1626">        int defaultCidrGroupsCacheRefreshInterval = 5; // mins</span>

<span class="pc bpc" id="L1628" title="3 of 4 branches missed.">        if (conf.cidr_authorizer == null  || conf.cidr_authorizer.parameters == null)</span>
<span class="fc" id="L1629">            return defaultCidrGroupsCacheRefreshInterval;</span>

<span class="nc" id="L1631">        String cidrGroupsCacheRefreshInterval = conf.cidr_authorizer.parameters.get(&quot;cidr_groups_cache_refresh_interval&quot;);</span>
<span class="nc bnc" id="L1632" title="All 4 branches missed.">        if (cidrGroupsCacheRefreshInterval == null || cidrGroupsCacheRefreshInterval.isEmpty())</span>
<span class="nc" id="L1633">            return defaultCidrGroupsCacheRefreshInterval;</span>

<span class="nc" id="L1635">        return Integer.parseInt(cidrGroupsCacheRefreshInterval);</span>
    }

    public static int getIpCacheMaxSize()
    {
<span class="fc" id="L1640">        int defaultIpCacheMaxSize = 100;</span>

<span class="pc bpc" id="L1642" title="3 of 4 branches missed.">        if (conf.cidr_authorizer == null  || conf.cidr_authorizer.parameters == null)</span>
<span class="fc" id="L1643">            return defaultIpCacheMaxSize;</span>

<span class="nc" id="L1645">        String ipCacheMaxSize = conf.cidr_authorizer.parameters.get(&quot;ip_cache_max_size&quot;);</span>
<span class="nc bnc" id="L1646" title="All 4 branches missed.">        if (ipCacheMaxSize == null || ipCacheMaxSize.isEmpty())</span>
<span class="nc" id="L1647">            return defaultIpCacheMaxSize;</span>

<span class="nc" id="L1649">        return Integer.parseInt(ipCacheMaxSize);</span>
    }

    public static void setAuthFromRoot(boolean fromRoot)
    {
<span class="fc" id="L1654">        conf.traverse_auth_from_root = fromRoot;</span>
<span class="fc" id="L1655">    }</span>

    public static boolean getAuthFromRoot()
    {
<span class="fc" id="L1659">        return conf.traverse_auth_from_root;</span>
    }

    public static IRoleManager getRoleManager()
    {
<span class="fc" id="L1664">        return roleManager;</span>
    }

    public static void setRoleManager(IRoleManager roleManager)
    {
<span class="fc" id="L1669">        DatabaseDescriptor.roleManager = roleManager;</span>
<span class="fc" id="L1670">    }</span>

    public static int getPermissionsValidity()
    {
<span class="fc" id="L1674">        return conf.permissions_validity.toMilliseconds();</span>
    }

    public static void setPermissionsValidity(int timeout)
    {
<span class="fc" id="L1679">        conf.permissions_validity = new DurationSpec.IntMillisecondsBound(timeout);</span>
<span class="fc" id="L1680">    }</span>

    public static int getPermissionsUpdateInterval()
    {
<span class="fc bfc" id="L1684" title="All 2 branches covered.">        return conf.permissions_update_interval == null</span>
<span class="fc" id="L1685">             ? conf.permissions_validity.toMilliseconds()</span>
<span class="fc" id="L1686">             : conf.permissions_update_interval.toMilliseconds();</span>
    }

    public static void setPermissionsUpdateInterval(int updateInterval)
    {
<span class="fc bfc" id="L1691" title="All 2 branches covered.">        if (updateInterval == -1)</span>
<span class="fc" id="L1692">            conf.permissions_update_interval = null;</span>
        else
<span class="fc" id="L1694">            conf.permissions_update_interval = new DurationSpec.IntMillisecondsBound(updateInterval);</span>
<span class="fc" id="L1695">    }</span>

    public static int getPermissionsCacheMaxEntries()
    {
<span class="fc" id="L1699">        return conf.permissions_cache_max_entries;</span>
    }

    public static int setPermissionsCacheMaxEntries(int maxEntries)
    {
<span class="fc" id="L1704">        return conf.permissions_cache_max_entries = maxEntries;</span>
    }

    public static boolean getPermissionsCacheActiveUpdate()
    {
<span class="fc" id="L1709">        return conf.permissions_cache_active_update;</span>
    }

    public static void setPermissionsCacheActiveUpdate(boolean update)
    {
<span class="fc" id="L1714">        conf.permissions_cache_active_update = update;</span>
<span class="fc" id="L1715">    }</span>

    public static int getRolesValidity()
    {
<span class="fc" id="L1719">        return conf.roles_validity.toMilliseconds();</span>
    }

    public static void setRolesValidity(int validity)
    {
<span class="fc" id="L1724">        conf.roles_validity = new DurationSpec.IntMillisecondsBound(validity);</span>
<span class="fc" id="L1725">    }</span>

    public static int getRolesUpdateInterval()
    {
<span class="fc bfc" id="L1729" title="All 2 branches covered.">        return conf.roles_update_interval == null</span>
<span class="fc" id="L1730">             ? conf.roles_validity.toMilliseconds()</span>
<span class="fc" id="L1731">             : conf.roles_update_interval.toMilliseconds();</span>
    }

    public static void setRolesCacheActiveUpdate(boolean update)
    {
<span class="fc" id="L1736">        conf.roles_cache_active_update = update;</span>
<span class="fc" id="L1737">    }</span>

    public static boolean getRolesCacheActiveUpdate()
    {
<span class="fc" id="L1741">        return conf.roles_cache_active_update;</span>
    }

    public static void setRolesUpdateInterval(int interval)
    {
<span class="fc bfc" id="L1746" title="All 2 branches covered.">        if (interval == -1)</span>
<span class="fc" id="L1747">            conf.roles_update_interval = null;</span>
        else
<span class="fc" id="L1749">            conf.roles_update_interval = new DurationSpec.IntMillisecondsBound(interval);</span>
<span class="fc" id="L1750">    }</span>

    public static int getRolesCacheMaxEntries()
    {
<span class="fc" id="L1754">        return conf.roles_cache_max_entries;</span>
    }

    public static int setRolesCacheMaxEntries(int maxEntries)
    {
<span class="fc" id="L1759">        return conf.roles_cache_max_entries = maxEntries;</span>
    }

    public static int getCredentialsValidity()
    {
<span class="fc" id="L1764">        return conf.credentials_validity.toMilliseconds();</span>
    }

    public static void setCredentialsValidity(int timeout)
    {
<span class="fc" id="L1769">        conf.credentials_validity = new DurationSpec.IntMillisecondsBound(timeout);</span>
<span class="fc" id="L1770">    }</span>

    public static int getCredentialsUpdateInterval()
    {
<span class="fc bfc" id="L1774" title="All 2 branches covered.">        return conf.credentials_update_interval == null</span>
<span class="fc" id="L1775">               ? conf.credentials_validity.toMilliseconds()</span>
<span class="fc" id="L1776">               : conf.credentials_update_interval.toMilliseconds();</span>
    }

    public static void setCredentialsUpdateInterval(int updateInterval)
    {
<span class="fc bfc" id="L1781" title="All 2 branches covered.">        if (updateInterval == -1)</span>
<span class="fc" id="L1782">            conf.credentials_update_interval = null;</span>
        else
<span class="fc" id="L1784">            conf.credentials_update_interval = new DurationSpec.IntMillisecondsBound(updateInterval);</span>
<span class="fc" id="L1785">    }</span>

    public static int getCredentialsCacheMaxEntries()
    {
<span class="fc" id="L1789">        return conf.credentials_cache_max_entries;</span>
    }

    public static int setCredentialsCacheMaxEntries(int maxEntries)
    {
<span class="fc" id="L1794">        return conf.credentials_cache_max_entries = maxEntries;</span>
    }

    public static boolean getCredentialsCacheActiveUpdate()
    {
<span class="fc" id="L1799">        return conf.credentials_cache_active_update;</span>
    }

    public static void setCredentialsCacheActiveUpdate(boolean update)
    {
<span class="fc" id="L1804">        conf.credentials_cache_active_update = update;</span>
<span class="fc" id="L1805">    }</span>

    public static int getMaxValueSize()
    {
<span class="fc" id="L1809">        return Ints.saturatedCast(conf.max_value_size.toMebibytes() * 1024L * 1024);</span>
    }

    public static void setMaxValueSize(int maxValueSizeInBytes)
    {
        // the below division is safe as this setter is used only in tests with values that won't lead to precision loss
<span class="fc" id="L1815">        conf.max_value_size = new DataStorageSpec.IntMebibytesBound((maxValueSizeInBytes / (1024L * 1024)), MEBIBYTES);</span>
<span class="fc" id="L1816">    }</span>

    /**
     * Creates all storage-related directories.
     */
    public static void createAllDirectories()
    {
        try
        {
<span class="pc bpc" id="L1825" title="1 of 2 branches missed.">            if (conf.data_file_directories.length == 0)</span>
<span class="nc" id="L1826">                throw new ConfigurationException(&quot;At least one DataFileDirectory must be specified&quot;, false);</span>

<span class="fc bfc" id="L1828" title="All 2 branches covered.">            for (String dataFileDirectory : conf.data_file_directories)</span>
<span class="fc" id="L1829">                FileUtils.createDirectory(dataFileDirectory);</span>

<span class="pc bpc" id="L1831" title="1 of 2 branches missed.">            if (conf.local_system_data_file_directory != null)</span>
<span class="nc" id="L1832">                FileUtils.createDirectory(conf.local_system_data_file_directory);</span>

<span class="pc bpc" id="L1834" title="1 of 2 branches missed.">            if (conf.commitlog_directory == null)</span>
<span class="nc" id="L1835">                throw new ConfigurationException(&quot;commitlog_directory must be specified&quot;, false);</span>
<span class="fc" id="L1836">            FileUtils.createDirectory(conf.commitlog_directory);</span>

<span class="pc bpc" id="L1838" title="1 of 2 branches missed.">            if (conf.hints_directory == null)</span>
<span class="nc" id="L1839">                throw new ConfigurationException(&quot;hints_directory must be specified&quot;, false);</span>
<span class="fc" id="L1840">            FileUtils.createDirectory(conf.hints_directory);</span>

<span class="pc bpc" id="L1842" title="1 of 2 branches missed.">            if (conf.saved_caches_directory == null)</span>
<span class="nc" id="L1843">                throw new ConfigurationException(&quot;saved_caches_directory must be specified&quot;, false);</span>
<span class="fc" id="L1844">            FileUtils.createDirectory(conf.saved_caches_directory);</span>

<span class="fc bfc" id="L1846" title="All 2 branches covered.">            if (conf.cdc_enabled)</span>
            {
<span class="pc bpc" id="L1848" title="1 of 2 branches missed.">                if (conf.cdc_raw_directory == null)</span>
<span class="nc" id="L1849">                    throw new ConfigurationException(&quot;cdc_raw_directory must be specified&quot;, false);</span>
<span class="fc" id="L1850">                FileUtils.createDirectory(conf.cdc_raw_directory);</span>
            }

<span class="fc" id="L1853">            boolean created = maybeCreateHeapDumpPath();</span>
<span class="pc bpc" id="L1854" title="2 of 4 branches missed.">            if (!created &amp;&amp; conf.dump_heap_on_uncaught_exception)</span>
            {
<span class="nc bnc" id="L1856" title="All 2 branches missed.">                logger.error(String.format(&quot;cassandra.yaml:dump_heap_on_uncaught_exception is enabled but unable to create heap dump path %s. Disabling.&quot;, conf.heap_dump_path != null ? conf.heap_dump_path : &quot;null&quot;));</span>
<span class="nc" id="L1857">                conf.dump_heap_on_uncaught_exception = false;</span>
            }
        }
<span class="nc" id="L1860">        catch (ConfigurationException e)</span>
        {
<span class="nc" id="L1862">            throw new IllegalArgumentException(&quot;Bad configuration; unable to start server: &quot;+e.getMessage());</span>
        }
<span class="nc" id="L1864">        catch (FSWriteError e)</span>
        {
<span class="nc" id="L1866">            throw new IllegalStateException(e.getCause().getMessage() + &quot;; unable to start server&quot;);</span>
<span class="fc" id="L1867">        }</span>
<span class="fc" id="L1868">    }</span>

    public static IPartitioner getPartitioner()
    {
<span class="fc" id="L1872">        return partitioner;</span>
    }

    public static String getPartitionerName()
    {
<span class="fc" id="L1877">        return paritionerName;</span>
    }

    /* For tests ONLY, don't use otherwise or all hell will break loose. Tests should restore value at the end. */
    public static IPartitioner setPartitionerUnsafe(IPartitioner newPartitioner)
    {
<span class="fc" id="L1883">        IPartitioner old = partitioner;</span>
<span class="fc" id="L1884">        partitioner = newPartitioner;</span>
<span class="fc" id="L1885">        return old;</span>
    }

    public static IEndpointSnitch getEndpointSnitch()
    {
<span class="fc" id="L1890">        return snitch;</span>
    }
    public static void setEndpointSnitch(IEndpointSnitch eps)
    {
<span class="fc" id="L1894">        snitch = eps;</span>
<span class="fc" id="L1895">    }</span>

    public static IFailureDetector newFailureDetector()
    {
<span class="fc" id="L1899">        return newFailureDetector.get();</span>
    }

    public static void setDefaultFailureDetector()
    {
<span class="fc" id="L1904">        newFailureDetector = () -&gt; createFailureDetector(&quot;FailureDetector&quot;);</span>
<span class="fc" id="L1905">    }</span>

    public static int getColumnIndexSize(int defaultValue)
    {
<span class="fc bfc" id="L1909" title="All 2 branches covered.">        return conf.column_index_size != null ? conf.column_index_size.toBytes() : defaultValue;</span>
    }

    public static int getColumnIndexSizeInKiB()
    {
<span class="fc bfc" id="L1914" title="All 2 branches covered.">        return conf.column_index_size != null ? conf.column_index_size.toKibibytes() : -1;</span>
    }

    public static void setColumnIndexSizeInKiB(int val)
    {
<span class="fc bfc" id="L1919" title="All 2 branches covered.">        conf.column_index_size = val != -1 ? createIntKibibyteBoundAndEnsureItIsValidForByteConversion(val,&quot;column_index_size&quot;) : null;</span>
<span class="fc" id="L1920">    }</span>

    public static int getColumnIndexCacheSize()
    {
<span class="fc" id="L1924">        return conf.column_index_cache_size.toBytes();</span>
    }

    public static int getColumnIndexCacheSizeInKiB()
    {
<span class="fc" id="L1929">        return conf.column_index_cache_size.toKibibytes();</span>
    }

    public static void setColumnIndexCacheSize(int val)
    {
<span class="fc" id="L1934">        conf.column_index_cache_size = createIntKibibyteBoundAndEnsureItIsValidForByteConversion(val,&quot;column_index_cache_size&quot;);</span>
<span class="fc" id="L1935">    }</span>

    public static int getBatchSizeWarnThreshold()
    {
<span class="fc" id="L1939">        return conf.batch_size_warn_threshold.toBytes();</span>
    }

    public static int getBatchSizeWarnThresholdInKiB()
    {
<span class="fc" id="L1944">        return conf.batch_size_warn_threshold.toKibibytes();</span>
    }

    public static long getBatchSizeFailThreshold()
    {
<span class="fc" id="L1949">        return conf.batch_size_fail_threshold.toBytesInLong();</span>
    }

    public static int getBatchSizeFailThresholdInKiB()
    {
<span class="fc" id="L1954">        return conf.batch_size_fail_threshold.toKibibytes();</span>
    }

    public static int getUnloggedBatchAcrossPartitionsWarnThreshold()
    {
<span class="fc" id="L1959">        return conf.unlogged_batch_across_partitions_warn_threshold;</span>
    }

    public static void setBatchSizeWarnThresholdInKiB(int threshold)
    {
<span class="fc" id="L1964">        conf.batch_size_warn_threshold = createIntKibibyteBoundAndEnsureItIsValidForByteConversion(threshold,&quot;batch_size_warn_threshold&quot;);</span>
<span class="fc" id="L1965">    }</span>

    public static void setBatchSizeFailThresholdInKiB(int threshold)
    {
<span class="fc" id="L1969">        conf.batch_size_fail_threshold = new DataStorageSpec.IntKibibytesBound(threshold);</span>
<span class="fc" id="L1970">    }</span>

    public static Collection&lt;String&gt; getInitialTokens()
    {
<span class="fc" id="L1974">        return tokensFromString(INITIAL_TOKEN.getString(conf.initial_token));</span>
    }

    public static String getAllocateTokensForKeyspace()
    {
<span class="fc" id="L1979">        return ALLOCATE_TOKENS_FOR_KEYSPACE.getString(conf.allocate_tokens_for_keyspace);</span>
    }

    public static Integer getAllocateTokensForLocalRf()
    {
<span class="fc" id="L1984">        return conf.allocate_tokens_for_local_replication_factor;</span>
    }

    public static Collection&lt;String&gt; tokensFromString(String tokenString)
    {
<span class="fc" id="L1989">        List&lt;String&gt; tokens = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1990" title="All 2 branches covered.">        if (tokenString != null)</span>
<span class="fc bfc" id="L1991" title="All 2 branches covered.">            for (String token : StringUtils.split(tokenString, ','))</span>
<span class="fc" id="L1992">                tokens.add(token.trim());</span>
<span class="fc" id="L1993">        return tokens;</span>
    }

    public static int getNumTokens()
    {
<span class="fc" id="L1998">        return conf.num_tokens;</span>
    }

    public static InetAddressAndPort getReplaceAddress()
    {
        try
        {
<span class="fc" id="L2005">            String replaceAddress = REPLACE_ADDRESS.getString();</span>
<span class="fc bfc" id="L2006" title="All 2 branches covered.">            if (replaceAddress != null)</span>
<span class="fc" id="L2007">                return InetAddressAndPort.getByName(replaceAddress);</span>

<span class="fc" id="L2009">            String replaceAddressFirsstBoot = REPLACE_ADDRESS_FIRST_BOOT.getString();</span>
<span class="fc bfc" id="L2010" title="All 2 branches covered.">            if (replaceAddressFirsstBoot != null)</span>
<span class="fc" id="L2011">                return InetAddressAndPort.getByName(replaceAddressFirsstBoot);</span>

<span class="fc" id="L2013">            return null;</span>
        }
<span class="fc" id="L2015">        catch (UnknownHostException e)</span>
        {
<span class="fc" id="L2017">            throw new RuntimeException(&quot;Replacement host name could not be resolved or scope_id was specified for a global IPv6 address&quot;, e);</span>
        }
    }

    public static Collection&lt;String&gt; getReplaceTokens()
    {
<span class="fc" id="L2023">        return tokensFromString(REPLACE_TOKEN.getString());</span>
    }

    public static UUID getReplaceNode()
    {
        try
        {
<span class="nc" id="L2030">            return UUID.fromString(REPLACE_NODE.getString());</span>
<span class="fc" id="L2031">        } catch (NullPointerException e)</span>
        {
<span class="fc" id="L2033">            return null;</span>
        }
    }

    public static String getClusterName()
    {
<span class="fc" id="L2039">        return conf.cluster_name;</span>
    }

    public static int getStoragePort()
    {
<span class="fc" id="L2044">        return STORAGE_PORT.getInt(conf.storage_port);</span>
    }

    public static int getSSLStoragePort()
    {
<span class="fc" id="L2049">        return SSL_STORAGE_PORT.getInt(conf.ssl_storage_port);</span>
    }

    public static long nativeTransportIdleTimeout()
    {
<span class="fc" id="L2054">        return conf.native_transport_idle_timeout.toMilliseconds();</span>
    }

    public static void setNativeTransportIdleTimeout(long nativeTransportTimeout)
    {
<span class="fc" id="L2059">        conf.native_transport_idle_timeout = new DurationSpec.LongMillisecondsBound(nativeTransportTimeout);</span>
<span class="fc" id="L2060">    }</span>

    public static long getRpcTimeout(TimeUnit unit)
    {
<span class="fc" id="L2064">        return conf.request_timeout.to(unit);</span>
    }

    public static void setRpcTimeout(long timeOutInMillis)
    {
<span class="fc" id="L2069">        conf.request_timeout = new DurationSpec.LongMillisecondsBound(timeOutInMillis);</span>
<span class="fc" id="L2070">    }</span>

    public static long getReadRpcTimeout(TimeUnit unit)
    {
<span class="fc" id="L2074">        return conf.read_request_timeout.to(unit);</span>
    }

    public static void setReadRpcTimeout(long timeOutInMillis)
    {
<span class="fc" id="L2079">        conf.read_request_timeout = new DurationSpec.LongMillisecondsBound(timeOutInMillis);</span>
<span class="fc" id="L2080">    }</span>

    public static long getRangeRpcTimeout(TimeUnit unit)
    {
<span class="fc" id="L2084">        return conf.range_request_timeout.to(unit);</span>
    }

    public static void setRangeRpcTimeout(long timeOutInMillis)
    {
<span class="fc" id="L2089">        conf.range_request_timeout = new DurationSpec.LongMillisecondsBound(timeOutInMillis);</span>
<span class="fc" id="L2090">    }</span>

    public static long getWriteRpcTimeout(TimeUnit unit)
    {
<span class="fc" id="L2094">        return conf.write_request_timeout.to(unit);</span>
    }

    public static void setWriteRpcTimeout(long timeOutInMillis)
    {
<span class="fc" id="L2099">        conf.write_request_timeout = new DurationSpec.LongMillisecondsBound(timeOutInMillis);</span>
<span class="fc" id="L2100">    }</span>

    public static long getCounterWriteRpcTimeout(TimeUnit unit)
    {
<span class="fc" id="L2104">        return conf.counter_write_request_timeout.to(unit);</span>
    }

    public static void setCounterWriteRpcTimeout(long timeOutInMillis)
    {
<span class="fc" id="L2109">        conf.counter_write_request_timeout = new DurationSpec.LongMillisecondsBound(timeOutInMillis);</span>
<span class="fc" id="L2110">    }</span>

    public static long getCasContentionTimeout(TimeUnit unit)
    {
<span class="fc" id="L2114">        return conf.cas_contention_timeout.to(unit);</span>
    }

    public static void setCasContentionTimeout(long timeOutInMillis)
    {
<span class="fc" id="L2119">        conf.cas_contention_timeout = new DurationSpec.LongMillisecondsBound(timeOutInMillis);</span>
<span class="fc" id="L2120">    }</span>

    public static long getTruncateRpcTimeout(TimeUnit unit)
    {
<span class="fc" id="L2124">        return conf.truncate_request_timeout.to(unit);</span>
    }

    public static void setTruncateRpcTimeout(long timeOutInMillis)
    {
<span class="fc" id="L2129">        conf.truncate_request_timeout = new DurationSpec.LongMillisecondsBound(timeOutInMillis);</span>
<span class="fc" id="L2130">    }</span>

    public static long getRepairRpcTimeout(TimeUnit unit)
    {
<span class="fc" id="L2134">        return conf.repair_request_timeout.to(unit);</span>
    }

    public static void setRepairRpcTimeout(Long timeOutInMillis)
    {
<span class="fc" id="L2139">        conf.repair_request_timeout = new DurationSpec.LongMillisecondsBound(timeOutInMillis);</span>
<span class="fc" id="L2140">    }</span>

    public static boolean hasCrossNodeTimeout()
    {
<span class="fc" id="L2144">        return conf.internode_timeout;</span>
    }

    public static void setCrossNodeTimeout(boolean crossNodeTimeout)
    {
<span class="fc" id="L2149">        conf.internode_timeout = crossNodeTimeout;</span>
<span class="fc" id="L2150">    }</span>

    public static long getSlowQueryTimeout(TimeUnit unit)
    {
<span class="fc" id="L2154">        return conf.slow_query_log_timeout.to(unit);</span>
    }

    /**
     * @return the minimum configured {read, write, range, truncate, misc} timeout
     */
    public static long getMinRpcTimeout(TimeUnit unit)
    {
<span class="fc" id="L2162">        return Longs.min(getRpcTimeout(unit),</span>
<span class="fc" id="L2163">                         getReadRpcTimeout(unit),</span>
<span class="fc" id="L2164">                         getRangeRpcTimeout(unit),</span>
<span class="fc" id="L2165">                         getWriteRpcTimeout(unit),</span>
<span class="fc" id="L2166">                         getCounterWriteRpcTimeout(unit),</span>
<span class="fc" id="L2167">                         getTruncateRpcTimeout(unit));</span>
    }

    public static long getPingTimeout(TimeUnit unit)
    {
<span class="fc" id="L2172">        return unit.convert(getBlockForPeersTimeoutInSeconds(), TimeUnit.SECONDS);</span>
    }

    public static double getPhiConvictThreshold()
    {
<span class="fc" id="L2177">        return conf.phi_convict_threshold;</span>
    }

    public static void setPhiConvictThreshold(double phiConvictThreshold)
    {
<span class="fc" id="L2182">        conf.phi_convict_threshold = phiConvictThreshold;</span>
<span class="fc" id="L2183">    }</span>

    public static int getConcurrentReaders()
    {
<span class="fc" id="L2187">        return conf.concurrent_reads;</span>
    }

    public static void setConcurrentReaders(int concurrent_reads)
    {
<span class="nc bnc" id="L2192" title="All 2 branches missed.">        if (concurrent_reads &lt; 0)</span>
        {
<span class="nc" id="L2194">            throw new IllegalArgumentException(&quot;Concurrent reads must be non-negative&quot;);</span>
        }
<span class="nc" id="L2196">        conf.concurrent_reads = concurrent_reads;</span>
<span class="nc" id="L2197">    }</span>

    public static int getConcurrentWriters()
    {
<span class="fc" id="L2201">        return conf.concurrent_writes;</span>
    }

    public static void setConcurrentWriters(int concurrent_writers)
    {
<span class="nc bnc" id="L2206" title="All 2 branches missed.">        if (concurrent_writers &lt; 0)</span>
        {
<span class="nc" id="L2208">            throw new IllegalArgumentException(&quot;Concurrent reads must be non-negative&quot;);</span>
        }
<span class="nc" id="L2210">        conf.concurrent_writes = concurrent_writers;</span>
<span class="nc" id="L2211">    }</span>

    public static int getConcurrentCounterWriters()
    {
<span class="fc" id="L2215">        return conf.concurrent_counter_writes;</span>
    }

    public static void setConcurrentCounterWriters(int concurrent_counter_writes)
    {
<span class="nc bnc" id="L2220" title="All 2 branches missed.">        if (concurrent_counter_writes &lt; 0)</span>
        {
<span class="nc" id="L2222">            throw new IllegalArgumentException(&quot;Concurrent reads must be non-negative&quot;);</span>
        }
<span class="nc" id="L2224">        conf.concurrent_counter_writes = concurrent_counter_writes;</span>
<span class="nc" id="L2225">    }</span>

    public static int getConcurrentViewWriters()
    {
<span class="fc" id="L2229">        return conf.concurrent_materialized_view_writes;</span>
    }

    public static void setConcurrentViewWriters(int concurrent_materialized_view_writes)
    {
<span class="nc bnc" id="L2234" title="All 2 branches missed.">        if (concurrent_materialized_view_writes &lt; 0)</span>
        {
<span class="nc" id="L2236">            throw new IllegalArgumentException(&quot;Concurrent reads must be non-negative&quot;);</span>
        }
<span class="nc" id="L2238">        conf.concurrent_materialized_view_writes = concurrent_materialized_view_writes;</span>
<span class="nc" id="L2239">    }</span>

    public static int getFlushWriters()
    {
<span class="fc" id="L2243">        return conf.memtable_flush_writers;</span>
    }

    public static int getAvailableProcessors()
    {
<span class="pc bpc" id="L2248" title="1 of 2 branches missed.">        return conf == null ? -1 : conf.available_processors;</span>
    }

    public static int getConcurrentCompactors()
    {
<span class="fc" id="L2253">        return conf.concurrent_compactors;</span>
    }

    public static void setConcurrentCompactors(int value)
    {
<span class="fc" id="L2258">        conf.concurrent_compactors = value;</span>
<span class="fc" id="L2259">    }</span>

    public static int getCompactionThroughputMebibytesPerSecAsInt()
    {
<span class="fc" id="L2263">        return conf.compaction_throughput.toMebibytesPerSecondAsInt();</span>
    }

    public static double getCompactionThroughputBytesPerSec()
    {
<span class="fc" id="L2268">        return conf.compaction_throughput.toBytesPerSecond();</span>
    }

    public static double getCompactionThroughputMebibytesPerSec()
    {
<span class="fc" id="L2273">        return conf.compaction_throughput.toMebibytesPerSecond();</span>
    }

    @VisibleForTesting // only for testing!
    public static void setCompactionThroughputBytesPerSec(int value)
    {
<span class="pc bpc" id="L2279" title="1 of 2 branches missed.">        if (BYTES_PER_SECOND.toMebibytesPerSecond(value) &gt;= Integer.MAX_VALUE)</span>
<span class="nc" id="L2280">            throw new IllegalArgumentException(&quot;compaction_throughput: &quot; + value +</span>
                                               &quot; is too large; it should be less than &quot; +
                                               Integer.MAX_VALUE + &quot; in MiB/s&quot;);

<span class="fc" id="L2284">        conf.compaction_throughput = new DataRateSpec.LongBytesPerSecondBound(value);</span>
<span class="fc" id="L2285">    }</span>

    public static void setCompactionThroughputMebibytesPerSec(int value)
    {
<span class="fc bfc" id="L2289" title="All 2 branches covered.">        if (value == Integer.MAX_VALUE)</span>
<span class="fc" id="L2290">            throw new IllegalArgumentException(&quot;compaction_throughput: &quot; + value +</span>
                                               &quot; is too large; it should be less than &quot; +
                                               Integer.MAX_VALUE + &quot; in MiB/s&quot;);

<span class="fc" id="L2294">        conf.compaction_throughput = new DataRateSpec.LongBytesPerSecondBound(value, MEBIBYTES_PER_SECOND);</span>
<span class="fc" id="L2295">    }</span>

    public static int getConcurrentValidations()
    {
<span class="fc" id="L2299">        return conf.concurrent_validations;</span>
    }

    public static int getConcurrentIndexBuilders()
    {
<span class="fc" id="L2304">        return conf.concurrent_index_builders;</span>
    }

    public static void setConcurrentValidations(int value)
    {
<span class="pc bpc" id="L2309" title="1 of 2 branches missed.">        value = value &gt; 0 ? value : Integer.MAX_VALUE;</span>
<span class="fc" id="L2310">        conf.concurrent_validations = value;</span>
<span class="fc" id="L2311">    }</span>

    public static int getConcurrentViewBuilders()
    {
<span class="fc" id="L2315">        return conf.concurrent_materialized_view_builders;</span>
    }

    public static void setConcurrentViewBuilders(int value)
    {
<span class="fc" id="L2320">        conf.concurrent_materialized_view_builders = value;</span>
<span class="fc" id="L2321">    }</span>

    public static long getMinFreeSpacePerDriveInMebibytes()
    {
<span class="fc" id="L2325">        return conf.min_free_space_per_drive.toMebibytes();</span>
    }

    public static long getMinFreeSpacePerDriveInBytes()
    {
<span class="fc" id="L2330">        return conf.min_free_space_per_drive.toBytesInLong();</span>
    }

    @VisibleForTesting
    public static long setMinFreeSpacePerDriveInMebibytes(long mebiBytes)
    {
<span class="fc" id="L2336">        conf.min_free_space_per_drive = new DataStorageSpec.IntMebibytesBound(mebiBytes);</span>
<span class="fc" id="L2337">        return getMinFreeSpacePerDriveInBytes();</span>
    }

    public static double getMaxSpaceForCompactionsPerDrive()
    {
<span class="fc" id="L2342">        return conf.max_space_usable_for_compactions_in_percentage;</span>
    }

    public static void setMaxSpaceForCompactionsPerDrive(double percentage)
    {
<span class="fc" id="L2347">        conf.max_space_usable_for_compactions_in_percentage = percentage;</span>
<span class="fc" id="L2348">    }</span>

    public static boolean getDisableSTCSInL0()
    {
<span class="fc" id="L2352">        return disableSTCSInL0;</span>
    }

    public static void setDisableSTCSInL0(boolean disabled)
    {
<span class="fc" id="L2357">        disableSTCSInL0 = disabled;</span>
<span class="fc" id="L2358">    }</span>

    public static int getStreamThroughputOutboundMegabitsPerSec()
    {
<span class="fc" id="L2362">        return conf.stream_throughput_outbound.toMegabitsPerSecondAsInt();</span>
    }

    public static double getStreamThroughputOutboundMegabitsPerSecAsDouble()
    {
<span class="fc" id="L2367">        return conf.stream_throughput_outbound.toMegabitsPerSecond();</span>
    }

    public static double getStreamThroughputOutboundMebibytesPerSec()
    {
<span class="fc" id="L2372">        return conf.stream_throughput_outbound.toMebibytesPerSecond();</span>
    }

    public static double getStreamThroughputOutboundBytesPerSec()
    {
<span class="fc" id="L2377">        return conf.stream_throughput_outbound.toBytesPerSecond();</span>
    }

    public static int getStreamThroughputOutboundMebibytesPerSecAsInt()
    {
<span class="fc" id="L2382">        return conf.stream_throughput_outbound.toMebibytesPerSecondAsInt();</span>
    }

    public static void setStreamThroughputOutboundMebibytesPerSecAsInt(int value)
    {
<span class="fc bfc" id="L2387" title="All 2 branches covered.">        if (MEBIBYTES_PER_SECOND.toMegabitsPerSecond(value) &gt;= Integer.MAX_VALUE)</span>
<span class="fc" id="L2388">            throw new IllegalArgumentException(&quot;stream_throughput_outbound: &quot; + value  +</span>
                                               &quot; is too large; it should be less than &quot; +
                                               Integer.MAX_VALUE + &quot; in megabits/s&quot;);

<span class="fc" id="L2392">        conf.stream_throughput_outbound = new DataRateSpec.LongBytesPerSecondBound(value, MEBIBYTES_PER_SECOND);</span>
<span class="fc" id="L2393">    }</span>

    public static void setStreamThroughputOutboundBytesPerSec(long value)
    {
<span class="fc" id="L2397">        conf.stream_throughput_outbound = new DataRateSpec.LongBytesPerSecondBound(value, BYTES_PER_SECOND);</span>
<span class="fc" id="L2398">    }</span>

    public static void setStreamThroughputOutboundMegabitsPerSec(int value)
    {
<span class="fc" id="L2402">        conf.stream_throughput_outbound = DataRateSpec.LongBytesPerSecondBound.megabitsPerSecondInBytesPerSecond(value);</span>
<span class="fc" id="L2403">    }</span>

    public static double getEntireSSTableStreamThroughputOutboundMebibytesPerSec()
    {
<span class="fc" id="L2407">        return conf.entire_sstable_stream_throughput_outbound.toMebibytesPerSecond();</span>
    }

    public static double getEntireSSTableStreamThroughputOutboundBytesPerSec()
    {
<span class="fc" id="L2412">        return conf.entire_sstable_stream_throughput_outbound.toBytesPerSecond();</span>
    }

    public static void setEntireSSTableStreamThroughputOutboundMebibytesPerSec(int value)
    {
<span class="fc bfc" id="L2417" title="All 2 branches covered.">        if (value == Integer.MAX_VALUE)</span>
<span class="fc" id="L2418">            throw new IllegalArgumentException(&quot;entire_sstable_stream_throughput_outbound: &quot; + value +</span>
                                               &quot; is too large; it should be less than &quot; +
                                               Integer.MAX_VALUE + &quot; in MiB/s&quot;);

<span class="fc" id="L2422">        conf.entire_sstable_stream_throughput_outbound = new DataRateSpec.LongBytesPerSecondBound(value, MEBIBYTES_PER_SECOND);</span>
<span class="fc" id="L2423">    }</span>

    public static int getInterDCStreamThroughputOutboundMegabitsPerSec()
    {
<span class="fc" id="L2427">        return conf.inter_dc_stream_throughput_outbound.toMegabitsPerSecondAsInt();</span>
    }

    public static double getInterDCStreamThroughputOutboundMegabitsPerSecAsDouble()
    {
<span class="fc" id="L2432">        return conf.inter_dc_stream_throughput_outbound.toMegabitsPerSecond();</span>
    }

    public static double getInterDCStreamThroughputOutboundMebibytesPerSec()
    {
<span class="fc" id="L2437">        return conf.inter_dc_stream_throughput_outbound.toMebibytesPerSecond();</span>
    }

    public static double getInterDCStreamThroughputOutboundBytesPerSec()
    {
<span class="fc" id="L2442">        return conf.inter_dc_stream_throughput_outbound.toBytesPerSecond();</span>
    }

    public static int getInterDCStreamThroughputOutboundMebibytesPerSecAsInt()
    {
<span class="fc" id="L2447">        return conf.inter_dc_stream_throughput_outbound.toMebibytesPerSecondAsInt();</span>
    }

    public static void setInterDCStreamThroughputOutboundMebibytesPerSecAsInt(int value)
    {
<span class="fc bfc" id="L2452" title="All 2 branches covered.">        if (MEBIBYTES_PER_SECOND.toMegabitsPerSecond(value) &gt;= Integer.MAX_VALUE)</span>
<span class="fc" id="L2453">            throw new IllegalArgumentException(&quot;inter_dc_stream_throughput_outbound: &quot; + value +</span>
                                               &quot; is too large; it should be less than &quot; +
                                               Integer.MAX_VALUE + &quot; in megabits/s&quot;);

<span class="fc" id="L2457">        conf.inter_dc_stream_throughput_outbound = new DataRateSpec.LongBytesPerSecondBound(value, MEBIBYTES_PER_SECOND);</span>
<span class="fc" id="L2458">    }</span>

    public static void setInterDCStreamThroughputOutboundBytesPerSec(long value)
    {
<span class="fc" id="L2462">        conf.inter_dc_stream_throughput_outbound = new DataRateSpec.LongBytesPerSecondBound(value, BYTES_PER_SECOND);</span>
<span class="fc" id="L2463">    }</span>

    public static void setInterDCStreamThroughputOutboundMegabitsPerSec(int value)
    {
<span class="fc" id="L2467">        conf.inter_dc_stream_throughput_outbound = DataRateSpec.LongBytesPerSecondBound.megabitsPerSecondInBytesPerSecond(value);</span>
<span class="fc" id="L2468">    }</span>

    public static double getEntireSSTableInterDCStreamThroughputOutboundBytesPerSec()
    {
<span class="fc" id="L2472">        return conf.entire_sstable_inter_dc_stream_throughput_outbound.toBytesPerSecond();</span>
    }

    public static double getEntireSSTableInterDCStreamThroughputOutboundMebibytesPerSec()
    {
<span class="fc" id="L2477">        return conf.entire_sstable_inter_dc_stream_throughput_outbound.toMebibytesPerSecond();</span>
    }

    public static void setEntireSSTableInterDCStreamThroughputOutboundMebibytesPerSec(int value)
    {
<span class="fc bfc" id="L2482" title="All 2 branches covered.">        if (value == Integer.MAX_VALUE)</span>
<span class="fc" id="L2483">            throw new IllegalArgumentException(&quot;entire_sstable_inter_dc_stream_throughput_outbound: &quot; + value +</span>
                                               &quot; is too large; it should be less than &quot; +
                                               Integer.MAX_VALUE + &quot; in MiB/s&quot;);

<span class="fc" id="L2487">        conf.entire_sstable_inter_dc_stream_throughput_outbound = new DataRateSpec.LongBytesPerSecondBound(value, MEBIBYTES_PER_SECOND);</span>
<span class="fc" id="L2488">    }</span>

    /**
     * Checks if the local system data must be stored in a specific location which supports redundancy.
     *
     * @return {@code true} if the local system keyspaces data must be stored in a different location,
     * {@code false} otherwise.
     */
    public static boolean useSpecificLocationForLocalSystemData()
    {
<span class="fc bfc" id="L2498" title="All 2 branches covered.">        return conf.local_system_data_file_directory != null;</span>
    }

    /**
     * Returns the locations where the local system keyspaces data should be stored.
     *
     * &lt;p&gt;If the {@code local_system_data_file_directory} was unspecified, the local system keyspaces data should be stored
     * in the first data directory. This approach guarantees that the server can tolerate the lost of all the disks but the first one.&lt;/p&gt;
     *
     * @return the locations where should be stored the local system keyspaces data
     */
    public static String[] getLocalSystemKeyspacesDataFileLocations()
    {
<span class="fc bfc" id="L2511" title="All 2 branches covered.">        if (useSpecificLocationForLocalSystemData())</span>
<span class="fc" id="L2512">            return new String[] {conf.local_system_data_file_directory};</span>

<span class="pc bpc" id="L2514" title="1 of 2 branches missed.">        return conf.data_file_directories.length == 0  ? conf.data_file_directories</span>
<span class="fc" id="L2515">                                                       : new String[] {conf.data_file_directories[0]};</span>
    }

    /**
     * Returns the locations where the non local system keyspaces data should be stored.
     *
     * @return the locations where the non local system keyspaces data should be stored.
     */
    public static String[] getNonLocalSystemKeyspacesDataFileLocations()
    {
<span class="fc" id="L2525">        return conf.data_file_directories;</span>
    }

    /**
     * Returns the list of all the directories where the data files can be stored (for local system and non local system keyspaces).
     *
     * @return the list of all the directories where the data files can be stored.
     */
    public static String[] getAllDataFileLocations()
    {
<span class="fc bfc" id="L2535" title="All 2 branches covered.">        if (conf.local_system_data_file_directory == null)</span>
<span class="fc" id="L2536">            return conf.data_file_directories;</span>

<span class="fc" id="L2538">        return ArrayUtils.addFirst(conf.data_file_directories, conf.local_system_data_file_directory);</span>
    }

    public static String getCommitLogLocation()
    {
<span class="fc" id="L2543">        return conf.commitlog_directory;</span>
    }

    @VisibleForTesting
    public static void setCommitLogLocation(String value)
    {
<span class="fc" id="L2549">        conf.commitlog_directory = value;</span>
<span class="fc" id="L2550">    }</span>

    public static ParameterizedClass getCommitLogCompression()
    {
<span class="fc" id="L2554">        return conf.commitlog_compression;</span>
    }

    public static void setCommitLogCompression(ParameterizedClass compressor)
    {
<span class="fc" id="L2559">        conf.commitlog_compression = compressor;</span>
<span class="fc" id="L2560">    }</span>

    public static Config.FlushCompression getFlushCompression()
    {
<span class="fc" id="L2564">        return conf.flush_compression;</span>
    }

    public static void setFlushCompression(Config.FlushCompression compression)
    {
<span class="fc" id="L2569">        conf.flush_compression = compression;</span>
<span class="fc" id="L2570">    }</span>

   /**
    * Maximum number of buffers in the compression pool. The default value is 3, it should not be set lower than that
    * (one segment in compression, one written to, one in reserve); delays in compression may cause the log to use
    * more, depending on how soon the sync policy stops all writing threads.
    */
    public static int getCommitLogMaxCompressionBuffersInPool()
    {
<span class="fc" id="L2579">        return conf.commitlog_max_compression_buffers_in_pool;</span>
    }

    public static void setCommitLogMaxCompressionBuffersPerPool(int buffers)
    {
<span class="fc" id="L2584">        conf.commitlog_max_compression_buffers_in_pool = buffers;</span>
<span class="fc" id="L2585">    }</span>

    public static int getMaxMutationSize()
    {
<span class="fc" id="L2589">        return conf.max_mutation_size.toBytes();</span>
    }

    public static int getTombstoneWarnThreshold()
    {
<span class="fc" id="L2594">        return conf.tombstone_warn_threshold;</span>
    }

    public static void setTombstoneWarnThreshold(int threshold)
    {
<span class="fc" id="L2599">        conf.tombstone_warn_threshold = threshold;</span>
<span class="fc" id="L2600">    }</span>

    public static int getTombstoneFailureThreshold()
    {
<span class="fc" id="L2604">        return conf.tombstone_failure_threshold;</span>
    }

    public static void setTombstoneFailureThreshold(int threshold)
    {
<span class="fc" id="L2609">        conf.tombstone_failure_threshold = threshold;</span>
<span class="fc" id="L2610">    }</span>

    public static int getCachedReplicaRowsWarnThreshold()
    {
<span class="fc" id="L2614">        return conf.replica_filtering_protection.cached_rows_warn_threshold;</span>
    }

    public static void setCachedReplicaRowsWarnThreshold(int threshold)
    {
<span class="fc" id="L2619">        conf.replica_filtering_protection.cached_rows_warn_threshold = threshold;</span>
<span class="fc" id="L2620">    }</span>

    public static int getCachedReplicaRowsFailThreshold()
    {
<span class="fc" id="L2624">        return conf.replica_filtering_protection.cached_rows_fail_threshold;</span>
    }

    public static void setCachedReplicaRowsFailThreshold(int threshold)
    {
<span class="fc" id="L2629">        conf.replica_filtering_protection.cached_rows_fail_threshold = threshold;</span>
<span class="fc" id="L2630">    }</span>

    /**
     * size of commitlog segments to allocate
     */
    public static int getCommitLogSegmentSize()
    {
<span class="fc" id="L2637">        return conf.commitlog_segment_size.toBytes();</span>
    }

    /**
     * Update commitlog_segment_size in the tests.
     * {@link CommitLogSegmentManagerCDC} uses the CommitLogSegmentSize to estimate the file size on allocation.
     * It is important to keep the value unchanged for the estimation to be correct.
     * @param sizeMebibytes
     */
    @VisibleForTesting /* Only for testing */
    public static void setCommitLogSegmentSize(int sizeMebibytes)
    {
<span class="fc" id="L2649">        conf.commitlog_segment_size = new DataStorageSpec.IntMebibytesBound(sizeMebibytes);</span>
<span class="fc" id="L2650">    }</span>

    public static String getSavedCachesLocation()
    {
<span class="fc" id="L2654">        return conf.saved_caches_directory;</span>
    }

    public static Set&lt;InetAddressAndPort&gt; getSeeds()
    {
<span class="fc" id="L2659">        return ImmutableSet.&lt;InetAddressAndPort&gt;builder().addAll(seedProvider.getSeeds()).build();</span>
    }

    public static SeedProvider getSeedProvider()
    {
<span class="fc" id="L2664">        return seedProvider;</span>
    }

    public static void setSeedProvider(SeedProvider newSeedProvider)
    {
<span class="fc" id="L2669">        seedProvider = newSeedProvider;</span>
<span class="fc" id="L2670">    }</span>

    public static InetAddress getListenAddress()
    {
<span class="fc" id="L2674">        return listenAddress;</span>
    }

    public static void setListenAddress(InetAddress newlistenAddress)
    {
<span class="fc" id="L2679">        listenAddress = newlistenAddress;</span>
<span class="fc" id="L2680">    }</span>

    public static InetAddress getBroadcastAddress()
    {
<span class="fc" id="L2684">        return broadcastAddress;</span>
    }

    public static boolean shouldListenOnBroadcastAddress()
    {
<span class="fc" id="L2689">        return conf.listen_on_broadcast_address;</span>
    }

    public static void setShouldListenOnBroadcastAddress(boolean shouldListenOnBroadcastAddress)
    {
<span class="fc" id="L2694">        conf.listen_on_broadcast_address = shouldListenOnBroadcastAddress;</span>
<span class="fc" id="L2695">    }</span>

    public static void setListenOnBroadcastAddress(boolean listen_on_broadcast_address)
    {
<span class="nc" id="L2699">        conf.listen_on_broadcast_address = listen_on_broadcast_address;</span>
<span class="nc" id="L2700">    }</span>

    public static IInternodeAuthenticator getInternodeAuthenticator()
    {
<span class="fc" id="L2704">        return internodeAuthenticator;</span>
    }

    public static void setInternodeAuthenticator(IInternodeAuthenticator internodeAuthenticator)
    {
<span class="fc" id="L2709">        Preconditions.checkNotNull(internodeAuthenticator);</span>
<span class="fc" id="L2710">        DatabaseDescriptor.internodeAuthenticator = internodeAuthenticator;</span>
<span class="fc" id="L2711">    }</span>

    public static void setBroadcastAddress(InetAddress broadcastAdd)
    {
<span class="fc" id="L2715">        broadcastAddress = broadcastAdd;</span>
<span class="fc" id="L2716">    }</span>

    /**
     * This is the address used to bind for the native protocol to communicate with clients. Most usages in the code
     * refer to it as native address although some places still call it RPC address. It's not thrift RPC anymore
     * so native is more appropriate. The address alone is not enough to uniquely identify this instance because
     * multiple instances might use the same interface with different ports.
     */
    public static InetAddress getRpcAddress()
    {
<span class="fc" id="L2726">        return rpcAddress;</span>
    }

    public static void setBroadcastRpcAddress(InetAddress broadcastRPCAddr)
    {
<span class="fc" id="L2731">        broadcastRpcAddress = broadcastRPCAddr;</span>
<span class="fc" id="L2732">    }</span>

    /**
     * This is the address used to reach this instance for the native protocol to communicate with clients. Most usages in the code
     * refer to it as native address although some places still call it RPC address. It's not thrift RPC anymore
     * so native is more appropriate. The address alone is not enough to uniquely identify this instance because
     * multiple instances might use the same interface with different ports.
     *
     * May be null, please use {@link FBUtilities#getBroadcastNativeAddressAndPort()} instead.
     */
    public static InetAddress getBroadcastRpcAddress()
    {
<span class="fc" id="L2744">        return broadcastRpcAddress;</span>
    }

    public static boolean getRpcKeepAlive()
    {
<span class="fc" id="L2749">        return conf.rpc_keepalive;</span>
    }

    public static int getInternodeSocketSendBufferSizeInBytes()
    {
<span class="fc" id="L2754">        return conf.internode_socket_send_buffer_size.toBytes();</span>
    }

    public static int getInternodeSocketReceiveBufferSizeInBytes()
    {
<span class="fc" id="L2759">        return conf.internode_socket_receive_buffer_size.toBytes();</span>
    }

    public static int getInternodeApplicationSendQueueCapacityInBytes()
    {
<span class="fc" id="L2764">        return conf.internode_application_send_queue_capacity.toBytes();</span>
    }

    public static int getInternodeApplicationSendQueueReserveEndpointCapacityInBytes()
    {
<span class="fc" id="L2769">        return conf.internode_application_send_queue_reserve_endpoint_capacity.toBytes();</span>
    }

    public static int getInternodeApplicationSendQueueReserveGlobalCapacityInBytes()
    {
<span class="fc" id="L2774">        return conf.internode_application_send_queue_reserve_global_capacity.toBytes();</span>
    }

    public static int getInternodeApplicationReceiveQueueCapacityInBytes()
    {
<span class="fc" id="L2779">        return conf.internode_application_receive_queue_capacity.toBytes();</span>
    }

    public static int getInternodeApplicationReceiveQueueReserveEndpointCapacityInBytes()
    {
<span class="fc" id="L2784">        return conf.internode_application_receive_queue_reserve_endpoint_capacity.toBytes();</span>
    }

    public static int getInternodeApplicationReceiveQueueReserveGlobalCapacityInBytes()
    {
<span class="fc" id="L2789">        return conf.internode_application_receive_queue_reserve_global_capacity.toBytes();</span>
    }

    public static int getInternodeTcpConnectTimeoutInMS()
    {
<span class="fc" id="L2794">        return conf.internode_tcp_connect_timeout.toMilliseconds();</span>
    }

    public static void setInternodeTcpConnectTimeoutInMS(int value)
    {
<span class="nc" id="L2799">        conf.internode_tcp_connect_timeout = new DurationSpec.IntMillisecondsBound(value);</span>
<span class="nc" id="L2800">    }</span>

    public static int getInternodeTcpUserTimeoutInMS()
    {
<span class="fc" id="L2804">        return conf.internode_tcp_user_timeout.toMilliseconds();</span>
    }

    public static void setInternodeTcpUserTimeoutInMS(int value)
    {
<span class="nc" id="L2809">        conf.internode_tcp_user_timeout = new DurationSpec.IntMillisecondsBound(value);</span>
<span class="nc" id="L2810">    }</span>

    public static int getInternodeStreamingTcpUserTimeoutInMS()
    {
<span class="fc" id="L2814">        return conf.internode_streaming_tcp_user_timeout.toMilliseconds();</span>
    }

    public static void setInternodeStreamingTcpUserTimeoutInMS(int value)
    {
<span class="fc" id="L2819">        conf.internode_streaming_tcp_user_timeout = new DurationSpec.IntMillisecondsBound(value);</span>
<span class="fc" id="L2820">    }</span>

    public static int getInternodeMaxMessageSizeInBytes()
    {
<span class="fc" id="L2824">        return conf.internode_max_message_size.toBytes();</span>
    }

    @VisibleForTesting
    public static void setInternodeMaxMessageSizeInBytes(int value)
    {
<span class="fc" id="L2830">        conf.internode_max_message_size = new DataStorageSpec.IntBytesBound(value);</span>
<span class="fc" id="L2831">    }</span>

    public static boolean startNativeTransport()
    {
<span class="fc" id="L2835">        return conf.start_native_transport;</span>
    }

    /**
     *  This is the port used with RPC address for the native protocol to communicate with clients. Now that thrift RPC
     *  is no longer in use there is no RPC port.
     */
    public static int getNativeTransportPort()
    {
<span class="fc" id="L2844">        return NATIVE_TRANSPORT_PORT.getInt(conf.native_transport_port);</span>
    }

    @VisibleForTesting
    public static void setNativeTransportPort(int port)
    {
<span class="nc" id="L2850">        conf.native_transport_port = port;</span>
<span class="nc" id="L2851">    }</span>

    public static int getNativeTransportPortSSL()
    {
<span class="fc bfc" id="L2855" title="All 2 branches covered.">        return conf.native_transport_port_ssl == null ? getNativeTransportPort() : conf.native_transport_port_ssl;</span>
    }

    @VisibleForTesting
    public static void setNativeTransportPortSSL(Integer port)
    {
<span class="fc" id="L2861">        conf.native_transport_port_ssl = port;</span>
<span class="fc" id="L2862">    }</span>

    public static int getNativeTransportMaxThreads()
    {
<span class="fc" id="L2866">        return conf.native_transport_max_threads;</span>
    }

    public static void setNativeTransportMaxThreads(int max_threads)
    {
<span class="nc" id="L2871">        conf.native_transport_max_threads = max_threads;</span>
<span class="nc" id="L2872">    }</span>

    public static Integer getNativeTransportMaxAuthThreads()
    {
<span class="fc" id="L2876">        return conf.native_transport_max_auth_threads;</span>
    }

    /**
     * If this value is set to &lt;= 0 it will move auth requests to the standard request pool regardless of the current
     * size of the {@link org.apache.cassandra.transport.Dispatcher#authExecutor}'s active size.
     *
     * see {@link org.apache.cassandra.transport.Dispatcher#dispatch} for executor selection
     */
    public static void setNativeTransportMaxAuthThreads(int threads)
    {
<span class="fc" id="L2887">        conf.native_transport_max_auth_threads = threads;</span>
<span class="fc" id="L2888">    }</span>

    public static int getNativeTransportMaxFrameSize()
    {
<span class="fc" id="L2892">        return conf.native_transport_max_frame_size.toBytes();</span>
    }

    public static void setNativeTransportMaxFrameSize(int bytes)
    {
<span class="fc" id="L2897">        conf.native_transport_max_frame_size = new DataStorageSpec.IntMebibytesBound(bytes);</span>
<span class="fc" id="L2898">    }</span>

    public static long getNativeTransportMaxConcurrentConnections()
    {
<span class="fc" id="L2902">        return conf.native_transport_max_concurrent_connections;</span>
    }

    public static void setNativeTransportMaxConcurrentConnections(long nativeTransportMaxConcurrentConnections)
    {
<span class="nc" id="L2907">        conf.native_transport_max_concurrent_connections = nativeTransportMaxConcurrentConnections;</span>
<span class="nc" id="L2908">    }</span>

    public static long getNativeTransportMaxConcurrentConnectionsPerIp()
    {
<span class="fc" id="L2912">        return conf.native_transport_max_concurrent_connections_per_ip;</span>
    }

    public static void setNativeTransportMaxConcurrentConnectionsPerIp(long native_transport_max_concurrent_connections_per_ip)
    {
<span class="nc" id="L2917">        conf.native_transport_max_concurrent_connections_per_ip = native_transport_max_concurrent_connections_per_ip;</span>
<span class="nc" id="L2918">    }</span>

    public static boolean useNativeTransportLegacyFlusher()
    {
<span class="fc" id="L2922">        return conf.native_transport_flush_in_batches_legacy;</span>
    }

    public static boolean getNativeTransportAllowOlderProtocols()
    {
<span class="fc" id="L2927">        return conf.native_transport_allow_older_protocols;</span>
    }

    public static void setNativeTransportAllowOlderProtocols(boolean isEnabled)
    {
<span class="fc" id="L2932">        conf.native_transport_allow_older_protocols = isEnabled;</span>
<span class="fc" id="L2933">    }</span>

    public static long getCommitLogSyncGroupWindow()
    {
<span class="fc" id="L2937">        return conf.commitlog_sync_group_window.toMilliseconds();</span>
    }

    public static void setCommitLogSyncGroupWindow(long windowMillis)
    {
<span class="fc" id="L2942">        conf.commitlog_sync_group_window = new DurationSpec.IntMillisecondsBound(windowMillis);</span>
<span class="fc" id="L2943">    }</span>

    public static int getNativeTransportReceiveQueueCapacityInBytes()
    {
<span class="fc" id="L2947">        return conf.native_transport_receive_queue_capacity.toBytes();</span>
    }

    public static void setNativeTransportReceiveQueueCapacityInBytes(int queueSize)
    {
<span class="fc" id="L2952">        conf.native_transport_receive_queue_capacity = new DataStorageSpec.IntBytesBound(queueSize);</span>
<span class="fc" id="L2953">    }</span>

    public static long getNativeTransportMaxRequestDataInFlightPerIpInBytes()
    {
<span class="fc" id="L2957">        return conf.native_transport_max_request_data_in_flight_per_ip.toBytes();</span>
    }

    public static Config.PaxosVariant getPaxosVariant()
    {
<span class="fc" id="L2962">        return conf.paxos_variant;</span>
    }

    public static void setPaxosVariant(Config.PaxosVariant variant)
    {
<span class="fc" id="L2967">        conf.paxos_variant = variant;</span>
<span class="fc" id="L2968">    }</span>

    public static String getPaxosContentionWaitRandomizer()
    {
<span class="fc" id="L2972">        return conf.paxos_contention_wait_randomizer;</span>
    }

    public static String getPaxosContentionMinWait()
    {
<span class="fc" id="L2977">        return conf.paxos_contention_min_wait;</span>
    }

    public static String getPaxosContentionMaxWait()
    {
<span class="fc" id="L2982">        return conf.paxos_contention_max_wait;</span>
    }

    public static String getPaxosContentionMinDelta()
    {
<span class="fc" id="L2987">        return conf.paxos_contention_min_delta;</span>
    }

    public static void setPaxosContentionWaitRandomizer(String waitRandomizer)
    {
<span class="fc" id="L2992">        conf.paxos_contention_wait_randomizer = waitRandomizer;</span>
<span class="fc" id="L2993">    }</span>

    public static void setPaxosContentionMinWait(String minWait)
    {
<span class="fc" id="L2997">        conf.paxos_contention_min_wait = minWait;</span>
<span class="fc" id="L2998">    }</span>

    public static void setPaxosContentionMaxWait(String maxWait)
    {
<span class="fc" id="L3002">        conf.paxos_contention_max_wait = maxWait;</span>
<span class="fc" id="L3003">    }</span>

    public static void setPaxosContentionMinDelta(String minDelta)
    {
<span class="fc" id="L3007">        conf.paxos_contention_min_delta = minDelta;</span>
<span class="fc" id="L3008">    }</span>

    public static boolean skipPaxosRepairOnTopologyChange()
    {
<span class="fc" id="L3012">        return conf.skip_paxos_repair_on_topology_change;</span>
    }

    public static void setSkipPaxosRepairOnTopologyChange(boolean value)
    {
<span class="nc" id="L3017">        conf.skip_paxos_repair_on_topology_change = value;</span>
<span class="nc" id="L3018">    }</span>

    public static long getPaxosPurgeGrace(TimeUnit units)
    {
<span class="fc" id="L3022">        return conf.paxos_purge_grace_period.to(units);</span>
    }

    public static void setPaxosPurgeGrace(long seconds)
    {
<span class="nc" id="L3027">        conf.paxos_purge_grace_period = new DurationSpec.LongSecondsBound(seconds);</span>
<span class="nc" id="L3028">    }</span>

    public static PaxosOnLinearizabilityViolation paxosOnLinearizabilityViolations()
    {
<span class="fc" id="L3032">        return conf.paxos_on_linearizability_violations;</span>
    }

    public static void setPaxosOnLinearizabilityViolations(PaxosOnLinearizabilityViolation v)
    {
<span class="nc" id="L3037">        conf.paxos_on_linearizability_violations = v;</span>
<span class="nc" id="L3038">    }</span>

    public static PaxosStatePurging paxosStatePurging()
    {
<span class="fc" id="L3042">        return conf.paxos_state_purging;</span>
    }

    public static void setPaxosStatePurging(PaxosStatePurging v)
    {
<span class="fc" id="L3047">        conf.paxos_state_purging = v;</span>
<span class="fc" id="L3048">    }</span>

    public static boolean paxosRepairEnabled()
    {
<span class="fc" id="L3052">        return conf.paxos_repair_enabled;</span>
    }

    public static void setPaxosRepairEnabled(boolean v)
    {
<span class="nc" id="L3057">        conf.paxos_repair_enabled = v;</span>
<span class="nc" id="L3058">    }</span>

    public static Set&lt;String&gt; skipPaxosRepairOnTopologyChangeKeyspaces()
    {
<span class="fc" id="L3062">        return conf.skip_paxos_repair_on_topology_change_keyspaces;</span>
    }

    public static void setSkipPaxosRepairOnTopologyChangeKeyspaces(String keyspaces)
    {
<span class="nc" id="L3067">        conf.skip_paxos_repair_on_topology_change_keyspaces = Config.splitCommaDelimited(keyspaces);</span>
<span class="nc" id="L3068">    }</span>

    public static boolean paxoTopologyRepairNoDcChecks()
    {
<span class="fc" id="L3072">        return conf.paxos_topology_repair_no_dc_checks;</span>
    }

    public static boolean paxoTopologyRepairStrictEachQuorum()
    {
<span class="fc" id="L3077">        return conf.paxos_topology_repair_strict_each_quorum;</span>
    }

    public static void setNativeTransportMaxRequestDataInFlightPerIpInBytes(long maxRequestDataInFlightInBytes)
    {
<span class="pc bpc" id="L3082" title="1 of 2 branches missed.">        if (maxRequestDataInFlightInBytes == -1)</span>
<span class="nc" id="L3083">            maxRequestDataInFlightInBytes = Runtime.getRuntime().maxMemory() / 40;</span>

<span class="fc" id="L3085">        conf.native_transport_max_request_data_in_flight_per_ip = new DataStorageSpec.LongBytesBound(maxRequestDataInFlightInBytes);</span>
<span class="fc" id="L3086">    }</span>

    public static long getNativeTransportMaxRequestDataInFlightInBytes()
    {
<span class="fc" id="L3090">        return conf.native_transport_max_request_data_in_flight.toBytes();</span>
    }

    public static void setNativeTransportConcurrentRequestDataInFlightInBytes(long maxRequestDataInFlightInBytes)
    {
<span class="pc bpc" id="L3095" title="1 of 2 branches missed.">        if (maxRequestDataInFlightInBytes == -1)</span>
<span class="nc" id="L3096">            maxRequestDataInFlightInBytes = Runtime.getRuntime().maxMemory() / 10;</span>

<span class="fc" id="L3098">        conf.native_transport_max_request_data_in_flight = new DataStorageSpec.LongBytesBound(maxRequestDataInFlightInBytes);</span>
<span class="fc" id="L3099">    }</span>

    public static int getNativeTransportMaxRequestsPerSecond()
    {
<span class="fc" id="L3103">        return conf.native_transport_max_requests_per_second;</span>
    }

    public static void setNativeTransportMaxRequestsPerSecond(int perSecond)
    {
<span class="pc bpc" id="L3108" title="1 of 2 branches missed.">        Preconditions.checkArgument(perSecond &gt; 0, &quot;native_transport_max_requests_per_second must be greater than zero&quot;);</span>
<span class="fc" id="L3109">        conf.native_transport_max_requests_per_second = perSecond;</span>
<span class="fc" id="L3110">    }</span>

    public static void setNativeTransportRateLimitingEnabled(boolean enabled)
    {
<span class="fc" id="L3114">        logger.info(&quot;native_transport_rate_limiting_enabled set to {}&quot;, enabled);</span>
<span class="fc" id="L3115">        conf.native_transport_rate_limiting_enabled = enabled;</span>
<span class="fc" id="L3116">    }</span>

    public static boolean getNativeTransportRateLimitingEnabled()
    {
<span class="fc" id="L3120">        return conf.native_transport_rate_limiting_enabled;</span>
    }

    public static int getCommitLogSyncPeriod()
    {
<span class="fc" id="L3125">        return conf.commitlog_sync_period.toMilliseconds();</span>
    }

    public static long getPeriodicCommitLogSyncBlock()
    {
<span class="fc" id="L3130">        DurationSpec.IntMillisecondsBound blockMillis = conf.periodic_commitlog_sync_lag_block;</span>
<span class="pc bpc" id="L3131" title="1 of 2 branches missed.">        return blockMillis == null</span>
<span class="fc" id="L3132">               ? (long)(getCommitLogSyncPeriod() * 1.5)</span>
<span class="nc" id="L3133">               : blockMillis.toMilliseconds();</span>
    }

    public static void setCommitLogSyncPeriod(int periodMillis)
    {
<span class="fc" id="L3138">        conf.commitlog_sync_period = new DurationSpec.IntMillisecondsBound(periodMillis);</span>
<span class="fc" id="L3139">    }</span>

    public static Config.CommitLogSync getCommitLogSync()
    {
<span class="fc" id="L3143">        return conf.commitlog_sync;</span>
    }

    public static void setCommitLogSync(CommitLogSync sync)
    {
<span class="fc" id="L3148">        conf.commitlog_sync = sync;</span>
<span class="fc" id="L3149">    }</span>

    public static Config.DiskAccessMode getDiskAccessMode()
    {
<span class="fc" id="L3153">        return conf.disk_access_mode;</span>
    }

    // Do not use outside unit tests.
    @VisibleForTesting
    public static void setDiskAccessMode(Config.DiskAccessMode mode)
    {
<span class="fc" id="L3160">        conf.disk_access_mode = mode;</span>
<span class="fc" id="L3161">    }</span>

    public static Config.DiskAccessMode getIndexAccessMode()
    {
<span class="fc" id="L3165">        return indexAccessMode;</span>
    }

    // Do not use outside unit tests.
    @VisibleForTesting
    public static void setIndexAccessMode(Config.DiskAccessMode mode)
    {
<span class="fc" id="L3172">        indexAccessMode = mode;</span>
<span class="fc" id="L3173">    }</span>

    public static void setDiskFailurePolicy(Config.DiskFailurePolicy policy)
    {
<span class="fc" id="L3177">        conf.disk_failure_policy = policy;</span>
<span class="fc" id="L3178">    }</span>

    public static Config.DiskFailurePolicy getDiskFailurePolicy()
    {
<span class="fc" id="L3182">        return conf.disk_failure_policy;</span>
    }

    public static void setCommitFailurePolicy(Config.CommitFailurePolicy policy)
    {
<span class="fc" id="L3187">        conf.commit_failure_policy = policy;</span>
<span class="fc" id="L3188">    }</span>

    public static Config.CommitFailurePolicy getCommitFailurePolicy()
    {
<span class="fc" id="L3192">        return conf.commit_failure_policy;</span>
    }

    public static boolean isSnapshotBeforeCompaction()
    {
<span class="fc" id="L3197">        return conf.snapshot_before_compaction;</span>
    }

    public static boolean isAutoSnapshot()
    {
<span class="fc" id="L3202">        return conf.auto_snapshot;</span>
    }

    public static DurationSpec.IntSecondsBound getAutoSnapshotTtl()
    {
<span class="fc" id="L3207">        return autoSnapshoTtl;</span>
    }

    @VisibleForTesting
    public static void setAutoSnapshotTtl(DurationSpec.IntSecondsBound newTtl)
    {
<span class="fc" id="L3213">        autoSnapshoTtl = newTtl;</span>
<span class="fc" id="L3214">    }</span>

    @VisibleForTesting
    public static void setAutoSnapshot(boolean autoSnapshot)
    {
<span class="fc" id="L3219">        conf.auto_snapshot = autoSnapshot;</span>
<span class="fc" id="L3220">    }</span>
    @VisibleForTesting
    public static boolean getAutoSnapshot()
    {
<span class="fc" id="L3224">        return conf.auto_snapshot;</span>
    }

    public static long getSnapshotLinksPerSecond()
    {
<span class="pc bpc" id="L3229" title="1 of 2 branches missed.">        return conf.snapshot_links_per_second == 0 ? Long.MAX_VALUE : conf.snapshot_links_per_second;</span>
    }

    public static void setSnapshotLinksPerSecond(long throttle)
    {
<span class="nc bnc" id="L3234" title="All 2 branches missed.">        if (throttle &lt; 0)</span>
<span class="nc" id="L3235">            throw new IllegalArgumentException(&quot;Invalid throttle for snapshot_links_per_second: must be positive&quot;);</span>

<span class="nc" id="L3237">        conf.snapshot_links_per_second = throttle;</span>
<span class="nc" id="L3238">    }</span>

    public static RateLimiter getSnapshotRateLimiter()
    {
<span class="fc" id="L3242">        return RateLimiter.create(getSnapshotLinksPerSecond());</span>
    }

    public static boolean isAutoBootstrap()
    {
<span class="fc" id="L3247">        return AUTO_BOOTSTRAP.getBoolean(conf.auto_bootstrap);</span>
    }

    public static void setHintedHandoffEnabled(boolean hintedHandoffEnabled)
    {
<span class="fc" id="L3252">        conf.hinted_handoff_enabled = hintedHandoffEnabled;</span>
<span class="fc" id="L3253">    }</span>

    public static boolean hintedHandoffEnabled()
    {
<span class="fc" id="L3257">        return conf.hinted_handoff_enabled;</span>
    }

    public static Set&lt;String&gt; hintedHandoffDisabledDCs()
    {
<span class="fc" id="L3262">        return conf.hinted_handoff_disabled_datacenters;</span>
    }

    public static boolean useDeterministicTableID()
    {
<span class="pc bpc" id="L3267" title="1 of 4 branches missed.">        return conf != null &amp;&amp; conf.use_deterministic_table_id;</span>
    }

    public static void useDeterministicTableID(boolean value)
    {
<span class="nc" id="L3272">        conf.use_deterministic_table_id = value;</span>
<span class="nc" id="L3273">    }</span>

    public static void enableHintsForDC(String dc)
    {
<span class="fc" id="L3277">        conf.hinted_handoff_disabled_datacenters.remove(dc);</span>
<span class="fc" id="L3278">    }</span>

    public static void disableHintsForDC(String dc)
    {
<span class="fc" id="L3282">        conf.hinted_handoff_disabled_datacenters.add(dc);</span>
<span class="fc" id="L3283">    }</span>

    public static void setMaxHintWindow(int ms)
    {
<span class="fc" id="L3287">        conf.max_hint_window = new DurationSpec.IntMillisecondsBound(ms);</span>
<span class="fc" id="L3288">    }</span>

    public static int getMaxHintWindow()
    {
<span class="fc" id="L3292">        return conf.max_hint_window.toMilliseconds();</span>
    }

    public static void setMaxHintsSizePerHostInMiB(int value)
    {
<span class="fc" id="L3297">        conf.max_hints_size_per_host = new DataStorageSpec.LongBytesBound(value, MEBIBYTES);</span>
<span class="fc" id="L3298">    }</span>

    public static int getMaxHintsSizePerHostInMiB()
    {
        // Warnings: this conversion rounds down while converting bytes to mebibytes
<span class="fc" id="L3303">        return Ints.saturatedCast(conf.max_hints_size_per_host.unit().toMebibytes(conf.max_hints_size_per_host.quantity()));</span>
    }

    public static long getMaxHintsSizePerHost()
    {
<span class="fc" id="L3308">        return conf.max_hints_size_per_host.toBytes();</span>
    }

    public static File getHintsDirectory()
    {
<span class="fc" id="L3313">        return new File(conf.hints_directory);</span>
    }

    public static boolean hintWindowPersistentEnabled()
    {
<span class="fc" id="L3318">        return conf.hint_window_persistent_enabled;</span>
    }

    public static File getSerializedCachePath(CacheType cacheType, String version, String extension)
    {
<span class="fc" id="L3323">        String name = cacheType.toString()</span>
<span class="pc bpc" id="L3324" title="1 of 2 branches missed.">                + (version == null ? &quot;&quot; : '-' + version + '.' + extension);</span>
<span class="fc" id="L3325">        return new File(conf.saved_caches_directory, name);</span>
    }

    public static int getDynamicUpdateInterval()
    {
<span class="fc" id="L3330">        return conf.dynamic_snitch_update_interval.toMilliseconds();</span>
    }
    public static void setDynamicUpdateInterval(int dynamicUpdateInterval)
    {
<span class="nc" id="L3334">        conf.dynamic_snitch_update_interval = new DurationSpec.IntMillisecondsBound(dynamicUpdateInterval);</span>
<span class="nc" id="L3335">    }</span>

    public static int getDynamicResetInterval()
    {
<span class="fc" id="L3339">        return conf.dynamic_snitch_reset_interval.toMilliseconds();</span>
    }
    public static void setDynamicResetInterval(int dynamicResetInterval)
    {
<span class="nc" id="L3343">        conf.dynamic_snitch_reset_interval = new DurationSpec.IntMillisecondsBound(dynamicResetInterval);</span>
<span class="nc" id="L3344">    }</span>

    public static double getDynamicBadnessThreshold()
    {
<span class="fc" id="L3348">        return conf.dynamic_snitch_badness_threshold;</span>
    }

    public static void setDynamicBadnessThreshold(double dynamicBadnessThreshold)
    {
<span class="fc" id="L3353">        conf.dynamic_snitch_badness_threshold = dynamicBadnessThreshold;</span>
<span class="fc" id="L3354">    }</span>

    public static EncryptionOptions.ServerEncryptionOptions getInternodeMessagingEncyptionOptions()
    {
<span class="fc" id="L3358">        return conf.server_encryption_options;</span>
    }

    public static void setInternodeMessagingEncyptionOptions(EncryptionOptions.ServerEncryptionOptions encryptionOptions)
    {
<span class="fc" id="L3363">        conf.server_encryption_options = encryptionOptions;</span>
<span class="fc" id="L3364">    }</span>

    public static EncryptionOptions getNativeProtocolEncryptionOptions()
    {
<span class="fc" id="L3368">        return conf.client_encryption_options;</span>
    }

    @VisibleForTesting
    public static void updateNativeProtocolEncryptionOptions(Function&lt;EncryptionOptions, EncryptionOptions&gt; update)
    {
<span class="fc" id="L3374">        conf.client_encryption_options = update.apply(conf.client_encryption_options);</span>
<span class="fc" id="L3375">    }</span>

    public static int getHintedHandoffThrottleInKiB()
    {
<span class="fc" id="L3379">        return conf.hinted_handoff_throttle.toKibibytes();</span>
    }

    public static void setHintedHandoffThrottleInKiB(int throttleInKiB)
    {
<span class="fc" id="L3384">        conf.hinted_handoff_throttle = new DataStorageSpec.IntKibibytesBound(throttleInKiB);</span>
<span class="fc" id="L3385">    }</span>

    public static int getBatchlogReplayThrottleInKiB()
    {
<span class="fc" id="L3389">        return conf.batchlog_replay_throttle.toKibibytes();</span>
    }

    public static void setBatchlogReplayThrottleInKiB(int throttleInKiB)
    {
<span class="fc" id="L3394">        conf.batchlog_replay_throttle = new DataStorageSpec.IntKibibytesBound(throttleInKiB);</span>
<span class="fc" id="L3395">    }</span>

    public static int getMaxHintsDeliveryThreads()
    {
<span class="fc" id="L3399">        return conf.max_hints_delivery_threads;</span>
    }

    public static int getHintsFlushPeriodInMS()
    {
<span class="fc" id="L3404">        return conf.hints_flush_period.toMilliseconds();</span>
    }

    public static long getMaxHintsFileSize()
    {
<span class="fc" id="L3409">        return  conf.max_hints_file_size.toBytesInLong();</span>
    }

    public static ParameterizedClass getHintsCompression()
    {
<span class="fc" id="L3414">        return conf.hints_compression;</span>
    }

    public static void setHintsCompression(ParameterizedClass parameterizedClass)
    {
<span class="nc" id="L3419">        conf.hints_compression = parameterizedClass;</span>
<span class="nc" id="L3420">    }</span>

    public static boolean isAutoHintsCleanupEnabled()
    {
<span class="nc" id="L3424">        return conf.auto_hints_cleanup_enabled;</span>
    }

    public static void setAutoHintsCleanupEnabled(boolean value)
    {
<span class="nc" id="L3429">        conf.auto_hints_cleanup_enabled = value;</span>
<span class="nc" id="L3430">    }</span>

    public static boolean getTransferHintsOnDecommission()
    {
<span class="fc" id="L3434">        return conf.transfer_hints_on_decommission;</span>
    }

    public static void setTransferHintsOnDecommission(boolean enabled)
    {
<span class="nc" id="L3439">        conf.transfer_hints_on_decommission = enabled;</span>
<span class="nc" id="L3440">    }</span>

    public static boolean isIncrementalBackupsEnabled()
    {
<span class="fc" id="L3444">        return conf.incremental_backups;</span>
    }

    public static void setIncrementalBackupsEnabled(boolean value)
    {
<span class="fc" id="L3449">        conf.incremental_backups = value;</span>
<span class="fc" id="L3450">    }</span>

    public static boolean getFileCacheEnabled()
    {
<span class="fc" id="L3454">        return conf.file_cache_enabled;</span>
    }

    @VisibleForTesting
    public static void setFileCacheEnabled(boolean enabled)
    {
<span class="fc" id="L3460">        conf.file_cache_enabled = enabled;</span>
<span class="fc" id="L3461">    }</span>

    public static int getFileCacheSizeInMiB()
    {
<span class="fc bfc" id="L3465" title="All 2 branches covered.">        if (conf.file_cache_size == null)</span>
        {
            // In client mode the value is not set.
<span class="pc bpc" id="L3468" title="1 of 2 branches missed.">            assert DatabaseDescriptor.isClientInitialized();</span>
<span class="fc" id="L3469">            return 0;</span>
        }

<span class="fc" id="L3472">        return conf.file_cache_size.toMebibytes();</span>
    }

    public static int getNetworkingCacheSizeInMiB()
    {
<span class="fc bfc" id="L3477" title="All 2 branches covered.">        if (conf.networking_cache_size == null)</span>
        {
            // In client mode the value is not set.
<span class="pc bpc" id="L3480" title="1 of 2 branches missed.">            assert DatabaseDescriptor.isClientInitialized();</span>
<span class="fc" id="L3481">            return 0;</span>
        }
<span class="fc" id="L3483">        return conf.networking_cache_size.toMebibytes();</span>
    }

    public static boolean getFileCacheRoundUp()
    {
<span class="fc bfc" id="L3488" title="All 2 branches covered.">        if (conf.file_cache_round_up == null)</span>
        {
            // In client mode the value is not set.
<span class="pc bpc" id="L3491" title="1 of 2 branches missed.">            assert DatabaseDescriptor.isClientInitialized();</span>
<span class="fc" id="L3492">            return false;</span>
        }

<span class="fc" id="L3495">        return conf.file_cache_round_up;</span>
    }

    public static DiskOptimizationStrategy getDiskOptimizationStrategy()
    {
<span class="fc" id="L3500">        return diskOptimizationStrategy;</span>
    }

    public static double getDiskOptimizationEstimatePercentile()
    {
<span class="fc" id="L3505">        return conf.disk_optimization_estimate_percentile;</span>
    }

    public static long getTotalCommitlogSpaceInMiB()
    {
<span class="fc" id="L3510">        return conf.commitlog_total_space.toMebibytes();</span>
    }

    public static boolean shouldMigrateKeycacheOnCompaction()
    {
<span class="fc" id="L3515">        return conf.key_cache_migrate_during_compaction;</span>
    }

    public static void setMigrateKeycacheOnCompaction(boolean migrateCacheEntry)
    {
<span class="nc" id="L3520">        conf.key_cache_migrate_during_compaction = migrateCacheEntry;</span>
<span class="nc" id="L3521">    }</span>

    /** This method can return negative number for disabled */
    public static int getSSTablePreemptiveOpenIntervalInMiB()
    {
<span class="fc bfc" id="L3526" title="All 2 branches covered.">        if (conf.sstable_preemptive_open_interval == null)</span>
<span class="fc" id="L3527">            return -1;</span>
<span class="fc" id="L3528">        return conf.sstable_preemptive_open_interval.toMebibytes();</span>
    }

    /** Negative number for disabled */
    public static void setSSTablePreemptiveOpenIntervalInMiB(int mib)
    {
<span class="fc bfc" id="L3534" title="All 2 branches covered.">        if (mib &lt; 0)</span>
<span class="fc" id="L3535">            conf.sstable_preemptive_open_interval = null;</span>
        else
<span class="fc" id="L3537">            conf.sstable_preemptive_open_interval = new DataStorageSpec.IntMebibytesBound(mib);</span>
<span class="fc" id="L3538">    }</span>

    public static boolean getTrickleFsync()
    {
<span class="fc" id="L3542">        return conf.trickle_fsync;</span>
    }

    public static int getTrickleFsyncIntervalInKiB()
    {
<span class="fc" id="L3547">        return conf.trickle_fsync_interval.toKibibytes();</span>
    }

    public static long getKeyCacheSizeInMiB()
    {
<span class="fc" id="L3552">        return keyCacheSizeInMiB;</span>
    }

    public static long getIndexSummaryCapacityInMiB()
    {
<span class="fc" id="L3557">        return indexSummaryCapacityInMiB;</span>
    }

    public static int getKeyCacheSavePeriod()
    {
<span class="fc" id="L3562">        return conf.key_cache_save_period.toSeconds();</span>
    }

    public static void setKeyCacheSavePeriod(int keyCacheSavePeriod)
    {
<span class="nc" id="L3567">        conf.key_cache_save_period = new DurationSpec.IntSecondsBound(keyCacheSavePeriod);</span>
<span class="nc" id="L3568">    }</span>

    public static int getKeyCacheKeysToSave()
    {
<span class="fc" id="L3572">        return conf.key_cache_keys_to_save;</span>
    }

    public static void setKeyCacheKeysToSave(int keyCacheKeysToSave)
    {
<span class="nc" id="L3577">        conf.key_cache_keys_to_save = keyCacheKeysToSave;</span>
<span class="nc" id="L3578">    }</span>

    public static String getRowCacheClassName()
    {
<span class="fc" id="L3582">        return conf.row_cache_class_name;</span>
    }

    public static long getRowCacheSizeInMiB()
    {
<span class="fc" id="L3587">        return conf.row_cache_size.toMebibytes();</span>
    }

    @VisibleForTesting
    public static void setRowCacheSizeInMiB(long val)
    {
<span class="nc" id="L3593">        conf.row_cache_size = new DataStorageSpec.LongMebibytesBound(val);</span>
<span class="nc" id="L3594">    }</span>

    public static int getRowCacheSavePeriod()
    {
<span class="fc" id="L3598">        return conf.row_cache_save_period.toSeconds();</span>
    }

    public static void setRowCacheSavePeriod(int rowCacheSavePeriod)
    {
<span class="nc" id="L3603">        conf.row_cache_save_period = new DurationSpec.IntSecondsBound(rowCacheSavePeriod);</span>
<span class="nc" id="L3604">    }</span>

    public static int getRowCacheKeysToSave()
    {
<span class="fc" id="L3608">        return conf.row_cache_keys_to_save;</span>
    }

    public static long getPaxosCacheSizeInMiB()
    {
<span class="fc" id="L3613">        return paxosCacheSizeInMiB;</span>
    }

    public static long getCounterCacheSizeInMiB()
    {
<span class="fc" id="L3618">        return counterCacheSizeInMiB;</span>
    }

    public static void setRowCacheKeysToSave(int rowCacheKeysToSave)
    {
<span class="nc" id="L3623">        conf.row_cache_keys_to_save = rowCacheKeysToSave;</span>
<span class="nc" id="L3624">    }</span>

    public static int getCounterCacheSavePeriod()
    {
<span class="fc" id="L3628">        return conf.counter_cache_save_period.toSeconds();</span>
    }

    public static void setCounterCacheSavePeriod(int counterCacheSavePeriod)
    {
<span class="nc" id="L3633">        conf.counter_cache_save_period = new DurationSpec.IntSecondsBound(counterCacheSavePeriod);</span>
<span class="nc" id="L3634">    }</span>

    public static int getCacheLoadTimeout()
    {
<span class="fc" id="L3638">        return conf.cache_load_timeout.toSeconds();</span>
    }

    @VisibleForTesting
    public static void setCacheLoadTimeout(int seconds)
    {
<span class="fc" id="L3644">        conf.cache_load_timeout = new DurationSpec.IntSecondsBound(seconds);</span>
<span class="fc" id="L3645">    }</span>

    public static int getCounterCacheKeysToSave()
    {
<span class="fc" id="L3649">        return conf.counter_cache_keys_to_save;</span>
    }

    public static void setCounterCacheKeysToSave(int counterCacheKeysToSave)
    {
<span class="nc" id="L3654">        conf.counter_cache_keys_to_save = counterCacheKeysToSave;</span>
<span class="nc" id="L3655">    }</span>

    public static int getStreamingKeepAlivePeriod()
    {
<span class="fc" id="L3659">        return conf.streaming_keep_alive_period.toSeconds();</span>
    }

    public static int getStreamingConnectionsPerHost()
    {
<span class="fc" id="L3664">        return conf.streaming_connections_per_host;</span>
    }

    public static boolean streamEntireSSTables()
    {
<span class="fc" id="L3669">        return conf.stream_entire_sstables;</span>
    }

    @VisibleForTesting
    public static boolean setStreamEntireSSTables(boolean value)
    {
<span class="fc" id="L3675">        return conf.stream_entire_sstables = value;</span>
    }

    public static DurationSpec.LongMillisecondsBound getStreamTransferTaskTimeout()
    {
<span class="fc" id="L3680">        return conf.stream_transfer_task_timeout;</span>
    }

    public static boolean getSkipStreamDiskSpaceCheck()
    {
<span class="fc" id="L3685">        return conf.skip_stream_disk_space_check;</span>
    }

    public static void setSkipStreamDiskSpaceCheck(boolean value)
    {
<span class="nc" id="L3690">        conf.skip_stream_disk_space_check = value;</span>
<span class="nc" id="L3691">    }</span>

    public static String getLocalDataCenter()
    {
<span class="fc" id="L3695">        return localDC;</span>
    }

    @VisibleForTesting
    public static void setLocalDataCenter(String value)
    {
<span class="fc" id="L3701">        localDC = value;</span>
<span class="fc" id="L3702">    }</span>

    public static Comparator&lt;Replica&gt; getLocalComparator()
    {
<span class="nc" id="L3706">        return localComparator;</span>
    }

    public static Config.InternodeCompression internodeCompression()
    {
<span class="fc" id="L3711">        return conf.internode_compression;</span>
    }

    public static void setInternodeCompression(Config.InternodeCompression compression)
    {
<span class="fc" id="L3716">        conf.internode_compression = compression;</span>
<span class="fc" id="L3717">    }</span>

    public static boolean getInterDCTcpNoDelay()
    {
<span class="fc" id="L3721">        return conf.inter_dc_tcp_nodelay;</span>
    }

    public static long getMemtableHeapSpaceInMiB()
    {
<span class="fc" id="L3726">        return conf.memtable_heap_space.toMebibytes();</span>
    }

    public static long getMemtableOffheapSpaceInMiB()
    {
<span class="fc" id="L3731">        return conf.memtable_offheap_space.toMebibytes();</span>
    }

    public static Config.MemtableAllocationType getMemtableAllocationType()
    {
<span class="fc" id="L3736">        return conf.memtable_allocation_type;</span>
    }

    public static int getRepairSessionMaxTreeDepth()
    {
<span class="fc" id="L3741">        return conf.repair_session_max_tree_depth;</span>
    }

    public static void setRepairSessionMaxTreeDepth(int depth)
    {
<span class="fc bfc" id="L3746" title="All 2 branches covered.">        if (depth &lt; 10)</span>
<span class="fc" id="L3747">            throw new ConfigurationException(&quot;Cannot set repair_session_max_tree_depth to &quot; + depth +</span>
                                             &quot; which is &lt; 10, doing nothing&quot;);
<span class="fc bfc" id="L3749" title="All 2 branches covered.">        else if (depth &gt; 20)</span>
<span class="fc" id="L3750">            logger.warn(&quot;repair_session_max_tree_depth of &quot; + depth + &quot; &gt; 20 could lead to excessive memory usage&quot;);</span>

<span class="fc" id="L3752">        conf.repair_session_max_tree_depth = depth;</span>
<span class="fc" id="L3753">    }</span>

    public static int getRepairSessionSpaceInMiB()
    {
<span class="fc" id="L3757">        return conf.repair_session_space.toMebibytes();</span>
    }

    public static void setRepairSessionSpaceInMiB(int sizeInMiB)
    {
<span class="fc bfc" id="L3762" title="All 2 branches covered.">        if (sizeInMiB &lt; 1)</span>
<span class="fc" id="L3763">            throw new ConfigurationException(&quot;Cannot set repair_session_space to &quot; + sizeInMiB +</span>
                                             &quot; &lt; 1 mebibyte&quot;);
<span class="fc bfc" id="L3765" title="All 2 branches covered.">        else if (sizeInMiB &gt; (int) (Runtime.getRuntime().maxMemory() / (4 * 1048576)))</span>
<span class="fc" id="L3766">            logger.warn(&quot;A repair_session_space of &quot; + conf.repair_session_space +</span>
                        &quot; is likely to cause heap pressure.&quot;);

<span class="fc" id="L3769">        conf.repair_session_space = new DataStorageSpec.IntMebibytesBound(sizeInMiB);</span>
<span class="fc" id="L3770">    }</span>

    public static int getPaxosRepairParallelism()
    {
<span class="fc" id="L3774">        return conf.paxos_repair_parallelism;</span>
    }

    public static void setPaxosRepairParallelism(int v)
    {
<span class="nc bnc" id="L3779" title="All 2 branches missed.">        Preconditions.checkArgument(v &gt; 0);</span>
<span class="nc" id="L3780">        conf.paxos_repair_parallelism = v;</span>
<span class="nc" id="L3781">    }</span>

    public static Float getMemtableCleanupThreshold()
    {
<span class="fc" id="L3785">        return conf.memtable_cleanup_threshold;</span>
    }

    public static Map&lt;String, InheritingClass&gt; getMemtableConfigurations()
    {
<span class="fc bfc" id="L3790" title="All 4 branches covered.">        if (conf == null || conf.memtable == null)</span>
<span class="fc" id="L3791">            return null;</span>
<span class="fc" id="L3792">        return conf.memtable.configurations;</span>
    }

    public static int getIndexSummaryResizeIntervalInMinutes()
    {
<span class="fc bfc" id="L3797" title="All 2 branches covered.">        if (conf.index_summary_resize_interval == null)</span>
<span class="fc" id="L3798">            return -1;</span>

<span class="fc" id="L3800">        return conf.index_summary_resize_interval.toMinutes();</span>
    }

    public static void setIndexSummaryResizeIntervalInMinutes(int value)
    {
<span class="fc bfc" id="L3805" title="All 2 branches covered.">        if (value == -1)</span>
<span class="fc" id="L3806">            conf.index_summary_resize_interval = null;</span>
        else
<span class="fc" id="L3808">            conf.index_summary_resize_interval = new DurationSpec.IntMinutesBound(value);</span>
<span class="fc" id="L3809">    }</span>

    public static boolean hasLargeAddressSpace()
    {
        // currently we just check if it's a 64bit arch, but any we only really care if the address space is large
<span class="fc" id="L3814">        String datamodel = SUN_ARCH_DATA_MODEL.getString();</span>
<span class="pc bpc" id="L3815" title="1 of 2 branches missed.">        if (datamodel != null)</span>
        {
<span class="pc bpc" id="L3817" title="2 of 3 branches missed.">            switch (datamodel)</span>
            {
<span class="fc" id="L3819">                case &quot;64&quot;: return true;</span>
<span class="nc" id="L3820">                case &quot;32&quot;: return false;</span>
            }
        }
<span class="nc" id="L3823">        String arch = OS_ARCH.getString();</span>
<span class="nc bnc" id="L3824" title="All 4 branches missed.">        return arch.contains(&quot;64&quot;) || arch.contains(&quot;sparcv9&quot;);</span>
    }

    public static int getTracetypeRepairTTL()
    {
<span class="fc" id="L3829">        return conf.trace_type_repair_ttl.toSeconds();</span>
    }

    public static int getTracetypeQueryTTL()
    {
<span class="fc" id="L3834">        return conf.trace_type_query_ttl.toSeconds();</span>
    }

    public static long getPreparedStatementsCacheSizeMiB()
    {
<span class="fc" id="L3839">        return preparedStatementsCacheSizeInMiB;</span>
    }

    public static boolean enableUserDefinedFunctions()
    {
<span class="fc" id="L3844">        return conf.user_defined_functions_enabled;</span>
    }

    public static boolean enableScriptedUserDefinedFunctions()
    {
<span class="nc" id="L3849">        return conf.scripted_user_defined_functions_enabled;</span>
    }

    public static boolean enableUserDefinedFunctionsThreads()
    {
<span class="fc" id="L3854">        return conf.user_defined_functions_threads_enabled;</span>
    }

    public static long getUserDefinedFunctionWarnTimeout()
    {
<span class="fc" id="L3859">        return conf.user_defined_functions_warn_timeout.toMilliseconds();</span>
    }

    public static void setUserDefinedFunctionWarnTimeout(long userDefinedFunctionWarnTimeout)
    {
<span class="fc" id="L3864">        conf.user_defined_functions_warn_timeout = new DurationSpec.LongMillisecondsBound(userDefinedFunctionWarnTimeout);</span>
<span class="fc" id="L3865">    }</span>

    public static boolean allowInsecureUDFs()
    {
<span class="nc" id="L3869">        return conf.allow_insecure_udfs;</span>
    }

    public static boolean allowExtraInsecureUDFs()
    {
<span class="nc" id="L3874">        return conf.allow_extra_insecure_udfs;</span>
    }

    public static boolean getMaterializedViewsEnabled()
    {
<span class="fc" id="L3879">        return conf.materialized_views_enabled;</span>
    }

    public static void setMaterializedViewsEnabled(boolean enableMaterializedViews)
    {
<span class="fc" id="L3884">        conf.materialized_views_enabled = enableMaterializedViews;</span>
<span class="fc" id="L3885">    }</span>

    public static boolean getSASIIndexesEnabled()
    {
<span class="fc" id="L3889">        return conf.sasi_indexes_enabled;</span>
    }

    public static void setSASIIndexesEnabled(boolean enableSASIIndexes)
    {
<span class="fc" id="L3894">        conf.sasi_indexes_enabled = enableSASIIndexes;</span>
<span class="fc" id="L3895">    }</span>

    public static String getDefaultSecondaryIndex()
    {
<span class="fc" id="L3899">        return conf.default_secondary_index;</span>
    }

    public static void setDefaultSecondaryIndex(String name)
    {
<span class="fc" id="L3904">        conf.default_secondary_index = name;</span>
<span class="fc" id="L3905">    }</span>

    public static boolean getDefaultSecondaryIndexEnabled()
    {
<span class="fc" id="L3909">        return conf.default_secondary_index_enabled;</span>
    }

    public static void setDefaultSecondaryIndexEnabled(boolean enabled)
    {
<span class="fc" id="L3914">        conf.default_secondary_index_enabled = enabled;</span>
<span class="fc" id="L3915">    }</span>

    public static boolean isTransientReplicationEnabled()
    {
<span class="fc" id="L3919">        return conf.transient_replication_enabled;</span>
    }

    public static void setTransientReplicationEnabledUnsafe(boolean enabled)
    {
<span class="fc" id="L3924">        conf.transient_replication_enabled = enabled;</span>
<span class="fc" id="L3925">    }</span>

    public static boolean enableDropCompactStorage()
    {
<span class="fc" id="L3929">        return conf.drop_compact_storage_enabled;</span>
    }

    @VisibleForTesting
    public static void setEnableDropCompactStorage(boolean enableDropCompactStorage)
    {
<span class="fc" id="L3935">        conf.drop_compact_storage_enabled = enableDropCompactStorage;</span>
<span class="fc" id="L3936">    }</span>

    public static long getUserDefinedFunctionFailTimeout()
    {
<span class="fc" id="L3940">        return conf.user_defined_functions_fail_timeout.toMilliseconds();</span>
    }

    public static void setUserDefinedFunctionFailTimeout(long userDefinedFunctionFailTimeout)
    {
<span class="fc" id="L3945">        conf.user_defined_functions_fail_timeout = new DurationSpec.LongMillisecondsBound(userDefinedFunctionFailTimeout);</span>
<span class="fc" id="L3946">    }</span>

    public static Config.UserFunctionTimeoutPolicy getUserFunctionTimeoutPolicy()
    {
<span class="fc" id="L3950">        return conf.user_function_timeout_policy;</span>
    }

    public static void setUserFunctionTimeoutPolicy(Config.UserFunctionTimeoutPolicy userFunctionTimeoutPolicy)
    {
<span class="fc" id="L3955">        conf.user_function_timeout_policy = userFunctionTimeoutPolicy;</span>
<span class="fc" id="L3956">    }</span>

    public static long getGCLogThreshold()
    {
<span class="fc" id="L3960">        return conf.gc_log_threshold.toMilliseconds();</span>
    }

    public static void setGCLogThreshold(int gcLogThreshold)
    {
<span class="fc" id="L3965">        conf.gc_log_threshold = new DurationSpec.IntMillisecondsBound(gcLogThreshold);</span>
<span class="fc" id="L3966">    }</span>

    public static EncryptionContext getEncryptionContext()
    {
<span class="fc" id="L3970">        return encryptionContext;</span>
    }

    public static long getGCWarnThreshold()
    {
<span class="fc" id="L3975">        return conf.gc_warn_threshold.toMilliseconds();</span>
    }

    public static void setGCWarnThreshold(int threshold)
    {
<span class="fc" id="L3980">        conf.gc_warn_threshold = new DurationSpec.IntMillisecondsBound(threshold);</span>
<span class="fc" id="L3981">    }</span>

    public static boolean isCDCEnabled()
    {
<span class="fc" id="L3985">        return conf.cdc_enabled;</span>
    }

    @VisibleForTesting
    public static void setCDCEnabled(boolean cdc_enabled)
    {
<span class="fc" id="L3991">        conf.cdc_enabled = cdc_enabled;</span>
<span class="fc" id="L3992">    }</span>

    public static boolean getCDCBlockWrites()
    {
<span class="fc" id="L3996">        return conf.cdc_block_writes;</span>
    }

    public static void setCDCBlockWrites(boolean val)
    {
<span class="fc" id="L4001">        conf.cdc_block_writes = val;</span>
<span class="fc" id="L4002">    }</span>

    public static boolean isCDCOnRepairEnabled()
    {
<span class="fc" id="L4006">        return conf.cdc_on_repair_enabled;</span>
    }

    public static void setCDCOnRepairEnabled(boolean val)
    {
<span class="nc" id="L4011">        conf.cdc_on_repair_enabled = val;</span>
<span class="nc" id="L4012">    }</span>

    public static String getCDCLogLocation()
    {
<span class="fc" id="L4016">        return conf.cdc_raw_directory;</span>
    }

    public static long getCDCTotalSpace()
    {
<span class="fc" id="L4021">        return conf.cdc_total_space.toBytesInLong();</span>
    }

    @VisibleForTesting
    public static void setCDCTotalSpaceInMiB(int mibs)
    {
<span class="fc" id="L4027">        conf.cdc_total_space = new DataStorageSpec.IntMebibytesBound(mibs);</span>
<span class="fc" id="L4028">    }</span>

    public static int getCDCDiskCheckInterval()
    {
<span class="fc" id="L4032">        return conf.cdc_free_space_check_interval.toMilliseconds();</span>
    }

    @VisibleForTesting
    public static void setEncryptionContext(EncryptionContext ec)
    {
<span class="fc" id="L4038">        encryptionContext = ec;</span>
<span class="fc" id="L4039">    }</span>

    public static int searchConcurrencyFactor()
    {
<span class="fc" id="L4043">        return searchConcurrencyFactor;</span>
    }

    public static boolean isUnsafeSystem()
    {
<span class="fc" id="L4048">        return unsafeSystem;</span>
    }

    public static boolean diagnosticEventsEnabled()
    {
<span class="fc" id="L4053">        return conf.diagnostic_events_enabled;</span>
    }

    public static void setDiagnosticEventsEnabled(boolean enabled)
    {
<span class="fc" id="L4058">        conf.diagnostic_events_enabled = enabled;</span>
<span class="fc" id="L4059">    }</span>

    public static ConsistencyLevel getIdealConsistencyLevel()
    {
<span class="fc" id="L4063">        return conf.ideal_consistency_level;</span>
    }

    public static void setIdealConsistencyLevel(ConsistencyLevel cl)
    {
<span class="nc" id="L4068">        conf.ideal_consistency_level = cl;</span>
<span class="nc" id="L4069">    }</span>

    public static int getRepairCommandPoolSize()
    {
<span class="fc" id="L4073">        return conf.repair_command_pool_size;</span>
    }

    public static Config.RepairCommandPoolFullStrategy getRepairCommandPoolFullStrategy()
    {
<span class="fc" id="L4078">        return conf.repair_command_pool_full_strategy;</span>
    }

    public static FullQueryLoggerOptions getFullQueryLogOptions()
    {
<span class="fc" id="L4083">        return  conf.full_query_logging_options;</span>
    }

    public static void setFullQueryLogOptions(FullQueryLoggerOptions options)
    {
<span class="fc" id="L4088">        conf.full_query_logging_options = options;</span>
<span class="fc" id="L4089">    }</span>

    public static boolean getBlockForPeersInRemoteDatacenters()
    {
<span class="fc" id="L4093">        return conf.block_for_peers_in_remote_dcs;</span>
    }

    public static int getBlockForPeersTimeoutInSeconds()
    {
<span class="fc" id="L4098">        return conf.block_for_peers_timeout_in_secs;</span>
    }

    public static boolean automaticSSTableUpgrade()
    {
<span class="fc" id="L4103">        return conf.automatic_sstable_upgrade;</span>
    }

    public static void setAutomaticSSTableUpgradeEnabled(boolean enabled)
    {
<span class="pc bpc" id="L4108" title="1 of 2 branches missed.">        if (conf.automatic_sstable_upgrade != enabled)</span>
<span class="fc" id="L4109">            logger.debug(&quot;Changing automatic_sstable_upgrade to {}&quot;, enabled);</span>
<span class="fc" id="L4110">        conf.automatic_sstable_upgrade = enabled;</span>
<span class="fc" id="L4111">    }</span>

    public static int maxConcurrentAutoUpgradeTasks()
    {
<span class="fc" id="L4115">        return conf.max_concurrent_automatic_sstable_upgrades;</span>
    }

    public static void setMaxConcurrentAutoUpgradeTasks(int value)
    {
<span class="fc bfc" id="L4120" title="All 2 branches covered.">        if (conf.max_concurrent_automatic_sstable_upgrades != value)</span>
<span class="fc" id="L4121">            logger.debug(&quot;Changing max_concurrent_automatic_sstable_upgrades to {}&quot;, value);</span>
<span class="fc" id="L4122">        validateMaxConcurrentAutoUpgradeTasksConf(value);</span>
<span class="fc" id="L4123">        conf.max_concurrent_automatic_sstable_upgrades = value;</span>
<span class="fc" id="L4124">    }</span>

    private static void validateMaxConcurrentAutoUpgradeTasksConf(int value)
    {
<span class="pc bpc" id="L4128" title="1 of 2 branches missed.">        if (value &lt; 0)</span>
<span class="nc" id="L4129">            throw new ConfigurationException(&quot;max_concurrent_automatic_sstable_upgrades can't be negative&quot;);</span>
<span class="pc bpc" id="L4130" title="1 of 2 branches missed.">        if (value &gt; getConcurrentCompactors())</span>
<span class="nc" id="L4131">            logger.warn(&quot;max_concurrent_automatic_sstable_upgrades ({}) is larger than concurrent_compactors ({})&quot;, value, getConcurrentCompactors());</span>
<span class="fc" id="L4132">    }</span>

    public static AuditLogOptions getAuditLoggingOptions()
    {
<span class="fc" id="L4136">        return conf.audit_logging_options;</span>
    }

    public static void setAuditLoggingOptions(AuditLogOptions auditLoggingOptions)
    {
<span class="fc" id="L4141">        conf.audit_logging_options = new AuditLogOptions.Builder(auditLoggingOptions).build();</span>
<span class="fc" id="L4142">    }</span>

    public static Config.CorruptedTombstoneStrategy getCorruptedTombstoneStrategy()
    {
<span class="fc" id="L4146">        return conf.corrupted_tombstone_strategy;</span>
    }

    public static void setCorruptedTombstoneStrategy(Config.CorruptedTombstoneStrategy strategy)
    {
<span class="fc" id="L4151">        conf.corrupted_tombstone_strategy = strategy;</span>
<span class="fc" id="L4152">    }</span>

    public static boolean getRepairedDataTrackingForRangeReadsEnabled()
    {
<span class="fc" id="L4156">        return conf.repaired_data_tracking_for_range_reads_enabled;</span>
    }

    public static void setRepairedDataTrackingForRangeReadsEnabled(boolean enabled)
    {
<span class="fc" id="L4161">        conf.repaired_data_tracking_for_range_reads_enabled = enabled;</span>
<span class="fc" id="L4162">    }</span>

    public static boolean getRepairedDataTrackingForPartitionReadsEnabled()
    {
<span class="fc" id="L4166">        return conf.repaired_data_tracking_for_partition_reads_enabled;</span>
    }

    public static void setRepairedDataTrackingForPartitionReadsEnabled(boolean enabled)
    {
<span class="fc" id="L4171">        conf.repaired_data_tracking_for_partition_reads_enabled = enabled;</span>
<span class="fc" id="L4172">    }</span>

    public static boolean snapshotOnRepairedDataMismatch()
    {
<span class="fc" id="L4176">        return conf.snapshot_on_repaired_data_mismatch;</span>
    }

    public static void setSnapshotOnRepairedDataMismatch(boolean enabled)
    {
<span class="fc" id="L4181">        conf.snapshot_on_repaired_data_mismatch = enabled;</span>
<span class="fc" id="L4182">    }</span>

    public static boolean snapshotOnDuplicateRowDetection()
    {
<span class="fc" id="L4186">        return conf.snapshot_on_duplicate_row_detection;</span>
    }

    public static void setSnapshotOnDuplicateRowDetection(boolean enabled)
    {
<span class="fc" id="L4191">        conf.snapshot_on_duplicate_row_detection = enabled;</span>
<span class="fc" id="L4192">    }</span>

    public static boolean reportUnconfirmedRepairedDataMismatches()
    {
<span class="fc" id="L4196">        return conf.report_unconfirmed_repaired_data_mismatches;</span>
    }

    public static void reportUnconfirmedRepairedDataMismatches(boolean enabled)
    {
<span class="fc" id="L4201">        conf.report_unconfirmed_repaired_data_mismatches = enabled;</span>
<span class="fc" id="L4202">    }</span>

    public static boolean strictRuntimeChecks()
    {
<span class="nc" id="L4206">        return strictRuntimeChecks;</span>
    }

    public static boolean useOffheapMerkleTrees()
    {
<span class="fc" id="L4211">        return conf.use_offheap_merkle_trees;</span>
    }

    public static void useOffheapMerkleTrees(boolean value)
    {
<span class="fc" id="L4216">        logger.info(&quot;Setting use_offheap_merkle_trees to {}&quot;, value);</span>
<span class="fc" id="L4217">        conf.use_offheap_merkle_trees = value;</span>
<span class="fc" id="L4218">    }</span>

    public static Function&lt;CommitLog, AbstractCommitLogSegmentManager&gt; getCommitLogSegmentMgrProvider()
    {
<span class="fc" id="L4222">        return commitLogSegmentMgrProvider;</span>
    }

    public static void setCommitLogSegmentMgrProvider(Function&lt;CommitLog, AbstractCommitLogSegmentManager&gt; provider)
    {
<span class="fc" id="L4227">        commitLogSegmentMgrProvider = provider;</span>
<span class="fc" id="L4228">    }</span>

    private static DataStorageSpec.IntKibibytesBound createIntKibibyteBoundAndEnsureItIsValidForByteConversion(int kibibytes, String propertyName)
    {
<span class="fc" id="L4232">        DataStorageSpec.IntKibibytesBound intKibibytesBound = new DataStorageSpec.IntKibibytesBound(kibibytes);</span>
<span class="fc" id="L4233">        checkValidForByteConversion(intKibibytesBound, propertyName);</span>
<span class="fc" id="L4234">        return intKibibytesBound;</span>
    }

    /**
     * Ensures passed in configuration value is positive and will not overflow when converted to Bytes
     */
    private static void checkValidForByteConversion(final DataStorageSpec.IntKibibytesBound value, String name)
    {
<span class="fc" id="L4242">        long valueInBytes = value.toBytesInLong();</span>
<span class="pc bpc" id="L4243" title="1 of 4 branches missed.">        if (valueInBytes &lt; 0 || valueInBytes &gt; Integer.MAX_VALUE - 1)</span>
        {
<span class="fc" id="L4245">            throw new ConfigurationException(String.format(&quot;%s must be positive value &lt;= %dB, but was %dB&quot;,</span>
                                                           name,
<span class="fc" id="L4247">                                                           Integer.MAX_VALUE - 1,</span>
<span class="fc" id="L4248">                                                           valueInBytes),</span>
                                             false);
        }
<span class="fc" id="L4251">    }</span>

    public static int getValidationPreviewPurgeHeadStartInSec()
    {
<span class="fc" id="L4255">        return conf.validation_preview_purge_head_start.toSeconds();</span>
    }

    public static boolean checkForDuplicateRowsDuringReads()
    {
<span class="fc" id="L4260">        return conf.check_for_duplicate_rows_during_reads;</span>
    }

    public static void setCheckForDuplicateRowsDuringReads(boolean enabled)
    {
<span class="fc" id="L4265">        conf.check_for_duplicate_rows_during_reads = enabled;</span>
<span class="fc" id="L4266">    }</span>

    public static boolean checkForDuplicateRowsDuringCompaction()
    {
<span class="fc" id="L4270">        return conf.check_for_duplicate_rows_during_compaction;</span>
    }

    public static void setCheckForDuplicateRowsDuringCompaction(boolean enabled)
    {
<span class="fc" id="L4275">        conf.check_for_duplicate_rows_during_compaction = enabled;</span>
<span class="fc" id="L4276">    }</span>

    public static int getRepairPendingCompactionRejectThreshold()
    {
<span class="fc" id="L4280">        return conf.reject_repair_compaction_threshold;</span>
    }

    public static void setRepairPendingCompactionRejectThreshold(int value)
    {
<span class="fc" id="L4285">        conf.reject_repair_compaction_threshold = value;</span>
<span class="fc" id="L4286">    }</span>

    public static int getInitialRangeTombstoneListAllocationSize()
    {
<span class="fc" id="L4290">        return conf.initial_range_tombstone_list_allocation_size;</span>
    }

    public static void setInitialRangeTombstoneListAllocationSize(int size)
    {
<span class="fc" id="L4295">        conf.initial_range_tombstone_list_allocation_size = size;</span>
<span class="fc" id="L4296">    }</span>

    public static double getRangeTombstoneListGrowthFactor()
    {
<span class="fc" id="L4300">        return conf.range_tombstone_list_growth_factor;</span>
    }

    public static void setRangeTombstoneListGrowthFactor(double resizeFactor)
    {
<span class="fc" id="L4305">        conf.range_tombstone_list_growth_factor = resizeFactor;</span>
<span class="fc" id="L4306">    }</span>

    public static boolean getAutocompactionOnStartupEnabled()
    {
<span class="fc" id="L4310">        return conf.autocompaction_on_startup_enabled;</span>
    }

    public static boolean autoOptimiseIncRepairStreams()
    {
<span class="fc" id="L4315">        return conf.auto_optimise_inc_repair_streams;</span>
    }

    public static void setAutoOptimiseIncRepairStreams(boolean enabled)
    {
<span class="fc bfc" id="L4320" title="All 2 branches covered.">        if (enabled != conf.auto_optimise_inc_repair_streams)</span>
<span class="fc" id="L4321">            logger.info(&quot;Changing auto_optimise_inc_repair_streams from {} to {}&quot;, conf.auto_optimise_inc_repair_streams, enabled);</span>
<span class="fc" id="L4322">        conf.auto_optimise_inc_repair_streams = enabled;</span>
<span class="fc" id="L4323">    }</span>

    public static boolean autoOptimiseFullRepairStreams()
    {
<span class="fc" id="L4327">        return conf.auto_optimise_full_repair_streams;</span>
    }

    public static void setAutoOptimiseFullRepairStreams(boolean enabled)
    {
<span class="fc bfc" id="L4332" title="All 2 branches covered.">        if (enabled != conf.auto_optimise_full_repair_streams)</span>
<span class="fc" id="L4333">            logger.info(&quot;Changing auto_optimise_full_repair_streams from {} to {}&quot;, conf.auto_optimise_full_repair_streams, enabled);</span>
<span class="fc" id="L4334">        conf.auto_optimise_full_repair_streams = enabled;</span>
<span class="fc" id="L4335">    }</span>

    public static boolean autoOptimisePreviewRepairStreams()
    {
<span class="fc" id="L4339">        return conf.auto_optimise_preview_repair_streams;</span>
    }

    public static void setAutoOptimisePreviewRepairStreams(boolean enabled)
    {
<span class="fc bfc" id="L4344" title="All 2 branches covered.">        if (enabled != conf.auto_optimise_preview_repair_streams)</span>
<span class="fc" id="L4345">            logger.info(&quot;Changing auto_optimise_preview_repair_streams from {} to {}&quot;, conf.auto_optimise_preview_repair_streams, enabled);</span>
<span class="fc" id="L4346">        conf.auto_optimise_preview_repair_streams = enabled;</span>
<span class="fc" id="L4347">    }</span>

    @Deprecated // this warning threshold will be replaced by an equivalent guardrail
    public static ConsistencyLevel getAuthWriteConsistencyLevel()
    {
<span class="fc" id="L4352">        return ConsistencyLevel.valueOf(conf.auth_write_consistency_level);</span>
    }

    public static ConsistencyLevel getAuthReadConsistencyLevel()
    {
<span class="fc" id="L4357">        return ConsistencyLevel.valueOf(conf.auth_read_consistency_level);</span>
    }

    public static void setAuthWriteConsistencyLevel(ConsistencyLevel cl)
    {
<span class="fc" id="L4362">        conf.auth_write_consistency_level = cl.toString();</span>
<span class="fc" id="L4363">    }</span>

    public static void setAuthReadConsistencyLevel(ConsistencyLevel cl)
    {
<span class="fc" id="L4367">        conf.auth_read_consistency_level = cl.toString();</span>
<span class="fc" id="L4368">    }</span>

    public static int getConsecutiveMessageErrorsThreshold()
    {
<span class="fc" id="L4372">        return conf.consecutive_message_errors_threshold;</span>
    }

    public static void setConsecutiveMessageErrorsThreshold(int value)
    {
<span class="nc" id="L4377">        conf.consecutive_message_errors_threshold = value;</span>
<span class="nc" id="L4378">    }</span>

    public static boolean getPartitionDenylistEnabled()
    {
<span class="fc" id="L4382">        return conf.partition_denylist_enabled;</span>
    }

    public static void setPartitionDenylistEnabled(boolean enabled)
    {
<span class="fc" id="L4387">        conf.partition_denylist_enabled = enabled;</span>
<span class="fc" id="L4388">    }</span>

    public static boolean getDenylistWritesEnabled()
    {
<span class="fc" id="L4392">        return conf.denylist_writes_enabled;</span>
    }

    public static void setDenylistWritesEnabled(boolean enabled)
    {
<span class="nc" id="L4397">        conf.denylist_writes_enabled = enabled;</span>
<span class="nc" id="L4398">    }</span>

    public static boolean getDenylistReadsEnabled()
    {
<span class="fc" id="L4402">        return conf.denylist_reads_enabled;</span>
    }

    public static void setDenylistReadsEnabled(boolean enabled)
    {
<span class="nc" id="L4407">        conf.denylist_reads_enabled = enabled;</span>
<span class="nc" id="L4408">    }</span>

    public static boolean getDenylistRangeReadsEnabled()
    {
<span class="fc" id="L4412">        return conf.denylist_range_reads_enabled;</span>
    }

    public static void setDenylistRangeReadsEnabled(boolean enabled)
    {
<span class="fc" id="L4417">        conf.denylist_range_reads_enabled = enabled;</span>
<span class="fc" id="L4418">    }</span>

    public static int getDenylistRefreshSeconds()
    {
<span class="fc" id="L4422">        return conf.denylist_refresh.toSeconds();</span>
    }

    public static void setDenylistRefreshSeconds(int seconds)
    {
<span class="fc bfc" id="L4427" title="All 2 branches covered.">        if (seconds &lt;= 0)</span>
<span class="fc" id="L4428">            throw new IllegalArgumentException(&quot;denylist_refresh must be a positive integer.&quot;);</span>

<span class="fc" id="L4430">        conf.denylist_refresh = new DurationSpec.IntSecondsBound(seconds);</span>
<span class="fc" id="L4431">    }</span>

    public static int getDenylistInitialLoadRetrySeconds()
    {
<span class="fc" id="L4435">        return conf.denylist_initial_load_retry.toSeconds();</span>
    }

    public static void setDenylistInitialLoadRetrySeconds(int seconds)
    {
<span class="nc bnc" id="L4440" title="All 2 branches missed.">        if (seconds &lt;= 0)</span>
<span class="nc" id="L4441">            throw new IllegalArgumentException(&quot;denylist_initial_load_retry must be a positive integer.&quot;);</span>

<span class="nc" id="L4443">        conf.denylist_initial_load_retry = new DurationSpec.IntSecondsBound(seconds);</span>
<span class="nc" id="L4444">    }</span>

    public static ConsistencyLevel getDenylistConsistencyLevel()
    {
<span class="fc" id="L4448">        return conf.denylist_consistency_level;</span>
    }

    public static void setDenylistConsistencyLevel(ConsistencyLevel cl)
    {
<span class="fc" id="L4453">        conf.denylist_consistency_level = cl;</span>
<span class="fc" id="L4454">    }</span>

    public static int getDenylistMaxKeysPerTable()
    {
<span class="fc" id="L4458">        return conf.denylist_max_keys_per_table;</span>
    }

    public static void setDenylistMaxKeysPerTable(int value)
    {
<span class="fc bfc" id="L4463" title="All 2 branches covered.">        if (value &lt;= 0)</span>
<span class="fc" id="L4464">            throw new IllegalArgumentException(&quot;denylist_max_keys_per_table must be a positive integer.&quot;);</span>
<span class="fc" id="L4465">        conf.denylist_max_keys_per_table = value;</span>
<span class="fc" id="L4466">    }</span>

    public static int getDenylistMaxKeysTotal()
    {
<span class="fc" id="L4470">        return conf.denylist_max_keys_total;</span>
    }

    public static void setDenylistMaxKeysTotal(int value)
    {
<span class="fc bfc" id="L4475" title="All 2 branches covered.">        if (value &lt;= 0)</span>
<span class="fc" id="L4476">            throw new IllegalArgumentException(&quot;denylist_max_keys_total must be a positive integer.&quot;);</span>
<span class="fc" id="L4477">        conf.denylist_max_keys_total = value;</span>
<span class="fc" id="L4478">    }</span>

    public static boolean getAuthCacheWarmingEnabled()
    {
<span class="fc" id="L4482">        return conf.auth_cache_warming_enabled;</span>
    }

    public static SubnetGroups getClientErrorReportingExclusions()
    {
<span class="fc" id="L4487">        return conf.client_error_reporting_exclusions;</span>
    }

    public static SubnetGroups getInternodeErrorReportingExclusions()
    {
<span class="fc" id="L4492">        return conf.internode_error_reporting_exclusions;</span>
    }

    public static boolean getReadThresholdsEnabled()
    {
<span class="fc" id="L4497">        return conf.read_thresholds_enabled;</span>
    }

    public static void setReadThresholdsEnabled(boolean value)
    {
<span class="fc bfc" id="L4502" title="All 2 branches covered.">        if (conf.read_thresholds_enabled != value)</span>
        {
<span class="fc" id="L4504">            conf.read_thresholds_enabled = value;</span>
<span class="fc" id="L4505">            logger.info(&quot;updated read_thresholds_enabled to {}&quot;, value);</span>
        }
<span class="fc" id="L4507">    }</span>

    @Nullable
    public static DataStorageSpec.LongBytesBound getCoordinatorReadSizeWarnThreshold()
    {
<span class="fc" id="L4512">        return conf.coordinator_read_size_warn_threshold;</span>
    }

    public static void setCoordinatorReadSizeWarnThreshold(@Nullable DataStorageSpec.LongBytesBound value)
    {
<span class="fc" id="L4517">        logger.info(&quot;updating  coordinator_read_size_warn_threshold to {}&quot;, value);</span>
<span class="fc" id="L4518">        conf.coordinator_read_size_warn_threshold = value;</span>
<span class="fc" id="L4519">    }</span>

    @Nullable
    public static DataStorageSpec.LongBytesBound getCoordinatorReadSizeFailThreshold()
    {
<span class="fc" id="L4524">        return conf.coordinator_read_size_fail_threshold;</span>
    }

    public static void setCoordinatorReadSizeFailThreshold(@Nullable DataStorageSpec.LongBytesBound value)
    {
<span class="fc" id="L4529">        logger.info(&quot;updating  coordinator_read_size_fail_threshold to {}&quot;, value);</span>
<span class="fc" id="L4530">        conf.coordinator_read_size_fail_threshold = value;</span>
<span class="fc" id="L4531">    }</span>

    @Nullable
    public static DataStorageSpec.LongBytesBound getLocalReadSizeWarnThreshold()
    {
<span class="fc" id="L4536">        return conf.local_read_size_warn_threshold;</span>
    }

    public static void setLocalReadSizeWarnThreshold(@Nullable DataStorageSpec.LongBytesBound value)
    {
<span class="fc" id="L4541">        logger.info(&quot;updating  local_read_size_warn_threshold to {}&quot;, value);</span>
<span class="fc" id="L4542">        conf.local_read_size_warn_threshold = value;</span>
<span class="fc" id="L4543">    }</span>

    @Nullable
    public static DataStorageSpec.LongBytesBound getLocalReadSizeFailThreshold()
    {
<span class="fc" id="L4548">        return conf.local_read_size_fail_threshold;</span>
    }

    public static void setLocalReadSizeFailThreshold(@Nullable DataStorageSpec.LongBytesBound value)
    {
<span class="fc" id="L4553">        logger.info(&quot;updating  local_read_size_fail_threshold to {}&quot;, value);</span>
<span class="fc" id="L4554">        conf.local_read_size_fail_threshold = value;</span>
<span class="fc" id="L4555">    }</span>

    @Nullable
    public static DataStorageSpec.LongBytesBound getRowIndexReadSizeWarnThreshold()
    {
<span class="fc" id="L4560">        return conf.row_index_read_size_warn_threshold;</span>
    }

    public static void setRowIndexReadSizeWarnThreshold(@Nullable DataStorageSpec.LongBytesBound value)
    {
<span class="fc" id="L4565">        logger.info(&quot;updating  row_index_size_warn_threshold to {}&quot;, value);</span>
<span class="fc" id="L4566">        conf.row_index_read_size_warn_threshold = value;</span>
<span class="fc" id="L4567">    }</span>

    @Nullable
    public static DataStorageSpec.LongBytesBound getRowIndexReadSizeFailThreshold()
    {
<span class="fc" id="L4572">        return conf.row_index_read_size_fail_threshold;</span>
    }

    public static void setRowIndexReadSizeFailThreshold(@Nullable DataStorageSpec.LongBytesBound value)
    {
<span class="fc" id="L4577">        logger.info(&quot;updating  row_index_read_size_fail_threshold to {}&quot;, value);</span>
<span class="fc" id="L4578">        conf.row_index_read_size_fail_threshold = value;</span>
<span class="fc" id="L4579">    }</span>

<span class="fc" id="L4581">    public static int getDefaultKeyspaceRF() { return conf.default_keyspace_rf; }</span>

    public static void setDefaultKeyspaceRF(int value) throws IllegalArgumentException
    {
<span class="fc bfc" id="L4585" title="All 2 branches covered.">        if (value &lt; 1)</span>
        {
<span class="fc" id="L4587">            throw new IllegalArgumentException(&quot;default_keyspace_rf cannot be less than 1&quot;);</span>
        }

<span class="fc bfc" id="L4590" title="All 2 branches covered.">        if (value &lt; guardrails.getMinimumReplicationFactorFailThreshold())</span>
        {
<span class="fc" id="L4592">            throw new IllegalArgumentException(String.format(&quot;default_keyspace_rf to be set (%d) cannot be less than minimum_replication_factor_fail_threshold (%d)&quot;, value, guardrails.getMinimumReplicationFactorFailThreshold()));</span>
        }

<span class="fc bfc" id="L4595" title="All 4 branches covered.">        if (guardrails.getMaximumReplicationFactorFailThreshold() != -1 &amp;&amp; value &gt; guardrails.getMaximumReplicationFactorFailThreshold())</span>
        {
<span class="fc" id="L4597">            throw new IllegalArgumentException(String.format(&quot;default_keyspace_rf to be set (%d) cannot be greater than maximum_replication_factor_fail_threshold (%d)&quot;, value, guardrails.getMaximumReplicationFactorFailThreshold()));</span>
        }

<span class="fc" id="L4600">        conf.default_keyspace_rf = value;</span>
<span class="fc" id="L4601">    }</span>


    public static boolean getUseStatementsEnabled()
    {
<span class="fc" id="L4606">        return conf.use_statements_enabled;</span>
    }

    public static void setUseStatementsEnabled(boolean enabled)
    {
<span class="fc bfc" id="L4611" title="All 2 branches covered.">        if (enabled != conf.use_statements_enabled)</span>
        {
<span class="fc" id="L4613">            logger.info(&quot;Setting use_statements_enabled to {}&quot;, enabled);</span>
<span class="fc" id="L4614">            conf.use_statements_enabled = enabled;</span>
        }
<span class="fc" id="L4616">    }</span>

    public static boolean getForceNewPreparedStatementBehaviour()
    {
<span class="fc" id="L4620">        return conf.force_new_prepared_statement_behaviour;</span>
    }

    public static void setForceNewPreparedStatementBehaviour(boolean value)
    {
<span class="nc bnc" id="L4625" title="All 2 branches missed.">        if (value != conf.force_new_prepared_statement_behaviour)</span>
        {
<span class="nc" id="L4627">            logger.info(&quot;Setting force_new_prepared_statement_behaviour to {}&quot;, value);</span>
<span class="nc" id="L4628">            conf.force_new_prepared_statement_behaviour = value;</span>
        }
<span class="nc" id="L4630">    }</span>

    public static DurationSpec.LongNanosecondsBound getStreamingStateExpires()
    {
<span class="fc" id="L4634">        return conf.streaming_state_expires;</span>
    }

    public static void setStreamingStateExpires(DurationSpec.LongNanosecondsBound duration)
    {
<span class="nc bnc" id="L4639" title="All 2 branches missed.">        if (!conf.streaming_state_expires.equals(Objects.requireNonNull(duration, &quot;duration&quot;)))</span>
        {
<span class="nc" id="L4641">            logger.info(&quot;Setting streaming_state_expires to {}&quot;, duration);</span>
<span class="nc" id="L4642">            conf.streaming_state_expires = duration;</span>
        }
<span class="nc" id="L4644">    }</span>

    public static DataStorageSpec.LongBytesBound getStreamingStateSize()
    {
<span class="fc" id="L4648">        return conf.streaming_state_size;</span>
    }

    public static void setStreamingStateSize(DataStorageSpec.LongBytesBound duration)
    {
<span class="nc bnc" id="L4653" title="All 2 branches missed.">        if (!conf.streaming_state_size.equals(Objects.requireNonNull(duration, &quot;duration&quot;)))</span>
        {
<span class="nc" id="L4655">            logger.info(&quot;Setting streaming_state_size to {}&quot;, duration);</span>
<span class="nc" id="L4656">            conf.streaming_state_size = duration;</span>
        }
<span class="nc" id="L4658">    }</span>

    public static boolean getStreamingStatsEnabled()
    {
<span class="fc" id="L4662">        return conf.streaming_stats_enabled;</span>
    }

    public static void setStreamingStatsEnabled(boolean streamingStatsEnabled)
    {
<span class="pc bpc" id="L4667" title="1 of 2 branches missed.">        if (conf.streaming_stats_enabled != streamingStatsEnabled)</span>
        {
<span class="fc" id="L4669">            logger.info(&quot;Setting streaming_stats_enabled to {}&quot;, streamingStatsEnabled);</span>
<span class="fc" id="L4670">            conf.streaming_stats_enabled = streamingStatsEnabled;</span>
        }
<span class="fc" id="L4672">    }</span>

    public static DurationSpec.IntSecondsBound getStreamingSlowEventsLogTimeout() {
<span class="fc" id="L4675">        return conf.streaming_slow_events_log_timeout;</span>
    }

    public static void setStreamingSlowEventsLogTimeout(String value) {
<span class="nc" id="L4679">        DurationSpec.IntSecondsBound next = new DurationSpec.IntSecondsBound(value);</span>
<span class="nc bnc" id="L4680" title="All 2 branches missed.">        if (!conf.streaming_slow_events_log_timeout.equals(next))</span>
        {
<span class="nc" id="L4682">            logger.info(&quot;Setting streaming_slow_events_log to &quot; + value);</span>
<span class="nc" id="L4683">            conf.streaming_slow_events_log_timeout = next;</span>
        }
<span class="nc" id="L4685">    }</span>

    public static boolean isUUIDSSTableIdentifiersEnabled()
    {
<span class="fc" id="L4689">        return conf.uuid_sstable_identifiers_enabled;</span>
    }

    public static DurationSpec.LongNanosecondsBound getRepairStateExpires()
    {
<span class="fc" id="L4694">        return conf.repair_state_expires;</span>
    }

    public static void setRepairStateExpires(DurationSpec.LongNanosecondsBound duration)
    {
<span class="nc bnc" id="L4699" title="All 2 branches missed.">        if (!conf.repair_state_expires.equals(Objects.requireNonNull(duration, &quot;duration&quot;)))</span>
        {
<span class="nc" id="L4701">            logger.info(&quot;Setting repair_state_expires to {}&quot;, duration);</span>
<span class="nc" id="L4702">            conf.repair_state_expires = duration;</span>
        }
<span class="nc" id="L4704">    }</span>

    public static int getRepairStateSize()
    {
<span class="fc" id="L4708">        return conf.repair_state_size;</span>
    }

    public static void setRepairStateSize(int size)
    {
<span class="nc bnc" id="L4713" title="All 2 branches missed.">        if (conf.repair_state_size != size)</span>
        {
<span class="nc" id="L4715">            logger.info(&quot;Setting repair_state_size to {}&quot;, size);</span>
<span class="nc" id="L4716">            conf.repair_state_size = size;</span>
        }
<span class="nc" id="L4718">    }</span>

    public static boolean topPartitionsEnabled()
    {
<span class="fc" id="L4722">        return conf.top_partitions_enabled;</span>
    }

    public static int getMaxTopSizePartitionCount()
    {
<span class="fc" id="L4727">        return conf.max_top_size_partition_count;</span>
    }

    public static void setMaxTopSizePartitionCount(int value)
    {
<span class="fc" id="L4732">        conf.max_top_size_partition_count = value;</span>
<span class="fc" id="L4733">    }</span>

    public static int getMaxTopTombstonePartitionCount()
    {
<span class="fc" id="L4737">        return conf.max_top_tombstone_partition_count;</span>
    }

    public static void setMaxTopTombstonePartitionCount(int value)
    {
<span class="fc" id="L4742">        conf.max_top_tombstone_partition_count = value;</span>
<span class="fc" id="L4743">    }</span>

    public static DataStorageSpec.LongBytesBound getMinTrackedPartitionSizeInBytes()
    {
<span class="fc" id="L4747">        return conf.min_tracked_partition_size;</span>
    }

    public static void setMinTrackedPartitionSizeInBytes(DataStorageSpec.LongBytesBound spec)
    {
<span class="fc" id="L4752">        conf.min_tracked_partition_size = spec;</span>
<span class="fc" id="L4753">    }</span>

    public static long getMinTrackedPartitionTombstoneCount()
    {
<span class="fc" id="L4757">        return conf.min_tracked_partition_tombstone_count;</span>
    }

    public static void setMinTrackedPartitionTombstoneCount(long value)
    {
<span class="fc" id="L4762">        conf.min_tracked_partition_tombstone_count = value;</span>
<span class="fc" id="L4763">    }</span>

    public static boolean getDumpHeapOnUncaughtException()
    {
<span class="fc" id="L4767">        return conf.dump_heap_on_uncaught_exception;</span>
    }

    /**
     * @return Whether the path exists (be it created now or already prior)
     */
    private static boolean maybeCreateHeapDumpPath()
    {
<span class="fc bfc" id="L4775" title="All 2 branches covered.">        if (!conf.dump_heap_on_uncaught_exception)</span>
<span class="fc" id="L4776">            return false;</span>

<span class="fc" id="L4778">        Path heap_dump_path = getHeapDumpPath();</span>
<span class="pc bpc" id="L4779" title="1 of 2 branches missed.">        if (heap_dump_path == null)</span>
        {
<span class="nc" id="L4781">            logger.warn(&quot;Neither -XX:HeapDumpPath nor cassandra.yaml:heap_dump_path are set; unable to create a directory to hold the output.&quot;);</span>
<span class="nc" id="L4782">            return false;</span>
        }
<span class="pc bpc" id="L4784" title="1 of 2 branches missed.">        if (PathUtils.exists(File.getPath(conf.heap_dump_path)))</span>
<span class="fc" id="L4785">            return true;</span>
<span class="nc" id="L4786">        return PathUtils.createDirectoryIfNotExists(File.getPath(conf.heap_dump_path));</span>
    }

    /**
     * As this is at its heart a debug operation (getting a one-shot heapdump from an uncaught exception), we support
     * both the more evolved cassandra.yaml approach but also the -XX param to override it on a one-off basis so you don't
     * have to change the full config of a node or a cluster in order to get a heap dump from a single node that's
     * misbehaving.
     * @return the absolute path of the -XX param if provided, else the heap_dump_path in cassandra.yaml
     */
    public static Path getHeapDumpPath()
    {
<span class="fc" id="L4798">        RuntimeMXBean runtimeMxBean = ManagementFactory.getRuntimeMXBean();</span>
<span class="fc" id="L4799">        Optional&lt;String&gt; pathArg = runtimeMxBean.getInputArguments().stream().filter(s -&gt; s.startsWith(&quot;-XX:HeapDumpPath=&quot;)).findFirst();</span>

<span class="pc bpc" id="L4801" title="1 of 2 branches missed.">        if (pathArg.isPresent())</span>
        {
<span class="fc" id="L4803">            Pattern HEAP_DUMP_PATH_SPLITTER = Pattern.compile(&quot;HeapDumpPath=&quot;);</span>
<span class="fc" id="L4804">            String fullHeapPathString = HEAP_DUMP_PATH_SPLITTER.split(pathArg.get())[1];</span>
<span class="fc" id="L4805">            Path absolutePath = File.getPath(fullHeapPathString).toAbsolutePath();</span>
<span class="pc bpc" id="L4806" title="1 of 2 branches missed.">            Path basePath = fullHeapPathString.endsWith(&quot;.hprof&quot;) ? absolutePath.subpath(0, absolutePath.getNameCount() - 1) : absolutePath;</span>
<span class="fc" id="L4807">            return File.getPath(&quot;/&quot;).resolve(basePath);</span>
        }
<span class="nc bnc" id="L4809" title="All 2 branches missed.">        if (conf.heap_dump_path == null)</span>
<span class="nc" id="L4810">            throw new ConfigurationException(&quot;Attempted to get heap dump path without -XX:HeapDumpPath or cassandra.yaml:heap_dump_path set.&quot;);</span>
<span class="nc" id="L4811">        return File.getPath(conf.heap_dump_path);</span>
    }

    public static void setDumpHeapOnUncaughtException(boolean enabled)
    {
<span class="fc" id="L4816">        conf.dump_heap_on_uncaught_exception = enabled;</span>
<span class="fc" id="L4817">        boolean pathExists = maybeCreateHeapDumpPath();</span>

<span class="pc bpc" id="L4819" title="1 of 4 branches missed.">        if (enabled &amp;&amp; !pathExists)</span>
        {
<span class="nc" id="L4821">            logger.error(&quot;Attempted to enable heap dump but cannot create the requested path. Disabling.&quot;);</span>
<span class="nc" id="L4822">            conf.dump_heap_on_uncaught_exception = false;</span>
        }
        else
<span class="fc" id="L4825">            logger.info(&quot;Setting dump_heap_on_uncaught_exception to {}&quot;, enabled);</span>
<span class="fc" id="L4826">    }</span>

    public static boolean getSStableReadRatePersistenceEnabled()
    {
<span class="fc" id="L4830">        return conf.sstable_read_rate_persistence_enabled;</span>
    }

    public static void setSStableReadRatePersistenceEnabled(boolean enabled)
    {
<span class="fc bfc" id="L4835" title="All 2 branches covered.">        if (enabled != conf.sstable_read_rate_persistence_enabled)</span>
        {
<span class="fc" id="L4837">            logger.info(&quot;Setting sstable_read_rate_persistence_enabled to {}&quot;, enabled);</span>
<span class="fc" id="L4838">            conf.sstable_read_rate_persistence_enabled = enabled;</span>
        }
<span class="fc" id="L4840">    }</span>

    public static boolean getClientRequestSizeMetricsEnabled()
    {
<span class="fc" id="L4844">        return conf.client_request_size_metrics_enabled;</span>
    }

    public static void setClientRequestSizeMetricsEnabled(boolean enabled)
    {
<span class="fc" id="L4849">        conf.client_request_size_metrics_enabled = enabled;</span>
<span class="fc" id="L4850">    }</span>

    @VisibleForTesting
    public static void resetSSTableFormats(Iterable&lt;SSTableFormat.Factory&gt; factories, Config.SSTableConfig config)
    {
<span class="fc" id="L4855">        sstableFormats = null;</span>
<span class="fc" id="L4856">        selectedSSTableFormat = null;</span>
<span class="fc" id="L4857">        applySSTableFormats(factories, config);</span>
<span class="fc" id="L4858">    }</span>

    public static ImmutableMap&lt;String, SSTableFormat&lt;?, ?&gt;&gt; getSSTableFormats()
    {
<span class="fc" id="L4862">        return Objects.requireNonNull(sstableFormats, &quot;Forgot to initialize DatabaseDescriptor?&quot;);</span>
    }

    public static SSTableFormat&lt;?, ?&gt; getSelectedSSTableFormat()
    {
<span class="fc" id="L4867">        return Objects.requireNonNull(selectedSSTableFormat, &quot;Forgot to initialize DatabaseDescriptor?&quot;);</span>
    }

    @VisibleForTesting
    public static void setSelectedSSTableFormat(SSTableFormat&lt;?, ?&gt; format)
    {
<span class="fc" id="L4873">        selectedSSTableFormat = Objects.requireNonNull(format);</span>
<span class="fc" id="L4874">    }</span>

    public static boolean getDynamicDataMaskingEnabled()
    {
<span class="fc" id="L4878">        return conf.dynamic_data_masking_enabled;</span>
    }

    public static void setDynamicDataMaskingEnabled(boolean enabled)
    {
<span class="fc bfc" id="L4883" title="All 2 branches covered.">        if (enabled != conf.dynamic_data_masking_enabled)</span>
        {
<span class="fc" id="L4885">            logger.info(&quot;Setting dynamic_data_masking_enabled to {}&quot;, enabled);</span>
<span class="fc" id="L4886">            conf.dynamic_data_masking_enabled = enabled;</span>
        }
<span class="fc" id="L4888">    }</span>

    public static OptionalDouble getSeverityDuringDecommission()
    {
<span class="fc bfc" id="L4892" title="All 2 branches covered.">        return conf.severity_during_decommission &gt; 0 ?</span>
<span class="fc" id="L4893">               OptionalDouble.of(conf.severity_during_decommission) :</span>
<span class="fc" id="L4894">               OptionalDouble.empty();</span>
    }

    public static StorageCompatibilityMode getStorageCompatibilityMode()
    {
        // Config is null for junits that don't load the config. Get from env var that CI/build.xml sets
<span class="fc bfc" id="L4900" title="All 2 branches covered.">        if (conf == null)</span>
<span class="fc" id="L4901">            return CassandraRelevantProperties.JUNIT_STORAGE_COMPATIBILITY_MODE.getEnum(StorageCompatibilityMode.CASSANDRA_4);</span>
        else
<span class="fc" id="L4903">            return conf.storage_compatibility_mode;</span>
    }

    public static ParameterizedClass getDefaultCompaction()
    {
<span class="fc bfc" id="L4908" title="All 2 branches covered.">        return conf != null ? conf.default_compaction : null;</span>
    }

    public static DataStorageSpec.IntMebibytesBound getSAISegmentWriteBufferSpace()
    {
<span class="fc" id="L4913">        return conf.sai_options.segment_write_buffer_size;</span>
    }

    public static RepairRetrySpec getRepairRetrySpec()
    {
<span class="pc bpc" id="L4918" title="1 of 2 branches missed.">        return conf == null ? new RepairRetrySpec() : conf.repair.retries;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>