<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ByteArrayUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.utils</a> &gt; <span class="el_source">ByteArrayUtil.java</span></div><h1>ByteArrayUtil.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
     * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.utils;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;

import org.apache.cassandra.db.TypeSizes;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;

// mostly copied from java.io.Bits
<span class="nc" id="L33">public class ByteArrayUtil</span>
{
<span class="fc" id="L35">    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];</span>

    public static int compareUnsigned(byte[] o1, byte[] o2)
    {
<span class="fc" id="L39">        return FastByteOperations.compareUnsigned(o1, 0, o1.length, o2, 0, o2.length);</span>
    }

    public static int compareUnsigned(byte[] o1, int off1, byte[] o2, int off2, int len)
    {
<span class="fc" id="L44">        return FastByteOperations.compareUnsigned(o1, off1, len, o2, off2, len);</span>
    }

    public static byte[] bytes(byte b)
    {
<span class="fc" id="L49">        return new byte[] {b};</span>
    }

    public static byte[] bytes(int v)
    {
<span class="fc" id="L54">        byte[] b = new byte[TypeSizes.sizeof(v)];</span>
<span class="fc" id="L55">        putInt(b, 0, v);</span>
<span class="fc" id="L56">        return b;</span>
    }

    public static byte[] bytes(long v)
    {
<span class="fc" id="L61">        byte[] b = new byte[TypeSizes.sizeof(v)];</span>
<span class="fc" id="L62">        putLong(b, 0, v);</span>
<span class="fc" id="L63">        return b;</span>
    }

    public static byte[] bytes(short v)
    {
<span class="fc" id="L68">        byte[] b = new byte[TypeSizes.sizeof(v)];</span>
<span class="fc" id="L69">        putShort(b, 0, v);</span>
<span class="fc" id="L70">        return b;</span>
    }

    public static byte[] bytes(float v)
    {
<span class="fc" id="L75">        byte[] b = new byte[TypeSizes.sizeof(v)];</span>
<span class="fc" id="L76">        putFloat(b, 0, v);</span>
<span class="fc" id="L77">        return b;</span>
    }

    public static byte[] bytes(double v)
    {
<span class="fc" id="L82">        byte[] b = new byte[TypeSizes.sizeof(v)];</span>
<span class="fc" id="L83">        putDouble(b, 0, v);</span>
<span class="fc" id="L84">        return b;</span>
    }

    public static byte[] bytes(String v)
    {
<span class="nc" id="L89">        return v.getBytes();</span>
    }

    public static byte[] bytes(String v, Charset charset)
    {
<span class="nc" id="L94">        return v.getBytes(charset);</span>
    }

    /*
     * Methods for unpacking primitive values from byte arrays starting at
     * given offsets.
     */

    public static boolean getBoolean(byte[] b, int off) {
<span class="fc bfc" id="L103" title="All 2 branches covered.">        return b[off] != 0;</span>
    }

    public static char getChar(byte[] b, int off) {
<span class="nc" id="L107">        return (char) ((b[off + 1] &amp; 0xFF) +</span>
                       (b[off] &lt;&lt; 8));
    }

    public static short getShort(byte[] b, int off) {
<span class="fc" id="L112">        return (short) ((b[off + 1] &amp; 0xFF) +</span>
                        (b[off] &lt;&lt; 8));
    }

    public static int getUnsignedShort(byte[] b, int off) {
<span class="fc" id="L117">        return ((b[off] &amp; 0xFF) &lt;&lt; 8) | (b[off + 1] &amp; 0xFF);</span>
    }

    public static int getInt(byte[] b, int off) {
<span class="fc" id="L121">        return ((b[off + 3] &amp; 0xFF)      ) +</span>
               ((b[off + 2] &amp; 0xFF) &lt;&lt;  8) +
               ((b[off + 1] &amp; 0xFF) &lt;&lt; 16) +
               ((b[off    ]       ) &lt;&lt; 24);
    }

    public static int getInt(byte[] b) {
<span class="nc" id="L128">        return getInt(b, 0);</span>
    }

    public static float getFloat(byte[] b, int off) {
<span class="fc" id="L132">        return Float.intBitsToFloat(getInt(b, off));</span>
    }

    public static long getLong(byte[] b)
    {
<span class="nc" id="L137">        return getLong(b, 0);</span>
    }

    public static long getLong(byte[] b, int off) {
<span class="fc" id="L141">        return ((b[off + 7] &amp; 0xFFL)      ) +</span>
               ((b[off + 6] &amp; 0xFFL) &lt;&lt;  8) +
               ((b[off + 5] &amp; 0xFFL) &lt;&lt; 16) +
               ((b[off + 4] &amp; 0xFFL) &lt;&lt; 24) +
               ((b[off + 3] &amp; 0xFFL) &lt;&lt; 32) +
               ((b[off + 2] &amp; 0xFFL) &lt;&lt; 40) +
               ((b[off + 1] &amp; 0xFFL) &lt;&lt; 48) +
               (((long) b[off])      &lt;&lt; 56);
    }

    public static double getDouble(byte[] b, int off) {
<span class="fc" id="L152">        return Double.longBitsToDouble(getLong(b, off));</span>
    }

    /*
     * Methods for packing primitive values into byte arrays starting at given
     * offsets.
     */

    public static void putBoolean(byte[] b, int off, boolean val) {
<span class="fc bfc" id="L161" title="All 2 branches covered.">        b[off] = (byte) (val ? 1 : 0);</span>
<span class="fc" id="L162">    }</span>

    public static void putChar(byte[] b, int off, char val) {
<span class="nc" id="L165">        b[off + 1] = (byte) (val      );</span>
<span class="nc" id="L166">        b[off    ] = (byte) (val &gt;&gt;&gt; 8);</span>
<span class="nc" id="L167">    }</span>

    public static void putShort(byte[] b, int off, short val) {
<span class="fc" id="L170">        b[off + 1] = (byte) (val      );</span>
<span class="fc" id="L171">        b[off    ] = (byte) (val &gt;&gt;&gt; 8);</span>
<span class="fc" id="L172">    }</span>

    public static void putInt(byte[] b, int off, int val) {
<span class="fc" id="L175">        b[off + 3] = (byte) (val       );</span>
<span class="fc" id="L176">        b[off + 2] = (byte) (val &gt;&gt;&gt;  8);</span>
<span class="fc" id="L177">        b[off + 1] = (byte) (val &gt;&gt;&gt; 16);</span>
<span class="fc" id="L178">        b[off    ] = (byte) (val &gt;&gt;&gt; 24);</span>
<span class="fc" id="L179">    }</span>

    public static void putFloat(byte[] b, int off, float val) {
<span class="fc" id="L182">        putInt(b, off,  Float.floatToIntBits(val));</span>
<span class="fc" id="L183">    }</span>

    public static void putLong(byte[] b, int off, long val) {
<span class="fc" id="L186">        b[off + 7] = (byte) (val       );</span>
<span class="fc" id="L187">        b[off + 6] = (byte) (val &gt;&gt;&gt;  8);</span>
<span class="fc" id="L188">        b[off + 5] = (byte) (val &gt;&gt;&gt; 16);</span>
<span class="fc" id="L189">        b[off + 4] = (byte) (val &gt;&gt;&gt; 24);</span>
<span class="fc" id="L190">        b[off + 3] = (byte) (val &gt;&gt;&gt; 32);</span>
<span class="fc" id="L191">        b[off + 2] = (byte) (val &gt;&gt;&gt; 40);</span>
<span class="fc" id="L192">        b[off + 1] = (byte) (val &gt;&gt;&gt; 48);</span>
<span class="fc" id="L193">        b[off    ] = (byte) (val &gt;&gt;&gt; 56);</span>
<span class="fc" id="L194">    }</span>

    public static void putDouble(byte[] b, int off, double val) {
<span class="fc" id="L197">        putLong(b, off, Double.doubleToLongBits(val));</span>
<span class="fc" id="L198">    }</span>

    public static String bytesToHex(byte[] bytes)
    {
<span class="fc" id="L202">        return Hex.bytesToHex(bytes, 0, bytes.length);</span>
    }

    public static byte[] hexToBytes(String hex)
    {
<span class="nc" id="L207">        return Hex.hexToBytes(hex);</span>
    }

    public static String string(byte[] bytes) throws CharacterCodingException
    {
<span class="nc" id="L212">        return ByteBufferUtil.string(ByteBuffer.wrap(bytes));</span>
    }

    public static String string(byte[] buffer, Charset charset) throws CharacterCodingException
    {
<span class="nc" id="L217">        return new String(buffer, charset);</span>
    }

    public static void writeWithLength(byte[] bytes, DataOutput out) throws IOException
    {
<span class="fc" id="L222">        out.writeInt(bytes.length);</span>
<span class="fc" id="L223">        out.write(bytes);</span>
<span class="fc" id="L224">    }</span>

    public static void writeWithShortLength(byte[] buffer, DataOutput out) throws IOException
    {
<span class="fc" id="L228">        int length = buffer.length;</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        assert length &lt;= FBUtilities.MAX_UNSIGNED_SHORT</span>
<span class="nc" id="L230">         : String.format(&quot;Attempted serializing to buffer exceeded maximum of %s bytes: %s&quot;, FBUtilities.MAX_UNSIGNED_SHORT, length);</span>
<span class="fc" id="L231">        out.writeShort(length);</span>
<span class="fc" id="L232">        out.write(buffer);</span>
<span class="fc" id="L233">    }</span>

    public static void writeWithVIntLength(byte[] bytes, DataOutputPlus out) throws IOException
    {
<span class="fc" id="L237">        out.writeUnsignedVInt32(bytes.length);</span>
<span class="fc" id="L238">        out.write(bytes);</span>
<span class="fc" id="L239">    }</span>

    public static int serializedSizeWithVIntLength(byte[] bytes)
    {
<span class="fc" id="L243">        return TypeSizes.sizeofUnsignedVInt(bytes.length) + bytes.length;</span>
    }

    public static byte[] readWithLength(DataInput in) throws IOException
    {
<span class="nc" id="L248">        byte[] b = new byte[in.readInt()];</span>
<span class="nc" id="L249">        in.readFully(b);</span>
<span class="nc" id="L250">        return b;</span>
    }

    public static byte[] readWithShortLength(DataInput in) throws IOException
    {
<span class="nc" id="L255">        byte[] b = new byte[in.readUnsignedShort()];</span>
<span class="nc" id="L256">        in.readFully(b);</span>
<span class="nc" id="L257">        return b;</span>
    }

    public static byte[] readWithVIntLength(DataInputPlus in) throws IOException
    {
<span class="fc" id="L262">        int length = in.readUnsignedVInt32();</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        if (length &lt; 0)</span>
<span class="nc" id="L264">            throw new IOException(&quot;Corrupt (negative) value length encountered&quot;);</span>

<span class="fc" id="L266">        byte[] bytes = new byte[length];</span>
<span class="fc" id="L267">        in.readFully(bytes);</span>
<span class="fc" id="L268">        return bytes;</span>
    }

    public static void copyBytes(byte[] src, int srcPos, byte[] dst, int dstPos, int length)
    {
<span class="nc" id="L273">        System.arraycopy(src, srcPos, dst, dstPos, length);</span>
<span class="nc" id="L274">    }</span>

    public static void copyBytes(byte[] src, int srcPos, ByteBuffer dst, int dstPos, int length)
    {
<span class="nc" id="L278">        FastByteOperations.copy(src, srcPos, dst, dstPos, length);</span>
<span class="nc" id="L279">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>