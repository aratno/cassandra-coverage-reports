<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HeapUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.utils</a> &gt; <span class="el_source">HeapUtils.java</span></div><h1>HeapUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.utils;


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.management.ManagementFactory;
import java.nio.file.FileStore;
import java.nio.file.Path;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import javax.management.MBeanServer;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.text.StrBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.sun.management.HotSpotDiagnosticMXBean;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.io.util.PathUtils;

import static org.apache.cassandra.config.CassandraRelevantEnv.JAVA_HOME;
import static org.apache.cassandra.utils.Clock.Global.currentTimeMillis;

/**
 * Utility to log heap histogram.
 *
 */
public final class HeapUtils
{
<span class="fc" id="L50">    private static final Logger logger = LoggerFactory.getLogger(HeapUtils.class);</span>

<span class="fc" id="L52">    private static final Lock DUMP_LOCK = new ReentrantLock();</span>

    /**
     * Generates a HEAP histogram in the log file.
     */
    public static void logHeapHistogram()
    {
        try
        {
<span class="nc" id="L61">            logger.info(&quot;Trying to log the heap histogram using jcmd&quot;);</span>

<span class="nc" id="L63">            Long processId = getProcessId();</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">            if (processId == null)</span>
            {
<span class="nc" id="L66">                logger.error(&quot;The process ID could not be retrieved. Skipping heap histogram generation.&quot;);</span>
<span class="nc" id="L67">                return;</span>
            }

<span class="nc" id="L70">            String jcmdPath = getJcmdPath();</span>

            // The jcmd file could not be found. In this case let's default to jcmd in the hope that it is in the path.
<span class="nc bnc" id="L73" title="All 2 branches missed.">            String jcmdCommand = jcmdPath == null ? &quot;jcmd&quot; : jcmdPath;</span>

<span class="nc" id="L75">            String[] histoCommands = new String[] {jcmdCommand,</span>
<span class="nc" id="L76">                    processId.toString(),</span>
                    &quot;GC.class_histogram&quot;};

<span class="nc" id="L79">            logProcessOutput(Runtime.getRuntime().exec(histoCommands));</span>
        }
<span class="nc" id="L81">        catch (Throwable e)</span>
        {
<span class="nc" id="L83">            logger.error(&quot;The heap histogram could not be generated due to the following error: &quot;, e);</span>
<span class="nc" id="L84">        }</span>
<span class="nc" id="L85">    }</span>

    /**
     * @return full path to the created heap dump file
     */
    public static String maybeCreateHeapDump()
    {
        // Make sure that only one heap dump can be in progress across all threads, and abort for
        // threads that cannot immediately acquire the lock, allowing them to fail normally.
<span class="fc bfc" id="L94" title="All 2 branches covered.">        if (DUMP_LOCK.tryLock())</span>
        {
            try
            {
<span class="fc bfc" id="L98" title="All 2 branches covered.">                if (DatabaseDescriptor.getDumpHeapOnUncaughtException())</span>
                {
<span class="fc" id="L100">                    MBeanServer server = ManagementFactory.getPlatformMBeanServer();</span>

<span class="fc" id="L102">                    Path absoluteBasePath = DatabaseDescriptor.getHeapDumpPath();</span>
                    // We should never reach this point with this value null as we initialize the bool only after confirming
                    // the -XX param / .yaml conf is present on initial init and the JMX entry point, but still worth checking.
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">                    if (absoluteBasePath == null)</span>
                    {
<span class="nc" id="L107">                        DatabaseDescriptor.setDumpHeapOnUncaughtException(false);</span>
<span class="nc" id="L108">                        throw new RuntimeException(&quot;Cannot create heap dump unless -XX:HeapDumpPath or cassandra.yaml:heap_dump_path is specified.&quot;);</span>
                    }

<span class="fc" id="L111">                    long maxMemoryBytes = Runtime.getRuntime().maxMemory();</span>
<span class="fc" id="L112">                    long freeSpaceBytes = PathUtils.tryGetSpace(absoluteBasePath, FileStore::getUnallocatedSpace);</span>

                    // Abort if there isn't enough room on the target disk to dump the entire heap and then copy it.
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">                    if (freeSpaceBytes &lt; 2 * maxMemoryBytes)</span>
<span class="nc" id="L116">                        throw new RuntimeException(&quot;Cannot allocated space for a heap dump snapshot. There are only &quot; + freeSpaceBytes + &quot; bytes free at &quot; + absoluteBasePath + '.');</span>

<span class="fc" id="L118">                    HotSpotDiagnosticMXBean mxBean = ManagementFactory.newPlatformMXBeanProxy(server, &quot;com.sun.management:type=HotSpotDiagnostic&quot;, HotSpotDiagnosticMXBean.class);</span>
<span class="fc" id="L119">                    String filename = String.format(&quot;pid%s-epoch%s.hprof&quot;, HeapUtils.getProcessId().toString(), currentTimeMillis());</span>
<span class="fc" id="L120">                    String fullPath = File.getPath(absoluteBasePath.toString(), filename).toString();</span>

<span class="fc" id="L122">                    logger.info(&quot;Writing heap dump to {} on partition w/ {} free bytes...&quot;, absoluteBasePath, freeSpaceBytes);</span>
<span class="fc" id="L123">                    mxBean.dumpHeap(fullPath, false);</span>
<span class="fc" id="L124">                    logger.info(&quot;Heap dump written to {}&quot;, fullPath);</span>

                    // Disable further heap dump creations until explicitly re-enabled.
<span class="fc" id="L127">                    DatabaseDescriptor.setDumpHeapOnUncaughtException(false);</span>

<span class="fc" id="L129">                    return fullPath;</span>
                }
                else
                {
<span class="fc" id="L133">                    logger.debug(&quot;Heap dump creation on uncaught exceptions is disabled.&quot;);</span>
                }
            }
<span class="fc" id="L136">            catch (Throwable e)</span>
            {
<span class="fc" id="L138">                logger.warn(&quot;Unable to create heap dump.&quot;, e);</span>
            }
            finally
            {
<span class="fc" id="L142">                DUMP_LOCK.unlock();</span>
<span class="fc" id="L143">            }</span>
        }
        else
        {
<span class="fc" id="L147">            logger.debug(&quot;Heap dump creation is already in progress. Request aborted.&quot;);</span>
        }

<span class="fc" id="L150">        return null;</span>
    }

    /**
     * Retrieve the path to the JCMD executable.
     * @return the path to the JCMD executable or null if it cannot be found.
     */
    private static String getJcmdPath()
    {
        // Searching in the JAVA_HOME is safer than searching into System.getProperty(&quot;java.home&quot;) as the Oracle
        // JVM might use the JRE which do not contains jmap.
<span class="nc" id="L161">        String javaHome = JAVA_HOME.getString();</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        if (javaHome == null)</span>
<span class="nc" id="L163">            return null;</span>
<span class="nc" id="L164">        File javaBinDirectory = new File(javaHome, &quot;bin&quot;);</span>
<span class="nc" id="L165">        File[] files = javaBinDirectory.tryList((dir, name) -&gt; name.startsWith(&quot;jcmd&quot;));</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">        return ArrayUtils.isEmpty(files) ? null : files[0].path();</span>
    }

    /**
     * Logs the output of the specified process.
     *
     * @param p the process
     * @throws IOException if an I/O problem occurs
     */
    private static void logProcessOutput(Process p) throws IOException
    {
<span class="nc" id="L177">        try (BufferedReader input = new BufferedReader(new InputStreamReader(p.getInputStream())))</span>
        {
<span class="nc" id="L179">            StrBuilder builder = new StrBuilder();</span>
            String line;
<span class="nc bnc" id="L181" title="All 2 branches missed.">            while ((line = input.readLine()) != null)</span>
            {
<span class="nc" id="L183">                builder.appendln(line);</span>
            }
<span class="nc" id="L185">            logger.info(builder.toString());</span>
        }
<span class="nc" id="L187">    }</span>

    /**
     * Retrieves the process ID or &lt;code&gt;null&lt;/code&gt; if the process ID cannot be retrieved.
     * @return the process ID or &lt;code&gt;null&lt;/code&gt; if the process ID cannot be retrieved.
     */
    private static Long getProcessId()
    {
<span class="fc" id="L195">        long pid = NativeLibrary.getProcessID();</span>
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">        if (pid &gt;= 0)</span>
<span class="fc" id="L197">            return pid;</span>

<span class="nc" id="L199">        return getProcessIdFromJvmName();</span>
    }

    /**
     * Retrieves the process ID from the JVM name.
     * @return the process ID or &lt;code&gt;null&lt;/code&gt; if the process ID cannot be retrieved.
     */
    private static Long getProcessIdFromJvmName()
    {
        // the JVM name in Oracle JVMs is: '&lt;pid&gt;@&lt;hostname&gt;' but this might not be the case on all JVMs
<span class="nc" id="L209">        String jvmName = ManagementFactory.getRuntimeMXBean().getName();</span>
        try
        {
<span class="nc" id="L212">            return Long.valueOf(jvmName.split(&quot;@&quot;)[0]);</span>
        }
<span class="nc" id="L214">        catch (NumberFormatException e)</span>
        {
            // ignore
        }
<span class="nc" id="L218">        return null;</span>
    }

    /**
     * The class must not be instantiated.
     */
    private HeapUtils()
    {
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>