<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SyncStatSummary.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.repair.consistent</a> &gt; <span class="el_source">SyncStatSummary.java</span></div><h1>SyncStatSummary.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.repair.consistent;

import java.net.InetSocketAddress;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;

import com.google.common.collect.Lists;

import org.apache.cassandra.dht.Range;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.repair.RepairResult;
import org.apache.cassandra.repair.RepairSessionResult;
import org.apache.cassandra.repair.SyncStat;
import org.apache.cassandra.schema.Schema;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.streaming.SessionSummary;
import org.apache.cassandra.streaming.StreamSummary;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.Pair;

import static com.google.common.collect.Iterables.filter;

public class SyncStatSummary
{

    private static class Session
    {
        final InetSocketAddress src;
        final InetSocketAddress dst;

<span class="fc" id="L56">        int files = 0;</span>
<span class="fc" id="L57">        long bytes = 0;</span>
<span class="fc" id="L58">        Set&lt;Range&lt;Token&gt;&gt; ranges = new HashSet&lt;&gt;();</span>

        Session(InetSocketAddress src, InetSocketAddress dst)
<span class="fc" id="L61">        {</span>
<span class="fc" id="L62">            this.src = src;</span>
<span class="fc" id="L63">            this.dst = dst;</span>
<span class="fc" id="L64">        }</span>

        void consumeSummary(StreamSummary summary)
        {
<span class="fc" id="L68">            files += summary.files;</span>
<span class="fc" id="L69">            bytes += summary.totalSize;</span>
<span class="fc" id="L70">        }</span>

        void consumeSummaries(Collection&lt;StreamSummary&gt; summaries, Collection&lt;Range&lt;Token&gt;&gt; ranges)
        {
<span class="fc" id="L74">            summaries.forEach(this::consumeSummary);</span>
<span class="fc" id="L75">            this.ranges.addAll(ranges);</span>
<span class="fc" id="L76">        }</span>

        public String toString()
        {
<span class="fc" id="L80">            return String.format(&quot;%s -&gt; %s: %s ranges, %s sstables, %s bytes&quot;, src, dst, ranges.size(), files, FBUtilities.prettyPrintMemory(bytes));</span>
        }
    }

    private static class Table
    {
        final String keyspace;

        final String table;

<span class="fc" id="L90">        int files = -1;</span>
<span class="fc" id="L91">        long bytes = -1;</span>
<span class="fc" id="L92">        Collection&lt;Range&lt;Token&gt;&gt; ranges = new HashSet&lt;&gt;();</span>
<span class="fc" id="L93">        boolean totalsCalculated = false;</span>

<span class="fc" id="L95">        final Map&lt;Pair&lt;InetSocketAddress, InetSocketAddress&gt;, Session&gt; sessions = new HashMap&lt;&gt;();</span>

        Table(String keyspace, String table)
<span class="fc" id="L98">        {</span>
<span class="fc" id="L99">            this.keyspace = keyspace;</span>
<span class="fc" id="L100">            this.table = table;</span>
<span class="fc" id="L101">        }</span>

        Session getOrCreate(InetSocketAddress from, InetSocketAddress to)
        {
<span class="fc" id="L105">            Pair&lt;InetSocketAddress, InetSocketAddress&gt; k = Pair.create(from, to);</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">            if (!sessions.containsKey(k))</span>
            {
<span class="fc" id="L108">                sessions.put(k, new Session(from, to));</span>
            }
<span class="fc" id="L110">            return sessions.get(k);</span>
        }

        void consumeStat(SyncStat stat)
        {
<span class="fc bfc" id="L115" title="All 2 branches covered.">            for (SessionSummary summary: stat.summaries)</span>
            {
<span class="fc" id="L117">                getOrCreate(summary.coordinator, summary.peer).consumeSummaries(summary.sendingSummaries, stat.differences);</span>
<span class="fc" id="L118">                getOrCreate(summary.peer, summary.coordinator).consumeSummaries(summary.receivingSummaries, stat.differences);</span>
<span class="fc" id="L119">            }</span>
<span class="fc" id="L120">        }</span>

        void consumeStats(List&lt;SyncStat&gt; stats)
        {
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">            filter(stats, s -&gt; s.summaries != null).forEach(this::consumeStat);</span>
<span class="fc" id="L125">        }</span>

        void calculateTotals()
        {
<span class="fc" id="L129">            files = 0;</span>
<span class="fc" id="L130">            bytes = 0;</span>
<span class="fc" id="L131">            ranges = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">            for (Session session: sessions.values())</span>
            {
<span class="fc" id="L134">                files += session.files;</span>
<span class="fc" id="L135">                bytes += session.bytes;</span>
<span class="fc" id="L136">                ranges.addAll(session.ranges);</span>
<span class="fc" id="L137">            }</span>
<span class="fc" id="L138">            totalsCalculated = true;</span>
<span class="fc" id="L139">        }</span>

        boolean isCounter()
        {
<span class="fc" id="L143">            TableMetadata tmd = Schema.instance.getTableMetadata(keyspace, table);</span>
<span class="pc bpc" id="L144" title="2 of 4 branches missed.">            return tmd != null &amp;&amp; tmd.isCounter();</span>
        }

        public String toString()
        {
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">            if (!totalsCalculated)</span>
            {
<span class="nc" id="L151">                calculateTotals();</span>
            }
<span class="fc" id="L153">            StringBuilder output = new StringBuilder();</span>

<span class="fc" id="L155">            output.append(String.format(&quot;%s.%s - %s ranges, %s sstables, %s bytes\n&quot;, keyspace, table, ranges.size(), files, FBUtilities.prettyPrintMemory(bytes)));</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">            if (ranges.size() &gt; 0)</span>
            {
<span class="fc" id="L158">                output.append(&quot;    Mismatching ranges: &quot;);</span>
<span class="fc" id="L159">                int i = 0;</span>
<span class="fc" id="L160">                Iterator&lt;Range&lt;Token&gt;&gt; rangeIterator = ranges.iterator();</span>
<span class="pc bpc" id="L161" title="1 of 4 branches missed.">                while (rangeIterator.hasNext() &amp;&amp; i &lt; 30)</span>
                {
<span class="fc" id="L163">                    Range&lt;Token&gt; r = rangeIterator.next();</span>
<span class="fc" id="L164">                    output.append('(').append(r.left).append(',').append(r.right).append(&quot;],&quot;);</span>
<span class="fc" id="L165">                    i++;</span>
<span class="fc" id="L166">                }</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">                if (i == 30)</span>
<span class="nc" id="L168">                    output.append(&quot;...&quot;);</span>
<span class="fc" id="L169">                output.append(System.lineSeparator());</span>
            }
<span class="fc bfc" id="L171" title="All 2 branches covered.">            for (Session session: sessions.values())</span>
            {
<span class="fc" id="L173">                output.append(&quot;    &quot;).append(session.toString()).append(System.lineSeparator());</span>
<span class="fc" id="L174">            }</span>
<span class="fc" id="L175">            return output.toString();</span>
        }
    }

<span class="fc" id="L179">    private final Map&lt;Pair&lt;String, String&gt;, Table&gt; summaries = new HashMap&lt;&gt;();</span>
    private final boolean isEstimate;

<span class="fc" id="L182">    private int files = -1;</span>
<span class="fc" id="L183">    private long bytes = -1;</span>
<span class="fc" id="L184">    private Set&lt;Range&lt;Token&gt;&gt; ranges = new HashSet&lt;&gt;();</span>
<span class="fc" id="L185">    private boolean totalsCalculated = false;</span>

    public SyncStatSummary(boolean isEstimate)
<span class="fc" id="L188">    {</span>
<span class="fc" id="L189">        this.isEstimate = isEstimate;</span>
<span class="fc" id="L190">    }</span>

    public void consumeRepairResult(RepairResult result)
    {
<span class="fc" id="L194">        Pair&lt;String, String&gt; cf = Pair.create(result.desc.keyspace, result.desc.columnFamily);</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">        if (!summaries.containsKey(cf))</span>
        {
<span class="fc" id="L197">            summaries.put(cf, new Table(cf.left, cf.right));</span>
        }
<span class="fc" id="L199">        summaries.get(cf).consumeStats(result.stats);</span>
<span class="fc" id="L200">    }</span>

    public void consumeSessionResults(Optional&lt;List&lt;RepairSessionResult&gt;&gt; results)
    {
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">        if (results.isPresent())</span>
        {
<span class="fc" id="L206">            filter(results.get(), Objects::nonNull).forEach(r -&gt; filter(r.repairJobResults, Objects::nonNull).forEach(this::consumeRepairResult));</span>
        }
<span class="fc" id="L208">    }</span>

    public boolean isEmpty()
    {
<span class="fc" id="L212">        calculateTotals();</span>
<span class="pc bpc" id="L213" title="2 of 6 branches missed.">        return files == 0 &amp;&amp; bytes == 0 &amp;&amp; ranges.isEmpty();</span>
    }

    private void calculateTotals()
    {
<span class="fc" id="L218">        files = 0;</span>
<span class="fc" id="L219">        bytes = 0;</span>
<span class="fc" id="L220">        ranges = new HashSet&lt;&gt;();</span>
<span class="fc" id="L221">        summaries.values().forEach(Table::calculateTotals);</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">        for (Table table: summaries.values())</span>
        {
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">            if (table.isCounter())</span>
            {
<span class="nc" id="L226">                continue;</span>
            }
<span class="fc" id="L228">            table.calculateTotals();</span>
<span class="fc" id="L229">            files += table.files;</span>
<span class="fc" id="L230">            bytes += table.bytes;</span>
<span class="fc" id="L231">            ranges.addAll(table.ranges);</span>
<span class="fc" id="L232">        }</span>
<span class="fc" id="L233">        totalsCalculated = true;</span>
<span class="fc" id="L234">    }</span>

    public String toString()
    {
<span class="fc" id="L238">        List&lt;Pair&lt;String, String&gt;&gt; tables = Lists.newArrayList(summaries.keySet());</span>
<span class="fc" id="L239">        tables.sort((o1, o2) -&gt;</span>
            {
<span class="fc" id="L241">                int ks = o1.left.compareTo(o2.left);</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">                return ks != 0 ? ks : o1.right.compareTo(o2.right);</span>
            });

<span class="fc" id="L245">        calculateTotals();</span>

<span class="fc" id="L247">        StringBuilder output = new StringBuilder();</span>

<span class="pc bpc" id="L249" title="1 of 2 branches missed.">        if (isEstimate)</span>
        {
<span class="fc" id="L251">            output.append(String.format(&quot;Total estimated streaming: %s ranges, %s sstables, %s bytes\n&quot;, ranges.size(), files, FBUtilities.prettyPrintMemory(bytes)));</span>
        }
        else
        {
<span class="nc" id="L255">            output.append(String.format(&quot;Total streaming: %s ranges, %s sstables, %s bytes\n&quot;, ranges.size(), files, FBUtilities.prettyPrintMemory(bytes)));</span>
        }

<span class="fc bfc" id="L258" title="All 2 branches covered.">        for (Pair&lt;String, String&gt; tableName: tables)</span>
        {
<span class="fc" id="L260">            Table table = summaries.get(tableName);</span>
<span class="fc" id="L261">            output.append(table.toString()).append('\n');</span>
<span class="fc" id="L262">        }</span>

<span class="fc" id="L264">        return output.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>