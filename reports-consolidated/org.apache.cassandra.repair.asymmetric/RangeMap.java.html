<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RangeMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.repair.asymmetric</a> &gt; <span class="el_source">RangeMap.java</span></div><h1>RangeMap.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.repair.asymmetric;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NavigableMap;
import java.util.Objects;
import java.util.Set;
import java.util.TreeMap;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.AbstractIterator;

import org.apache.cassandra.dht.Range;
import org.apache.cassandra.dht.Token;

public class RangeMap&lt;T&gt; implements Map&lt;Range&lt;Token&gt;, T&gt;
{
<span class="fc" id="L41">    private static final Comparator&lt;Range&lt;Token&gt;&gt; comparator = Comparator.comparing((Range&lt;Token&gt; o) -&gt; o.left);</span>

    private final NavigableMap&lt;Range&lt;Token&gt;, T&gt; byStart;

    public RangeMap()
<span class="fc" id="L46">    {</span>
<span class="fc" id="L47">        byStart = new TreeMap&lt;&gt;(comparator);</span>
<span class="fc" id="L48">    }</span>

    public int size()
    {
<span class="fc" id="L52">        return byStart.size();</span>
    }

    public boolean isEmpty()
    {
<span class="fc" id="L57">        return byStart.isEmpty();</span>
    }

    public boolean containsKey(Object key)
    {
<span class="fc" id="L62">        return byStart.containsKey(key);</span>
    }

    public boolean containsValue(Object value)
    {
<span class="nc" id="L67">        return byStart.containsValue(value);</span>
    }

    public T get(Object key)
    {
<span class="fc" id="L72">        return byStart.get(key);</span>
    }

    public T put(Range&lt;Token&gt; key, T value)
    {
<span class="fc" id="L77">        assertNonIntersecting(key);</span>
<span class="fc" id="L78">        return byStart.put(key, value);</span>
    }

    private void assertNonIntersecting(Range&lt;Token&gt; range)
    {
        // todo: wraparound
<span class="fc" id="L84">        Range&lt;Token&gt; before = byStart.floorKey(range);</span>
<span class="fc" id="L85">        Range&lt;Token&gt; after = byStart.ceilingKey(range);</span>
<span class="pc bpc" id="L86" title="1 of 4 branches missed.">        assert before == null || !before.intersects(range);</span>
<span class="pc bpc" id="L87" title="1 of 4 branches missed.">        assert after == null || !after.intersects(range);</span>
<span class="fc" id="L88">    }</span>

    public T remove(Object key)
    {
<span class="nc" id="L92">        return byStart.remove(key);</span>
    }

    public void putAll(Map&lt;? extends Range&lt;Token&gt;, ? extends T&gt; m)
    {
<span class="nc" id="L97">        byStart.putAll(m);</span>
<span class="nc" id="L98">    }</span>

    public void clear()
    {
<span class="nc" id="L102">        byStart.clear();</span>
<span class="nc" id="L103">    }</span>

    public Set&lt;Range&lt;Token&gt;&gt; keySet()
    {
<span class="fc" id="L107">        return byStart.keySet();</span>
    }

    public Collection&lt;T&gt; values()
    {
<span class="nc" id="L112">        return byStart.values();</span>
    }

    public Set&lt;Map.Entry&lt;Range&lt;Token&gt;, T&gt;&gt; entrySet()
    {
<span class="fc" id="L117">        return byStart.entrySet();</span>
    }

    /**
     * might return duplicate entries if range.isWrapAround()
     *
     * don't depend on the order of the entries returned
     */
    @VisibleForTesting
    Iterator&lt;Map.Entry&lt;Range&lt;Token&gt;, T&gt;&gt; intersectingEntryIterator(Range&lt;Token&gt; range)
    {
<span class="fc bfc" id="L128" title="All 2 branches covered.">        return range.isWrapAround() ? new WrappingIntersectingIterator(range) : new IntersectingIterator(range);</span>
    }

    public Set&lt;Map.Entry&lt;Range&lt;Token&gt;, T&gt;&gt; removeIntersecting(Range&lt;Token&gt; range)
    {
<span class="fc" id="L133">        Iterator&lt;Map.Entry&lt;Range&lt;Token&gt;, T&gt;&gt; iter = intersectingEntryIterator(range);</span>
<span class="fc" id="L134">        Set&lt;Map.Entry&lt;Range&lt;Token&gt;, T&gt;&gt; intersecting = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">        while (iter.hasNext())</span>
        {
<span class="fc" id="L137">            Map.Entry&lt;Range&lt;Token&gt;, T&gt; entry = iter.next();</span>
<span class="fc" id="L138">            intersecting.add(entry);</span>
<span class="fc" id="L139">        }</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">        for (Map.Entry&lt;Range&lt;Token&gt;, T&gt; entry : intersecting)</span>
<span class="fc" id="L141">            byStart.remove(entry.getKey());</span>
<span class="fc" id="L142">        return intersecting;</span>
    }

    private class WrappingIntersectingIterator extends AbstractIterator&lt;Map.Entry&lt;Range&lt;Token&gt;, T&gt;&gt;
    {
        private final Iterator&lt;Iterator&lt;Map.Entry&lt;Range&lt;Token&gt;, T&gt;&gt;&gt; iterators;
        private Iterator&lt;Map.Entry&lt;Range&lt;Token&gt;, T&gt;&gt; currentIter;

        public WrappingIntersectingIterator(Range&lt;Token&gt; range)
<span class="fc" id="L151">        {</span>
<span class="fc" id="L152">            List&lt;Iterator&lt;Map.Entry&lt;Range&lt;Token&gt;, T&gt;&gt;&gt; iters = new ArrayList&lt;&gt;(2);</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">            for (Range&lt;Token&gt; unwrapped : range.unwrap())</span>
<span class="fc" id="L154">                iters.add((new IntersectingIterator(unwrapped)));</span>
<span class="fc" id="L155">            iterators = iters.iterator();</span>
<span class="fc" id="L156">        }</span>
        protected Map.Entry&lt;Range&lt;Token&gt;, T&gt; computeNext()
        {
<span class="fc bfc" id="L159" title="All 4 branches covered.">            while (currentIter == null || !currentIter.hasNext())</span>
            {
<span class="fc bfc" id="L161" title="All 2 branches covered.">                if (!iterators.hasNext())</span>
<span class="fc" id="L162">                    return endOfData();</span>
<span class="fc" id="L163">                currentIter = iterators.next();</span>
            }
<span class="fc" id="L165">            return currentIter.next();</span>
        }
    }

    private class IntersectingIterator extends AbstractIterator&lt;Map.Entry&lt;Range&lt;Token&gt;, T&gt;&gt;
    {
        private final Iterator&lt;Map.Entry&lt;Range&lt;Token&gt;, T&gt;&gt; tailIterator;
        private final Range&lt;Token&gt; range;
        // since we guarantee no ranges overlap in byStart, we know the last entry is possibly the wrap around range
<span class="fc" id="L174">        private boolean shouldReturnLast = false;</span>

        public IntersectingIterator(Range&lt;Token&gt; range)
<span class="fc" id="L177">        {</span>
<span class="fc" id="L178">            Range&lt;Token&gt; startKey = byStart.floorKey(range);</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">            tailIterator = startKey == null ? byStart.entrySet().iterator() :</span>
<span class="fc" id="L180">                                              byStart.tailMap(startKey, true).entrySet().iterator();</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">            Range&lt;Token&gt; last = byStart.isEmpty() ? null : byStart.lastKey();</span>
<span class="fc bfc" id="L182" title="All 6 branches covered.">            if (last != null &amp;&amp; last.isWrapAround() &amp;&amp; last.intersects(range))</span>
<span class="fc" id="L183">                shouldReturnLast = true;</span>
<span class="fc" id="L184">            this.range = range;</span>
<span class="fc" id="L185">        }</span>

        protected Map.Entry&lt;Range&lt;Token&gt;, T&gt; computeNext()
        {
<span class="fc bfc" id="L189" title="All 2 branches covered.">            if (shouldReturnLast)</span>
            {
<span class="fc" id="L191">                shouldReturnLast = false;</span>
<span class="fc" id="L192">                return new Entry&lt;&gt;(byStart.lastEntry());</span>
            }
<span class="fc bfc" id="L194" title="All 2 branches covered.">            while (tailIterator.hasNext())</span>
            {
<span class="fc" id="L196">                Entry&lt;Range&lt;Token&gt;, T&gt; candidateNext = new Entry&lt;&gt;(tailIterator.next());</span>
<span class="fc" id="L197">                Range&lt;Token&gt; candidateRange = candidateNext.getKey();</span>

<span class="fc bfc" id="L199" title="All 2 branches covered.">                if (candidateRange.isWrapAround()) // we know we already returned any wrapping range</span>
<span class="fc" id="L200">                    continue;</span>

<span class="fc bfc" id="L202" title="All 4 branches covered.">                if (candidateRange.left.compareTo(range.right) &gt;= 0 &amp;&amp; (!range.isWrapAround())) // range is unwrapped, but that means one range has right == min token and is still wrapping</span>
<span class="fc" id="L203">                    return endOfData();</span>

<span class="fc bfc" id="L205" title="All 2 branches covered.">                if (range.left.compareTo(candidateRange.right) &gt;= 0)</span>
<span class="fc" id="L206">                    continue;</span>

<span class="fc" id="L208">                return candidateNext;</span>
            }
<span class="fc" id="L210">            return endOfData();</span>
        }
    }

    public String toString()
    {
<span class="nc" id="L216">        return byStart.toString();</span>
    }

    static class Entry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt;
    {
        private final V v;
        private final K k;

        Entry(K key, V val)
<span class="fc" id="L225">        {</span>
<span class="fc" id="L226">            this.k = key;</span>
<span class="fc" id="L227">            this.v = val;</span>
<span class="fc" id="L228">        }</span>

        Entry(Map.Entry&lt;K, V&gt; toClone)
        {
<span class="fc" id="L232">            this(toClone.getKey(), toClone.getValue());</span>
<span class="fc" id="L233">        }</span>
        public K getKey()
        {
<span class="fc" id="L236">            return k;</span>
        }

        public V getValue()
        {
<span class="fc" id="L241">            return v;</span>
        }

        public V setValue(V value)
        {
<span class="nc" id="L246">            throw new UnsupportedOperationException();</span>
        }

        public boolean equals(Object o)
        {
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">            if (this == o) return true;</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">            if (!(o instanceof Map.Entry)) return false;</span>
<span class="fc" id="L253">            Map.Entry&lt;?, ?&gt; entry = (Map.Entry&lt;?, ?&gt;) o;</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">            return v.equals(entry.getValue()) &amp;&amp;</span>
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">                   k.equals(entry.getKey());</span>
        }

        public int hashCode()
        {
<span class="fc" id="L260">            return Objects.hash(v, k);</span>
        }

        public String toString()
        {
<span class="nc" id="L265">            return &quot;Entry{&quot; +</span>
                   &quot;v=&quot; + v +
                   &quot;, k=&quot; + k +
                   '}';
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>