<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractAllocatorMemtable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.memtable</a> &gt; <span class="el_source">AbstractAllocatorMemtable.java</span></div><h1>AbstractAllocatorMemtable.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.db.memtable;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

import com.google.common.annotations.VisibleForTesting;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.concurrent.ImmediateExecutor;
import org.apache.cassandra.concurrent.ScheduledExecutors;
import org.apache.cassandra.config.Config;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.ClusteringComparator;
import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.commitlog.CommitLogPosition;
import org.apache.cassandra.schema.TableMetadataRef;
import org.apache.cassandra.utils.Clock;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.WrappedRunnable;
import org.apache.cassandra.utils.concurrent.AsyncPromise;
import org.apache.cassandra.utils.concurrent.Future;
import org.apache.cassandra.utils.concurrent.OpOrder;
import org.apache.cassandra.utils.concurrent.Promise;
import org.apache.cassandra.utils.memory.HeapPool;
import org.apache.cassandra.utils.memory.MemtableAllocator;
import org.apache.cassandra.utils.memory.MemtableCleaner;
import org.apache.cassandra.utils.memory.MemtablePool;
import org.apache.cassandra.utils.memory.NativePool;
import org.apache.cassandra.utils.memory.SlabPool;
import org.github.jamm.Unmetered;

/**
 * A memtable that uses memory tracked and maybe allocated via a MemtableAllocator from a MemtablePool.
 * Provides methods of memory tracking and triggering flushes when the relevant limits are reached.
 */
public abstract class AbstractAllocatorMemtable extends AbstractMemtableWithCommitlog
{
<span class="fc" id="L57">    private static final Logger logger = LoggerFactory.getLogger(AbstractAllocatorMemtable.class);</span>

<span class="fc" id="L59">    public static final MemtablePool MEMORY_POOL = AbstractAllocatorMemtable.createMemtableAllocatorPool();</span>

    @Unmetered
    protected final Owner owner;
    @Unmetered  // total pool size should not be included in memtable's deep size
    protected final MemtableAllocator allocator;

    // Record the comparator of the CFS at the creation of the memtable. This
    // is only used when a user update the CF comparator, to know if the
    // memtable was created with the new or old comparator.
    @Unmetered
    protected final ClusteringComparator initialComparator;
    // As above, used to determine if the memtable needs to be flushed on schema change.
    @Unmetered
    public final Factory initialFactory;

<span class="fc" id="L75">    private final long creationNano = Clock.Global.nanoTime();</span>

    @VisibleForTesting
    static MemtablePool createMemtableAllocatorPool()
    {
<span class="fc" id="L80">        Config.MemtableAllocationType allocationType = DatabaseDescriptor.getMemtableAllocationType();</span>
<span class="fc" id="L81">        long heapLimit = DatabaseDescriptor.getMemtableHeapSpaceInMiB() &lt;&lt; 20;</span>
<span class="fc" id="L82">        long offHeapLimit = DatabaseDescriptor.getMemtableOffheapSpaceInMiB() &lt;&lt; 20;</span>
<span class="fc" id="L83">        float memtableCleanupThreshold = DatabaseDescriptor.getMemtableCleanupThreshold();</span>
<span class="fc" id="L84">        MemtableCleaner cleaner = AbstractAllocatorMemtable::flushLargestMemtable;</span>
<span class="fc" id="L85">        return createMemtableAllocatorPoolInternal(allocationType, heapLimit, offHeapLimit, memtableCleanupThreshold, cleaner);</span>
    }

    @VisibleForTesting
    public static MemtablePool createMemtableAllocatorPoolInternal(Config.MemtableAllocationType allocationType,
                                                                   long heapLimit, long offHeapLimit,
                                                                   float memtableCleanupThreshold, MemtableCleaner cleaner)
    {
<span class="pc bpc" id="L93" title="1 of 6 branches missed.">        switch (allocationType)</span>
        {
        case unslabbed_heap_buffers_logged:
<span class="fc" id="L96">            return new HeapPool.Logged(heapLimit, memtableCleanupThreshold, cleaner);</span>
        case unslabbed_heap_buffers:
<span class="fc" id="L98">            logger.debug(&quot;Memtables allocating with on-heap buffers&quot;);</span>
<span class="fc" id="L99">            return new HeapPool(heapLimit, memtableCleanupThreshold, cleaner);</span>
        case heap_buffers:
<span class="fc" id="L101">            logger.debug(&quot;Memtables allocating with on-heap slabs&quot;);</span>
<span class="fc" id="L102">            return new SlabPool(heapLimit, 0, memtableCleanupThreshold, cleaner);</span>
        case offheap_buffers:
<span class="fc" id="L104">            logger.debug(&quot;Memtables allocating with off-heap buffers&quot;);</span>
<span class="fc" id="L105">            return new SlabPool(heapLimit, offHeapLimit, memtableCleanupThreshold, cleaner);</span>
        case offheap_objects:
<span class="fc" id="L107">            logger.debug(&quot;Memtables allocating with off-heap objects&quot;);</span>
<span class="fc" id="L108">            return new NativePool(heapLimit, offHeapLimit, memtableCleanupThreshold, cleaner);</span>
        default:
<span class="nc" id="L110">            throw new AssertionError();</span>
        }
    }

    // only to be used by init(), to setup the very first memtable for the cfs
    public AbstractAllocatorMemtable(AtomicReference&lt;CommitLogPosition&gt; commitLogLowerBound, TableMetadataRef metadataRef, Owner owner)
    {
<span class="fc" id="L117">        super(metadataRef, commitLogLowerBound);</span>
<span class="fc" id="L118">        this.allocator = MEMORY_POOL.newAllocator(metadataRef.toString());</span>
<span class="fc" id="L119">        this.initialComparator = metadata.get().comparator;</span>
<span class="fc" id="L120">        this.initialFactory = metadata().params.memtable.factory();</span>
<span class="fc" id="L121">        this.owner = owner;</span>
<span class="fc" id="L122">        scheduleFlush();</span>
<span class="fc" id="L123">    }</span>

    public MemtableAllocator getAllocator()
    {
<span class="fc" id="L127">        return allocator;</span>
    }

    @Override
    public boolean shouldSwitch(ColumnFamilyStore.FlushReason reason)
    {
<span class="fc bfc" id="L133" title="All 3 branches covered.">        switch (reason)</span>
        {
        case SCHEMA_CHANGE:
<span class="fc bfc" id="L136" title="All 2 branches covered.">            return initialComparator != metadata().comparator // If the CF comparator has changed, because our partitions reference the old one</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">                   || !initialFactory.equals(metadata().params.memtable.factory()); // If a different type of memtable is requested</span>
        case OWNED_RANGES_CHANGE:
<span class="fc" id="L139">            return false; // by default we don't use the local ranges, thus this has no effect</span>
        default:
<span class="fc" id="L141">            return true;</span>
        }
    }

    public void metadataUpdated()
    {
        // We decided not to swap out this memtable, but if the flush period has changed we must schedule it for the
        // new expiration time.
<span class="fc" id="L149">        scheduleFlush();</span>
<span class="fc" id="L150">    }</span>

    public void localRangesUpdated()
    {
        // nothing to be done by default
<span class="fc" id="L155">    }</span>

    public void performSnapshot(String snapshotName)
    {
<span class="nc" id="L159">        throw new AssertionError(&quot;performSnapshot must be implemented if shouldSwitch(SNAPSHOT) can return false.&quot;);</span>
    }

    public void switchOut(OpOrder.Barrier writeBarrier, AtomicReference&lt;CommitLogPosition&gt; commitLogUpperBound)
    {
<span class="fc" id="L164">        super.switchOut(writeBarrier, commitLogUpperBound);</span>
<span class="fc" id="L165">        allocator.setDiscarding();</span>
<span class="fc" id="L166">    }</span>

    public void discard()
    {
<span class="fc" id="L170">        super.discard();</span>
<span class="fc" id="L171">        allocator.setDiscarded();</span>
<span class="fc" id="L172">    }</span>

    public String toString()
    {
<span class="fc" id="L176">        MemoryUsage usage = Memtable.getMemoryUsage(this);</span>
<span class="fc" id="L177">        return String.format(&quot;Memtable-%s@%s(%s serialized bytes, %s ops, %s)&quot;,</span>
<span class="fc" id="L178">                             metadata.get().name,</span>
<span class="fc" id="L179">                             hashCode(),</span>
<span class="fc" id="L180">                             FBUtilities.prettyPrintMemory(getLiveDataSize()),</span>
<span class="fc" id="L181">                             operationCount(),</span>
                             usage);
    }

    @Override
    public void addMemoryUsageTo(MemoryUsage stats)
    {
<span class="fc" id="L188">        stats.ownershipRatioOnHeap += getAllocator().onHeap().ownershipRatio();</span>
<span class="fc" id="L189">        stats.ownershipRatioOffHeap += getAllocator().offHeap().ownershipRatio();</span>
<span class="fc" id="L190">        stats.ownsOnHeap += getAllocator().onHeap().owns();</span>
<span class="fc" id="L191">        stats.ownsOffHeap += getAllocator().offHeap().owns();</span>
<span class="fc" id="L192">    }</span>

    public void markExtraOnHeapUsed(long additionalSpace, OpOrder.Group opGroup)
    {
<span class="fc" id="L196">        getAllocator().onHeap().allocate(additionalSpace, opGroup);</span>
<span class="fc" id="L197">    }</span>

    public void markExtraOffHeapUsed(long additionalSpace, OpOrder.Group opGroup)
    {
<span class="nc" id="L201">        getAllocator().offHeap().allocate(additionalSpace, opGroup);</span>
<span class="nc" id="L202">    }</span>

    void scheduleFlush()
    {
<span class="fc" id="L206">        int period = metadata().params.memtableFlushPeriodInMs;</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if (period &gt; 0)</span>
<span class="fc" id="L208">            scheduleFlush(owner, period);</span>
<span class="fc" id="L209">    }</span>

    private static void scheduleFlush(Owner owner, int period)
    {
<span class="fc" id="L213">        logger.trace(&quot;scheduling flush in {} ms&quot;, period);</span>
<span class="fc" id="L214">        WrappedRunnable runnable = new WrappedRunnable()</span>
<span class="fc" id="L215">        {</span>
            protected void runMayThrow()
            {
<span class="fc" id="L218">                Memtable current = owner.getCurrentMemtable();</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">                if (current instanceof AbstractAllocatorMemtable)</span>
<span class="fc" id="L220">                    ((AbstractAllocatorMemtable) current).flushIfPeriodExpired();</span>
<span class="fc" id="L221">            }</span>
        };
<span class="fc" id="L223">        ScheduledExecutors.scheduledTasks.scheduleSelfRecurring(runnable, period, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L224">    }</span>

    private void flushIfPeriodExpired()
    {
<span class="fc" id="L228">        int period = metadata().params.memtableFlushPeriodInMs;</span>
<span class="pc bpc" id="L229" title="2 of 4 branches missed.">        if (period &gt; 0 &amp;&amp; (Clock.Global.nanoTime() - creationNano &gt;= TimeUnit.MILLISECONDS.toNanos(period)))</span>
        {
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">            if (isClean())</span>
            {
                // if we're still clean, instead of swapping just reschedule a flush for later
<span class="fc" id="L234">                scheduleFlush(owner, period);</span>
            }
            else
            {
                // we'll be rescheduled by the constructor of the Memtable.
<span class="nc" id="L239">                owner.signalFlushRequired(AbstractAllocatorMemtable.this,</span>
                                          ColumnFamilyStore.FlushReason.MEMTABLE_PERIOD_EXPIRED);
            }
        }
<span class="fc" id="L243">    }</span>

    /**
     * Finds the largest memtable, as a percentage of *either* on- or off-heap memory limits, and immediately
     * queues it for flushing. If the memtable selected is flushed before this completes, no work is done.
     */
    public static Future&lt;Boolean&gt; flushLargestMemtable()
    {
<span class="fc" id="L251">        float largestRatio = 0f;</span>
<span class="fc" id="L252">        AbstractAllocatorMemtable largestMemtable = null;</span>
<span class="fc" id="L253">        Memtable.MemoryUsage largestUsage = null;</span>
<span class="fc" id="L254">        float liveOnHeap = 0, liveOffHeap = 0;</span>
        // we take a reference to the current main memtable for the CF prior to snapping its ownership ratios
        // to ensure we have some ordering guarantee for performing the switchMemtableIf(), i.e. we will only
        // swap if the memtables we are measuring here haven't already been swapped by the time we try to swap them
<span class="fc bfc" id="L258" title="All 2 branches covered.">        for (Memtable currentMemtable : ColumnFamilyStore.activeMemtables())</span>
        {
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">            if (!(currentMemtable instanceof AbstractAllocatorMemtable))</span>
<span class="nc" id="L261">                continue;</span>
<span class="fc" id="L262">            AbstractAllocatorMemtable current = (AbstractAllocatorMemtable) currentMemtable;</span>

            // find the total ownership ratio for the memtable and all SecondaryIndexes owned by this CF,
            // both on- and off-heap, and select the largest of the two ratios to weight this CF
<span class="fc" id="L266">            MemoryUsage usage = Memtable.newMemoryUsage();</span>
<span class="fc" id="L267">            current.addMemoryUsageTo(usage);</span>

<span class="fc bfc" id="L269" title="All 2 branches covered.">            for (Memtable indexMemtable : current.owner.getIndexMemtables())</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">                if (indexMemtable instanceof AbstractAllocatorMemtable)</span>
<span class="fc" id="L271">                    indexMemtable.addMemoryUsageTo(usage);</span>

<span class="fc" id="L273">            float ratio = Math.max(usage.ownershipRatioOnHeap, usage.ownershipRatioOffHeap);</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">            if (ratio &gt; largestRatio)</span>
            {
<span class="fc" id="L276">                largestMemtable = current;</span>
<span class="fc" id="L277">                largestUsage = usage;</span>
<span class="fc" id="L278">                largestRatio = ratio;</span>
            }

<span class="fc" id="L281">            liveOnHeap += usage.ownershipRatioOnHeap;</span>
<span class="fc" id="L282">            liveOffHeap += usage.ownershipRatioOffHeap;</span>
<span class="fc" id="L283">        }</span>

<span class="fc" id="L285">        Promise&lt;Boolean&gt; returnFuture = new AsyncPromise&lt;&gt;();</span>

<span class="pc bpc" id="L287" title="1 of 2 branches missed.">        if (largestMemtable != null)</span>
        {
<span class="fc" id="L289">            float usedOnHeap = MEMORY_POOL.onHeap.usedRatio();</span>
<span class="fc" id="L290">            float usedOffHeap = MEMORY_POOL.offHeap.usedRatio();</span>
<span class="fc" id="L291">            float flushingOnHeap = MEMORY_POOL.onHeap.reclaimingRatio();</span>
<span class="fc" id="L292">            float flushingOffHeap = MEMORY_POOL.offHeap.reclaimingRatio();</span>
<span class="fc" id="L293">            logger.info(&quot;Flushing largest {} to free up room. Used total: {}, live: {}, flushing: {}, this: {}&quot;,</span>
<span class="fc" id="L294">                        largestMemtable.owner, ratio(usedOnHeap, usedOffHeap), ratio(liveOnHeap, liveOffHeap),</span>
<span class="fc" id="L295">                        ratio(flushingOnHeap, flushingOffHeap), ratio(largestUsage.ownershipRatioOnHeap, largestUsage.ownershipRatioOffHeap));</span>

<span class="fc" id="L297">            Future&lt;CommitLogPosition&gt; flushFuture = largestMemtable.owner.signalFlushRequired(largestMemtable, ColumnFamilyStore.FlushReason.MEMTABLE_LIMIT);</span>
<span class="fc" id="L298">            flushFuture.addListener(() -&gt; {</span>
                try
                {
<span class="fc" id="L301">                    flushFuture.get();</span>
<span class="fc" id="L302">                    returnFuture.trySuccess(true);</span>
                }
<span class="nc" id="L304">                catch (Throwable t)</span>
                {
<span class="nc" id="L306">                    returnFuture.tryFailure(t);</span>
<span class="fc" id="L307">                }</span>
<span class="fc" id="L308">            }, ImmediateExecutor.INSTANCE);</span>
<span class="fc" id="L309">        }</span>
        else
        {
<span class="nc" id="L312">            logger.debug(&quot;Flushing of largest memtable, not done, no memtable found&quot;);</span>

<span class="nc" id="L314">            returnFuture.trySuccess(false);</span>
        }

<span class="fc" id="L317">        return returnFuture;</span>
    }

    private static String ratio(float onHeap, float offHeap)
    {
<span class="fc" id="L322">        return String.format(&quot;%.2f/%.2f&quot;, onHeap, offHeap);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>