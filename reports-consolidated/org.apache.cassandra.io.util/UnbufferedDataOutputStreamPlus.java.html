<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UnbufferedDataOutputStreamPlus.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.io.util</a> &gt; <span class="el_source">UnbufferedDataOutputStreamPlus.java</span></div><h1>UnbufferedDataOutputStreamPlus.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.io.util;

import java.io.DataOutput;
import java.io.IOException;
import java.io.UTFDataFormatException;
import java.nio.ByteBuffer;
import java.nio.channels.WritableByteChannel;

import org.apache.cassandra.utils.memory.MemoryUtil;

/**
 * Base class for DataOutput implementations that does not have an optimized implementations of Plus methods
 * and does no buffering.
 * &lt;p&gt;
 * Unlike BufferedDataOutputStreamPlus this is capable of operating as an unbuffered output stream.
 * Currently necessary because SequentialWriter implements its own buffering along with mark/reset/truncate.
 * &lt;/p&gt;
 */
public abstract class UnbufferedDataOutputStreamPlus extends DataOutputStreamPlus
{
<span class="fc" id="L38">    private static final byte[] zeroBytes = new byte[2];</span>

    protected UnbufferedDataOutputStreamPlus()
    {
<span class="fc" id="L42">        super();</span>
<span class="fc" id="L43">    }</span>

    protected UnbufferedDataOutputStreamPlus(WritableByteChannel channel)
    {
<span class="nc" id="L47">        super(channel);</span>
<span class="nc" id="L48">    }</span>

    /*
    !! DataOutput methods below are copied from the implementation in Apache Harmony RandomAccessFile.
    */

    /**
     * Writes the entire contents of the byte array &lt;code&gt;buffer&lt;/code&gt; to
     * this RandomAccessFile starting at the current file pointer.
     *
     * @param buffer the buffer to be written.
     * @throws IOException If an error occurs trying to write to this RandomAccessFile.
     */
    public void write(byte[] buffer) throws IOException
    {
<span class="fc" id="L63">        write(buffer, 0, buffer.length);</span>
<span class="fc" id="L64">    }</span>

    /**
     * Writes &lt;code&gt;count&lt;/code&gt; bytes from the byte array &lt;code&gt;buffer&lt;/code&gt;
     * starting at &lt;code&gt;offset&lt;/code&gt; to this RandomAccessFile starting at
     * the current file pointer..
     *
     * @param buffer the bytes to be written
     * @param offset offset in buffer to get bytes
     * @param count  number of bytes in buffer to write
     * @throws IOException               If an error occurs attempting to write to this
     *                                   RandomAccessFile.
     * @throws IndexOutOfBoundsException If offset or count are outside of bounds.
     */
    public abstract void write(byte[] buffer, int offset, int count) throws IOException;

    /**
     * Writes the specified byte &lt;code&gt;oneByte&lt;/code&gt; to this RandomAccessFile
     * starting at the current file pointer. Only the low order byte of
     * &lt;code&gt;oneByte&lt;/code&gt; is written.
     *
     * @param oneByte the byte to be written
     * @throws IOException If an error occurs attempting to write to this
     *                     RandomAccessFile.
     */
    public abstract void write(int oneByte) throws IOException;

    /**
     * Writes a boolean to this output stream.
     *
     * @param val the boolean value to write to the OutputStream
     * @throws IOException If an error occurs attempting to write to this
     *                     DataOutputStream.
     */
    public final void writeBoolean(boolean val) throws IOException
    {
<span class="fc bfc" id="L100" title="All 2 branches covered.">        write(val ? 1 : 0);</span>
<span class="fc" id="L101">    }</span>

    /**
     * Writes a 8-bit byte to this output stream.
     *
     * @param val the byte value to write to the OutputStream
     * @throws java.io.IOException If an error occurs attempting to write to this
     *                             DataOutputStream.
     */
    public final void writeByte(int val) throws IOException
    {
<span class="fc" id="L112">        write(val &amp; 0xFF);</span>
<span class="fc" id="L113">    }</span>

    /**
     * Writes the low order 8-bit bytes from a String to this output stream.
     *
     * @param str the String containing the bytes to write to the OutputStream
     * @throws IOException If an error occurs attempting to write to this
     *                     DataOutputStream.
     */
    public final void writeBytes(String str) throws IOException
    {
<span class="fc" id="L124">        byte bytes[] = new byte[str.length()];</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">        for (int index = 0; index &lt; str.length(); index++)</span>
        {
<span class="fc" id="L127">            bytes[index] = (byte) (str.charAt(index) &amp; 0xFF);</span>
        }
<span class="fc" id="L129">        write(bytes);</span>
<span class="fc" id="L130">    }</span>

    /**
     * Writes the specified 16-bit character to the OutputStream. Only the lower
     * 2 bytes are written with the higher of the 2 bytes written first. This
     * represents the Unicode value of val.
     *
     * @param val the character to be written
     * @throws IOException If an error occurs attempting to write to this
     *                     DataOutputStream.
     */
    public final void writeChar(int val) throws IOException
    {
<span class="fc" id="L143">        write((val &gt;&gt;&gt; 8) &amp; 0xFF);</span>
<span class="fc" id="L144">        write((val &gt;&gt;&gt; 0) &amp; 0xFF);</span>
<span class="fc" id="L145">    }</span>

    /**
     * Writes the specified 16-bit characters contained in str to the
     * OutputStream. Only the lower 2 bytes of each character are written with
     * the higher of the 2 bytes written first. This represents the Unicode
     * value of each character in str.
     *
     * @param str the String whose characters are to be written.
     * @throws IOException If an error occurs attempting to write to this
     *                     DataOutputStream.
     */
    public final void writeChars(String str) throws IOException
    {
<span class="fc" id="L159">        byte newBytes[] = new byte[str.length() * 2];</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">        for (int index = 0; index &lt; str.length(); index++)</span>
        {
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">            int newIndex = index == 0 ? index : index * 2;</span>
<span class="fc" id="L163">            newBytes[newIndex] = (byte) ((str.charAt(index) &gt;&gt; 8) &amp; 0xFF);</span>
<span class="fc" id="L164">            newBytes[newIndex + 1] = (byte) (str.charAt(index) &amp; 0xFF);</span>
        }
<span class="fc" id="L166">        write(newBytes);</span>
<span class="fc" id="L167">    }</span>

    /**
     * Writes a 64-bit double to this output stream. The resulting output is the
     * 8 bytes resulting from calling Double.doubleToLongBits().
     *
     * @param val the double to be written.
     * @throws IOException If an error occurs attempting to write to this
     *                     DataOutputStream.
     */
    public final void writeDouble(double val) throws IOException
    {
<span class="fc" id="L179">        writeLong(Double.doubleToLongBits(val));</span>
<span class="fc" id="L180">    }</span>

    /**
     * Writes a 32-bit float to this output stream. The resulting output is the
     * 4 bytes resulting from calling Float.floatToIntBits().
     *
     * @param val the float to be written.
     * @throws IOException If an error occurs attempting to write to this
     *                     DataOutputStream.
     */
    public final void writeFloat(float val) throws IOException
    {
<span class="fc" id="L192">        writeInt(Float.floatToIntBits(val));</span>
<span class="fc" id="L193">    }</span>

    /**
     * Writes a 32-bit int to this output stream. The resulting output is the 4
     * bytes, highest order first, of val.
     *
     * @param val the int to be written.
     * @throws IOException If an error occurs attempting to write to this
     *                     DataOutputStream.
     */
    public void writeInt(int val) throws IOException
    {
<span class="fc" id="L205">        write((val &gt;&gt;&gt; 24) &amp; 0xFF);</span>
<span class="fc" id="L206">        write((val &gt;&gt;&gt; 16) &amp; 0xFF);</span>
<span class="fc" id="L207">        write((val &gt;&gt;&gt; 8) &amp; 0xFF);</span>
<span class="fc" id="L208">        write((val &gt;&gt;&gt; 0) &amp; 0xFF);</span>
<span class="fc" id="L209">    }</span>

    /**
     * Writes a 64-bit long to this output stream. The resulting output is the 8
     * bytes, highest order first, of val.
     *
     * @param val the long to be written.
     * @throws IOException If an error occurs attempting to write to this
     *                     DataOutputStream.
     */
    public void writeLong(long val) throws IOException
    {
<span class="fc" id="L221">        write((int) (val &gt;&gt;&gt; 56) &amp; 0xFF);</span>
<span class="fc" id="L222">        write((int) (val &gt;&gt;&gt; 48) &amp; 0xFF);</span>
<span class="fc" id="L223">        write((int) (val &gt;&gt;&gt; 40) &amp; 0xFF);</span>
<span class="fc" id="L224">        write((int) (val &gt;&gt;&gt; 32) &amp; 0xFF);</span>
<span class="fc" id="L225">        write((int) (val &gt;&gt;&gt; 24) &amp; 0xFF);</span>
<span class="fc" id="L226">        write((int) (val &gt;&gt;&gt; 16) &amp; 0xFF);</span>
<span class="fc" id="L227">        write((int) (val &gt;&gt;&gt; 8) &amp; 0xFF);</span>
<span class="fc" id="L228">        write((int) (val &gt;&gt;&gt; 0) &amp; 0xFF);</span>
<span class="fc" id="L229">    }</span>

    /**
     * Writes the specified 16-bit short to the OutputStream. Only the lower 2
     * bytes are written with the higher of the 2 bytes written first.
     *
     * @param val the short to be written
     * @throws IOException If an error occurs attempting to write to this
     *                     DataOutputStream.
     */
    public void writeShort(int val) throws IOException
    {
<span class="fc" id="L241">        writeChar(val);</span>
<span class="fc" id="L242">    }</span>

    /**
     * Writes the specified String out in UTF format to the provided DataOutput
     *
     * @param str the String to be written in UTF format.
     * @param out the DataOutput to write the UTF encoded string to
     * @throws IOException If an error occurs attempting to write to this
     *                     DataOutputStream.
     */
    public static void writeUTF(String str, DataOutput out) throws IOException
    {
<span class="fc" id="L254">        int length = str.length();</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">        if (length == 0)</span>
        {
<span class="fc" id="L257">            out.write(zeroBytes);</span>
<span class="fc" id="L258">            return;</span>
        }

<span class="fc" id="L261">        int utfCount = 0;</span>
<span class="fc" id="L262">        int maxSize = 2;</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">        for (int i = 0 ; i &lt; length ; i++)</span>
        {
<span class="fc" id="L265">            int ch = str.charAt(i);</span>
<span class="fc bfc" id="L266" title="All 6 branches covered.">            if ((ch &gt; 0) &amp; (ch &lt;= 127))</span>
<span class="fc" id="L267">                utfCount += 1;</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">            else if (ch &lt;= 2047)</span>
<span class="fc" id="L269">                utfCount += 2;</span>
            else
<span class="fc" id="L271">                utfCount += maxSize = 3;</span>
        }

<span class="pc bpc" id="L274" title="1 of 2 branches missed.">        if (utfCount &gt; 65535)</span>
<span class="nc" id="L275">            throw new UTFDataFormatException(); //$NON-NLS-1$</span>

<span class="fc" id="L277">        byte[] utfBytes = retrieveTemporaryBuffer(utfCount + 2);</span>

<span class="fc" id="L279">        int bufferLength = utfBytes.length;</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">        if (utfCount == length)</span>
        {
<span class="fc" id="L282">            utfBytes[0] = (byte) (utfCount &gt;&gt; 8);</span>
<span class="fc" id="L283">            utfBytes[1] = (byte) utfCount;</span>
<span class="fc" id="L284">            int firstIndex = 2;</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">            for (int offset = 0 ; offset &lt; length ; offset += bufferLength)</span>
            {
<span class="fc" id="L287">                int runLength = Math.min(bufferLength - firstIndex, length - offset) + firstIndex;</span>
<span class="fc" id="L288">                offset -= firstIndex;</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">                for (int i = firstIndex ; i &lt; runLength; i++)</span>
<span class="fc" id="L290">                    utfBytes[i] = (byte) str.charAt(offset + i);</span>
<span class="fc" id="L291">                out.write(utfBytes, 0, runLength);</span>
<span class="fc" id="L292">                firstIndex = 0;</span>
            }
<span class="fc" id="L294">        }</span>
        else
        {
<span class="fc" id="L297">            int utfIndex = 2;</span>
<span class="fc" id="L298">            int offset = 0;</span>
<span class="fc" id="L299">            utfBytes[0] = (byte) (utfCount &gt;&gt; 8);</span>
<span class="fc" id="L300">            utfBytes[1] = (byte) utfCount;</span>

<span class="fc bfc" id="L302" title="All 2 branches covered.">            while (length &gt; 0)</span>
            {
<span class="fc" id="L304">                int charRunLength = (utfBytes.length - utfIndex) / maxSize;</span>
<span class="fc bfc" id="L305" title="All 4 branches covered.">                if (charRunLength &lt; 128 &amp;&amp; charRunLength &lt; length)</span>
                {
<span class="fc" id="L307">                    out.write(utfBytes, 0, utfIndex);</span>
<span class="fc" id="L308">                    utfIndex = 0;</span>
                }
<span class="fc bfc" id="L310" title="All 2 branches covered.">                if (charRunLength &gt; length)</span>
<span class="fc" id="L311">                    charRunLength = length;</span>

<span class="fc bfc" id="L313" title="All 2 branches covered.">                for (int i = 0 ; i &lt; charRunLength ; i++)</span>
                {
<span class="fc" id="L315">                    char ch = str.charAt(offset + i);</span>
<span class="fc bfc" id="L316" title="All 4 branches covered.">                    if ((ch &gt; 0) &amp;&amp; (ch &lt;= 127))</span>
                    {
<span class="fc" id="L318">                        utfBytes[utfIndex++] = (byte) ch;</span>
                    }
<span class="fc bfc" id="L320" title="All 2 branches covered.">                    else if (ch &lt;= 2047)</span>
                    {
<span class="fc" id="L322">                        utfBytes[utfIndex++] = (byte) (0xc0 | (0x1f &amp; (ch &gt;&gt; 6)));</span>
<span class="fc" id="L323">                        utfBytes[utfIndex++] = (byte) (0x80 | (0x3f &amp; ch));</span>
                    }
                    else
                    {
<span class="fc" id="L327">                        utfBytes[utfIndex++] = (byte) (0xe0 | (0x0f &amp; (ch &gt;&gt; 12)));</span>
<span class="fc" id="L328">                        utfBytes[utfIndex++] = (byte) (0x80 | (0x3f &amp; (ch &gt;&gt; 6)));</span>
<span class="fc" id="L329">                        utfBytes[utfIndex++] = (byte) (0x80 | (0x3f &amp; ch));</span>
                    }
                }

<span class="fc" id="L333">                offset += charRunLength;</span>
<span class="fc" id="L334">                length -= charRunLength;</span>
<span class="fc" id="L335">            }</span>

<span class="fc" id="L337">            out.write(utfBytes, 0, utfIndex);</span>
        }
<span class="fc" id="L339">    }</span>

    /**
     * Writes the specified String out in UTF format.
     *
     * @param str the String to be written in UTF format.
     * @throws IOException If an error occurs attempting to write to this
     *                     DataOutputStream.
     */
    public final void writeUTF(String str) throws IOException
    {
<span class="nc" id="L350">        writeUTF(str, this);</span>
<span class="nc" id="L351">    }</span>

    // ByteBuffer to use for defensive copies
<span class="pc" id="L354">    private final ByteBuffer hollowBufferD = MemoryUtil.getHollowDirectByteBuffer();</span>

    @Override
    public void write(ByteBuffer buf) throws IOException
    {
<span class="fc bfc" id="L359" title="All 2 branches covered.">        if (buf.hasArray())</span>
        {
<span class="fc" id="L361">            write(buf.array(), buf.arrayOffset() + buf.position(), buf.remaining());</span>
        }
        else
        {
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">            assert buf.isDirect();</span>
<span class="fc" id="L366">            MemoryUtil.duplicateDirectByteBuffer(buf, hollowBufferD);</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">            while (hollowBufferD.hasRemaining())</span>
<span class="fc" id="L368">                channel.write(hollowBufferD);</span>
        }
<span class="fc" id="L370">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>