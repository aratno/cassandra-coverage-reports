<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StreamCoordinator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.streaming</a> &gt; <span class="el_source">StreamCoordinator.java</span></div><h1>StreamCoordinator.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.streaming;

import java.net.InetSocketAddress;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

import com.google.common.annotations.VisibleForTesting;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.utils.TimeUUID;

import static org.apache.cassandra.net.MessagingService.current_version;


/**
 * {@link StreamCoordinator} is a helper class that abstracts away maintaining multiple
 * StreamSession and ProgressInfo instances per peer.
 *
 * This class coordinates multiple SessionStreams per peer in both the outgoing StreamPlan context and on the
 * inbound StreamResultFuture context.
 */
public class StreamCoordinator
{
<span class="fc" id="L43">    private static final Logger logger = LoggerFactory.getLogger(StreamCoordinator.class);</span>

    private final boolean connectSequentially;

<span class="fc" id="L47">    private final Map&lt;InetSocketAddress, HostStreamingData&gt; peerSessions = new ConcurrentHashMap&lt;&gt;();</span>
    private final StreamOperation streamOperation;
    private final int connectionsPerHost;
    private final boolean follower;
    private StreamingChannel.Factory factory;
<span class="fc" id="L52">    private Iterator&lt;StreamSession&gt; sessionsToConnect = null;</span>
    private final TimeUUID pendingRepair;
    private final PreviewKind previewKind;

    public StreamCoordinator(StreamOperation streamOperation, int connectionsPerHost, StreamingChannel.Factory factory,
                             boolean follower, boolean connectSequentially, TimeUUID pendingRepair, PreviewKind previewKind)
<span class="fc" id="L58">    {</span>
<span class="fc" id="L59">        this.streamOperation = streamOperation;</span>
<span class="fc" id="L60">        this.connectionsPerHost = connectionsPerHost;</span>
<span class="fc" id="L61">        this.factory = factory;</span>
<span class="fc" id="L62">        this.follower = follower;</span>
<span class="fc" id="L63">        this.connectSequentially = connectSequentially;</span>
<span class="fc" id="L64">        this.pendingRepair = pendingRepair;</span>
<span class="fc" id="L65">        this.previewKind = previewKind;</span>
<span class="fc" id="L66">    }</span>

    public void setConnectionFactory(StreamingChannel.Factory factory)
    {
<span class="fc" id="L70">        this.factory = factory;</span>
<span class="fc" id="L71">    }</span>

    /**
     * @return true if any stream session is active
     */
    public synchronized boolean hasActiveSessions()
    {
<span class="fc bfc" id="L78" title="All 2 branches covered.">        for (HostStreamingData data : peerSessions.values())</span>
        {
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">            if (data.hasActiveSessions())</span>
<span class="fc" id="L81">                return true;</span>
<span class="nc" id="L82">        }</span>
<span class="fc" id="L83">        return false;</span>
    }

    public synchronized Collection&lt;StreamSession&gt; getAllStreamSessions()
    {
<span class="fc" id="L88">        Collection&lt;StreamSession&gt; results = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">        for (HostStreamingData data : peerSessions.values())</span>
        {
<span class="fc" id="L91">            results.addAll(data.getAllStreamSessions());</span>
<span class="fc" id="L92">        }</span>
<span class="fc" id="L93">        return results;</span>
    }

    public boolean isFollower()
    {
<span class="fc" id="L98">        return follower;</span>
    }

    public void connect(StreamResultFuture future)
    {
<span class="fc bfc" id="L103" title="All 2 branches covered.">        if (this.connectSequentially)</span>
<span class="fc" id="L104">            connectSequentially(future);</span>
        else
<span class="fc" id="L106">            connectAllStreamSessions();</span>
<span class="fc" id="L107">    }</span>

    private void connectAllStreamSessions()
    {
<span class="fc bfc" id="L111" title="All 2 branches covered.">        for (HostStreamingData data : peerSessions.values())</span>
<span class="fc" id="L112">            data.connectAllStreamSessions();</span>
<span class="fc" id="L113">    }</span>

    private void connectSequentially(StreamResultFuture future)
    {
<span class="fc" id="L117">        sessionsToConnect = getAllStreamSessions().iterator();</span>
<span class="fc" id="L118">        future.addEventListener(new StreamEventHandler()</span>
<span class="fc" id="L119">        {</span>
            public void handleStreamEvent(StreamEvent event)
            {
<span class="fc bfc" id="L122" title="All 4 branches covered.">                if (event.eventType == StreamEvent.Type.STREAM_PREPARED || event.eventType == StreamEvent.Type.STREAM_COMPLETE)</span>
<span class="fc" id="L123">                    connectNext();</span>
<span class="fc" id="L124">            }</span>

            public void onSuccess(StreamState result)
            {

<span class="fc" id="L129">            }</span>

            public void onFailure(Throwable t)
            {

<span class="fc" id="L134">            }</span>
        });
<span class="fc" id="L136">        connectNext();</span>
<span class="fc" id="L137">    }</span>

    private void connectNext()
    {
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">        if (sessionsToConnect == null)</span>
<span class="nc" id="L142">            return;</span>

<span class="fc bfc" id="L144" title="All 2 branches covered.">        if (sessionsToConnect.hasNext())</span>
        {
<span class="fc" id="L146">            StreamSession next = sessionsToConnect.next();</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">            if (logger.isDebugEnabled())</span>
<span class="fc" id="L148">                logger.debug(&quot;Connecting next session {} with {}.&quot;, next.planId(), next.peer.toString());</span>
<span class="fc" id="L149">            startSession(next);</span>
<span class="fc" id="L150">        }</span>
        else
<span class="fc" id="L152">            logger.debug(&quot;Finished connecting all sessions&quot;);</span>
<span class="fc" id="L153">    }</span>

    public synchronized Set&lt;InetSocketAddress&gt; getPeers()
    {
<span class="fc" id="L157">        return new HashSet&lt;&gt;(peerSessions.keySet());</span>
    }

    public synchronized StreamSession getOrCreateOutboundSession(InetAddressAndPort peer)
    {
<span class="fc" id="L162">        return getOrCreateHostData(peer).getOrCreateOutboundSession(peer);</span>
    }

    public synchronized StreamSession getOrCreateInboundSession(InetAddressAndPort from, StreamingChannel channel, int messagingVersion, int id)
    {
<span class="fc" id="L167">        return getOrCreateHostData(from).getOrCreateInboundSession(from, channel, messagingVersion, id);</span>
    }

    public StreamSession getSessionById(InetAddressAndPort peer, int id)
    {
<span class="fc" id="L172">        return getHostData(peer).getSessionById(id);</span>
    }

    public synchronized void updateProgress(ProgressInfo info)
    {
<span class="fc" id="L177">        getHostData(info.peer).updateProgress(info);</span>
<span class="fc" id="L178">    }</span>

    public synchronized void addSessionInfo(SessionInfo session)
    {
<span class="fc" id="L182">        HostStreamingData data = getOrCreateHostData(session.peer);</span>
<span class="fc" id="L183">        data.addSessionInfo(session);</span>
<span class="fc" id="L184">    }</span>

    public synchronized Set&lt;SessionInfo&gt; getAllSessionInfo()
    {
<span class="fc" id="L188">        Set&lt;SessionInfo&gt; result = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">        for (HostStreamingData data : peerSessions.values())</span>
        {
<span class="fc" id="L191">            result.addAll(data.getAllSessionInfo());</span>
<span class="fc" id="L192">        }</span>
<span class="fc" id="L193">        return result;</span>
    }

    public synchronized void transferStreams(InetAddressAndPort to, Collection&lt;OutgoingStream&gt; streams)
    {
<span class="fc" id="L198">        HostStreamingData sessionList = getOrCreateHostData(to);</span>

<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        if (connectionsPerHost &gt; 1)</span>
        {
<span class="nc" id="L202">            List&lt;Collection&lt;OutgoingStream&gt;&gt; buckets = bucketStreams(streams);</span>

<span class="nc bnc" id="L204" title="All 2 branches missed.">            for (Collection&lt;OutgoingStream&gt; bucket : buckets)</span>
            {
<span class="nc" id="L206">                StreamSession session = sessionList.getOrCreateOutboundSession(to);</span>
<span class="nc" id="L207">                session.addTransferStreams(bucket);</span>
<span class="nc" id="L208">            }</span>
<span class="nc" id="L209">        }</span>
        else
        {
<span class="fc" id="L212">            StreamSession session = sessionList.getOrCreateOutboundSession(to);</span>
<span class="fc" id="L213">            session.addTransferStreams(streams);</span>
        }
<span class="fc" id="L215">    }</span>

    private List&lt;Collection&lt;OutgoingStream&gt;&gt; bucketStreams(Collection&lt;OutgoingStream&gt; streams)
    {
        // There's no point in divvying things up into more buckets than we have sstableDetails
<span class="nc" id="L220">        int targetSlices = Math.min(streams.size(), connectionsPerHost);</span>
<span class="nc" id="L221">        int step = Math.round((float) streams.size() / (float) targetSlices);</span>
<span class="nc" id="L222">        int index = 0;</span>

<span class="nc" id="L224">        List&lt;Collection&lt;OutgoingStream&gt;&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L225">        List&lt;OutgoingStream&gt; slice = null;</span>

<span class="nc bnc" id="L227" title="All 2 branches missed.">        for (OutgoingStream stream: streams)</span>
        {
<span class="nc bnc" id="L229" title="All 2 branches missed.">            if (index % step == 0)</span>
            {
<span class="nc" id="L231">                slice = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L232">                result.add(slice);</span>
            }
<span class="nc" id="L234">            slice.add(stream);</span>
<span class="nc" id="L235">            ++index;</span>
<span class="nc" id="L236">        }</span>
<span class="nc" id="L237">        return result;</span>
    }

    private HostStreamingData getHostData(InetAddressAndPort peer)
    {
<span class="fc" id="L242">        HostStreamingData data = peerSessions.get(peer);</span>

<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        if (data == null)</span>
<span class="nc" id="L245">            throw new IllegalArgumentException(&quot;Unknown peer requested: &quot; + peer);</span>
<span class="fc" id="L246">        return data;</span>
    }

    private HostStreamingData getOrCreateHostData(InetSocketAddress peer)
    {
<span class="fc" id="L251">        HostStreamingData data = peerSessions.get(peer);</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">        if (data == null)</span>
        {
<span class="fc" id="L254">            data = new HostStreamingData();</span>
<span class="fc" id="L255">            peerSessions.put(peer, data);</span>
        }
<span class="fc" id="L257">        return data;</span>
    }

    public TimeUUID getPendingRepair()
    {
<span class="fc" id="L262">        return pendingRepair;</span>
    }

    private void startSession(StreamSession session)
    {
<span class="fc" id="L267">        session.start();</span>
<span class="fc" id="L268">        logger.info(&quot;[Stream #{}, ID#{}] Beginning stream session with {}&quot;, session.planId(), session.sessionIndex(), session.peer);</span>
<span class="fc" id="L269">    }</span>

<span class="fc" id="L271">    private class HostStreamingData</span>
    {
<span class="fc" id="L273">        private final Map&lt;Integer, StreamSession&gt; streamSessions = new HashMap&lt;&gt;();</span>
<span class="fc" id="L274">        private final Map&lt;Integer, SessionInfo&gt; sessionInfos = new HashMap&lt;&gt;();</span>

<span class="fc" id="L276">        private int lastReturned = -1;</span>

        public boolean hasActiveSessions()
        {
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">            for (StreamSession session : streamSessions.values())</span>
            {
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">                if (!session.state().isFinalState())</span>
<span class="fc" id="L283">                    return true;</span>
<span class="nc" id="L284">            }</span>
<span class="nc" id="L285">            return false;</span>
        }

        public StreamSession getOrCreateOutboundSession(InetAddressAndPort peer)
        {
            // create
<span class="fc bfc" id="L291" title="All 2 branches covered.">            if (streamSessions.size() &lt; connectionsPerHost)</span>
            {
<span class="fc" id="L293">                StreamSession session = new StreamSession(streamOperation, peer, factory, null, current_version, isFollower(), streamSessions.size(),</span>
                                                          pendingRepair, previewKind);
<span class="fc" id="L295">                streamSessions.put(++lastReturned, session);</span>
<span class="fc" id="L296">                sessionInfos.put(lastReturned, session.getSessionInfo());</span>
<span class="fc" id="L297">                return session;</span>
            }
            // get
            else
            {
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">                if (lastReturned &gt;= streamSessions.size() - 1)</span>
<span class="fc" id="L303">                    lastReturned = 0;</span>

<span class="fc" id="L305">                return streamSessions.get(lastReturned++);</span>
            }
        }

        public void connectAllStreamSessions()
        {
<span class="fc bfc" id="L311" title="All 2 branches covered.">            for (StreamSession session : streamSessions.values())</span>
            {
<span class="fc" id="L313">                startSession(session);</span>
<span class="fc" id="L314">            }</span>
<span class="fc" id="L315">        }</span>

        public Collection&lt;StreamSession&gt; getAllStreamSessions()
        {
<span class="fc" id="L319">            return Collections.unmodifiableCollection(streamSessions.values());</span>
        }

        public StreamSession getOrCreateInboundSession(InetAddressAndPort from, StreamingChannel channel, int messagingVersion, int id)
        {
<span class="fc" id="L324">            StreamSession session = streamSessions.get(id);</span>
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">            if (session == null)</span>
            {
<span class="fc" id="L327">                session = new StreamSession(streamOperation, from, factory, channel, messagingVersion, isFollower(), id, pendingRepair, previewKind);</span>
<span class="fc" id="L328">                streamSessions.put(id, session);</span>
<span class="fc" id="L329">                sessionInfos.put(id, session.getSessionInfo());</span>
            }
<span class="fc" id="L331">            return session;</span>
        }

        public StreamSession getSessionById(int id)
        {
<span class="fc" id="L336">            return streamSessions.get(id);</span>
        }

        public void updateProgress(ProgressInfo info)
        {
<span class="fc" id="L341">            sessionInfos.get(info.sessionIndex).updateProgress(info);</span>
<span class="fc" id="L342">        }</span>

        public void addSessionInfo(SessionInfo info)
        {
<span class="fc" id="L346">            sessionInfos.put(info.sessionIndex, info);</span>
<span class="fc" id="L347">        }</span>

        public Collection&lt;SessionInfo&gt; getAllSessionInfo()
        {
<span class="fc" id="L351">            return sessionInfos.values();</span>
        }

        @VisibleForTesting
        public void shutdown()
        {
<span class="nc" id="L357">            streamSessions.values().forEach(ss -&gt; ss.sessionFailed());</span>
<span class="nc" id="L358">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>