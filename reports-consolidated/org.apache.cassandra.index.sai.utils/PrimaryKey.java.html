<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PrimaryKey.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.index.sai.utils</a> &gt; <span class="el_source">PrimaryKey.java</span></div><h1>PrimaryKey.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.index.sai.utils;

import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.Objects;

import java.util.stream.Collectors;

import org.apache.cassandra.db.BufferDecoratedKey;
import org.apache.cassandra.db.Clustering;
import org.apache.cassandra.db.ClusteringComparator;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.marshal.ByteBufferAccessor;
import org.apache.cassandra.dht.IPartitioner;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.bytecomparable.ByteComparable;
import org.apache.cassandra.utils.bytecomparable.ByteSource;
import org.apache.cassandra.utils.bytecomparable.ByteSourceInverse;

/**
 * Representation of the primary key for a row consisting of the {@link DecoratedKey} and
 * {@link Clustering} associated with a {@link org.apache.cassandra.db.rows.Row}.
 * The {@link Factory.TokenOnlyPrimaryKey} is used by the {@link org.apache.cassandra.index.sai.plan.StorageAttachedIndexSearcher} to
 * position the search within the query range.
 */
public interface PrimaryKey extends Comparable&lt;PrimaryKey&gt;, ByteComparable
{
    /**
     * See the javadoc for {@link #kind()} for how this enum is used.
      */
<span class="fc" id="L49">    enum Kind</span>
    {
<span class="fc" id="L51">        TOKEN(false),</span>
<span class="fc" id="L52">        SKINNY(false),</span>
<span class="fc" id="L53">        WIDE(true),</span>
<span class="fc" id="L54">        STATIC(true);</span>

        public final boolean hasClustering;

        Kind(boolean hasClustering)
<span class="fc" id="L59">        {</span>
<span class="fc" id="L60">            this.hasClustering = hasClustering;</span>
<span class="fc" id="L61">        }</span>
    }

<span class="fc" id="L64">    class Factory</span>
    {
        private final IPartitioner partitioner;
        private final ClusteringComparator clusteringComparator;

        public Factory(IPartitioner partitioner, ClusteringComparator clusteringComparator)
<span class="fc" id="L70">        {</span>
<span class="fc" id="L71">            this.partitioner = partitioner;</span>
<span class="fc" id="L72">            this.clusteringComparator = clusteringComparator;</span>
<span class="fc" id="L73">        }</span>

        /**
         * Creates a {@link PrimaryKey} that is represented by a {@link Token}.
         * &lt;p&gt;
         * {@link Token} only primary keys are used for defining the partition range
         * of a query.
         */
        public PrimaryKey create(Token token)
        {
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">            assert token != null : &quot;Cannot create a primary key with a null token&quot;;</span>

<span class="fc" id="L85">            return new TokenOnlyPrimaryKey(token);</span>
        }

        /**
         * Create a {@link PrimaryKey} for tables without clustering columns
         */
        public PrimaryKey create(DecoratedKey partitionKey)
        {
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">            assert clusteringComparator.size() == 0 : &quot;Cannot create a skinny primary key for a table with clustering columns&quot;;</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">            assert partitionKey != null : &quot;Cannot create a primary key with a null partition key&quot;;</span>

<span class="fc" id="L96">            return new SkinnyPrimaryKey(partitionKey);</span>
        }

        /**
         * Creates a {@link PrimaryKey} that is fully represented by partition key
         * and clustering.
         */
        public PrimaryKey create(DecoratedKey partitionKey, Clustering&lt;?&gt; clustering)
        {
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">            assert clusteringComparator.size() &gt; 0 : &quot;Cannot create a wide primary key for a table without clustering columns&quot;;</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">            assert partitionKey != null : &quot;Cannot create a primary key with a null partition key&quot;;</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">            assert clustering != null : &quot;Cannot create a primary key with a null clustering&quot;;</span>

<span class="fc bfc" id="L109" title="All 2 branches covered.">            return clustering == Clustering.STATIC_CLUSTERING ? new StaticPrimaryKey(partitionKey) : new WidePrimaryKey(partitionKey, clustering);</span>
        }

        /**
         * Create a {@link PrimaryKey} from a {@link ByteSource}. This should only be used with {@link ByteSource} instances
         * created by calls to {@link PrimaryKey#asComparableBytes(Version)}.
         */
        public PrimaryKey fromComparableBytes(ByteSource byteSource)
        {
<span class="fc bfc" id="L118" title="All 2 branches covered.">            if (clusteringComparator.size() &gt; 0)</span>
            {
<span class="fc" id="L120">                ByteSource.Peekable peekable = ByteSource.peekable(byteSource);</span>
<span class="fc" id="L121">                DecoratedKey partitionKey = partitionKeyFromComparableBytes(ByteSourceInverse.nextComponentSource(peekable));</span>
<span class="fc" id="L122">                Clustering&lt;?&gt; clustering = clusteringFromByteComparable(ByteSourceInverse.nextComponentSource(peekable));</span>
<span class="fc" id="L123">                return create(partitionKey, clustering);</span>
            }
            else
            {
<span class="fc" id="L127">                return create(partitionKeyFromComparableBytes(byteSource));</span>
            }
        }

        /**
         * Create a {@link DecoratedKey} from a {@link ByteSource}. This is a separate method because of it's use by
         * the {@link org.apache.cassandra.index.sai.disk.PrimaryKeyMap} implementations to create partition keys.
         */
        public DecoratedKey partitionKeyFromComparableBytes(ByteSource byteSource)
        {
<span class="fc" id="L137">            ByteBuffer decoratedKey = ByteBuffer.wrap(ByteSourceInverse.getUnescapedBytes(ByteSource.peekable(byteSource)));</span>
<span class="fc" id="L138">            return new BufferDecoratedKey(partitioner.getToken(decoratedKey), decoratedKey);</span>
        }

        /**
         * Create a {@link Clustering} from a {@link ByteSource}. This is a separate method because of its use by
         * the {@link org.apache.cassandra.index.sai.disk.v1.WidePrimaryKeyMap} to create its clustering keys.
         */
        public Clustering&lt;?&gt; clusteringFromByteComparable(ByteSource byteSource)
        {
<span class="fc" id="L147">            Clustering&lt;?&gt; clustering = clusteringComparator.clusteringFromByteComparable(ByteBufferAccessor.instance, v -&gt; byteSource);</span>

            // Clustering is null for static rows
<span class="fc bfc" id="L150" title="All 2 branches covered.">            return (clustering == null) ? Clustering.STATIC_CLUSTERING : clustering;</span>
        }

        class TokenOnlyPrimaryKey implements PrimaryKey
        {
            protected final Token token;

            TokenOnlyPrimaryKey(Token token)
<span class="fc" id="L158">            {</span>
<span class="fc" id="L159">                this.token = token;</span>
<span class="fc" id="L160">            }</span>

            @Override
            public Kind kind()
            {
<span class="fc" id="L165">                return Kind.TOKEN;</span>
            }

            @Override
            public Token token()
            {
<span class="fc" id="L171">                return token;</span>
            }

            @Override
            public DecoratedKey partitionKey()
            {
<span class="nc" id="L177">                throw new UnsupportedOperationException();</span>
            }

            @Override
            public Clustering&lt;?&gt; clustering()
            {
<span class="nc" id="L183">                throw new UnsupportedOperationException();</span>
            }

            @Override
            public ByteSource asComparableBytes(Version version)
            {
<span class="nc" id="L189">                throw new UnsupportedOperationException();</span>
            }

            @Override
            public int compareTo(PrimaryKey o)
            {
<span class="fc" id="L195">                return token().compareTo(o.token());</span>
            }

            @Override
            public int hashCode()
            {
<span class="nc" id="L201">                return Objects.hash(token(), clusteringComparator);</span>
            }

            @Override
            public boolean equals(Object obj)
            {
<span class="fc bfc" id="L207" title="All 2 branches covered.">                if (obj instanceof PrimaryKey)</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">                    return compareTo((PrimaryKey) obj) == 0;</span>
<span class="fc" id="L209">                return false;</span>
            }

            @Override
            public String toString()
            {
<span class="fc" id="L215">                return String.format(&quot;PrimaryKey: { token: %s }&quot;, token());</span>
            }
        }

        class SkinnyPrimaryKey extends TokenOnlyPrimaryKey
        {
            protected final DecoratedKey partitionKey;

            SkinnyPrimaryKey(DecoratedKey partitionKey)
<span class="fc" id="L224">            {</span>
<span class="fc" id="L225">                super(partitionKey.getToken());</span>
<span class="fc" id="L226">                this.partitionKey = partitionKey;</span>
<span class="fc" id="L227">            }</span>

            @Override
            public Kind kind()
            {
<span class="fc" id="L232">                return Kind.SKINNY;</span>
            }

            @Override
            public DecoratedKey partitionKey()
            {
<span class="fc" id="L238">                return partitionKey;</span>
            }

            @Override
            public ByteSource asComparableBytes(Version version)
            {
<span class="fc" id="L244">                return ByteSource.of(partitionKey().getKey(), version);</span>
            }

            @Override
            public int compareTo(PrimaryKey o)
            {
<span class="fc" id="L250">                int cmp = super.compareTo(o);</span>

                // If the tokens don't match then we don't need to compare any more of the key.
                // Otherwise, if the other key is token only we can only compare tokens
                // This is used by the ResultRetriever to skip to the current key range start position
                // during result retrieval.
<span class="fc bfc" id="L256" title="All 4 branches covered.">                if ((cmp != 0) || o.kind() == Kind.TOKEN)</span>
<span class="fc" id="L257">                    return cmp;</span>

                // Finally compare the partition keys
<span class="fc" id="L260">                return partitionKey().compareTo(o.partitionKey());</span>
            }

            @Override
            public int hashCode()
            {
<span class="nc" id="L266">                return Objects.hash(token(), partitionKey(), Clustering.EMPTY, clusteringComparator);</span>
            }

            @Override
            public String toString()
            {
<span class="fc" id="L272">                return String.format(&quot;PrimaryKey: { token: %s, partition: %s }&quot;, token(), partitionKey());</span>
            }
        }

        class StaticPrimaryKey extends SkinnyPrimaryKey
        {
            StaticPrimaryKey(DecoratedKey partitionKey)
<span class="fc" id="L279">            {</span>
<span class="fc" id="L280">                super(partitionKey);</span>
<span class="fc" id="L281">            }</span>

            @Override
            public Kind kind()
            {
<span class="fc" id="L286">                return Kind.STATIC;</span>
            }

            @Override
            public Clustering&lt;?&gt; clustering()
            {
<span class="fc" id="L292">                return Clustering.STATIC_CLUSTERING;</span>
            }

            @Override
            public ByteSource asComparableBytes(ByteComparable.Version version)
            {
<span class="fc" id="L298">                ByteSource keyComparable = ByteSource.of(partitionKey().getKey(), version);</span>
                // Static clustering cannot be serialized or made to a byte comparable, so we use null as the component.
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">                return ByteSource.withTerminator(version == ByteComparable.Version.LEGACY ? ByteSource.END_OF_STREAM</span>
<span class="fc" id="L301">                                                                                          : ByteSource.TERMINATOR,</span>
                                                 keyComparable,
                                                 null);
            }

            @Override
            public int compareTo(PrimaryKey o)
            {
<span class="fc" id="L309">                int cmp = super.compareTo(o);</span>
<span class="pc bpc" id="L310" title="1 of 6 branches missed.">                if (cmp != 0 || o.kind() == Kind.TOKEN || o.kind() == Kind.SKINNY)</span>
<span class="fc" id="L311">                    return cmp;</span>
                // The static clustering comes first in the sort order of if the other key has static clustering we
                // are equals otherwise we are less than the other
<span class="fc bfc" id="L314" title="All 2 branches covered.">                return o.kind() == Kind.STATIC ? 0 : -1;</span>
            }

            @Override
            public int hashCode()
            {
<span class="nc" id="L320">                return Objects.hash(token(), partitionKey(), Clustering.STATIC_CLUSTERING, clusteringComparator);</span>
            }

            @Override
            public String toString()
            {
<span class="fc" id="L326">                return String.format(&quot;PrimaryKey: { token: %s, partition: %s, clustering: STATIC } &quot;, token(), partitionKey());</span>
            }
        }

        class WidePrimaryKey extends SkinnyPrimaryKey
        {
            private final Clustering&lt;?&gt; clustering;

            WidePrimaryKey(DecoratedKey partitionKey, Clustering&lt;?&gt; clustering)
<span class="fc" id="L335">            {</span>
<span class="fc" id="L336">                super(partitionKey);</span>
<span class="fc" id="L337">                this.clustering = clustering;</span>
<span class="fc" id="L338">            }</span>

            @Override
            public Kind kind()
            {
<span class="fc" id="L343">                return Kind.WIDE;</span>
            }

            @Override
            public Clustering&lt;?&gt; clustering()
            {
<span class="fc" id="L349">                return clustering;</span>
            }

            @Override
            public ByteSource asComparableBytes(ByteComparable.Version version)
            {
<span class="fc" id="L355">                ByteSource keyComparable = ByteSource.of(partitionKey().getKey(), version);</span>
                // It is important that the ClusteringComparator.asBytesComparable method is used
                // to maintain the correct clustering sort order.
<span class="fc" id="L358">                ByteSource clusteringComparable = clusteringComparator.asByteComparable(clustering()).asComparableBytes(version);</span>
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">                return ByteSource.withTerminator(version == ByteComparable.Version.LEGACY ? ByteSource.END_OF_STREAM</span>
<span class="fc" id="L360">                                                                                          : ByteSource.TERMINATOR,</span>
                                                 keyComparable,
                                                 clusteringComparable);
            }

            @Override
            public int compareTo(PrimaryKey o)
            {
<span class="fc" id="L368">                int cmp = super.compareTo(o);</span>
<span class="pc bpc" id="L369" title="1 of 6 branches missed.">                if (cmp != 0 || o.kind() == Kind.TOKEN || o.kind() == Kind.SKINNY)</span>
<span class="fc" id="L370">                    return cmp;</span>
                // At this point we will be greater than other if it is static
<span class="fc bfc" id="L372" title="All 2 branches covered.">                if (o.kind() == Kind.STATIC)</span>
<span class="fc" id="L373">                    return 1;</span>
<span class="fc" id="L374">                return clusteringComparator.compare(clustering(), o.clustering());</span>
            }

            @Override
            public int hashCode()
            {
<span class="nc" id="L380">                return Objects.hash(token(), partitionKey(), clustering(), clusteringComparator);</span>
            }

            @Override
            public String toString()
            {
<span class="fc" id="L386">                return String.format(&quot;PrimaryKey: { token: %s, partition: %s, clustering: %s:%s } &quot;,</span>
<span class="fc" id="L387">                                     token(),</span>
<span class="fc" id="L388">                                     partitionKey(),</span>
<span class="fc" id="L389">                                     clustering().kind(),</span>
<span class="fc" id="L390">                                     Arrays.stream(clustering().getBufferArray())</span>
<span class="fc" id="L391">                                           .map(ByteBufferUtil::bytesToHex)</span>
<span class="fc" id="L392">                                           .collect(Collectors.joining(&quot;, &quot;)));</span>
            }
        }
    }

    /**
     * Returns the {@link Kind} of the {@link PrimaryKey}. The {@link Kind} is used locally in the {@link #compareTo(Object)}
     * methods to determine how far the comparision needs to go between keys.
     * &lt;p&gt;
     * The {@link Kind} values have a categorization of {@code isClustering}. This indicates whether the key belongs to
     * a table with clustering tables or not.
     */
    Kind kind();

    /**
     * Returns the {@link Token} component of the {@link PrimaryKey}
     */
    Token token();

    /**
     * Returns the {@link DecoratedKey} representing the partition key of the {@link PrimaryKey}.
     * &lt;p&gt;
     * Note: This cannot be null but some {@link PrimaryKey} implementations can throw {@link UnsupportedOperationException}
     * if they do not support partition keys.
     */
    DecoratedKey partitionKey();

    /**
     * Returns the {@link Clustering} representing the clustering component of the {@link PrimaryKey}.
     * &lt;p&gt;
     * Note: This cannot be null but some {@link PrimaryKey} implementations can throw {@link UnsupportedOperationException}
     * if they do not support clustering columns.
     */
    Clustering&lt;?&gt; clustering();

    /**
     * Returns the {@link PrimaryKey} as a {@link ByteSource} byte comparable representation.
     * &lt;p&gt;
     * It is important that these representations are only ever used with byte comparables using
     * the same elements. This means that {@code asComparableBytes} responses can only be used
     * together from the same {@link PrimaryKey} implementation.
     *
     * @param version the {@link ByteComparable.Version} to use for the implementation
     * @return the {@code ByteSource} byte comparable.
     * @throws UnsupportedOperationException for {@link PrimaryKey} implementations that are not byte-comparable
     */
    ByteSource asComparableBytes(ByteComparable.Version version);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>