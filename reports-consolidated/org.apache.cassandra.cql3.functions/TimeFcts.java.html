<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TimeFcts.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.functions</a> &gt; <span class="el_source">TimeFcts.java</span></div><h1>TimeFcts.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3.functions;

import java.nio.ByteBuffer;
import java.util.List;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.cql3.Duration;
import org.apache.cassandra.db.marshal.*;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.TimeUUID;

import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;

<span class="nc" id="L34">public abstract class TimeFcts</span>
{
<span class="fc" id="L36">    public static Logger logger = LoggerFactory.getLogger(TimeFcts.class);</span>

    public static void addFunctionsTo(NativeFunctions functions)
    {
<span class="fc" id="L40">        functions.addAll(new NowFunction(&quot;now&quot;, TimeUUIDType.instance),</span>
                         new NowFunction(&quot;current_timeuuid&quot;, TimeUUIDType.instance),
                         new NowFunction(&quot;current_timestamp&quot;, TimestampType.instance),
                         new NowFunction(&quot;current_date&quot;, SimpleDateType.instance),
                         new NowFunction(&quot;current_time&quot;, TimeType.instance),
                         minTimeuuidFct,
                         maxTimeuuidFct,
<span class="fc" id="L47">                         toDate(TimeUUIDType.instance),</span>
<span class="fc" id="L48">                         toTimestamp(TimeUUIDType.instance),</span>
<span class="fc" id="L49">                         toUnixTimestamp(TimeUUIDType.instance),</span>
<span class="fc" id="L50">                         toUnixTimestamp(TimestampType.instance),</span>
<span class="fc" id="L51">                         toDate(TimestampType.instance),</span>
<span class="fc" id="L52">                         toUnixTimestamp(SimpleDateType.instance),</span>
<span class="fc" id="L53">                         toTimestamp(SimpleDateType.instance),</span>
<span class="fc" id="L54">                         FloorTimestampFunction.newInstance(),</span>
<span class="fc" id="L55">                         FloorTimestampFunction.newInstanceWithStartTimeArgument(),</span>
<span class="fc" id="L56">                         FloorTimeUuidFunction.newInstance(),</span>
<span class="fc" id="L57">                         FloorTimeUuidFunction.newInstanceWithStartTimeArgument(),</span>
<span class="fc" id="L58">                         FloorDateFunction.newInstance(),</span>
<span class="fc" id="L59">                         FloorDateFunction.newInstanceWithStartTimeArgument(),</span>
                         floorTime);
<span class="fc" id="L61">    }</span>

    private static class NowFunction extends NativeScalarFunction
    {
        private final TemporalType&lt;?&gt; type;

        public NowFunction(String name, TemporalType&lt;?&gt; type)
        {
<span class="fc" id="L69">            super(name, type);</span>
<span class="fc" id="L70">            this.type = type;</span>
<span class="fc" id="L71">        }</span>

        @Override
        public ByteBuffer execute(Arguments arguments)
        {
<span class="fc" id="L76">            return type.now();</span>
        }

        @Override
        public boolean isPure()
        {
<span class="nc" id="L82">            return false; // as it returns non-identical results for identical arguments</span>
        }

        @Override
        public NativeFunction withLegacyName()
        {
<span class="fc" id="L88">            String name = name().name;</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">            return name.contains(&quot;current&quot;) ? new NowFunction(StringUtils.remove(name, '_'), type) : null;</span>
        }
    }

    public static abstract class TemporalConversionFunction extends NativeScalarFunction
    {
        protected TemporalConversionFunction(String name, AbstractType&lt;?&gt; returnType, AbstractType&lt;?&gt;... argsType)
        {
<span class="fc" id="L97">            super(name, returnType, argsType);</span>
<span class="fc" id="L98">        }</span>

        public ByteBuffer execute(Arguments arguments)
        {
<span class="fc" id="L102">            beforeExecution();</span>

<span class="fc bfc" id="L104" title="All 2 branches covered.">            if (arguments.containsNulls())</span>
<span class="fc" id="L105">                return null;</span>

<span class="fc" id="L107">            return convertArgument(arguments.getAsLong(0));</span>
        }

        protected void beforeExecution()
        {
<span class="fc" id="L112">        }</span>

        protected abstract ByteBuffer convertArgument(long timeInMillis);
    }

<span class="fc" id="L117">    public static final NativeFunction minTimeuuidFct = new MinTimeuuidFunction(false);</span>

    private static final class MinTimeuuidFunction extends TemporalConversionFunction
    {
        public MinTimeuuidFunction(boolean legacy)
        {
<span class="fc bfc" id="L123" title="All 2 branches covered.">            super(legacy ? &quot;mintimeuuid&quot; : &quot;min_timeuuid&quot;, TimeUUIDType.instance, TimestampType.instance);</span>
<span class="fc" id="L124">        }</span>

        @Override
        protected ByteBuffer convertArgument(long timeInMillis)
        {
<span class="fc" id="L129">            return TimeUUID.minAtUnixMillis(timeInMillis).toBytes();</span>
        }

        @Override
        public NativeFunction withLegacyName()
        {
<span class="fc" id="L135">            return new MinTimeuuidFunction(true);</span>
        }
    }

<span class="fc" id="L139">    public static final NativeFunction maxTimeuuidFct = new MaxTimeuuidFunction(false);</span>

    private static final class MaxTimeuuidFunction extends TemporalConversionFunction
    {
        public MaxTimeuuidFunction(boolean legacy)
        {
<span class="fc bfc" id="L145" title="All 2 branches covered.">            super(legacy ? &quot;maxtimeuuid&quot; : &quot;max_timeuuid&quot;, TimeUUIDType.instance, TimestampType.instance);</span>
<span class="fc" id="L146">        }</span>

        @Override
        protected ByteBuffer convertArgument(long timeInMillis)
        {
<span class="fc" id="L151">            return TimeUUID.maxAtUnixMillis(timeInMillis).toBytes();</span>
        }

        @Override
        public NativeFunction withLegacyName()
        {
<span class="fc" id="L157">            return new MaxTimeuuidFunction(true);</span>
        }
    }

    /**
     * Creates a function that converts a value of the specified type into a {@code DATE}.
     *
     * @param type the temporal type
     * @return a function that convert a value of the specified type into a &lt;code&gt;DATE&lt;/code&gt;.
     */
    public static NativeScalarFunction toDate(TemporalType&lt;?&gt; type)
    {
<span class="fc" id="L169">        return new ToDateFunction(type, false);</span>
    }

    private static class ToDateFunction extends TemporalConversionFunction
    {
        private final TemporalType&lt;?&gt; type;

        public ToDateFunction(TemporalType&lt;?&gt; type, boolean useLegacyName)
        {
<span class="fc bfc" id="L178" title="All 2 branches covered.">            super(useLegacyName ? &quot;todate&quot; : &quot;to_date&quot;, SimpleDateType.instance, type);</span>
<span class="fc" id="L179">            this.type = type;</span>
<span class="fc" id="L180">        }</span>

        @Override
        protected ByteBuffer convertArgument(long timeInMillis)
        {
<span class="fc" id="L185">            return SimpleDateType.instance.fromTimeInMillis(timeInMillis);</span>
        }

        @Override
        public boolean isMonotonic()
        {
<span class="nc" id="L191">            return true;</span>
        }

        @Override
        public NativeFunction withLegacyName()
        {
<span class="fc" id="L197">            return new ToDateFunction(type, true);</span>
        }
    }

    /**
     * Creates a function that converts a value of the specified type into a {@code TIMESTAMP}.
     *
     * @param type the temporal type
     * @return a function that convert a value of the specified type into a {@code TIMESTAMP}.
     */
    public static NativeScalarFunction toTimestamp(TemporalType&lt;?&gt; type)
    {
<span class="fc" id="L209">        return new ToTimestampFunction(type, false);</span>
    }

    private static class ToTimestampFunction extends TemporalConversionFunction
    {
        private final TemporalType&lt;?&gt; type;

        public ToTimestampFunction(TemporalType&lt;?&gt; type, boolean useLegacyName)
        {
<span class="fc bfc" id="L218" title="All 2 branches covered.">            super(useLegacyName ? &quot;totimestamp&quot; : &quot;to_timestamp&quot;, TimestampType.instance, type);</span>
<span class="fc" id="L219">            this.type = type;</span>
<span class="fc" id="L220">        }</span>

        @Override
        protected ByteBuffer convertArgument(long timeInMillis)
        {
<span class="fc" id="L225">            return TimestampType.instance.fromTimeInMillis(timeInMillis);</span>
        }

        @Override
        public boolean isMonotonic()
        {
<span class="fc" id="L231">            return true;</span>
        }

        @Override
        public NativeFunction withLegacyName()
        {
<span class="fc" id="L237">            return new ToTimestampFunction(type, true);</span>
        }
    }

    /**
     * Creates a function that converts a value of the specified type into a UNIX timestamp.
     *
     * @param type the temporal type
     * @return a function that convert a value of the specified type into a UNIX timestamp.
     */
    public static NativeScalarFunction toUnixTimestamp(TemporalType&lt;?&gt; type)
    {
<span class="fc" id="L249">        return new ToUnixTimestampFunction(type, false);</span>
    }

    private static class ToUnixTimestampFunction extends TemporalConversionFunction
    {
        private final TemporalType&lt;?&gt; type;

        private ToUnixTimestampFunction(TemporalType&lt;?&gt; type, boolean useLegacyName)
        {
<span class="fc bfc" id="L258" title="All 2 branches covered.">            super(useLegacyName ? &quot;tounixtimestamp&quot; : &quot;to_unix_timestamp&quot;, LongType.instance, type);</span>
<span class="fc" id="L259">            this.type = type;</span>
<span class="fc" id="L260">        }</span>

        @Override
        protected ByteBuffer convertArgument(long timeInMillis)
        {
<span class="fc" id="L265">            return ByteBufferUtil.bytes(timeInMillis);</span>
        }

        @Override
        public boolean isMonotonic()
        {
<span class="nc" id="L271">            return true;</span>
        }

        @Override
        public NativeFunction withLegacyName()
        {
<span class="fc" id="L277">            return new ToUnixTimestampFunction(type, true);</span>
        }
    }

    /**
     * Function that rounds a timestamp down to the closest multiple of a duration.
     */
     private static abstract class FloorFunction extends NativeScalarFunction
     {
<span class="fc" id="L286">         private static final Long ZERO = 0L;</span>

         protected FloorFunction(AbstractType&lt;?&gt; returnType,
                                 AbstractType&lt;?&gt;... argsType)
         {
<span class="fc" id="L291">             super(&quot;floor&quot;, returnType, argsType);</span>
             // The function can accept either 2 parameters (time and duration) or 3 parameters (time, duration and startTime)r
<span class="pc bpc" id="L293" title="1 of 4 branches missed.">             assert argsType.length == 2 || argsType.length == 3;</span>
<span class="fc" id="L294">         }</span>

         @Override
         protected boolean isPartialApplicationMonotonic(List&lt;ByteBuffer&gt; partialParameters)
         {
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">             return partialParameters.get(0) == UNRESOLVED</span>
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">                     &amp;&amp; partialParameters.get(1) != UNRESOLVED</span>
<span class="fc bfc" id="L301" title="All 4 branches covered.">                     &amp;&amp; (partialParameters.size() == 2 || partialParameters.get(2) != UNRESOLVED);</span>
         }

         @Override
         public final ByteBuffer execute(Arguments arguments)
         {
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">             if (arguments.containsNulls())</span>
<span class="nc" id="L308">                 return null;</span>

<span class="fc" id="L310">             long time = arguments.getAsLong(0);</span>
<span class="fc" id="L311">             Duration duration = arguments.get(1);</span>
<span class="fc" id="L312">             long startingTime = getStartingTime(arguments);</span>
<span class="fc" id="L313">             validateDuration(duration);</span>

<span class="fc" id="L315">             long floor = Duration.floorTimestamp(time, duration, startingTime);</span>

<span class="fc" id="L317">             return fromTimeInMillis(floor);</span>
         }

         /**
          * Returns the time to use as the starting time.
          *
          * @param arguments the function arguments
          * @return the time to use as the starting time
          */
         private long getStartingTime(Arguments arguments)
         {
<span class="fc bfc" id="L328" title="All 2 branches covered.">             if (arguments.size() == 3)</span>
<span class="fc" id="L329">                 return arguments.getAsLong(2);</span>

<span class="fc" id="L331">             return ZERO;</span>
         }

         /**
          * Validates that the duration has the correct precision.
          * @param duration the duration to validate.
          */
         protected void validateDuration(Duration duration)
         {
<span class="fc bfc" id="L340" title="All 2 branches covered.">             if (!duration.hasMillisecondPrecision())</span>
<span class="fc" id="L341">                 throw invalidRequest(&quot;The floor cannot be computed for the %s duration as precision is below 1 millisecond&quot;, duration);</span>
<span class="fc" id="L342">         }</span>

         /**
          * Serializes the specified time.
          *
          * @param timeInMillis the time in milliseconds
          * @return the serialized time
          */
         protected abstract ByteBuffer fromTimeInMillis(long timeInMillis);
     }

    /**
     * Function that rounds a timestamp down to the closest multiple of a duration.
     */
     public static final class FloorTimestampFunction extends FloorFunction
     {
         public static FloorTimestampFunction newInstance()
         {
<span class="fc" id="L360">             return new FloorTimestampFunction(TimestampType.instance,</span>
                                               TimestampType.instance,
                                               DurationType.instance);
         }

         public static FloorTimestampFunction newInstanceWithStartTimeArgument()
         {
<span class="fc" id="L367">             return new FloorTimestampFunction(TimestampType.instance,</span>
                                               TimestampType.instance,
                                               DurationType.instance,
                                               TimestampType.instance);
         }

         private FloorTimestampFunction(AbstractType&lt;?&gt; returnType,
                                        AbstractType&lt;?&gt;... argTypes)
         {
<span class="fc" id="L376">             super(returnType, argTypes);</span>
<span class="fc" id="L377">         }</span>

         protected ByteBuffer fromTimeInMillis(long timeInMillis)
         {
<span class="fc" id="L381">             return TimestampType.instance.fromTimeInMillis(timeInMillis);</span>
         }
     }

     /**
      * Function that rounds a timeUUID down to the closest multiple of a duration.
      */
     public static final class FloorTimeUuidFunction extends FloorFunction
     {
         public static FloorTimeUuidFunction newInstance()
         {
<span class="fc" id="L392">             return new FloorTimeUuidFunction(TimestampType.instance,</span>
                                              TimeUUIDType.instance,
                                              DurationType.instance);
         }

         public static FloorTimeUuidFunction newInstanceWithStartTimeArgument()
         {
<span class="fc" id="L399">             return new FloorTimeUuidFunction(TimestampType.instance,</span>
                                              TimeUUIDType.instance,
                                              DurationType.instance,
                                              TimestampType.instance);
         }

         private FloorTimeUuidFunction(AbstractType&lt;?&gt; returnType,
                                       AbstractType&lt;?&gt;... argTypes)
         {
<span class="fc" id="L408">             super(returnType, argTypes);</span>
<span class="fc" id="L409">         }</span>

         protected ByteBuffer fromTimeInMillis(long timeInMillis)
         {
<span class="fc" id="L413">             return TimestampType.instance.fromTimeInMillis(timeInMillis);</span>
         }
     }

     /**
      * Function that rounds a date down to the closest multiple of a duration.
      */
     public static final class FloorDateFunction extends FloorFunction
     {
         public static FloorDateFunction newInstance()
         {
<span class="fc" id="L424">             return new FloorDateFunction(SimpleDateType.instance,</span>
                                          SimpleDateType.instance,
                                          DurationType.instance);
         }

         public static FloorDateFunction newInstanceWithStartTimeArgument()
         {
<span class="fc" id="L431">             return new FloorDateFunction(SimpleDateType.instance,</span>
                                          SimpleDateType.instance,
                                          DurationType.instance,
                                          SimpleDateType.instance);
         }

         private FloorDateFunction(AbstractType&lt;?&gt; returnType,
                                   AbstractType&lt;?&gt;... argTypes)
         {
<span class="fc" id="L440">             super(returnType, argTypes);</span>
<span class="fc" id="L441">         }</span>

         protected ByteBuffer fromTimeInMillis(long timeInMillis)
         {
<span class="fc" id="L445">             return SimpleDateType.instance.fromTimeInMillis(timeInMillis);</span>
         }

         @Override
         protected void validateDuration(Duration duration)
         {
             // Checks that the duration has no data below days.
<span class="fc bfc" id="L452" title="All 2 branches covered.">             if (duration.getNanoseconds() != 0)</span>
<span class="fc" id="L453">                 throw invalidRequest(&quot;The floor on %s values cannot be computed for the %s duration as precision is below 1 day&quot;,</span>
<span class="fc" id="L454">                                      SimpleDateType.instance.asCQL3Type(), duration);</span>
<span class="fc" id="L455">         }</span>
     }

     /**
      * Function that rounds a time down to the closest multiple of a duration.
      */
<span class="fc" id="L461">     public static final NativeScalarFunction floorTime = new NativeScalarFunction(&quot;floor&quot;, TimeType.instance, TimeType.instance, DurationType.instance)</span>
<span class="fc" id="L462">     {</span>
         @Override
         protected boolean isPartialApplicationMonotonic(List&lt;ByteBuffer&gt; partialParameters)
         {
<span class="pc bpc" id="L466" title="2 of 4 branches missed.">             return partialParameters.get(0) == UNRESOLVED &amp;&amp; partialParameters.get(1) != UNRESOLVED;</span>
         }

         @Override
         public ByteBuffer execute(Arguments arguments)
         {
<span class="pc bpc" id="L472" title="1 of 2 branches missed.">             if (arguments.containsNulls())</span>
<span class="nc" id="L473">                 return null;</span>

<span class="fc" id="L475">             long time = arguments.getAsLong(0);</span>
<span class="fc" id="L476">             Duration duration = arguments.get(1);</span>

<span class="fc" id="L478">             long floor = Duration.floorTime(time, duration);</span>

<span class="fc" id="L480">             return TimeType.instance.decompose(floor);</span>
         }
     };
 }
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>