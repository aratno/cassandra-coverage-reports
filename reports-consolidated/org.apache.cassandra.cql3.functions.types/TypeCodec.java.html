<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TypeCodec.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.functions.types</a> &gt; <span class="el_source">TypeCodec.java</span></div><h1>TypeCodec.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3.functions.types;

import java.io.DataInput;
import java.io.IOException;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.nio.BufferUnderflowException;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.text.ParseException;
import java.util.*;
import java.util.regex.Pattern;

import com.google.common.io.ByteStreams;
import com.google.common.reflect.TypeToken;

import org.apache.cassandra.cql3.functions.types.exceptions.InvalidTypeException;
import org.apache.cassandra.cql3.functions.types.utils.Bytes;
import org.apache.cassandra.transport.ProtocolVersion;
import org.apache.cassandra.utils.vint.VIntCoding;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static org.apache.cassandra.cql3.functions.types.DataType.*;

/**
 * A Codec that can serialize and deserialize to and from a given {@link #getCqlType() CQL type} and
 * a given {@link #getJavaType() Java Type}.
 *
 * &lt;p&gt;
 *
 * &lt;h3&gt;Serializing and deserializing&lt;/h3&gt;
 *
 * &lt;p&gt;Two methods handle the serialization and deserialization of Java types into CQL types
 * according to the native protocol specifications:
 *
 * &lt;ol&gt;
 * &lt;li&gt;{@link #serialize(Object, ProtocolVersion)}: used to serialize from the codec's Java type
 * to a {@link ByteBuffer} instance corresponding to the codec's CQL type;
 * &lt;li&gt;{@link #deserialize(ByteBuffer, ProtocolVersion)}: used to deserialize a {@link ByteBuffer}
 * instance corresponding to the codec's CQL type to the codec's Java type.
 * &lt;/ol&gt;
 *
 * &lt;p&gt;
 *
 * &lt;h3&gt;Formatting and parsing&lt;/h3&gt;
 *
 * &lt;p&gt;Two methods handle the formatting and parsing of Java types into CQL strings:
 *
 * &lt;ol&gt;
 * &lt;li&gt;{@link #format(Object)}: formats the Java type handled by the codec as a CQL string;
 * &lt;li&gt;{@link #parse(String)}; parses a CQL string into the Java type handled by the codec.
 * &lt;/ol&gt;
 *
 * &lt;p&gt;
 *
 * &lt;h3&gt;Inspection&lt;/h3&gt;
 *
 * &lt;p&gt;Codecs also have the following inspection methods:
 *
 * &lt;p&gt;
 *
 * &lt;ol&gt;
 * &lt;li&gt;{@link #accepts(DataType)}: returns true if the codec can deserialize the given CQL type;
 * &lt;li&gt;{@link #accepts(TypeToken)}: returns true if the codec can serialize the given Java type;
 * &lt;li&gt;{@link #accepts(Object)}; returns true if the codec can serialize the given object.
 * &lt;/ol&gt;
 *
 * &lt;p&gt;
 *
 * &lt;h3&gt;Implementation notes&lt;/h3&gt;
 *
 * &lt;p&gt;
 *
 * &lt;ol&gt;
 * &lt;li&gt;TypeCodec implementations &lt;em&gt;must&lt;/em&gt; be thread-safe.
 * &lt;li&gt;TypeCodec implementations &lt;em&gt;must&lt;/em&gt; perform fast and never block.
 * &lt;li&gt;TypeCodec implementations &lt;em&gt;must&lt;/em&gt; support all native protocol versions; it is not
 * possible to use different codecs for the same types but under different protocol versions.
 * &lt;li&gt;TypeCodec implementations must comply with the native protocol specifications; failing to
 * do so will result in unexpected results and could cause the driver to crash.
 * &lt;li&gt;TypeCodec implementations &lt;em&gt;should&lt;/em&gt; be stateless and immutable.
 * &lt;li&gt;TypeCodec implementations &lt;em&gt;should&lt;/em&gt; interpret {@code null} values and empty
 * ByteBuffers (i.e. &lt;code&gt;{@link ByteBuffer#remaining()} == 0&lt;/code&gt;) in a
 * &lt;em&gt;reasonable&lt;/em&gt; way; usually, {@code NULL} CQL values should map to {@code null}
 * references, but exceptions exist; e.g. for varchar types, a {@code NULL} CQL value maps to
 * a {@code null} reference, whereas an empty buffer maps to an empty String. For collection
 * types, it is also admitted that {@code NULL} CQL values map to empty Java collections
 * instead of {@code null} references. In any case, the codec's behavior in respect to {@code
 * null} values and empty ByteBuffers should be clearly documented.
 * &lt;li&gt;TypeCodec implementations that wish to handle Java primitive types &lt;em&gt;must&lt;/em&gt; be
 * instantiated with the wrapper Java class instead, and implement the appropriate interface
 * (e.g. {@link TypeCodec.PrimitiveBooleanCodec} for primitive {@code
 * boolean} types; there is one such interface for each Java primitive type).
 * &lt;li&gt;When deserializing, TypeCodec implementations should not consume {@link ByteBuffer}
 * instances by performing relative read operations that modify their current position; codecs
 * should instead prefer absolute read methods, or, if necessary, they should {@link
 * ByteBuffer#duplicate() duplicate} their byte buffers prior to reading them.
 * &lt;/ol&gt;
 *
 * @param &lt;T&gt; The codec's Java type
 */
public abstract class TypeCodec&lt;T&gt;
{
    private final static int VARIABLE_LENGTH = -1;

    /**
     * Return the default codec for the CQL type {@code boolean}. The returned codec maps the CQL type
     * {@code boolean} into the Java type {@link Boolean}. The returned instance is a singleton.
     *
     * @return the default codec for CQL type {@code boolean}.
     */
    public static PrimitiveBooleanCodec cboolean()
    {
<span class="fc" id="L135">        return BooleanCodec.instance;</span>
    }

    /**
     * Return the default codec for the CQL type {@code tinyint}. The returned codec maps the CQL type
     * {@code tinyint} into the Java type {@link Byte}. The returned instance is a singleton.
     *
     * @return the default codec for CQL type {@code tinyint}.
     */
    public static PrimitiveByteCodec tinyInt()
    {
<span class="fc" id="L146">        return TinyIntCodec.instance;</span>
    }

    /**
     * Return the default codec for the CQL type {@code smallint}. The returned codec maps the CQL
     * type {@code smallint} into the Java type {@link Short}. The returned instance is a singleton.
     *
     * @return the default codec for CQL type {@code smallint}.
     */
    public static PrimitiveShortCodec smallInt()
    {
<span class="fc" id="L157">        return SmallIntCodec.instance;</span>
    }

    /**
     * Return the default codec for the CQL type {@code int}. The returned codec maps the CQL type
     * {@code int} into the Java type {@link Integer}. The returned instance is a singleton.
     *
     * @return the default codec for CQL type {@code int}.
     */
    public static PrimitiveIntCodec cint()
    {
<span class="fc" id="L168">        return IntCodec.instance;</span>
    }

    /**
     * Return the default codec for the CQL type {@code bigint}. The returned codec maps the CQL type
     * {@code bigint} into the Java type {@link Long}. The returned instance is a singleton.
     *
     * @return the default codec for CQL type {@code bigint}.
     */
    public static PrimitiveLongCodec bigint()
    {
<span class="fc" id="L179">        return BigintCodec.instance;</span>
    }

    /**
     * Return the default codec for the CQL type {@code counter}. The returned codec maps the CQL type
     * {@code counter} into the Java type {@link Long}. The returned instance is a singleton.
     *
     * @return the default codec for CQL type {@code counter}.
     */
    public static PrimitiveLongCodec counter()
    {
<span class="fc" id="L190">        return CounterCodec.instance;</span>
    }

    /**
     * Return the default codec for the CQL type {@code float}. The returned codec maps the CQL type
     * {@code float} into the Java type {@link Float}. The returned instance is a singleton.
     *
     * @return the default codec for CQL type {@code float}.
     */
    public static PrimitiveFloatCodec cfloat()
    {
<span class="fc" id="L201">        return FloatCodec.instance;</span>
    }

    /**
     * Return the default codec for the CQL type {@code double}. The returned codec maps the CQL type
     * {@code double} into the Java type {@link Double}. The returned instance is a singleton.
     *
     * @return the default codec for CQL type {@code double}.
     */
    public static PrimitiveDoubleCodec cdouble()
    {
<span class="fc" id="L212">        return DoubleCodec.instance;</span>
    }

    /**
     * Return the default codec for the CQL type {@code varint}. The returned codec maps the CQL type
     * {@code varint} into the Java type {@link BigInteger}. The returned instance is a singleton.
     *
     * @return the default codec for CQL type {@code varint}.
     */
    public static TypeCodec&lt;BigInteger&gt; varint()
    {
<span class="fc" id="L223">        return VarintCodec.instance;</span>
    }

    /**
     * Return the default codec for the CQL type {@code decimal}. The returned codec maps the CQL type
     * {@code decimal} into the Java type {@link BigDecimal}. The returned instance is a singleton.
     *
     * @return the default codec for CQL type {@code decimal}.
     */
    public static TypeCodec&lt;BigDecimal&gt; decimal()
    {
<span class="fc" id="L234">        return DecimalCodec.instance;</span>
    }

    /**
     * Return the default codec for the CQL type {@code ascii}. The returned codec maps the CQL type
     * {@code ascii} into the Java type {@link String}. The returned instance is a singleton.
     *
     * @return the default codec for CQL type {@code ascii}.
     */
    public static TypeCodec&lt;String&gt; ascii()
    {
<span class="fc" id="L245">        return AsciiCodec.instance;</span>
    }

    /**
     * Return the default codec for the CQL type {@code varchar}. The returned codec maps the CQL type
     * {@code varchar} into the Java type {@link String}. The returned instance is a singleton.
     *
     * @return the default codec for CQL type {@code varchar}.
     */
    public static TypeCodec&lt;String&gt; varchar()
    {
<span class="fc" id="L256">        return VarcharCodec.instance;</span>
    }

    /**
     * Return the default codec for the CQL type {@code blob}. The returned codec maps the CQL type
     * {@code blob} into the Java type {@link ByteBuffer}. The returned instance is a singleton.
     *
     * @return the default codec for CQL type {@code blob}.
     */
    public static TypeCodec&lt;ByteBuffer&gt; blob()
    {
<span class="fc" id="L267">        return BlobCodec.instance;</span>
    }

    /**
     * Return the default codec for the CQL type {@code date}. The returned codec maps the CQL type
     * {@code date} into the Java type {@link LocalDate}. The returned instance is a singleton.
     *
     * @return the default codec for CQL type {@code date}.
     */
    public static TypeCodec&lt;LocalDate&gt; date()
    {
<span class="fc" id="L278">        return DateCodec.instance;</span>
    }

    /**
     * Return the default codec for the CQL type {@code time}. The returned codec maps the CQL type
     * {@code time} into the Java type {@link Long}. The returned instance is a singleton.
     *
     * @return the default codec for CQL type {@code time}.
     */
    public static PrimitiveLongCodec time()
    {
<span class="fc" id="L289">        return TimeCodec.instance;</span>
    }

    /**
     * Return the default codec for the CQL type {@code timestamp}. The returned codec maps the CQL
     * type {@code timestamp} into the Java type {@link Date}. The returned instance is a singleton.
     *
     * @return the default codec for CQL type {@code timestamp}.
     */
    public static TypeCodec&lt;Date&gt; timestamp()
    {
<span class="fc" id="L300">        return TimestampCodec.instance;</span>
    }

    /**
     * Return the default codec for the CQL type {@code uuid}. The returned codec maps the CQL type
     * {@code uuid} into the Java type {@link UUID}. The returned instance is a singleton.
     *
     * @return the default codec for CQL type {@code uuid}.
     */
    public static TypeCodec&lt;UUID&gt; uuid()
    {
<span class="fc" id="L311">        return UUIDCodec.instance;</span>
    }

    /**
     * Return the default codec for the CQL type {@code timeuuid}. The returned codec maps the CQL
     * type {@code timeuuid} into the Java type {@link UUID}. The returned instance is a singleton.
     *
     * @return the default codec for CQL type {@code timeuuid}.
     */
    public static TypeCodec&lt;UUID&gt; timeUUID()
    {
<span class="fc" id="L322">        return TimeUUIDCodec.instance;</span>
    }

    /**
     * Return the default codec for the CQL type {@code inet}. The returned codec maps the CQL type
     * {@code inet} into the Java type {@link InetAddress}. The returned instance is a singleton.
     *
     * @return the default codec for CQL type {@code inet}.
     */
    public static TypeCodec&lt;InetAddress&gt; inet()
    {
<span class="fc" id="L333">        return InetCodec.instance;</span>
    }

    /**
     * Return a newly-created codec for the CQL type {@code list} whose element type is determined by
     * the given element codec. The returned codec maps the CQL type {@code list} into the Java type
     * {@link List}. This method does not cache returned instances and returns a newly-allocated
     * object at each invocation.
     *
     * @param elementCodec the codec that will handle elements of this list.
     * @return A newly-created codec for CQL type {@code list}.
     */
    public static &lt;T&gt; TypeCodec&lt;List&lt;T&gt;&gt; list(TypeCodec&lt;T&gt; elementCodec)
    {
<span class="fc" id="L347">        return new ListCodec&lt;&gt;(elementCodec);</span>
    }

    /**
     * Return a newly-created codec for the CQL type {@code set} whose element type is determined by
     * the given element codec. The returned codec maps the CQL type {@code set} into the Java type
     * {@link Set}. This method does not cache returned instances and returns a newly-allocated object
     * at each invocation.
     *
     * @param elementCodec the codec that will handle elements of this set.
     * @return A newly-created codec for CQL type {@code set}.
     */
    public static &lt;T&gt; TypeCodec&lt;Set&lt;T&gt;&gt; set(TypeCodec&lt;T&gt; elementCodec)
    {
<span class="fc" id="L361">        return new SetCodec&lt;&gt;(elementCodec);</span>
    }

    /**
     * Return a newly-created codec for the CQL type {@code map} whose key type and value type are
     * determined by the given codecs. The returned codec maps the CQL type {@code map} into the Java
     * type {@link Map}. This method does not cache returned instances and returns a newly-allocated
     * object at each invocation.
     *
     * @param keyCodec   the codec that will handle keys of this map.
     * @param valueCodec the codec that will handle values of this map.
     * @return A newly-created codec for CQL type {@code map}.
     */
    public static &lt;K, V&gt; TypeCodec&lt;Map&lt;K, V&gt;&gt; map(TypeCodec&lt;K&gt; keyCodec, TypeCodec&lt;V&gt; valueCodec)
    {
<span class="fc" id="L376">        return new MapCodec&lt;&gt;(keyCodec, valueCodec);</span>
    }

    /**
     * Return a newly-created codec for the given CQL vector type. The returned codec maps the vector
     * type into the Java type {@link List}. This method does not cache returned instances and
     * returns a newly-allocated object at each invocation.
     *
     * @param type the vector type this codec should handle.
     * @return A newly-created codec for the given CQL tuple type.
     */
    public static &lt;E&gt; TypeCodec&lt;List&lt;E&gt;&gt; vector(VectorType type, TypeCodec&lt;E&gt; valueCodec)
    {
<span class="fc" id="L389">        return VectorCodec.of(type, valueCodec);</span>
    }

    /**
     * Return a newly-created codec for the given user-defined CQL type. The returned codec maps the
     * user-defined type into the Java type {@link UDTValue}. This method does not cache returned
     * instances and returns a newly-allocated object at each invocation.
     *
     * @param type the user-defined type this codec should handle.
     * @return A newly-created codec for the given user-defined CQL type.
     */
    public static TypeCodec&lt;UDTValue&gt; userType(UserType type)
    {
<span class="fc" id="L402">        return new UDTCodec(type);</span>
    }

    /**
     * Return a newly-created codec for the given CQL tuple type. The returned codec maps the tuple
     * type into the Java type {@link TupleValue}. This method does not cache returned instances and
     * returns a newly-allocated object at each invocation.
     *
     * @param type the tuple type this codec should handle.
     * @return A newly-created codec for the given CQL tuple type.
     */
    public static TypeCodec&lt;TupleValue&gt; tuple(TupleType type)
    {
<span class="fc" id="L415">        return new TupleCodec(type);</span>
    }

    /**
     * Return a newly-created codec for the given CQL custom type.
     *
     * &lt;p&gt;The returned codec maps the custom type into the Java type {@link ByteBuffer}, thus
     * providing a (very lightweight) support for Cassandra types that do not have a CQL equivalent.
     *
     * &lt;p&gt;Note that the returned codec assumes that CQL literals for the given custom type are
     * expressed in binary form as well, e.g. {@code 0xcafebabe}. If this is not the case, &lt;em&gt;the
     * returned codec might be unable to {@link #parse(String) parse} and {@link #format(Object)
     * format} literals for this type&lt;/em&gt;. This is notoriously true for types inheriting from {@code
     * org.apache.cassandra.db.marshal.AbstractCompositeType}, whose CQL literals are actually
     * expressed as quoted strings.
     *
     * &lt;p&gt;This method does not cache returned instances and returns a newly-allocated object at each
     * invocation.
     *
     * @param type the custom type this codec should handle.
     * @return A newly-created codec for the given CQL custom type.
     */
    public static TypeCodec&lt;ByteBuffer&gt; custom(DataType.CustomType type)
    {
<span class="fc" id="L439">        return new CustomCodec(type);</span>
    }

    /**
     * Returns the default codec for the {@link DataType#duration() Duration type}.
     *
     * &lt;p&gt;This codec maps duration types to the driver's built-in {@link Duration} class, thus
     * providing a more user-friendly mapping than the low-level mapping provided by regular {@link
     * #custom(DataType.CustomType) custom type codecs}.
     *
     * &lt;p&gt;The returned instance is a singleton.
     *
     * @return the default codec for the Duration type.
     */
    public static TypeCodec&lt;Duration&gt; duration()
    {
<span class="fc" id="L455">        return DurationCodec.instance;</span>
    }

    private final TypeToken&lt;T&gt; javaType;

    final DataType cqlType;

    /**
     * This constructor can only be used for non parameterized types. For parameterized ones, please
     * use {@link #TypeCodec(DataType, TypeToken)} instead.
     *
     * @param javaClass The Java class this codec serializes from and deserializes to.
     */
    protected TypeCodec(DataType cqlType, Class&lt;T&gt; javaClass)
    {
<span class="fc" id="L470">        this(cqlType, TypeToken.of(javaClass));</span>
<span class="fc" id="L471">    }</span>

    protected TypeCodec(DataType cqlType, TypeToken&lt;T&gt; javaType)
<span class="fc" id="L474">    {</span>
<span class="fc" id="L475">        checkNotNull(cqlType, &quot;cqlType cannot be null&quot;);</span>
<span class="fc" id="L476">        checkNotNull(javaType, &quot;javaType cannot be null&quot;);</span>
<span class="fc" id="L477">        checkArgument(</span>
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">        !javaType.isPrimitive(),</span>
        &quot;Cannot create a codec for a primitive Java type (%s), please use the wrapper type instead&quot;,
        javaType);
<span class="fc" id="L481">        this.cqlType = cqlType;</span>
<span class="fc" id="L482">        this.javaType = javaType;</span>
<span class="fc" id="L483">    }</span>

    /**
     * Return the Java type that this codec deserializes to and serializes from.
     *
     * @return The Java type this codec deserializes to and serializes from.
     */
    public TypeToken&lt;T&gt; getJavaType()
    {
<span class="fc" id="L492">        return javaType;</span>
    }

    /**
     * Return the CQL type that this codec deserializes from and serializes to.
     *
     * @return The Java type this codec deserializes from and serializes to.
     */
    public DataType getCqlType()
    {
<span class="fc" id="L502">        return cqlType;</span>
    }

    /**
     * @return the length of values for this type if all values are of fixed length, {@link #VARIABLE_LENGTH} otherwise
     */
    public int serializedSize()
    {
<span class="fc" id="L510">        return VARIABLE_LENGTH;</span>
    }

    /**
     * Checks if all values are of fixed length.
     *
     * @return {@code true} if all values are of fixed length, {@code false} otherwise.
     */
    public final boolean isSerializedSizeFixed()
    {
<span class="fc bfc" id="L520" title="All 2 branches covered.">        return serializedSize() != VARIABLE_LENGTH;</span>
    }

    /**
     * Serialize the given value according to the CQL type handled by this codec.
     *
     * &lt;p&gt;Implementation notes:
     *
     * &lt;ol&gt;
     * &lt;li&gt;Null values should be gracefully handled and no exception should be raised; these should
     * be considered as the equivalent of a NULL CQL value;
     * &lt;li&gt;Codecs for CQL collection types should not permit null elements;
     * &lt;li&gt;Codecs for CQL collection types should treat a {@code null} input as the equivalent of an
     * empty collection.
     * &lt;/ol&gt;
     *
     * @param value           An instance of T; may be {@code null}.
     * @param protocolVersion the protocol version to use when serializing {@code bytes}. In most
     *                        cases, the proper value to provide for this argument is the value returned by {@code
     *                        ProtocolOptions#getProtocolVersion} (which is the protocol version in use by the driver).
     * @return A {@link ByteBuffer} instance containing the serialized form of T
     * @throws InvalidTypeException if the given value does not have the expected type
     */
    public abstract ByteBuffer serialize(T value, ProtocolVersion protocolVersion)
    throws InvalidTypeException;

    /**
     * Deserialize the given {@link ByteBuffer} instance according to the CQL type handled by this
     * codec.
     *
     * &lt;p&gt;Implementation notes:
     *
     * &lt;ol&gt;
     * &lt;li&gt;Null or empty buffers should be gracefully handled and no exception should be raised;
     * these should be considered as the equivalent of a NULL CQL value and, in most cases,
     * should map to {@code null} or a default value for the corresponding Java type, if
     * applicable;
     * &lt;li&gt;Codecs for CQL collection types should clearly document whether they return immutable
     * collections or not (note that the driver's default collection codecs return
     * &lt;em&gt;mutable&lt;/em&gt; collections);
     * &lt;li&gt;Codecs for CQL collection types should avoid returning {@code null}; they should return
     * empty collections instead (the driver's default collection codecs all comply with this
     * rule).
     * &lt;li&gt;The provided {@link ByteBuffer} should never be consumed by read operations that modify
     * its current position; if necessary, {@link ByteBuffer#duplicate()} duplicate} it before
     * consuming.
     * &lt;/ol&gt;
     *
     * @param bytes           A {@link ByteBuffer} instance containing the serialized form of T; may be {@code
     *                        null} or empty.
     * @param protocolVersion the protocol version to use when serializing {@code bytes}. In most
     *                        cases, the proper value to provide for this argument is the value returned by {@code
     *                        ProtocolOptions#getProtocolVersion} (which is the protocol version in use by the driver).
     * @return An instance of T
     * @throws InvalidTypeException if the given {@link ByteBuffer} instance cannot be deserialized
     */
    public abstract T deserialize(ByteBuffer bytes, ProtocolVersion protocolVersion)
    throws InvalidTypeException;

    /**
     * Parse the given CQL literal into an instance of the Java type handled by this codec.
     *
     * &lt;p&gt;Implementors should take care of unquoting and unescaping the given CQL string where
     * applicable. Null values and empty Strings should be accepted, as well as the string {@code
     * &quot;NULL&quot;}; in most cases, implementations should interpret these inputs has equivalent to a
     * {@code null} reference.
     *
     * &lt;p&gt;Implementing this method is not strictly mandatory: internally, the driver only uses it to
     * parse the INITCOND when building the metadata of an aggregate function (and in most cases it
     * will use a built-in codec, unless the INITCOND has a custom type).
     *
     * @param value The CQL string to parse, may be {@code null} or empty.
     * @return An instance of T; may be {@code null} on a {@code null input}.
     * @throws InvalidTypeException if the given value cannot be parsed into the expected type
     */
    public abstract T parse(String value) throws InvalidTypeException;

    /**
     * Format the given value as a valid CQL literal according to the CQL type handled by this codec.
     *
     * &lt;p&gt;Implementors should take care of quoting and escaping the resulting CQL literal where
     * applicable. Null values should be accepted; in most cases, implementations should return the
     * CQL keyword {@code &quot;NULL&quot;} for {@code null} inputs.
     *
     * &lt;p&gt;Implementing this method is not strictly mandatory. It is used:
     *
     * &lt;ol&gt;
     * &lt;li&gt;in the query builder, when values are inlined in the query string (see {@code
     * querybuilder.BuiltStatement} for a detailed explanation of when
     * this happens);
     * &lt;li&gt;in the {@code QueryLogger}, if parameter logging is enabled;
     * &lt;li&gt;to format the INITCOND in {@code AggregateMetadata#asCQLQuery(boolean)};
     * &lt;li&gt;in the {@code toString()} implementation of some objects ({@link UDTValue}, {@link
     * TupleValue}, and the internal representation of a {@code ROWS} response), which may
     * appear in driver logs.
     * &lt;/ol&gt;
     * &lt;p&gt;
     * If you choose not to implement this method, you should not throw an exception but instead
     * return a constant string (for example &quot;XxxCodec.format not implemented&quot;).
     *
     * @param value An instance of T; may be {@code null}.
     * @return CQL string
     * @throws InvalidTypeException if the given value does not have the expected type
     */
    public abstract String format(T value) throws InvalidTypeException;

    /**
     * Return {@code true} if this codec is capable of serializing the given {@code javaType}.
     *
     * &lt;p&gt;The implementation is &lt;em&gt;invariant&lt;/em&gt; with respect to the passed argument (through the
     * usage of {@link TypeToken#equals(Object)} and &lt;em&gt;it's strongly recommended not to modify this
     * behavior&lt;/em&gt;. This means that a codec will only ever return {@code true} for the
     * &lt;em&gt;exact&lt;/em&gt; Java type that it has been created for.
     *
     * &lt;p&gt;If the argument represents a Java primitive type, its wrapper type is considered instead.
     *
     * @param javaType The Java type this codec should serialize from and deserialize to; cannot be
     *                 {@code null}.
     * @return {@code true} if the codec is capable of serializing the given {@code javaType}, and
     * {@code false} otherwise.
     * @throws NullPointerException if {@code javaType} is {@code null}.
     */
    public boolean accepts(TypeToken&lt;?&gt; javaType)
    {
<span class="fc" id="L644">        checkNotNull(javaType, &quot;Parameter javaType cannot be null&quot;);</span>
<span class="fc" id="L645">        return this.javaType.equals(javaType.wrap());</span>
    }

    /**
     * Return {@code true} if this codec is capable of serializing the given {@code javaType}.
     *
     * &lt;p&gt;This implementation simply calls {@link #accepts(TypeToken)}.
     *
     * @param javaType The Java type this codec should serialize from and deserialize to; cannot be
     *                 {@code null}.
     * @return {@code true} if the codec is capable of serializing the given {@code javaType}, and
     * {@code false} otherwise.
     * @throws NullPointerException if {@code javaType} is {@code null}.
     */
    public boolean accepts(Class&lt;?&gt; javaType)
    {
<span class="nc" id="L661">        checkNotNull(javaType, &quot;Parameter javaType cannot be null&quot;);</span>
<span class="nc" id="L662">        return accepts(TypeToken.of(javaType));</span>
    }

    /**
     * Return {@code true} if this codec is capable of deserializing the given {@code cqlType}.
     *
     * @param cqlType The CQL type this codec should deserialize from and serialize to; cannot be
     *                {@code null}.
     * @return {@code true} if the codec is capable of deserializing the given {@code cqlType}, and
     * {@code false} otherwise.
     * @throws NullPointerException if {@code cqlType} is {@code null}.
     */
    public boolean accepts(DataType cqlType)
    {
<span class="fc" id="L676">        checkNotNull(cqlType, &quot;Parameter cqlType cannot be null&quot;);</span>
<span class="fc" id="L677">        return this.cqlType.equals(cqlType);</span>
    }

    /**
     * Return {@code true} if this codec is capable of serializing the given object. Note that the
     * object's Java type is inferred from the object' runtime (raw) type, contrary to {@link
     * #accepts(TypeToken)} which is capable of handling generic types.
     *
     * &lt;p&gt;This method is intended mostly to be used by the QueryBuilder when no type information is
     * available when the codec is used.
     *
     * &lt;p&gt;Implementation notes:
     *
     * &lt;ol&gt;
     * &lt;li&gt;The default implementation is &lt;em&gt;covariant&lt;/em&gt; with respect to the passed argument
     * (through the usage of {@code TypeToken#isAssignableFrom(TypeToken)} or {@link
     * TypeToken#isSupertypeOf(Type)}) and &lt;em&gt;it's strongly recommended not to modify this
     * behavior&lt;/em&gt;. This means that, by default, a codec will accept &lt;em&gt;any subtype&lt;/em&gt; of
     * the Java type that it has been created for.
     * &lt;li&gt;The base implementation provided here can only handle non-parameterized types; codecs
     * handling parameterized types, such as collection types, must override this method and
     * perform some sort of &quot;manual&quot; inspection of the actual type parameters.
     * &lt;li&gt;Similarly, codecs that only accept a partial subset of all possible values must override
     * this method and manually inspect the object to check if it complies or not with the
     * codec's limitations.
     * &lt;/ol&gt;
     *
     * @param value The Java type this codec should serialize from and deserialize to; cannot be
     *              {@code null}.
     * @return {@code true} if the codec is capable of serializing the given {@code javaType}, and
     * {@code false} otherwise.
     * @throws NullPointerException if {@code value} is {@code null}.
     */
    public boolean accepts(Object value)
    {
<span class="nc" id="L712">        checkNotNull(value, &quot;Parameter value cannot be null&quot;);</span>
<span class="nc" id="L713">        return this.javaType.isSupertypeOf(TypeToken.of(value.getClass()));</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L719">        return String.format(&quot;%s [%s &lt;-&gt; %s]&quot;, this.getClass().getSimpleName(), cqlType, javaType);</span>
    }

    /**
     * A codec that is capable of handling primitive booleans, thus avoiding the overhead of boxing
     * and unboxing such primitives.
     */
    public abstract static class PrimitiveBooleanCodec extends TypeCodec&lt;Boolean&gt;
    {

        PrimitiveBooleanCodec(DataType cqlType)
        {
<span class="fc" id="L731">            super(cqlType, Boolean.class);</span>
<span class="fc" id="L732">        }</span>

        public abstract ByteBuffer serializeNoBoxing(boolean v, ProtocolVersion protocolVersion);

        public abstract boolean deserializeNoBoxing(ByteBuffer v, ProtocolVersion protocolVersion);

        @Override
        public ByteBuffer serialize(Boolean value, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L741" title="1 of 2 branches missed.">            return value == null ? null : serializeNoBoxing(value, protocolVersion);</span>
        }

        @Override
        public Boolean deserialize(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L747" title="2 of 4 branches missed.">            return bytes == null || bytes.remaining() == 0</span>
<span class="nc" id="L748">                   ? null</span>
<span class="fc" id="L749">                   : deserializeNoBoxing(bytes, protocolVersion);</span>
        }
    }

    /**
     * A codec that is capable of handling primitive bytes, thus avoiding the overhead of boxing and
     * unboxing such primitives.
     */
    public abstract static class PrimitiveByteCodec extends TypeCodec&lt;Byte&gt;
    {

        PrimitiveByteCodec(DataType cqlType)
        {
<span class="fc" id="L762">            super(cqlType, Byte.class);</span>
<span class="fc" id="L763">        }</span>

        public abstract ByteBuffer serializeNoBoxing(byte v, ProtocolVersion protocolVersion);

        public abstract byte deserializeNoBoxing(ByteBuffer v, ProtocolVersion protocolVersion);

        @Override
        public ByteBuffer serialize(Byte value, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L772" title="1 of 2 branches missed.">            return value == null ? null : serializeNoBoxing(value, protocolVersion);</span>
        }

        @Override
        public Byte deserialize(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L778" title="2 of 4 branches missed.">            return bytes == null || bytes.remaining() == 0</span>
<span class="nc" id="L779">                   ? null</span>
<span class="fc" id="L780">                   : deserializeNoBoxing(bytes, protocolVersion);</span>
        }
    }

    /**
     * A codec that is capable of handling primitive shorts, thus avoiding the overhead of boxing and
     * unboxing such primitives.
     */
    public abstract static class PrimitiveShortCodec extends TypeCodec&lt;Short&gt;
    {

        PrimitiveShortCodec(DataType cqlType)
        {
<span class="fc" id="L793">            super(cqlType, Short.class);</span>
<span class="fc" id="L794">        }</span>

        public abstract ByteBuffer serializeNoBoxing(short v, ProtocolVersion protocolVersion);

        public abstract short deserializeNoBoxing(ByteBuffer v, ProtocolVersion protocolVersion);

        @Override
        public ByteBuffer serialize(Short value, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L803" title="1 of 2 branches missed.">            return value == null ? null : serializeNoBoxing(value, protocolVersion);</span>
        }

        @Override
        public Short deserialize(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L809" title="2 of 4 branches missed.">            return bytes == null || bytes.remaining() == 0</span>
<span class="nc" id="L810">                   ? null</span>
<span class="fc" id="L811">                   : deserializeNoBoxing(bytes, protocolVersion);</span>
        }
    }

    /**
     * A codec that is capable of handling primitive ints, thus avoiding the overhead of boxing and
     * unboxing such primitives.
     */
    public abstract static class PrimitiveIntCodec extends TypeCodec&lt;Integer&gt;
    {

        PrimitiveIntCodec(DataType cqlType)
        {
<span class="fc" id="L824">            super(cqlType, Integer.class);</span>
<span class="fc" id="L825">        }</span>

        public abstract ByteBuffer serializeNoBoxing(int v, ProtocolVersion protocolVersion);

        public abstract int deserializeNoBoxing(ByteBuffer v, ProtocolVersion protocolVersion);

        @Override
        public ByteBuffer serialize(Integer value, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L834" title="1 of 2 branches missed.">            return value == null ? null : serializeNoBoxing(value, protocolVersion);</span>
        }

        @Override
        public Integer deserialize(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L840" title="1 of 4 branches missed.">            return bytes == null || bytes.remaining() == 0</span>
<span class="fc" id="L841">                   ? null</span>
<span class="fc" id="L842">                   : deserializeNoBoxing(bytes, protocolVersion);</span>
        }
    }

    /**
     * A codec that is capable of handling primitive longs, thus avoiding the overhead of boxing and
     * unboxing such primitives.
     */
    public abstract static class PrimitiveLongCodec extends TypeCodec&lt;Long&gt;
    {

        PrimitiveLongCodec(DataType cqlType)
        {
<span class="fc" id="L855">            super(cqlType, Long.class);</span>
<span class="fc" id="L856">        }</span>

        public abstract ByteBuffer serializeNoBoxing(long v, ProtocolVersion protocolVersion);

        public abstract long deserializeNoBoxing(ByteBuffer v, ProtocolVersion protocolVersion);

        @Override
        public ByteBuffer serialize(Long value, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">            return value == null ? null : serializeNoBoxing(value, protocolVersion);</span>
        }

        @Override
        public Long deserialize(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L871" title="2 of 4 branches missed.">            return bytes == null || bytes.remaining() == 0</span>
<span class="nc" id="L872">                   ? null</span>
<span class="fc" id="L873">                   : deserializeNoBoxing(bytes, protocolVersion);</span>
        }
    }

    /**
     * A codec that is capable of handling primitive floats, thus avoiding the overhead of boxing and
     * unboxing such primitives.
     */
    public abstract static class PrimitiveFloatCodec extends TypeCodec&lt;Float&gt;
    {

        PrimitiveFloatCodec(DataType cqlType)
        {
<span class="fc" id="L886">            super(cqlType, Float.class);</span>
<span class="fc" id="L887">        }</span>

        public abstract ByteBuffer serializeNoBoxing(float v, ProtocolVersion protocolVersion);

        public abstract float deserializeNoBoxing(ByteBuffer v, ProtocolVersion protocolVersion);

        @Override
        public ByteBuffer serialize(Float value, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L896" title="1 of 2 branches missed.">            return value == null ? null : serializeNoBoxing(value, protocolVersion);</span>
        }

        @Override
        public Float deserialize(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L902" title="2 of 4 branches missed.">            return bytes == null || bytes.remaining() == 0</span>
<span class="nc" id="L903">                   ? null</span>
<span class="fc" id="L904">                   : deserializeNoBoxing(bytes, protocolVersion);</span>
        }
    }

    /**
     * A codec that is capable of handling primitive doubles, thus avoiding the overhead of boxing and
     * unboxing such primitives.
     */
    public abstract static class PrimitiveDoubleCodec extends TypeCodec&lt;Double&gt;
    {

        PrimitiveDoubleCodec(DataType cqlType)
        {
<span class="fc" id="L917">            super(cqlType, Double.class);</span>
<span class="fc" id="L918">        }</span>

        public abstract ByteBuffer serializeNoBoxing(double v, ProtocolVersion protocolVersion);

        public abstract double deserializeNoBoxing(ByteBuffer v, ProtocolVersion protocolVersion);

        @Override
        public ByteBuffer serialize(Double value, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L927" title="1 of 2 branches missed.">            return value == null ? null : serializeNoBoxing(value, protocolVersion);</span>
        }

        @Override
        public Double deserialize(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L933" title="2 of 4 branches missed.">            return bytes == null || bytes.remaining() == 0</span>
<span class="nc" id="L934">                   ? null</span>
<span class="fc" id="L935">                   : deserializeNoBoxing(bytes, protocolVersion);</span>
        }
    }

    /**
     * Base class for codecs handling CQL string types such as {@link DataType#varchar()}, {@link
     * DataType#text()} or {@link DataType#ascii()}.
     */
    private abstract static class StringCodec extends TypeCodec&lt;String&gt;
    {

        private final Charset charset;

        private StringCodec(DataType cqlType, Charset charset)
        {
<span class="fc" id="L950">            super(cqlType, String.class);</span>
<span class="fc" id="L951">            this.charset = charset;</span>
<span class="fc" id="L952">        }</span>

        @Override
        public String parse(String value)
        {
<span class="nc bnc" id="L957" title="All 6 branches missed.">            if (value == null || value.isEmpty() || value.equalsIgnoreCase(&quot;NULL&quot;)) return null;</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">            if (!ParseUtils.isQuoted(value))</span>
<span class="nc" id="L959">                throw new InvalidTypeException(&quot;text or varchar values must be enclosed by single quotes&quot;);</span>

<span class="nc" id="L961">            return ParseUtils.unquote(value);</span>
        }

        @Override
        public String format(String value)
        {
<span class="pc bpc" id="L967" title="1 of 2 branches missed.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="fc" id="L968">            return ParseUtils.quote(value);</span>
        }

        @Override
        public ByteBuffer serialize(String value, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L974" title="1 of 2 branches missed.">            return value == null ? null : ByteBuffer.wrap(value.getBytes(charset));</span>
        }

        /**
         * {@inheritDoc}
         *
         * &lt;p&gt;Implementation note: this method treats {@code null}s and empty buffers differently: the
         * formers are mapped to {@code null}s while the latters are mapped to empty strings.
         */
        @Override
        public String deserialize(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L986" title="1 of 2 branches missed.">            if (bytes == null) return null;</span>
<span class="fc bfc" id="L987" title="All 2 branches covered.">            if (bytes.remaining() == 0) return &quot;&quot;;</span>
<span class="fc" id="L988">            return new String(Bytes.getArray(bytes), charset);</span>
        }
    }

    /**
     * This codec maps a CQL {@link DataType#varchar()} to a Java {@link String}. Note that this codec
     * also handles {@link DataType#text()}, which is merely an alias for {@link DataType#varchar()}.
     */
    private static class VarcharCodec extends StringCodec
    {

<span class="fc" id="L999">        private static final VarcharCodec instance = new VarcharCodec();</span>

        private VarcharCodec()
        {
<span class="fc" id="L1003">            super(DataType.varchar(), Charset.forName(&quot;UTF-8&quot;));</span>
<span class="fc" id="L1004">        }</span>
    }

    /**
     * This codec maps a CQL {@link DataType#ascii()} to a Java {@link String}.
     */
    private static class AsciiCodec extends StringCodec
    {

<span class="fc" id="L1013">        private static final AsciiCodec instance = new AsciiCodec();</span>

<span class="fc" id="L1015">        private static final Pattern ASCII_PATTERN = Pattern.compile(&quot;^\\p{ASCII}*$&quot;);</span>

        private AsciiCodec()
        {
<span class="fc" id="L1019">            super(DataType.ascii(), Charset.forName(&quot;US-ASCII&quot;));</span>
<span class="fc" id="L1020">        }</span>

        @Override
        public ByteBuffer serialize(String value, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L1025" title="2 of 4 branches missed.">            if (value != null &amp;&amp; !ASCII_PATTERN.matcher(value).matches())</span>
            {
<span class="nc" id="L1027">                throw new InvalidTypeException(String.format(&quot;%s is not a valid ASCII String&quot;, value));</span>
            }
<span class="fc" id="L1029">            return super.serialize(value, protocolVersion);</span>
        }

        @Override
        public String format(String value)
        {
<span class="pc bpc" id="L1035" title="2 of 4 branches missed.">            if (value != null &amp;&amp; !ASCII_PATTERN.matcher(value).matches())</span>
            {
<span class="nc" id="L1037">                throw new InvalidTypeException(String.format(&quot;%s is not a valid ASCII String&quot;, value));</span>
            }
<span class="fc" id="L1039">            return super.format(value);</span>
        }
    }

    /**
     * Base class for codecs handling CQL 8-byte integer types such as {@link DataType#bigint()},
     * {@link DataType#counter()} or {@link DataType#time()}.
     */
    private abstract static class LongCodec extends PrimitiveLongCodec
    {

        private LongCodec(DataType cqlType)
        {
<span class="fc" id="L1052">            super(cqlType);</span>
<span class="fc" id="L1053">        }</span>

        @Override
        public int serializedSize()
        {
<span class="nc" id="L1058">            return 8;</span>
        }

        @Override
        public Long parse(String value)
        {
            try
            {
<span class="nc bnc" id="L1066" title="All 6 branches missed.">                return value == null || value.isEmpty() || value.equalsIgnoreCase(&quot;NULL&quot;)</span>
<span class="nc" id="L1067">                       ? null</span>
<span class="nc" id="L1068">                       : Long.parseLong(value);</span>
            }
<span class="nc" id="L1070">            catch (NumberFormatException e)</span>
            {
<span class="nc" id="L1072">                throw new InvalidTypeException(</span>
<span class="nc" id="L1073">                String.format(&quot;Cannot parse 64-bits long value from \&quot;%s\&quot;&quot;, value));</span>
            }
        }

        @Override
        public String format(Long value)
        {
<span class="nc bnc" id="L1080" title="All 2 branches missed.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="nc" id="L1081">            return Long.toString(value);</span>
        }

        @Override
        public ByteBuffer serializeNoBoxing(long value, ProtocolVersion protocolVersion)
        {
<span class="fc" id="L1087">            ByteBuffer bb = ByteBuffer.allocate(8);</span>
<span class="fc" id="L1088">            bb.putLong(0, value);</span>
<span class="fc" id="L1089">            return bb;</span>
        }

        @Override
        public long deserializeNoBoxing(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L1095" title="2 of 4 branches missed.">            if (bytes == null || bytes.remaining() == 0) return 0;</span>
<span class="pc bpc" id="L1096" title="1 of 2 branches missed.">            if (bytes.remaining() != 8)</span>
<span class="nc" id="L1097">                throw new InvalidTypeException(</span>
<span class="nc" id="L1098">                &quot;Invalid 64-bits long value, expecting 8 bytes but got &quot; + bytes.remaining());</span>

<span class="fc" id="L1100">            return bytes.getLong(bytes.position());</span>
        }
    }

    /**
     * This codec maps a CQL {@link DataType#bigint()} to a Java {@link Long}.
     */
    private static class BigintCodec extends LongCodec
    {

<span class="fc" id="L1110">        private static final BigintCodec instance = new BigintCodec();</span>

        private BigintCodec()
        {
<span class="fc" id="L1114">            super(DataType.bigint());</span>
<span class="fc" id="L1115">        }</span>
    }

    /**
     * This codec maps a CQL {@link DataType#counter()} to a Java {@link Long}.
     */
    private static class CounterCodec extends LongCodec
    {

<span class="fc" id="L1124">        private static final CounterCodec instance = new CounterCodec();</span>

        private CounterCodec()
        {
<span class="fc" id="L1128">            super(DataType.counter());</span>
<span class="fc" id="L1129">        }</span>
    }

    /**
     * This codec maps a CQL {@link DataType#blob()} to a Java {@link ByteBuffer}.
     */
    private static class BlobCodec extends TypeCodec&lt;ByteBuffer&gt;
    {

<span class="fc" id="L1138">        private static final BlobCodec instance = new BlobCodec();</span>

        private BlobCodec()
        {
<span class="fc" id="L1142">            super(DataType.blob(), ByteBuffer.class);</span>
<span class="fc" id="L1143">        }</span>

        @Override
        public ByteBuffer parse(String value)
        {
<span class="nc bnc" id="L1148" title="All 6 branches missed.">            return value == null || value.isEmpty() || value.equalsIgnoreCase(&quot;NULL&quot;)</span>
<span class="nc" id="L1149">                   ? null</span>
<span class="nc" id="L1150">                   : Bytes.fromHexString(value);</span>
        }

        @Override
        public String format(ByteBuffer value)
        {
<span class="nc bnc" id="L1156" title="All 2 branches missed.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="nc" id="L1157">            return Bytes.toHexString(value);</span>
        }

        @Override
        public ByteBuffer serialize(ByteBuffer value, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L1163" title="1 of 2 branches missed.">            return value == null ? null : value.duplicate();</span>
        }

        @Override
        public ByteBuffer deserialize(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L1169" title="1 of 2 branches missed.">            return bytes == null ? null : bytes.duplicate();</span>
        }
    }

    /**
     * This codec maps a CQL {@link DataType#custom(String) custom} type to a Java {@link ByteBuffer}.
     * Note that no instance of this codec is part of the default set of codecs used by the Java
     * driver; instances of this codec must be manually registered.
     */
<span class="fc" id="L1178">    private static class CustomCodec extends TypeCodec&lt;ByteBuffer&gt;</span>
    {

        private CustomCodec(DataType custom)
        {
<span class="fc" id="L1183">            super(custom, ByteBuffer.class);</span>
<span class="pc bpc" id="L1184" title="1 of 2 branches missed.">            assert custom.getName() == Name.CUSTOM;</span>
<span class="fc" id="L1185">        }</span>

        @Override
        public ByteBuffer parse(String value)
        {
<span class="nc bnc" id="L1190" title="All 6 branches missed.">            return value == null || value.isEmpty() || value.equalsIgnoreCase(&quot;NULL&quot;)</span>
<span class="nc" id="L1191">                   ? null</span>
<span class="nc" id="L1192">                   : Bytes.fromHexString(value);</span>
        }

        @Override
        public String format(ByteBuffer value)
        {
<span class="nc bnc" id="L1198" title="All 2 branches missed.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="nc" id="L1199">            return Bytes.toHexString(value);</span>
        }

        @Override
        public ByteBuffer serialize(ByteBuffer value, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L1205" title="1 of 2 branches missed.">            return value == null ? null : value.duplicate();</span>
        }

        @Override
        public ByteBuffer deserialize(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L1211" title="1 of 2 branches missed.">            return bytes == null ? null : bytes.duplicate();</span>
        }
    }

    /**
     * This codec maps a CQL {@link DataType#cboolean()} to a Java {@link Boolean}.
     */
    private static class BooleanCodec extends PrimitiveBooleanCodec
    {

<span class="fc" id="L1221">        private static final ByteBuffer TRUE = ByteBuffer.wrap(new byte[]{ 1 });</span>
<span class="fc" id="L1222">        private static final ByteBuffer FALSE = ByteBuffer.wrap(new byte[]{ 0 });</span>

<span class="fc" id="L1224">        private static final BooleanCodec instance = new BooleanCodec();</span>

        private BooleanCodec()
        {
<span class="fc" id="L1228">            super(DataType.cboolean());</span>
<span class="fc" id="L1229">        }</span>

        @Override
        public int serializedSize()
        {
<span class="nc" id="L1234">            return 1;</span>
        }

        @Override
        public Boolean parse(String value)
        {
<span class="nc bnc" id="L1240" title="All 6 branches missed.">            if (value == null || value.isEmpty() || value.equalsIgnoreCase(&quot;NULL&quot;)) return null;</span>
<span class="nc bnc" id="L1241" title="All 2 branches missed.">            if (value.equalsIgnoreCase(Boolean.FALSE.toString())) return false;</span>
<span class="nc bnc" id="L1242" title="All 2 branches missed.">            if (value.equalsIgnoreCase(Boolean.TRUE.toString())) return true;</span>

<span class="nc" id="L1244">            throw new InvalidTypeException(</span>
<span class="nc" id="L1245">            String.format(&quot;Cannot parse boolean value from \&quot;%s\&quot;&quot;, value));</span>
        }

        @Override
        public String format(Boolean value)
        {
<span class="nc bnc" id="L1251" title="All 2 branches missed.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="nc bnc" id="L1252" title="All 2 branches missed.">            return value ? &quot;true&quot; : &quot;false&quot;;</span>
        }

        @Override
        public ByteBuffer serializeNoBoxing(boolean value, ProtocolVersion protocolVersion)
        {
<span class="fc bfc" id="L1258" title="All 2 branches covered.">            return value ? TRUE.duplicate() : FALSE.duplicate();</span>
        }

        @Override
        public boolean deserializeNoBoxing(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L1264" title="2 of 4 branches missed.">            if (bytes == null || bytes.remaining() == 0) return false;</span>
<span class="pc bpc" id="L1265" title="1 of 2 branches missed.">            if (bytes.remaining() != 1)</span>
<span class="nc" id="L1266">                throw new InvalidTypeException(</span>
<span class="nc" id="L1267">                &quot;Invalid boolean value, expecting 1 byte but got &quot; + bytes.remaining());</span>

<span class="fc bfc" id="L1269" title="All 2 branches covered.">            return bytes.get(bytes.position()) != 0;</span>
        }
    }

    /**
     * This codec maps a CQL {@link DataType#decimal()} to a Java {@link BigDecimal}.
     */
    private static class DecimalCodec extends TypeCodec&lt;BigDecimal&gt;
    {

<span class="fc" id="L1279">        private static final DecimalCodec instance = new DecimalCodec();</span>

        private DecimalCodec()
        {
<span class="fc" id="L1283">            super(DataType.decimal(), BigDecimal.class);</span>
<span class="fc" id="L1284">        }</span>

        @Override
        public BigDecimal parse(String value)
        {
            try
            {
<span class="nc bnc" id="L1291" title="All 6 branches missed.">                return value == null || value.isEmpty() || value.equalsIgnoreCase(&quot;NULL&quot;)</span>
<span class="nc" id="L1292">                       ? null</span>
<span class="nc" id="L1293">                       : new BigDecimal(value);</span>
            }
<span class="nc" id="L1295">            catch (NumberFormatException e)</span>
            {
<span class="nc" id="L1297">                throw new InvalidTypeException(</span>
<span class="nc" id="L1298">                String.format(&quot;Cannot parse decimal value from \&quot;%s\&quot;&quot;, value));</span>
            }
        }

        @Override
        public String format(BigDecimal value)
        {
<span class="nc bnc" id="L1305" title="All 2 branches missed.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="nc" id="L1306">            return value.toString();</span>
        }

        @Override
        public ByteBuffer serialize(BigDecimal value, ProtocolVersion protocolVersion)
        {
<span class="nc bnc" id="L1312" title="All 2 branches missed.">            if (value == null) return null;</span>
<span class="nc" id="L1313">            BigInteger bi = value.unscaledValue();</span>
<span class="nc" id="L1314">            int scale = value.scale();</span>
<span class="nc" id="L1315">            byte[] bibytes = bi.toByteArray();</span>

<span class="nc" id="L1317">            ByteBuffer bytes = ByteBuffer.allocate(4 + bibytes.length);</span>
<span class="nc" id="L1318">            bytes.putInt(scale);</span>
<span class="nc" id="L1319">            bytes.put(bibytes);</span>
<span class="nc" id="L1320">            bytes.rewind();</span>
<span class="nc" id="L1321">            return bytes;</span>
        }

        @Override
        public BigDecimal deserialize(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="nc bnc" id="L1327" title="All 4 branches missed.">            if (bytes == null || bytes.remaining() == 0) return null;</span>
<span class="nc bnc" id="L1328" title="All 2 branches missed.">            if (bytes.remaining() &lt; 4)</span>
<span class="nc" id="L1329">                throw new InvalidTypeException(</span>
<span class="nc" id="L1330">                &quot;Invalid decimal value, expecting at least 4 bytes but got &quot; + bytes.remaining());</span>

<span class="nc" id="L1332">            bytes = bytes.duplicate();</span>
<span class="nc" id="L1333">            int scale = bytes.getInt();</span>
<span class="nc" id="L1334">            byte[] bibytes = new byte[bytes.remaining()];</span>
<span class="nc" id="L1335">            bytes.get(bibytes);</span>

<span class="nc" id="L1337">            BigInteger bi = new BigInteger(bibytes);</span>
<span class="nc" id="L1338">            return new BigDecimal(bi, scale);</span>
        }
    }

    /**
     * This codec maps a CQL {@link DataType#cdouble()} to a Java {@link Double}.
     */
    private static class DoubleCodec extends PrimitiveDoubleCodec
    {

<span class="fc" id="L1348">        private static final DoubleCodec instance = new DoubleCodec();</span>

        private DoubleCodec()
        {
<span class="fc" id="L1352">            super(DataType.cdouble());</span>
<span class="fc" id="L1353">        }</span>

        @Override
        public int serializedSize()
        {
<span class="fc" id="L1358">            return 8;</span>
        }

        @Override
        public Double parse(String value)
        {
            try
            {
<span class="nc bnc" id="L1366" title="All 6 branches missed.">                return value == null || value.isEmpty() || value.equalsIgnoreCase(&quot;NULL&quot;)</span>
<span class="nc" id="L1367">                       ? null</span>
<span class="nc" id="L1368">                       : Double.parseDouble(value);</span>
            }
<span class="nc" id="L1370">            catch (NumberFormatException e)</span>
            {
<span class="nc" id="L1372">                throw new InvalidTypeException(</span>
<span class="nc" id="L1373">                String.format(&quot;Cannot parse 64-bits double value from \&quot;%s\&quot;&quot;, value));</span>
            }
        }

        @Override
        public String format(Double value)
        {
<span class="nc bnc" id="L1380" title="All 2 branches missed.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="nc" id="L1381">            return Double.toString(value);</span>
        }

        @Override
        public ByteBuffer serializeNoBoxing(double value, ProtocolVersion protocolVersion)
        {
<span class="fc" id="L1387">            ByteBuffer bb = ByteBuffer.allocate(8);</span>
<span class="fc" id="L1388">            bb.putDouble(0, value);</span>
<span class="fc" id="L1389">            return bb;</span>
        }

        @Override
        public double deserializeNoBoxing(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L1395" title="1 of 4 branches missed.">            if (bytes == null || bytes.remaining() == 0) return 0;</span>
<span class="pc bpc" id="L1396" title="1 of 2 branches missed.">            if (bytes.remaining() != 8)</span>
<span class="nc" id="L1397">                throw new InvalidTypeException(</span>
<span class="nc" id="L1398">                &quot;Invalid 64-bits double value, expecting 8 bytes but got &quot; + bytes.remaining());</span>

<span class="fc" id="L1400">            return bytes.getDouble(bytes.position());</span>
        }
    }

    /**
     * This codec maps a CQL {@link DataType#cfloat()} to a Java {@link Float}.
     */
    private static class FloatCodec extends PrimitiveFloatCodec
    {

<span class="fc" id="L1410">        private static final FloatCodec instance = new FloatCodec();</span>

        private FloatCodec()
        {
<span class="fc" id="L1414">            super(DataType.cfloat());</span>
<span class="fc" id="L1415">        }</span>

        @Override
        public int serializedSize()
        {
<span class="nc" id="L1420">            return 4;</span>
        }

        @Override
        public Float parse(String value)
        {
            try
            {
<span class="nc bnc" id="L1428" title="All 6 branches missed.">                return value == null || value.isEmpty() || value.equalsIgnoreCase(&quot;NULL&quot;)</span>
<span class="nc" id="L1429">                       ? null</span>
<span class="nc" id="L1430">                       : Float.parseFloat(value);</span>
            }
<span class="nc" id="L1432">            catch (NumberFormatException e)</span>
            {
<span class="nc" id="L1434">                throw new InvalidTypeException(</span>
<span class="nc" id="L1435">                String.format(&quot;Cannot parse 32-bits float value from \&quot;%s\&quot;&quot;, value));</span>
            }
        }

        @Override
        public String format(Float value)
        {
<span class="nc bnc" id="L1442" title="All 2 branches missed.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="nc" id="L1443">            return Float.toString(value);</span>
        }

        @Override
        public ByteBuffer serializeNoBoxing(float value, ProtocolVersion protocolVersion)
        {
<span class="fc" id="L1449">            ByteBuffer bb = ByteBuffer.allocate(4);</span>
<span class="fc" id="L1450">            bb.putFloat(0, value);</span>
<span class="fc" id="L1451">            return bb;</span>
        }

        @Override
        public float deserializeNoBoxing(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L1457" title="2 of 4 branches missed.">            if (bytes == null || bytes.remaining() == 0) return 0;</span>
<span class="pc bpc" id="L1458" title="1 of 2 branches missed.">            if (bytes.remaining() != 4)</span>
<span class="nc" id="L1459">                throw new InvalidTypeException(</span>
<span class="nc" id="L1460">                &quot;Invalid 32-bits float value, expecting 4 bytes but got &quot; + bytes.remaining());</span>

<span class="fc" id="L1462">            return bytes.getFloat(bytes.position());</span>
        }
    }

    /**
     * This codec maps a CQL {@link DataType#inet()} to a Java {@link InetAddress}.
     */
    private static class InetCodec extends TypeCodec&lt;InetAddress&gt;
    {

<span class="fc" id="L1472">        private static final InetCodec instance = new InetCodec();</span>

        private InetCodec()
        {
<span class="fc" id="L1476">            super(DataType.inet(), InetAddress.class);</span>
<span class="fc" id="L1477">        }</span>

        @Override
        public InetAddress parse(String value)
        {
<span class="nc bnc" id="L1482" title="All 6 branches missed.">            if (value == null || value.isEmpty() || value.equalsIgnoreCase(&quot;NULL&quot;)) return null;</span>

<span class="nc" id="L1484">            value = value.trim();</span>
<span class="nc bnc" id="L1485" title="All 2 branches missed.">            if (!ParseUtils.isQuoted(value))</span>
<span class="nc" id="L1486">                throw new InvalidTypeException(</span>
<span class="nc" id="L1487">                String.format(&quot;inet values must be enclosed in single quotes (\&quot;%s\&quot;)&quot;, value));</span>
            try
            {
<span class="nc" id="L1490">                return InetAddress.getByName(value.substring(1, value.length() - 1));</span>
            }
<span class="nc" id="L1492">            catch (Exception e)</span>
            {
<span class="nc" id="L1494">                throw new InvalidTypeException(String.format(&quot;Cannot parse inet value from \&quot;%s\&quot;&quot;, value));</span>
            }
        }

        @Override
        public String format(InetAddress value)
        {
<span class="pc bpc" id="L1501" title="1 of 2 branches missed.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="fc" id="L1502">            return '\'' + value.getHostAddress() + '\'';</span>
        }

        @Override
        public ByteBuffer serialize(InetAddress value, ProtocolVersion protocolVersion)
        {
<span class="nc bnc" id="L1508" title="All 2 branches missed.">            return value == null ? null : ByteBuffer.wrap(value.getAddress());</span>
        }

        @Override
        public InetAddress deserialize(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="nc bnc" id="L1514" title="All 4 branches missed.">            if (bytes == null || bytes.remaining() == 0) return null;</span>
            try
            {
<span class="nc" id="L1517">                return InetAddress.getByAddress(Bytes.getArray(bytes));</span>
            }
<span class="nc" id="L1519">            catch (UnknownHostException e)</span>
            {
<span class="nc" id="L1521">                throw new InvalidTypeException(</span>
<span class="nc" id="L1522">                &quot;Invalid bytes for inet value, got &quot; + bytes.remaining() + &quot; bytes&quot;);</span>
            }
        }
    }

    /**
     * This codec maps a CQL {@link DataType#tinyint()} to a Java {@link Byte}.
     */
    private static class TinyIntCodec extends PrimitiveByteCodec
    {

<span class="fc" id="L1533">        private static final TinyIntCodec instance = new TinyIntCodec();</span>

        private TinyIntCodec()
        {
<span class="fc" id="L1537">            super(tinyint());</span>
<span class="fc" id="L1538">        }</span>

        @Override
        public Byte parse(String value)
        {
            try
            {
<span class="nc bnc" id="L1545" title="All 6 branches missed.">                return value == null || value.isEmpty() || value.equalsIgnoreCase(&quot;NULL&quot;)</span>
<span class="nc" id="L1546">                       ? null</span>
<span class="nc" id="L1547">                       : Byte.parseByte(value);</span>
            }
<span class="nc" id="L1549">            catch (NumberFormatException e)</span>
            {
<span class="nc" id="L1551">                throw new InvalidTypeException(</span>
<span class="nc" id="L1552">                String.format(&quot;Cannot parse 8-bits int value from \&quot;%s\&quot;&quot;, value));</span>
            }
        }

        @Override
        public String format(Byte value)
        {
<span class="nc bnc" id="L1559" title="All 2 branches missed.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="nc" id="L1560">            return Byte.toString(value);</span>
        }

        @Override
        public ByteBuffer serializeNoBoxing(byte value, ProtocolVersion protocolVersion)
        {
<span class="fc" id="L1566">            ByteBuffer bb = ByteBuffer.allocate(1);</span>
<span class="fc" id="L1567">            bb.put(0, value);</span>
<span class="fc" id="L1568">            return bb;</span>
        }

        @Override
        public byte deserializeNoBoxing(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L1574" title="2 of 4 branches missed.">            if (bytes == null || bytes.remaining() == 0) return 0;</span>
<span class="pc bpc" id="L1575" title="1 of 2 branches missed.">            if (bytes.remaining() != 1)</span>
<span class="nc" id="L1576">                throw new InvalidTypeException(</span>
<span class="nc" id="L1577">                &quot;Invalid 8-bits integer value, expecting 1 byte but got &quot; + bytes.remaining());</span>

<span class="fc" id="L1579">            return bytes.get(bytes.position());</span>
        }
    }

    /**
     * This codec maps a CQL {@link DataType#smallint()} to a Java {@link Short}.
     */
    private static class SmallIntCodec extends PrimitiveShortCodec
    {

<span class="fc" id="L1589">        private static final SmallIntCodec instance = new SmallIntCodec();</span>

        private SmallIntCodec()
        {
<span class="fc" id="L1593">            super(smallint());</span>
<span class="fc" id="L1594">        }</span>

        @Override
        public Short parse(String value)
        {
            try
            {
<span class="nc bnc" id="L1601" title="All 6 branches missed.">                return value == null || value.isEmpty() || value.equalsIgnoreCase(&quot;NULL&quot;)</span>
<span class="nc" id="L1602">                       ? null</span>
<span class="nc" id="L1603">                       : Short.parseShort(value);</span>
            }
<span class="nc" id="L1605">            catch (NumberFormatException e)</span>
            {
<span class="nc" id="L1607">                throw new InvalidTypeException(</span>
<span class="nc" id="L1608">                String.format(&quot;Cannot parse 16-bits int value from \&quot;%s\&quot;&quot;, value));</span>
            }
        }

        @Override
        public String format(Short value)
        {
<span class="nc bnc" id="L1615" title="All 2 branches missed.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="nc" id="L1616">            return Short.toString(value);</span>
        }

        @Override
        public ByteBuffer serializeNoBoxing(short value, ProtocolVersion protocolVersion)
        {
<span class="fc" id="L1622">            ByteBuffer bb = ByteBuffer.allocate(2);</span>
<span class="fc" id="L1623">            bb.putShort(0, value);</span>
<span class="fc" id="L1624">            return bb;</span>
        }

        @Override
        public short deserializeNoBoxing(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L1630" title="2 of 4 branches missed.">            if (bytes == null || bytes.remaining() == 0) return 0;</span>
<span class="pc bpc" id="L1631" title="1 of 2 branches missed.">            if (bytes.remaining() != 2)</span>
<span class="nc" id="L1632">                throw new InvalidTypeException(</span>
<span class="nc" id="L1633">                &quot;Invalid 16-bits integer value, expecting 2 bytes but got &quot; + bytes.remaining());</span>

<span class="fc" id="L1635">            return bytes.getShort(bytes.position());</span>
        }
    }

    /**
     * This codec maps a CQL {@link DataType#cint()} to a Java {@link Integer}.
     */
    private static class IntCodec extends PrimitiveIntCodec
    {

<span class="fc" id="L1645">        private static final IntCodec instance = new IntCodec();</span>

        private IntCodec()
        {
<span class="fc" id="L1649">            super(DataType.cint());</span>
<span class="fc" id="L1650">        }</span>

        @Override
        public int serializedSize()
        {
<span class="fc" id="L1655">            return 4;</span>
        }

        @Override
        public Integer parse(String value)
        {
            try
            {
<span class="nc bnc" id="L1663" title="All 6 branches missed.">                return value == null || value.isEmpty() || value.equalsIgnoreCase(&quot;NULL&quot;)</span>
<span class="nc" id="L1664">                       ? null</span>
<span class="nc" id="L1665">                       : Integer.parseInt(value);</span>
            }
<span class="nc" id="L1667">            catch (NumberFormatException e)</span>
            {
<span class="nc" id="L1669">                throw new InvalidTypeException(</span>
<span class="nc" id="L1670">                String.format(&quot;Cannot parse 32-bits int value from \&quot;%s\&quot;&quot;, value));</span>
            }
        }

        @Override
        public String format(Integer value)
        {
<span class="fc bfc" id="L1677" title="All 2 branches covered.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="fc" id="L1678">            return Integer.toString(value);</span>
        }

        @Override
        public ByteBuffer serializeNoBoxing(int value, ProtocolVersion protocolVersion)
        {
<span class="fc" id="L1684">            ByteBuffer bb = ByteBuffer.allocate(4);</span>
<span class="fc" id="L1685">            bb.putInt(0, value);</span>
<span class="fc" id="L1686">            return bb;</span>
        }

        @Override
        public int deserializeNoBoxing(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L1692" title="2 of 4 branches missed.">            if (bytes == null || bytes.remaining() == 0) return 0;</span>
<span class="pc bpc" id="L1693" title="1 of 2 branches missed.">            if (bytes.remaining() != 4)</span>
<span class="nc" id="L1694">                throw new InvalidTypeException(</span>
<span class="nc" id="L1695">                &quot;Invalid 32-bits integer value, expecting 4 bytes but got &quot; + bytes.remaining());</span>

<span class="fc" id="L1697">            return bytes.getInt(bytes.position());</span>
        }
    }

    /**
     * This codec maps a CQL {@link DataType#timestamp()} to a Java {@link Date}.
     */
    private static class TimestampCodec extends TypeCodec&lt;Date&gt;
    {

<span class="fc" id="L1707">        private static final TimestampCodec instance = new TimestampCodec();</span>

        private TimestampCodec()
        {
<span class="fc" id="L1711">            super(DataType.timestamp(), Date.class);</span>
<span class="fc" id="L1712">        }</span>

        @Override
        public int serializedSize()
        {
<span class="nc" id="L1717">            return 8;</span>
        }

        @Override
        public Date parse(String value)
        {
<span class="nc bnc" id="L1723" title="All 6 branches missed.">            if (value == null || value.isEmpty() || value.equalsIgnoreCase(&quot;NULL&quot;)) return null;</span>
            // strip enclosing single quotes, if any
<span class="nc bnc" id="L1725" title="All 2 branches missed.">            if (ParseUtils.isQuoted(value)) value = ParseUtils.unquote(value);</span>

<span class="nc bnc" id="L1727" title="All 2 branches missed.">            if (ParseUtils.isLongLiteral(value))</span>
            {
                try
                {
<span class="nc" id="L1731">                    return new Date(Long.parseLong(value));</span>
                }
<span class="nc" id="L1733">                catch (NumberFormatException e)</span>
                {
<span class="nc" id="L1735">                    throw new InvalidTypeException(</span>
<span class="nc" id="L1736">                    String.format(&quot;Cannot parse timestamp value from \&quot;%s\&quot;&quot;, value));</span>
                }
            }

            try
            {
<span class="nc" id="L1742">                return ParseUtils.parseDate(value);</span>
            }
<span class="nc" id="L1744">            catch (ParseException e)</span>
            {
<span class="nc" id="L1746">                throw new InvalidTypeException(</span>
<span class="nc" id="L1747">                String.format(&quot;Cannot parse timestamp value from \&quot;%s\&quot;&quot;, value));</span>
            }
        }

        @Override
        public String format(Date value)
        {
<span class="nc bnc" id="L1754" title="All 2 branches missed.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="nc" id="L1755">            return Long.toString(value.getTime());</span>
        }

        @Override
        public ByteBuffer serialize(Date value, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L1761" title="1 of 2 branches missed.">            return value == null</span>
<span class="nc" id="L1762">                   ? null</span>
<span class="fc" id="L1763">                   : BigintCodec.instance.serializeNoBoxing(value.getTime(), protocolVersion);</span>
        }

        @Override
        public Date deserialize(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L1769" title="2 of 4 branches missed.">            return bytes == null || bytes.remaining() == 0</span>
<span class="nc" id="L1770">                   ? null</span>
<span class="fc" id="L1771">                   : new Date(BigintCodec.instance.deserializeNoBoxing(bytes, protocolVersion));</span>
        }
    }

    /**
     * This codec maps a CQL {@link DataType#date()} to the custom {@link LocalDate} class.
     */
    private static class DateCodec extends TypeCodec&lt;LocalDate&gt;
    {

<span class="fc" id="L1781">        private static final DateCodec instance = new DateCodec();</span>

        private static final String pattern = &quot;yyyy-MM-dd&quot;;

        private DateCodec()
        {
<span class="fc" id="L1787">            super(DataType.date(), LocalDate.class);</span>
<span class="fc" id="L1788">        }</span>

        @Override
        public int serializedSize()
        {
<span class="nc" id="L1793">            return 8;</span>
        }

        @Override
        public LocalDate parse(String value)
        {
<span class="nc bnc" id="L1799" title="All 6 branches missed.">            if (value == null || value.isEmpty() || value.equalsIgnoreCase(&quot;NULL&quot;)) return null;</span>

            // single quotes are optional for long literals, mandatory for date patterns
            // strip enclosing single quotes, if any
<span class="nc bnc" id="L1803" title="All 2 branches missed.">            if (ParseUtils.isQuoted(value)) value = ParseUtils.unquote(value);</span>

<span class="nc bnc" id="L1805" title="All 2 branches missed.">            if (ParseUtils.isLongLiteral(value))</span>
            {
                long unsigned;
                try
                {
<span class="nc" id="L1810">                    unsigned = Long.parseLong(value);</span>
                }
<span class="nc" id="L1812">                catch (NumberFormatException e)</span>
                {
<span class="nc" id="L1814">                    throw new InvalidTypeException(</span>
<span class="nc" id="L1815">                    String.format(&quot;Cannot parse date value from \&quot;%s\&quot;&quot;, value), e);</span>
<span class="nc" id="L1816">                }</span>
                try
                {
<span class="nc" id="L1819">                    int days = CodecUtils.fromCqlDateToDaysSinceEpoch(unsigned);</span>
<span class="nc" id="L1820">                    return LocalDate.fromDaysSinceEpoch(days);</span>
                }
<span class="nc" id="L1822">                catch (IllegalArgumentException e)</span>
                {
<span class="nc" id="L1824">                    throw new InvalidTypeException(</span>
<span class="nc" id="L1825">                    String.format(&quot;Cannot parse date value from \&quot;%s\&quot;&quot;, value), e);</span>
                }
            }

            try
            {
<span class="nc" id="L1831">                Date date = ParseUtils.parseDate(value, pattern);</span>
<span class="nc" id="L1832">                return LocalDate.fromMillisSinceEpoch(date.getTime());</span>
            }
<span class="nc" id="L1834">            catch (ParseException e)</span>
            {
<span class="nc" id="L1836">                throw new InvalidTypeException(</span>
<span class="nc" id="L1837">                String.format(&quot;Cannot parse date value from \&quot;%s\&quot;&quot;, value), e);</span>
            }
        }

        @Override
        public String format(LocalDate value)
        {
<span class="nc bnc" id="L1844" title="All 2 branches missed.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="nc" id="L1845">            return ParseUtils.quote(value.toString());</span>
        }

        @Override
        public ByteBuffer serialize(LocalDate value, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L1851" title="1 of 2 branches missed.">            if (value == null) return null;</span>
<span class="fc" id="L1852">            int unsigned = CodecUtils.fromSignedToUnsignedInt(value.getDaysSinceEpoch());</span>
<span class="fc" id="L1853">            return IntCodec.instance.serializeNoBoxing(unsigned, protocolVersion);</span>
        }

        @Override
        public LocalDate deserialize(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L1859" title="2 of 4 branches missed.">            if (bytes == null || bytes.remaining() == 0) return null;</span>
<span class="fc" id="L1860">            int unsigned = IntCodec.instance.deserializeNoBoxing(bytes, protocolVersion);</span>
<span class="fc" id="L1861">            int signed = CodecUtils.fromUnsignedToSignedInt(unsigned);</span>
<span class="fc" id="L1862">            return LocalDate.fromDaysSinceEpoch(signed);</span>
        }
    }

    /**
     * This codec maps a CQL {@link DataType#time()} to a Java {@link Long}.
     */
    private static class TimeCodec extends LongCodec
    {

<span class="fc" id="L1872">        private static final TimeCodec instance = new TimeCodec();</span>

        private TimeCodec()
        {
<span class="fc" id="L1876">            super(DataType.time());</span>
<span class="fc" id="L1877">        }</span>

        @Override
        public Long parse(String value)
        {
<span class="nc bnc" id="L1882" title="All 6 branches missed.">            if (value == null || value.isEmpty() || value.equalsIgnoreCase(&quot;NULL&quot;)) return null;</span>

            // enclosing single quotes required, even for long literals
<span class="nc bnc" id="L1885" title="All 2 branches missed.">            if (!ParseUtils.isQuoted(value))</span>
<span class="nc" id="L1886">                throw new InvalidTypeException(&quot;time values must be enclosed by single quotes&quot;);</span>
<span class="nc" id="L1887">            value = value.substring(1, value.length() - 1);</span>

<span class="nc bnc" id="L1889" title="All 2 branches missed.">            if (ParseUtils.isLongLiteral(value))</span>
            {
                try
                {
<span class="nc" id="L1893">                    return Long.parseLong(value);</span>
                }
<span class="nc" id="L1895">                catch (NumberFormatException e)</span>
                {
<span class="nc" id="L1897">                    throw new InvalidTypeException(</span>
<span class="nc" id="L1898">                    String.format(&quot;Cannot parse time value from \&quot;%s\&quot;&quot;, value), e);</span>
                }
            }

            try
            {
<span class="nc" id="L1904">                return ParseUtils.parseTime(value);</span>
            }
<span class="nc" id="L1906">            catch (ParseException e)</span>
            {
<span class="nc" id="L1908">                throw new InvalidTypeException(</span>
<span class="nc" id="L1909">                String.format(&quot;Cannot parse time value from \&quot;%s\&quot;&quot;, value), e);</span>
            }
        }

        @Override
        public String format(Long value)
        {
<span class="nc bnc" id="L1916" title="All 2 branches missed.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="nc" id="L1917">            return ParseUtils.quote(ParseUtils.formatTime(value));</span>
        }
    }

    /**
     * Base class for codecs handling CQL UUID types such as {@link DataType#uuid()} and {@link
     * DataType#timeuuid()}.
     */
    private abstract static class AbstractUUIDCodec extends TypeCodec&lt;UUID&gt;
    {

        private AbstractUUIDCodec(DataType cqlType)
        {
<span class="fc" id="L1930">            super(cqlType, UUID.class);</span>
<span class="fc" id="L1931">        }</span>

        @Override
        public int serializedSize()
        {
<span class="nc" id="L1936">            return 16;</span>
        }

        @Override
        public UUID parse(String value)
        {
            try
            {
<span class="nc bnc" id="L1944" title="All 6 branches missed.">                return value == null || value.isEmpty() || value.equalsIgnoreCase(&quot;NULL&quot;)</span>
<span class="nc" id="L1945">                       ? null</span>
<span class="nc" id="L1946">                       : UUID.fromString(value);</span>
            }
<span class="nc" id="L1948">            catch (IllegalArgumentException e)</span>
            {
<span class="nc" id="L1950">                throw new InvalidTypeException(</span>
<span class="nc" id="L1951">                String.format(&quot;Cannot parse UUID value from \&quot;%s\&quot;&quot;, value), e);</span>
            }
        }

        @Override
        public String format(UUID value)
        {
<span class="nc bnc" id="L1958" title="All 2 branches missed.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="nc" id="L1959">            return value.toString();</span>
        }

        @Override
        public ByteBuffer serialize(UUID value, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L1965" title="1 of 2 branches missed.">            if (value == null) return null;</span>
<span class="fc" id="L1966">            ByteBuffer bb = ByteBuffer.allocate(16);</span>
<span class="fc" id="L1967">            bb.putLong(0, value.getMostSignificantBits());</span>
<span class="fc" id="L1968">            bb.putLong(8, value.getLeastSignificantBits());</span>
<span class="fc" id="L1969">            return bb;</span>
        }

        @Override
        public UUID deserialize(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L1975" title="2 of 4 branches missed.">            return bytes == null || bytes.remaining() == 0</span>
<span class="nc" id="L1976">                   ? null</span>
<span class="fc" id="L1977">                   : new UUID(bytes.getLong(bytes.position()), bytes.getLong(bytes.position() + 8));</span>
        }
    }

    /**
     * This codec maps a CQL {@link DataType#uuid()} to a Java {@link UUID}.
     */
    private static class UUIDCodec extends AbstractUUIDCodec
    {

<span class="fc" id="L1987">        private static final UUIDCodec instance = new UUIDCodec();</span>

        private UUIDCodec()
        {
<span class="fc" id="L1991">            super(DataType.uuid());</span>
<span class="fc" id="L1992">        }</span>
    }

    /**
     * This codec maps a CQL {@link DataType#timeuuid()} to a Java {@link UUID}.
     */
    private static class TimeUUIDCodec extends AbstractUUIDCodec
    {

<span class="fc" id="L2001">        private static final TimeUUIDCodec instance = new TimeUUIDCodec();</span>

        private TimeUUIDCodec()
        {
<span class="fc" id="L2005">            super(timeuuid());</span>
<span class="fc" id="L2006">        }</span>

        @Override
        public String format(UUID value)
        {
<span class="nc bnc" id="L2011" title="All 2 branches missed.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="nc bnc" id="L2012" title="All 2 branches missed.">            if (value.version() != 1)</span>
<span class="nc" id="L2013">                throw new InvalidTypeException(</span>
<span class="nc" id="L2014">                String.format(&quot;%s is not a Type 1 (time-based) UUID&quot;, value));</span>
<span class="nc" id="L2015">            return super.format(value);</span>
        }

        @Override
        public ByteBuffer serialize(UUID value, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L2021" title="1 of 2 branches missed.">            if (value == null) return null;</span>
<span class="pc bpc" id="L2022" title="1 of 2 branches missed.">            if (value.version() != 1)</span>
<span class="nc" id="L2023">                throw new InvalidTypeException(</span>
<span class="nc" id="L2024">                String.format(&quot;%s is not a Type 1 (time-based) UUID&quot;, value));</span>
<span class="fc" id="L2025">            return super.serialize(value, protocolVersion);</span>
        }
    }

    /**
     * This codec maps a CQL {@link DataType#varint()} to a Java {@link BigInteger}.
     */
    private static class VarintCodec extends TypeCodec&lt;BigInteger&gt;
    {

<span class="fc" id="L2035">        private static final VarintCodec instance = new VarintCodec();</span>

        private VarintCodec()
        {
<span class="fc" id="L2039">            super(DataType.varint(), BigInteger.class);</span>
<span class="fc" id="L2040">        }</span>

        @Override
        public BigInteger parse(String value)
        {
            try
            {
<span class="nc bnc" id="L2047" title="All 6 branches missed.">                return value == null || value.isEmpty() || value.equalsIgnoreCase(&quot;NULL&quot;)</span>
<span class="nc" id="L2048">                       ? null</span>
<span class="nc" id="L2049">                       : new BigInteger(value);</span>
            }
<span class="nc" id="L2051">            catch (NumberFormatException e)</span>
            {
<span class="nc" id="L2053">                throw new InvalidTypeException(</span>
<span class="nc" id="L2054">                String.format(&quot;Cannot parse varint value from \&quot;%s\&quot;&quot;, value), e);</span>
            }
        }

        @Override
        public String format(BigInteger value)
        {
<span class="nc bnc" id="L2061" title="All 2 branches missed.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="nc" id="L2062">            return value.toString();</span>
        }

        @Override
        public ByteBuffer serialize(BigInteger value, ProtocolVersion protocolVersion)
        {
<span class="nc bnc" id="L2068" title="All 2 branches missed.">            return value == null ? null : ByteBuffer.wrap(value.toByteArray());</span>
        }

        @Override
        public BigInteger deserialize(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="nc bnc" id="L2074" title="All 4 branches missed.">            return bytes == null || bytes.remaining() == 0 ? null : new BigInteger(Bytes.getArray(bytes));</span>
        }
    }

    /**
     * Base class for codecs mapping CQL {@link DataType#list(DataType) lists} and {@link
     * DataType#set(DataType) sets} to Java collections.
     */
    public abstract static class AbstractCollectionCodec&lt;E, C extends Collection&lt;E&gt;&gt;
    extends TypeCodec&lt;C&gt;
    {

        final TypeCodec&lt;E&gt; eltCodec;

        AbstractCollectionCodec(
        CollectionType cqlType, TypeToken&lt;C&gt; javaType, TypeCodec&lt;E&gt; eltCodec)
        {
<span class="fc" id="L2091">            super(cqlType, javaType);</span>
<span class="fc" id="L2092">            checkArgument(</span>
<span class="pc bpc" id="L2093" title="1 of 4 branches missed.">            cqlType.getName() == Name.LIST || cqlType.getName() == Name.SET,</span>
            &quot;Expecting list or set type, got %s&quot;,
            cqlType);
<span class="fc" id="L2096">            this.eltCodec = eltCodec;</span>
<span class="fc" id="L2097">        }</span>

        @Override
        public ByteBuffer serialize(C value, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L2102" title="1 of 2 branches missed.">            if (value == null) return null;</span>
<span class="fc" id="L2103">            int i = 0;</span>
<span class="fc" id="L2104">            ByteBuffer[] bbs = new ByteBuffer[value.size()];</span>
<span class="fc bfc" id="L2105" title="All 2 branches covered.">            for (E elt : value)</span>
            {
<span class="pc bpc" id="L2107" title="1 of 2 branches missed.">                if (elt == null)</span>
                {
<span class="nc" id="L2109">                    throw new NullPointerException(&quot;Collection elements cannot be null&quot;);</span>
                }
                ByteBuffer bb;
                try
                {
<span class="fc" id="L2114">                    bb = eltCodec.serialize(elt, protocolVersion);</span>
                }
<span class="nc" id="L2116">                catch (ClassCastException e)</span>
                {
<span class="nc" id="L2118">                    throw new InvalidTypeException(</span>
<span class="nc" id="L2119">                    String.format(</span>
                    &quot;Invalid type for %s element, expecting %s but got %s&quot;,
<span class="nc" id="L2121">                    cqlType, eltCodec.getJavaType(), elt.getClass()),</span>
                    e);
<span class="fc" id="L2123">                }</span>
<span class="fc" id="L2124">                bbs[i++] = bb;</span>
<span class="fc" id="L2125">            }</span>
<span class="fc" id="L2126">            return CodecUtils.pack(bbs, value.size(), protocolVersion);</span>
        }

        @Override
        public C deserialize(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L2132" title="2 of 4 branches missed.">            if (bytes == null || bytes.remaining() == 0) return newInstance(0);</span>
            try
            {
<span class="fc" id="L2135">                ByteBuffer input = bytes.duplicate();</span>
<span class="fc" id="L2136">                int size = CodecUtils.readSize(input, protocolVersion);</span>
<span class="fc" id="L2137">                C coll = newInstance(size);</span>
<span class="fc bfc" id="L2138" title="All 2 branches covered.">                for (int i = 0; i &lt; size; i++)</span>
                {
<span class="fc" id="L2140">                    ByteBuffer databb = CodecUtils.readValue(input, protocolVersion);</span>
<span class="fc" id="L2141">                    coll.add(eltCodec.deserialize(databb, protocolVersion));</span>
                }
<span class="fc" id="L2143">                return coll;</span>
            }
<span class="nc" id="L2145">            catch (BufferUnderflowException e)</span>
            {
<span class="nc" id="L2147">                throw new InvalidTypeException(&quot;Not enough bytes to deserialize collection&quot;, e);</span>
            }
        }

        @Override
        public String format(C value)
        {
<span class="nc bnc" id="L2154" title="All 2 branches missed.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="nc" id="L2155">            StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L2156">            sb.append(getOpeningChar());</span>
<span class="nc" id="L2157">            int i = 0;</span>
<span class="nc bnc" id="L2158" title="All 2 branches missed.">            for (E v : value)</span>
            {
<span class="nc bnc" id="L2160" title="All 2 branches missed.">                if (i++ != 0) sb.append(',');</span>
<span class="nc" id="L2161">                sb.append(eltCodec.format(v));</span>
<span class="nc" id="L2162">            }</span>
<span class="nc" id="L2163">            sb.append(getClosingChar());</span>
<span class="nc" id="L2164">            return sb.toString();</span>
        }

        @Override
        public C parse(String value)
        {
<span class="nc bnc" id="L2170" title="All 6 branches missed.">            if (value == null || value.isEmpty() || value.equalsIgnoreCase(&quot;NULL&quot;)) return null;</span>

<span class="nc" id="L2172">            int idx = ParseUtils.skipSpaces(value, 0);</span>
<span class="nc bnc" id="L2173" title="All 2 branches missed.">            if (value.charAt(idx++) != getOpeningChar())</span>
<span class="nc" id="L2174">                throw new InvalidTypeException(</span>
<span class="nc" id="L2175">                String.format(</span>
                &quot;Cannot parse collection value from \&quot;%s\&quot;, at character %d expecting '%s' but got '%c'&quot;,
<span class="nc" id="L2177">                value, idx, getOpeningChar(), value.charAt(idx)));</span>

<span class="nc" id="L2179">            idx = ParseUtils.skipSpaces(value, idx);</span>

<span class="nc bnc" id="L2181" title="All 2 branches missed.">            if (value.charAt(idx) == getClosingChar()) return newInstance(0);</span>

<span class="nc" id="L2183">            C l = newInstance(10);</span>
<span class="nc bnc" id="L2184" title="All 2 branches missed.">            while (idx &lt; value.length())</span>
            {
                int n;
                try
                {
<span class="nc" id="L2189">                    n = ParseUtils.skipCQLValue(value, idx);</span>
                }
<span class="nc" id="L2191">                catch (IllegalArgumentException e)</span>
                {
<span class="nc" id="L2193">                    throw new InvalidTypeException(</span>
<span class="nc" id="L2194">                    String.format(</span>
                    &quot;Cannot parse collection value from \&quot;%s\&quot;, invalid CQL value at character %d&quot;,
<span class="nc" id="L2196">                    value, idx),</span>
                    e);
<span class="nc" id="L2198">                }</span>

<span class="nc" id="L2200">                l.add(eltCodec.parse(value.substring(idx, n)));</span>
<span class="nc" id="L2201">                idx = n;</span>

<span class="nc" id="L2203">                idx = ParseUtils.skipSpaces(value, idx);</span>
<span class="nc bnc" id="L2204" title="All 2 branches missed.">                if (value.charAt(idx) == getClosingChar()) return l;</span>
<span class="nc bnc" id="L2205" title="All 2 branches missed.">                if (value.charAt(idx++) != ',')</span>
<span class="nc" id="L2206">                    throw new InvalidTypeException(</span>
<span class="nc" id="L2207">                    String.format(</span>
                    &quot;Cannot parse collection value from \&quot;%s\&quot;, at character %d expecting ',' but got '%c'&quot;,
<span class="nc" id="L2209">                    value, idx, value.charAt(idx)));</span>

<span class="nc" id="L2211">                idx = ParseUtils.skipSpaces(value, idx);</span>
<span class="nc" id="L2212">            }</span>
<span class="nc" id="L2213">            throw new InvalidTypeException(</span>
<span class="nc" id="L2214">            String.format(</span>
<span class="nc" id="L2215">            &quot;Malformed collection value \&quot;%s\&quot;, missing closing '%s'&quot;, value, getClosingChar()));</span>
        }

        @Override
        public boolean accepts(Object value)
        {
<span class="nc bnc" id="L2221" title="All 2 branches missed.">            if (getJavaType().getRawType().isAssignableFrom(value.getClass()))</span>
            {
                // runtime type ok, now check element type
<span class="nc" id="L2224">                Collection&lt;?&gt; coll = (Collection&lt;?&gt;) value;</span>
<span class="nc bnc" id="L2225" title="All 2 branches missed.">                if (coll.isEmpty()) return true;</span>
<span class="nc" id="L2226">                Object elt = coll.iterator().next();</span>
<span class="nc" id="L2227">                return eltCodec.accepts(elt);</span>
            }
<span class="nc" id="L2229">            return false;</span>
        }

        /**
         * Return a new instance of {@code C} with the given estimated size.
         *
         * @param size The estimated size of the collection to create.
         * @return new instance of {@code C} with the given estimated size.
         */
        protected abstract C newInstance(int size);

        /**
         * Return the opening character to use when formatting values as CQL literals.
         *
         * @return The opening character to use when formatting values as CQL literals.
         */
        private char getOpeningChar()
        {
<span class="nc bnc" id="L2247" title="All 2 branches missed.">            return cqlType.getName() == Name.LIST ? '[' : '{';</span>
        }

        /**
         * Return the closing character to use when formatting values as CQL literals.
         *
         * @return The closing character to use when formatting values as CQL literals.
         */
        private char getClosingChar()
        {
<span class="nc bnc" id="L2257" title="All 2 branches missed.">            return cqlType.getName() == Name.LIST ? ']' : '}';</span>
        }
    }

    /**
     * This codec maps a CQL {@link DataType#list(DataType) list type} to a Java {@link List}.
     * Implementation note: this codec returns mutable, non thread-safe {@link ArrayList} instances.
     */
    private static class ListCodec&lt;T&gt; extends AbstractCollectionCodec&lt;T, List&lt;T&gt;&gt;
    {

        private ListCodec(TypeCodec&lt;T&gt; eltCodec)
        {
<span class="fc" id="L2270">            super(</span>
<span class="fc" id="L2271">            DataType.list(eltCodec.getCqlType()),</span>
<span class="fc" id="L2272">            TypeTokens.listOf(eltCodec.getJavaType()),</span>
            eltCodec);
<span class="fc" id="L2274">        }</span>

        @Override
        protected List&lt;T&gt; newInstance(int size)
        {
<span class="fc" id="L2279">            return new ArrayList&lt;&gt;(size);</span>
        }
    }

    /**
     * This codec maps a CQL {@link DataType#set(DataType) set type} to a Java {@link Set}.
     * Implementation note: this codec returns mutable, non thread-safe {@link LinkedHashSet}
     * instances.
     */
    private static class SetCodec&lt;T&gt; extends AbstractCollectionCodec&lt;T, Set&lt;T&gt;&gt;
    {

        private SetCodec(TypeCodec&lt;T&gt; eltCodec)
        {
<span class="fc" id="L2293">            super(DataType.set(eltCodec.cqlType), TypeTokens.setOf(eltCodec.getJavaType()), eltCodec);</span>
<span class="fc" id="L2294">        }</span>

        @Override
        protected Set&lt;T&gt; newInstance(int size)
        {
<span class="fc" id="L2299">            return new LinkedHashSet&lt;&gt;(size);</span>
        }
    }

    /**
     * Base class for codecs mapping CQL {@link DataType#map(DataType, DataType) maps} to a Java
     * {@link Map}.
     */
    public abstract static class AbstractMapCodec&lt;K, V&gt; extends TypeCodec&lt;Map&lt;K, V&gt;&gt;
    {

        final TypeCodec&lt;K&gt; keyCodec;

        final TypeCodec&lt;V&gt; valueCodec;

        AbstractMapCodec(TypeCodec&lt;K&gt; keyCodec, TypeCodec&lt;V&gt; valueCodec)
        {
<span class="fc" id="L2316">            super(</span>
<span class="fc" id="L2317">            DataType.map(keyCodec.getCqlType(), valueCodec.getCqlType()),</span>
<span class="fc" id="L2318">            TypeTokens.mapOf(keyCodec.getJavaType(), valueCodec.getJavaType()));</span>
<span class="fc" id="L2319">            this.keyCodec = keyCodec;</span>
<span class="fc" id="L2320">            this.valueCodec = valueCodec;</span>
<span class="fc" id="L2321">        }</span>

        @Override
        public boolean accepts(Object value)
        {
<span class="nc bnc" id="L2326" title="All 2 branches missed.">            if (value instanceof Map)</span>
            {
                // runtime type ok, now check key and value types
<span class="nc" id="L2329">                Map&lt;?, ?&gt; map = (Map&lt;?, ?&gt;) value;</span>
<span class="nc bnc" id="L2330" title="All 2 branches missed.">                if (map.isEmpty()) return true;</span>
<span class="nc" id="L2331">                Map.Entry&lt;?, ?&gt; entry = map.entrySet().iterator().next();</span>
<span class="nc bnc" id="L2332" title="All 4 branches missed.">                return keyCodec.accepts(entry.getKey()) &amp;&amp; valueCodec.accepts(entry.getValue());</span>
            }
<span class="nc" id="L2334">            return false;</span>
        }

        @Override
        public Map&lt;K, V&gt; parse(String value)
        {
<span class="nc bnc" id="L2340" title="All 6 branches missed.">            if (value == null || value.isEmpty() || value.equalsIgnoreCase(&quot;NULL&quot;)) return null;</span>

<span class="nc" id="L2342">            int idx = ParseUtils.skipSpaces(value, 0);</span>
<span class="nc bnc" id="L2343" title="All 2 branches missed.">            if (value.charAt(idx++) != '{')</span>
<span class="nc" id="L2344">                throw new InvalidTypeException(</span>
<span class="nc" id="L2345">                String.format(</span>
                &quot;cannot parse map value from \&quot;%s\&quot;, at character %d expecting '{' but got '%c'&quot;,
<span class="nc" id="L2347">                value, idx, value.charAt(idx)));</span>

<span class="nc" id="L2349">            idx = ParseUtils.skipSpaces(value, idx);</span>

<span class="nc bnc" id="L2351" title="All 2 branches missed.">            if (value.charAt(idx) == '}') return newInstance(0);</span>

<span class="nc" id="L2353">            Map&lt;K, V&gt; m = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L2354" title="All 2 branches missed.">            while (idx &lt; value.length())</span>
            {
                int n;
                try
                {
<span class="nc" id="L2359">                    n = ParseUtils.skipCQLValue(value, idx);</span>
                }
<span class="nc" id="L2361">                catch (IllegalArgumentException e)</span>
                {
<span class="nc" id="L2363">                    throw new InvalidTypeException(</span>
<span class="nc" id="L2364">                    String.format(</span>
                    &quot;Cannot parse map value from \&quot;%s\&quot;, invalid CQL value at character %d&quot;,
<span class="nc" id="L2366">                    value, idx),</span>
                    e);
<span class="nc" id="L2368">                }</span>

<span class="nc" id="L2370">                K k = keyCodec.parse(value.substring(idx, n));</span>
<span class="nc" id="L2371">                idx = n;</span>

<span class="nc" id="L2373">                idx = ParseUtils.skipSpaces(value, idx);</span>
<span class="nc bnc" id="L2374" title="All 2 branches missed.">                if (value.charAt(idx++) != ':')</span>
<span class="nc" id="L2375">                    throw new InvalidTypeException(</span>
<span class="nc" id="L2376">                    String.format(</span>
                    &quot;Cannot parse map value from \&quot;%s\&quot;, at character %d expecting ':' but got '%c'&quot;,
<span class="nc" id="L2378">                    value, idx, value.charAt(idx)));</span>
<span class="nc" id="L2379">                idx = ParseUtils.skipSpaces(value, idx);</span>

                try
                {
<span class="nc" id="L2383">                    n = ParseUtils.skipCQLValue(value, idx);</span>
                }
<span class="nc" id="L2385">                catch (IllegalArgumentException e)</span>
                {
<span class="nc" id="L2387">                    throw new InvalidTypeException(</span>
<span class="nc" id="L2388">                    String.format(</span>
                    &quot;Cannot parse map value from \&quot;%s\&quot;, invalid CQL value at character %d&quot;,
<span class="nc" id="L2390">                    value, idx),</span>
                    e);
<span class="nc" id="L2392">                }</span>

<span class="nc" id="L2394">                V v = valueCodec.parse(value.substring(idx, n));</span>
<span class="nc" id="L2395">                idx = n;</span>

<span class="nc" id="L2397">                m.put(k, v);</span>

<span class="nc" id="L2399">                idx = ParseUtils.skipSpaces(value, idx);</span>
<span class="nc bnc" id="L2400" title="All 2 branches missed.">                if (value.charAt(idx) == '}') return m;</span>
<span class="nc bnc" id="L2401" title="All 2 branches missed.">                if (value.charAt(idx++) != ',')</span>
<span class="nc" id="L2402">                    throw new InvalidTypeException(</span>
<span class="nc" id="L2403">                    String.format(</span>
                    &quot;Cannot parse map value from \&quot;%s\&quot;, at character %d expecting ',' but got '%c'&quot;,
<span class="nc" id="L2405">                    value, idx, value.charAt(idx)));</span>

<span class="nc" id="L2407">                idx = ParseUtils.skipSpaces(value, idx);</span>
<span class="nc" id="L2408">            }</span>
<span class="nc" id="L2409">            throw new InvalidTypeException(</span>
<span class="nc" id="L2410">            String.format(&quot;Malformed map value \&quot;%s\&quot;, missing closing '}'&quot;, value));</span>
        }

        @Override
        public String format(Map&lt;K, V&gt; value)
        {
<span class="nc bnc" id="L2416" title="All 2 branches missed.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="nc" id="L2417">            StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L2418">            sb.append('{');</span>
<span class="nc" id="L2419">            int i = 0;</span>
<span class="nc bnc" id="L2420" title="All 2 branches missed.">            for (Map.Entry&lt;K, V&gt; e : value.entrySet())</span>
            {
<span class="nc bnc" id="L2422" title="All 2 branches missed.">                if (i++ != 0) sb.append(',');</span>
<span class="nc" id="L2423">                sb.append(keyCodec.format(e.getKey()));</span>
<span class="nc" id="L2424">                sb.append(':');</span>
<span class="nc" id="L2425">                sb.append(valueCodec.format(e.getValue()));</span>
<span class="nc" id="L2426">            }</span>
<span class="nc" id="L2427">            sb.append('}');</span>
<span class="nc" id="L2428">            return sb.toString();</span>
        }

        @Override
        public ByteBuffer serialize(Map&lt;K, V&gt; value, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L2434" title="1 of 2 branches missed.">            if (value == null) return null;</span>
<span class="fc" id="L2435">            int i = 0;</span>
<span class="fc" id="L2436">            ByteBuffer[] bbs = new ByteBuffer[2 * value.size()];</span>
<span class="fc bfc" id="L2437" title="All 2 branches covered.">            for (Map.Entry&lt;K, V&gt; entry : value.entrySet())</span>
            {
                ByteBuffer bbk;
<span class="fc" id="L2440">                K key = entry.getKey();</span>
<span class="pc bpc" id="L2441" title="1 of 2 branches missed.">                if (key == null)</span>
                {
<span class="nc" id="L2443">                    throw new NullPointerException(&quot;Map keys cannot be null&quot;);</span>
                }
                try
                {
<span class="fc" id="L2447">                    bbk = keyCodec.serialize(key, protocolVersion);</span>
                }
<span class="nc" id="L2449">                catch (ClassCastException e)</span>
                {
<span class="nc" id="L2451">                    throw new InvalidTypeException(</span>
<span class="nc" id="L2452">                    String.format(</span>
                    &quot;Invalid type for map key, expecting %s but got %s&quot;,
<span class="nc" id="L2454">                    keyCodec.getJavaType(), key.getClass()),</span>
                    e);
<span class="fc" id="L2456">                }</span>
                ByteBuffer bbv;
<span class="fc" id="L2458">                V v = entry.getValue();</span>
<span class="pc bpc" id="L2459" title="1 of 2 branches missed.">                if (v == null)</span>
                {
<span class="nc" id="L2461">                    throw new NullPointerException(&quot;Map values cannot be null&quot;);</span>
                }
                try
                {
<span class="fc" id="L2465">                    bbv = valueCodec.serialize(v, protocolVersion);</span>
                }
<span class="nc" id="L2467">                catch (ClassCastException e)</span>
                {
<span class="nc" id="L2469">                    throw new InvalidTypeException(</span>
<span class="nc" id="L2470">                    String.format(</span>
                    &quot;Invalid type for map value, expecting %s but got %s&quot;,
<span class="nc" id="L2472">                    valueCodec.getJavaType(), v.getClass()),</span>
                    e);
<span class="fc" id="L2474">                }</span>
<span class="fc" id="L2475">                bbs[i++] = bbk;</span>
<span class="fc" id="L2476">                bbs[i++] = bbv;</span>
<span class="fc" id="L2477">            }</span>
<span class="fc" id="L2478">            return CodecUtils.pack(bbs, value.size(), protocolVersion);</span>
        }

        @Override
        public Map&lt;K, V&gt; deserialize(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L2484" title="2 of 4 branches missed.">            if (bytes == null || bytes.remaining() == 0) return newInstance(0);</span>
            try
            {
<span class="fc" id="L2487">                ByteBuffer input = bytes.duplicate();</span>
<span class="fc" id="L2488">                int n = CodecUtils.readSize(input, protocolVersion);</span>
<span class="fc" id="L2489">                Map&lt;K, V&gt; m = newInstance(n);</span>
<span class="fc bfc" id="L2490" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++)</span>
                {
<span class="fc" id="L2492">                    ByteBuffer kbb = CodecUtils.readValue(input, protocolVersion);</span>
<span class="fc" id="L2493">                    ByteBuffer vbb = CodecUtils.readValue(input, protocolVersion);</span>
<span class="fc" id="L2494">                    m.put(</span>
<span class="fc" id="L2495">                    keyCodec.deserialize(kbb, protocolVersion),</span>
<span class="fc" id="L2496">                    valueCodec.deserialize(vbb, protocolVersion));</span>
                }
<span class="fc" id="L2498">                return m;</span>
            }
<span class="nc" id="L2500">            catch (BufferUnderflowException e)</span>
            {
<span class="nc" id="L2502">                throw new InvalidTypeException(&quot;Not enough bytes to deserialize a map&quot;, e);</span>
            }
        }

        /**
         * Return a new {@link Map} instance with the given estimated size.
         *
         * @param size The estimated size of the collection to create.
         * @return A new {@link Map} instance with the given estimated size.
         */
        protected abstract Map&lt;K, V&gt; newInstance(int size);
    }

    /**
     * This codec maps a CQL {@link DataType#map(DataType, DataType) map type} to a Java {@link Map}.
     * Implementation note: this codec returns mutable, non thread-safe {@link LinkedHashMap}
     * instances.
     */
    private static class MapCodec&lt;K, V&gt; extends AbstractMapCodec&lt;K, V&gt;
    {

        private MapCodec(TypeCodec&lt;K&gt; keyCodec, TypeCodec&lt;V&gt; valueCodec)
        {
<span class="fc" id="L2525">            super(keyCodec, valueCodec);</span>
<span class="fc" id="L2526">        }</span>

        @Override
        protected Map&lt;K, V&gt; newInstance(int size)
        {
<span class="fc" id="L2531">            return new LinkedHashMap&lt;&gt;(size);</span>
        }
    }

    /**
     * Base class for codecs mapping CQL {@link UserType user-defined types} (UDTs) to Java objects.
     * It can serve as a base class for codecs dealing with direct UDT-to-Pojo mappings.
     *
     * @param &lt;T&gt; The Java type that the UDT will be mapped to.
     */
    public abstract static class AbstractUDTCodec&lt;T&gt; extends TypeCodec&lt;T&gt;
    {

        protected final UserType definition;

        AbstractUDTCodec(UserType definition, Class&lt;T&gt; javaClass)
        {
<span class="fc" id="L2548">            this(definition, TypeToken.of(javaClass));</span>
<span class="fc" id="L2549">        }</span>

        AbstractUDTCodec(UserType definition, TypeToken&lt;T&gt; javaType)
        {
<span class="fc" id="L2553">            super(definition, javaType);</span>
<span class="fc" id="L2554">            this.definition = definition;</span>
<span class="fc" id="L2555">        }</span>

        @Override
        public ByteBuffer serialize(T value, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L2560" title="1 of 2 branches missed.">            if (value == null) return null;</span>
<span class="fc" id="L2561">            int size = 0;</span>
<span class="fc" id="L2562">            int length = definition.size();</span>
<span class="fc" id="L2563">            ByteBuffer[] elements = new ByteBuffer[length];</span>
<span class="fc" id="L2564">            int i = 0;</span>
<span class="fc bfc" id="L2565" title="All 2 branches covered.">            for (UserType.Field field : definition)</span>
            {
<span class="fc" id="L2567">                elements[i] =</span>
<span class="fc" id="L2568">                serializeField(value, Metadata.quoteIfNecessary(field.getName()), protocolVersion);</span>
<span class="pc bpc" id="L2569" title="1 of 2 branches missed.">                size += 4 + (elements[i] == null ? 0 : elements[i].remaining());</span>
<span class="fc" id="L2570">                i++;</span>
<span class="fc" id="L2571">            }</span>
<span class="fc" id="L2572">            ByteBuffer result = ByteBuffer.allocate(size);</span>
<span class="fc bfc" id="L2573" title="All 2 branches covered.">            for (ByteBuffer bb : elements)</span>
            {
<span class="pc bpc" id="L2575" title="1 of 2 branches missed.">                if (bb == null)</span>
                {
<span class="nc" id="L2577">                    result.putInt(-1);</span>
                }
                else
                {
<span class="fc" id="L2581">                    result.putInt(bb.remaining());</span>
<span class="fc" id="L2582">                    result.put(bb.duplicate());</span>
                }
            }
<span class="fc" id="L2585">            return (ByteBuffer) result.flip();</span>
        }

        @Override
        public T deserialize(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L2591" title="1 of 2 branches missed.">            if (bytes == null) return null;</span>
            // empty byte buffers will result in empty values
            try
            {
<span class="fc" id="L2595">                ByteBuffer input = bytes.duplicate();</span>
<span class="fc" id="L2596">                T value = newInstance();</span>
<span class="fc bfc" id="L2597" title="All 2 branches covered.">                for (UserType.Field field : definition)</span>
                {
<span class="fc bfc" id="L2599" title="All 2 branches covered.">                    if (!input.hasRemaining()) break;</span>
<span class="fc" id="L2600">                    int n = input.getInt();</span>
<span class="pc bpc" id="L2601" title="1 of 2 branches missed.">                    ByteBuffer element = n &lt; 0 ? null : CodecUtils.readBytes(input, n);</span>
<span class="fc" id="L2602">                    value =</span>
<span class="fc" id="L2603">                    deserializeAndSetField(</span>
<span class="fc" id="L2604">                    element, value, Metadata.quoteIfNecessary(field.getName()), protocolVersion);</span>
<span class="fc" id="L2605">                }</span>
<span class="fc" id="L2606">                return value;</span>
            }
<span class="nc" id="L2608">            catch (BufferUnderflowException e)</span>
            {
<span class="nc" id="L2610">                throw new InvalidTypeException(&quot;Not enough bytes to deserialize a UDT&quot;, e);</span>
            }
        }

        @Override
        public String format(T value)
        {
<span class="pc bpc" id="L2617" title="1 of 2 branches missed.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="fc" id="L2618">            StringBuilder sb = new StringBuilder(&quot;{&quot;);</span>
<span class="fc" id="L2619">            int i = 0;</span>
<span class="fc bfc" id="L2620" title="All 2 branches covered.">            for (UserType.Field field : definition)</span>
            {
<span class="pc bpc" id="L2622" title="1 of 2 branches missed.">                if (i &gt; 0) sb.append(',');</span>
<span class="fc" id="L2623">                sb.append(Metadata.quoteIfNecessary(field.getName()));</span>
<span class="fc" id="L2624">                sb.append(':');</span>
<span class="fc" id="L2625">                sb.append(formatField(value, Metadata.quoteIfNecessary(field.getName())));</span>
<span class="fc" id="L2626">                i += 1;</span>
<span class="fc" id="L2627">            }</span>
<span class="fc" id="L2628">            sb.append('}');</span>
<span class="fc" id="L2629">            return sb.toString();</span>
        }

        @Override
        public T parse(String value)
        {
<span class="nc bnc" id="L2635" title="All 6 branches missed.">            if (value == null || value.isEmpty() || value.equals(&quot;NULL&quot;)) return null;</span>

<span class="nc" id="L2637">            T v = newInstance();</span>

<span class="nc" id="L2639">            int idx = ParseUtils.skipSpaces(value, 0);</span>
<span class="nc bnc" id="L2640" title="All 2 branches missed.">            if (value.charAt(idx++) != '{')</span>
<span class="nc" id="L2641">                throw new InvalidTypeException(</span>
<span class="nc" id="L2642">                String.format(</span>
                &quot;Cannot parse UDT value from \&quot;%s\&quot;, at character %d expecting '{' but got '%c'&quot;,
<span class="nc" id="L2644">                value, idx, value.charAt(idx)));</span>

<span class="nc" id="L2646">            idx = ParseUtils.skipSpaces(value, idx);</span>

<span class="nc bnc" id="L2648" title="All 2 branches missed.">            if (value.charAt(idx) == '}') return v;</span>

<span class="nc bnc" id="L2650" title="All 2 branches missed.">            while (idx &lt; value.length())</span>
            {

                int n;
                try
                {
<span class="nc" id="L2656">                    n = ParseUtils.skipCQLId(value, idx);</span>
                }
<span class="nc" id="L2658">                catch (IllegalArgumentException e)</span>
                {
<span class="nc" id="L2660">                    throw new InvalidTypeException(</span>
<span class="nc" id="L2661">                    String.format(</span>
                    &quot;Cannot parse UDT value from \&quot;%s\&quot;, cannot parse a CQL identifier at character %d&quot;,
<span class="nc" id="L2663">                    value, idx),</span>
                    e);
<span class="nc" id="L2665">                }</span>
<span class="nc" id="L2666">                String name = value.substring(idx, n);</span>
<span class="nc" id="L2667">                idx = n;</span>

<span class="nc bnc" id="L2669" title="All 2 branches missed.">                if (!definition.contains(name))</span>
<span class="nc" id="L2670">                    throw new InvalidTypeException(</span>
<span class="nc" id="L2671">                    String.format(&quot;Unknown field %s in value \&quot;%s\&quot;&quot;, name, value));</span>

<span class="nc" id="L2673">                idx = ParseUtils.skipSpaces(value, idx);</span>
<span class="nc bnc" id="L2674" title="All 2 branches missed.">                if (value.charAt(idx++) != ':')</span>
<span class="nc" id="L2675">                    throw new InvalidTypeException(</span>
<span class="nc" id="L2676">                    String.format(</span>
                    &quot;Cannot parse UDT value from \&quot;%s\&quot;, at character %d expecting ':' but got '%c'&quot;,
<span class="nc" id="L2678">                    value, idx, value.charAt(idx)));</span>
<span class="nc" id="L2679">                idx = ParseUtils.skipSpaces(value, idx);</span>

                try
                {
<span class="nc" id="L2683">                    n = ParseUtils.skipCQLValue(value, idx);</span>
                }
<span class="nc" id="L2685">                catch (IllegalArgumentException e)</span>
                {
<span class="nc" id="L2687">                    throw new InvalidTypeException(</span>
<span class="nc" id="L2688">                    String.format(</span>
                    &quot;Cannot parse UDT value from \&quot;%s\&quot;, invalid CQL value at character %d&quot;,
<span class="nc" id="L2690">                    value, idx),</span>
                    e);
<span class="nc" id="L2692">                }</span>

<span class="nc" id="L2694">                String input = value.substring(idx, n);</span>
<span class="nc" id="L2695">                v = parseAndSetField(input, v, name);</span>
<span class="nc" id="L2696">                idx = n;</span>

<span class="nc" id="L2698">                idx = ParseUtils.skipSpaces(value, idx);</span>
<span class="nc bnc" id="L2699" title="All 2 branches missed.">                if (value.charAt(idx) == '}') return v;</span>
<span class="nc bnc" id="L2700" title="All 2 branches missed.">                if (value.charAt(idx) != ',')</span>
<span class="nc" id="L2701">                    throw new InvalidTypeException(</span>
<span class="nc" id="L2702">                    String.format(</span>
                    &quot;Cannot parse UDT value from \&quot;%s\&quot;, at character %d expecting ',' but got '%c'&quot;,
<span class="nc" id="L2704">                    value, idx, value.charAt(idx)));</span>
<span class="nc" id="L2705">                ++idx; // skip ','</span>

<span class="nc" id="L2707">                idx = ParseUtils.skipSpaces(value, idx);</span>
<span class="nc" id="L2708">            }</span>
<span class="nc" id="L2709">            throw new InvalidTypeException(</span>
<span class="nc" id="L2710">            String.format(&quot;Malformed UDT value \&quot;%s\&quot;, missing closing '}'&quot;, value));</span>
        }

        /**
         * Return a new instance of {@code T}.
         *
         * @return A new instance of {@code T}.
         */
        protected abstract T newInstance();

        /**
         * Serialize an individual field in an object, as part of serializing the whole object to a CQL
         * UDT (see {@link #serialize(Object, ProtocolVersion)}).
         *
         * @param source          The object to read the field from.
         * @param fieldName       The name of the field. Note that if it is case-sensitive or contains special
         *                        characters, it will be double-quoted (i.e. the string will contain actual quote
         *                        characters, as in {@code &quot;\&quot;foobar\&quot;&quot;}).
         * @param protocolVersion The protocol version to use.
         * @return The serialized field, or {@code null} if that field should be ignored.
         */
        protected abstract ByteBuffer serializeField(
        T source, String fieldName, ProtocolVersion protocolVersion);

        /**
         * Deserialize an individual field and set it on an object, as part of deserializing the whole
         * object from a CQL UDT (see {@link #deserialize(ByteBuffer, ProtocolVersion)}).
         *
         * @param input           The serialized form of the field.
         * @param target          The object to set the field on.
         * @param fieldName       The name of the field. Note that if it is case-sensitive or contains special
         *                        characters, it will be double-quoted (i.e. the string will contain actual quote
         *                        characters, as in {@code &quot;\&quot;foobar\&quot;&quot;}).
         * @param protocolVersion The protocol version to use.
         * @return The target object with the field set. In most cases this should be the same as {@code
         * target}, but if you're dealing with immutable types you'll need to return a different
         * instance.
         */
        protected abstract T deserializeAndSetField(
        ByteBuffer input, T target, String fieldName, ProtocolVersion protocolVersion);

        /**
         * Format an individual field in an object as a CQL literal, as part of formatting the whole
         * object (see {@link #format(Object)}).
         *
         * @param source    The object to read the field from.
         * @param fieldName The name of the field. Note that if it is case-sensitive or contains special
         *                  characters, it will be double-quoted (i.e. the string will contain actual quote
         *                  characters, as in {@code &quot;\&quot;foobar\&quot;&quot;}).
         * @return The formatted value.
         */
        protected abstract String formatField(T source, String fieldName);

        /**
         * Parse an individual field and set it on an object, as part of parsing the whole object (see
         * {@link #parse(String)}).
         *
         * @param input     The String to parse the field from.
         * @param target    The value to write to.
         * @param fieldName The name of the field. Note that if it is case-sensitive or contains special
         *                  characters, it will be double-quoted (i.e. the string will contain actual quote
         *                  characters, as in {@code &quot;\&quot;foobar\&quot;&quot;}).
         * @return The target object with the field set. In most cases this should be the same as {@code
         * target}, but if you're dealing with immutable types you'll need to return a different
         * instance.
         */
        protected abstract T parseAndSetField(String input, T target, String fieldName);
    }

    /**
     * This codec maps a CQL {@link UserType} to a {@link UDTValue}.
     */
    private static class UDTCodec extends AbstractUDTCodec&lt;UDTValue&gt;
    {

        private UDTCodec(UserType definition)
        {
<span class="fc" id="L2787">            super(definition, UDTValue.class);</span>
<span class="fc" id="L2788">        }</span>

        @Override
        public boolean accepts(Object value)
        {
<span class="nc bnc" id="L2793" title="All 4 branches missed.">            return super.accepts(value) &amp;&amp; ((UDTValue) value).getType().equals(definition);</span>
        }

        @Override
        protected UDTValue newInstance()
        {
<span class="fc" id="L2799">            return definition.newValue();</span>
        }

        @Override
        protected ByteBuffer serializeField(
        UDTValue source, String fieldName, ProtocolVersion protocolVersion)
        {
<span class="fc" id="L2806">            return source.getBytesUnsafe(fieldName);</span>
        }

        @Override
        protected UDTValue deserializeAndSetField(
        ByteBuffer input, UDTValue target, String fieldName, ProtocolVersion protocolVersion)
        {
<span class="fc" id="L2813">            return target.setBytesUnsafe(fieldName, input);</span>
        }

        @Override
        protected String formatField(UDTValue source, String fieldName)
        {
<span class="fc" id="L2819">            DataType elementType = definition.getFieldType(fieldName);</span>
<span class="fc" id="L2820">            TypeCodec&lt;Object&gt; codec = definition.getCodecRegistry().codecFor(elementType);</span>
<span class="fc" id="L2821">            return codec.format(source.get(fieldName, codec.getJavaType()));</span>
        }

        @Override
        protected UDTValue parseAndSetField(String input, UDTValue target, String fieldName)
        {
<span class="nc" id="L2827">            DataType elementType = definition.getFieldType(fieldName);</span>
<span class="nc" id="L2828">            TypeCodec&lt;Object&gt; codec = definition.getCodecRegistry().codecFor(elementType);</span>
<span class="nc" id="L2829">            target.set(fieldName, codec.parse(input), codec.getJavaType());</span>
<span class="nc" id="L2830">            return target;</span>
        }
    }

    /**
     * Base class for codecs mapping CQL {@link TupleType tuples} to Java objects. It can serve as a
     * base class for codecs dealing with direct tuple-to-Pojo mappings.
     *
     * @param &lt;T&gt; The Java type that this codec handles.
     */
    public abstract static class AbstractTupleCodec&lt;T&gt; extends TypeCodec&lt;T&gt;
    {

        protected final TupleType definition;

        AbstractTupleCodec(TupleType definition, Class&lt;T&gt; javaClass)
        {
<span class="fc" id="L2847">            this(definition, TypeToken.of(javaClass));</span>
<span class="fc" id="L2848">        }</span>

        AbstractTupleCodec(TupleType definition, TypeToken&lt;T&gt; javaType)
        {
<span class="fc" id="L2852">            super(definition, javaType);</span>
<span class="fc" id="L2853">            this.definition = definition;</span>
<span class="fc" id="L2854">        }</span>

        @Override
        public boolean accepts(DataType cqlType)
        {
            // a tuple codec should accept tuple values of a different type,
            // provided that the latter is contained in this codec's type.
<span class="pc bpc" id="L2861" title="2 of 4 branches missed.">            return super.accepts(cqlType) &amp;&amp; definition.contains((TupleType) cqlType);</span>
        }

        @Override
        public ByteBuffer serialize(T value, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L2867" title="1 of 2 branches missed.">            if (value == null) return null;</span>
<span class="fc" id="L2868">            int size = 0;</span>
<span class="fc" id="L2869">            int length = definition.getComponentTypes().size();</span>
<span class="fc" id="L2870">            ByteBuffer[] elements = new ByteBuffer[length];</span>
<span class="fc bfc" id="L2871" title="All 2 branches covered.">            for (int i = 0; i &lt; length; i++)</span>
            {
<span class="fc" id="L2873">                elements[i] = serializeField(value, i, protocolVersion);</span>
<span class="pc bpc" id="L2874" title="1 of 2 branches missed.">                size += 4 + (elements[i] == null ? 0 : elements[i].remaining());</span>
            }
<span class="fc" id="L2876">            ByteBuffer result = ByteBuffer.allocate(size);</span>
<span class="fc bfc" id="L2877" title="All 2 branches covered.">            for (ByteBuffer bb : elements)</span>
            {
<span class="pc bpc" id="L2879" title="1 of 2 branches missed.">                if (bb == null)</span>
                {
<span class="nc" id="L2881">                    result.putInt(-1);</span>
                }
                else
                {
<span class="fc" id="L2885">                    result.putInt(bb.remaining());</span>
<span class="fc" id="L2886">                    result.put(bb.duplicate());</span>
                }
            }
<span class="fc" id="L2889">            return (ByteBuffer) result.flip();</span>
        }

        @Override
        public T deserialize(ByteBuffer bytes, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L2895" title="1 of 2 branches missed.">            if (bytes == null) return null;</span>
            // empty byte buffers will result in empty values
            try
            {
<span class="fc" id="L2899">                ByteBuffer input = bytes.duplicate();</span>
<span class="fc" id="L2900">                T value = newInstance();</span>
<span class="fc" id="L2901">                int i = 0;</span>
<span class="pc bpc" id="L2902" title="1 of 4 branches missed.">                while (input.hasRemaining() &amp;&amp; i &lt; definition.getComponentTypes().size())</span>
                {
<span class="fc" id="L2904">                    int n = input.getInt();</span>
<span class="pc bpc" id="L2905" title="1 of 2 branches missed.">                    ByteBuffer element = n &lt; 0 ? null : CodecUtils.readBytes(input, n);</span>
<span class="fc" id="L2906">                    value = deserializeAndSetField(element, value, i++, protocolVersion);</span>
<span class="fc" id="L2907">                }</span>
<span class="fc" id="L2908">                return value;</span>
            }
<span class="nc" id="L2910">            catch (BufferUnderflowException e)</span>
            {
<span class="nc" id="L2912">                throw new InvalidTypeException(&quot;Not enough bytes to deserialize a tuple&quot;, e);</span>
            }
        }

        @Override
        public String format(T value)
        {
<span class="pc bpc" id="L2919" title="1 of 2 branches missed.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="fc" id="L2920">            StringBuilder sb = new StringBuilder(&quot;(&quot;);</span>
<span class="fc" id="L2921">            int length = definition.getComponentTypes().size();</span>
<span class="fc bfc" id="L2922" title="All 2 branches covered.">            for (int i = 0; i &lt; length; i++)</span>
            {
<span class="fc bfc" id="L2924" title="All 2 branches covered.">                if (i &gt; 0) sb.append(',');</span>
<span class="fc" id="L2925">                sb.append(formatField(value, i));</span>
            }
<span class="fc" id="L2927">            sb.append(')');</span>
<span class="fc" id="L2928">            return sb.toString();</span>
        }

        @Override
        public T parse(String value)
        {
<span class="nc bnc" id="L2934" title="All 6 branches missed.">            if (value == null || value.isEmpty() || value.equalsIgnoreCase(&quot;NULL&quot;)) return null;</span>

<span class="nc" id="L2936">            T v = newInstance();</span>

<span class="nc" id="L2938">            int idx = ParseUtils.skipSpaces(value, 0);</span>
<span class="nc bnc" id="L2939" title="All 2 branches missed.">            if (value.charAt(idx++) != '(')</span>
<span class="nc" id="L2940">                throw new InvalidTypeException(</span>
<span class="nc" id="L2941">                String.format(</span>
                &quot;Cannot parse tuple value from \&quot;%s\&quot;, at character %d expecting '(' but got '%c'&quot;,
<span class="nc" id="L2943">                value, idx, value.charAt(idx)));</span>

<span class="nc" id="L2945">            idx = ParseUtils.skipSpaces(value, idx);</span>

<span class="nc bnc" id="L2947" title="All 2 branches missed.">            if (value.charAt(idx) == ')') return v;</span>

<span class="nc" id="L2949">            int i = 0;</span>
<span class="nc bnc" id="L2950" title="All 2 branches missed.">            while (idx &lt; value.length())</span>
            {
                int n;
                try
                {
<span class="nc" id="L2955">                    n = ParseUtils.skipCQLValue(value, idx);</span>
                }
<span class="nc" id="L2957">                catch (IllegalArgumentException e)</span>
                {
<span class="nc" id="L2959">                    throw new InvalidTypeException(</span>
<span class="nc" id="L2960">                    String.format(</span>
                    &quot;Cannot parse tuple value from \&quot;%s\&quot;, invalid CQL value at character %d&quot;,
<span class="nc" id="L2962">                    value, idx),</span>
                    e);
<span class="nc" id="L2964">                }</span>

<span class="nc" id="L2966">                String input = value.substring(idx, n);</span>
<span class="nc" id="L2967">                v = parseAndSetField(input, v, i);</span>
<span class="nc" id="L2968">                idx = n;</span>
<span class="nc" id="L2969">                i += 1;</span>

<span class="nc" id="L2971">                idx = ParseUtils.skipSpaces(value, idx);</span>
<span class="nc bnc" id="L2972" title="All 2 branches missed.">                if (value.charAt(idx) == ')') return v;</span>
<span class="nc bnc" id="L2973" title="All 2 branches missed.">                if (value.charAt(idx) != ',')</span>
<span class="nc" id="L2974">                    throw new InvalidTypeException(</span>
<span class="nc" id="L2975">                    String.format(</span>
                    &quot;Cannot parse tuple value from \&quot;%s\&quot;, at character %d expecting ',' but got '%c'&quot;,
<span class="nc" id="L2977">                    value, idx, value.charAt(idx)));</span>
<span class="nc" id="L2978">                ++idx; // skip ','</span>

<span class="nc" id="L2980">                idx = ParseUtils.skipSpaces(value, idx);</span>
<span class="nc" id="L2981">            }</span>
<span class="nc" id="L2982">            throw new InvalidTypeException(</span>
<span class="nc" id="L2983">            String.format(&quot;Malformed tuple value \&quot;%s\&quot;, missing closing ')'&quot;, value));</span>
        }

        /**
         * Return a new instance of {@code T}.
         *
         * @return A new instance of {@code T}.
         */
        protected abstract T newInstance();

        /**
         * Serialize an individual field in an object, as part of serializing the whole object to a CQL
         * tuple (see {@link #serialize(Object, ProtocolVersion)}).
         *
         * @param source          The object to read the field from.
         * @param index           The index of the field.
         * @param protocolVersion The protocol version to use.
         * @return The serialized field, or {@code null} if that field should be ignored.
         */
        protected abstract ByteBuffer serializeField(
        T source, int index, ProtocolVersion protocolVersion);

        /**
         * Deserialize an individual field and set it on an object, as part of deserializing the whole
         * object from a CQL tuple (see {@link #deserialize(ByteBuffer, ProtocolVersion)}).
         *
         * @param input           The serialized form of the field.
         * @param target          The object to set the field on.
         * @param index           The index of the field.
         * @param protocolVersion The protocol version to use.
         * @return The target object with the field set. In most cases this should be the same as {@code
         * target}, but if you're dealing with immutable types you'll need to return a different
         * instance.
         */
        protected abstract T deserializeAndSetField(
        ByteBuffer input, T target, int index, ProtocolVersion protocolVersion);

        /**
         * Format an individual field in an object as a CQL literal, as part of formatting the whole
         * object (see {@link #format(Object)}).
         *
         * @param source The object to read the field from.
         * @param index  The index of the field.
         * @return The formatted value.
         */
        protected abstract String formatField(T source, int index);

        /**
         * Parse an individual field and set it on an object, as part of parsing the whole object (see
         * {@link #parse(String)}).
         *
         * @param input  The String to parse the field from.
         * @param target The value to write to.
         * @param index  The index of the field.
         * @return The target object with the field set. In most cases this should be the same as {@code
         * target}, but if you're dealing with immutable types you'll need to return a different
         * instance.
         */
        protected abstract T parseAndSetField(String input, T target, int index);
    }

    /**
     * This codec maps a CQL {@link TupleType tuple} to a {@link TupleValue}.
     */
    private static class TupleCodec extends AbstractTupleCodec&lt;TupleValue&gt;
    {

        private TupleCodec(TupleType definition)
        {
<span class="fc" id="L3052">            super(definition, TupleValue.class);</span>
<span class="fc" id="L3053">        }</span>

        @Override
        public boolean accepts(Object value)
        {
            // a tuple codec should accept tuple values of a different type,
            // provided that the latter is contained in this codec's type.
<span class="nc bnc" id="L3060" title="All 4 branches missed.">            return super.accepts(value) &amp;&amp; definition.contains(((TupleValue) value).getType());</span>
        }

        @Override
        protected TupleValue newInstance()
        {
<span class="fc" id="L3066">            return definition.newValue();</span>
        }

        @Override
        protected ByteBuffer serializeField(
        TupleValue source, int index, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L3073" title="1 of 2 branches missed.">            if (index &gt;= source.values.length) return null;</span>
<span class="fc" id="L3074">            return source.getBytesUnsafe(index);</span>
        }

        @Override
        protected TupleValue deserializeAndSetField(
        ByteBuffer input, TupleValue target, int index, ProtocolVersion protocolVersion)
        {
<span class="pc bpc" id="L3081" title="1 of 2 branches missed.">            if (index &gt;= target.values.length) return target;</span>
<span class="fc" id="L3082">            return target.setBytesUnsafe(index, input);</span>
        }

        @Override
        protected String formatField(TupleValue value, int index)
        {
<span class="fc" id="L3088">            DataType elementType = definition.getComponentTypes().get(index);</span>
<span class="fc" id="L3089">            TypeCodec&lt;Object&gt; codec = definition.getCodecRegistry().codecFor(elementType);</span>
<span class="fc" id="L3090">            return codec.format(value.get(index, codec.getJavaType()));</span>
        }

        @Override
        protected TupleValue parseAndSetField(String input, TupleValue target, int index)
        {
<span class="nc" id="L3096">            DataType elementType = definition.getComponentTypes().get(index);</span>
<span class="nc" id="L3097">            TypeCodec&lt;Object&gt; codec = definition.getCodecRegistry().codecFor(elementType);</span>
<span class="nc" id="L3098">            target.set(index, codec.parse(input), codec.getJavaType());</span>
<span class="nc" id="L3099">            return target;</span>
        }
    }

    private static class DurationCodec extends TypeCodec&lt;Duration&gt;
    {

<span class="fc" id="L3106">        private static final DurationCodec instance = new DurationCodec();</span>

        private DurationCodec()
        {
<span class="fc" id="L3110">            super(DataType.duration(), Duration.class);</span>
<span class="fc" id="L3111">        }</span>

        @Override
        public ByteBuffer serialize(Duration duration, ProtocolVersion protocolVersion)
        throws InvalidTypeException
        {
<span class="nc bnc" id="L3117" title="All 2 branches missed.">            if (duration == null) return null;</span>
<span class="nc" id="L3118">            long months = duration.getMonths();</span>
<span class="nc" id="L3119">            long days = duration.getDays();</span>
<span class="nc" id="L3120">            long nanoseconds = duration.getNanoseconds();</span>
<span class="nc" id="L3121">            int size =</span>
<span class="nc" id="L3122">            VIntCoding.computeVIntSize(months)</span>
<span class="nc" id="L3123">            + VIntCoding.computeVIntSize(days)</span>
<span class="nc" id="L3124">            + VIntCoding.computeVIntSize(nanoseconds);</span>
<span class="nc" id="L3125">            ByteBuffer bb = ByteBuffer.allocate(size);</span>
<span class="nc" id="L3126">            VIntCoding.writeVInt(months, bb);</span>
<span class="nc" id="L3127">            VIntCoding.writeVInt(days, bb);</span>
<span class="nc" id="L3128">            VIntCoding.writeVInt(nanoseconds, bb);</span>
<span class="nc" id="L3129">            bb.flip();</span>
<span class="nc" id="L3130">            return bb;</span>
        }

        @Override
        public Duration deserialize(ByteBuffer bytes, ProtocolVersion protocolVersion)
        throws InvalidTypeException
        {
<span class="nc bnc" id="L3137" title="All 4 branches missed.">            if (bytes == null || bytes.remaining() == 0)</span>
            {
<span class="nc" id="L3139">                return null;</span>
            }
            else
            {
<span class="nc" id="L3143">                DataInput in = ByteStreams.newDataInput(Bytes.getArray(bytes));</span>
                try
                {
<span class="nc" id="L3146">                    int months = VIntCoding.readVInt32(in);</span>
<span class="nc" id="L3147">                    int days = VIntCoding.readVInt32(in);</span>
<span class="nc" id="L3148">                    long nanoseconds = VIntCoding.readVInt(in);</span>
<span class="nc" id="L3149">                    return Duration.newInstance(months, days, nanoseconds);</span>
                }
<span class="nc" id="L3151">                catch (IOException e)</span>
                {
                    // cannot happen
<span class="nc" id="L3154">                    throw new AssertionError();</span>
                }
            }
        }

        @Override
        public Duration parse(String value) throws InvalidTypeException
        {
<span class="nc bnc" id="L3162" title="All 6 branches missed.">            if (value == null || value.isEmpty() || value.equalsIgnoreCase(&quot;NULL&quot;)) return null;</span>
<span class="nc" id="L3163">            return Duration.from(value);</span>
        }

        @Override
        public String format(Duration value) throws InvalidTypeException
        {
<span class="nc bnc" id="L3169" title="All 2 branches missed.">            if (value == null) return &quot;NULL&quot;;</span>
<span class="nc" id="L3170">            return value.toString();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>