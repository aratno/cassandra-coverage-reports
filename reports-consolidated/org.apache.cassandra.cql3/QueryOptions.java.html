<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QueryOptions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3</a> &gt; <span class="el_source">QueryOptions.java</span></div><h1>QueryOptions.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3;

import java.nio.ByteBuffer;
import java.util.*;

import com.google.common.collect.ImmutableList;

import io.netty.buffer.ByteBuf;

import org.apache.cassandra.config.DataStorageSpec;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.db.ConsistencyLevel;
import org.apache.cassandra.db.marshal.UTF8Type;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.service.QueryState;
import org.apache.cassandra.service.pager.PagingState;
import org.apache.cassandra.transport.CBCodec;
import org.apache.cassandra.transport.CBUtil;
import org.apache.cassandra.transport.ProtocolException;
import org.apache.cassandra.transport.ProtocolVersion;
import org.apache.cassandra.utils.CassandraUInt;
import org.apache.cassandra.utils.Pair;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;

/**
 * Options for a query.
 */
<span class="fc" id="L47">public abstract class QueryOptions</span>
{
<span class="fc" id="L49">    public static final QueryOptions DEFAULT = new DefaultQueryOptions(ConsistencyLevel.ONE,</span>
<span class="fc" id="L50">                                                                       Collections.emptyList(),</span>
                                                                       false,
                                                                       SpecificOptions.DEFAULT,
                                                                       ProtocolVersion.CURRENT);

<span class="fc" id="L55">    public static final CBCodec&lt;QueryOptions&gt; codec = new Codec();</span>

    private static final long UNSET_NOWINSEC = Long.MIN_VALUE;

    // A cache of bind values parsed as JSON, see getJsonColumnValue for details.
    private List&lt;Map&lt;ColumnIdentifier, Term&gt;&gt; jsonValuesCache;

    public static QueryOptions forInternalCalls(ConsistencyLevel consistency, List&lt;ByteBuffer&gt; values)
    {
<span class="fc" id="L64">        return new DefaultQueryOptions(consistency, values, false, SpecificOptions.DEFAULT, ProtocolVersion.V3);</span>
    }

    public static QueryOptions forInternalCallsWithNowInSec(long nowInSec, ConsistencyLevel consistency, List&lt;ByteBuffer&gt; values)
    {
<span class="fc" id="L69">        return new DefaultQueryOptions(consistency, values, false, SpecificOptions.DEFAULT.withNowInSec(nowInSec), ProtocolVersion.CURRENT);</span>
    }

    public static QueryOptions forInternalCalls(List&lt;ByteBuffer&gt; values)
    {
<span class="fc" id="L74">        return new DefaultQueryOptions(ConsistencyLevel.ONE, values, false, SpecificOptions.DEFAULT, ProtocolVersion.V3);</span>
    }

    public static QueryOptions forProtocolVersion(ProtocolVersion protocolVersion)
    {
<span class="fc" id="L79">        return new DefaultQueryOptions(null, null, true, null, protocolVersion);</span>
    }

    public static QueryOptions create(ConsistencyLevel consistency,
                                      List&lt;ByteBuffer&gt; values,
                                      boolean skipMetadata,
                                      int pageSize,
                                      PagingState pagingState,
                                      ConsistencyLevel serialConsistency,
                                      ProtocolVersion version,
                                      String keyspace)
    {
<span class="fc" id="L91">        return create(consistency, values, skipMetadata, pageSize, pagingState, serialConsistency, version, keyspace, Long.MIN_VALUE, UNSET_NOWINSEC);</span>
    }

    public static QueryOptions create(ConsistencyLevel consistency,
                                      List&lt;ByteBuffer&gt; values,
                                      boolean skipMetadata,
                                      int pageSize,
                                      PagingState pagingState,
                                      ConsistencyLevel serialConsistency,
                                      ProtocolVersion version,
                                      String keyspace,
                                      long timestamp,
                                      long nowInSeconds)
    {
<span class="fc" id="L105">        return new DefaultQueryOptions(consistency,</span>
                                       values,
                                       skipMetadata,
                                       new SpecificOptions(pageSize, pagingState, serialConsistency, timestamp, keyspace, nowInSeconds),
                                       version);
    }

    public static QueryOptions addColumnSpecifications(QueryOptions options, List&lt;ColumnSpecification&gt; columnSpecs)
    {
<span class="fc" id="L114">        return new OptionsWithColumnSpecifications(options, columnSpecs);</span>
    }

    public abstract ConsistencyLevel getConsistency();
    public abstract List&lt;ByteBuffer&gt; getValues();
    public abstract boolean skipMetadata();

    /**
     * Returns the term corresponding to column {@code columnName} in the JSON value of bind index {@code bindIndex}.
     *
     * This is functionally equivalent to:
     *   {@code Json.parseJson(UTF8Type.instance.getSerializer().deserialize(getValues().get(bindIndex)), expectedReceivers).get(columnName)}
     * but this caches the result of parsing the JSON, so that while this might be called for multiple columns on the same {@code bindIndex}
     * value, the underlying JSON value is only parsed/processed once.
     *
     * Note: this is a bit more involved in CQL specifics than this class generally is, but as we need to cache this per-query and in an object
     * that is available when we bind values, this is the easiest place to have this.
     *
     * @param bindIndex the index of the bind value that should be interpreted as a JSON value.
     * @param columnName the name of the column we want the value of.
     * @param expectedReceivers the columns expected in the JSON value at index {@code bindIndex}. This is only used when parsing the
     * json initially and no check is done afterwards. So in practice, any call of this method on the same QueryOptions object and with the same
     * {@code bindIndx} values should use the same value for this parameter, but this isn't validated in any way.
     *
     * @return the value correspong to column {@code columnName} in the (JSON) bind value at index {@code bindIndex}. This may return null if the
     * JSON value has no value for this column.
     */
    public Term getJsonColumnValue(int bindIndex, ColumnIdentifier columnName, Collection&lt;ColumnMetadata&gt; expectedReceivers) throws InvalidRequestException
    {
<span class="fc bfc" id="L143" title="All 2 branches covered.">        if (jsonValuesCache == null)</span>
<span class="fc" id="L144">            jsonValuesCache = new ArrayList&lt;&gt;(Collections.&lt;Map&lt;ColumnIdentifier, Term&gt;&gt;nCopies(getValues().size(), null));</span>

<span class="fc" id="L146">        Map&lt;ColumnIdentifier, Term&gt; jsonValue = jsonValuesCache.get(bindIndex);</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">        if (jsonValue == null)</span>
        {
<span class="fc" id="L149">            ByteBuffer value = getValues().get(bindIndex);</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">            if (value == null)</span>
<span class="fc" id="L151">                throw new InvalidRequestException(&quot;Got null for INSERT JSON values&quot;);</span>

<span class="fc" id="L153">            jsonValue = Json.parseJson(UTF8Type.instance.getSerializer().deserialize(value), expectedReceivers);</span>
<span class="fc" id="L154">            jsonValuesCache.set(bindIndex, jsonValue);</span>
        }

<span class="fc" id="L157">        return jsonValue.get(columnName);</span>
    }

    /**
     * Tells whether or not this &lt;code&gt;QueryOptions&lt;/code&gt; contains the column specifications for the bound variables.
     * &lt;p&gt;The column specifications will be present only for prepared statements.&lt;/p&gt;
     * @return &lt;code&gt;true&lt;/code&gt; this &lt;code&gt;QueryOptions&lt;/code&gt; contains the column specifications for the bound
     * variables, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean hasColumnSpecifications()
    {
<span class="nc" id="L168">        return false;</span>
    }

    /**
     * Returns the column specifications for the bound variables (&lt;i&gt;optional operation&lt;/i&gt;).
     *
     * &lt;p&gt;The column specifications will be present only for prepared statements.&lt;/p&gt;
     *
     * &lt;p&gt;Invoke the {@link #hasColumnSpecifications} method before invoking this method in order to ensure that this
     * &lt;code&gt;QueryOptions&lt;/code&gt; contains the column specifications.&lt;/p&gt;
     *
     * @return the option names
     * @throws UnsupportedOperationException If this &lt;code&gt;QueryOptions&lt;/code&gt; does not contains the column
     * specifications.
     */
    public ImmutableList&lt;ColumnSpecification&gt; getColumnSpecifications()
    {
<span class="nc" id="L185">        throw new UnsupportedOperationException();</span>
    }

    /**  The pageSize for this query. Will be {@code &lt;= 0} if not relevant for the query.  */
    public int getPageSize()
    {
<span class="fc" id="L191">        return getSpecificOptions().pageSize;</span>
    }

    /** The paging state for this query, or null if not relevant. */
    public PagingState getPagingState()
    {
<span class="fc" id="L197">        return getSpecificOptions().state;</span>
    }

    /**  Serial consistency for conditional updates. */
    public ConsistencyLevel getSerialConsistency()
    {
<span class="fc" id="L203">        return getSpecificOptions().serialConsistency;</span>
    }

    public long getTimestamp(QueryState state)
    {
<span class="fc" id="L208">        long tstamp = getSpecificOptions().timestamp;</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">        return tstamp != Long.MIN_VALUE ? tstamp : state.getTimestamp();</span>
    }

    public long getNowInSeconds(QueryState state)
    {
<span class="fc" id="L214">        long nowInSeconds = getSpecificOptions().nowInSeconds;</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">        return nowInSeconds != UNSET_NOWINSEC ? nowInSeconds : state.getNowInSeconds();</span>
    }

    /** The keyspace that this query is bound to, or null if not relevant. */
<span class="fc" id="L219">    public String getKeyspace() { return getSpecificOptions().keyspace; }</span>

    public long getNowInSec(long ifNotSet)
    {
<span class="fc" id="L223">        long nowInSec = getSpecificOptions().nowInSeconds;</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        return nowInSec != UNSET_NOWINSEC ? nowInSec : ifNotSet;</span>
    }

    /**
     * The protocol version for the query.
     */
    public abstract ProtocolVersion getProtocolVersion();

    // Mainly for the sake of BatchQueryOptions
    abstract SpecificOptions getSpecificOptions();

    abstract ReadThresholds getReadThresholds();

    public boolean isReadThresholdsEnabled()
    {
<span class="fc" id="L239">        return getReadThresholds().isEnabled();</span>
    }

    public long getCoordinatorReadSizeWarnThresholdBytes()
    {
<span class="fc" id="L244">        return getReadThresholds().getCoordinatorReadSizeWarnThresholdBytes();</span>
    }

    public long getCoordinatorReadSizeAbortThresholdBytes()
    {
<span class="fc" id="L249">        return getReadThresholds().getCoordinatorReadSizeFailThresholdBytes();</span>
    }

    public QueryOptions prepare(List&lt;ColumnSpecification&gt; specs)
    {
<span class="fc" id="L254">        return this;</span>
    }

    interface ReadThresholds
    {
        boolean isEnabled();

        long getCoordinatorReadSizeWarnThresholdBytes();

        long getCoordinatorReadSizeFailThresholdBytes();

        static ReadThresholds create()
        {
            // if daemon initialization hasn't happened yet (very common in tests) then ignore
<span class="fc bfc" id="L268" title="All 4 branches covered.">            if (!DatabaseDescriptor.isDaemonInitialized() || !DatabaseDescriptor.getReadThresholdsEnabled())</span>
<span class="fc" id="L269">                return DisabledReadThresholds.INSTANCE;</span>
<span class="fc" id="L270">            return new DefaultReadThresholds(DatabaseDescriptor.getCoordinatorReadSizeWarnThreshold(), DatabaseDescriptor.getCoordinatorReadSizeFailThreshold());</span>
        }
    }

<span class="fc" id="L274">    private enum DisabledReadThresholds implements ReadThresholds</span>
    {
<span class="fc" id="L276">        INSTANCE;</span>

        @Override
        public boolean isEnabled()
        {
<span class="fc" id="L281">            return false;</span>
        }

        @Override
        public long getCoordinatorReadSizeWarnThresholdBytes()
        {
<span class="nc" id="L287">            return -1;</span>
        }

        @Override
        public long getCoordinatorReadSizeFailThresholdBytes()
        {
<span class="nc" id="L293">            return -1;</span>
        }
    }

    private static class DefaultReadThresholds implements ReadThresholds
    {
        private final long warnThresholdBytes;
        private final long abortThresholdBytes;

        public DefaultReadThresholds(DataStorageSpec.LongBytesBound warnThreshold, DataStorageSpec.LongBytesBound abortThreshold)
<span class="fc" id="L303">        {</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">            this.warnThresholdBytes = warnThreshold == null ? -1 : warnThreshold.toBytes();</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">            this.abortThresholdBytes = abortThreshold == null ? -1 : abortThreshold.toBytes();</span>
<span class="fc" id="L306">        }</span>

        @Override
        public boolean isEnabled()
        {
<span class="fc" id="L311">            return true;</span>
        }

        @Override
        public long getCoordinatorReadSizeWarnThresholdBytes()
        {
<span class="fc" id="L317">            return warnThresholdBytes;</span>
        }

        @Override
        public long getCoordinatorReadSizeFailThresholdBytes()
        {
<span class="fc" id="L323">            return abortThresholdBytes;</span>
        }
    }

    static class DefaultQueryOptions extends QueryOptions
    {
        private final ConsistencyLevel consistency;
        private final List&lt;ByteBuffer&gt; values;
        private final boolean skipMetadata;

        private final SpecificOptions options;

        private final transient ProtocolVersion protocolVersion;
<span class="fc" id="L336">        private final transient ReadThresholds readThresholds = ReadThresholds.create();</span>

        DefaultQueryOptions(ConsistencyLevel consistency, List&lt;ByteBuffer&gt; values, boolean skipMetadata, SpecificOptions options, ProtocolVersion protocolVersion)
<span class="fc" id="L339">        {</span>
<span class="fc" id="L340">            this.consistency = consistency;</span>
<span class="fc" id="L341">            this.values = values;</span>
<span class="fc" id="L342">            this.skipMetadata = skipMetadata;</span>
<span class="fc" id="L343">            this.options = options;</span>
<span class="fc" id="L344">            this.protocolVersion = protocolVersion;</span>
<span class="fc" id="L345">        }</span>

        public ConsistencyLevel getConsistency()
        {
<span class="fc" id="L349">            return consistency;</span>
        }

        public List&lt;ByteBuffer&gt; getValues()
        {
<span class="fc" id="L354">            return values;</span>
        }

        public boolean skipMetadata()
        {
<span class="fc" id="L359">            return skipMetadata;</span>
        }

        public ProtocolVersion getProtocolVersion()
        {
<span class="fc" id="L364">            return protocolVersion;</span>
        }

        SpecificOptions getSpecificOptions()
        {
<span class="fc" id="L369">            return options;</span>
        }

        @Override
        ReadThresholds getReadThresholds()
        {
<span class="fc" id="L375">            return readThresholds;</span>
        }
    }

    static class QueryOptionsWrapper extends QueryOptions
    {
        protected final QueryOptions wrapped;

        QueryOptionsWrapper(QueryOptions wrapped)
<span class="fc" id="L384">        {</span>
<span class="fc" id="L385">            this.wrapped = wrapped;</span>
<span class="fc" id="L386">        }</span>

        public List&lt;ByteBuffer&gt; getValues()
        {
<span class="fc" id="L390">            return this.wrapped.getValues();</span>
        }

        public ConsistencyLevel getConsistency()
        {
<span class="fc" id="L395">            return wrapped.getConsistency();</span>
        }

        public boolean skipMetadata()
        {
<span class="nc" id="L400">            return wrapped.skipMetadata();</span>
        }

        public ProtocolVersion getProtocolVersion()
        {
<span class="fc" id="L405">            return wrapped.getProtocolVersion();</span>
        }

        SpecificOptions getSpecificOptions()
        {
<span class="fc" id="L410">            return wrapped.getSpecificOptions();</span>
        }

        @Override
        ReadThresholds getReadThresholds()
        {
<span class="fc" id="L416">            return wrapped.getReadThresholds();</span>
        }

        @Override
        public QueryOptions prepare(List&lt;ColumnSpecification&gt; specs)
        {
<span class="fc" id="L422">            wrapped.prepare(specs);</span>
<span class="fc" id="L423">            return this;</span>
        }
    }

    /**
     * &lt;code&gt;QueryOptions&lt;/code&gt; decorator that provides access to the column specifications.
     */
    static class OptionsWithColumnSpecifications extends QueryOptionsWrapper
    {
        private final ImmutableList&lt;ColumnSpecification&gt; columnSpecs;

        OptionsWithColumnSpecifications(QueryOptions wrapped, List&lt;ColumnSpecification&gt; columnSpecs)
        {
<span class="fc" id="L436">            super(wrapped);</span>
<span class="fc" id="L437">            this.columnSpecs = ImmutableList.copyOf(columnSpecs);</span>
<span class="fc" id="L438">        }</span>

        @Override
        public boolean hasColumnSpecifications()
        {
<span class="nc" id="L443">            return true;</span>
        }

        @Override
        public ImmutableList&lt;ColumnSpecification&gt; getColumnSpecifications()
        {
<span class="nc" id="L449">            return columnSpecs;</span>
        }
    }

<span class="nc" id="L453">    static class OptionsWithNames extends QueryOptionsWrapper</span>
    {
        private final List&lt;String&gt; names;
        private List&lt;ByteBuffer&gt; orderedValues;

        OptionsWithNames(DefaultQueryOptions wrapped, List&lt;String&gt; names)
        {
<span class="nc" id="L460">            super(wrapped);</span>
<span class="nc" id="L461">            this.names = names;</span>
<span class="nc" id="L462">        }</span>

        @Override
        public QueryOptions prepare(List&lt;ColumnSpecification&gt; specs)
        {
<span class="nc" id="L467">            super.prepare(specs);</span>

<span class="nc" id="L469">            orderedValues = new ArrayList&lt;&gt;(specs.size());</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">            for (int i = 0; i &lt; specs.size(); i++)</span>
            {
<span class="nc" id="L472">                String name = specs.get(i).name.toString();</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">                for (int j = 0; j &lt; names.size(); j++)</span>
                {
<span class="nc bnc" id="L475" title="All 2 branches missed.">                    if (name.equals(names.get(j)))</span>
                    {
<span class="nc" id="L477">                        orderedValues.add(wrapped.getValues().get(j));</span>
<span class="nc" id="L478">                        break;</span>
                    }
                }
            }
<span class="nc" id="L482">            return this;</span>
        }

        @Override
        public List&lt;ByteBuffer&gt; getValues()
        {
<span class="nc bnc" id="L488" title="All 2 branches missed.">            assert orderedValues != null; // We should have called prepare first!</span>
<span class="nc" id="L489">            return orderedValues;</span>
        }
    }

    // Options that are likely to not be present in most queries
    static class SpecificOptions
    {
<span class="fc" id="L496">        private static final SpecificOptions DEFAULT = new SpecificOptions(-1, null, null, Long.MIN_VALUE, null, UNSET_NOWINSEC);</span>

        private final int pageSize;
        private final PagingState state;
        private final ConsistencyLevel serialConsistency;
        private final long timestamp;
        private final String keyspace;
        private final long nowInSeconds;

        private SpecificOptions(int pageSize,
                                PagingState state,
                                ConsistencyLevel serialConsistency,
                                long timestamp,
                                String keyspace,
                                long nowInSeconds)
<span class="fc" id="L511">        {</span>
<span class="fc" id="L512">            this.pageSize = pageSize;</span>
<span class="fc" id="L513">            this.state = state;</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">            this.serialConsistency = serialConsistency == null ? ConsistencyLevel.SERIAL : serialConsistency;</span>
<span class="fc" id="L515">            this.timestamp = timestamp;</span>
<span class="fc" id="L516">            this.keyspace = keyspace;</span>
<span class="fc" id="L517">            this.nowInSeconds = nowInSeconds;</span>
<span class="fc" id="L518">        }</span>

        public SpecificOptions withNowInSec(long nowInSec)
        {
<span class="fc" id="L522">            return new SpecificOptions(pageSize, state, serialConsistency, timestamp, keyspace, nowInSec);</span>
        }
    }

    private static class Codec implements CBCodec&lt;QueryOptions&gt;
    {
<span class="fc" id="L528">        private enum Flag</span>
        {
            // The order of that enum matters!!
<span class="fc" id="L531">            VALUES,</span>
<span class="fc" id="L532">            SKIP_METADATA,</span>
<span class="fc" id="L533">            PAGE_SIZE,</span>
<span class="fc" id="L534">            PAGING_STATE,</span>
<span class="fc" id="L535">            SERIAL_CONSISTENCY,</span>
<span class="fc" id="L536">            TIMESTAMP,</span>
<span class="fc" id="L537">            NAMES_FOR_VALUES,</span>
<span class="fc" id="L538">            KEYSPACE,</span>
<span class="fc" id="L539">            NOW_IN_SECONDS;</span>

<span class="fc" id="L541">            private static final Flag[] ALL_VALUES = values();</span>

            public static EnumSet&lt;Flag&gt; deserialize(int flags)
            {
<span class="fc" id="L545">                EnumSet&lt;Flag&gt; set = EnumSet.noneOf(Flag.class);</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">                for (int n = 0; n &lt; ALL_VALUES.length; n++)</span>
                {
<span class="fc bfc" id="L548" title="All 2 branches covered.">                    if ((flags &amp; (1 &lt;&lt; n)) != 0)</span>
<span class="fc" id="L549">                        set.add(ALL_VALUES[n]);</span>
                }
<span class="fc" id="L551">                return set;</span>
            }

            public static int serialize(EnumSet&lt;Flag&gt; flags)
            {
<span class="fc" id="L556">                int i = 0;</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">                for (Flag flag : flags)</span>
<span class="fc" id="L558">                    i |= 1 &lt;&lt; flag.ordinal();</span>
<span class="fc" id="L559">                return i;</span>
            }
        }

        public QueryOptions decode(ByteBuf body, ProtocolVersion version)
        {
<span class="fc" id="L565">            ConsistencyLevel consistency = CBUtil.readConsistencyLevel(body);</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">            EnumSet&lt;Flag&gt; flags = Flag.deserialize(version.isGreaterOrEqualTo(ProtocolVersion.V5)</span>
<span class="fc" id="L567">                                                   ? (int)body.readUnsignedInt()</span>
<span class="fc" id="L568">                                                   : (int)body.readUnsignedByte());</span>

<span class="fc" id="L570">            List&lt;ByteBuffer&gt; values = Collections.&lt;ByteBuffer&gt;emptyList();</span>
<span class="fc" id="L571">            List&lt;String&gt; names = null;</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">            if (flags.contains(Flag.VALUES))</span>
            {
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">                if (flags.contains(Flag.NAMES_FOR_VALUES))</span>
                {
<span class="nc" id="L576">                    Pair&lt;List&lt;String&gt;, List&lt;ByteBuffer&gt;&gt; namesAndValues = CBUtil.readNameAndValueList(body, version);</span>
<span class="nc" id="L577">                    names = namesAndValues.left;</span>
<span class="nc" id="L578">                    values = namesAndValues.right;</span>
<span class="nc" id="L579">                }</span>
                else
                {
<span class="fc" id="L582">                    values = CBUtil.readValueList(body, version);</span>
                }
            }

<span class="fc" id="L586">            boolean skipMetadata = flags.contains(Flag.SKIP_METADATA);</span>
<span class="fc" id="L587">            flags.remove(Flag.VALUES);</span>
<span class="fc" id="L588">            flags.remove(Flag.SKIP_METADATA);</span>

<span class="fc" id="L590">            SpecificOptions options = SpecificOptions.DEFAULT;</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">            if (!flags.isEmpty())</span>
            {
<span class="fc bfc" id="L593" title="All 2 branches covered.">                int pageSize = flags.contains(Flag.PAGE_SIZE) ? body.readInt() : -1;</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">                PagingState pagingState = flags.contains(Flag.PAGING_STATE) ? PagingState.deserialize(CBUtil.readValueNoCopy(body), version) : null;</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">                ConsistencyLevel serialConsistency = flags.contains(Flag.SERIAL_CONSISTENCY) ? CBUtil.readConsistencyLevel(body) : ConsistencyLevel.SERIAL;</span>
<span class="fc" id="L596">                long timestamp = Long.MIN_VALUE;</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">                if (flags.contains(Flag.TIMESTAMP))</span>
                {
<span class="fc" id="L599">                    long ts = body.readLong();</span>
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">                    if (ts == Long.MIN_VALUE)</span>
<span class="nc" id="L601">                        throw new ProtocolException(String.format(&quot;Out of bound timestamp, must be in [%d, %d] (got %d)&quot;, Long.MIN_VALUE + 1, Long.MAX_VALUE, ts));</span>
<span class="fc" id="L602">                    timestamp = ts;</span>
                }
<span class="fc bfc" id="L604" title="All 2 branches covered.">                String keyspace = flags.contains(Flag.KEYSPACE) ? CBUtil.readString(body) : null;</span>
<span class="fc bfc" id="L605" title="All 2 branches covered.">                long nowInSeconds = flags.contains(Flag.NOW_IN_SECONDS) ? CassandraUInt.toLong(body.readInt())</span>
<span class="fc" id="L606">                                                                        : UNSET_NOWINSEC;</span>
<span class="fc" id="L607">                options = new SpecificOptions(pageSize, pagingState, serialConsistency, timestamp, keyspace, nowInSeconds);</span>
            }

<span class="fc" id="L610">            DefaultQueryOptions opts = new DefaultQueryOptions(consistency, values, skipMetadata, options, version);</span>
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">            return names == null ? opts : new OptionsWithNames(opts, names);</span>
        }

        public void encode(QueryOptions options, ByteBuf dest, ProtocolVersion version)
        {
<span class="fc" id="L616">            CBUtil.writeConsistencyLevel(options.getConsistency(), dest);</span>

<span class="fc" id="L618">            EnumSet&lt;Flag&gt; flags = gatherFlags(options, version);</span>
<span class="fc bfc" id="L619" title="All 2 branches covered.">            if (version.isGreaterOrEqualTo(ProtocolVersion.V5))</span>
<span class="fc" id="L620">                dest.writeInt(Flag.serialize(flags));</span>
            else
<span class="fc" id="L622">                dest.writeByte((byte)Flag.serialize(flags));</span>

<span class="fc bfc" id="L624" title="All 2 branches covered.">            if (flags.contains(Flag.VALUES))</span>
<span class="fc" id="L625">                CBUtil.writeValueList(options.getValues(), dest);</span>
<span class="fc bfc" id="L626" title="All 2 branches covered.">            if (flags.contains(Flag.PAGE_SIZE))</span>
<span class="fc" id="L627">                dest.writeInt(options.getPageSize());</span>
<span class="fc bfc" id="L628" title="All 2 branches covered.">            if (flags.contains(Flag.PAGING_STATE))</span>
<span class="fc" id="L629">                CBUtil.writeValue(options.getPagingState().serialize(version), dest);</span>
<span class="pc bpc" id="L630" title="1 of 2 branches missed.">            if (flags.contains(Flag.SERIAL_CONSISTENCY))</span>
<span class="nc" id="L631">                CBUtil.writeConsistencyLevel(options.getSerialConsistency(), dest);</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">            if (flags.contains(Flag.TIMESTAMP))</span>
<span class="fc" id="L633">                dest.writeLong(options.getSpecificOptions().timestamp);</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">            if (flags.contains(Flag.KEYSPACE))</span>
<span class="fc" id="L635">                CBUtil.writeAsciiString(options.getSpecificOptions().keyspace, dest);</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">            if (flags.contains(Flag.NOW_IN_SECONDS))</span>
<span class="fc" id="L637">                dest.writeInt(CassandraUInt.fromLong(options.getSpecificOptions().nowInSeconds));</span>

            // Note that we don't really have to bother with NAMES_FOR_VALUES server side,
            // and in fact we never really encode QueryOptions, only decode them, so we
            // don't bother.
<span class="fc" id="L642">        }</span>

        public int encodedSize(QueryOptions options, ProtocolVersion version)
        {
<span class="fc" id="L646">            int size = 0;</span>

<span class="fc" id="L648">            size += CBUtil.sizeOfConsistencyLevel(options.getConsistency());</span>

<span class="fc" id="L650">            EnumSet&lt;Flag&gt; flags = gatherFlags(options, version);</span>
<span class="fc bfc" id="L651" title="All 2 branches covered.">            size += (version.isGreaterOrEqualTo(ProtocolVersion.V5) ? 4 : 1);</span>

<span class="fc bfc" id="L653" title="All 2 branches covered.">            if (flags.contains(Flag.VALUES))</span>
<span class="fc" id="L654">                size += CBUtil.sizeOfValueList(options.getValues());</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">            if (flags.contains(Flag.PAGE_SIZE))</span>
<span class="fc" id="L656">                size += 4;</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">            if (flags.contains(Flag.PAGING_STATE))</span>
<span class="fc" id="L658">                size += CBUtil.sizeOfValue(options.getPagingState().serializedSize(version));</span>
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">            if (flags.contains(Flag.SERIAL_CONSISTENCY))</span>
<span class="nc" id="L660">                size += CBUtil.sizeOfConsistencyLevel(options.getSerialConsistency());</span>
<span class="fc bfc" id="L661" title="All 2 branches covered.">            if (flags.contains(Flag.TIMESTAMP))</span>
<span class="fc" id="L662">                size += 8;</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">            if (flags.contains(Flag.KEYSPACE))</span>
<span class="fc" id="L664">                size += CBUtil.sizeOfAsciiString(options.getSpecificOptions().keyspace);</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">            if (flags.contains(Flag.NOW_IN_SECONDS))</span>
<span class="fc" id="L666">                size += 4;</span>

<span class="fc" id="L668">            return size;</span>
        }

        private EnumSet&lt;Flag&gt; gatherFlags(QueryOptions options, ProtocolVersion version)
        {
<span class="fc" id="L673">            EnumSet&lt;Flag&gt; flags = EnumSet.noneOf(Flag.class);</span>
<span class="fc bfc" id="L674" title="All 2 branches covered.">            if (options.getValues().size() &gt; 0)</span>
<span class="fc" id="L675">                flags.add(Flag.VALUES);</span>
<span class="fc bfc" id="L676" title="All 2 branches covered.">            if (options.skipMetadata())</span>
<span class="fc" id="L677">                flags.add(Flag.SKIP_METADATA);</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">            if (options.getPageSize() &gt;= 0)</span>
<span class="fc" id="L679">                flags.add(Flag.PAGE_SIZE);</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">            if (options.getPagingState() != null)</span>
<span class="fc" id="L681">                flags.add(Flag.PAGING_STATE);</span>
<span class="pc bpc" id="L682" title="1 of 2 branches missed.">            if (options.getSerialConsistency() != ConsistencyLevel.SERIAL)</span>
<span class="nc" id="L683">                flags.add(Flag.SERIAL_CONSISTENCY);</span>
<span class="fc bfc" id="L684" title="All 2 branches covered.">            if (options.getSpecificOptions().timestamp != Long.MIN_VALUE)</span>
<span class="fc" id="L685">                flags.add(Flag.TIMESTAMP);</span>

<span class="fc bfc" id="L687" title="All 2 branches covered.">            if (version.isGreaterOrEqualTo(ProtocolVersion.V5))</span>
            {
<span class="fc bfc" id="L689" title="All 2 branches covered.">                if (options.getSpecificOptions().keyspace != null)</span>
<span class="fc" id="L690">                    flags.add(Flag.KEYSPACE);</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">                if (options.getSpecificOptions().nowInSeconds != UNSET_NOWINSEC)</span>
<span class="fc" id="L692">                    flags.add(Flag.NOW_IN_SECONDS);</span>
            }

<span class="fc" id="L695">            return flags;</span>
        }
    }
    
    @Override
    public String toString()
    {
<span class="nc" id="L702">        return ToStringBuilder.reflectionToString(this, ToStringStyle.SHORT_PREFIX_STYLE);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>