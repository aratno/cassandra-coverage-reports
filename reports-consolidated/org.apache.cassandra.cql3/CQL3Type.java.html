<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CQL3Type.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3</a> &gt; <span class="el_source">CQL3Type.java</span></div><h1>CQL3Type.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.db.guardrails.Guardrails;
import org.apache.cassandra.db.marshal.*;
import org.apache.cassandra.db.marshal.CollectionType.Kind;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.exceptions.SyntaxException;
import org.apache.cassandra.schema.KeyspaceMetadata;
import org.apache.cassandra.schema.Schema;
import org.apache.cassandra.schema.SchemaConstants;
import org.apache.cassandra.schema.Types;
import org.apache.cassandra.serializers.CollectionSerializer;
import org.apache.cassandra.serializers.MarshalException;
import org.apache.cassandra.service.ClientState;
import org.apache.cassandra.utils.ByteBufferUtil;

import static java.util.stream.Collectors.toList;

public interface CQL3Type
{
<span class="fc" id="L46">    static final Logger logger = LoggerFactory.getLogger(CQL3Type.class);</span>

    default boolean isCollection()
    {
<span class="fc" id="L50">        return false;</span>
    }

    default boolean isUDT()
    {
<span class="fc" id="L55">        return false;</span>
    }

    default boolean isVector()
    {
<span class="fc" id="L60">        return false;</span>
    }

    public AbstractType&lt;?&gt; getType();

    /**
     * Generates CQL literal from a binary value of this type.
     *  @param bytes the value to convert to a CQL literal. This value must be
     * serialized with {@code version} of the native protocol.
     */
    String toCQLLiteral(ByteBuffer bytes);

    /**
     * Generates a binary value for the CQL literal of this type
     */
    default ByteBuffer fromCQLLiteral(String literal)
    {
<span class="fc" id="L77">        return fromCQLLiteral(SchemaConstants.DUMMY_KEYSPACE_OR_TABLE_NAME, literal);</span>
    }

    /**
     * Generates a binary value for the CQL literal of this type
     */
    default ByteBuffer fromCQLLiteral(String keyspaceName, String literal)
    {
<span class="fc" id="L85">        return Terms.asBytes(keyspaceName, literal, getType());</span>
    }

<span class="fc" id="L88">    public enum Native implements CQL3Type</span>
    {
<span class="fc" id="L90">        ASCII       (AsciiType.instance),</span>
<span class="fc" id="L91">        BIGINT      (LongType.instance),</span>
<span class="fc" id="L92">        BLOB        (BytesType.instance),</span>
<span class="fc" id="L93">        BOOLEAN     (BooleanType.instance),</span>
<span class="fc" id="L94">        COUNTER     (CounterColumnType.instance),</span>
<span class="fc" id="L95">        DATE        (SimpleDateType.instance),</span>
<span class="fc" id="L96">        DECIMAL     (DecimalType.instance),</span>
<span class="fc" id="L97">        DOUBLE      (DoubleType.instance),</span>
<span class="fc" id="L98">        DURATION    (DurationType.instance),</span>
<span class="fc" id="L99">        EMPTY       (EmptyType.instance),</span>
<span class="fc" id="L100">        FLOAT       (FloatType.instance),</span>
<span class="fc" id="L101">        INET        (InetAddressType.instance),</span>
<span class="fc" id="L102">        INT         (Int32Type.instance),</span>
<span class="fc" id="L103">        SMALLINT    (ShortType.instance),</span>
<span class="fc" id="L104">        TEXT        (UTF8Type.instance),</span>
<span class="fc" id="L105">        TIME        (TimeType.instance),</span>
<span class="fc" id="L106">        TIMESTAMP   (TimestampType.instance),</span>
<span class="fc" id="L107">        TIMEUUID    (TimeUUIDType.instance),</span>
<span class="fc" id="L108">        TINYINT     (ByteType.instance),</span>
<span class="fc" id="L109">        UUID        (UUIDType.instance),</span>
<span class="fc" id="L110">        VARCHAR     (UTF8Type.instance),</span>
<span class="fc" id="L111">        VARINT      (IntegerType.instance);</span>

        private final AbstractType&lt;?&gt; type;

        Native(AbstractType&lt;?&gt; type)
<span class="fc" id="L116">        {</span>
<span class="fc" id="L117">            this.type = type;</span>
<span class="fc" id="L118">        }</span>

        public AbstractType&lt;?&gt; getType()
        {
<span class="fc" id="L122">            return type;</span>
        }

        /**
         * Delegate to
         * {@link org.apache.cassandra.serializers.TypeSerializer#toCQLLiteral(ByteBuffer)}
         * for native types as most CQL literal representations work fine with the default
         * {@link org.apache.cassandra.serializers.TypeSerializer#toString(Object)}
         * {@link org.apache.cassandra.serializers.TypeSerializer#deserialize(ByteBuffer)} implementations.
         */
        public String toCQLLiteral(ByteBuffer buffer)
        {
<span class="fc" id="L134">            return type.getSerializer().toCQLLiteral(buffer);</span>
        }

        @Override
        public String toString()
        {
<span class="fc" id="L140">            return super.toString().toLowerCase();</span>
        }
    }

    public static class Custom implements CQL3Type
    {
        private final AbstractType&lt;?&gt; type;

        public Custom(AbstractType&lt;?&gt; type)
<span class="fc" id="L149">        {</span>
<span class="fc" id="L150">            this.type = type;</span>
<span class="fc" id="L151">        }</span>

        public Custom(String className) throws SyntaxException, ConfigurationException
        {
<span class="fc" id="L155">            this(TypeParser.parse(className));</span>
<span class="fc" id="L156">        }</span>

        public AbstractType&lt;?&gt; getType()
        {
<span class="fc" id="L160">            return type;</span>
        }

        @Override
        public String toCQLLiteral(ByteBuffer buffer)
        {
            // *always* use the 'blob' syntax to express custom types in CQL
<span class="fc" id="L167">            return Native.BLOB.toCQLLiteral(buffer);</span>
        }

        @Override
        public final boolean equals(Object o)
        {
<span class="nc bnc" id="L173" title="All 2 branches missed.">            if(!(o instanceof Custom))</span>
<span class="nc" id="L174">                return false;</span>

<span class="nc" id="L176">            Custom that = (Custom)o;</span>
<span class="nc" id="L177">            return type.equals(that.type);</span>
        }

        @Override
        public final int hashCode()
        {
<span class="nc" id="L183">            return type.hashCode();</span>
        }

        @Override
        public String toString()
        {
<span class="fc" id="L189">            return &quot;'&quot; + type + '\'';</span>
        }
    }

    public static class Collection implements CQL3Type
    {
        private final CollectionType&lt;?&gt; type;

        public Collection(CollectionType&lt;?&gt; type)
<span class="fc" id="L198">        {</span>
<span class="fc" id="L199">            this.type = type;</span>
<span class="fc" id="L200">        }</span>

        public CollectionType&lt;?&gt; getType()
        {
<span class="fc" id="L204">            return type;</span>
        }

        public boolean isCollection()
        {
<span class="nc" id="L209">            return true;</span>
        }

        @Override
        public String toCQLLiteral(ByteBuffer buffer)
        {
<span class="fc bfc" id="L215" title="All 2 branches covered.">            if (buffer == null)</span>
<span class="fc" id="L216">                return &quot;null&quot;;</span>

<span class="fc" id="L218">            StringBuilder target = new StringBuilder();</span>
<span class="fc" id="L219">            buffer = buffer.duplicate();</span>
<span class="fc" id="L220">            int size = CollectionSerializer.readCollectionSize(buffer, ByteBufferAccessor.instance);</span>
<span class="fc" id="L221">            buffer.position(buffer.position() + CollectionSerializer.sizeOfCollectionSize());</span>

<span class="pc bpc" id="L223" title="1 of 4 branches missed.">            switch (type.kind)</span>
            {
                case LIST:
<span class="fc" id="L226">                    CQL3Type elements = ((ListType&lt;?&gt;) type).getElementsType().asCQL3Type();</span>
<span class="fc" id="L227">                    target.append('[');</span>
<span class="fc" id="L228">                    generateSetOrListCQLLiteral(buffer, target, size, elements);</span>
<span class="fc" id="L229">                    target.append(']');</span>
<span class="fc" id="L230">                    break;</span>
                case SET:
<span class="fc" id="L232">                    elements = ((SetType&lt;?&gt;) type).getElementsType().asCQL3Type();</span>
<span class="fc" id="L233">                    target.append('{');</span>
<span class="fc" id="L234">                    generateSetOrListCQLLiteral(buffer, target, size, elements);</span>
<span class="fc" id="L235">                    target.append('}');</span>
<span class="fc" id="L236">                    break;</span>
                case MAP:
<span class="fc" id="L238">                    target.append('{');</span>
<span class="fc" id="L239">                    generateMapCQLLiteral(buffer, target, size);</span>
<span class="fc" id="L240">                    target.append('}');</span>
                    break;
            }
<span class="fc" id="L243">            return target.toString();</span>
        }

        private void generateMapCQLLiteral(ByteBuffer buffer, StringBuilder target, int size)
        {
<span class="fc" id="L248">            CQL3Type keys = ((MapType&lt;?, ?&gt;) type).getKeysType().asCQL3Type();</span>
<span class="fc" id="L249">            CQL3Type values = ((MapType&lt;?, ?&gt;) type).getValuesType().asCQL3Type();</span>
<span class="fc" id="L250">            int offset = 0;</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++)</span>
            {
<span class="fc bfc" id="L253" title="All 2 branches covered.">                if (i &gt; 0)</span>
<span class="fc" id="L254">                    target.append(&quot;, &quot;);</span>
<span class="fc" id="L255">                ByteBuffer element = CollectionSerializer.readValue(buffer, ByteBufferAccessor.instance, offset);</span>
<span class="fc" id="L256">                offset += CollectionSerializer.sizeOfValue(element, ByteBufferAccessor.instance);</span>
<span class="fc" id="L257">                target.append(keys.toCQLLiteral(element));</span>
<span class="fc" id="L258">                target.append(&quot;: &quot;);</span>
<span class="fc" id="L259">                element = CollectionSerializer.readValue(buffer, ByteBufferAccessor.instance, offset);</span>
<span class="fc" id="L260">                offset += CollectionSerializer.sizeOfValue(element, ByteBufferAccessor.instance);</span>
<span class="fc" id="L261">                target.append(values.toCQLLiteral(element));</span>
            }
<span class="fc" id="L263">        }</span>

        private static void generateSetOrListCQLLiteral(ByteBuffer buffer, StringBuilder target, int size, CQL3Type elements)
        {
<span class="fc" id="L267">            int offset = 0;</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++)</span>
            {
<span class="fc bfc" id="L270" title="All 2 branches covered.">                if (i &gt; 0)</span>
<span class="fc" id="L271">                    target.append(&quot;, &quot;);</span>
<span class="fc" id="L272">                ByteBuffer element = CollectionSerializer.readValue(buffer, ByteBufferAccessor.instance, offset);</span>
<span class="fc" id="L273">                offset += CollectionSerializer.sizeOfValue(element, ByteBufferAccessor.instance);</span>
<span class="fc" id="L274">                target.append(elements.toCQLLiteral(element));</span>
            }
<span class="fc" id="L276">        }</span>

        @Override
        public final boolean equals(Object o)
        {
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">            if(!(o instanceof Collection))</span>
<span class="nc" id="L282">                return false;</span>

<span class="fc" id="L284">            Collection that = (Collection)o;</span>
<span class="fc" id="L285">            return type.equals(that.type);</span>
        }

        @Override
        public final int hashCode()
        {
<span class="fc" id="L291">            return type.hashCode();</span>
        }

        @Override
        public String toString()
        {
<span class="fc bfc" id="L297" title="All 2 branches covered.">            boolean isFrozen = !this.type.isMultiCell();</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">            StringBuilder sb = new StringBuilder(isFrozen ? &quot;frozen&lt;&quot; : &quot;&quot;);</span>
<span class="pc bpc" id="L299" title="1 of 4 branches missed.">            switch (type.kind)</span>
            {
                case LIST:
<span class="fc" id="L302">                    AbstractType&lt;?&gt; listType = ((ListType&lt;?&gt;) type).getElementsType();</span>
<span class="fc" id="L303">                    sb.append(&quot;list&lt;&quot;).append(listType.asCQL3Type());</span>
<span class="fc" id="L304">                    break;</span>
                case SET:
<span class="fc" id="L306">                    AbstractType&lt;?&gt; setType = ((SetType&lt;?&gt;) type).getElementsType();</span>
<span class="fc" id="L307">                    sb.append(&quot;set&lt;&quot;).append(setType.asCQL3Type());</span>
<span class="fc" id="L308">                    break;</span>
                case MAP:
<span class="fc" id="L310">                    AbstractType&lt;?&gt; keysType = ((MapType&lt;?, ?&gt;) type).getKeysType();</span>
<span class="fc" id="L311">                    AbstractType&lt;?&gt; valuesType = ((MapType&lt;?, ?&gt;) type).getValuesType();</span>
<span class="fc" id="L312">                    sb.append(&quot;map&lt;&quot;).append(keysType.asCQL3Type()).append(&quot;, &quot;).append(valuesType.asCQL3Type());</span>
<span class="fc" id="L313">                    break;</span>
                default:
<span class="nc" id="L315">                    throw new AssertionError();</span>
            }
<span class="fc" id="L317">            sb.append('&gt;');</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">            if (isFrozen)</span>
<span class="fc" id="L319">                sb.append('&gt;');</span>
<span class="fc" id="L320">            return sb.toString();</span>
        }
    }

    public static class UserDefined implements CQL3Type
    {
        // Keeping this separatly from type just to simplify toString()
        private final String name;
        private final UserType type;

        private UserDefined(String name, UserType type)
<span class="fc" id="L331">        {</span>
<span class="fc" id="L332">            this.name = name;</span>
<span class="fc" id="L333">            this.type = type;</span>
<span class="fc" id="L334">        }</span>

        public static UserDefined create(UserType type)
        {
<span class="fc" id="L338">            return new UserDefined(UTF8Type.instance.compose(type.name), type);</span>
        }

        public boolean isUDT()
        {
<span class="nc" id="L343">            return true;</span>
        }

        public AbstractType&lt;?&gt; getType()
        {
<span class="fc" id="L348">            return type;</span>
        }

        @Override
        public String toCQLLiteral(ByteBuffer buffer)
        {
<span class="fc bfc" id="L354" title="All 2 branches covered.">            if (buffer == null)</span>
<span class="fc" id="L355">                return &quot;null&quot;;</span>


<span class="fc" id="L358">            StringBuilder target = new StringBuilder();</span>
<span class="fc" id="L359">            buffer = buffer.duplicate();</span>
<span class="fc" id="L360">            target.append('{');</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">            for (int i = 0; i &lt; type.size(); i++)</span>
            {
                // we allow the input to have less fields than declared so as to support field addition.
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">                if (!buffer.hasRemaining())</span>
<span class="nc" id="L365">                    break;</span>

<span class="pc bpc" id="L367" title="1 of 2 branches missed.">                if (buffer.remaining() &lt; 4)</span>
<span class="nc" id="L368">                    throw new MarshalException(String.format(&quot;Not enough bytes to read size of %dth field %s&quot;, i, type.fieldName(i)));</span>

<span class="fc" id="L370">                int size = buffer.getInt();</span>

<span class="fc bfc" id="L372" title="All 2 branches covered.">                if (i &gt; 0)</span>
<span class="fc" id="L373">                    target.append(&quot;, &quot;);</span>

<span class="fc" id="L375">                target.append(ColumnIdentifier.maybeQuote(type.fieldNameAsString(i)));</span>
<span class="fc" id="L376">                target.append(&quot;: &quot;);</span>

                // size &lt; 0 means null value
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">                if (size &lt; 0)</span>
                {
<span class="nc" id="L381">                    target.append(&quot;null&quot;);</span>
<span class="nc" id="L382">                    continue;</span>
                }

<span class="pc bpc" id="L385" title="1 of 2 branches missed.">                if (buffer.remaining() &lt; size)</span>
<span class="nc" id="L386">                    throw new MarshalException(String.format(&quot;Not enough bytes to read %dth field %s&quot;, i, type.fieldName(i)));</span>

<span class="fc" id="L388">                ByteBuffer field = ByteBufferUtil.readBytes(buffer, size);</span>
<span class="fc" id="L389">                target.append(type.fieldType(i).asCQL3Type().toCQLLiteral(field));</span>
            }
<span class="fc" id="L391">            target.append('}');</span>
<span class="fc" id="L392">            return target.toString();</span>
        }

        @Override
        public final boolean equals(Object o)
        {
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">            if(!(o instanceof UserDefined))</span>
<span class="nc" id="L399">                return false;</span>

<span class="fc" id="L401">            UserDefined that = (UserDefined)o;</span>
<span class="fc" id="L402">            return type.equals(that.type);</span>
        }

        @Override
        public final int hashCode()
        {
<span class="fc" id="L408">            return type.hashCode();</span>
        }

        @Override
        public String toString()
        {
<span class="fc bfc" id="L414" title="All 2 branches covered.">            if (type.isMultiCell())</span>
<span class="fc" id="L415">                return ColumnIdentifier.maybeQuote(name);</span>
            else
<span class="fc" id="L417">                return &quot;frozen&lt;&quot; + ColumnIdentifier.maybeQuote(name) + '&gt;';</span>
        }
    }

    public static class Tuple implements CQL3Type
    {
        private final TupleType type;

        private Tuple(TupleType type)
<span class="fc" id="L426">        {</span>
<span class="fc" id="L427">            this.type = type;</span>
<span class="fc" id="L428">        }</span>

        public static Tuple create(TupleType type)
        {
<span class="fc" id="L432">            return new Tuple(type);</span>
        }

        public TupleType getType()
        {
<span class="fc" id="L437">            return type;</span>
        }

        public String toCQLLiteral(ByteBuffer buffer)
        {
<span class="fc bfc" id="L442" title="All 2 branches covered.">            if (buffer == null)</span>
<span class="fc" id="L443">                return &quot;null&quot;;</span>

<span class="fc" id="L445">            StringBuilder target = new StringBuilder();</span>
<span class="fc" id="L446">            buffer = buffer.duplicate();</span>
<span class="fc" id="L447">            target.append('(');</span>
<span class="fc" id="L448">            boolean first = true;</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">            for (int i = 0; i &lt; type.size(); i++)</span>
            {
                // we allow the input to have less fields than declared so as to support field addition.
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">                if (!buffer.hasRemaining())</span>
<span class="nc" id="L453">                    break;</span>

<span class="pc bpc" id="L455" title="1 of 2 branches missed.">                if (buffer.remaining() &lt; 4)</span>
<span class="nc" id="L456">                    throw new MarshalException(String.format(&quot;Not enough bytes to read size of %dth component&quot;, i));</span>

<span class="fc" id="L458">                int size = buffer.getInt();</span>

<span class="fc bfc" id="L460" title="All 2 branches covered.">                if (first)</span>
<span class="fc" id="L461">                    first = false;</span>
                else
<span class="fc" id="L463">                    target.append(&quot;, &quot;);</span>

                // size &lt; 0 means null value
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">                if (size &lt; 0)</span>
                {
<span class="nc" id="L468">                    target.append(&quot;null&quot;);</span>
<span class="nc" id="L469">                    continue;</span>
                }

<span class="pc bpc" id="L472" title="1 of 2 branches missed.">                if (buffer.remaining() &lt; size)</span>
<span class="nc" id="L473">                    throw new MarshalException(String.format(&quot;Not enough bytes to read %dth component&quot;, i));</span>

<span class="fc" id="L475">                ByteBuffer field = ByteBufferUtil.readBytes(buffer, size);</span>
<span class="fc" id="L476">                target.append(type.type(i).asCQL3Type().toCQLLiteral(field));</span>
            }
<span class="fc" id="L478">            target.append(')');</span>
<span class="fc" id="L479">            return target.toString();</span>
        }

        @Override
        public final boolean equals(Object o)
        {
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">            if(!(o instanceof Tuple))</span>
<span class="nc" id="L486">                return false;</span>

<span class="fc" id="L488">            Tuple that = (Tuple)o;</span>
<span class="fc" id="L489">            return type.equals(that.type);</span>
        }

        @Override
        public final int hashCode()
        {
<span class="fc" id="L495">            return type.hashCode();</span>
        }

        @Override
        public String toString()
        {
<span class="fc" id="L501">            return toString(true);</span>
        }

        public String toString(boolean withFrozen)
        {
<span class="fc" id="L506">            StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">            if (withFrozen)</span>
<span class="fc" id="L508">                sb.append(&quot;frozen&lt;&quot;);</span>
<span class="fc" id="L509">            sb.append(&quot;tuple&lt;&quot;);</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">            for (int i = 0; i &lt; type.size(); i++)</span>
            {
<span class="fc bfc" id="L512" title="All 2 branches covered.">                if (i &gt; 0)</span>
<span class="fc" id="L513">                    sb.append(&quot;, &quot;);</span>
<span class="fc" id="L514">                sb.append(type.type(i).asCQL3Type());</span>
            }
<span class="fc" id="L516">            sb.append('&gt;');</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">            if (withFrozen)</span>
<span class="fc" id="L518">                sb.append('&gt;');</span>

<span class="fc" id="L520">            return sb.toString();</span>
        }
    }

    public static class Vector implements CQL3Type
    {
        private final VectorType&lt;?&gt; type;

        public Vector(VectorType&lt;?&gt; type)
<span class="fc" id="L529">        {</span>
<span class="fc" id="L530">            this.type = type;</span>
<span class="fc" id="L531">        }</span>

        public Vector(AbstractType&lt;?&gt; elementType, int dimensions)
<span class="fc" id="L534">        {</span>
<span class="fc" id="L535">            this.type = VectorType.getInstance(elementType, dimensions);</span>
<span class="fc" id="L536">        }</span>

        public boolean isVector()
        {
<span class="nc" id="L540">            return true;</span>
        }

        @Override
        public VectorType&lt;?&gt; getType()
        {
<span class="fc" id="L546">            return type;</span>
        }

        @Override
        public String toCQLLiteral(ByteBuffer buffer)
        {
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">            if (type.isNull(buffer))</span>
<span class="nc" id="L553">                return &quot;null&quot;;</span>
<span class="fc" id="L554">            buffer = buffer.duplicate();</span>
<span class="fc" id="L555">            CQL3Type elementType = type.elementType.asCQL3Type();</span>
<span class="fc" id="L556">            List&lt;ByteBuffer&gt; values = getType().split(buffer);</span>
<span class="fc" id="L557">            StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L558">            sb.append('[');</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">            for (int i = 0; i &lt; values.size(); i++)</span>
            {
<span class="fc bfc" id="L561" title="All 2 branches covered.">                if (i &gt; 0)</span>
<span class="fc" id="L562">                    sb.append(&quot;, &quot;);</span>
<span class="fc" id="L563">                sb.append(elementType.toCQLLiteral(values.get(i)));</span>
            }
<span class="fc" id="L565">            sb.append(']');</span>
<span class="fc" id="L566">            return sb.toString();</span>
        }

        @Override
        public String toString()
        {
<span class="fc" id="L572">            StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L573">            sb.append(&quot;vector&lt;&quot;).append(type.elementType.asCQL3Type()).append(&quot;, &quot;).append(type.dimension).append('&gt;');</span>
<span class="fc" id="L574">            return sb.toString();</span>
        }
    }

    // For UserTypes, we need to know the current keyspace to resolve the
    // actual type used, so Raw is a &quot;not yet prepared&quot; CQL3Type.
    public abstract class Raw
    {
        protected final boolean frozen;

        protected Raw(boolean frozen)
<span class="fc" id="L585">        {</span>
<span class="fc" id="L586">            this.frozen = frozen;</span>
<span class="fc" id="L587">        }</span>

        public abstract boolean supportsFreezing();

        public boolean isFrozen()
        {
<span class="fc" id="L593">            return this.frozen;</span>
        }

        public boolean isDuration()
        {
<span class="fc" id="L598">            return false;</span>
        }

        public boolean isCounter()
        {
<span class="fc" id="L603">            return false;</span>
        }

        public boolean isUDT()
        {
<span class="fc" id="L608">            return false;</span>
        }

        public boolean isTuple()
        {
<span class="fc" id="L613">            return false;</span>
        }

        public boolean isImplicitlyFrozen()
        {
<span class="fc bfc" id="L618" title="All 4 branches covered.">            return isTuple() || isVector();</span>
        }

        public boolean isVector()
        {
<span class="fc" id="L623">            return false;</span>
        }

        public String keyspace()
        {
<span class="nc" id="L628">            return null;</span>
        }

        public Raw freeze()
        {
<span class="fc" id="L633">            String message = String.format(&quot;frozen&lt;&gt; is only allowed on collections, tuples, and user-defined types (got %s)&quot;, this);</span>
<span class="fc" id="L634">            throw new InvalidRequestException(message);</span>
        }

        public abstract void validate(ClientState state, String name);

        public CQL3Type prepare(String keyspace)
        {
<span class="fc" id="L641">            KeyspaceMetadata ksm = Schema.instance.getKeyspaceMetadata(keyspace);</span>
<span class="pc bpc" id="L642" title="1 of 2 branches missed.">            if (ksm == null)</span>
<span class="nc" id="L643">                throw new ConfigurationException(String.format(&quot;Keyspace %s doesn't exist&quot;, keyspace));</span>
<span class="fc" id="L644">            return prepare(keyspace, ksm.types);</span>
        }

        public abstract CQL3Type prepare(String keyspace, Types udts) throws InvalidRequestException;

        public CQL3Type prepareInternal(String keyspace, Types udts) throws InvalidRequestException
        {
<span class="fc" id="L651">            return prepare(keyspace, udts);</span>
        }

        public boolean referencesUserType(String name)
        {
<span class="fc" id="L656">            return false;</span>
        }

        public static Raw from(CQL3Type type)
        {
<span class="fc" id="L661">            return new RawType(type, false);</span>
        }

        public static Raw userType(UTName name)
        {
<span class="fc" id="L666">            return new RawUT(name, false);</span>
        }

        public static Raw map(CQL3Type.Raw t1, CQL3Type.Raw t2)
        {
<span class="fc" id="L671">            return new RawCollection(CollectionType.Kind.MAP, t1, t2, false);</span>
        }

        public static Raw list(CQL3Type.Raw t)
        {
<span class="fc" id="L676">            return new RawCollection(CollectionType.Kind.LIST, null, t, false);</span>
        }

        public static Raw set(CQL3Type.Raw t)
        {
<span class="fc" id="L681">            return new RawCollection(CollectionType.Kind.SET, null, t, false);</span>
        }

        public static Raw tuple(List&lt;CQL3Type.Raw&gt; ts)
        {
<span class="fc" id="L686">            return new RawTuple(ts);</span>
        }

        public static Raw vector(CQL3Type.Raw t, int dimension)
        {
<span class="fc" id="L691">            return new RawVector(t, dimension);</span>
        }

        private static class RawType extends Raw
        {
            private final CQL3Type type;

            private RawType(CQL3Type type, boolean frozen)
            {
<span class="fc" id="L700">                super(frozen);</span>
<span class="fc" id="L701">                this.type = type;</span>
<span class="fc" id="L702">            }</span>

            @Override
            public void validate(ClientState state, String name)
            {
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">                if (type.isVector())</span>
                {
<span class="nc" id="L709">                    int dimensions = ((Vector) type).getType().dimension;</span>
<span class="nc" id="L710">                    Guardrails.vectorDimensions.guard(dimensions, name, false, state);</span>
                }
<span class="fc" id="L712">            }</span>

            public CQL3Type prepare(String keyspace, Types udts) throws InvalidRequestException
            {
<span class="fc" id="L716">                return type;</span>
            }

            public boolean supportsFreezing()
            {
<span class="fc" id="L721">                return false;</span>
            }

            public boolean isCounter()
            {
<span class="fc bfc" id="L726" title="All 2 branches covered.">                return type == Native.COUNTER;</span>
            }

            public boolean isDuration()
            {
<span class="fc bfc" id="L731" title="All 2 branches covered.">                return type == Native.DURATION;</span>
            }

            @Override
            public String toString()
            {
<span class="fc" id="L737">                return type.toString();</span>
            }
        }

<span class="fc" id="L741">        private static class RawCollection extends Raw</span>
        {
            private final CollectionType.Kind kind;
            private final CQL3Type.Raw keys;
            private final CQL3Type.Raw values;

            private RawCollection(CollectionType.Kind kind, CQL3Type.Raw keys, CQL3Type.Raw values, boolean frozen)
            {
<span class="fc" id="L749">                super(frozen);</span>
<span class="fc" id="L750">                this.kind = kind;</span>
<span class="fc" id="L751">                this.keys = keys;</span>
<span class="fc" id="L752">                this.values = values;</span>
<span class="fc" id="L753">            }</span>

            @Override
            public RawCollection freeze()
            {
                CQL3Type.Raw frozenKeys =
<span class="fc bfc" id="L759" title="All 4 branches covered.">                    null != keys &amp;&amp; keys.supportsFreezing()</span>
<span class="fc" id="L760">                  ? keys.freeze()</span>
<span class="fc" id="L761">                  : keys;</span>

                CQL3Type.Raw frozenValues =
<span class="pc bpc" id="L764" title="1 of 4 branches missed.">                    null != values &amp;&amp; values.supportsFreezing()</span>
<span class="fc" id="L765">                  ? values.freeze()</span>
<span class="fc" id="L766">                  : values;</span>

<span class="fc" id="L768">                return new RawCollection(kind, frozenKeys, frozenValues, true);</span>
            }

            public boolean supportsFreezing()
            {
<span class="fc" id="L773">                return true;</span>
            }

            public boolean isCollection()
            {
<span class="nc" id="L778">                return true;</span>
            }

            @Override
            public void validate(ClientState state, String name)
            {
<span class="fc bfc" id="L784" title="All 2 branches covered.">                if (keys != null)</span>
<span class="fc" id="L785">                    keys.validate(state, name);</span>

<span class="pc bpc" id="L787" title="1 of 2 branches missed.">                if (values != null)</span>
<span class="fc" id="L788">                    values.validate(state, name);</span>
<span class="fc" id="L789">            }</span>

            public CQL3Type prepare(String keyspace, Types udts) throws InvalidRequestException
            {
<span class="fc" id="L793">                return prepare(keyspace, udts, false);</span>
            }

            public CQL3Type prepareInternal(String keyspace, Types udts)
            {
<span class="fc" id="L798">                return prepare(keyspace, udts, true);</span>
            }

            public CQL3Type prepare(String keyspace, Types udts, boolean isInternal) throws InvalidRequestException
            {
<span class="pc bpc" id="L803" title="1 of 2 branches missed.">                assert values != null : &quot;Got null values type for a collection&quot;;</span>

<span class="fc bfc" id="L805" title="All 6 branches covered.">                if (!frozen &amp;&amp; values.supportsFreezing() &amp;&amp; !values.frozen)</span>
<span class="nc" id="L806">                    throwNestedNonFrozenError(values);</span>

                // we represent supercolumns as maps, internally, and we do allow counters in supercolumns. Thus,
                // for internal type parsing (think schema) we have to make an exception and allow counters as (map) values
<span class="pc bpc" id="L810" title="1 of 4 branches missed.">                if (values.isCounter() &amp;&amp; !isInternal)</span>
<span class="fc" id="L811">                    throw new InvalidRequestException(&quot;Counters are not allowed inside collections: &quot; + this);</span>

<span class="fc bfc" id="L813" title="All 4 branches covered.">                if (values.isDuration() &amp;&amp; kind == Kind.SET)</span>
<span class="fc" id="L814">                    throw new InvalidRequestException(&quot;Durations are not allowed inside sets: &quot; + this);</span>

<span class="fc bfc" id="L816" title="All 2 branches covered.">                if (keys != null)</span>
                {
<span class="pc bpc" id="L818" title="1 of 2 branches missed.">                    if (keys.isCounter())</span>
<span class="nc" id="L819">                        throw new InvalidRequestException(&quot;Counters are not allowed inside collections: &quot; + this);</span>
<span class="fc bfc" id="L820" title="All 2 branches covered.">                    if (keys.isDuration())</span>
<span class="fc" id="L821">                        throw new InvalidRequestException(&quot;Durations are not allowed as map keys: &quot; + this);</span>
<span class="fc bfc" id="L822" title="All 6 branches covered.">                    if (!frozen &amp;&amp; keys.supportsFreezing() &amp;&amp; !keys.frozen)</span>
<span class="nc" id="L823">                        throwNestedNonFrozenError(keys);</span>
                }

<span class="fc" id="L826">                AbstractType&lt;?&gt; valueType = values.prepare(keyspace, udts).getType();</span>
<span class="pc bpc" id="L827" title="1 of 4 branches missed.">                switch (kind)</span>
                {
                    case LIST:
<span class="fc bfc" id="L830" title="All 2 branches covered.">                        return new Collection(ListType.getInstance(valueType, !frozen));</span>
                    case SET:
<span class="fc bfc" id="L832" title="All 2 branches covered.">                        return new Collection(SetType.getInstance(valueType, !frozen));</span>
                    case MAP:
<span class="pc bpc" id="L834" title="1 of 2 branches missed.">                        assert keys != null : &quot;Got null keys type for a collection&quot;;</span>
<span class="fc bfc" id="L835" title="All 2 branches covered.">                        return new Collection(MapType.getInstance(keys.prepare(keyspace, udts).getType(), valueType, !frozen));</span>
                }
<span class="nc" id="L837">                throw new AssertionError();</span>
            }

            private void throwNestedNonFrozenError(Raw innerType)
            {
<span class="fc bfc" id="L842" title="All 2 branches covered.">                if (innerType instanceof RawCollection)</span>
<span class="fc" id="L843">                    throw new InvalidRequestException(&quot;Non-frozen collections are not allowed inside collections: &quot; + this);</span>
<span class="pc bpc" id="L844" title="1 of 2 branches missed.">                else if (innerType.isUDT())</span>
<span class="fc" id="L845">                    throw new InvalidRequestException(&quot;Non-frozen UDTs are not allowed inside collections: &quot; + this);</span>
<span class="nc" id="L846">            }</span>

            public boolean referencesUserType(String name)
            {
<span class="pc bpc" id="L850" title="1 of 6 branches missed.">                return (keys != null &amp;&amp; keys.referencesUserType(name)) || values.referencesUserType(name);</span>
            }

            @Override
            public String toString()
            {
<span class="fc bfc" id="L856" title="All 2 branches covered.">                String start = frozen? &quot;frozen&lt;&quot; : &quot;&quot;;</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">                String end = frozen ? &quot;&gt;&quot; : &quot;&quot;;</span>
<span class="pc bpc" id="L858" title="1 of 4 branches missed.">                switch (kind)</span>
                {
<span class="fc" id="L860">                    case LIST: return start + &quot;list&lt;&quot; + values + '&gt;' + end;</span>
<span class="fc" id="L861">                    case SET:  return start + &quot;set&lt;&quot; + values + '&gt;' + end;</span>
<span class="fc" id="L862">                    case MAP:  return start + &quot;map&lt;&quot; + keys + &quot;, &quot; + values + '&gt;' + end;</span>
                }
<span class="nc" id="L864">                throw new AssertionError();</span>
            }
        }

        private static class RawVector extends Raw
        {
            private final CQL3Type.Raw element;
            private final int dimension;

            private RawVector(Raw element, int dimension)
            {
<span class="fc" id="L875">                super(true);</span>
<span class="fc" id="L876">                this.element = element;</span>
<span class="fc" id="L877">                this.dimension = dimension;</span>
<span class="fc" id="L878">            }</span>

            @Override
            public boolean isVector()
            {
<span class="fc" id="L883">                return true;</span>
            }

            @Override
            public boolean supportsFreezing()
            {
<span class="fc" id="L889">                return true;</span>
            }

            @Override
            public Raw freeze()
            {
<span class="fc" id="L895">                return this;</span>
            }

            @Override
            public void validate(ClientState state, String name)
            {
<span class="fc" id="L901">                Guardrails.vectorDimensions.guard(dimension, name, false, state);</span>
<span class="fc" id="L902">            }</span>

            @Override
            public CQL3Type prepare(String keyspace, Types udts) throws InvalidRequestException
            {
<span class="fc" id="L907">                CQL3Type type = element.prepare(keyspace, udts);</span>
<span class="fc" id="L908">                return new Vector(type.getType(), dimension);</span>
            }

            @Override
            public String toString()
            {
<span class="fc" id="L914">                return &quot;vector&lt;&quot; + element.toString() + &quot;, &quot; + dimension + '&gt;';</span>
            }
        }

        private static class RawUT extends Raw
        {
            private final UTName name;

            private RawUT(UTName name, boolean frozen)
            {
<span class="fc" id="L924">                super(frozen);</span>
<span class="fc" id="L925">                this.name = name;</span>
<span class="fc" id="L926">            }</span>

            public String keyspace()
            {
<span class="nc" id="L930">                return name.getKeyspace();</span>
            }

            @Override
            public RawUT freeze()
            {
<span class="fc" id="L936">                return new RawUT(name, true);</span>
            }

            @Override
            public void validate(ClientState state, String name)
            {
                // nothing to do here
<span class="fc" id="L943">            }</span>

            public CQL3Type prepare(String keyspace, Types udts) throws InvalidRequestException
            {
<span class="fc bfc" id="L947" title="All 2 branches covered.">                if (name.hasKeyspace())</span>
                {
                    // The provided keyspace is the one of the current statement this is part of. If it's different from the keyspace of
                    // the UTName, we reject since we want to limit user types to their own keyspace (see #6643)
<span class="fc bfc" id="L951" title="All 2 branches covered.">                    if (!keyspace.equals(name.getKeyspace()))</span>
<span class="fc" id="L952">                        throw new InvalidRequestException(String.format(&quot;Statement on keyspace %s cannot refer to a user type in keyspace %s; &quot;</span>
                                                                        + &quot;user types can only be used in the keyspace they are defined in&quot;,
<span class="fc" id="L954">                                                                        keyspace, name.getKeyspace()));</span>
                }
                else
                {
<span class="fc" id="L958">                    name.setKeyspace(keyspace);</span>
                }

<span class="fc" id="L961">                UserType type = udts.getNullable(name.getUserTypeName());</span>
<span class="fc bfc" id="L962" title="All 2 branches covered.">                if (type == null)</span>
<span class="fc" id="L963">                    throw new InvalidRequestException(&quot;Unknown type &quot; + name);</span>

<span class="fc bfc" id="L965" title="All 2 branches covered.">                if (frozen)</span>
<span class="fc" id="L966">                    type = type.freeze();</span>
<span class="fc" id="L967">                return new UserDefined(name.toString(), type);</span>
            }

            public boolean referencesUserType(String name)
            {
<span class="fc" id="L972">                return this.name.getStringTypeName().equals(name);</span>
            }

            public boolean supportsFreezing()
            {
<span class="fc" id="L977">                return true;</span>
            }

            public boolean isUDT()
            {
<span class="fc" id="L982">                return true;</span>
            }

            @Override
            public String toString()
            {
<span class="fc bfc" id="L988" title="All 2 branches covered.">                if (frozen)</span>
<span class="fc" id="L989">                    return &quot;frozen&lt;&quot; + name.toString() + '&gt;';</span>
                else
<span class="fc" id="L991">                    return name.toString();</span>
            }
        }

        private static class RawTuple extends Raw
        {
            private final List&lt;CQL3Type.Raw&gt; types;

            private RawTuple(List&lt;CQL3Type.Raw&gt; types)
            {
<span class="fc" id="L1001">                super(true);</span>
<span class="fc" id="L1002">                this.types = types.stream()</span>
<span class="fc bfc" id="L1003" title="All 2 branches covered.">                                  .map(t -&gt; t.supportsFreezing() ? t.freeze() : t)</span>
<span class="fc" id="L1004">                                  .collect(toList());</span>
<span class="fc" id="L1005">            }</span>

            public boolean supportsFreezing()
            {
<span class="fc" id="L1009">                return true;</span>
            }

            @Override
            public RawTuple freeze()
            {
<span class="fc" id="L1015">                return this;</span>
            }

            @Override
            public void validate(ClientState state, String name)
            {
<span class="fc bfc" id="L1021" title="All 2 branches covered.">                for (CQL3Type.Raw t : types)</span>
<span class="fc" id="L1022">                    t.validate(state, name);</span>
<span class="fc" id="L1023">            }</span>

            public CQL3Type prepare(String keyspace, Types udts) throws InvalidRequestException
            {
<span class="fc" id="L1027">                List&lt;AbstractType&lt;?&gt;&gt; ts = new ArrayList&lt;&gt;(types.size());</span>
<span class="fc bfc" id="L1028" title="All 2 branches covered.">                for (CQL3Type.Raw t : types)</span>
                {
<span class="pc bpc" id="L1030" title="1 of 2 branches missed.">                    if (t.isCounter())</span>
<span class="nc" id="L1031">                        throw new InvalidRequestException(&quot;Counters are not allowed inside tuples&quot;);</span>

<span class="fc" id="L1033">                    ts.add(t.prepare(keyspace, udts).getType());</span>
<span class="fc" id="L1034">                }</span>
<span class="fc" id="L1035">                return new Tuple(new TupleType(ts));</span>
            }

            public boolean isTuple()
            {
<span class="fc" id="L1040">                return true;</span>
            }

            public boolean referencesUserType(String name)
            {
<span class="nc" id="L1045">                return types.stream().anyMatch(t -&gt; t.referencesUserType(name));</span>
            }

            @Override
            public String toString()
            {
<span class="fc" id="L1051">                StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L1052">                sb.append(&quot;tuple&lt;&quot;);</span>
<span class="fc bfc" id="L1053" title="All 2 branches covered.">                for (int i = 0; i &lt; types.size(); i++)</span>
                {
<span class="fc bfc" id="L1055" title="All 2 branches covered.">                    if (i &gt; 0)</span>
<span class="fc" id="L1056">                        sb.append(&quot;, &quot;);</span>
<span class="fc" id="L1057">                    sb.append(types.get(i));</span>
                }
<span class="fc" id="L1059">                sb.append('&gt;');</span>
<span class="fc" id="L1060">                return sb.toString();</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>