<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InboundMessageHandler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.net</a> &gt; <span class="el_source">InboundMessageHandler.java</span></div><h1>InboundMessageHandler.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.net;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;
import org.apache.cassandra.concurrent.ExecutorLocals;
import org.apache.cassandra.concurrent.Stage;
import org.apache.cassandra.exceptions.IncompatibleSchemaException;
import org.apache.cassandra.io.util.DataInputBuffer;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.net.Message.Header;
import org.apache.cassandra.net.FrameDecoder.IntactFrame;
import org.apache.cassandra.net.FrameDecoder.CorruptFrame;
import org.apache.cassandra.net.ResourceLimits.Limit;
import org.apache.cassandra.tracing.TraceState;
import org.apache.cassandra.tracing.Tracing;
import org.apache.cassandra.utils.JVMStabilityInspector;
import org.apache.cassandra.utils.NoSpamLogger;

import static java.util.concurrent.TimeUnit.NANOSECONDS;
import static org.apache.cassandra.utils.MonotonicClock.Global.approxTime;

/**
 * Implementation of {@link AbstractMessageHandler} for processing internode messages from peers.
 *
 * # Small vs large messages
 * Small messages are deserialized in place, and then handed off to an appropriate
 * thread pool for processing. Large messages accumulate frames until completion of a message, then hand off
 * the untouched frames to the correct thread pool for the verb to be deserialized there and immediately processed.
 *
 * # Flow control (backpressure)
 *
 * To prevent nodes from overwhelming and bringing each other to the knees with more inbound messages that
 * can be processed in a timely manner, {@link InboundMessageHandler} implements a strict flow control policy.
 * The size of the incoming message is dependent on the messaging version of the specific peer connection. See
 * {@link Message.Serializer#inferMessageSize(ByteBuffer, int, int, int)}.
 *
 * By default, every connection has 4MiB of exlusive permits available before needing to access the per-endpoint
 * and global reserves.
 *
 * Permits are released after the verb handler has been invoked on the {@link Stage} for the {@link Verb} of the message.
 */
public class InboundMessageHandler extends AbstractMessageHandler
{
<span class="fc" id="L70">    private static final Logger logger = LoggerFactory.getLogger(InboundMessageHandler.class);</span>
<span class="fc" id="L71">    private static final NoSpamLogger noSpamLogger = NoSpamLogger.getLogger(logger, 1L, TimeUnit.SECONDS);</span>

<span class="fc" id="L73">    private static final Message.Serializer serializer = Message.serializer;</span>

    private final ConnectionType type;
    private final InetAddressAndPort self;
    private final InetAddressAndPort peer;
    private final int version;

    private final InboundMessageCallbacks callbacks;
    private final Consumer&lt;Message&lt;?&gt;&gt; consumer;

    InboundMessageHandler(FrameDecoder decoder,

                          ConnectionType type,
                          Channel channel,
                          InetAddressAndPort self,
                          InetAddressAndPort peer,
                          int version,
                          int largeThreshold,

                          long queueCapacity,
                          Limit endpointReserveCapacity,
                          Limit globalReserveCapacity,
                          WaitQueue endpointWaitQueue,
                          WaitQueue globalWaitQueue,

                          OnHandlerClosed onClosed,
                          InboundMessageCallbacks callbacks,
                          Consumer&lt;Message&lt;?&gt;&gt; consumer)
    {
<span class="fc" id="L102">        super(decoder,</span>
              channel,
              largeThreshold,
              queueCapacity,
              endpointReserveCapacity,
              globalReserveCapacity,
              endpointWaitQueue,
              globalWaitQueue,
              onClosed);


<span class="fc" id="L113">        this.type = type;</span>
<span class="fc" id="L114">        this.self = self;</span>
<span class="fc" id="L115">        this.peer = peer;</span>
<span class="fc" id="L116">        this.version = version;</span>
<span class="fc" id="L117">        this.callbacks = callbacks;</span>
<span class="fc" id="L118">        this.consumer = consumer;</span>
<span class="fc" id="L119">    }</span>

    protected boolean processOneContainedMessage(ShareableBytes bytes, Limit endpointReserve, Limit globalReserve) throws IOException
    {
<span class="fc" id="L123">        ByteBuffer buf = bytes.get();</span>

<span class="fc" id="L125">        long currentTimeNanos = approxTime.now();</span>
<span class="fc" id="L126">        Header header = serializer.extractHeader(buf, peer, currentTimeNanos, version);</span>
<span class="fc" id="L127">        long timeElapsed = currentTimeNanos - header.createdAtNanos;</span>
<span class="fc" id="L128">        int size = serializer.inferMessageSize(buf, buf.position(), buf.limit());</span>

<span class="fc bfc" id="L130" title="All 2 branches covered.">        if (approxTime.isAfter(currentTimeNanos, header.expiresAtNanos))</span>
        {
<span class="fc" id="L132">            callbacks.onHeaderArrived(size, header, timeElapsed, NANOSECONDS);</span>
<span class="fc" id="L133">            callbacks.onArrivedExpired(size, header, false, timeElapsed, NANOSECONDS);</span>
<span class="fc" id="L134">            receivedCount++;</span>
<span class="fc" id="L135">            receivedBytes += size;</span>
<span class="fc" id="L136">            bytes.skipBytes(size);</span>
<span class="fc" id="L137">            return true;</span>
        }

<span class="pc bpc" id="L140" title="1 of 2 branches missed.">        if (!acquireCapacity(endpointReserve, globalReserve, size, currentTimeNanos, header.expiresAtNanos))</span>
<span class="nc" id="L141">            return false;</span>

<span class="fc" id="L143">        callbacks.onHeaderArrived(size, header, timeElapsed, NANOSECONDS);</span>
<span class="fc" id="L144">        callbacks.onArrived(size, header, timeElapsed, NANOSECONDS);</span>
<span class="fc" id="L145">        receivedCount++;</span>
<span class="fc" id="L146">        receivedBytes += size;</span>

<span class="fc bfc" id="L148" title="All 2 branches covered.">        if (size &lt;= largeThreshold)</span>
<span class="fc" id="L149">            processSmallMessage(bytes, size, header);</span>
        else
<span class="fc" id="L151">            processLargeMessage(bytes, size, header);</span>

<span class="fc" id="L153">        return true;</span>
    }

    private void processSmallMessage(ShareableBytes bytes, int size, Header header)
    {
<span class="fc" id="L158">        ByteBuffer buf = bytes.get();</span>
<span class="fc" id="L159">        final int begin = buf.position();</span>
<span class="fc" id="L160">        final int end = buf.limit();</span>
<span class="fc" id="L161">        buf.limit(begin + size); // cap to expected message size</span>

<span class="fc" id="L163">        Message&lt;?&gt; message = null;</span>
<span class="fc" id="L164">        try (DataInputBuffer in = new DataInputBuffer(buf, false))</span>
        {
<span class="fc" id="L166">            Message&lt;?&gt; m = serializer.deserialize(in, header, version);</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">            if (in.available() &gt; 0) // bytes remaining after deser: deserializer is busted</span>
<span class="nc" id="L168">                throw new InvalidSerializedSizeException(header.verb, size, size - in.available());</span>
<span class="fc" id="L169">            message = m;</span>
        }
<span class="fc" id="L171">        catch (IncompatibleSchemaException e)</span>
        {
<span class="fc" id="L173">            callbacks.onFailedDeserialize(size, header, e);</span>
<span class="fc" id="L174">            noSpamLogger.info(&quot;{} incompatible schema encountered while deserializing a message&quot;, this, e);</span>
        }
<span class="nc" id="L176">        catch (Throwable t)</span>
        {
<span class="nc" id="L178">            JVMStabilityInspector.inspectThrowable(t);</span>
<span class="nc" id="L179">            callbacks.onFailedDeserialize(size, header, t);</span>
<span class="nc" id="L180">            logger.error(&quot;{} unexpected exception caught while deserializing a message&quot;, id(), t);</span>
        }
        finally
        {
<span class="fc bfc" id="L184" title="All 2 branches covered.">            if (null == message)</span>
<span class="fc" id="L185">                releaseCapacity(size);</span>

            // no matter what, set position to the beginning of the next message and restore limit, so that
            // we can always keep on decoding the frame even on failure to deserialize previous message
<span class="fc" id="L189">            buf.position(begin + size);</span>
<span class="fc" id="L190">            buf.limit(end);</span>
        }

<span class="fc bfc" id="L193" title="All 2 branches covered.">        if (null != message)</span>
<span class="fc" id="L194">            dispatch(new ProcessSmallMessage(message, size));</span>
<span class="fc" id="L195">    }</span>

    // for various reasons, it's possible for a large message to be contained in a single frame
    private void processLargeMessage(ShareableBytes bytes, int size, Header header)
    {
<span class="fc" id="L200">        new LargeMessage(size, header, bytes.sliceAndConsume(size).share()).schedule();</span>
<span class="fc" id="L201">    }</span>

    /*
     * Handling of multi-frame large messages
     */

    protected boolean processFirstFrameOfLargeMessage(IntactFrame frame, Limit endpointReserve, Limit globalReserve) throws IOException
    {
<span class="fc" id="L209">        ShareableBytes bytes = frame.contents;</span>
<span class="fc" id="L210">        ByteBuffer buf = bytes.get();</span>

<span class="fc" id="L212">        long currentTimeNanos = approxTime.now();</span>
<span class="fc" id="L213">        Header header = serializer.extractHeader(buf, peer, currentTimeNanos, version);</span>
<span class="fc" id="L214">        int size = serializer.inferMessageSize(buf, buf.position(), buf.limit());</span>

<span class="fc" id="L216">        boolean expired = approxTime.isAfter(currentTimeNanos, header.expiresAtNanos);</span>
<span class="pc bpc" id="L217" title="2 of 4 branches missed.">        if (!expired &amp;&amp; !acquireCapacity(endpointReserve, globalReserve, size, currentTimeNanos, header.expiresAtNanos))</span>
<span class="nc" id="L218">            return false;</span>

<span class="fc" id="L220">        callbacks.onHeaderArrived(size, header, currentTimeNanos - header.createdAtNanos, NANOSECONDS);</span>
<span class="fc" id="L221">        receivedBytes += buf.remaining();</span>
<span class="fc" id="L222">        largeMessage = new LargeMessage(size, header, expired);</span>
<span class="fc" id="L223">        largeMessage.supply(frame);</span>
<span class="fc" id="L224">        return true;</span>
    }

    protected void processCorruptFrame(CorruptFrame frame) throws Crc.InvalidCrc
    {
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        if (!frame.isRecoverable())</span>
        {
<span class="fc" id="L231">            corruptFramesUnrecovered++;</span>
<span class="fc" id="L232">            throw new Crc.InvalidCrc(frame.readCRC, frame.computedCRC);</span>
        }
<span class="nc bnc" id="L234" title="All 2 branches missed.">        else if (frame.isSelfContained)</span>
        {
<span class="nc" id="L236">            receivedBytes += frame.frameSize;</span>
<span class="nc" id="L237">            corruptFramesRecovered++;</span>
<span class="nc" id="L238">            noSpamLogger.warn(&quot;{} invalid, recoverable CRC mismatch detected while reading messages (corrupted self-contained frame)&quot;, id());</span>
        }
<span class="nc bnc" id="L240" title="All 2 branches missed.">        else if (null == largeMessage) // first frame of a large message</span>
        {
<span class="nc" id="L242">            receivedBytes += frame.frameSize;</span>
<span class="nc" id="L243">            corruptFramesUnrecovered++;</span>
<span class="nc" id="L244">            noSpamLogger.error(&quot;{} invalid, unrecoverable CRC mismatch detected while reading messages (corrupted first frame of a large message)&quot;, id());</span>
<span class="nc" id="L245">            throw new Crc.InvalidCrc(frame.readCRC, frame.computedCRC);</span>
        }
        else // subsequent frame of a large message
        {
<span class="nc" id="L249">            processSubsequentFrameOfLargeMessage(frame);</span>
<span class="nc" id="L250">            corruptFramesRecovered++;</span>
<span class="nc" id="L251">            noSpamLogger.warn(&quot;{} invalid, recoverable CRC mismatch detected while reading a large message&quot;, id());</span>
        }
<span class="nc" id="L253">    }</span>

    String id(boolean includeReal)
    {
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">        if (!includeReal)</span>
<span class="nc" id="L258">            return id();</span>

<span class="fc" id="L260">        return SocketFactory.channelId(peer, (InetSocketAddress) channel.remoteAddress(),</span>
<span class="fc" id="L261">                                       self, (InetSocketAddress) channel.localAddress(),</span>
<span class="fc" id="L262">                                       type, channel.id().asShortText());</span>
    }

    protected String id()
    {
<span class="fc" id="L267">        return SocketFactory.channelId(peer, self, type, channel.id().asShortText());</span>
    }

    @Override
    public String toString()
    {
<span class="fc" id="L273">        return id();</span>
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)
    {
        try
        {
<span class="fc" id="L281">            fatalExceptionCaught(cause);</span>
        }
<span class="nc" id="L283">        catch (Throwable t)</span>
        {
<span class="nc" id="L285">            logger.error(&quot;Unexpected exception in {}.exceptionCaught&quot;, this.getClass().getSimpleName(), t);</span>
<span class="fc" id="L286">        }</span>
<span class="fc" id="L287">    }</span>

    protected void fatalExceptionCaught(Throwable cause)
    {
<span class="fc" id="L291">        decoder.discard();</span>

<span class="fc" id="L293">        JVMStabilityInspector.inspectThrowable(cause);</span>

<span class="pc bpc" id="L295" title="1 of 2 branches missed.">        if (cause instanceof Message.InvalidLegacyProtocolMagic)</span>
<span class="nc" id="L296">            logger.error(&quot;{} invalid, unrecoverable CRC mismatch detected while reading messages - closing the connection&quot;, id());</span>
        else
<span class="fc" id="L298">            logger.error(&quot;{} unexpected exception caught while processing inbound messages; terminating connection&quot;, id(), cause);</span>

<span class="fc" id="L300">        channel.close();</span>
<span class="fc" id="L301">    }</span>

    /*
     * A large-message frame-accumulating state machine.
     *
     * Collects intact frames until it's has all the bytes necessary to deserialize the large message,
     * at which point it schedules a task on the appropriate {@link Stage},
     * a task that deserializes the message and immediately invokes the verb handler.
     *
     * Also handles corrupt frames and potential expiry of the large message during accumulation:
     * if it's taking the frames too long to arrive, there is no point in holding on to the
     * accumulated frames, or in gathering more - so we release the ones we already have, and
     * skip any remaining ones, alongside with returning memory permits early.
     */
    private class LargeMessage extends AbstractMessageHandler.LargeMessage&lt;Header&gt;
    {
        private LargeMessage(int size, Header header, boolean isExpired)
<span class="fc" id="L318">        {</span>
<span class="fc" id="L319">            super(size, header, header.expiresAtNanos, isExpired);</span>
<span class="fc" id="L320">        }</span>

        private LargeMessage(int size, Header header, ShareableBytes bytes)
<span class="fc" id="L323">        {</span>
<span class="fc" id="L324">            super(size, header, header.expiresAtNanos, bytes);</span>
<span class="fc" id="L325">        }</span>

        private void schedule()
        {
<span class="fc" id="L329">            dispatch(new ProcessLargeMessage(this));</span>
<span class="fc" id="L330">        }</span>

        protected void onComplete()
        {
<span class="fc" id="L334">            long timeElapsed = approxTime.now() - header.createdAtNanos;</span>

<span class="pc bpc" id="L336" title="2 of 4 branches missed.">            if (!isExpired &amp;&amp; !isCorrupt)</span>
            {
<span class="fc" id="L338">                callbacks.onArrived(size, header, timeElapsed, NANOSECONDS);</span>
<span class="fc" id="L339">                schedule();</span>
            }
<span class="nc bnc" id="L341" title="All 2 branches missed.">            else if (isExpired)</span>
            {
<span class="nc" id="L343">                callbacks.onArrivedExpired(size, header, isCorrupt, timeElapsed, NANOSECONDS);</span>
            }
            else
            {
<span class="nc" id="L347">                callbacks.onArrivedCorrupt(size, header, timeElapsed, NANOSECONDS);</span>
            }
<span class="fc" id="L349">        }</span>

        protected void abort()
        {
<span class="nc bnc" id="L353" title="All 4 branches missed.">            if (!isExpired &amp;&amp; !isCorrupt)</span>
<span class="nc" id="L354">                releaseBuffersAndCapacity(); // release resources if in normal state when abort() is invoked</span>
<span class="nc" id="L355">            callbacks.onClosedBeforeArrival(size, header, received, isCorrupt, isExpired);</span>
<span class="nc" id="L356">        }</span>

        private Message deserialize()
        {
<span class="fc" id="L360">            try (ChunkedInputPlus input = ChunkedInputPlus.of(buffers))</span>
            {
<span class="fc" id="L362">                Message&lt;?&gt; m = serializer.deserialize(input, header, version);</span>
<span class="fc" id="L363">                int remainder = input.remainder();</span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">                if (remainder &gt; 0)</span>
<span class="nc" id="L365">                    throw new InvalidSerializedSizeException(header.verb, size, size - remainder);</span>
<span class="fc" id="L366">                return m;</span>
            }
<span class="nc" id="L368">            catch (IncompatibleSchemaException e)</span>
            {
<span class="nc" id="L370">                callbacks.onFailedDeserialize(size, header, e);</span>
<span class="nc" id="L371">                noSpamLogger.info(&quot;{} incompatible schema encountered while deserializing a message&quot;, InboundMessageHandler.this, e);</span>
            }
<span class="nc" id="L373">            catch (Throwable t)</span>
            {
<span class="nc" id="L375">                JVMStabilityInspector.inspectThrowable(t);</span>
<span class="nc" id="L376">                callbacks.onFailedDeserialize(size, header, t);</span>
<span class="nc" id="L377">                logger.error(&quot;{} unexpected exception caught while deserializing a message&quot;, id(), t);</span>
            }
            finally
            {
<span class="fc" id="L381">                buffers.clear(); // closing the input will have ensured that the buffers were released no matter what</span>
            }

<span class="nc" id="L384">            return null;</span>
        }
    }

    /**
     * Submit a {@link ProcessMessage} task to the appropriate {@link Stage} for the {@link Verb}.
     */
    private void dispatch(ProcessMessage task)
    {
<span class="fc" id="L393">        Header header = task.header();</span>

<span class="fc" id="L395">        TraceState state = Tracing.instance.initializeFromMessage(header);</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">        if (state != null) state.trace(&quot;{} message received from {}&quot;, header.verb, header.from);</span>

<span class="fc" id="L398">        callbacks.onDispatched(task.size(), header);</span>
<span class="fc" id="L399">        header.verb.stage.execute(ExecutorLocals.create(state), task);</span>
<span class="fc" id="L400">    }</span>

<span class="fc" id="L402">    private abstract class ProcessMessage implements Runnable</span>
    {
        /**
         * Actually handle the message. Runs on the appropriate {@link Stage} for the {@link Verb}.
         *
         * Small messages will come pre-deserialized. Large messages will be deserialized on the stage,
         * just in time, and only then processed.
         */
        public void run()
        {
<span class="fc" id="L412">            Header header = header();</span>
<span class="fc" id="L413">            long currentTimeNanos = approxTime.now();</span>
<span class="fc" id="L414">            boolean expired = approxTime.isAfter(currentTimeNanos, header.expiresAtNanos);</span>

<span class="fc" id="L416">            boolean processed = false;</span>
            try
            {
<span class="fc" id="L419">                callbacks.onExecuting(size(), header, currentTimeNanos - header.createdAtNanos, NANOSECONDS);</span>

<span class="fc bfc" id="L421" title="All 2 branches covered.">                if (expired)</span>
                {
<span class="fc" id="L423">                    callbacks.onExpired(size(), header, currentTimeNanos - header.createdAtNanos, NANOSECONDS);</span>
<span class="fc" id="L424">                    return;</span>
                }

<span class="fc" id="L427">                Message message = provideMessage();</span>
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">                if (null != message)</span>
                {
<span class="fc" id="L430">                    consumer.accept(message);</span>
<span class="fc" id="L431">                    processed = true;</span>
<span class="fc" id="L432">                    callbacks.onProcessed(size(), header);</span>
                }
            }
            finally
            {
<span class="fc bfc" id="L437" title="All 2 branches covered.">                if (processed)</span>
<span class="fc" id="L438">                    releaseProcessedCapacity(size(), header);</span>
                else
<span class="fc" id="L440">                    releaseCapacity(size());</span>

<span class="fc" id="L442">                releaseResources();</span>

<span class="fc" id="L444">                callbacks.onExecuted(size(), header, approxTime.now() - currentTimeNanos, NANOSECONDS);</span>
            }
<span class="fc" id="L446">        }</span>

        abstract int size();
        abstract Header header();
        abstract Message provideMessage();
<span class="fc" id="L451">        void releaseResources() {}</span>
    }

    private class ProcessSmallMessage extends ProcessMessage
    {
        private final int size;
        private final Message message;

        ProcessSmallMessage(Message message, int size)
<span class="fc" id="L460">        {</span>
<span class="fc" id="L461">            this.size = size;</span>
<span class="fc" id="L462">            this.message = message;</span>
<span class="fc" id="L463">        }</span>

        int size()
        {
<span class="fc" id="L467">            return size;</span>
        }

        Header header()
        {
<span class="fc" id="L472">            return message.header;</span>
        }

        Message provideMessage()
        {
<span class="fc" id="L477">            return message;</span>
        }
    }

    private class ProcessLargeMessage extends ProcessMessage
    {
        private final LargeMessage message;

        ProcessLargeMessage(LargeMessage message)
<span class="fc" id="L486">        {</span>
<span class="fc" id="L487">            this.message = message;</span>
<span class="fc" id="L488">        }</span>

        int size()
        {
<span class="fc" id="L492">            return message.size;</span>
        }

        Header header()
        {
<span class="fc" id="L497">            return message.header;</span>
        }

        Message provideMessage()
        {
<span class="fc" id="L502">            return message.deserialize();</span>
        }

        @Override
        void releaseResources()
        {
<span class="fc" id="L508">            message.releaseBuffers(); // releases buffers if they haven't been yet (by deserialize() call)</span>
<span class="fc" id="L509">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>