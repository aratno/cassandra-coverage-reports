<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Commit.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.service.paxos</a> &gt; <span class="el_source">Commit.java</span></div><h1>Commit.java</h1><pre class="source lang-java linenums">package org.apache.cassandra.service.paxos;
/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */


import java.io.IOException;
import java.util.function.BiFunction;

import javax.annotation.Nullable;

import com.google.common.base.Objects;

import org.apache.cassandra.db.*;
import org.apache.cassandra.db.rows.*;
import org.apache.cassandra.db.partitions.PartitionUpdate;
import org.apache.cassandra.io.IVersionedSerializer;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.schema.TableMetadata;

import static org.apache.cassandra.db.SystemKeyspace.*;
import static org.apache.cassandra.service.paxos.Commit.CompareResult.AFTER;
import static org.apache.cassandra.service.paxos.Commit.CompareResult.BEFORE;
import static org.apache.cassandra.service.paxos.Commit.CompareResult.IS_REPROPOSAL;
import static org.apache.cassandra.service.paxos.Commit.CompareResult.WAS_REPROPOSED_BY;
import static org.apache.cassandra.service.paxos.Commit.CompareResult.SAME;
import static org.apache.cassandra.utils.FBUtilities.nowInSeconds;

public class Commit
{
<span class="fc" id="L49">    enum CompareResult { SAME, BEFORE, AFTER, IS_REPROPOSAL, WAS_REPROPOSED_BY}</span>

<span class="fc" id="L51">    public static final CommitSerializer&lt;Commit&gt; serializer = new CommitSerializer&lt;&gt;(Commit::new);</span>

    public static class Proposal extends Commit
    {
<span class="fc" id="L55">        public static final CommitSerializer&lt;Proposal&gt; serializer = new CommitSerializer&lt;&gt;(Proposal::new);</span>

        public Proposal(Ballot ballot, PartitionUpdate update)
        {
<span class="fc" id="L59">            super(ballot, update);</span>
<span class="fc" id="L60">        }</span>

        public String toString()
        {
<span class="nc" id="L64">            return toString(&quot;Proposal&quot;);</span>
        }

        public static Proposal of(Ballot ballot, PartitionUpdate update)
        {
<span class="fc" id="L69">            update = withTimestamp(update, ballot.unixMicros());</span>
<span class="fc" id="L70">            return new Proposal(ballot, update);</span>
        }

        public static Proposal empty(Ballot ballot, DecoratedKey partitionKey, TableMetadata metadata)
        {
<span class="fc" id="L75">            return new Proposal(ballot, PartitionUpdate.emptyUpdate(metadata, partitionKey));</span>
        }

        public Accepted accepted()
        {
<span class="fc" id="L80">            return new Accepted(ballot, update);</span>
        }

        public Agreed agreed()
        {
<span class="fc" id="L85">            return new Agreed(ballot, update);</span>
        }
    }

    public static class Accepted extends Proposal
    {
<span class="fc" id="L91">        public static final CommitSerializer&lt;Accepted&gt; serializer = new CommitSerializer&lt;&gt;(Accepted::new);</span>

        public static Accepted none(DecoratedKey partitionKey, TableMetadata metadata)
        {
<span class="fc" id="L95">            return new Accepted(Ballot.none(), PartitionUpdate.emptyUpdate(metadata, partitionKey));</span>
        }

        public Accepted(Ballot ballot, PartitionUpdate update)
        {
<span class="fc" id="L100">            super(ballot, update);</span>
<span class="fc" id="L101">        }</span>

        public Accepted(Commit commit)
        {
<span class="fc" id="L105">            super(commit.ballot, commit.update);</span>
<span class="fc" id="L106">        }</span>

        Committed committed()
        {
<span class="fc" id="L110">            return new Committed(ballot, update);</span>
        }

        boolean isExpired(long nowInSec)
        {
<span class="fc" id="L115">            return false;</span>
        }

        public String toString()
        {
<span class="nc" id="L120">            return toString(&quot;Accepted&quot;);</span>
        }

        /**
         * Like {@link #latest(Commit, Commit)} but also takes into account deletion time
         */
        public static Accepted latestAccepted(Accepted a, Accepted b)
        {
<span class="fc" id="L128">            int c = compare(a, b);</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">            if (c != 0)</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">                return c &gt; 0 ? a : b;</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">            return a instanceof AcceptedWithTTL ? ((AcceptedWithTTL)a).lastDeleted(b) : a;</span>
        }
    }

    public static class AcceptedWithTTL extends Accepted
    {
        public static AcceptedWithTTL withDefaultTTL(Commit copy)
        {
<span class="fc" id="L139">            return new AcceptedWithTTL(copy, nowInSeconds() + legacyPaxosTtlSec(copy.update.metadata()));</span>
        }

        public final long localDeletionTime;

        public AcceptedWithTTL(Commit copy, long localDeletionTime)
        {
<span class="fc" id="L146">            super(copy);</span>
<span class="fc" id="L147">            this.localDeletionTime = localDeletionTime;</span>
<span class="fc" id="L148">        }</span>

        public AcceptedWithTTL(Ballot ballot, PartitionUpdate update, long localDeletionTime)
        {
<span class="fc" id="L152">            super(ballot, update);</span>
<span class="fc" id="L153">            this.localDeletionTime = localDeletionTime;</span>
<span class="fc" id="L154">        }</span>

        boolean isExpired(long nowInSec)
        {
<span class="fc bfc" id="L158" title="All 2 branches covered.">            return nowInSec &gt;= localDeletionTime;</span>
        }

        Accepted lastDeleted(Accepted b)
        {
<span class="fc bfc" id="L163" title="All 4 branches covered.">            return b instanceof AcceptedWithTTL &amp;&amp; localDeletionTime &gt;= ((AcceptedWithTTL) b).localDeletionTime</span>
<span class="fc" id="L164">                   ? this : b;</span>
        }
    }

    // might prefer to call this Commit, but would mean refactoring more legacy code
    public static class Agreed extends Accepted
    {
<span class="fc" id="L171">        public static final CommitSerializer&lt;Agreed&gt; serializer = new CommitSerializer&lt;&gt;(Agreed::new);</span>

        public Agreed(Ballot ballot, PartitionUpdate update)
        {
<span class="fc" id="L175">            super(ballot, update);</span>
<span class="fc" id="L176">        }</span>

        public Agreed(Commit copy)
        {
<span class="fc" id="L180">            super(copy);</span>
<span class="fc" id="L181">        }</span>
    }

    public static class Committed extends Agreed
    {
<span class="fc" id="L186">        public static final CommitSerializer&lt;Committed&gt; serializer = new CommitSerializer&lt;&gt;(Committed::new);</span>

        public static Committed none(DecoratedKey partitionKey, TableMetadata metadata)
        {
<span class="fc" id="L190">            return new Committed(Ballot.none(), PartitionUpdate.emptyUpdate(metadata, partitionKey));</span>
        }

        public Committed(Ballot ballot, PartitionUpdate update)
        {
<span class="fc" id="L195">            super(ballot, update);</span>
<span class="fc" id="L196">        }</span>

        public Committed(Commit copy)
        {
<span class="fc" id="L200">            super(copy);</span>
<span class="fc" id="L201">        }</span>

        public String toString()
        {
<span class="nc" id="L205">            return toString(&quot;Committed&quot;);</span>
        }

        public static Committed latestCommitted(Committed a, Committed b)
        {
<span class="fc" id="L210">            int c = compare(a, b);</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">            if (c != 0)</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">                return c &gt; 0 ? a : b;</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">            return a instanceof CommittedWithTTL ? ((CommittedWithTTL)a).lastDeleted(b) : a;</span>
        }
    }

    public static class CommittedWithTTL extends Committed
    {
        public static CommittedWithTTL withDefaultTTL(Commit copy)
        {
<span class="fc" id="L221">            return new CommittedWithTTL(copy, nowInSeconds() + legacyPaxosTtlSec(copy.update.metadata()));</span>
        }

        public final long localDeletionTime;

        public CommittedWithTTL(Ballot ballot, PartitionUpdate update, long localDeletionTime)
        {
<span class="fc" id="L228">            super(ballot, update);</span>
<span class="fc" id="L229">            this.localDeletionTime = localDeletionTime;</span>
<span class="fc" id="L230">        }</span>

        public CommittedWithTTL(Commit copy, long localDeletionTime)
        {
<span class="fc" id="L234">            super(copy);</span>
<span class="fc" id="L235">            this.localDeletionTime = localDeletionTime;</span>
<span class="fc" id="L236">        }</span>

        boolean isExpired(long nowInSec)
        {
<span class="fc bfc" id="L240" title="All 2 branches covered.">            return nowInSec &gt;= localDeletionTime;</span>
        }

        Committed lastDeleted(Committed b)
        {
<span class="fc bfc" id="L245" title="All 4 branches covered.">            return b instanceof CommittedWithTTL &amp;&amp; localDeletionTime &gt;= ((CommittedWithTTL) b).localDeletionTime</span>
<span class="fc" id="L246">                   ? this : b;</span>
        }
    }

    public final Ballot ballot;
    public final PartitionUpdate update;

    public Commit(Ballot ballot, PartitionUpdate update)
<span class="fc" id="L254">    {</span>
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        assert ballot != null;</span>
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">        assert update != null;</span>

<span class="fc" id="L258">        this.ballot = ballot;</span>
<span class="fc" id="L259">        this.update = update;</span>
<span class="fc" id="L260">    }</span>

    public static Commit newPrepare(DecoratedKey partitionKey, TableMetadata metadata, Ballot ballot)
    {
<span class="fc" id="L264">        return new Commit(ballot, PartitionUpdate.emptyUpdate(metadata, partitionKey));</span>
    }

    public static Commit emptyCommit(DecoratedKey partitionKey, TableMetadata metadata)
    {
<span class="fc" id="L269">        return new Commit(Ballot.none(), PartitionUpdate.emptyUpdate(metadata, partitionKey));</span>
    }

    @Deprecated
    public static Commit newProposal(Ballot ballot, PartitionUpdate update)
    {
<span class="fc" id="L275">        update = withTimestamp(update, ballot.unixMicros());</span>
<span class="fc" id="L276">        return new Commit(ballot, update);</span>
    }

    public boolean isAfter(Commit other)
    {
<span class="pc bpc" id="L281" title="1 of 4 branches missed.">        return other == null || ballot.uuidTimestamp() &gt; other.ballot.uuidTimestamp();</span>
    }

    public boolean isSameOrAfter(@Nullable Ballot otherBallot)
    {
<span class="pc bpc" id="L286" title="1 of 6 branches missed.">        return otherBallot == null || otherBallot.equals(ballot) || ballot.uuidTimestamp() &gt; otherBallot.uuidTimestamp();</span>
    }

    public boolean isAfter(@Nullable Ballot otherBallot)
    {
<span class="pc bpc" id="L291" title="1 of 4 branches missed.">        return otherBallot == null || ballot.uuidTimestamp() &gt; otherBallot.uuidTimestamp();</span>
    }

    public boolean isBefore(@Nullable Ballot otherBallot)
    {
<span class="pc bpc" id="L296" title="2 of 4 branches missed.">        return otherBallot != null &amp;&amp; ballot.uuidTimestamp() &lt; otherBallot.uuidTimestamp();</span>
    }

    public boolean hasBallot(Ballot ballot)
    {
<span class="fc" id="L301">        return this.ballot.equals(ballot);</span>
    }

    public boolean hasSameBallot(Commit other)
    {
<span class="fc" id="L306">        return this.ballot.equals(other.ballot);</span>
    }

    public Mutation makeMutation()
    {
<span class="fc" id="L311">        return new Mutation(update);</span>
    }

    @Override
    public boolean equals(Object o)
    {
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">        if (this == o) return true;</span>
<span class="pc bpc" id="L318" title="2 of 4 branches missed.">        if (o == null || getClass() != o.getClass()) return false;</span>

<span class="fc" id="L320">        Commit commit = (Commit) o;</span>

<span class="pc bpc" id="L322" title="2 of 4 branches missed.">        return ballot.equals(commit.ballot) &amp;&amp; update.equals(commit.update);</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L328">        return Objects.hashCode(ballot, update);</span>
    }

    @Override
    public String toString()
    {
<span class="fc" id="L334">        return toString(&quot;Commit&quot;);</span>
    }

    public String toString(String kind)
    {
<span class="fc" id="L339">        return String.format(&quot;%s(%d:%s, %d:%s)&quot;, kind, ballot.uuidTimestamp(), ballot, update.stats().minTimestamp, update.toString(false));</span>
    }

    /**
     * We can witness reproposals of the latest successful commit; we can detect this by comparing the timestamp of
     * the update with our ballot; if it is the same, we are not a reproposal. If it is the same as either the
     * ballot timestamp or update timestamp of the latest committed proposal, then we are reproposing it and can
     * instead simpy commit it.
     */
    public boolean isReproposalOf(Commit older)
    {
<span class="fc" id="L350">        return isReproposal(older, older.ballot.uuidTimestamp(), this, this.ballot.uuidTimestamp());</span>
    }

    private boolean isReproposal(Commit older, long ballotOfOlder, Commit newer, long ballotOfNewer)
    {
        // NOTE: it would in theory be possible to just check
        // newer.update.stats().minTimestamp == older.update.stats().minTimestamp
        // however this could be brittle, if for some reason they don't get updated;
        // the logic below is fail-safe, in that if minTimestamp is not set we will treat it as not a reproposal
        // which is the safer way to get it wrong.

        // the timestamp of a mutation stays unchanged as we repropose it, so the timestamp of the mutation
        // is the timestamp of the ballot that originally proposed it
<span class="fc" id="L363">        long originalBallotOfNewer = newer.update.stats().minTimestamp;</span>

        // so, if the mutation and ballot timestamps match, this is not a reproposal but a first proposal
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">        if (ballotOfNewer == originalBallotOfNewer)</span>
<span class="nc" id="L367">            return false;</span>

        // otherwise, if the original proposing ballot matches the older proposal's ballot, it is reproposing it
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">        if (originalBallotOfNewer == ballotOfOlder)</span>
<span class="nc" id="L371">            return true;</span>

        // otherwise, it could be that both are reproposals, so just check both for the &quot;original&quot; ballot timestamp
<span class="fc bfc" id="L374" title="All 2 branches covered.">        return originalBallotOfNewer == older.update.stats().minTimestamp;</span>
    }

    public CompareResult compareWith(Commit that)
    {
<span class="fc" id="L379">        long thisBallot = this.ballot.uuidTimestamp();</span>
<span class="fc" id="L380">        long thatBallot = that.ballot.uuidTimestamp();</span>
        // by the time we reach proposal and commit, timestamps are unique so we can assert identity
<span class="fc bfc" id="L382" title="All 2 branches covered.">        if (thisBallot == thatBallot)</span>
<span class="fc" id="L383">            return SAME;</span>

<span class="fc bfc" id="L385" title="All 2 branches covered.">        if (thisBallot &lt; thatBallot)</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">            return isReproposal(this, thisBallot, that, thatBallot) ? WAS_REPROPOSED_BY : BEFORE;</span>
        else
<span class="fc bfc" id="L388" title="All 2 branches covered.">            return isReproposal(that, thatBallot, this, thisBallot) ? IS_REPROPOSAL : AFTER;</span>
    }

    private static int compare(@Nullable Commit a, @Nullable Commit b)
    {
<span class="fc bfc" id="L393" title="All 2 branches covered.">        if (a == null) return 1;</span>
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">        if (b == null) return -1;</span>
<span class="fc" id="L395">        return Long.compare(a.ballot.uuidTimestamp(), b.ballot.uuidTimestamp());</span>
    }

    /**
     * @return testIfAfter.isAfter(testIfBefore), with non-null &gt; null
     */
    public static boolean isAfter(@Nullable Commit testIsAfter, @Nullable Commit testIsBefore)
    {
<span class="fc bfc" id="L403" title="All 4 branches covered.">        return testIsAfter != null &amp;&amp; testIsAfter.isAfter(testIsBefore);</span>
    }

    /**
     * @return testIfAfter.isAfter(testIfBefore), with non-null &gt; null
     */
    public static boolean isAfter(@Nullable Ballot testIsAfter, @Nullable Commit testIsBefore)
    {
<span class="pc bpc" id="L411" title="1 of 6 branches missed.">        return testIsAfter != null &amp;&amp; (testIsBefore == null || testIsAfter.uuidTimestamp() &gt; testIsBefore.ballot.uuidTimestamp());</span>
    }

    /**
     * @return testIfAfter.isAfter(testIfBefore), with non-null &gt; null
     */
    public static boolean isAfter(@Nullable Commit testIsAfter, @Nullable Ballot testIsBefore)
    {
<span class="pc bpc" id="L419" title="2 of 6 branches missed.">        return testIsAfter != null &amp;&amp; (testIsBefore == null || testIsAfter.ballot.uuidTimestamp() &gt; testIsBefore.uuidTimestamp());</span>
    }

    /**
     * @return testIfAfter.isAfter(testIfBefore), with non-null &gt; null
     */
    public static boolean isAfter(@Nullable Ballot testIsAfter, @Nullable Ballot testIsBefore)
    {
<span class="fc bfc" id="L427" title="All 6 branches covered.">        return testIsAfter != null &amp;&amp; (testIsBefore == null || testIsAfter.uuidTimestamp() &gt; testIsBefore.uuidTimestamp());</span>
    }

    /**
     * the latest of two ballots, or the first ballot if equal timestamps
     */
    public static &lt;C extends Commit&gt; C latest(@Nullable C a, @Nullable C b)
    {
<span class="fc bfc" id="L435" title="All 10 branches covered.">        return (a == null | b == null) ? (a == null ? b : a) : a.ballot.uuidTimestamp() &gt;= b.ballot.uuidTimestamp() ? a : b;</span>
    }

    /**
     * the latest of two ballots, or the first ballot if equal timestamps
     */
    public static Ballot latest(@Nullable Commit a, @Nullable Ballot b)
    {
<span class="pc bpc" id="L443" title="2 of 10 branches missed.">        return (a == null | b == null) ? (a == null ? b : a.ballot) : a.ballot.uuidTimestamp() &gt;= b.uuidTimestamp() ? a.ballot : b;</span>
    }

    /**
     * the latest of two ballots, or the first ballot if equal timestamps
     */
    public static Ballot latest(@Nullable Ballot a, @Nullable Ballot b)
    {
<span class="fc bfc" id="L451" title="All 10 branches covered.">        return (a == null | b == null) ? (a == null ? b : a) : a.uuidTimestamp() &gt;= b.uuidTimestamp() ? a : b;</span>
    }

    /**
     * unequal ballots with same timestamp
     */
    public static boolean timestampsClash(@Nullable Commit a, @Nullable Ballot b)
    {
<span class="pc bpc" id="L459" title="2 of 8 branches missed.">        return a != null &amp;&amp; b != null &amp;&amp; !a.ballot.equals(b) &amp;&amp; a.ballot.uuidTimestamp() == b.uuidTimestamp();</span>
    }

    public static boolean timestampsClash(@Nullable Ballot a, @Nullable Ballot b)
    {
<span class="pc bpc" id="L464" title="2 of 8 branches missed.">        return a != null &amp;&amp; b != null &amp;&amp; !a.equals(b) &amp;&amp; a.uuidTimestamp() == b.uuidTimestamp();</span>
    }

    private static PartitionUpdate withTimestamp(PartitionUpdate update, long timestamp)
    {
<span class="fc" id="L469">        return new PartitionUpdate.Builder(update, 0).updateAllTimestamp(timestamp).build();</span>
    }

    public static class CommitSerializer&lt;T extends Commit&gt; implements IVersionedSerializer&lt;T&gt;
    {
        final BiFunction&lt;Ballot, PartitionUpdate, T&gt; constructor;
        public CommitSerializer(BiFunction&lt;Ballot, PartitionUpdate, T&gt; constructor)
<span class="fc" id="L476">        {</span>
<span class="fc" id="L477">            this.constructor = constructor;</span>
<span class="fc" id="L478">        }</span>

        public void serialize(T commit, DataOutputPlus out, int version) throws IOException
        {
<span class="fc" id="L482">            commit.ballot.serialize(out);</span>
<span class="fc" id="L483">            PartitionUpdate.serializer.serialize(commit.update, out, version);</span>
<span class="fc" id="L484">        }</span>

        public T deserialize(DataInputPlus in, int version) throws IOException
        {
<span class="fc" id="L488">            Ballot ballot = Ballot.deserialize(in);</span>
<span class="fc" id="L489">            PartitionUpdate update = PartitionUpdate.serializer.deserialize(in, version, DeserializationHelper.Flag.LOCAL);</span>
<span class="fc" id="L490">            return constructor.apply(ballot, update);</span>
        }

        public long serializedSize(T commit, int version)
        {
<span class="fc" id="L495">            return Ballot.sizeInBytes()</span>
<span class="fc" id="L496">                   + PartitionUpdate.serializer.serializedSize(commit.update, version);</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>