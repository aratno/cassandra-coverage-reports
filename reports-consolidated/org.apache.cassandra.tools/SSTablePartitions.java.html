<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SSTablePartitions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.tools</a> &gt; <span class="el_source">SSTablePartitions.java</span></div><h1>SSTablePartitions.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.tools;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.UUID;
import java.util.function.ToLongFunction;
import java.util.stream.Collectors;

import com.google.common.collect.ImmutableSet;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.cli.PosixParser;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.math.NumberUtils;

import org.apache.cassandra.config.DataStorageSpec;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.Directories;
import org.apache.cassandra.db.LivenessInfo;
import org.apache.cassandra.db.PartitionPosition;
import org.apache.cassandra.db.rows.Cell;
import org.apache.cassandra.db.rows.ColumnData;
import org.apache.cassandra.db.rows.ComplexColumnData;
import org.apache.cassandra.db.rows.RangeTombstoneMarker;
import org.apache.cassandra.db.rows.Row;
import org.apache.cassandra.db.rows.Unfiltered;
import org.apache.cassandra.db.rows.UnfilteredRowIterator;
import org.apache.cassandra.dht.AbstractBounds;
import org.apache.cassandra.dht.Bounds;
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.io.sstable.Descriptor;
import org.apache.cassandra.io.sstable.ISSTableScanner;
import org.apache.cassandra.io.sstable.format.SSTableReader;
import org.apache.cassandra.io.sstable.format.big.BigFormat;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.schema.TableId;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.schema.TableMetadataRef;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.Clock;
import org.apache.cassandra.utils.EstimatedHistogram;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.Pair;

<span class="nc" id="L73">public class SSTablePartitions</span>
{
    private static final String KEY_OPTION = &quot;k&quot;;
    private static final String EXCLUDE_KEY_OPTION = &quot;x&quot;;
    private static final String RECURSIVE_OPTION = &quot;r&quot;;
    private static final String SNAPSHOTS_OPTION = &quot;s&quot;;
    private static final String BACKUPS_OPTION = &quot;b&quot;;
    private static final String PARTITIONS_ONLY_OPTION = &quot;y&quot;;
    private static final String SIZE_THRESHOLD_OPTION = &quot;t&quot;;
    private static final String TOMBSTONE_THRESHOLD_OPTION = &quot;o&quot;;
    private static final String CELL_THRESHOLD_OPTION = &quot;c&quot;;
    private static final String ROW_THRESHOLD_OPTION = &quot;w&quot;;
    private static final String CSV_OPTION = &quot;m&quot;;
    private static final String CURRENT_TIMESTAMP_OPTION = &quot;u&quot;;

<span class="fc" id="L88">    private static final Options options = new Options();</span>

<span class="fc" id="L90">    private static final TableId EMPTY_TABLE_ID = TableId.fromUUID(new UUID(0L, 0L));</span>

    static
    {
<span class="fc" id="L94">        DatabaseDescriptor.clientInitialization();</span>

<span class="fc" id="L96">        Option optKey = new Option(KEY_OPTION, &quot;key&quot;, true, &quot;Partition keys to include&quot;);</span>
        // Number of times -k &lt;key&gt; can be passed on the command line.
<span class="fc" id="L98">        optKey.setArgs(Option.UNLIMITED_VALUES);</span>
<span class="fc" id="L99">        options.addOption(optKey);</span>

<span class="fc" id="L101">        Option excludeKey = new Option(EXCLUDE_KEY_OPTION, &quot;exclude-key&quot;, true,</span>
                                       &quot;Excluded partition key(s) from partition detailed row/cell/tombstone &quot; +
                                       &quot;information (irrelevant, if --partitions-only is given)&quot;);
<span class="fc" id="L104">        excludeKey.setArgs(Option.UNLIMITED_VALUES); // Number of times -x &lt;key&gt; can be passed on the command line.</span>
<span class="fc" id="L105">        options.addOption(excludeKey);</span>

<span class="fc" id="L107">        Option thresholdKey = new Option(SIZE_THRESHOLD_OPTION, &quot;min-size&quot;, true,</span>
                                         &quot;partition size threshold, expressed as either the number of bytes or a &quot; +
                                         &quot;size with unit of the form 10KiB, 20MiB, 30GiB, etc.&quot;);
<span class="fc" id="L110">        options.addOption(thresholdKey);</span>

<span class="fc" id="L112">        Option tombstoneKey = new Option(TOMBSTONE_THRESHOLD_OPTION, &quot;min-tombstones&quot;, true,</span>
                                         &quot;partition tombstone count threshold&quot;);
<span class="fc" id="L114">        options.addOption(tombstoneKey);</span>

<span class="fc" id="L116">        Option cellKey = new Option(CELL_THRESHOLD_OPTION, &quot;min-cells&quot;, true, &quot;partition cell count threshold&quot;);</span>
<span class="fc" id="L117">        options.addOption(cellKey);</span>

<span class="fc" id="L119">        Option rowKey = new Option(ROW_THRESHOLD_OPTION, &quot;min-rows&quot;, true, &quot;partition row count threshold&quot;);</span>
<span class="fc" id="L120">        options.addOption(rowKey);</span>

<span class="fc" id="L122">        Option currentTimestampKey = new Option(CURRENT_TIMESTAMP_OPTION, &quot;current-timestamp&quot;, true,</span>
                                                &quot;timestamp (seconds since epoch, unit time) for TTL expired calculation&quot;);
<span class="fc" id="L124">        options.addOption(currentTimestampKey);</span>

<span class="fc" id="L126">        Option recursiveKey = new Option(RECURSIVE_OPTION, &quot;recursive&quot;, false, &quot;scan for sstables recursively&quot;);</span>
<span class="fc" id="L127">        options.addOption(recursiveKey);</span>

<span class="fc" id="L129">        Option snapshotsKey = new Option(SNAPSHOTS_OPTION, &quot;snapshots&quot;, false,</span>
                                         &quot;include snapshots present in data directories (recursive scans)&quot;);
<span class="fc" id="L131">        options.addOption(snapshotsKey);</span>

<span class="fc" id="L133">        Option backupsKey = new Option(BACKUPS_OPTION, &quot;backups&quot;, false,</span>
                                       &quot;include backups present in data directories (recursive scans)&quot;);
<span class="fc" id="L135">        options.addOption(backupsKey);</span>

<span class="fc" id="L137">        Option partitionsOnlyKey = new Option(PARTITIONS_ONLY_OPTION, &quot;partitions-only&quot;, false,</span>
                                              &quot;Do not process per-partition detailed row/cell/tombstone information, &quot; +
                                              &quot;only brief information&quot;);
<span class="fc" id="L140">        options.addOption(partitionsOnlyKey);</span>

<span class="fc" id="L142">        Option csvKey = new Option(CSV_OPTION, &quot;csv&quot;, false, &quot;CSV output (machine readable)&quot;);</span>
<span class="fc" id="L143">        options.addOption(csvKey);</span>
<span class="fc" id="L144">    }</span>

    /**
     * Given arguments specifying a list of SSTables or directories, print information about SSTable partitions.
     *
     * @param args command lines arguments
     * @throws ConfigurationException on configuration failure (wrong params given)
     */
    public static void main(String[] args) throws ConfigurationException, IOException
    {
<span class="fc" id="L154">        CommandLineParser parser = new PosixParser();</span>
        CommandLine cmd;
        try
        {
<span class="fc" id="L158">            cmd = parser.parse(options, args);</span>
        }
<span class="nc" id="L160">        catch (ParseException e)</span>
        {
<span class="nc" id="L162">            System.err.println(e.getMessage());</span>
<span class="nc" id="L163">            printUsage();</span>
<span class="nc" id="L164">            System.exit(1);</span>
<span class="nc" id="L165">            return;</span>
<span class="fc" id="L166">        }</span>

<span class="fc bfc" id="L168" title="All 2 branches covered.">        if (cmd.getArgs().length == 0)</span>
        {
<span class="fc" id="L170">            System.err.println(&quot;You must supply at least one sstable or directory&quot;);</span>
<span class="fc" id="L171">            printUsage();</span>
<span class="nc" id="L172">            System.exit(1);</span>
        }

<span class="fc" id="L175">        int ec = processArguments(cmd);</span>

<span class="nc" id="L177">        System.exit(ec);</span>
<span class="nc" id="L178">    }</span>

    private static void printUsage()
    {
<span class="fc" id="L182">        String usage = String.format(&quot;sstablepartitions &lt;options&gt; &lt;sstable files or directories&gt;%n&quot;);</span>
<span class="fc" id="L183">        String header = &quot;Print partition statistics of one or more sstables.&quot;;</span>
<span class="fc" id="L184">        new HelpFormatter().printHelp(usage, header, options, &quot;&quot;);</span>
<span class="fc" id="L185">    }</span>

    private static int processArguments(CommandLine cmd) throws IOException
    {
<span class="fc" id="L189">        String[] keys = cmd.getOptionValues(KEY_OPTION);</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">        Set&lt;String&gt; excludes = cmd.getOptionValues(EXCLUDE_KEY_OPTION) == null</span>
<span class="fc" id="L191">                               ? Collections.emptySet()</span>
<span class="fc" id="L192">                               : ImmutableSet.copyOf(cmd.getOptionValues(EXCLUDE_KEY_OPTION));</span>

<span class="fc" id="L194">        boolean scanRecursive = cmd.hasOption(RECURSIVE_OPTION);</span>
<span class="fc" id="L195">        boolean withSnapshots = cmd.hasOption(SNAPSHOTS_OPTION);</span>
<span class="fc" id="L196">        boolean withBackups = cmd.hasOption(BACKUPS_OPTION);</span>
<span class="fc" id="L197">        boolean csv = cmd.hasOption(CSV_OPTION);</span>
<span class="fc" id="L198">        boolean partitionsOnly = cmd.hasOption(PARTITIONS_ONLY_OPTION);</span>

<span class="fc" id="L200">        long sizeThreshold = Long.MAX_VALUE;</span>
<span class="fc" id="L201">        int cellCountThreshold = Integer.MAX_VALUE;</span>
<span class="fc" id="L202">        int rowCountThreshold = Integer.MAX_VALUE;</span>
<span class="fc" id="L203">        int tombstoneCountThreshold = Integer.MAX_VALUE;</span>
<span class="fc" id="L204">        long currentTime = Clock.Global.currentTimeMillis() / 1000L;</span>

        try
        {
<span class="fc bfc" id="L208" title="All 2 branches covered.">            if (cmd.hasOption(SIZE_THRESHOLD_OPTION))</span>
            {
<span class="fc" id="L210">                String threshold = cmd.getOptionValue(SIZE_THRESHOLD_OPTION);</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">                sizeThreshold = NumberUtils.isParsable(threshold)</span>
<span class="fc" id="L212">                                ? Long.parseLong(threshold)</span>
<span class="fc" id="L213">                                : new DataStorageSpec.LongBytesBound(threshold).toBytes();</span>
            }
<span class="fc bfc" id="L215" title="All 2 branches covered.">            if (cmd.hasOption(CELL_THRESHOLD_OPTION))</span>
<span class="fc" id="L216">                cellCountThreshold = Integer.parseInt(cmd.getOptionValue(CELL_THRESHOLD_OPTION));</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">            if (cmd.hasOption(ROW_THRESHOLD_OPTION))</span>
<span class="fc" id="L218">                rowCountThreshold = Integer.parseInt(cmd.getOptionValue(ROW_THRESHOLD_OPTION));</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">            if (cmd.hasOption(TOMBSTONE_THRESHOLD_OPTION))</span>
<span class="fc" id="L220">                tombstoneCountThreshold = Integer.parseInt(cmd.getOptionValue(TOMBSTONE_THRESHOLD_OPTION));</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">            if (cmd.hasOption(CURRENT_TIMESTAMP_OPTION))</span>
<span class="fc" id="L222">                currentTime = Integer.parseInt(cmd.getOptionValue(CURRENT_TIMESTAMP_OPTION));</span>
        }
<span class="nc" id="L224">        catch (NumberFormatException e)</span>
        {
<span class="nc" id="L226">            System.err.printf(&quot;Invalid threshold argument: %s%n&quot;, e.getMessage());</span>
<span class="nc" id="L227">            return 1;</span>
<span class="fc" id="L228">        }</span>

<span class="pc bpc" id="L230" title="4 of 8 branches missed.">        if (sizeThreshold &lt; 0 || cellCountThreshold &lt; 0 || tombstoneCountThreshold &lt; 0 || currentTime &lt; 0)</span>
        {
<span class="nc" id="L232">            System.err.println(&quot;Negative values are not allowed&quot;);</span>
<span class="nc" id="L233">            return 1;</span>
        }

<span class="fc" id="L236">        List&lt;File&gt; directories = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L237">        List&lt;ExtendedDescriptor&gt; descriptors = new ArrayList&lt;&gt;();</span>

<span class="pc bpc" id="L239" title="1 of 2 branches missed.">        if (!argumentsToFiles(cmd.getArgs(), descriptors, directories))</span>
<span class="nc" id="L240">            return 1;</span>

<span class="fc bfc" id="L242" title="All 2 branches covered.">        for (File directory : directories)</span>
        {
<span class="fc" id="L244">            processDirectory(scanRecursive, withSnapshots, withBackups, directory, descriptors);</span>
<span class="fc" id="L245">        }</span>

<span class="fc bfc" id="L247" title="All 2 branches covered.">        if (csv)</span>
<span class="fc" id="L248">            System.out.println(&quot;key,keyBinary,live,offset,size,rowCount,cellCount,&quot; +</span>
                               &quot;tombstoneCount,rowTombstoneCount,rangeTombstoneCount,complexTombstoneCount,&quot; +
                               &quot;cellTombstoneCount,rowTtlExpired,cellTtlExpired,&quot; +
                               &quot;directory,keyspace,table,index,&quot; +
                               &quot;snapshot,backup,generation,format,version&quot;);

<span class="fc" id="L254">        Collections.sort(descriptors);</span>

<span class="fc bfc" id="L256" title="All 2 branches covered.">        for (ExtendedDescriptor desc : descriptors)</span>
        {
<span class="fc" id="L258">            processSSTable(keys, excludes, desc,</span>
                           sizeThreshold, cellCountThreshold, rowCountThreshold, tombstoneCountThreshold, partitionsOnly,
                           csv, currentTime);
<span class="fc" id="L261">        }</span>

<span class="fc" id="L263">        return 0;</span>
    }

    private static void processDirectory(boolean scanRecursive,
                                         boolean withSnapshots,
                                         boolean withBackups,
                                         File dir,
                                         List&lt;ExtendedDescriptor&gt; descriptors)
    {
<span class="fc" id="L272">        File[] files = dir.tryList();</span>
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">        if (files == null)</span>
<span class="nc" id="L274">            return;</span>

<span class="fc bfc" id="L276" title="All 2 branches covered.">        for (File file : files)</span>
        {
<span class="fc bfc" id="L278" title="All 2 branches covered.">            if (file.isFile())</span>
            {
                try
                {
<span class="fc bfc" id="L282" title="All 2 branches covered.">                    if (Descriptor.componentFromFile(file) != BigFormat.Components.DATA)</span>
<span class="fc" id="L283">                        continue;</span>

<span class="fc" id="L285">                    ExtendedDescriptor desc = ExtendedDescriptor.guessFromFile(file);</span>
<span class="fc bfc" id="L286" title="All 4 branches covered.">                    if (desc.snapshot != null &amp;&amp; !withSnapshots)</span>
<span class="fc" id="L287">                        continue;</span>
<span class="fc bfc" id="L288" title="All 4 branches covered.">                    if (desc.backup != null &amp;&amp; !withBackups)</span>
<span class="fc" id="L289">                        continue;</span>

<span class="fc" id="L291">                    descriptors.add(desc);</span>
                }
<span class="nc" id="L293">                catch (IllegalArgumentException e)</span>
                {
                    // ignore that error when scanning directories
<span class="fc" id="L296">                }</span>
            }
<span class="fc bfc" id="L298" title="All 4 branches covered.">            if (scanRecursive &amp;&amp; file.isDirectory())</span>
            {
<span class="fc" id="L300">                processDirectory(true,</span>
                                 withSnapshots, withBackups,
                                 file,
                                 descriptors);
            }
        }
<span class="fc" id="L306">    }</span>

    private static boolean argumentsToFiles(String[] args, List&lt;ExtendedDescriptor&gt; descriptors, List&lt;File&gt; directories)
    {
<span class="fc" id="L310">        boolean err = false;</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">        for (String arg : args)</span>
        {
<span class="fc" id="L313">            File file = new File(arg);</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">            if (!file.exists())</span>
            {
<span class="nc" id="L316">                System.err.printf(&quot;Argument '%s' does not resolve to a file or directory%n&quot;, arg);</span>
<span class="nc" id="L317">                err = true;</span>
            }

<span class="pc bpc" id="L320" title="1 of 2 branches missed.">            if (!file.isReadable())</span>
            {
<span class="nc" id="L322">                System.err.printf(&quot;Argument '%s' is not a readable file or directory (check permissions)%n&quot;, arg);</span>
<span class="nc" id="L323">                err = true;</span>
<span class="nc" id="L324">                continue;</span>
            }

<span class="fc bfc" id="L327" title="All 2 branches covered.">            if (file.isFile())</span>
            {
                try
                {
<span class="fc" id="L331">                    descriptors.add(ExtendedDescriptor.guessFromFile(file));</span>
                }
<span class="nc" id="L333">                catch (IllegalArgumentException e)</span>
                {
<span class="nc" id="L335">                    System.err.printf(&quot;Argument '%s' is not an sstable%n&quot;, arg);</span>
<span class="nc" id="L336">                    err = true;</span>
<span class="fc" id="L337">                }</span>
            }
<span class="fc bfc" id="L339" title="All 2 branches covered.">            if (file.isDirectory())</span>
<span class="fc" id="L340">                directories.add(file);</span>
        }
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">        return !err;</span>
    }

    private static void processSSTable(String[] keys,
                                       Set&lt;String&gt; excludedKeys,
                                       ExtendedDescriptor desc,
                                       long sizeThreshold,
                                       int cellCountThreshold,
                                       int rowCountThreshold,
                                       int tombstoneCountThreshold,
                                       boolean partitionsOnly,
                                       boolean csv,
                                       long currentTime) throws IOException
    {
<span class="fc" id="L356">        TableMetadata metadata = Util.metadataFromSSTable(desc.descriptor);</span>
<span class="fc" id="L357">        SSTableReader sstable = SSTableReader.openNoValidation(null, desc.descriptor, TableMetadataRef.forOfflineTools(metadata));</span>

<span class="fc bfc" id="L359" title="All 2 branches covered.">        if (!csv)</span>
<span class="fc" id="L360">            System.out.printf(&quot;%nProcessing %s (%s uncompressed, %s on disk)%n&quot;,</span>
                              desc,
<span class="fc" id="L362">                              prettyPrintMemory(sstable.uncompressedLength()),</span>
<span class="fc" id="L363">                              prettyPrintMemory(sstable.onDiskLength()));</span>

<span class="fc" id="L365">        List&lt;PartitionStats&gt; matches = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L366">        SSTableStats sstableStats = new SSTableStats();</span>

<span class="fc" id="L368">        try (ISSTableScanner scanner = buildScanner(sstable, metadata, keys, excludedKeys))</span>
        {
<span class="fc bfc" id="L370" title="All 2 branches covered.">            while (scanner.hasNext())</span>
            {
<span class="fc" id="L372">                try (UnfilteredRowIterator partition = scanner.next())</span>
                {
<span class="fc" id="L374">                    ByteBuffer key = partition.partitionKey().getKey();</span>
<span class="fc" id="L375">                    boolean isExcluded = excludedKeys.contains(metadata.partitionKeyType.getString(key));</span>

<span class="fc" id="L377">                    PartitionStats partitionStats = new PartitionStats(key,</span>
<span class="fc" id="L378">                                                                       scanner.getCurrentPosition(),</span>
<span class="fc" id="L379">                                                                       partition.partitionLevelDeletion().isLive());</span>

                    // Consume the partition to populate the stats.
<span class="fc bfc" id="L382" title="All 2 branches covered.">                    while (partition.hasNext())</span>
                    {
<span class="fc" id="L384">                        Unfiltered unfiltered = partition.next();</span>

                        // We don't need any details if we are only interested on its size or if it's excluded.
<span class="fc bfc" id="L387" title="All 4 branches covered.">                        if (!partitionsOnly &amp;&amp; !isExcluded)</span>
<span class="fc" id="L388">                            partitionStats.addUnfiltered(desc, currentTime, unfiltered);</span>
<span class="fc" id="L389">                    }</span>

                    // record the partiton size
<span class="fc" id="L392">                    partitionStats.endOfPartition(scanner.getCurrentPosition());</span>

<span class="fc bfc" id="L394" title="All 2 branches covered.">                    if (isExcluded)</span>
                        continue;

<span class="fc" id="L397">                    sstableStats.addPartition(partitionStats);</span>

<span class="fc bfc" id="L399" title="All 6 branches covered.">                    if (partitionStats.size &lt; sizeThreshold &amp;&amp;</span>
                        partitionStats.rowCount &lt; rowCountThreshold &amp;&amp;
                        partitionStats.cellCount &lt; cellCountThreshold &amp;&amp;
<span class="fc bfc" id="L402" title="All 2 branches covered.">                        partitionStats.tombstoneCount() &lt; tombstoneCountThreshold)</span>
                        continue;

<span class="fc" id="L405">                    matches.add(partitionStats);</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">                    if (csv)</span>
<span class="fc" id="L407">                        partitionStats.printPartitionInfoCSV(metadata, desc);</span>
                    else
<span class="fc" id="L409">                        partitionStats.printPartitionInfo(metadata, partitionsOnly);</span>
<span class="pc bpc" id="L410" title="2 of 4 branches missed.">                }</span>
            }
        }
<span class="nc" id="L413">        catch (RuntimeException e)</span>
        {
<span class="nc" id="L415">            System.err.printf(&quot;Failure processing sstable %s: %s%n&quot;, desc.descriptor, e);</span>
        }
        finally
        {
<span class="fc" id="L419">            sstable.selfRef().release();</span>
        }

<span class="fc bfc" id="L422" title="All 2 branches covered.">        if (!csv)</span>
        {
<span class="fc" id="L424">            printSummary(metadata, desc, sstableStats, matches, partitionsOnly);</span>
        }
<span class="fc" id="L426">    }</span>

    private static String prettyPrintMemory(long bytes)
    {
<span class="fc" id="L430">        return FBUtilities.prettyPrintMemory(bytes, &quot; &quot;);</span>
    }

    private static ISSTableScanner buildScanner(SSTableReader sstable,
                                                TableMetadata metadata,
                                                String[] keys,
                                                Set&lt;String&gt; excludedKeys)
    {
<span class="pc bpc" id="L438" title="1 of 4 branches missed.">        if (keys != null &amp;&amp; keys.length &gt; 0)</span>
        {
            try
            {
<span class="fc" id="L442">                return sstable.getScanner(Arrays.stream(keys)</span>
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">                                                .filter(key -&gt; !excludedKeys.contains(key))</span>
<span class="fc" id="L444">                                                .map(metadata.partitionKeyType::fromString)</span>
<span class="fc" id="L445">                                                .map(k -&gt; sstable.getPartitioner().decorateKey(k))</span>
<span class="fc" id="L446">                                                .sorted()</span>
<span class="fc" id="L447">                                                .map(DecoratedKey::getToken)</span>
<span class="fc" id="L448">                                                .map(token -&gt; new Bounds&lt;&gt;(token.minKeyBound(), token.maxKeyBound()))</span>
<span class="fc" id="L449">                                                .collect(Collectors.&lt;AbstractBounds&lt;PartitionPosition&gt;&gt;toList())</span>
<span class="fc" id="L450">                                                .iterator());</span>
            }
<span class="nc" id="L452">            catch (RuntimeException e)</span>
            {
<span class="nc" id="L454">                System.err.printf(&quot;Cannot use one or more partition keys in %s for the partition key type ('%s') &quot; +</span>
                                  &quot;of the underlying table: %s%n&quot;,
<span class="nc" id="L456">                                  Arrays.toString(keys),</span>
<span class="nc" id="L457">                                  metadata.partitionKeyType.asCQL3Type(), e);</span>
            }
        }
<span class="fc" id="L460">        return sstable.getScanner();</span>
    }

    private static void printSummary(TableMetadata metadata,
                                     ExtendedDescriptor desc,
                                     SSTableStats stats,
                                     List&lt;PartitionStats&gt; matches,
                                     boolean partitionsOnly)
    {
        // Print header
<span class="fc bfc" id="L470" title="All 2 branches covered.">        if (!matches.isEmpty())</span>
        {
<span class="fc" id="L472">            System.out.printf(&quot;Summary of %s:%n&quot; +</span>
                              &quot;  File: %s%n&quot; +
                              &quot;  %d partitions match%n&quot; +
<span class="fc" id="L475">                              &quot;  Keys:&quot;, desc, desc.descriptor.fileFor(BigFormat.Components.DATA), matches.size());</span>

<span class="fc bfc" id="L477" title="All 2 branches covered.">            for (PartitionStats match : matches)</span>
<span class="fc" id="L478">                System.out.print(&quot; &quot; + maybeEscapeKeyForSummary(metadata, match.key));</span>

<span class="fc" id="L480">            System.out.println();</span>
        }

        // Print stats table columns
        String format;
<span class="fc bfc" id="L485" title="All 2 branches covered.">        if (partitionsOnly)</span>
        {
<span class="fc" id="L487">            System.out.printf(&quot;         %20s%n&quot;, &quot;Partition size&quot;);</span>
<span class="fc" id="L488">            format = &quot;  %-5s  %20s%n&quot;;</span>
        }
        else
        {
<span class="fc" id="L492">            System.out.printf(&quot;         %20s %20s %20s %20s%n&quot;, &quot;Partition size&quot;, &quot;Row count&quot;, &quot;Cell count&quot;, &quot;Tombstone count&quot;);</span>
<span class="fc" id="L493">            format = &quot;  %-5s  %20s %20d %20d %20d%n&quot;;</span>
        }

        // Print approximate percentiles from the histograms
<span class="fc" id="L497">        printPercentile(partitionsOnly, stats, format, &quot;~p50&quot;, h -&gt; h.percentile(.5d));</span>
<span class="fc" id="L498">        printPercentile(partitionsOnly, stats, format, &quot;~p75&quot;, h -&gt; h.percentile(.75d));</span>
<span class="fc" id="L499">        printPercentile(partitionsOnly, stats, format, &quot;~p90&quot;, h -&gt; h.percentile(.90d));</span>
<span class="fc" id="L500">        printPercentile(partitionsOnly, stats, format, &quot;~p95&quot;, h -&gt; h.percentile(.95d));</span>
<span class="fc" id="L501">        printPercentile(partitionsOnly, stats, format, &quot;~p99&quot;, h -&gt; h.percentile(.99d));</span>
<span class="fc" id="L502">        printPercentile(partitionsOnly, stats, format, &quot;~p999&quot;, h -&gt; h.percentile(.999d));</span>

        // Print accurate metrics (min/max/count)
<span class="fc bfc" id="L505" title="All 2 branches covered.">        if (partitionsOnly)</span>
        {
<span class="fc" id="L507">            System.out.printf(format, &quot;min&quot;, prettyPrintMemory(stats.minSize));</span>
<span class="fc" id="L508">            System.out.printf(format, &quot;max&quot;, prettyPrintMemory(stats.maxSize));</span>
        }
        else
        {
<span class="fc" id="L512">            System.out.printf(format,</span>
                              &quot;min&quot;,
<span class="fc" id="L514">                              prettyPrintMemory(stats.minSize),</span>
<span class="fc" id="L515">                              stats.minRowCount,</span>
<span class="fc" id="L516">                              stats.minCellCount,</span>
<span class="fc" id="L517">                              stats.minTombstoneCount);</span>
<span class="fc" id="L518">            System.out.printf(format,</span>
                              &quot;max&quot;,
<span class="fc" id="L520">                              prettyPrintMemory(stats.maxSize),</span>
<span class="fc" id="L521">                              stats.maxRowCount,</span>
<span class="fc" id="L522">                              stats.maxCellCount,</span>
<span class="fc" id="L523">                              stats.maxTombstoneCount);</span>
        }
<span class="fc" id="L525">        System.out.printf(&quot;  count  %20d%n&quot;, stats.partitionSizeHistogram.count());</span>
<span class="fc" id="L526">    }</span>

    private static void printPercentile(boolean partitionsOnly,
                                        SSTableStats stats,
                                        String format,
                                        String header,
                                        ToLongFunction&lt;EstimatedHistogram&gt; value)
    {
<span class="fc bfc" id="L534" title="All 2 branches covered.">        if (partitionsOnly)</span>
        {
<span class="fc" id="L536">            System.out.printf(format,</span>
                              header,
<span class="fc" id="L538">                              prettyPrintMemory(value.applyAsLong(stats.partitionSizeHistogram)));</span>
        }
        else
        {
<span class="fc" id="L542">            System.out.printf(format,</span>
                              header,
<span class="fc" id="L544">                              prettyPrintMemory(value.applyAsLong(stats.partitionSizeHistogram)),</span>
<span class="fc" id="L545">                              value.applyAsLong(stats.rowCountHistogram),</span>
<span class="fc" id="L546">                              value.applyAsLong(stats.cellCountHistogram),</span>
<span class="fc" id="L547">                              value.applyAsLong(stats.tombstoneCountHistogram));</span>
        }
<span class="fc" id="L549">    }</span>

    private static String maybeEscapeKeyForSummary(TableMetadata metadata, ByteBuffer key)
    {
<span class="fc" id="L553">        String s = metadata.partitionKeyType.getString(key);</span>
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">        if (s.indexOf(' ') == -1)</span>
<span class="fc" id="L555">            return s;</span>
<span class="nc" id="L556">        return &quot;\&quot;&quot; + StringUtils.replace(s, &quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;) + &quot;\&quot;&quot;;</span>
    }

<span class="fc" id="L559">    static final class SSTableStats</span>
    {
        // EH of 155 can track a max value of 3520571548412 i.e. 3.5TB
<span class="fc" id="L562">        EstimatedHistogram partitionSizeHistogram = new EstimatedHistogram(155, true);</span>

        // EH of 118 can track a max value of 4139110981, i.e., &gt; 4B rows, cells or tombstones
<span class="fc" id="L565">        EstimatedHistogram rowCountHistogram = new EstimatedHistogram(118, true);</span>
<span class="fc" id="L566">        EstimatedHistogram cellCountHistogram = new EstimatedHistogram(118, true);</span>
<span class="fc" id="L567">        EstimatedHistogram tombstoneCountHistogram = new EstimatedHistogram(118, true);</span>

<span class="fc" id="L569">        long minSize = 0;</span>
<span class="fc" id="L570">        long maxSize = 0;</span>

<span class="fc" id="L572">        int minRowCount = 0;</span>
<span class="fc" id="L573">        int maxRowCount = 0;</span>

<span class="fc" id="L575">        int minCellCount = 0;</span>
<span class="fc" id="L576">        int maxCellCount = 0;</span>

<span class="fc" id="L578">        int minTombstoneCount = 0;</span>
<span class="fc" id="L579">        int maxTombstoneCount = 0;</span>

        void addPartition(PartitionStats stats)
        {
<span class="fc" id="L583">            partitionSizeHistogram.add(stats.size);</span>
<span class="fc" id="L584">            rowCountHistogram.add(stats.rowCount);</span>
<span class="fc" id="L585">            cellCountHistogram.add(stats.cellCount);</span>
<span class="fc" id="L586">            tombstoneCountHistogram.add(stats.tombstoneCount());</span>

<span class="pc bpc" id="L588" title="1 of 4 branches missed.">            if (minSize == 0 || stats.size &lt; minSize)</span>
<span class="fc" id="L589">                minSize = stats.size;</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">            if (stats.size &gt; maxSize)</span>
<span class="fc" id="L591">                maxSize = stats.size;</span>

<span class="pc bpc" id="L593" title="1 of 4 branches missed.">            if (minRowCount == 0 || stats.rowCount &lt; minRowCount)</span>
<span class="fc" id="L594">                minRowCount = stats.rowCount;</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">            if (stats.rowCount &gt; maxRowCount)</span>
<span class="fc" id="L596">                maxRowCount = stats.rowCount;</span>

<span class="pc bpc" id="L598" title="1 of 4 branches missed.">            if (minCellCount == 0 || stats.cellCount &lt; minCellCount)</span>
<span class="fc" id="L599">                minCellCount = stats.cellCount;</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">            if (stats.cellCount &gt; maxCellCount)</span>
<span class="fc" id="L601">                maxCellCount = stats.cellCount;</span>

<span class="pc bpc" id="L603" title="3 of 4 branches missed.">            if (minTombstoneCount == 0 || stats.tombstoneCount() &lt; minTombstoneCount)</span>
<span class="fc" id="L604">                minTombstoneCount = stats.tombstoneCount();</span>
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">            if (stats.tombstoneCount() &gt; maxTombstoneCount)</span>
<span class="nc" id="L606">                maxTombstoneCount = stats.tombstoneCount();</span>
<span class="fc" id="L607">        }</span>
    }

    static final class PartitionStats
    {
        final ByteBuffer key;
        final long offset;
        final boolean live;

<span class="fc" id="L616">        long size = -1;</span>
<span class="fc" id="L617">        int rowCount = 0;</span>
<span class="fc" id="L618">        int cellCount = 0;</span>
<span class="fc" id="L619">        int rowTombstoneCount = 0;</span>
<span class="fc" id="L620">        int rangeTombstoneCount = 0;</span>
<span class="fc" id="L621">        int complexTombstoneCount = 0;</span>
<span class="fc" id="L622">        int cellTombstoneCount = 0;</span>
<span class="fc" id="L623">        int rowTtlExpired = 0;</span>
<span class="fc" id="L624">        int cellTtlExpired = 0;</span>

        PartitionStats(ByteBuffer key, long offset, boolean live)
<span class="fc" id="L627">        {</span>
<span class="fc" id="L628">            this.key = key;</span>
<span class="fc" id="L629">            this.offset = offset;</span>
<span class="fc" id="L630">            this.live = live;</span>
<span class="fc" id="L631">        }</span>

        void endOfPartition(long position)
        {
<span class="fc" id="L635">            size = position - offset;</span>
<span class="fc" id="L636">        }</span>

        int tombstoneCount()
        {
<span class="fc" id="L640">            return rowTombstoneCount + rangeTombstoneCount + complexTombstoneCount + cellTombstoneCount + rowTtlExpired + cellTtlExpired;</span>
        }

        void addUnfiltered(ExtendedDescriptor desc, long currentTime, Unfiltered unfiltered)
        {
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">            if (unfiltered instanceof Row)</span>
            {
<span class="fc" id="L647">                Row row = (Row) unfiltered;</span>
<span class="fc" id="L648">                rowCount++;</span>

<span class="pc bpc" id="L650" title="1 of 2 branches missed.">                if (!row.deletion().isLive())</span>
<span class="nc" id="L651">                    rowTombstoneCount++;</span>

<span class="fc" id="L653">                LivenessInfo liveInfo = row.primaryKeyLivenessInfo();</span>
<span class="pc bpc" id="L654" title="3 of 6 branches missed.">                if (!liveInfo.isEmpty() &amp;&amp; liveInfo.isExpiring() &amp;&amp; liveInfo.localExpirationTime() &lt; currentTime)</span>
<span class="nc" id="L655">                    rowTtlExpired++;</span>

<span class="fc bfc" id="L657" title="All 2 branches covered.">                for (ColumnData cd : row)</span>
                {

<span class="pc bpc" id="L660" title="1 of 2 branches missed.">                    if (cd.column().isSimple())</span>
                    {
<span class="fc" id="L662">                        addCell((int) currentTime, liveInfo, (Cell&lt;?&gt;) cd);</span>
                    }
                    else
                    {
<span class="nc" id="L666">                        ComplexColumnData complexData = (ComplexColumnData) cd;</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">                        if (!complexData.complexDeletion().isLive())</span>
<span class="nc" id="L668">                            complexTombstoneCount++;</span>

<span class="nc bnc" id="L670" title="All 2 branches missed.">                        for (Cell&lt;?&gt; cell : complexData)</span>
<span class="nc" id="L671">                            addCell((int) currentTime, liveInfo, cell);</span>
                    }
<span class="fc" id="L673">                }</span>
<span class="fc" id="L674">            }</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">            else if (unfiltered instanceof RangeTombstoneMarker)</span>
            {
<span class="nc" id="L677">                rangeTombstoneCount++;</span>
            }
            else
            {
<span class="nc" id="L681">                throw new UnsupportedOperationException(&quot;Unknown kind &quot; + unfiltered.kind() + &quot; in sstable &quot; + desc.descriptor);</span>
            }
<span class="fc" id="L683">        }</span>

        private void addCell(int currentTime, LivenessInfo liveInfo, Cell&lt;?&gt; cell)
        {
<span class="fc" id="L687">            cellCount++;</span>
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">            if (cell.isTombstone())</span>
<span class="nc" id="L689">                cellTombstoneCount++;</span>
<span class="pc bpc" id="L690" title="7 of 8 branches missed.">            if (cell.isExpiring() &amp;&amp; (liveInfo.isEmpty() || cell.ttl() != liveInfo.ttl()) &amp;&amp; !cell.isLive(currentTime))</span>
<span class="nc" id="L691">                cellTtlExpired++;</span>
<span class="fc" id="L692">        }</span>

        void printPartitionInfo(TableMetadata metadata, boolean partitionsOnly)
        {
<span class="fc" id="L696">            String key = metadata.partitionKeyType.getString(this.key);</span>
<span class="fc bfc" id="L697" title="All 2 branches covered.">            if (partitionsOnly)</span>
<span class="fc" id="L698">                System.out.printf(&quot;  Partition: '%s' (%s) %s, size: %s%n&quot;,</span>
                                  key,
<span class="pc bpc" id="L700" title="1 of 2 branches missed.">                                  ByteBufferUtil.bytesToHex(this.key), live ? &quot;live&quot; : &quot;not live&quot;,</span>
<span class="fc" id="L701">                                  prettyPrintMemory(size));</span>
            else
<span class="fc" id="L703">                System.out.printf(&quot;  Partition: '%s' (%s) %s, size: %s, rows: %d, cells: %d, &quot; +</span>
                                  &quot;tombstones: %d (row:%d, range:%d, complex:%d, cell:%d, row-TTLd:%d, cell-TTLd:%d)%n&quot;,
                                  key,
<span class="fc" id="L706">                                  ByteBufferUtil.bytesToHex(this.key),</span>
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">                                  live ? &quot;live&quot; : &quot;not live&quot;,</span>
<span class="fc" id="L708">                                  prettyPrintMemory(size),</span>
<span class="fc" id="L709">                                  rowCount,</span>
<span class="fc" id="L710">                                  cellCount,</span>
<span class="fc" id="L711">                                  tombstoneCount(),</span>
<span class="fc" id="L712">                                  rowTombstoneCount,</span>
<span class="fc" id="L713">                                  rangeTombstoneCount,</span>
<span class="fc" id="L714">                                  complexTombstoneCount,</span>
<span class="fc" id="L715">                                  cellTombstoneCount,</span>
<span class="fc" id="L716">                                  rowTtlExpired,</span>
<span class="fc" id="L717">                                  cellTtlExpired);</span>
<span class="fc" id="L718">        }</span>

        void printPartitionInfoCSV(TableMetadata metadata, ExtendedDescriptor desc)
        {
<span class="fc" id="L722">            System.out.printf(&quot;\&quot;%s\&quot;,%s,%s,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%s,%s,%s,%s,%s,%s,%s,%s,%s%n&quot;,</span>
<span class="fc" id="L723">                              maybeEscapeKeyForSummary(metadata, key),</span>
<span class="fc" id="L724">                              ByteBufferUtil.bytesToHex(key),</span>
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">                              live ? &quot;true&quot; : &quot;false&quot;,</span>
<span class="fc" id="L726">                              offset, size,</span>
<span class="fc" id="L727">                              rowCount, cellCount, tombstoneCount(),</span>
<span class="fc" id="L728">                              rowTombstoneCount, rangeTombstoneCount, complexTombstoneCount, cellTombstoneCount,</span>
<span class="fc" id="L729">                              rowTtlExpired, cellTtlExpired,</span>
<span class="fc" id="L730">                              desc.descriptor.fileFor(BigFormat.Components.DATA),</span>
<span class="fc" id="L731">                              notNull(desc.keyspace),</span>
<span class="fc" id="L732">                              notNull(desc.table),</span>
<span class="fc" id="L733">                              notNull(desc.index),</span>
<span class="fc" id="L734">                              notNull(desc.snapshot),</span>
<span class="fc" id="L735">                              notNull(desc.backup),</span>
                              desc.descriptor.id,
<span class="fc" id="L737">                              desc.descriptor.version.format.name(),</span>
                              desc.descriptor.version.version);
<span class="fc" id="L739">        }</span>
    }

    static final class ExtendedDescriptor implements Comparable&lt;ExtendedDescriptor&gt;
    {
        final String keyspace;
        final String table;
        final String index;
        final String snapshot;
        final String backup;
        final TableId tableId;
        final Descriptor descriptor;

        ExtendedDescriptor(String keyspace, String table, TableId tableId, String index, String snapshot, String backup, Descriptor descriptor)
<span class="fc" id="L753">        {</span>
<span class="fc" id="L754">            this.keyspace = keyspace;</span>
<span class="fc" id="L755">            this.table = table;</span>
<span class="fc" id="L756">            this.tableId = tableId;</span>
<span class="fc" id="L757">            this.index = index;</span>
<span class="fc" id="L758">            this.snapshot = snapshot;</span>
<span class="fc" id="L759">            this.backup = backup;</span>
<span class="fc" id="L760">            this.descriptor = descriptor;</span>
<span class="fc" id="L761">        }</span>

        @Override
        public String toString()
        {
<span class="fc" id="L766">            StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">            if (backup != null)</span>
<span class="fc" id="L768">                sb.append(&quot;Backup:&quot;).append(backup).append(' ');</span>
<span class="fc bfc" id="L769" title="All 2 branches covered.">            if (snapshot != null)</span>
<span class="fc" id="L770">                sb.append(&quot;Snapshot:&quot;).append(snapshot).append(' ');</span>
<span class="pc bpc" id="L771" title="1 of 2 branches missed.">            if (keyspace != null)</span>
<span class="nc" id="L772">                sb.append(keyspace).append('.');</span>
<span class="pc bpc" id="L773" title="1 of 2 branches missed.">            if (table != null)</span>
<span class="nc" id="L774">                sb.append(table);</span>
<span class="pc bpc" id="L775" title="1 of 2 branches missed.">            if (index != null)</span>
<span class="nc" id="L776">                sb.append('.').append(index);</span>
<span class="pc bpc" id="L777" title="1 of 2 branches missed.">            if (tableId != null)</span>
<span class="nc" id="L778">                sb.append('-').append(tableId.toHexString());</span>
<span class="fc" id="L779">            return sb.append(&quot; #&quot;)</span>
<span class="fc" id="L780">                     .append(descriptor.id)</span>
<span class="fc" id="L781">                     .append(&quot; (&quot;)</span>
<span class="fc" id="L782">                     .append(descriptor.version.format.name())</span>
<span class="fc" id="L783">                     .append('-')</span>
<span class="fc" id="L784">                     .append(descriptor.version.version)</span>
<span class="fc" id="L785">                     .append(')')</span>
<span class="fc" id="L786">                     .toString();</span>
        }

        static ExtendedDescriptor guessFromFile(File fArg)
        {
<span class="fc" id="L791">            Descriptor desc = Descriptor.fromFile(fArg);</span>

<span class="fc" id="L793">            String snapshot = null;</span>
<span class="fc" id="L794">            String backup = null;</span>
<span class="fc" id="L795">            String index = null;</span>

<span class="fc" id="L797">            File parent = fArg.parent();</span>
<span class="fc" id="L798">            File grandparent = parent.parent();</span>

<span class="pc bpc" id="L800" title="4 of 6 branches missed.">            if (parent.name().length() &gt; 1 &amp;&amp; parent.name().startsWith(&quot;.&quot;) &amp;&amp; parent.name().charAt(1) != '.')</span>
            {
<span class="nc" id="L802">                index = parent.name().substring(1);</span>
<span class="nc" id="L803">                parent = parent.parent();</span>
<span class="nc" id="L804">                grandparent = parent.parent();</span>
            }

<span class="fc bfc" id="L807" title="All 2 branches covered.">            if (parent.name().equals(Directories.BACKUPS_SUBDIR))</span>
            {
<span class="fc" id="L809">                backup = parent.name();</span>
<span class="fc" id="L810">                parent = parent.parent();</span>
<span class="fc" id="L811">                grandparent = parent.parent();</span>
            }

<span class="fc bfc" id="L814" title="All 2 branches covered.">            if (grandparent.name().equals(Directories.SNAPSHOT_SUBDIR))</span>
            {
<span class="fc" id="L816">                snapshot = parent.name();</span>
<span class="fc" id="L817">                parent = grandparent.parent();</span>
<span class="fc" id="L818">                grandparent = parent.parent();</span>
            }

            try
            {
<span class="fc" id="L823">                Pair&lt;String, TableId&gt; tableNameAndId = TableId.tableNameAndIdFromFilename(parent.name());</span>
<span class="pc bpc" id="L824" title="1 of 2 branches missed.">                if (tableNameAndId != null)</span>
                {
<span class="nc" id="L826">                    return new ExtendedDescriptor(grandparent.name(),</span>
                                                  tableNameAndId.left,
                                                  tableNameAndId.right,
                                                  index,
                                                  snapshot,
                                                  backup,
                                                  desc);
                }
            }
<span class="nc" id="L835">            catch (NumberFormatException e)</span>
            {
                // ignore non-parseable table-IDs
<span class="fc" id="L838">            }</span>

<span class="fc" id="L840">            return new ExtendedDescriptor(null,</span>
                                          null,
                                          null,
                                          index,
                                          snapshot,
                                          backup,
                                          desc);
        }

        @Override
        public int compareTo(ExtendedDescriptor o)
        {
<span class="fc" id="L852">            int c = descriptor.directory.toString().compareTo(o.descriptor.directory.toString());</span>
<span class="pc bpc" id="L853" title="1 of 2 branches missed.">            if (c != 0)</span>
<span class="fc" id="L854">                return c;</span>
<span class="nc" id="L855">            c = notNull(keyspace).compareTo(notNull(o.keyspace));</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">            if (c != 0)</span>
<span class="nc" id="L857">                return c;</span>
<span class="nc" id="L858">            c = notNull(table).compareTo(notNull(o.table));</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">            if (c != 0)</span>
<span class="nc" id="L860">                return c;</span>
<span class="nc" id="L861">            c = notNull(tableId).toString().compareTo(notNull(o.tableId).toString());</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">            if (c != 0)</span>
<span class="nc" id="L863">                return c;</span>
<span class="nc" id="L864">            c = notNull(index).compareTo(notNull(o.index));</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">            if (c != 0)</span>
<span class="nc" id="L866">                return c;</span>
<span class="nc" id="L867">            c = notNull(snapshot).compareTo(notNull(o.snapshot));</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">            if (c != 0)</span>
<span class="nc" id="L869">                return c;</span>
<span class="nc" id="L870">            c = notNull(backup).compareTo(notNull(o.backup));</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">            if (c != 0)</span>
<span class="nc" id="L872">                return c;</span>
<span class="nc" id="L873">            c = notNull(descriptor.id.toString()).compareTo(notNull(o.descriptor.id.toString()));</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">            if (c != 0)</span>
<span class="nc" id="L875">                return c;</span>
<span class="nc" id="L876">            return Integer.compare(System.identityHashCode(this), System.identityHashCode(o));</span>
        }
    }

    private static String notNull(String s)
    {
<span class="pc bpc" id="L882" title="1 of 2 branches missed.">        return s != null ? s : &quot;&quot;;</span>
    }

    private static TableId notNull(TableId s)
    {
<span class="nc bnc" id="L887" title="All 2 branches missed.">        return s != null ? s : EMPTY_TABLE_ID;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>