<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SSTableMetadataViewer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.tools</a> &gt; <span class="el_source">SSTableMetadataViewer.java</span></div><h1>SSTableMetadataViewer.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.tools;

import java.io.IOException;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.nio.ByteBuffer;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

import com.google.common.collect.MinMaxPriorityQueue;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.cli.PosixParser;

import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.ClusteringComparator;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.SerializationHeader;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.marshal.UTF8Type;
import org.apache.cassandra.db.rows.EncodingStats;
import org.apache.cassandra.db.rows.Row;
import org.apache.cassandra.db.rows.Unfiltered;
import org.apache.cassandra.db.rows.UnfilteredRowIterator;
import org.apache.cassandra.dht.IPartitioner;
import org.apache.cassandra.io.compress.CompressionMetadata;
import org.apache.cassandra.io.compress.ICompressor;
import org.apache.cassandra.io.sstable.Descriptor;
import org.apache.cassandra.io.sstable.ISSTableScanner;
import org.apache.cassandra.io.sstable.format.CompressionInfoComponent;
import org.apache.cassandra.io.sstable.format.SSTableReader;
import org.apache.cassandra.io.sstable.format.StatsComponent;
import org.apache.cassandra.io.sstable.metadata.CompactionMetadata;
import org.apache.cassandra.io.sstable.metadata.StatsMetadata;
import org.apache.cassandra.io.sstable.metadata.ValidationMetadata;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.schema.TableMetadataRef;
import org.apache.cassandra.tools.Util.TermHistogram;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.Pair;

import static org.apache.cassandra.tools.Util.BLUE;
import static org.apache.cassandra.tools.Util.CYAN;
import static org.apache.cassandra.tools.Util.RESET;
import static org.apache.cassandra.tools.Util.WHITE;
import static org.apache.cassandra.utils.Clock.Global.currentTimeMillis;
import static org.apache.commons.lang3.time.DurationFormatUtils.formatDurationWords;

/**
 * Shows the contents of sstable metadata
 */
public class SSTableMetadataViewer
{
<span class="fc" id="L79">    private static final Options options = new Options();</span>
    private static CommandLine cmd;
    private static final String COLORS = &quot;c&quot;;
    private static final String UNICODE = &quot;u&quot;;
    private static final String GCGS_KEY = &quot;g&quot;;
    private static final String TIMESTAMP_UNIT = &quot;t&quot;;
    private static final String SCAN = &quot;s&quot;;
    private static final String HELP = &quot;h&quot;;
<span class="fc" id="L87">    private static final Comparator&lt;ValuedByteBuffer&gt; VCOMP = Comparator.comparingLong(ValuedByteBuffer::getValue).reversed();</span>

    static
    {
<span class="fc" id="L91">        DatabaseDescriptor.toolInitialization();</span>
<span class="fc" id="L92">    }</span>

    boolean color;
    boolean unicode;
    int gc;
    PrintStream out;
    String[] files;
    TimeUnit tsUnit;

    public SSTableMetadataViewer()
    {
<span class="nc" id="L103">        this(true, true, 0, TimeUnit.MICROSECONDS, System.out);</span>
<span class="nc" id="L104">    }</span>

    public SSTableMetadataViewer(boolean color, boolean unicode, int gc, TimeUnit tsUnit, PrintStream out)
<span class="fc" id="L107">    {</span>
<span class="fc" id="L108">        this.color = color;</span>
<span class="fc" id="L109">        this.tsUnit = tsUnit;</span>
<span class="fc" id="L110">        this.unicode = unicode;</span>
<span class="fc" id="L111">        this.out = out;</span>
<span class="fc" id="L112">        this.gc = gc;</span>
<span class="fc" id="L113">    }</span>

    public static String deletion(long time)
    {
<span class="pc bpc" id="L117" title="2 of 4 branches missed.">        if (time == 0 || time == Long.MAX_VALUE)</span>
        {
<span class="fc" id="L119">            return &quot;no tombstones&quot;;</span>
        }
<span class="nc" id="L121">        return toDateString(time, TimeUnit.SECONDS);</span>
    }

    public static String toDateString(long time, TimeUnit unit)
    {
<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (time == 0)</span>
        {
<span class="fc" id="L128">            return null;</span>
        }
<span class="fc" id="L130">        return new java.text.SimpleDateFormat(&quot;MM/dd/yyyy HH:mm:ss&quot;).format(new java.util.Date(unit.toMillis(time)));</span>
    }

    public static String toDurationString(long duration, TimeUnit unit)
    {
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">        if (duration == 0)</span>
        {
<span class="fc" id="L137">            return null;</span>
        }
<span class="nc bnc" id="L139" title="All 2 branches missed.">        else if (duration == Integer.MAX_VALUE)</span>
        {
<span class="nc" id="L141">            return &quot;never&quot;;</span>
        }
<span class="nc" id="L143">        return formatDurationWords(unit.toMillis(duration), true, true);</span>
    }

    public static String toByteString(long bytes)
    {
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">        if (bytes == 0)</span>
<span class="nc" id="L149">            return null;</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">        else if (bytes &lt; 1024)</span>
<span class="fc" id="L151">            return bytes + &quot; B&quot;;</span>

<span class="fc" id="L153">        int exp = (int) (Math.log(bytes) / Math.log(1024));</span>
<span class="fc" id="L154">        char pre = &quot;kMGTP&quot;.charAt(exp - 1);</span>
<span class="fc" id="L155">        return String.format(&quot;%.1f %sB&quot;, bytes / Math.pow(1024, exp), pre);</span>
    }

    public String scannedOverviewOutput(String key, long value)
    {
<span class="fc" id="L160">        StringBuilder sb = new StringBuilder();</span>
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">        if (color) sb.append(CYAN);</span>
<span class="fc" id="L162">        sb.append('[');</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">        if (color) sb.append(RESET);</span>
<span class="fc" id="L164">        sb.append(key);</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">        if (color) sb.append(CYAN);</span>
<span class="fc" id="L166">        sb.append(&quot;] &quot;);</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">        if (color) sb.append(RESET);</span>
<span class="fc" id="L168">        sb.append(value);</span>
<span class="fc" id="L169">        return sb.toString();</span>
    }

    private void printScannedOverview(Descriptor descriptor, StatsMetadata stats) throws IOException
    {
<span class="fc" id="L174">        TableMetadata cfm = Util.metadataFromSSTable(descriptor);</span>
<span class="fc" id="L175">        SSTableReader reader = SSTableReader.openNoValidation(null, descriptor, TableMetadataRef.forOfflineTools(cfm));</span>
<span class="fc" id="L176">        try (ISSTableScanner scanner = reader.getScanner())</span>
        {
<span class="fc" id="L178">            long bytes = scanner.getLengthInBytes();</span>
<span class="fc" id="L179">            MinMaxPriorityQueue&lt;ValuedByteBuffer&gt; widestPartitions = MinMaxPriorityQueue</span>
<span class="fc" id="L180">                                                                     .orderedBy(VCOMP)</span>
<span class="fc" id="L181">                                                                     .maximumSize(5)</span>
<span class="fc" id="L182">                                                                     .create();</span>
<span class="fc" id="L183">            MinMaxPriorityQueue&lt;ValuedByteBuffer&gt; largestPartitions = MinMaxPriorityQueue</span>
<span class="fc" id="L184">                                                                      .orderedBy(VCOMP)</span>
<span class="fc" id="L185">                                                                      .maximumSize(5)</span>
<span class="fc" id="L186">                                                                      .create();</span>
<span class="fc" id="L187">            MinMaxPriorityQueue&lt;ValuedByteBuffer&gt; mostTombstones = MinMaxPriorityQueue</span>
<span class="fc" id="L188">                                                                   .orderedBy(VCOMP)</span>
<span class="fc" id="L189">                                                                   .maximumSize(5)</span>
<span class="fc" id="L190">                                                                   .create();</span>
<span class="fc" id="L191">            long partitionCount = 0;</span>
<span class="fc" id="L192">            long rowCount = 0;</span>
<span class="fc" id="L193">            long tombstoneCount = 0;</span>
<span class="fc" id="L194">            long cellCount = 0;</span>
<span class="fc" id="L195">            double totalCells = stats.totalColumnsSet;</span>
<span class="fc" id="L196">            int lastPercent = 0;</span>
<span class="fc" id="L197">            long lastPercentTime = 0;</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">            while (scanner.hasNext())</span>
            {
<span class="fc" id="L200">                try (UnfilteredRowIterator partition = scanner.next())</span>
                {

<span class="fc" id="L203">                    long psize = 0;</span>
<span class="fc" id="L204">                    long pcount = 0;</span>
<span class="fc" id="L205">                    int ptombcount = 0;</span>
<span class="fc" id="L206">                    partitionCount++;</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">                    if (!partition.staticRow().isEmpty())</span>
                    {
<span class="nc" id="L209">                        rowCount++;</span>
<span class="nc" id="L210">                        pcount++;</span>
<span class="nc" id="L211">                        psize += partition.staticRow().dataSize();</span>
                    }
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">                    if (!partition.partitionLevelDeletion().isLive())</span>
                    {
<span class="nc" id="L215">                        tombstoneCount++;</span>
<span class="nc" id="L216">                        ptombcount++;</span>
                    }
<span class="fc bfc" id="L218" title="All 2 branches covered.">                    while (partition.hasNext())</span>
                    {
<span class="fc" id="L220">                        Unfiltered unfiltered = partition.next();</span>
<span class="pc bpc" id="L221" title="2 of 3 branches missed.">                        switch (unfiltered.kind())</span>
                        {
                            case ROW:
<span class="fc" id="L224">                                rowCount++;</span>
<span class="fc" id="L225">                                Row row = (Row) unfiltered;</span>
<span class="fc" id="L226">                                psize += row.dataSize();</span>
<span class="fc" id="L227">                                pcount++;</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">                                for (org.apache.cassandra.db.rows.Cell&lt;?&gt; cell : row.cells())</span>
                                {
<span class="fc" id="L230">                                    cellCount++;</span>
<span class="fc" id="L231">                                    double percentComplete = Math.min(1.0, cellCount / totalCells);</span>
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">                                    if (lastPercent != (int) (percentComplete * 100) &amp;&amp;</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">                                        (currentTimeMillis() - lastPercentTime) &gt; 1000)</span>
                                    {
<span class="fc" id="L235">                                        lastPercentTime = currentTimeMillis();</span>
<span class="fc" id="L236">                                        lastPercent = (int) (percentComplete * 100);</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">                                        if (color)</span>
<span class="nc" id="L238">                                            out.printf(&quot;\r%sAnalyzing SSTable...  %s%s %s(%%%s)&quot;, BLUE, CYAN,</span>
<span class="nc" id="L239">                                                       Util.progress(percentComplete, 30, unicode),</span>
                                                       RESET,
<span class="nc" id="L241">                                                       (int) (percentComplete * 100));</span>
                                        else
<span class="fc" id="L243">                                            out.printf(&quot;\rAnalyzing SSTable...  %s (%%%s)&quot;,</span>
<span class="fc" id="L244">                                                       Util.progress(percentComplete, 30, unicode),</span>
<span class="fc" id="L245">                                                       (int) (percentComplete * 100));</span>
<span class="fc" id="L246">                                        out.flush();</span>
                                    }
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">                                    if (cell.isTombstone())</span>
                                    {
<span class="nc" id="L250">                                        tombstoneCount++;</span>
<span class="nc" id="L251">                                        ptombcount++;</span>
                                    }
<span class="fc" id="L253">                                }</span>
<span class="fc" id="L254">                                break;</span>
                            case RANGE_TOMBSTONE_MARKER:
<span class="nc" id="L256">                                tombstoneCount++;</span>
<span class="nc" id="L257">                                ptombcount++;</span>
                                break;
                        }
<span class="fc" id="L260">                    }</span>

<span class="fc" id="L262">                    widestPartitions.add(new ValuedByteBuffer(partition.partitionKey().getKey(), pcount));</span>
<span class="fc" id="L263">                    largestPartitions.add(new ValuedByteBuffer(partition.partitionKey().getKey(), psize));</span>
<span class="fc" id="L264">                    mostTombstones.add(new ValuedByteBuffer(partition.partitionKey().getKey(), ptombcount));</span>
                }
            }

<span class="fc" id="L268">            out.printf(&quot;\r%80s\r&quot;, &quot; &quot;);</span>
<span class="fc" id="L269">            field(&quot;Size&quot;, bytes);</span>
<span class="fc" id="L270">            field(&quot;Partitions&quot;, partitionCount);</span>
<span class="fc" id="L271">            field(&quot;Rows&quot;, rowCount);</span>
<span class="fc" id="L272">            field(&quot;Tombstones&quot;, tombstoneCount);</span>
<span class="fc" id="L273">            field(&quot;Cells&quot;, cellCount);</span>
<span class="fc" id="L274">            field(&quot;Widest Partitions&quot;, &quot;&quot;);</span>
<span class="fc" id="L275">            Util.iterToStream(widestPartitions.iterator()).sorted(VCOMP).forEach(p -&gt;</span>
                                                                                 {
<span class="fc" id="L277">                                                                                     out.println(&quot;  &quot; + scannedOverviewOutput(cfm.partitionKeyType.getString(p.buffer), p.value));</span>
<span class="fc" id="L278">                                                                                 });</span>
<span class="fc" id="L279">            field(&quot;Largest Partitions&quot;, &quot;&quot;);</span>
<span class="fc" id="L280">            Util.iterToStream(largestPartitions.iterator()).sorted(VCOMP).forEach(p -&gt;</span>
                                                                                  {
<span class="fc" id="L282">                                                                                      out.print(&quot;  &quot;);</span>
<span class="fc" id="L283">                                                                                      out.print(scannedOverviewOutput(cfm.partitionKeyType.getString(p.buffer), p.value));</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">                                                                                      if (color)</span>
<span class="nc" id="L285">                                                                                          out.print(WHITE);</span>
<span class="fc" id="L286">                                                                                      out.print(&quot; (&quot;);</span>
<span class="fc" id="L287">                                                                                      out.print(toByteString(p.value));</span>
<span class="fc" id="L288">                                                                                      out.print(&quot;)&quot;);</span>
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">                                                                                      if (color)</span>
<span class="nc" id="L290">                                                                                          out.print(RESET);</span>
<span class="fc" id="L291">                                                                                      out.println();</span>
<span class="fc" id="L292">                                                                                  });</span>
<span class="fc" id="L293">            StringBuilder tleaders = new StringBuilder();</span>
<span class="fc" id="L294">            Util.iterToStream(mostTombstones.iterator()).sorted(VCOMP).forEach(p -&gt;</span>
                                                                               {
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">                                                                                   if (p.value &gt; 0)</span>
                                                                                   {
<span class="nc" id="L298">                                                                                       tleaders.append(&quot;  &quot;);</span>
<span class="nc" id="L299">                                                                                       tleaders.append(scannedOverviewOutput(cfm.partitionKeyType.getString(p.buffer), p.value));</span>
<span class="nc" id="L300">                                                                                       tleaders.append(System.lineSeparator());</span>
                                                                                   }
<span class="fc" id="L302">                                                                               });</span>
<span class="fc" id="L303">            String tombstoneLeaders = tleaders.toString();</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">            if (tombstoneLeaders.length() &gt; 10)</span>
            {
<span class="nc" id="L306">                field(&quot;Tombstone Leaders&quot;, &quot;&quot;);</span>
<span class="nc" id="L307">                out.print(tombstoneLeaders);</span>
            }
        }
        finally
        {
<span class="fc" id="L312">            reader.selfRef().ensureReleased();</span>
        }
<span class="fc" id="L314">    }</span>

    private void printSStableMetadata(File file, boolean scan) throws IOException
    {
<span class="fc" id="L318">        Descriptor descriptor = Descriptor.fromFileWithComponent(file, false).left;</span>
<span class="fc" id="L319">        StatsComponent statsComponent = StatsComponent.load(descriptor);</span>
<span class="fc" id="L320">        ValidationMetadata validation = statsComponent.validationMetadata();</span>
<span class="fc" id="L321">        StatsMetadata stats = statsComponent.statsMetadata();</span>
<span class="fc" id="L322">        CompactionMetadata compaction = statsComponent.compactionMetadata();</span>
<span class="fc" id="L323">        SerializationHeader.Component header = statsComponent.serializationHeader();</span>
<span class="fc" id="L324">        Class&lt;? extends ICompressor&gt; compressorClass = null;</span>
<span class="fc" id="L325">        try (CompressionMetadata compression = CompressionInfoComponent.loadIfExists(descriptor))</span>
        {
<span class="fc bfc" id="L327" title="All 2 branches covered.">            compressorClass = compression != null ? compression.compressor().getClass() : null;</span>
        }

<span class="fc" id="L330">        field(&quot;SSTable&quot;, descriptor);</span>
<span class="pc bpc" id="L331" title="1 of 4 branches missed.">        if (scan &amp;&amp; descriptor.version.version.compareTo(&quot;ma&quot;) &gt;= 0)</span>
        {
<span class="fc" id="L333">            printScannedOverview(descriptor, stats);</span>
        }
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">        if (validation != null)</span>
        {
<span class="fc" id="L337">            field(&quot;Partitioner&quot;, validation.partitioner);</span>
<span class="fc" id="L338">            field(&quot;Bloom Filter FP chance&quot;, validation.bloomFilterFPChance);</span>
        }
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">        if (stats != null)</span>
        {
<span class="fc" id="L342">            TimeUnit tsUnit = TimeUnit.MICROSECONDS;</span>
<span class="fc" id="L343">            field(&quot;Minimum timestamp&quot;, toDateString(stats.minTimestamp, tsUnit), Long.toString(stats.minTimestamp));</span>
<span class="fc" id="L344">            field(&quot;Maximum timestamp&quot;, toDateString(stats.maxTimestamp, tsUnit), Long.toString(stats.maxTimestamp));</span>
<span class="fc" id="L345">            field(&quot;Duration&quot;, durationString(stats.maxTimestamp - stats.minTimestamp));</span>
<span class="fc" id="L346">            field(&quot;SSTable min local deletion time&quot;, deletion(stats.minLocalDeletionTime), Long.toString(stats.minLocalDeletionTime));</span>
<span class="fc" id="L347">            field(&quot;SSTable max local deletion time&quot;, deletion(stats.maxLocalDeletionTime), Long.toString(stats.maxLocalDeletionTime));</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">            field(&quot;Compressor&quot;, compressorClass != null ? compressorClass.getName() : &quot;-&quot;);</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">            if (compressorClass != null)</span>
<span class="fc" id="L350">                field(&quot;Compression ratio&quot;, stats.compressionRatio);</span>
<span class="fc" id="L351">            field(&quot;TTL min&quot;, stats.minTTL, toDurationString(stats.minTTL, TimeUnit.SECONDS));</span>
<span class="fc" id="L352">            field(&quot;TTL max&quot;, stats.maxTTL, toDurationString(stats.maxTTL, TimeUnit.SECONDS));</span>

<span class="pc bpc" id="L354" title="2 of 4 branches missed.">            if (validation != null &amp;&amp; header != null)</span>
<span class="fc" id="L355">                printMinMaxToken(descriptor, FBUtilities.newPartitioner(descriptor), header.getKeyType(), stats);</span>

<span class="pc bpc" id="L357" title="1 of 2 branches missed.">            if (header != null)</span>
            {
<span class="fc" id="L359">                ClusteringComparator comparator = new ClusteringComparator(header.getClusteringTypes());</span>
<span class="fc" id="L360">                field(&quot;Covered clusterings&quot;, stats.coveredClustering.toString(comparator));</span>
            }
<span class="fc" id="L362">            field(&quot;Estimated droppable tombstones&quot;,</span>
<span class="fc" id="L363">                  stats.getEstimatedDroppableTombstoneRatio((int) (currentTimeMillis() / 1000) - this.gc));</span>
<span class="fc" id="L364">            field(&quot;SSTable Level&quot;, stats.sstableLevel);</span>
<span class="fc" id="L365">            field(&quot;Repaired at&quot;, stats.repairedAt, toDateString(stats.repairedAt, TimeUnit.MILLISECONDS));</span>
<span class="fc" id="L366">            field(&quot;Originating host id&quot;, stats.originatingHostId);</span>
<span class="fc" id="L367">            field(&quot;Pending repair&quot;, stats.pendingRepair);</span>
<span class="fc" id="L368">            field(&quot;Replay positions covered&quot;, stats.commitLogIntervals);</span>
<span class="fc" id="L369">            field(&quot;totalColumnsSet&quot;, stats.totalColumnsSet);</span>
<span class="fc" id="L370">            field(&quot;totalRows&quot;, stats.totalRows);</span>
<span class="fc" id="L371">            field(&quot;Estimated tombstone drop times&quot;, &quot;&quot;);</span>

<span class="fc" id="L373">            TermHistogram estDropped = new TermHistogram(stats.estimatedTombstoneDropTime,</span>
                                                         &quot;Drop Time&quot;,
<span class="fc" id="L375">                                                         offset -&gt; String.format(&quot;%d %s&quot;,</span>
<span class="fc" id="L376">                                                                offset,</span>
<span class="fc" id="L377">                                                                Util.wrapQuiet(toDateString(offset, TimeUnit.SECONDS),</span>
                                                                                        color)),
                                                         String::valueOf);
<span class="fc" id="L380">            estDropped.printHistogram(out, color, unicode);</span>
<span class="fc" id="L381">            field(&quot;Partition Size&quot;, &quot;&quot;);</span>
<span class="fc" id="L382">            TermHistogram rowSize = new TermHistogram(stats.estimatedPartitionSize,</span>
                                                      &quot;Size (bytes)&quot;,
<span class="fc" id="L384">                                                      offset -&gt; String.format(&quot;%d %s&quot;,</span>
<span class="fc" id="L385">                                                                              offset,</span>
<span class="fc" id="L386">                                                                              Util.wrapQuiet(toByteString(offset), color)),</span>
                                                      String::valueOf);
<span class="fc" id="L388">            rowSize.printHistogram(out, color, unicode);</span>
<span class="fc" id="L389">            field(&quot;Column Count&quot;, &quot;&quot;);</span>
<span class="fc" id="L390">            TermHistogram cellCount = new TermHistogram(stats.estimatedCellPerPartitionCount,</span>
                                                        &quot;Columns&quot;,
                                                        String::valueOf,
                                                        String::valueOf);
<span class="fc" id="L394">            cellCount.printHistogram(out, color, unicode);</span>
<span class="fc" id="L395">            field(&quot;Local token space coverage&quot;, stats.tokenSpaceCoverage);</span>
        }
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">        if (compaction != null)</span>
        {
<span class="fc" id="L399">            field(&quot;Estimated cardinality&quot;, compaction.cardinalityEstimator.cardinality());</span>
        }
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">        if (header != null)</span>
        {
<span class="fc" id="L403">            EncodingStats encodingStats = header.getEncodingStats();</span>
<span class="fc" id="L404">            AbstractType&lt;?&gt; keyType = header.getKeyType();</span>
<span class="fc" id="L405">            List&lt;AbstractType&lt;?&gt;&gt; clusteringTypes = header.getClusteringTypes();</span>
<span class="fc" id="L406">            Map&lt;ByteBuffer, AbstractType&lt;?&gt;&gt; staticColumns = header.getStaticColumns();</span>
<span class="fc" id="L407">            Map&lt;String, String&gt; statics = staticColumns.entrySet().stream()</span>
<span class="pc" id="L408">                    .collect(Collectors.toMap(e -&gt; UTF8Type.instance.getString(e.getKey()),</span>
<span class="nc" id="L409">                                              e -&gt; e.getValue().toString()));</span>
<span class="fc" id="L410">            Map&lt;ByteBuffer, AbstractType&lt;?&gt;&gt; regularColumns = header.getRegularColumns();</span>
<span class="fc" id="L411">            Map&lt;String, String&gt; regulars = regularColumns.entrySet().stream()</span>
<span class="fc" id="L412">                    .collect(Collectors.toMap(e -&gt; UTF8Type.instance.getString(e.getKey()),</span>
<span class="fc" id="L413">                                              e -&gt; e.getValue().toString()));</span>

<span class="fc" id="L415">            field(&quot;EncodingStats minTTL&quot;, encodingStats.minTTL,</span>
<span class="fc" id="L416">                    toDurationString(encodingStats.minTTL, TimeUnit.SECONDS));</span>
<span class="fc" id="L417">            field(&quot;EncodingStats minLocalDeletionTime&quot;, toDateString(encodingStats.minLocalDeletionTime,</span>
<span class="fc" id="L418">                    TimeUnit.SECONDS), Long.toString(encodingStats.minLocalDeletionTime));</span>
<span class="fc" id="L419">            field(&quot;EncodingStats minTimestamp&quot;, toDateString(encodingStats.minTimestamp, tsUnit),</span>
<span class="fc" id="L420">                    Long.toString(encodingStats.minTimestamp));</span>
<span class="fc" id="L421">            field(&quot;KeyType&quot;, keyType.toString());</span>
<span class="fc" id="L422">            field(&quot;ClusteringTypes&quot;, clusteringTypes.toString());</span>
<span class="fc" id="L423">            field(&quot;StaticColumns&quot;, FBUtilities.toString(statics));</span>
<span class="fc" id="L424">            field(&quot;RegularColumns&quot;, FBUtilities.toString(regulars));</span>
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">            if (stats != null)</span>
<span class="fc" id="L426">                field(&quot;IsTransient&quot;, stats.isTransient);</span>
        }
<span class="fc" id="L428">    }</span>

    private void field(String field, Object value)
    {
<span class="fc" id="L432">        field(field, value, null);</span>
<span class="fc" id="L433">    }</span>

    private void field(String field, Object value, String comment)
    {
<span class="fc" id="L437">        StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">        if (color) sb.append(BLUE);</span>
<span class="fc" id="L439">        sb.append(field);</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">        if (color) sb.append(CYAN);</span>
<span class="fc" id="L441">        sb.append(&quot;: &quot;);</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">        if (color) sb.append(RESET);</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">        sb.append(value == null? &quot;--&quot; : value.toString());</span>

<span class="fc bfc" id="L445" title="All 2 branches covered.">        if (comment != null)</span>
        {
<span class="fc bfc" id="L447" title="All 2 branches covered.">            if (color) sb.append(WHITE);</span>
<span class="fc" id="L448">            sb.append(&quot; (&quot;);</span>
<span class="fc" id="L449">            sb.append(comment);</span>
<span class="fc" id="L450">            sb.append(')');</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">            if (color) sb.append(RESET);</span>
        }
<span class="fc" id="L453">        this.out.println(sb);</span>
<span class="fc" id="L454">    }</span>

    public static String durationString(Long value)
    {
<span class="fc" id="L458">        long seconds  = TimeUnit.MICROSECONDS.toSeconds(value);</span>
<span class="fc" id="L459">        long day = TimeUnit.SECONDS.toDays(seconds);</span>
<span class="fc" id="L460">        long hours = TimeUnit.SECONDS.toHours(seconds) - (day * 24);</span>
<span class="fc" id="L461">        long minute = TimeUnit.SECONDS.toMinutes(seconds) - (TimeUnit.SECONDS.toHours(seconds) * 60);</span>
<span class="fc" id="L462">        long second = TimeUnit.SECONDS.toSeconds(seconds) - (TimeUnit.SECONDS.toMinutes(seconds) * 60);</span>
<span class="fc" id="L463">        return &quot;Days: &quot; + day + &quot; Hours: &quot; + hours + &quot; Minutes: &quot; + minute + &quot; Seconds: &quot; + second;</span>
    }

    private static void printUsage()
    {
<span class="fc" id="L468">        try (PrintWriter errWriter = new PrintWriter(System.err, true))</span>
        {
<span class="fc" id="L470">            HelpFormatter formatter = new HelpFormatter();</span>
<span class="fc" id="L471">            formatter.printHelp(errWriter, 120, &quot;sstablemetadata &lt;options&gt; &lt;sstable...&gt;&quot;,</span>
<span class="fc" id="L472">                                String.format(&quot;%nDump information about SSTable[s] for Apache Cassandra 3.x%nOptions:&quot;),</span>
                                options, 2, 1, &quot;&quot;, true);
<span class="fc" id="L474">            errWriter.println();</span>
        }
<span class="fc" id="L476">    }</span>

    private void printMinMaxToken(Descriptor descriptor, IPartitioner partitioner, AbstractType&lt;?&gt; keyType, StatsMetadata statsMetadata)
    throws IOException
    {
<span class="fc bfc" id="L481" title="All 2 branches covered.">        if (descriptor.version.hasKeyRange())</span>
        {
<span class="pc bpc" id="L483" title="2 of 4 branches missed.">            if (statsMetadata.firstKey == null || statsMetadata.lastKey == null)</span>
<span class="nc" id="L484">                return;</span>

<span class="fc" id="L486">            field(&quot;First token&quot;, partitioner.getToken(statsMetadata.firstKey), keyType.getString(statsMetadata.firstKey));</span>
<span class="fc" id="L487">            field(&quot;Last token&quot;, partitioner.getToken(statsMetadata.lastKey), keyType.getString(statsMetadata.lastKey));</span>
        }
        else
        {
<span class="fc" id="L491">            Pair&lt;DecoratedKey, DecoratedKey&gt; firstLast = descriptor.getFormat().getReaderFactory().readKeyRange(descriptor, partitioner);</span>
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">            if (firstLast == null)</span>
<span class="nc" id="L493">                return;</span>

<span class="fc" id="L495">            field(&quot;First token&quot;, firstLast.left.getToken(), keyType.getString(firstLast.left.getKey()));</span>
<span class="fc" id="L496">            field(&quot;Last token&quot;, firstLast.right.getToken(), keyType.getString(firstLast.right.getKey()));</span>
        }
<span class="fc" id="L498">    }</span>

    /**
     * @param args
     *            a list of sstables whose metadata we're interested in
     */
    public static void main(String[] args) throws IOException
    {
<span class="fc" id="L506">        CommandLineParser parser = new PosixParser();</span>

<span class="fc" id="L508">        Option disableColors = new Option(COLORS, &quot;colors&quot;, false, &quot;Use ANSI color sequences&quot;);</span>
<span class="fc" id="L509">        disableColors.setOptionalArg(true);</span>
<span class="fc" id="L510">        options.addOption(disableColors);</span>
<span class="fc" id="L511">        Option unicode = new Option(UNICODE, &quot;unicode&quot;, false, &quot;Use unicode to draw histograms and progress bars&quot;);</span>
<span class="fc" id="L512">        unicode.setOptionalArg(true);</span>

<span class="fc" id="L514">        options.addOption(unicode);</span>
<span class="fc" id="L515">        Option gcgs = new Option(GCGS_KEY, &quot;gc_grace_seconds&quot;, true, &quot;Time to use when calculating droppable tombstones&quot;);</span>
<span class="fc" id="L516">        gcgs.setOptionalArg(true);</span>
<span class="fc" id="L517">        options.addOption(gcgs);</span>
<span class="fc" id="L518">        Option tsUnit = new Option(TIMESTAMP_UNIT, &quot;timestamp_unit&quot;, true, &quot;Time unit that cell timestamps are written with&quot;);</span>
<span class="fc" id="L519">        tsUnit.setOptionalArg(true);</span>
<span class="fc" id="L520">        options.addOption(tsUnit);</span>

<span class="fc" id="L522">        Option help = new Option(HELP, &quot;help&quot;, false, &quot;Help&quot;);</span>
<span class="fc" id="L523">        help.setOptionalArg(true);</span>
<span class="fc" id="L524">        options.addOption(help);</span>

<span class="fc" id="L526">        Option scanEnabled = new Option(SCAN, &quot;scan&quot;, false,</span>
                &quot;Full sstable scan for additional details. Only available in 3.0+ sstables. Defaults: false&quot;);
<span class="fc" id="L528">        scanEnabled.setOptionalArg(true);</span>
<span class="fc" id="L529">        options.addOption(scanEnabled);</span>
        try
        {
<span class="fc" id="L532">            cmd = parser.parse(options, args);</span>
        }
<span class="fc" id="L534">        catch (ParseException e1)</span>
        {
<span class="fc" id="L536">            System.err.println(e1.getMessage());</span>
<span class="fc" id="L537">            printUsage();</span>
<span class="nc" id="L538">            System.exit(1);</span>
<span class="fc" id="L539">        }</span>

<span class="fc bfc" id="L541" title="All 2 branches covered.">        if (cmd.getArgs().length &lt; 1)</span>
        {
<span class="fc" id="L543">            System.err.println(&quot;You must supply at least one sstable&quot;);</span>
<span class="fc" id="L544">            printUsage();</span>
<span class="nc" id="L545">            System.exit(1);</span>
        }
<span class="fc" id="L547">        boolean enabledColors = cmd.hasOption(COLORS);</span>
<span class="fc" id="L548">        boolean enabledUnicode = cmd.hasOption(UNICODE);</span>
<span class="fc" id="L549">        boolean fullScan = cmd.hasOption(SCAN);</span>
<span class="fc" id="L550">        int gc = Integer.parseInt(cmd.getOptionValue(GCGS_KEY, &quot;0&quot;));</span>
<span class="fc" id="L551">        TimeUnit ts = TimeUnit.valueOf(cmd.getOptionValue(TIMESTAMP_UNIT, &quot;MICROSECONDS&quot;));</span>
<span class="fc" id="L552">        SSTableMetadataViewer metawriter = new SSTableMetadataViewer(enabledColors, enabledUnicode, gc, ts, System.out);</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">        for (String fname : cmd.getArgs())</span>
        {
<span class="fc" id="L555">            File sstable = new File(fname);</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">            if (sstable.exists())</span>
            {
<span class="fc" id="L558">                metawriter.printSStableMetadata(sstable, fullScan);</span>
            }
            else
            {
<span class="fc" id="L562">                System.out.println(&quot;No such file: &quot; + fname);</span>
            }
        }
<span class="fc" id="L565">    }</span>

    private static class ValuedByteBuffer
    {
        public long value;
        public ByteBuffer buffer;

        public ValuedByteBuffer(ByteBuffer buffer, long value)
<span class="fc" id="L573">        {</span>
<span class="fc" id="L574">            this.value = value;</span>
<span class="fc" id="L575">            this.buffer = buffer;</span>
<span class="fc" id="L576">        }</span>

        public long getValue()
        {
<span class="fc" id="L580">            return value;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>