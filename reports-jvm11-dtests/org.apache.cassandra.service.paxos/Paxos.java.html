<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Paxos.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.service.paxos</a> &gt; <span class="el_source">Paxos.java</span></div><h1>Paxos.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.service.paxos;

import java.io.IOException;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import java.util.function.Supplier;

import javax.annotation.Nullable;

import com.google.common.base.Preconditions;
import com.google.common.collect.Iterators;
import com.google.common.collect.Maps;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.codahale.metrics.Meter;
import org.apache.cassandra.exceptions.CasWriteTimeoutException;
import org.apache.cassandra.exceptions.ExceptionCode;
import org.apache.cassandra.gms.FailureDetector;
import org.apache.cassandra.locator.AbstractReplicationStrategy;
import org.apache.cassandra.locator.EndpointsForToken;
import org.apache.cassandra.locator.InOurDc;
import org.apache.cassandra.locator.Replica;
import org.apache.cassandra.locator.ReplicaLayout;
import org.apache.cassandra.locator.ReplicaLayout.ForTokenWrite;
import org.apache.cassandra.locator.ReplicaPlan.ForRead;
import org.apache.cassandra.metrics.ClientRequestSizeMetrics;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.config.Config;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.ConsistencyLevel;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.Keyspace;
import org.apache.cassandra.db.SinglePartitionReadCommand;
import org.apache.cassandra.db.WriteType;
import org.apache.cassandra.db.partitions.FilteredPartition;
import org.apache.cassandra.db.partitions.PartitionIterator;
import org.apache.cassandra.db.partitions.PartitionIterators;
import org.apache.cassandra.db.partitions.PartitionUpdate;
import org.apache.cassandra.db.rows.RowIterator;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.exceptions.IsBootstrappingException;
import org.apache.cassandra.exceptions.ReadFailureException;
import org.apache.cassandra.exceptions.ReadTimeoutException;
import org.apache.cassandra.exceptions.RequestExecutionException;
import org.apache.cassandra.exceptions.RequestFailureException;
import org.apache.cassandra.exceptions.RequestFailureReason;
import org.apache.cassandra.exceptions.RequestTimeoutException;
import org.apache.cassandra.exceptions.UnavailableException;
import org.apache.cassandra.exceptions.WriteFailureException;
import org.apache.cassandra.exceptions.WriteTimeoutException;
import org.apache.cassandra.gms.EndpointState;
import org.apache.cassandra.gms.Gossiper;
import org.apache.cassandra.io.IVersionedSerializer;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.metrics.ClientRequestMetrics;
import org.apache.cassandra.service.CASRequest;
import org.apache.cassandra.service.ClientState;
import org.apache.cassandra.service.FailureRecordingCallback.AsMap;
import org.apache.cassandra.service.paxos.Commit.Proposal;
import org.apache.cassandra.service.reads.DataResolver;
import org.apache.cassandra.service.reads.repair.NoopReadRepair;
import org.apache.cassandra.service.paxos.cleanup.PaxosTableRepairs;
import org.apache.cassandra.tracing.Tracing;
import org.apache.cassandra.triggers.TriggerExecutor;
import org.apache.cassandra.utils.CassandraVersion;
import org.apache.cassandra.utils.CollectionSerializer;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.service.paxos.PaxosPrepare.FoundIncompleteAccepted;
import org.apache.cassandra.service.paxos.PaxosPrepare.FoundIncompleteCommitted;
import org.apache.cassandra.utils.NoSpamLogger;

import static java.util.Collections.emptyMap;
import static java.util.concurrent.TimeUnit.NANOSECONDS;
import static java.util.concurrent.TimeUnit.SECONDS;
import static org.apache.cassandra.config.CassandraRelevantProperties.PAXOS_LOG_TTL_LINEARIZABILITY_VIOLATIONS;
import static org.apache.cassandra.config.CassandraRelevantProperties.PAXOS_MODERN_RELEASE;
import static org.apache.cassandra.config.Config.PaxosVariant.v2_without_linearizable_reads_or_rejected_writes;
import static org.apache.cassandra.db.Keyspace.openAndGetStore;
import static org.apache.cassandra.exceptions.RequestFailureReason.TIMEOUT;
import static org.apache.cassandra.gms.ApplicationState.RELEASE_VERSION;
import static org.apache.cassandra.config.DatabaseDescriptor.*;
import static org.apache.cassandra.db.ConsistencyLevel.*;
import static org.apache.cassandra.locator.InetAddressAndPort.Serializer.inetAddressAndPortSerializer;
import static org.apache.cassandra.locator.ReplicaLayout.forTokenWriteLiveAndDown;
import static org.apache.cassandra.metrics.ClientRequestsMetricsHolder.casReadMetrics;
import static org.apache.cassandra.metrics.ClientRequestsMetricsHolder.casWriteMetrics;
import static org.apache.cassandra.metrics.ClientRequestsMetricsHolder.readMetrics;
import static org.apache.cassandra.metrics.ClientRequestsMetricsHolder.readMetricsMap;
import static org.apache.cassandra.metrics.ClientRequestsMetricsHolder.writeMetricsMap;
import static org.apache.cassandra.service.paxos.Ballot.Flag.GLOBAL;
import static org.apache.cassandra.service.paxos.Ballot.Flag.LOCAL;
import static org.apache.cassandra.service.paxos.BallotGenerator.Global.nextBallot;
import static org.apache.cassandra.service.paxos.BallotGenerator.Global.staleBallot;
import static org.apache.cassandra.service.paxos.ContentionStrategy.*;
import static org.apache.cassandra.service.paxos.ContentionStrategy.Type.READ;
import static org.apache.cassandra.service.paxos.ContentionStrategy.Type.WRITE;
import static org.apache.cassandra.service.paxos.PaxosCommit.commit;
import static org.apache.cassandra.service.paxos.PaxosCommitAndPrepare.commitAndPrepare;
import static org.apache.cassandra.service.paxos.PaxosPrepare.prepare;
import static org.apache.cassandra.service.paxos.PaxosPropose.propose;
import static org.apache.cassandra.utils.Clock.Global.nanoTime;
import static org.apache.cassandra.utils.CollectionSerializer.newHashSet;
import static org.apache.cassandra.utils.FBUtilities.getBroadcastAddressAndPort;
import static org.apache.cassandra.utils.NoSpamLogger.Level.WARN;

/**
 * &lt;p&gt;This class serves as an entry-point to Cassandra's implementation of Paxos Consensus.
 * Note that Cassandra does not utilise the distinguished proposer (Multi Paxos) optimisation;
 * each operation executes its own instance of Paxos Consensus. Instead Cassandra employs
 * various optimisations to reduce the overhead of operations. This may lead to higher throughput
 * and lower overhead read operations, at the expense of contention during mixed or write-heavy workloads.
 *
 * Firstly, note that we do not follow Lamport's formulation, instead following the more common approach in
 * literature (see e.g. Dr. Heidi Howard's dissertation) of permitting any acceptor to vote on a proposal,
 * not only those who issued a promise.
 *
 * &lt;h2&gt;No Commit of Empty Proposals&lt;/h2&gt;
 * &lt;p&gt;If a proposal is empty, there can be no effect to the state, so once this empty proposal has poisoned any earlier
 * proposal it is safe to stop processing. An empty proposal effectively scrubs the instance of consensus being
 * performed once it has reached a quorum, as no earlier incomplete proposal (that may perhaps have reached a minority)
 * may now be completed.
 *
 * &lt;h2&gt;Fast Read / Failed Write&lt;/h2&gt;
 * &lt;p&gt;This optimisation relies on every voter having no incomplete promises, i.e. their commit register must be greater
 * than or equal to their promise and proposal registers (or there must be such an empty proposal).
 * Since the operation we are performing must invalidate any nascent operation that has reached a minority, and will
 * itself be invalidated by any newer write it might race with, we are only concerned about operations that might be
 * in-flight and incomplete. If we reach a quorum without any incomplete proposal, we prevent any incomplete proposal
 * that might have come before us from being committed, and so are correctly ordered.
 *
 * &lt;p&gt;NOTE: we could likely weaken this further, permitting a fast operation if we witness a stale incomplete operation
 * on one or more of the replicas, so long as we witness _some_ response that had knowledge of that operation's decision,
 * however we might waste more time performing optimistic reads (which we skip if we witness any in progress promise)
 *
 * &lt;h2&gt;Read Commutativity Optimisation&lt;/h2&gt;
 * &lt;p&gt;We separate read and write promises into distinct registers. Since reads are commutative they do not need to be
 * ordered with respect to each other, so read promises consult only the write promise register to find competing
 * operations, whereas writes consult both read and write registers. This permits better utilisation of the Fast Read
 * optimisation, permitting arbitrarily many fast reads to execute concurrently.
 *
 * &lt;p&gt;A read will use its promise to finish any in progress write it encounters, but note that this is safe for multiple
 * reads to attempt simultaneously. If a write operation has not reached a quorum of promises then it has no effect,
 * so while some read operations may attempt to complete it and others may not, the operation will only be invalidated
 * and these actions will be equivalent. If the write had reached a quorum of promises then every reads will attempt
 * to complete the write. At the accept phase, only the most recent read promise will be accepted so whether the write
 * proposal had reached a quorum or not, a consistent outcome will result.
 *
 * &lt;h2&gt;Reproposal Avoidance&lt;/h2&gt;
 * &lt;p&gt;It can occur that two (or more) commands begin competing to re-propose the same incomplete command even after it
 * has already committed - this can occur when an in progress command that has reached the commit condition (but not yet
 * committed) is encountered by a promise, so that it is re-proposed. If the original coordinator does not fail this
 * original command will be committed normally, but the re-proposal can take on a life of its own, and become contended
 * and re-proposed indefinitely. By having reproposals use the original proposal ballot's timestamp we spot this situation
 * and consider re-proposals of a command we have seen committed to be (in effect) empty proposals.
 *
 * &lt;h2&gt;Durability of Asynchronous Commit&lt;/h2&gt;
 * To permit asynchronous commit (and also because we should) we ensure commits are durable once a proposal has been
 * accepted by a majority.
 *
 * Replicas track commands that have *locally* been witnessed but not committed. They may clear this log by performing
 * a round of Paxos Repair for each key in the log (which is simply a round of Paxos that tries not to interfere with
 * future rounds of Paxos, while aiming to complete any earlier incomplete round).
 *
 * By selecting some quorum of replicas for a range to perform this operation on, once successful we guarantee that
 * any transaction that had previously been accepted by a majority has been committed, and any transaction that had been
 * previously witnessed by a majority has been either committed or invalidated.
 *
 * To ensure durability across range movements, once a joining node becomes pending such a coordinated paxos repair
 * is performed prior to performing bootstrap, so that commands initiated before joining will either be bootstrapped
 * or completed by paxos repair to be committed to a majority that includes the new node in its calculations, and
 * commands initiated after will anyway do so due to being pending.
 *
 * Finally, for greater guarantees across range movements despite the uncertainty of gossip, paxos operations validate
 * ring information with each other while seeking a quorum of promises. Any inconsistency is resolved by synchronising
 * gossip state between the coordinator and the peers in question.
 *
 * &lt;h2&gt;Clearing of Paxos State&lt;/h2&gt;
 * Coordinated paxos repairs as described above are preceded by an preparation step that determines a ballot below
 * which we agree to reject new promises. By deciding and disseminating this point prior to performing a coordinated
 * paxos repair, once complete we have ensured that all commands with a lower ballot are either committed or invalidated,
 * and so we are then able to disseminate this ballot as a bound below which may expunge all data for the range.
 *
 * For consistency of execution coordinators seek this latter ballot bound from each replica and, using the maximum of
 * these, ignore all data received associated with ballots lower than this bound.
 */
<span class="nc" id="L214">public class Paxos</span>
{
<span class="fc" id="L216">    private static final Logger logger = LoggerFactory.getLogger(Paxos.class);</span>

<span class="fc" id="L218">    private static volatile Config.PaxosVariant PAXOS_VARIANT = DatabaseDescriptor.getPaxosVariant();</span>
<span class="fc" id="L219">    private static final CassandraVersion MODERN_PAXOS_RELEASE = new CassandraVersion(PAXOS_MODERN_RELEASE.getString());</span>
<span class="fc" id="L220">    static final boolean LOG_TTL_LINEARIZABILITY_VIOLATIONS = PAXOS_LOG_TTL_LINEARIZABILITY_VIOLATIONS.getBoolean();</span>

    static class Electorate implements Iterable&lt;InetAddressAndPort&gt;
    {
<span class="fc" id="L224">        static final Serializer serializer = new Serializer();</span>

        // all replicas, including pending, but without those in a remote DC if consistency is local
        final Collection&lt;InetAddressAndPort&gt; natural;

        // pending subset of electorate
        final Collection&lt;InetAddressAndPort&gt; pending;

        public Electorate(Collection&lt;InetAddressAndPort&gt; natural, Collection&lt;InetAddressAndPort&gt; pending)
<span class="fc" id="L233">        {</span>
<span class="fc" id="L234">            this.natural = natural;</span>
<span class="fc" id="L235">            this.pending = pending;</span>
<span class="fc" id="L236">        }</span>

        public int size()
        {
<span class="fc" id="L240">            return natural.size() + pending.size();</span>
        }

        @Override
        public Iterator&lt;InetAddressAndPort&gt; iterator()
        {
<span class="fc" id="L246">            return Iterators.concat(natural.iterator(), pending.iterator());</span>
        }

        static Electorate get(TableMetadata table, DecoratedKey key, ConsistencyLevel consistency)
        {
<span class="fc" id="L251">            return get(consistency, forTokenWriteLiveAndDown(Keyspace.open(table.keyspace), key.getToken()));</span>
        }

        static Electorate get(ConsistencyLevel consistency, ForTokenWrite all)
        {
<span class="fc" id="L256">            ForTokenWrite electorate = all;</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">            if (consistency == LOCAL_SERIAL)</span>
<span class="fc" id="L258">                electorate = all.filter(InOurDc.replicas());</span>

<span class="fc" id="L260">            return new Electorate(electorate.natural().endpointList(), electorate.pending().endpointList());</span>
        }

        boolean hasPending()
        {
<span class="fc bfc" id="L265" title="All 2 branches covered.">            return !pending.isEmpty();</span>
        }

        boolean isPending(InetAddressAndPort endpoint)
        {
<span class="fc bfc" id="L270" title="All 4 branches covered.">            return hasPending() &amp;&amp; pending.contains(endpoint);</span>
        }

        public boolean equals(Object o)
        {
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">            if (this == o) return true;</span>
<span class="pc bpc" id="L276" title="2 of 4 branches missed.">            if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L277">            Electorate that = (Electorate) o;</span>
<span class="fc bfc" id="L278" title="All 4 branches covered.">            return natural.equals(that.natural) &amp;&amp; pending.equals(that.pending);</span>
        }

        public int hashCode()
        {
<span class="nc" id="L283">            return Objects.hash(natural, pending);</span>
        }

        public String toString()
        {
<span class="nc" id="L288">            return &quot;{&quot; + natural + &quot;, &quot; + pending + '}';</span>
        }

<span class="fc" id="L291">        static class Serializer implements IVersionedSerializer&lt;Electorate&gt;</span>
        {
            public void serialize(Electorate electorate, DataOutputPlus out, int version) throws IOException
            {
<span class="fc" id="L295">                CollectionSerializer.serializeCollection(inetAddressAndPortSerializer, electorate.natural, out, version);</span>
<span class="fc" id="L296">                CollectionSerializer.serializeCollection(inetAddressAndPortSerializer, electorate.pending, out, version);</span>
<span class="fc" id="L297">            }</span>

            public Electorate deserialize(DataInputPlus in, int version) throws IOException
            {
<span class="fc" id="L301">                Set&lt;InetAddressAndPort&gt; endpoints = CollectionSerializer.deserializeCollection(inetAddressAndPortSerializer, newHashSet(), in, version);</span>
<span class="fc" id="L302">                Set&lt;InetAddressAndPort&gt; pending = CollectionSerializer.deserializeCollection(inetAddressAndPortSerializer, newHashSet(), in, version);</span>
<span class="fc" id="L303">                return new Electorate(endpoints, pending);</span>
            }

            public long serializedSize(Electorate electorate, int version)
            {
<span class="fc" id="L308">                return CollectionSerializer.serializedSizeCollection(inetAddressAndPortSerializer, electorate.natural, version) +</span>
<span class="fc" id="L309">                       CollectionSerializer.serializedSizeCollection(inetAddressAndPortSerializer, electorate.pending, version);</span>
            }
        }
    }

    /**
     * Encapsulates the peers we will talk to for this operation.
     */
    static class Participants implements ForRead&lt;EndpointsForToken, Participants&gt;, Supplier&lt;Participants&gt;
    {
        final Keyspace keyspace;

        final AbstractReplicationStrategy replicationStrategy;

        /**
         * SERIAL or LOCAL_SERIAL
         */
        final ConsistencyLevel consistencyForConsensus;

        /**
         * Those members that vote for {@link #consistencyForConsensus}
         */
        final Electorate electorate;

        /**
         * Those members of {@link #electorate} that we will 'poll' for their vote
         * i.e. {@link #electorate} with down nodes removed
         */

        private final EndpointsForToken electorateNatural;
        final EndpointsForToken electorateLive;

        final EndpointsForToken all;
        final EndpointsForToken allLive;
        final EndpointsForToken allDown;
        final EndpointsForToken pending;

        /**
         * The number of responses we require to reach desired consistency from members of {@code contact}
         */
        final int sizeOfConsensusQuorum;

        /**
         * The number of read responses we require to reach desired consistency from members of {@code contact}
         * Note that this should always be met if {@link #sizeOfConsensusQuorum} is met, but we supply it separately
         * for corroboration.
         */
        final int sizeOfReadQuorum;

        Participants(Keyspace keyspace, ConsistencyLevel consistencyForConsensus, ReplicaLayout.ForTokenWrite all, ReplicaLayout.ForTokenWrite electorate, EndpointsForToken live)
<span class="fc" id="L359">        {</span>
<span class="fc" id="L360">            this.keyspace = keyspace;</span>
<span class="fc" id="L361">            this.replicationStrategy = all.replicationStrategy();</span>
<span class="fc" id="L362">            this.consistencyForConsensus = consistencyForConsensus;</span>
<span class="fc" id="L363">            this.all = all.all();</span>
<span class="fc" id="L364">            this.pending = all.pending();</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">            this.allDown = all.all() == live ? EndpointsForToken.empty(all.token()) : all.all().without(live.endpoints());</span>
<span class="fc" id="L366">            this.electorate = new Electorate(electorate.natural().endpointList(), electorate.pending().endpointList());</span>
<span class="fc" id="L367">            this.electorateNatural = electorate.natural();</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">            this.electorateLive = electorate.all() == live ? live : electorate.all().keep(live.endpoints());</span>
<span class="fc" id="L369">            this.allLive = live;</span>
<span class="fc" id="L370">            this.sizeOfReadQuorum = electorate.natural().size() / 2 + 1;</span>
<span class="fc" id="L371">            this.sizeOfConsensusQuorum = sizeOfReadQuorum + electorate.pending().size();</span>
<span class="fc" id="L372">        }</span>

        @Override
        public int readQuorum()
        {
<span class="nc" id="L377">            return sizeOfReadQuorum;</span>
        }

        @Override
        public EndpointsForToken readCandidates()
        {
            // Note: we could probably return electorateLive here and save a reference, but it's not strictly correct
<span class="fc" id="L384">            return electorateNatural;</span>
        }

        static Participants get(TableMetadata table, Token token, ConsistencyLevel consistencyForConsensus)
        {
<span class="fc" id="L389">            Keyspace keyspace = Keyspace.open(table.keyspace);</span>
<span class="fc" id="L390">            ReplicaLayout.ForTokenWrite all = forTokenWriteLiveAndDown(keyspace, token);</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">            ReplicaLayout.ForTokenWrite electorate = consistencyForConsensus.isDatacenterLocal()</span>
<span class="fc" id="L392">                                                     ? all.filter(InOurDc.replicas()) : all;</span>

<span class="fc" id="L394">            EndpointsForToken live = all.all().filter(FailureDetector.isReplicaAlive);</span>

<span class="fc" id="L396">            return new Participants(keyspace, consistencyForConsensus, all, electorate, live);</span>
        }

        static Participants get(TableMetadata cfm, DecoratedKey key, ConsistencyLevel consistency)
        {
<span class="fc" id="L401">            return get(cfm, key.getToken(), consistency);</span>
        }

        int sizeOfPoll()
        {
<span class="fc" id="L406">            return electorateLive.size();</span>
        }

        InetAddressAndPort voter(int i)
        {
<span class="fc" id="L411">            return electorateLive.endpoint(i);</span>
        }

        void assureSufficientLiveNodes(boolean isWrite) throws UnavailableException
        {
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">            if (sizeOfConsensusQuorum &gt; sizeOfPoll())</span>
            {
<span class="nc" id="L418">                mark(isWrite, m -&gt; m.unavailables, consistencyForConsensus);</span>
<span class="nc" id="L419">                throw new UnavailableException(&quot;Cannot achieve consistency level &quot; + consistencyForConsensus, consistencyForConsensus, sizeOfConsensusQuorum, sizeOfPoll());</span>
            }
<span class="fc" id="L421">        }</span>

        void assureSufficientLiveNodesForRepair() throws UnavailableException
        {
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">            if (sizeOfConsensusQuorum &gt; sizeOfPoll())</span>
            {
<span class="nc" id="L427">                throw UnavailableException.create(consistencyForConsensus, sizeOfConsensusQuorum, sizeOfPoll());</span>
            }
<span class="fc" id="L429">        }</span>

        int requiredFor(ConsistencyLevel consistency)
        {
<span class="fc bfc" id="L433" title="All 2 branches covered.">            if (consistency == Paxos.nonSerial(consistencyForConsensus))</span>
<span class="fc" id="L434">                return sizeOfConsensusQuorum;</span>

<span class="fc" id="L436">            return consistency.blockForWrite(replicationStrategy(), pending);</span>
        }

        public boolean hasOldParticipants()
        {
<span class="nc" id="L441">            return electorateLive.anyMatch(Paxos::isOldParticipant);</span>
        }

        @Override
        public Participants get()
        {
<span class="fc" id="L447">            return this;</span>
        }

        @Override
        public Keyspace keyspace()
        {
<span class="nc" id="L453">            return keyspace;</span>
        }

        @Override
        public AbstractReplicationStrategy replicationStrategy()
        {
<span class="fc" id="L459">            return replicationStrategy;</span>
        }

        @Override
        public ConsistencyLevel consistencyLevel()
        {
<span class="nc" id="L465">            return nonSerial(consistencyForConsensus);</span>
        }

        @Override
        public EndpointsForToken contacts()
        {
<span class="nc" id="L471">            return electorateLive;</span>
        }

        @Override
        public Replica lookup(InetAddressAndPort endpoint)
        {
<span class="fc" id="L477">            return all.lookup(endpoint);</span>
        }

        @Override
        public Participants withContacts(EndpointsForToken newContacts)
        {
<span class="nc" id="L483">            throw new UnsupportedOperationException();</span>
        }
    }

    /**
     * Encapsulates information about a failure to reach Success, either because of explicit failure responses
     * or insufficient responses (in which case the status is not final)
     */
    static class MaybeFailure
    {
        final boolean isFailure;
        final String serverError;
        final int contacted;
        final int required;
        final int successes;
        final Map&lt;InetAddressAndPort, RequestFailureReason&gt; failures;

        static MaybeFailure noResponses(Participants contacted)
        {
<span class="nc" id="L502">            return new MaybeFailure(false, contacted.sizeOfPoll(), contacted.sizeOfConsensusQuorum, 0, emptyMap());</span>
        }

        MaybeFailure(Participants contacted, int successes, AsMap failures)
        {
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">            this(contacted.sizeOfPoll() - failures.failureCount() &lt; contacted.sizeOfConsensusQuorum, contacted.sizeOfPoll(), contacted.sizeOfConsensusQuorum, successes, failures);</span>
<span class="fc" id="L508">        }</span>

        MaybeFailure(int contacted, int required, int successes, AsMap failures)
        {
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">            this(contacted - failures.failureCount() &lt; required, contacted, required, successes, failures);</span>
<span class="fc" id="L513">        }</span>

        MaybeFailure(boolean isFailure, int contacted, int required, int successes, Map&lt;InetAddressAndPort, RequestFailureReason&gt; failures)
        {
<span class="fc" id="L517">            this(isFailure, null, contacted, required, successes, failures);</span>
<span class="fc" id="L518">        }</span>

        MaybeFailure(boolean isFailure, String serverError, int contacted, int required, int successes, Map&lt;InetAddressAndPort, RequestFailureReason&gt; failures)
<span class="fc" id="L521">        {</span>
<span class="fc" id="L522">            this.isFailure = isFailure;</span>
<span class="fc" id="L523">            this.serverError = serverError;</span>
<span class="fc" id="L524">            this.contacted = contacted;</span>
<span class="fc" id="L525">            this.required = required;</span>
<span class="fc" id="L526">            this.successes = successes;</span>
<span class="fc" id="L527">            this.failures = failures;</span>
<span class="fc" id="L528">        }</span>

        private static int failureCount(Map&lt;InetAddressAndPort, RequestFailureReason&gt; failures)
        {
<span class="nc" id="L532">            int count = 0;</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">            for (RequestFailureReason reason : failures.values())</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">                count += reason != TIMEOUT ? 1 : 0;</span>
<span class="nc" id="L535">            return count;</span>
        }

        /**
         * update relevant counters and throw the relevant exception
         */
        RequestExecutionException markAndThrowAsTimeoutOrFailure(boolean isWrite, ConsistencyLevel consistency, int failedAttemptsDueToContention)
        {
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">            if (isFailure)</span>
            {
<span class="nc" id="L545">                mark(isWrite, m -&gt; m.failures, consistency);</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">                throw serverError != null ? new RequestFailureException(ExceptionCode.SERVER_ERROR, serverError, consistency, successes, required, failures)</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">                                          : isWrite</span>
<span class="nc" id="L548">                                            ? new WriteFailureException(consistency, successes, required, WriteType.CAS, failures)</span>
<span class="nc" id="L549">                                            : new ReadFailureException(consistency, successes, required, false, failures);</span>
            }
            else
            {
<span class="fc" id="L553">                mark(isWrite, m -&gt; m.timeouts, consistency);</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">                throw isWrite</span>
<span class="fc" id="L555">                        ? new CasWriteTimeoutException(WriteType.CAS, consistency, successes, required, failedAttemptsDueToContention)</span>
<span class="fc" id="L556">                        : new ReadTimeoutException(consistency, successes, required, false);</span>
            }
        }

        public String toString()
        {
<span class="nc bnc" id="L562" title="All 2 branches missed.">            return (isFailure ? &quot;Failure(&quot; : &quot;Timeout(&quot;) + successes + ',' + failures + ')';</span>
        }
    }

    public interface Async&lt;Result&gt;
    {
        Result awaitUntil(long until);
    }

    /**
     * Apply @param updates if and only if the current values in the row for @param key
     * match the provided @param conditions.  The algorithm is &quot;raw&quot; Paxos: that is, Paxos
     * minus leader election -- any node in the cluster may propose changes for any partition.
     *
     * The Paxos electorate consists only of the replicas for the partition key.
     * We expect performance to be reasonable, but CAS is still intended to be used
     * &quot;when you really need it,&quot; not for all your updates.
     *
     * There are three phases to Paxos:
     *  1. Prepare: the coordinator generates a ballot (Ballot in our case) and asks replicas to
     *     - promise not to accept updates from older ballots and
     *     - tell us about the latest ballots it has already _promised_, _accepted_, or _committed_
     *     - reads the necessary data to evaluate our CAS condition
     *
     *  2. Propose: if a majority of replicas reply, the coordinator asks replicas to accept the value of the
     *     highest proposal ballot it heard about, or a new value if no in-progress proposals were reported.
     *  3. Commit (Learn): if a majority of replicas acknowledge the accept request, we can commit the new
     *     value.
     *
     *  Commit procedure is not covered in &quot;Paxos Made Simple,&quot; and only briefly mentioned in &quot;Paxos Made Live,&quot;
     *  so here is our approach:
     *   3a. The coordinator sends a commit message to all replicas with the ballot and value.
     *   3b. Because of 1-2, this will be the highest-seen commit ballot.  The replicas will note that,
     *       and send it with subsequent promise replies.  This allows us to discard acceptance records
     *       for successfully committed replicas, without allowing incomplete proposals to commit erroneously
     *       later on.
     *
     *  Note that since we are performing a CAS rather than a simple update, when nodes respond positively to
     *  Prepare, they include read response of commited values that will be reconciled on the coordinator
     *  and checked against CAS precondition between the prepare and accept phases. This gives us a slightly
     *  longer window for another coordinator to come along and trump our own promise with a newer one but
     *  is otherwise safe.
     *
     *  Any successful prepare phase yielding a read that rejects the condition must be followed by the proposal of
     *  an empty update, to ensure the evaluation of the condition is linearized with respect to other reads and writes.
     *
     * @param key the row key for the row to CAS
     * @param request the conditions for the CAS to apply as well as the update to perform if the conditions hold.
     * @param consistencyForConsensus the consistency for the paxos prepare and propose round. This can only be either SERIAL or LOCAL_SERIAL.
     * @param consistencyForCommit the consistency for write done during the commit phase. This can be anything, except SERIAL or LOCAL_SERIAL.
     *
     * @return null if the operation succeeds in updating the row, or the current values corresponding to conditions.
     * (since, if the CAS doesn't succeed, it means the current value do not match the conditions).
     */
    public static RowIterator cas(DecoratedKey key,
                                  CASRequest request,
                                  ConsistencyLevel consistencyForConsensus,
                                  ConsistencyLevel consistencyForCommit,
                                  ClientState clientState)
            throws UnavailableException, IsBootstrappingException, RequestFailureException, RequestTimeoutException, InvalidRequestException
    {
<span class="fc" id="L623">        final long start = nanoTime();</span>
<span class="fc" id="L624">        final long proposeDeadline = start + getCasContentionTimeout(NANOSECONDS);</span>
<span class="fc" id="L625">        final long commitDeadline = Math.max(proposeDeadline, start + getWriteRpcTimeout(NANOSECONDS));</span>
<span class="fc" id="L626">        return cas(key, request, consistencyForConsensus, consistencyForCommit, clientState, start, proposeDeadline, commitDeadline);</span>
    }
    public static RowIterator cas(DecoratedKey key,
                                  CASRequest request,
                                  ConsistencyLevel consistencyForConsensus,
                                  ConsistencyLevel consistencyForCommit,
                                  ClientState clientState,
                                  long proposeDeadline,
                                  long commitDeadline
                                  )
            throws UnavailableException, IsBootstrappingException, RequestFailureException, RequestTimeoutException, InvalidRequestException
    {
<span class="nc" id="L638">        return cas(key, request, consistencyForConsensus, consistencyForCommit, clientState, nanoTime(), proposeDeadline, commitDeadline);</span>
    }
    private static RowIterator cas(DecoratedKey partitionKey,
                                  CASRequest request,
                                  ConsistencyLevel consistencyForConsensus,
                                  ConsistencyLevel consistencyForCommit,
                                  ClientState clientState,
                                  long start,
                                  long proposeDeadline,
                                  long commitDeadline
                                  )
            throws UnavailableException, IsBootstrappingException, RequestFailureException, RequestTimeoutException, InvalidRequestException
    {
<span class="fc" id="L651">        SinglePartitionReadCommand readCommand = request.readCommand(FBUtilities.nowInSeconds());</span>
<span class="fc" id="L652">        TableMetadata metadata = readCommand.metadata();</span>

<span class="fc" id="L654">        consistencyForConsensus.validateForCas();</span>
<span class="fc" id="L655">        consistencyForCommit.validateForCasCommit(Keyspace.open(metadata.keyspace).getReplicationStrategy());</span>

<span class="fc" id="L657">        Ballot minimumBallot = null;</span>
<span class="fc" id="L658">        int failedAttemptsDueToContention = 0;</span>
<span class="fc" id="L659">        try (PaxosOperationLock lock = PaxosState.lock(partitionKey, metadata, proposeDeadline, consistencyForConsensus, true))</span>
        {
<span class="fc" id="L661">            Paxos.Async&lt;PaxosCommit.Status&gt; commit = null;</span>
            done: while (true)
            {
                // read the current values and check they validate the conditions
<span class="fc" id="L665">                Tracing.trace(&quot;Reading existing values for CAS precondition&quot;);</span>

<span class="fc" id="L667">                BeginResult begin = begin(proposeDeadline, readCommand, consistencyForConsensus,</span>
                        true, minimumBallot, failedAttemptsDueToContention);
<span class="fc" id="L669">                Ballot ballot = begin.ballot;</span>
<span class="fc" id="L670">                Participants participants = begin.participants;</span>
<span class="fc" id="L671">                failedAttemptsDueToContention = begin.failedAttemptsDueToContention;</span>

                FilteredPartition current;
<span class="fc" id="L674">                try (RowIterator iter = PartitionIterators.getOnlyElement(begin.readResponse, readCommand))</span>
                {
<span class="fc" id="L676">                    current = FilteredPartition.create(iter);</span>
                }

                Proposal proposal;
<span class="fc" id="L680">                boolean conditionMet = request.appliesTo(current);</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">                if (!conditionMet)</span>
                {
<span class="pc bpc" id="L683" title="1 of 2 branches missed.">                    if (getPaxosVariant() == v2_without_linearizable_reads_or_rejected_writes)</span>
                    {
<span class="nc" id="L685">                        Tracing.trace(&quot;CAS precondition rejected&quot;, current);</span>
<span class="nc" id="L686">                        casWriteMetrics.conditionNotMet.inc();</span>
<span class="nc" id="L687">                        return current.rowIterator();</span>
                    }

                    // If we failed to meet our condition, it does not mean we can do nothing: if we do not propose
                    // anything that is accepted by a quorum, it is possible for our !conditionMet state
                    // to not be serialized wrt other operations.
                    // If a later read encounters an &quot;in progress&quot; write that did not reach a majority,
                    // but that would have permitted conditionMet had it done so (and hence we evidently did not witness),
                    // that operation will complete the in-progress proposal before continuing, so that this and future
                    // reads will perceive conditionMet without any intervening modification from the time at which we
                    // assured a conditional write that !conditionMet.
                    // So our evaluation is only serialized if we invalidate any in progress operations by proposing an empty update
                    // See also CASSANDRA-12126
<span class="fc bfc" id="L700" title="All 2 branches covered.">                    if (begin.isLinearizableRead)</span>
                    {
<span class="fc" id="L702">                        Tracing.trace(&quot;CAS precondition does not match current values {}; read is already linearizable; aborting&quot;, current);</span>
<span class="fc" id="L703">                        return conditionNotMet(current);</span>
                    }

<span class="fc" id="L706">                    Tracing.trace(&quot;CAS precondition does not match current values {}; proposing empty update&quot;, current);</span>
<span class="fc" id="L707">                    proposal = Proposal.empty(ballot, partitionKey, metadata);</span>
                }
<span class="fc bfc" id="L709" title="All 2 branches covered.">                else if (begin.isPromised)</span>
                {
                    // finish the paxos round w/ the desired updates
                    // TODO &quot;turn null updates into delete?&quot; - what does this TODO even mean?
<span class="fc" id="L713">                    PartitionUpdate updates = request.makeUpdates(current, clientState, begin.ballot);</span>

                    // Update the metrics before triggers potentially add mutations.
<span class="fc" id="L716">                    ClientRequestSizeMetrics.recordRowAndColumnCountMetrics(updates);</span>

                    // Apply triggers to cas updates. A consideration here is that
                    // triggers emit Mutations, and so a given trigger implementation
                    // may generate mutations for partitions other than the one this
                    // paxos round is scoped for. In this case, TriggerExecutor will
                    // validate that the generated mutations are targetted at the same
                    // partition as the initial updates and reject (via an
                    // InvalidRequestException) any which aren't.
<span class="fc" id="L725">                    updates = TriggerExecutor.instance.execute(updates);</span>

<span class="fc" id="L727">                    proposal = Proposal.of(ballot, updates);</span>
<span class="fc" id="L728">                    Tracing.trace(&quot;CAS precondition is met; proposing client-requested updates for {}&quot;, ballot);</span>
<span class="fc" id="L729">                }</span>
                else
                {
                    // must retry, as only achieved read success in begin
<span class="fc" id="L733">                    Tracing.trace(&quot;CAS precondition is met, but ballot stale for proposal; retrying&quot;, current);</span>
<span class="fc" id="L734">                    continue;</span>
                }

<span class="fc" id="L737">                PaxosPropose.Status propose = propose(proposal, participants, conditionMet).awaitUntil(proposeDeadline);</span>
<span class="pc bpc" id="L738" title="2 of 4 branches missed.">                switch (propose.outcome)</span>
                {
<span class="nc" id="L740">                    default: throw new IllegalStateException();</span>

                    case MAYBE_FAILURE:
<span class="nc" id="L743">                        throw propose.maybeFailure().markAndThrowAsTimeoutOrFailure(true, consistencyForConsensus, failedAttemptsDueToContention);</span>

                    case SUCCESS:
                    {
<span class="fc bfc" id="L747" title="All 2 branches covered.">                        if (!conditionMet)</span>
<span class="fc" id="L748">                            return conditionNotMet(current);</span>

                        // no need to commit a no-op; either it
                        //   1) reached a majority, in which case it was agreed, had no effect and we can do nothing; or
                        //   2) did not reach a majority, was not agreed, and was not user visible as a result so we can ignore it
<span class="pc bpc" id="L753" title="1 of 2 branches missed.">                        if (!proposal.update.isEmpty())</span>
<span class="fc" id="L754">                            commit = commit(proposal.agreed(), participants, consistencyForConsensus, consistencyForCommit, true);</span>

                        break done;
                    }

                    case SUPERSEDED:
                    {
<span class="pc bpc" id="L761" title="1 of 3 branches missed.">                        switch (propose.superseded().hadSideEffects)</span>
                        {
<span class="nc" id="L763">                            default: throw new IllegalStateException();</span>

                            case MAYBE:
                                // We don't know if our update has been applied, as the competing ballot may have completed
                                // our proposal.  We yield our uncertainty to the caller via timeout exception.
                                // TODO: should return more useful result to client, and should also avoid this situation where possible
<span class="fc" id="L769">                                throw new MaybeFailure(false, participants.sizeOfPoll(), participants.sizeOfConsensusQuorum, 0, emptyMap())</span>
<span class="nc" id="L770">                                        .markAndThrowAsTimeoutOrFailure(true, consistencyForConsensus, failedAttemptsDueToContention);</span>

                            case NO:
<span class="fc" id="L773">                                minimumBallot = propose.superseded().by;</span>
                                // We have been superseded without our proposal being accepted by anyone, so we can safely retry
<span class="fc" id="L775">                                Tracing.trace(&quot;Paxos proposal not accepted (pre-empted by a higher ballot)&quot;);</span>
<span class="pc bpc" id="L776" title="1 of 2 branches missed.">                                if (!waitForContention(proposeDeadline, ++failedAttemptsDueToContention, metadata, partitionKey, consistencyForConsensus, WRITE))</span>
<span class="nc" id="L777">                                    throw MaybeFailure.noResponses(participants).markAndThrowAsTimeoutOrFailure(true, consistencyForConsensus, failedAttemptsDueToContention);</span>
                        }
                    }
                }
                // continue to retry
<span class="fc" id="L782">            }</span>

<span class="pc bpc" id="L784" title="1 of 2 branches missed.">            if (commit != null)</span>
            {
<span class="fc" id="L786">                PaxosCommit.Status result = commit.awaitUntil(commitDeadline);</span>
<span class="fc bfc" id="L787" title="All 2 branches covered.">                if (!result.isSuccess())</span>
<span class="nc" id="L788">                    throw result.maybeFailure().markAndThrowAsTimeoutOrFailure(true, consistencyForCommit, failedAttemptsDueToContention);</span>
            }
<span class="fc" id="L790">            Tracing.trace(&quot;CAS successful&quot;);</span>
<span class="fc" id="L791">            return null;</span>

<span class="pc bpc" id="L793" title="4 of 6 branches missed.">        }</span>
        finally
        {
<span class="fc" id="L796">            final long latency = nanoTime() - start;</span>

<span class="fc bfc" id="L798" title="All 2 branches covered.">            if (failedAttemptsDueToContention &gt; 0)</span>
            {
<span class="fc" id="L800">                casWriteMetrics.contention.update(failedAttemptsDueToContention);</span>
<span class="fc" id="L801">                openAndGetStore(metadata).metric.topCasPartitionContention.addSample(partitionKey.getKey(), failedAttemptsDueToContention);</span>
            }


<span class="fc" id="L805">            casWriteMetrics.addNano(latency);</span>
<span class="fc" id="L806">            writeMetricsMap.get(consistencyForConsensus).addNano(latency);</span>
        }
    }

    private static RowIterator conditionNotMet(FilteredPartition read)
    {
<span class="fc" id="L812">        Tracing.trace(&quot;CAS precondition rejected&quot;, read);</span>
<span class="fc" id="L813">        casWriteMetrics.conditionNotMet.inc();</span>
<span class="fc" id="L814">        return read.rowIterator();</span>
    }

    public static PartitionIterator read(SinglePartitionReadCommand.Group group, ConsistencyLevel consistencyForConsensus)
            throws InvalidRequestException, UnavailableException, ReadFailureException, ReadTimeoutException
    {
<span class="fc" id="L820">        long start = nanoTime();</span>
<span class="fc" id="L821">        long deadline = start + DatabaseDescriptor.getReadRpcTimeout(NANOSECONDS);</span>
<span class="fc" id="L822">        return read(group, consistencyForConsensus, start, deadline);</span>
    }

    public static PartitionIterator read(SinglePartitionReadCommand.Group group, ConsistencyLevel consistencyForConsensus, long deadline)
            throws InvalidRequestException, UnavailableException, ReadFailureException, ReadTimeoutException
    {
<span class="nc" id="L828">        return read(group, consistencyForConsensus, nanoTime(), deadline);</span>
    }

    private static PartitionIterator read(SinglePartitionReadCommand.Group group, ConsistencyLevel consistencyForConsensus, long start, long deadline)
            throws InvalidRequestException, UnavailableException, ReadFailureException, ReadTimeoutException
    {
<span class="pc bpc" id="L834" title="1 of 2 branches missed.">        if (group.queries.size() &gt; 1)</span>
<span class="nc" id="L835">            throw new InvalidRequestException(&quot;SERIAL/LOCAL_SERIAL consistency may only be requested for one partition at a time&quot;);</span>

<span class="fc" id="L837">        int failedAttemptsDueToContention = 0;</span>
<span class="fc" id="L838">        Ballot minimumBallot = null;</span>
<span class="fc" id="L839">        SinglePartitionReadCommand read = group.queries.get(0);</span>
<span class="fc" id="L840">        try (PaxosOperationLock lock = PaxosState.lock(read.partitionKey(), read.metadata(), deadline, consistencyForConsensus, false))</span>
        {
            while (true)
            {
                // does the work of applying in-progress writes; throws UAE or timeout if it can't
<span class="fc" id="L845">                final BeginResult begin = begin(deadline, read, consistencyForConsensus, false, minimumBallot, failedAttemptsDueToContention);</span>
<span class="fc" id="L846">                failedAttemptsDueToContention = begin.failedAttemptsDueToContention;</span>

<span class="pc bpc" id="L848" title="2 of 3 branches missed.">                switch (PAXOS_VARIANT)</span>
                {
<span class="nc" id="L850">                    default: throw new AssertionError();</span>

                    case v2_without_linearizable_reads_or_rejected_writes:
                    case v2_without_linearizable_reads:
<span class="nc" id="L854">                        return begin.readResponse;</span>

                    case v2:
                        // no need to submit an empty proposal, as the promise will be treated as complete for future optimistic reads
<span class="fc bfc" id="L858" title="All 2 branches covered.">                        if (begin.isLinearizableRead)</span>
<span class="fc" id="L859">                            return begin.readResponse;</span>
                }

<span class="fc" id="L862">                Proposal proposal = Proposal.empty(begin.ballot, read.partitionKey(), read.metadata());</span>
<span class="fc" id="L863">                PaxosPropose.Status propose = propose(proposal, begin.participants, false).awaitUntil(deadline);</span>
<span class="pc bpc" id="L864" title="2 of 4 branches missed.">                switch (propose.outcome)</span>
                {
<span class="nc" id="L866">                    default: throw new IllegalStateException();</span>

                    case MAYBE_FAILURE:
<span class="nc" id="L869">                        throw propose.maybeFailure().markAndThrowAsTimeoutOrFailure(false, consistencyForConsensus, failedAttemptsDueToContention);</span>

                    case SUCCESS:
<span class="fc" id="L872">                        return begin.readResponse;</span>

                    case SUPERSEDED:
<span class="pc bpc" id="L875" title="1 of 3 branches missed.">                        switch (propose.superseded().hadSideEffects)</span>
                        {
<span class="nc" id="L877">                            default: throw new IllegalStateException();</span>

                            case MAYBE:
                                // We don't know if our update has been applied, as the competing ballot may have completed
                                // our proposal.  We yield our uncertainty to the caller via timeout exception.
                                // TODO: should return more useful result to client, and should also avoid this situation where possible
<span class="fc" id="L883">                                throw new MaybeFailure(false, begin.participants.sizeOfPoll(), begin.participants.sizeOfConsensusQuorum, 0, emptyMap())</span>
<span class="nc" id="L884">                                      .markAndThrowAsTimeoutOrFailure(true, consistencyForConsensus, failedAttemptsDueToContention);</span>

                            case NO:
<span class="fc" id="L887">                                minimumBallot = propose.superseded().by;</span>
                                // We have been superseded without our proposal being accepted by anyone, so we can safely retry
<span class="fc" id="L889">                                Tracing.trace(&quot;Paxos proposal not accepted (pre-empted by a higher ballot)&quot;);</span>
<span class="pc bpc" id="L890" title="1 of 2 branches missed.">                                if (!waitForContention(deadline, ++failedAttemptsDueToContention, group.metadata(), group.queries.get(0).partitionKey(), consistencyForConsensus, READ))</span>
<span class="nc" id="L891">                                    throw MaybeFailure.noResponses(begin.participants).markAndThrowAsTimeoutOrFailure(true, consistencyForConsensus, failedAttemptsDueToContention);</span>
                        }
                }
<span class="fc" id="L894">            }</span>
<span class="pc bpc" id="L895" title="3 of 4 branches missed.">        }</span>
        finally
        {
<span class="fc" id="L898">            long latency = nanoTime() - start;</span>
<span class="fc" id="L899">            readMetrics.addNano(latency);</span>
<span class="fc" id="L900">            casReadMetrics.addNano(latency);</span>
<span class="fc" id="L901">            readMetricsMap.get(consistencyForConsensus).addNano(latency);</span>
<span class="fc" id="L902">            TableMetadata table = read.metadata();</span>
<span class="fc" id="L903">            Keyspace.open(table.keyspace).getColumnFamilyStore(table.name).metric.coordinatorReadLatency.update(latency, TimeUnit.NANOSECONDS);</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">            if (failedAttemptsDueToContention &gt; 0)</span>
<span class="fc" id="L905">                casReadMetrics.contention.update(failedAttemptsDueToContention);</span>
        }
    }

<span class="fc" id="L909">    static class BeginResult</span>
    {
        final Ballot ballot;
        final Participants participants;
        final int failedAttemptsDueToContention;
        final PartitionIterator readResponse;
        final boolean isLinearizableRead;
        final boolean isPromised;
        final Ballot retryWithAtLeast;

        public BeginResult(Ballot ballot, Participants participants, int failedAttemptsDueToContention, PartitionIterator readResponse, boolean isLinearizableRead, boolean isPromised, Ballot retryWithAtLeast)
<span class="fc" id="L920">        {</span>
<span class="pc bpc" id="L921" title="1 of 4 branches missed.">            assert isPromised || isLinearizableRead;</span>
<span class="fc" id="L922">            this.ballot = ballot;</span>
<span class="fc" id="L923">            this.participants = participants;</span>
<span class="fc" id="L924">            this.failedAttemptsDueToContention = failedAttemptsDueToContention;</span>
<span class="fc" id="L925">            this.readResponse = readResponse;</span>
<span class="fc" id="L926">            this.isLinearizableRead = isLinearizableRead;</span>
<span class="fc" id="L927">            this.isPromised = isPromised;</span>
<span class="fc" id="L928">            this.retryWithAtLeast = retryWithAtLeast;</span>
<span class="fc" id="L929">        }</span>
    }

    /**
     * Begin a Paxos operation by seeking promises from our electorate to be completed with proposals by our caller; and:
     *
     *  - Completing any in-progress proposals witnessed, that are not known to have reached the commit phase
     *  - Completing any in-progress commits witnessed, that are not known to have reached a quorum of the electorate
     *  - Retrying and backing-off under contention
     *  - Detecting electorate mismatches with our peers and retrying to avoid non-overlapping
     *    electorates agreeing operations
     *  - Returning a resolved read response, and knowledge of if it is linearizable to read without proposing an empty update
     *
     * Optimisations:
     *    - If the promises report an incomplete commit (but have been able to witness it in a read response)
     *      we will submit the commit to those nodes that have not witnessed while waiting for those that have,
     *      returning as soon as a quorum is known to have witnessed the commit
     *    - If we witness an in-progress commit to complete, we batch the commit together with a new prepare
     *      restarting our operation.
     *    - If we witness an in-progress proposal to complete, after successfully proposing it we batch its
     *      commit together with a new prepare restarting our operation.
     *
     * @return the Paxos ballot promised by the replicas if no in-progress requests were seen and a quorum of
     * nodes have seen the mostRecentCommit.  Otherwise, return null.
     */
    @SuppressWarnings(&quot;resource&quot;)
    private static BeginResult begin(long deadline,
                                     SinglePartitionReadCommand query,
                                     ConsistencyLevel consistencyForConsensus,
                                     final boolean isWrite,
                                     Ballot minimumBallot,
                                     int failedAttemptsDueToContention)
            throws WriteTimeoutException, WriteFailureException, ReadTimeoutException, ReadFailureException
    {
<span class="fc bfc" id="L963" title="All 2 branches covered.">        boolean acceptEarlyReadPermission = !isWrite; // if we're reading, begin by assuming a read permission is sufficient</span>
<span class="fc" id="L964">        Participants initialParticipants = Participants.get(query.metadata(), query.partitionKey(), consistencyForConsensus);</span>
<span class="fc" id="L965">        initialParticipants.assureSufficientLiveNodes(isWrite);</span>
<span class="fc" id="L966">        PaxosPrepare preparing = prepare(minimumBallot, initialParticipants, query, isWrite, acceptEarlyReadPermission);</span>
        while (true)
        {
            // prepare
<span class="fc" id="L970">            PaxosPrepare retry = null;</span>
<span class="fc" id="L971">            PaxosPrepare.Status prepare = preparing.awaitUntil(deadline);</span>
<span class="fc" id="L972">            boolean isPromised = false;</span>
<span class="pc bpc" id="L973" title="3 of 8 branches missed.">            retry: switch (prepare.outcome)</span>
            {
<span class="nc" id="L975">                default: throw new IllegalStateException();</span>

                case FOUND_INCOMPLETE_COMMITTED:
                {
<span class="nc" id="L979">                    FoundIncompleteCommitted incomplete = prepare.incompleteCommitted();</span>
<span class="nc" id="L980">                    Tracing.trace(&quot;Repairing replicas that missed the most recent commit&quot;);</span>
<span class="nc" id="L981">                    retry = commitAndPrepare(incomplete.committed, incomplete.participants, query, isWrite, acceptEarlyReadPermission);</span>
<span class="nc" id="L982">                    break;</span>
                }
                case FOUND_INCOMPLETE_ACCEPTED:
                {
<span class="fc" id="L986">                    FoundIncompleteAccepted inProgress = prepare.incompleteAccepted();</span>
<span class="fc" id="L987">                    Tracing.trace(&quot;Finishing incomplete paxos round {}&quot;, inProgress.accepted);</span>
<span class="fc bfc" id="L988" title="All 2 branches covered.">                    if (isWrite)</span>
<span class="fc" id="L989">                        casWriteMetrics.unfinishedCommit.inc();</span>
                    else
<span class="fc" id="L991">                        casReadMetrics.unfinishedCommit.inc();</span>

                    // we DO NOT need to change the timestamp of this commit - either we or somebody else will finish it
                    // and the original timestamp is correctly linearised. By not updatinig the timestamp we leave enough
                    // information for nodes to avoid competing re-proposing the same proposal; if an in progress accept
                    // is equal to the latest commit (even if the ballots aren't) we're done and can abort earlier,
                    // and in fact it's possible for a CAS to sometimes determine if side effects occurred by reading
                    // the underlying data and not witnessing the timestamp of its ballot (or any newer for the relevant data).
<span class="fc" id="L999">                    Proposal repropose = new Proposal(inProgress.ballot, inProgress.accepted.update);</span>
<span class="fc" id="L1000">                    PaxosPropose.Status proposeResult = propose(repropose, inProgress.participants, false).awaitUntil(deadline);</span>
<span class="pc bpc" id="L1001" title="2 of 4 branches missed.">                    switch (proposeResult.outcome)</span>
                    {
<span class="nc" id="L1003">                        default: throw new IllegalStateException();</span>

                        case MAYBE_FAILURE:
<span class="nc" id="L1006">                            throw proposeResult.maybeFailure().markAndThrowAsTimeoutOrFailure(isWrite, consistencyForConsensus, failedAttemptsDueToContention);</span>

                        case SUCCESS:
<span class="fc" id="L1009">                            retry = commitAndPrepare(repropose.agreed(), inProgress.participants, query, isWrite, acceptEarlyReadPermission);</span>
<span class="fc" id="L1010">                            break retry;</span>

                        case SUPERSEDED:
                            // since we are proposing a previous value that was maybe superseded by us before completion
                            // we don't need to test the side effects, as we just want to start again, and fall through
                            // to the superseded section below
<span class="fc" id="L1016">                            prepare = new PaxosPrepare.Superseded(proposeResult.superseded().by, inProgress.participants);</span>

                    }
                }

                case SUPERSEDED:
                {
<span class="fc" id="L1023">                    Tracing.trace(&quot;Some replicas have already promised a higher ballot than ours; aborting&quot;);</span>
                    // sleep a random amount to give the other proposer a chance to finish
<span class="pc bpc" id="L1025" title="1 of 4 branches missed.">                    if (!waitForContention(deadline, ++failedAttemptsDueToContention, query.metadata(), query.partitionKey(), consistencyForConsensus, isWrite ? WRITE : READ))</span>
<span class="nc" id="L1026">                        throw MaybeFailure.noResponses(prepare.participants).markAndThrowAsTimeoutOrFailure(true, consistencyForConsensus, failedAttemptsDueToContention);</span>
<span class="fc" id="L1027">                    retry = prepare(prepare.retryWithAtLeast(), prepare.participants, query, isWrite, acceptEarlyReadPermission);</span>
<span class="fc" id="L1028">                    break;</span>
                }
<span class="fc" id="L1030">                case PROMISED: isPromised = true;</span>
                case READ_PERMITTED:
                {
                    // We have received a quorum of promises (or read permissions) that have all witnessed the commit of the prior paxos
                    // round's proposal (if any).
<span class="fc" id="L1035">                    PaxosPrepare.Success success = prepare.success();</span>

<span class="fc" id="L1037">                    DataResolver&lt;?, ?&gt; resolver = new DataResolver(query, success.participants, NoopReadRepair.instance, query.creationTimeNanos());</span>
<span class="fc bfc" id="L1038" title="All 2 branches covered.">                    for (int i = 0 ; i &lt; success.responses.size() ; ++i)</span>
<span class="fc" id="L1039">                        resolver.preprocess(success.responses.get(i));</span>

<span class="pc" id="L1041">                    class WasRun implements Runnable { boolean v; public void run() { v = true; } }</span>
<span class="fc" id="L1042">                    WasRun hadShortRead = new WasRun();</span>
<span class="fc" id="L1043">                    PartitionIterator result = resolver.resolve(hadShortRead);</span>

<span class="pc bpc" id="L1045" title="1 of 4 branches missed.">                    if (!isPromised &amp;&amp; hadShortRead.v)</span>
                    {
                        // we need to propose an empty update to linearize our short read, but only had read success
                        // since we may continue to perform short reads, we ask our prepare not to accept an early
                        // read permission, when a promise may yet be obtained
                        // TODO: increase read size each time this happens?
<span class="nc" id="L1051">                        acceptEarlyReadPermission = false;</span>
<span class="nc" id="L1052">                        break;</span>
                    }

<span class="pc bpc" id="L1055" title="1 of 4 branches missed.">                    return new BeginResult(success.ballot, success.participants, failedAttemptsDueToContention, result, !hadShortRead.v &amp;&amp; success.isReadSafe, isPromised, success.supersededBy);</span>
                }

                case MAYBE_FAILURE:
<span class="nc" id="L1059">                    throw prepare.maybeFailure().markAndThrowAsTimeoutOrFailure(isWrite, consistencyForConsensus, failedAttemptsDueToContention);</span>

                case ELECTORATE_MISMATCH:
<span class="fc" id="L1062">                    Participants participants = Participants.get(query.metadata(), query.partitionKey(), consistencyForConsensus);</span>
<span class="fc" id="L1063">                    participants.assureSufficientLiveNodes(isWrite);</span>
<span class="fc" id="L1064">                    retry = prepare(participants, query, isWrite, acceptEarlyReadPermission);</span>
                    break;

            }

<span class="pc bpc" id="L1069" title="1 of 2 branches missed.">            if (retry == null)</span>
            {
<span class="nc" id="L1071">                Tracing.trace(&quot;Some replicas have already promised a higher ballot than ours; retrying&quot;);</span>
                // sleep a random amount to give the other proposer a chance to finish
<span class="nc bnc" id="L1073" title="All 4 branches missed.">                if (!waitForContention(deadline, ++failedAttemptsDueToContention, query.metadata(), query.partitionKey(), consistencyForConsensus, isWrite ? WRITE : READ))</span>
<span class="nc" id="L1074">                    throw MaybeFailure.noResponses(prepare.participants).markAndThrowAsTimeoutOrFailure(true, consistencyForConsensus, failedAttemptsDueToContention);</span>
<span class="nc" id="L1075">                retry = prepare(prepare.retryWithAtLeast(), prepare.participants, query, isWrite, acceptEarlyReadPermission);</span>
            }

<span class="fc" id="L1078">            preparing = retry;</span>
<span class="fc" id="L1079">        }</span>
    }

    public static boolean isInRangeAndShouldProcess(InetAddressAndPort from, DecoratedKey key, TableMetadata table, boolean includesRead)
    {
<span class="fc" id="L1084">        Keyspace keyspace = Keyspace.open(table.keyspace);</span>
<span class="fc bfc" id="L1085" title="All 2 branches covered.">        return (includesRead ? EndpointsForToken.natural(keyspace, key.getToken())</span>
<span class="fc" id="L1086">                             : ReplicaLayout.forTokenWriteLiveAndDown(keyspace, key.getToken()).all()</span>
<span class="fc" id="L1087">        ).contains(getBroadcastAddressAndPort());</span>
    }

    static ConsistencyLevel nonSerial(ConsistencyLevel serial)
    {
<span class="pc bpc" id="L1092" title="1 of 3 branches missed.">        switch (serial)</span>
        {
<span class="nc" id="L1094">            default: throw new IllegalStateException();</span>
<span class="fc" id="L1095">            case SERIAL: return QUORUM;</span>
<span class="fc" id="L1096">            case LOCAL_SERIAL: return LOCAL_QUORUM;</span>
        }
    }

    private static void mark(boolean isWrite, Function&lt;ClientRequestMetrics, Meter&gt; toMark, ConsistencyLevel consistency)
    {
<span class="fc bfc" id="L1102" title="All 2 branches covered.">        if (isWrite)</span>
        {
<span class="fc" id="L1104">            toMark.apply(casWriteMetrics).mark();</span>
<span class="fc" id="L1105">            toMark.apply(writeMetricsMap.get(consistency)).mark();</span>
        }
        else
        {
<span class="fc" id="L1109">            toMark.apply(casReadMetrics).mark();</span>
<span class="fc" id="L1110">            toMark.apply(readMetricsMap.get(consistency)).mark();</span>
        }
<span class="fc" id="L1112">    }</span>

    public static Ballot newBallot(@Nullable Ballot minimumBallot, ConsistencyLevel consistency)
    {
        // We want a timestamp that is guaranteed to be unique for that node (so that the ballot is globally unique), but if we've got a prepare rejected
        // already we also want to make sure we pick a timestamp that has a chance to be promised, i.e. one that is greater that the most recently known
        // in progress (#5667). Lastly, we don't want to use a timestamp that is older than the last one assigned by ClientState or operations may appear
        // out-of-order (#7801).
<span class="fc bfc" id="L1120" title="All 2 branches covered.">        long minTimestampMicros = minimumBallot == null ? Long.MIN_VALUE : 1 + minimumBallot.unixMicros();</span>
        // Note that ballotMicros is not guaranteed to be unique if two proposal are being handled concurrently by the same coordinator. But we still
        // need ballots to be unique for each proposal so we have to use getRandomTimeUUIDFromMicros.
<span class="fc" id="L1123">        return nextBallot(minTimestampMicros, flag(consistency));</span>
    }

    static Ballot staleBallotNewerThan(Ballot than, ConsistencyLevel consistency)
    {
<span class="fc" id="L1128">        long minTimestampMicros = 1 + than.unixMicros();</span>
<span class="fc" id="L1129">        long maxTimestampMicros = BallotGenerator.Global.prevUnixMicros();</span>
<span class="fc" id="L1130">        maxTimestampMicros -= Math.min((maxTimestampMicros - minTimestampMicros) / 2, SECONDS.toMicros(5L));</span>
<span class="pc bpc" id="L1131" title="1 of 2 branches missed.">        if (maxTimestampMicros &lt;= minTimestampMicros)</span>
<span class="nc" id="L1132">            return nextBallot(minTimestampMicros, flag(consistency));</span>

<span class="fc" id="L1134">        return staleBallot(minTimestampMicros, maxTimestampMicros, flag(consistency));</span>
    }

    /**
     * Create a ballot uuid with the consistency level encoded in the timestamp.
     *
     * UUIDGen.getRandomTimeUUIDFromMicros timestamps are always a multiple of 10, so we add a 1 or 2 to indicate
     * the consistency level of the operation. This should have no effect in practice (except preferring a serial
     * operation over a local serial if there's a timestamp collision), but lets us avoid adding CL to the paxos
     * table and messages, which should make backcompat easier if a different solution is committed upstream.
     */
    public static Ballot ballotForConsistency(long whenInMicros, ConsistencyLevel consistency)
    {
<span class="nc" id="L1147">        Preconditions.checkArgument(consistency.isSerialConsistency());</span>
<span class="nc" id="L1148">        return nextBallot(whenInMicros, flag(consistency));</span>
    }

    private static Ballot.Flag flag(ConsistencyLevel consistency)
    {
<span class="fc bfc" id="L1153" title="All 2 branches covered.">        return consistency == SERIAL ? GLOBAL : LOCAL;</span>
    }

    public static ConsistencyLevel consistency(Ballot ballot)
    {
<span class="pc bpc" id="L1158" title="1 of 3 branches missed.">        switch (ballot.flag())</span>
        {
<span class="nc" id="L1160">            default: return null;</span>
<span class="fc" id="L1161">            case LOCAL: return LOCAL_SERIAL;</span>
<span class="fc" id="L1162">            case GLOBAL: return SERIAL;</span>
        }
    }

    static Map&lt;InetAddressAndPort, EndpointState&gt; verifyElectorate(Electorate remoteElectorate, Electorate localElectorate)
    {
        // verify electorates; if they differ, send back gossip info for superset of two participant sets
<span class="fc bfc" id="L1169" title="All 2 branches covered.">        if (remoteElectorate.equals(localElectorate))</span>
<span class="fc" id="L1170">            return emptyMap();</span>

<span class="fc" id="L1172">        Map&lt;InetAddressAndPort, EndpointState&gt; endpoints = Maps.newHashMapWithExpectedSize(remoteElectorate.size() + localElectorate.size());</span>
<span class="fc bfc" id="L1173" title="All 2 branches covered.">        for (InetAddressAndPort host : remoteElectorate)</span>
        {
<span class="fc" id="L1175">            EndpointState endpoint = Gossiper.instance.copyEndpointStateForEndpoint(host);</span>
<span class="pc bpc" id="L1176" title="1 of 2 branches missed.">            if (endpoint == null)</span>
            {
<span class="nc" id="L1178">                NoSpamLogger.log(logger, WARN, 1, TimeUnit.MINUTES, &quot;Remote electorate {} could not be found in Gossip&quot;, host);</span>
<span class="nc" id="L1179">                continue;</span>
            }
<span class="fc" id="L1181">            endpoints.put(host, endpoint);</span>
<span class="fc" id="L1182">        }</span>
<span class="fc bfc" id="L1183" title="All 2 branches covered.">        for (InetAddressAndPort host : localElectorate)</span>
        {
<span class="fc" id="L1185">            EndpointState endpoint = Gossiper.instance.copyEndpointStateForEndpoint(host);</span>
<span class="pc bpc" id="L1186" title="1 of 2 branches missed.">            if (endpoint == null)</span>
            {
<span class="nc" id="L1188">                NoSpamLogger.log(logger, WARN, 1, TimeUnit.MINUTES, &quot;Local electorate {} could not be found in Gossip&quot;, host);</span>
<span class="nc" id="L1189">                continue;</span>
            }
<span class="fc" id="L1191">            endpoints.putIfAbsent(host, endpoint);</span>
<span class="fc" id="L1192">        }</span>

<span class="fc" id="L1194">        return endpoints;</span>
    }

    public static boolean useV2()
    {
<span class="pc bpc" id="L1199" title="1 of 3 branches missed.">        switch (PAXOS_VARIANT)</span>
        {
            case v2_without_linearizable_reads_or_rejected_writes:
            case v2_without_linearizable_reads:
            case v2:
<span class="fc" id="L1204">                return true;</span>
            case v1:
            case v1_without_linearizable_reads_or_rejected_writes:
<span class="fc" id="L1207">                return false;</span>
            default:
<span class="nc" id="L1209">                throw new AssertionError();</span>
        }
    }

    public static boolean isLinearizable()
    {
<span class="pc bpc" id="L1215" title="1 of 3 branches missed.">        switch (PAXOS_VARIANT)</span>
        {
            case v2:
            case v1:
<span class="fc" id="L1219">                return true;</span>
            case v2_without_linearizable_reads_or_rejected_writes:
            case v2_without_linearizable_reads:
            case v1_without_linearizable_reads_or_rejected_writes:
<span class="fc" id="L1223">                return false;</span>
            default:
<span class="nc" id="L1225">                throw new AssertionError();</span>
        }
    }

    public static void setPaxosVariant(Config.PaxosVariant paxosVariant)
    {
<span class="fc" id="L1231">        Preconditions.checkNotNull(paxosVariant);</span>
<span class="fc" id="L1232">        PAXOS_VARIANT = paxosVariant;</span>
<span class="fc" id="L1233">        DatabaseDescriptor.setPaxosVariant(paxosVariant);</span>
<span class="fc" id="L1234">    }</span>

    public static Config.PaxosVariant getPaxosVariant()
    {
<span class="fc" id="L1238">        return PAXOS_VARIANT;</span>
    }

    static boolean isOldParticipant(Replica replica)
    {
<span class="nc" id="L1243">        String version = Gossiper.instance.getForEndpoint(replica.endpoint(), RELEASE_VERSION);</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">        if (version == null)</span>
<span class="nc" id="L1245">            return false;</span>

        try
        {
<span class="nc bnc" id="L1249" title="All 2 branches missed.">            return new CassandraVersion(version).compareTo(MODERN_PAXOS_RELEASE) &lt; 0;</span>
        }
<span class="nc" id="L1251">        catch (Throwable t)</span>
        {
<span class="nc" id="L1253">            return false;</span>
        }
    }

    public static void evictHungRepairs()
    {
<span class="fc" id="L1259">        PaxosTableRepairs.evictHungRepairs();</span>
<span class="fc" id="L1260">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>