<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IndexDescriptor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.index.sai.disk.format</a> &gt; <span class="el_source">IndexDescriptor.java</span></div><h1>IndexDescriptor.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.index.sai.disk.format;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.util.Set;
import java.util.stream.Collectors;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Objects;
import com.google.common.io.Files;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.db.ClusteringComparator;
import org.apache.cassandra.db.lifecycle.LifecycleNewTracker;
import org.apache.cassandra.dht.IPartitioner;
import org.apache.cassandra.index.sai.IndexContext;
import org.apache.cassandra.index.sai.IndexValidation;
import org.apache.cassandra.index.sai.SSTableContext;
import org.apache.cassandra.index.sai.StorageAttachedIndex;
import org.apache.cassandra.index.sai.disk.PerColumnIndexWriter;
import org.apache.cassandra.index.sai.disk.PerSSTableIndexWriter;
import org.apache.cassandra.index.sai.disk.PrimaryKeyMap;
import org.apache.cassandra.index.sai.disk.RowMapping;
import org.apache.cassandra.index.sai.disk.SSTableIndex;
import org.apache.cassandra.index.sai.disk.io.IndexFileUtils;
import org.apache.cassandra.index.sai.disk.io.IndexOutputWriter;
import org.apache.cassandra.index.sai.utils.PrimaryKey;
import org.apache.cassandra.io.sstable.Component;
import org.apache.cassandra.io.sstable.Descriptor;
import org.apache.cassandra.io.sstable.format.SSTableReader;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.io.util.FileHandle;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.Throwables;
import org.apache.lucene.store.IndexInput;
import org.apache.lucene.util.IOUtils;

/**
 * The {@link IndexDescriptor} is an analog of the SSTable {@link Descriptor} and provides version
 * specific information about the on-disk state of a {@link StorageAttachedIndex}.
 * &lt;p&gt;
 * The {@link IndexDescriptor} is primarily responsible for maintaining a view of the on-disk state
 * of an index for a specific {@link org.apache.cassandra.io.sstable.SSTable}.
 * &lt;p&gt;
 * It is responsible for opening files for use by writers and readers.
 * &lt;p&gt;
 * Its remaining responsibility is to act as a proxy to the {@link OnDiskFormat} associated with the
 * index {@link Version}.
 */
public class IndexDescriptor
{
<span class="fc" id="L71">    private static final Logger logger = LoggerFactory.getLogger(IndexDescriptor.class);</span>

    public final Version version;
    public final Descriptor sstableDescriptor;
    public final ClusteringComparator clusteringComparator;
    public final PrimaryKey.Factory primaryKeyFactory;

    private IndexDescriptor(Version version, Descriptor sstableDescriptor, IPartitioner partitioner, ClusteringComparator clusteringComparator)
<span class="fc" id="L79">    {</span>
<span class="fc" id="L80">        this.version = version;</span>
<span class="fc" id="L81">        this.sstableDescriptor = sstableDescriptor;</span>
<span class="fc" id="L82">        this.clusteringComparator = clusteringComparator;</span>
<span class="fc" id="L83">        this.primaryKeyFactory = new PrimaryKey.Factory(partitioner, clusteringComparator);</span>
<span class="fc" id="L84">    }</span>

    public static IndexDescriptor create(Descriptor descriptor, IPartitioner partitioner, ClusteringComparator clusteringComparator)
    {
<span class="fc" id="L88">        return new IndexDescriptor(Version.LATEST, descriptor, partitioner, clusteringComparator);</span>
    }

    public static IndexDescriptor create(SSTableReader sstable)
    {
<span class="fc bfc" id="L93" title="All 2 branches covered.">        for (Version version : Version.ALL)</span>
        {
<span class="fc" id="L95">            IndexDescriptor indexDescriptor = new IndexDescriptor(version,</span>
                                                                  sstable.descriptor,
<span class="fc" id="L97">                                                                  sstable.getPartitioner(),</span>
<span class="fc" id="L98">                                                                  sstable.metadata().comparator);</span>

<span class="fc bfc" id="L100" title="All 2 branches covered.">            if (version.onDiskFormat().isPerSSTableIndexBuildComplete(indexDescriptor))</span>
            {
<span class="fc" id="L102">                return indexDescriptor;</span>
            }
<span class="fc" id="L104">        }</span>
<span class="fc" id="L105">        return new IndexDescriptor(Version.LATEST,</span>
                                   sstable.descriptor,
<span class="fc" id="L107">                                   sstable.getPartitioner(),</span>
<span class="fc" id="L108">                                   sstable.metadata().comparator);</span>
    }

    public boolean hasClustering()
    {
<span class="fc bfc" id="L113" title="All 2 branches covered.">        return clusteringComparator.size() &gt; 0;</span>
    }

    public String componentName(IndexComponent indexComponent)
    {
<span class="fc" id="L118">        return version.fileNameFormatter().format(indexComponent, null);</span>
    }

    public PrimaryKeyMap.Factory newPrimaryKeyMapFactory(SSTableReader sstable)
    {
<span class="fc" id="L123">        return version.onDiskFormat().newPrimaryKeyMapFactory(this, sstable);</span>
    }

    public SSTableIndex newSSTableIndex(SSTableContext sstableContext, IndexContext indexContext)
    {
<span class="fc" id="L128">        return version.onDiskFormat().newSSTableIndex(sstableContext, indexContext);</span>
    }

    public PerSSTableIndexWriter newPerSSTableIndexWriter() throws IOException
    {
<span class="fc" id="L133">        return version.onDiskFormat().newPerSSTableIndexWriter(this);</span>
    }

    public PerColumnIndexWriter newPerColumnIndexWriter(StorageAttachedIndex index,
                                                        LifecycleNewTracker tracker,
                                                        RowMapping rowMapping)
    {
<span class="fc" id="L140">        return version.onDiskFormat().newPerColumnIndexWriter(index, this, tracker, rowMapping);</span>
    }

    public boolean isPerSSTableIndexBuildComplete()
    {
<span class="fc" id="L145">        return version.onDiskFormat().isPerSSTableIndexBuildComplete(this);</span>
    }

    public boolean isPerColumnIndexBuildComplete(IndexContext indexContext)
    {
<span class="fc" id="L150">        return version.onDiskFormat().isPerColumnIndexBuildComplete(this, indexContext);</span>
    }

    public boolean hasComponent(IndexComponent indexComponent)
    {
<span class="fc" id="L155">        return fileFor(indexComponent).exists();</span>
    }

    public boolean hasComponent(IndexComponent indexComponent, IndexContext indexContext)
    {
<span class="fc" id="L160">        return fileFor(indexComponent, indexContext).exists();</span>
    }

    public File fileFor(IndexComponent indexComponent)
    {
<span class="fc" id="L165">        return createFile(indexComponent, null);</span>
    }

    public File fileFor(IndexComponent indexComponent, IndexContext indexContext)
    {
<span class="fc" id="L170">        return createFile(indexComponent, indexContext);</span>
    }

    public boolean isIndexEmpty(IndexContext indexContext)
    {
        // The index is empty if the index build completed successfully in that both
        // a GROUP_COMPLETION_MARKER companent and a COLUMN_COMPLETION_MARKER exist for
        // the index and the number of per-index components is 1 indicating that only the
        // COLUMN_COMPLETION_MARKER exists for the index, as this is the only file that
        // will be written if the index is empty
<span class="pc bpc" id="L180" title="2 of 4 branches missed.">        return isPerColumnIndexBuildComplete(indexContext) &amp;&amp; numberOfPerIndexComponents(indexContext) == 1;</span>
    }

    public void createComponentOnDisk(IndexComponent component) throws IOException
    {
<span class="fc" id="L185">        Files.touch(fileFor(component).toJavaIOFile());</span>
<span class="fc" id="L186">    }</span>

    public void createComponentOnDisk(IndexComponent component, IndexContext indexContext) throws IOException
    {
<span class="fc" id="L190">        Files.touch(fileFor(component, indexContext).toJavaIOFile());</span>
<span class="fc" id="L191">    }</span>

    public IndexInput openPerSSTableInput(IndexComponent indexComponent)
    {
<span class="fc" id="L195">        File file = fileFor(indexComponent);</span>
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">        if (logger.isTraceEnabled())</span>
<span class="nc" id="L197">            logger.trace(logMessage(&quot;Opening blocking index input for file {} ({})&quot;),</span>
                         file,
<span class="nc" id="L199">                         FBUtilities.prettyPrintMemory(file.length()));</span>

<span class="fc" id="L201">        return IndexFileUtils.instance.openBlockingInput(file);</span>
    }

    public IndexInput openPerIndexInput(IndexComponent indexComponent, IndexContext indexContext)
    {
<span class="fc" id="L206">        final File file = fileFor(indexComponent, indexContext);</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (logger.isTraceEnabled())</span>
<span class="nc" id="L208">            logger.trace(logMessage(&quot;Opening blocking index input for file {} ({})&quot;),</span>
                         file,
<span class="nc" id="L210">                         FBUtilities.prettyPrintMemory(file.length()));</span>

<span class="fc" id="L212">        return IndexFileUtils.instance.openBlockingInput(file);</span>
    }

    public IndexOutputWriter openPerSSTableOutput(IndexComponent component) throws IOException
    {
<span class="fc" id="L217">        return openPerSSTableOutput(component, false);</span>
    }

    public IndexOutputWriter openPerSSTableOutput(IndexComponent component, boolean append) throws IOException
    {
<span class="fc" id="L222">        final File file = fileFor(component);</span>

<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        if (logger.isTraceEnabled())</span>
<span class="nc" id="L225">            logger.trace(logMessage(&quot;Creating SSTable attached index output for component {} on file {}...&quot;),</span>
                         component,
                         file);

<span class="fc" id="L229">        IndexOutputWriter writer = IndexFileUtils.instance.openOutput(file);</span>

<span class="pc bpc" id="L231" title="1 of 2 branches missed.">        if (append)</span>
        {
<span class="nc" id="L233">            writer.skipBytes(file.length());</span>
        }

<span class="fc" id="L236">        return writer;</span>
    }

    public IndexOutputWriter openPerIndexOutput(IndexComponent indexComponent, IndexContext indexContext) throws IOException
    {
<span class="fc" id="L241">        return openPerIndexOutput(indexComponent, indexContext, false);</span>
    }

    public IndexOutputWriter openPerIndexOutput(IndexComponent component, IndexContext indexContext, boolean append) throws IOException
    {
<span class="fc" id="L246">        final File file = fileFor(component, indexContext);</span>

<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        if (logger.isTraceEnabled())</span>
<span class="nc" id="L249">            logger.trace(indexContext.logMessage(&quot;Creating sstable attached index output for component {} on file {}...&quot;),</span>
                         component,
                         file);

<span class="fc" id="L253">        IndexOutputWriter writer = IndexFileUtils.instance.openOutput(file);</span>

<span class="fc bfc" id="L255" title="All 2 branches covered.">        if (append)</span>
        {
<span class="fc" id="L257">            writer.skipBytes(file.length());</span>
        }

<span class="fc" id="L260">        return writer;</span>
    }

    public FileHandle createPerSSTableFileHandle(IndexComponent indexComponent, Throwables.DiscreteAction&lt;?&gt; cleanup)
    {
        try
        {
<span class="fc" id="L267">            final File file = fileFor(indexComponent);</span>

<span class="pc bpc" id="L269" title="1 of 2 branches missed.">            if (logger.isTraceEnabled())</span>
            {
<span class="nc" id="L271">                logger.trace(logMessage(&quot;Opening {} file handle for {} ({})&quot;),</span>
<span class="nc" id="L272">                             file, FBUtilities.prettyPrintMemory(file.length()));</span>
            }

<span class="fc" id="L275">            return new FileHandle.Builder(file).mmapped(true).complete();</span>
        }
<span class="nc" id="L277">        catch (Throwable t)</span>
        {
<span class="nc" id="L279">            throw handleFileHandleCleanup(t, cleanup);</span>
        }
    }

    public FileHandle createPerIndexFileHandle(IndexComponent indexComponent, IndexContext indexContext, Throwables.DiscreteAction&lt;?&gt; cleanup)
    {
        try
        {
<span class="fc" id="L287">            final File file = fileFor(indexComponent, indexContext);</span>

<span class="pc bpc" id="L289" title="1 of 2 branches missed.">            if (logger.isTraceEnabled())</span>
            {
<span class="nc" id="L291">                logger.trace(indexContext.logMessage(&quot;Opening file handle for {} ({})&quot;),</span>
<span class="nc" id="L292">                             file, FBUtilities.prettyPrintMemory(file.length()));</span>
            }

<span class="fc" id="L295">            return new FileHandle.Builder(file).mmapped(true).complete();</span>
        }
<span class="nc" id="L297">        catch (Throwable t)</span>
        {
<span class="nc" id="L299">            throw handleFileHandleCleanup(t, cleanup);</span>
        }
    }

    private RuntimeException handleFileHandleCleanup(Throwable t, Throwables.DiscreteAction&lt;?&gt; cleanup)
    {
<span class="nc bnc" id="L305" title="All 2 branches missed.">        if (cleanup != null)</span>
        {
            try
            {
<span class="nc" id="L309">                cleanup.perform();</span>
            }
<span class="nc" id="L311">            catch (Exception e)</span>
            {
<span class="nc" id="L313">                return Throwables.unchecked(Throwables.merge(t, e));</span>
<span class="nc" id="L314">            }</span>
        }
<span class="nc" id="L316">        return Throwables.unchecked(t);</span>
    }

    public Set&lt;Component&gt; getLivePerSSTableComponents()
    {
<span class="fc" id="L321">        return version.onDiskFormat()</span>
<span class="fc" id="L322">                      .perSSTableIndexComponents(hasClustering())</span>
<span class="fc" id="L323">                      .stream()</span>
<span class="fc" id="L324">                      .filter(c -&gt; fileFor(c).exists())</span>
<span class="fc" id="L325">                      .map(version::makePerSSTableComponent)</span>
<span class="fc" id="L326">                      .collect(Collectors.toSet());</span>
    }

    public Set&lt;Component&gt; getLivePerIndexComponents(IndexContext indexContext)
    {
<span class="fc" id="L331">        return version.onDiskFormat()</span>
<span class="fc" id="L332">                      .perColumnIndexComponents(indexContext)</span>
<span class="fc" id="L333">                      .stream()</span>
<span class="fc" id="L334">                      .filter(c -&gt; fileFor(c, indexContext).exists())</span>
<span class="fc" id="L335">                      .map(c -&gt; version.makePerIndexComponent(c, indexContext))</span>
<span class="fc" id="L336">                      .collect(Collectors.toSet());</span>
    }

    public long sizeOnDiskOfPerSSTableComponents()
    {
<span class="nc" id="L341">        return version.onDiskFormat()</span>
<span class="nc" id="L342">                      .perSSTableIndexComponents(hasClustering())</span>
<span class="nc" id="L343">                      .stream()</span>
<span class="nc" id="L344">                      .map(this::fileFor)</span>
<span class="nc" id="L345">                      .filter(File::exists)</span>
<span class="nc" id="L346">                      .mapToLong(File::length)</span>
<span class="nc" id="L347">                      .sum();</span>
    }

    public long sizeOnDiskOfPerIndexComponents(IndexContext indexContext)
    {
<span class="nc" id="L352">        return version.onDiskFormat()</span>
<span class="nc" id="L353">                      .perColumnIndexComponents(indexContext)</span>
<span class="nc" id="L354">                      .stream()</span>
<span class="nc" id="L355">                      .map(c -&gt; fileFor(c, indexContext))</span>
<span class="nc" id="L356">                      .filter(File::exists)</span>
<span class="nc" id="L357">                      .mapToLong(File::length)</span>
<span class="nc" id="L358">                      .sum();</span>
    }

    @VisibleForTesting
    public long sizeOnDiskOfPerIndexComponent(IndexComponent indexComponent, IndexContext indexContext)
    {
<span class="nc" id="L364">        File componentFile = fileFor(indexComponent, indexContext);</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">        return componentFile.exists() ? componentFile.length() : 0;</span>
    }

    @SuppressWarnings(&quot;BooleanMethodIsAlwaysInverted&quot;)
    public boolean validatePerIndexComponents(IndexContext indexContext, IndexValidation validation)
    {
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">        if (validation == IndexValidation.NONE)</span>
<span class="nc" id="L372">            return true;</span>

<span class="fc" id="L374">        logger.info(indexContext.logMessage(&quot;Validating per-column index components using mode &quot; + validation));</span>
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">        boolean checksum = validation == IndexValidation.CHECKSUM;</span>

        try
        {
<span class="fc" id="L379">            version.onDiskFormat().validatePerColumnIndexComponents(this, indexContext, checksum);</span>
<span class="fc" id="L380">            return true;</span>
        }
<span class="nc" id="L382">        catch (UncheckedIOException e)</span>
        {
<span class="nc" id="L384">            return false;</span>
        }
    }

    @SuppressWarnings(&quot;BooleanMethodIsAlwaysInverted&quot;)
    public boolean validatePerSSTableComponents(IndexValidation validation)
    {
<span class="fc bfc" id="L391" title="All 2 branches covered.">        if (validation == IndexValidation.NONE)</span>
<span class="fc" id="L392">            return true;</span>

<span class="fc" id="L394">        logger.info(logMessage(&quot;Validating per-sstable index components using mode &quot; + validation));</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">        boolean checksum = validation == IndexValidation.CHECKSUM;</span>

        try
        {
<span class="fc" id="L399">            version.onDiskFormat().validatePerSSTableIndexComponents(this, checksum);</span>
<span class="fc" id="L400">            return true;</span>
        }
<span class="nc" id="L402">        catch (UncheckedIOException e)</span>
        {
<span class="nc" id="L404">            return false;</span>
        }
    }

    public void checksumPerIndexComponents(IndexContext indexContext)
    {
<span class="fc" id="L410">        version.onDiskFormat().validatePerColumnIndexComponents(this, indexContext, true);</span>
<span class="fc" id="L411">    }</span>

    @SuppressWarnings(&quot;BooleanMethodIsAlwaysInverted&quot;)
    public void checksumPerSSTableComponents()
    {
<span class="fc" id="L416">        version.onDiskFormat().validatePerSSTableIndexComponents(this, true);</span>
<span class="fc" id="L417">    }</span>

    public void deletePerSSTableIndexComponents()
    {
<span class="fc" id="L421">        version.onDiskFormat()</span>
<span class="fc" id="L422">               .perSSTableIndexComponents(hasClustering())</span>
<span class="fc" id="L423">               .stream()</span>
<span class="fc" id="L424">               .map(this::fileFor)</span>
<span class="fc" id="L425">               .filter(File::exists)</span>
<span class="fc" id="L426">               .forEach(this::deleteComponent);</span>
<span class="fc" id="L427">    }</span>

    public void deleteColumnIndex(IndexContext indexContext)
    {
<span class="fc" id="L431">        version.onDiskFormat()</span>
<span class="fc" id="L432">               .perColumnIndexComponents(indexContext)</span>
<span class="fc" id="L433">               .stream()</span>
<span class="fc" id="L434">               .map(c -&gt; fileFor(c, indexContext))</span>
<span class="fc" id="L435">               .filter(File::exists)</span>
<span class="fc" id="L436">               .forEach(this::deleteComponent);</span>
<span class="fc" id="L437">    }</span>

    @Override
    public int hashCode()
    {
<span class="nc" id="L442">        return Objects.hashCode(sstableDescriptor, version);</span>
    }

    @Override
    public boolean equals(Object o)
    {
<span class="nc bnc" id="L448" title="All 2 branches missed.">        if (this == o) return true;</span>
<span class="nc bnc" id="L449" title="All 4 branches missed.">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="nc" id="L450">        IndexDescriptor other = (IndexDescriptor)o;</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">        return Objects.equal(sstableDescriptor, other.sstableDescriptor) &amp;&amp;</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">               Objects.equal(version, other.version);</span>
    }

    @Override
    public String toString()
    {
<span class="fc" id="L458">        return sstableDescriptor.toString() + &quot;-SAI&quot;;</span>
    }

    public String logMessage(String message)
    {
        // Index names are unique only within a keyspace.
<span class="fc" id="L464">        return String.format(&quot;[%s.%s.*] %s&quot;,</span>
                             sstableDescriptor.ksname,
                             sstableDescriptor.cfname,
                             message);
    }

    private File createFile(IndexComponent component, IndexContext indexContext)
    {
<span class="fc" id="L472">        Component customComponent = version.makePerIndexComponent(component, indexContext);</span>
<span class="fc" id="L473">        return sstableDescriptor.fileFor(customComponent);</span>
    }

    private long numberOfPerIndexComponents(IndexContext indexContext)
    {
<span class="fc" id="L478">        return version.onDiskFormat()</span>
<span class="fc" id="L479">                      .perColumnIndexComponents(indexContext)</span>
<span class="fc" id="L480">                      .stream()</span>
<span class="fc" id="L481">                      .map(c -&gt; fileFor(c, indexContext))</span>
<span class="fc" id="L482">                      .filter(File::exists)</span>
<span class="fc" id="L483">                      .count();</span>
    }

    private void deleteComponent(File file)
    {
<span class="fc" id="L488">        logger.debug(logMessage(&quot;Deleting storage-attached index component file {}&quot;), file);</span>
        try
        {
<span class="fc" id="L491">            IOUtils.deleteFilesIfExist(file.toPath());</span>
        }
<span class="nc" id="L493">        catch (IOException e)</span>
        {
<span class="nc" id="L495">            logger.warn(logMessage(&quot;Unable to delete storage-attached index component file {} due to {}.&quot;), file, e.getMessage(), e);</span>
<span class="fc" id="L496">        }</span>
<span class="fc" id="L497">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>