<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IndexContext.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.index.sai</a> &gt; <span class="el_source">IndexContext.java</span></div><h1>IndexContext.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.index.sai;

import java.nio.ByteBuffer;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Nullable;

import com.google.common.base.MoreObjects;
import com.google.common.collect.ImmutableSet;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.cql3.Operator;
import org.apache.cassandra.cql3.statements.schema.IndexTarget;
import org.apache.cassandra.db.ClusteringComparator;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.marshal.AsciiType;
import org.apache.cassandra.db.marshal.BooleanType;
import org.apache.cassandra.db.marshal.CompositeType;
import org.apache.cassandra.db.marshal.UTF8Type;
import org.apache.cassandra.db.marshal.UUIDType;
import org.apache.cassandra.db.rows.Cell;
import org.apache.cassandra.db.rows.Row;
import org.apache.cassandra.dht.IPartitioner;
import org.apache.cassandra.index.sai.analyzer.AbstractAnalyzer;
import org.apache.cassandra.index.sai.disk.SSTableIndex;
import org.apache.cassandra.index.sai.disk.format.Version;
import org.apache.cassandra.index.sai.memory.MemtableIndexManager;
import org.apache.cassandra.index.sai.metrics.ColumnQueryMetrics;
import org.apache.cassandra.index.sai.metrics.IndexMetrics;
import org.apache.cassandra.index.sai.plan.Expression;
import org.apache.cassandra.index.sai.utils.PrimaryKey;
import org.apache.cassandra.index.sai.utils.TypeUtil;
import org.apache.cassandra.index.sai.view.IndexViewManager;
import org.apache.cassandra.index.sai.view.View;
import org.apache.cassandra.io.sstable.format.SSTableReader;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.IndexMetadata;
import org.apache.cassandra.utils.Pair;

/**
 * Manages metadata for each column index.
 */
public class IndexContext
{
<span class="fc" id="L69">    private static final Logger logger = LoggerFactory.getLogger(IndexContext.class);</span>

<span class="fc" id="L71">    private static final Set&lt;AbstractType&lt;?&gt;&gt; EQ_ONLY_TYPES = ImmutableSet.of(UTF8Type.instance,</span>
                                                                              AsciiType.instance,
                                                                              BooleanType.instance,
                                                                              UUIDType.instance);

    private final AbstractType&lt;?&gt; partitionKeyType;
    private final ClusteringComparator clusteringComparator;

    private final String keyspace;
    private final String table;
    private final ColumnMetadata columnMetadata;
    private final IndexTarget.Type indexType;
    private final AbstractType&lt;?&gt; validator;

    // Config can be null if the column context is &quot;fake&quot; (i.e. created for a filtering expression).
    @Nullable
    private final IndexMetadata indexMetadata;

    private final MemtableIndexManager memtableIndexManager;

    private final IndexViewManager viewManager;
    private final IndexMetrics indexMetrics;
    private final ColumnQueryMetrics columnQueryMetrics;
    private final AbstractAnalyzer.AnalyzerFactory analyzerFactory;
    private final PrimaryKey.Factory primaryKeyFactory;

    public IndexContext(String keyspace,
                        String table,
                        AbstractType&lt;?&gt; partitionKeyType,
                        IPartitioner partitioner,
                        ClusteringComparator clusteringComparator,
                        ColumnMetadata columnMetadata,
                        IndexTarget.Type indexType,
                        @Nullable IndexMetadata indexMetadata)
<span class="fc" id="L105">    {</span>
<span class="fc" id="L106">        this.keyspace = Objects.requireNonNull(keyspace);</span>
<span class="fc" id="L107">        this.table = Objects.requireNonNull(table);</span>
<span class="fc" id="L108">        this.partitionKeyType = Objects.requireNonNull(partitionKeyType);</span>
<span class="fc" id="L109">        this.clusteringComparator = Objects.requireNonNull(clusteringComparator);</span>
<span class="fc" id="L110">        this.columnMetadata = Objects.requireNonNull(columnMetadata);</span>
<span class="fc" id="L111">        this.indexType = Objects.requireNonNull(indexType);</span>
<span class="fc" id="L112">        this.validator = TypeUtil.cellValueType(columnMetadata, indexType);</span>
<span class="fc" id="L113">        this.primaryKeyFactory = new PrimaryKey.Factory(partitioner, clusteringComparator);</span>

<span class="fc" id="L115">        this.indexMetadata = indexMetadata;</span>
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        this.memtableIndexManager = indexMetadata == null ? null : new MemtableIndexManager(this);</span>

<span class="pc bpc" id="L118" title="1 of 2 branches missed.">        this.indexMetrics = indexMetadata == null ? null : new IndexMetrics(this);</span>
<span class="fc" id="L119">        this.viewManager = new IndexViewManager(this);</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">        this.columnQueryMetrics = isLiteral() ? new ColumnQueryMetrics.TrieIndexMetrics(this)</span>
<span class="fc" id="L121">                                              : new ColumnQueryMetrics.BalancedTreeIndexMetrics(this);</span>

<span class="pc bpc" id="L123" title="1 of 2 branches missed.">        this.analyzerFactory = indexMetadata == null ? AbstractAnalyzer.fromOptions(getValidator(), Collections.emptyMap())</span>
<span class="fc" id="L124">                                                     : AbstractAnalyzer.fromOptions(getValidator(), indexMetadata.options);</span>
<span class="fc" id="L125">    }</span>

    public boolean hasClustering()
    {
<span class="fc bfc" id="L129" title="All 2 branches covered.">        return clusteringComparator.size() &gt; 0;</span>
    }

    public AbstractType&lt;?&gt; keyValidator()
    {
<span class="nc" id="L134">        return partitionKeyType;</span>
    }

    public PrimaryKey.Factory keyFactory()
    {
<span class="fc" id="L139">        return primaryKeyFactory;</span>
    }

    public String getKeyspace()
    {
<span class="fc" id="L144">        return keyspace;</span>
    }

    public IndexMetrics getIndexMetrics()
    {
<span class="fc" id="L149">        return indexMetrics;</span>
    }

    public ColumnQueryMetrics getColumnQueryMetrics()
    {
<span class="fc" id="L154">        return columnQueryMetrics;</span>
    }

    public String getTable()
    {
<span class="fc" id="L159">        return table;</span>
    }

    public IndexMetadata getIndexMetadata()
    {
<span class="fc" id="L164">        return indexMetadata;</span>
    }

    /**
     * @return A set of SSTables which have attached to them invalid index components.
     */
    public Collection&lt;SSTableContext&gt; onSSTableChanged(Collection&lt;SSTableReader&gt; oldSSTables, Collection&lt;SSTableContext&gt; newSSTables, IndexValidation validation)
    {
<span class="fc" id="L172">        return viewManager.update(oldSSTables, newSSTables, validation);</span>
    }

    public ColumnMetadata getDefinition()
    {
<span class="fc" id="L177">        return columnMetadata;</span>
    }

    public AbstractType&lt;?&gt; getValidator()
    {
<span class="fc" id="L182">        return validator;</span>
    }

    public boolean isNonFrozenCollection()
    {
<span class="fc" id="L187">        return TypeUtil.isNonFrozenCollection(columnMetadata.type);</span>
    }

    public boolean isFrozen()
    {
<span class="fc" id="L192">        return TypeUtil.isFrozen(columnMetadata.type);</span>
    }

    public String getColumnName()
    {
<span class="fc" id="L197">        return columnMetadata.name.toString();</span>
    }

    @Nullable
    public String getIndexName()
    {
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        return indexMetadata == null ? null : indexMetadata.name;</span>
    }

    /**
     * Returns an {@link AbstractAnalyzer.AnalyzerFactory} for use by write and query paths to transform
     * literal values.
     */
    public AbstractAnalyzer.AnalyzerFactory getAnalyzerFactory()
    {
<span class="fc" id="L212">        return analyzerFactory;</span>
    }

    public View getView()
    {
<span class="fc" id="L217">        return viewManager.getView();</span>
    }

    public MemtableIndexManager getMemtableIndexManager()
    {
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">        assert memtableIndexManager != null : &quot;Attempt to use memtable index manager on non-indexed context&quot;;</span>

<span class="fc" id="L224">        return memtableIndexManager;</span>
    }

    /**
     * @return total number of per-index open files
     */
    public int openPerIndexFiles()
    {
<span class="nc" id="L232">        return viewManager.getView().size() * Version.LATEST.onDiskFormat().openFilesPerColumnIndex(this);</span>
    }

    public void drop(Collection&lt;SSTableReader&gt; sstablesToRebuild)
    {
<span class="fc" id="L237">        viewManager.drop(sstablesToRebuild);</span>
<span class="fc" id="L238">    }</span>

    public boolean isNotIndexed()
    {
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">        return indexMetadata == null;</span>
    }

    /**
     * Called when index is dropped. Clear all live in-memory indexes and close
     * analyzer factories. Mark all {@link SSTableIndex} as released and per-column index files
     * will be removed when in-flight queries are completed.
     */
    public void invalidate()
    {
<span class="fc" id="L252">        viewManager.invalidate();</span>
<span class="fc" id="L253">        analyzerFactory.close();</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">        if (memtableIndexManager != null)</span>
<span class="fc" id="L255">            memtableIndexManager.invalidate();</span>
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">        if (indexMetrics != null)</span>
<span class="fc" id="L257">            indexMetrics.release();</span>
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">        if (columnQueryMetrics != null)</span>
<span class="fc" id="L259">            columnQueryMetrics.release();</span>
<span class="fc" id="L260">    }</span>

    public boolean supports(Operator op)
    {
<span class="pc bpc" id="L264" title="5 of 10 branches missed.">        if (op == Operator.LIKE ||</span>
            op == Operator.LIKE_CONTAINS ||
            op == Operator.LIKE_PREFIX ||
            op == Operator.LIKE_MATCHES ||
<span class="nc" id="L268">            op == Operator.LIKE_SUFFIX) return false;</span>

<span class="fc" id="L270">        Expression.IndexOperator operator = Expression.IndexOperator.valueOf(op);</span>

<span class="pc bpc" id="L272" title="1 of 2 branches missed.">        if (isNonFrozenCollection())</span>
        {
<span class="nc bnc" id="L274" title="All 4 branches missed.">            if (indexType == IndexTarget.Type.KEYS) return operator == Expression.IndexOperator.CONTAINS_KEY;</span>
<span class="nc bnc" id="L275" title="All 4 branches missed.">            if (indexType == IndexTarget.Type.VALUES) return operator == Expression.IndexOperator.CONTAINS_VALUE;</span>
<span class="nc bnc" id="L276" title="All 4 branches missed.">            return indexType == IndexTarget.Type.KEYS_AND_VALUES &amp;&amp; operator == Expression.IndexOperator.EQ;</span>
        }

<span class="pc bpc" id="L279" title="1 of 2 branches missed.">        if (indexType == IndexTarget.Type.FULL)</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">            return operator == Expression.IndexOperator.EQ;</span>

<span class="fc" id="L282">        AbstractType&lt;?&gt; validator = getValidator();</span>

<span class="pc bpc" id="L284" title="1 of 4 branches missed.">        if (operator != Expression.IndexOperator.EQ &amp;&amp; EQ_ONLY_TYPES.contains(validator)) return false;</span>

        // RANGE only applicable to non-literal indexes
<span class="pc bpc" id="L287" title="2 of 6 branches missed.">        return (operator != null) &amp;&amp; !(TypeUtil.isLiteral(validator) &amp;&amp; operator == Expression.IndexOperator.RANGE);</span>
    }

    public ByteBuffer getValueOf(DecoratedKey key, Row row, long nowInSecs)
    {
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">        if (row == null)</span>
<span class="nc" id="L293">            return null;</span>

<span class="pc bpc" id="L295" title="4 of 5 branches missed.">        switch (columnMetadata.kind)</span>
        {
            case PARTITION_KEY:
<span class="nc bnc" id="L298" title="All 2 branches missed.">                return partitionKeyType instanceof CompositeType</span>
<span class="nc" id="L299">                       ? CompositeType.extractComponent(key.getKey(), columnMetadata.position())</span>
<span class="nc" id="L300">                       : key.getKey();</span>
            case CLUSTERING:
                // skip indexing of static clustering when regular column is indexed
<span class="nc bnc" id="L303" title="All 2 branches missed.">                return row.isStatic() ? null : row.clustering().bufferAt(columnMetadata.position());</span>

            // treat static cell retrieval the same was as regular
            // only if row kind is STATIC otherwise return null
            case STATIC:
<span class="nc bnc" id="L308" title="All 2 branches missed.">                if (!row.isStatic())</span>
<span class="nc" id="L309">                    return null;</span>
            case REGULAR:
<span class="fc" id="L311">                Cell&lt;?&gt; cell = row.getCell(columnMetadata);</span>
<span class="pc bpc" id="L312" title="1 of 4 branches missed.">                return cell == null || !cell.isLive(nowInSecs) ? null : cell.buffer();</span>

            default:
<span class="nc" id="L315">                return null;</span>
        }
    }

    public Iterator&lt;ByteBuffer&gt; getValuesOf(Row row, long nowInSecs)
    {
<span class="nc bnc" id="L321" title="All 2 branches missed.">        if (row == null)</span>
<span class="nc" id="L322">            return null;</span>

<span class="nc bnc" id="L324" title="All 3 branches missed.">        switch (columnMetadata.kind)</span>
        {
            // treat static cell retrieval the same was as regular
            // only if row kind is STATIC otherwise return null
            case STATIC:
<span class="nc bnc" id="L329" title="All 2 branches missed.">                if (!row.isStatic())</span>
<span class="nc" id="L330">                    return null;</span>
            case REGULAR:
<span class="nc" id="L332">                return TypeUtil.collectionIterator(validator,</span>
<span class="nc" id="L333">                                                   row.getComplexColumnData(columnMetadata),</span>
                                                   columnMetadata,
                                                   indexType,
                                                   nowInSecs);

            default:
<span class="nc" id="L339">                return null;</span>
        }
    }

    @Override
    public String toString()
    {
<span class="nc" id="L346">        return MoreObjects.toStringHelper(this)</span>
<span class="nc" id="L347">                          .add(&quot;columnName&quot;, getColumnName())</span>
<span class="nc" id="L348">                          .add(&quot;indexName&quot;, getIndexName())</span>
<span class="nc" id="L349">                          .toString();</span>
    }

    public boolean isLiteral()
    {
<span class="fc" id="L354">        return TypeUtil.isLiteral(getValidator());</span>
    }

    @Override
    public boolean equals(Object obj)
    {
<span class="nc bnc" id="L360" title="All 2 branches missed.">        if (obj == this)</span>
<span class="nc" id="L361">            return true;</span>

<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (!(obj instanceof IndexContext))</span>
<span class="nc" id="L364">            return false;</span>

<span class="nc" id="L366">        IndexContext other = (IndexContext) obj;</span>

<span class="nc bnc" id="L368" title="All 4 branches missed.">        return Objects.equals(columnMetadata, other.columnMetadata) &amp;&amp;</span>
               (indexType == other.indexType) &amp;&amp;
<span class="nc bnc" id="L370" title="All 2 branches missed.">               Objects.equals(indexMetadata, other.indexMetadata) &amp;&amp;</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">               Objects.equals(partitionKeyType, other.partitionKeyType) &amp;&amp;</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">               Objects.equals(clusteringComparator, other.clusteringComparator);</span>
    }

    @Override
    public int hashCode()
    {
<span class="fc" id="L378">        return Objects.hash(columnMetadata, indexType, indexMetadata, partitionKeyType, clusteringComparator);</span>
    }

    /**
     * A helper method for constructing consistent log messages for specific column indexes.
     * &lt;p&gt;
     * Example: For the index &quot;idx&quot; in keyspace &quot;ks&quot; on table &quot;tb&quot;, calling this method with the raw message
     * &quot;Flushing new index segment...&quot; will produce...
     * &lt;p&gt;
     * &quot;[ks.tb.idx] Flushing new index segment...&quot;
     *
     * @param message The raw content of a logging message, without information identifying it with an index.
     *
     * @return A log message with the proper keyspace, table and index name prepended to it.
     */
    public String logMessage(String message)
    {
        // Index names are unique only within a keyspace.
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        return String.format(&quot;[%s.%s.%s] %s&quot;, keyspace, table, indexMetadata == null ? &quot;?&quot; : indexMetadata.name, message);</span>
    }

    /**
     * @return the indexes that are built on the given SSTables on the left and corrupted indexes'
     * corresponding contexts on the right
     */
    public Pair&lt;Collection&lt;SSTableIndex&gt;, Collection&lt;SSTableContext&gt;&gt; getBuiltIndexes(Collection&lt;SSTableContext&gt; sstableContexts, IndexValidation validation)
    {
<span class="fc" id="L405">        Set&lt;SSTableIndex&gt; valid = new HashSet&lt;&gt;(sstableContexts.size());</span>
<span class="fc" id="L406">        Set&lt;SSTableContext&gt; invalid = new HashSet&lt;&gt;();</span>

<span class="fc bfc" id="L408" title="All 2 branches covered.">        for (SSTableContext sstableContext : sstableContexts)</span>
        {
<span class="pc bpc" id="L410" title="1 of 2 branches missed.">            if (sstableContext.sstable.isMarkedCompacted())</span>
<span class="nc" id="L411">                continue;</span>

<span class="pc bpc" id="L413" title="1 of 2 branches missed.">            if (!sstableContext.indexDescriptor.isPerColumnIndexBuildComplete(this))</span>
            {
<span class="nc" id="L415">                logger.debug(logMessage(&quot;An on-disk index build for SSTable {} has not completed.&quot;), sstableContext.descriptor());</span>
<span class="nc" id="L416">                continue;</span>
            }

<span class="pc bpc" id="L419" title="1 of 2 branches missed.">            if (sstableContext.indexDescriptor.isIndexEmpty(this))</span>
            {
<span class="nc" id="L421">                logger.debug(logMessage(&quot;No on-disk index was built for SSTable {} because the SSTable &quot; +</span>
<span class="nc" id="L422">                                        &quot;had no indexable rows for the index.&quot;), sstableContext.descriptor());</span>
<span class="nc" id="L423">                continue;</span>
            }

            try
            {
<span class="fc bfc" id="L428" title="All 2 branches covered.">                if (validation != IndexValidation.NONE)</span>
                {
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">                    if (!sstableContext.indexDescriptor.validatePerIndexComponents(this, validation))</span>
                    {
<span class="nc" id="L432">                        invalid.add(sstableContext);</span>
<span class="nc" id="L433">                        continue;</span>
                    }
                }

<span class="fc" id="L437">                SSTableIndex index = sstableContext.newSSTableIndex(this);</span>
<span class="fc" id="L438">                logger.debug(logMessage(&quot;Successfully created index for SSTable {}.&quot;), sstableContext.descriptor());</span>

                // Try to add new index to the set, if set already has such index, we'll simply release and move on.
                // This covers situation when SSTable collection has the same SSTable multiple
                // times because we don't know what kind of collection it actually is.
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">                if (!valid.add(index))</span>
                {
<span class="nc" id="L445">                    index.release();</span>
                }
            }
<span class="nc" id="L448">            catch (Throwable e)</span>
            {
<span class="nc" id="L450">                logger.warn(logMessage(&quot;Failed to update per-column components for SSTable {}&quot;), sstableContext.descriptor(), e);</span>
<span class="nc" id="L451">                invalid.add(sstableContext);</span>
<span class="fc" id="L452">            }</span>
<span class="fc" id="L453">        }</span>

<span class="fc" id="L455">        return Pair.create(valid, invalid);</span>
    }

    /**
     * @return the number of indexed rows in this index (aka. a pair of term and rowId)
     */
    public long getCellCount()
    {
<span class="nc" id="L463">        return getView().getIndexes()</span>
<span class="nc" id="L464">                        .stream()</span>
<span class="nc" id="L465">                        .mapToLong(SSTableIndex::getRowCount)</span>
<span class="nc" id="L466">                        .sum();</span>
    }

    /**
     * @return the total size (in bytes) of per-column index components
     */
    public long diskUsage()
    {
<span class="nc" id="L474">        return getView().getIndexes()</span>
<span class="nc" id="L475">                        .stream()</span>
<span class="nc" id="L476">                        .mapToLong(SSTableIndex::sizeOfPerColumnComponents)</span>
<span class="nc" id="L477">                        .sum();</span>
    }

    /**
     * @return the total memory usage (in bytes) of per-column index on-disk data structure
     */
    public long indexFileCacheSize()
    {
<span class="nc" id="L485">        return getView().getIndexes()</span>
<span class="nc" id="L486">                        .stream()</span>
<span class="nc" id="L487">                        .mapToLong(SSTableIndex::indexFileCacheSize)</span>
<span class="nc" id="L488">                        .sum();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>