<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExceptionHandlers.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.transport</a> &gt; <span class="el_source">ExceptionHandlers.java</span></div><h1>ExceptionHandlers.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.transport;

import java.io.IOException;
import java.net.SocketAddress;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import com.google.common.base.Predicate;
import com.google.common.collect.ImmutableSet;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.channel.ChannelPromise;
import io.netty.channel.unix.Errors;
import org.apache.cassandra.exceptions.OverloadedException;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.metrics.ClientMetrics;
import org.apache.cassandra.net.FrameEncoder;
import org.apache.cassandra.transport.messages.ErrorMessage;
import org.apache.cassandra.utils.JVMStabilityInspector;
import org.apache.cassandra.utils.NoSpamLogger;
import org.apache.cassandra.utils.Throwables;

<span class="nc" id="L46">public class ExceptionHandlers</span>
{
<span class="fc" id="L48">    private static final Logger logger = LoggerFactory.getLogger(ExceptionHandlers.class);</span>

    public static ChannelInboundHandlerAdapter postV5Handler(FrameEncoder.PayloadAllocator allocator,
                                                             ProtocolVersion version)
    {
<span class="fc" id="L53">        return new PostV5ExceptionHandler(allocator, version);</span>
    }

    private static final class PostV5ExceptionHandler extends ChannelInboundHandlerAdapter
    {
        private final FrameEncoder.PayloadAllocator allocator;
        private final ProtocolVersion version;

        public PostV5ExceptionHandler(FrameEncoder.PayloadAllocator allocator, ProtocolVersion version)
<span class="fc" id="L62">        {</span>
<span class="fc" id="L63">            this.allocator = allocator;</span>
<span class="fc" id="L64">            this.version = version;</span>
<span class="fc" id="L65">        }</span>

        @Override
        public void exceptionCaught(final ChannelHandlerContext ctx, Throwable cause)
        {
            // Provide error message to client in case channel is still open
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">            if (ctx.channel().isOpen())</span>
            {
<span class="fc" id="L73">                Predicate&lt;Throwable&gt; handler = getUnexpectedExceptionHandler(ctx.channel(), false);</span>
<span class="fc" id="L74">                ErrorMessage errorMessage = ErrorMessage.fromException(cause, handler);</span>
<span class="fc" id="L75">                Envelope response = errorMessage.encode(version);</span>
<span class="fc" id="L76">                FrameEncoder.Payload payload = allocator.allocate(true, CQLMessageHandler.envelopeSize(response.header));</span>
                try
                {
<span class="fc" id="L79">                    response.encodeInto(payload.buffer);</span>
<span class="fc" id="L80">                    response.release();</span>
<span class="fc" id="L81">                    payload.finish();</span>
<span class="fc" id="L82">                    ChannelPromise promise = ctx.newPromise();</span>
                    // On protocol exception, close the channel as soon as the message has been sent
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">                    if (isFatal(cause))</span>
<span class="nc" id="L85">                        promise.addListener(future -&gt; ctx.close());</span>
<span class="fc" id="L86">                    ctx.writeAndFlush(payload, promise);</span>
                }
                finally
                {
<span class="fc" id="L90">                    payload.release();</span>
<span class="fc" id="L91">                    JVMStabilityInspector.inspectThrowable(cause);</span>
                }
            }
            
<span class="fc bfc" id="L95" title="All 2 branches covered.">            if (DatabaseDescriptor.getClientErrorReportingExclusions().contains(ctx.channel().remoteAddress()))</span>
            {
                // Sometimes it is desirable to ignore exceptions from specific IPs; such as when security scans are
                // running.  To avoid polluting logs and metrics, metrics are not updated when the IP is in the exclude
                // list.
<span class="fc" id="L100">                logger.debug(&quot;Excluding client exception for {}; address contained in client_error_reporting_exclusions&quot;, ctx.channel().remoteAddress(), cause);</span>
<span class="fc" id="L101">                return;</span>
            }
<span class="fc" id="L103">            logClientNetworkingExceptions(cause);</span>
<span class="fc" id="L104">        }</span>

        private static boolean isFatal(Throwable cause)
        {
<span class="fc bfc" id="L108" title="All 2 branches covered.">            return Throwables.anyCauseMatches(cause, t -&gt; t instanceof ProtocolException</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">                                                          &amp;&amp; ((ProtocolException)t).isFatal());</span>
        }
    }

    static void logClientNetworkingExceptions(Throwable cause)
    {
<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (Throwables.anyCauseMatches(cause, t -&gt; t instanceof ProtocolException))</span>
        {
            // if any ProtocolExceptions is not silent, then handle
<span class="pc bpc" id="L118" title="2 of 6 branches missed.">            if (Throwables.anyCauseMatches(cause, t -&gt; t instanceof ProtocolException &amp;&amp; !((ProtocolException) t).isSilent()))</span>
            {
<span class="fc" id="L120">                ClientMetrics.instance.markProtocolException();</span>
                // since protocol exceptions are expected to be client issues, not logging stack trace
                // to avoid spamming the logs once a bad client shows up
<span class="fc" id="L123">                NoSpamLogger.log(logger, NoSpamLogger.Level.WARN, 1, TimeUnit.MINUTES, &quot;Protocol exception with client networking: &quot; + cause.getMessage());</span>
            }
        }
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">        else if (Throwables.anyCauseMatches(cause, t -&gt; t instanceof OverloadedException))</span>
        {
            // Once the threshold for overload is breached, it will very likely spam the logs...
<span class="nc" id="L129">            NoSpamLogger.log(logger, NoSpamLogger.Level.INFO, 1, TimeUnit.MINUTES, cause.getMessage());</span>
        }
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">        else if (Throwables.anyCauseMatches(cause, t -&gt; t instanceof Errors.NativeIoException))</span>
        {
<span class="nc" id="L133">            ClientMetrics.instance.markUnknownException();</span>
<span class="nc" id="L134">            logger.trace(&quot;Native exception in client networking&quot;, cause);</span>
        }
        else
        {
<span class="fc" id="L138">            ClientMetrics.instance.markUnknownException();</span>
<span class="fc" id="L139">            logger.warn(&quot;Unknown exception in client networking&quot;, cause);</span>
        }
<span class="fc" id="L141">    }</span>

    static Predicate&lt;Throwable&gt; getUnexpectedExceptionHandler(Channel channel, boolean alwaysLogAtError)
    {
<span class="fc" id="L145">        SocketAddress address = channel.remoteAddress();</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">        if (DatabaseDescriptor.getClientErrorReportingExclusions().contains(address))</span>
        {
<span class="fc" id="L148">            return cause -&gt; {</span>
<span class="fc" id="L149">                logger.debug(&quot;Excluding client exception for {}; address contained in client_error_reporting_exclusions&quot;, address, cause);</span>
<span class="fc" id="L150">                return true;</span>
            };
        }
<span class="fc" id="L153">        return new UnexpectedChannelExceptionHandler(channel, alwaysLogAtError);</span>
    }

    /**
     * Include the channel info in the logged information for unexpected errors, and (if {@link #alwaysLogAtError} is
     * false then choose the log level based on the type of exception (some are clearly client issues and shouldn't be
     * logged at server ERROR level)
     */
    static final class UnexpectedChannelExceptionHandler implements Predicate&lt;Throwable&gt;
    {

        /**
         * When we encounter an unexpected IOException we look for these {@link Throwable#getMessage() messages}
         * (because we have no better way to distinguish) and log them at DEBUG rather than INFO, since they
         * are generally caused by unclean client disconnects rather than an actual problem.
         */
<span class="fc" id="L169">        private static final Set&lt;String&gt; ioExceptionsAtDebugLevel = ImmutableSet.&lt;String&gt;builder().</span>
<span class="fc" id="L170">            add(&quot;Connection reset by peer&quot;).</span>
<span class="fc" id="L171">            add(&quot;Broken pipe&quot;).</span>
<span class="fc" id="L172">            add(&quot;Connection timed out&quot;).</span>
<span class="fc" id="L173">            build();</span>

        private final Channel channel;
        private final boolean alwaysLogAtError;

        UnexpectedChannelExceptionHandler(Channel channel, boolean alwaysLogAtError)
<span class="fc" id="L179">        {</span>
<span class="fc" id="L180">            this.channel = channel;</span>
<span class="fc" id="L181">            this.alwaysLogAtError = alwaysLogAtError;</span>
<span class="fc" id="L182">        }</span>

        @Override
        public boolean apply(Throwable exception)
        {
            String message;
            try
            {
<span class="nc" id="L190">                message = &quot;Unexpected exception during request; channel = &quot; + channel;</span>
            }
<span class="nc" id="L192">            catch (Exception ignore)</span>
            {
                // We don't want to make things worse if String.valueOf() throws an exception
<span class="nc" id="L195">                message = &quot;Unexpected exception during request; channel = &lt;unprintable&gt;&quot;;</span>
<span class="nc" id="L196">            }</span>

            // netty wraps SSL errors in a CodecExcpetion
<span class="nc bnc" id="L199" title="All 6 branches missed.">            if (!alwaysLogAtError &amp;&amp; (exception instanceof IOException || (exception.getCause() instanceof IOException)))</span>
            {
<span class="nc" id="L201">                String errorMessage = exception.getMessage();</span>
<span class="nc" id="L202">                boolean logAtTrace = false;</span>

<span class="nc bnc" id="L204" title="All 2 branches missed.">                for (String ioException : ioExceptionsAtDebugLevel)</span>
                {
                    // exceptions thrown from the netty epoll transport add the name of the function that failed
                    // to the exception string (which is simply wrapping a JDK exception), so we can't do a simple/naive comparison
<span class="nc bnc" id="L208" title="All 2 branches missed.">                    if (errorMessage.contains(ioException))</span>
                    {
<span class="nc" id="L210">                        logAtTrace = true;</span>
<span class="nc" id="L211">                        break;</span>
                    }
<span class="nc" id="L213">                }</span>

<span class="nc bnc" id="L215" title="All 2 branches missed.">                if (logAtTrace)</span>
                {
                    // Likely unclean client disconnects
<span class="nc" id="L218">                    logger.trace(message, exception);</span>
                }
                else
                {
                    // Generally unhandled IO exceptions are network issues, not actual ERRORS
<span class="nc" id="L223">                    logger.info(message, exception);</span>
                }
<span class="nc" id="L225">            }</span>
            else
            {
                // Anything else is probably a bug in server of client binary protocol handling
<span class="nc" id="L229">                logger.error(message, exception);</span>
            }

            // We handled the exception.
<span class="nc" id="L233">            return true;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>