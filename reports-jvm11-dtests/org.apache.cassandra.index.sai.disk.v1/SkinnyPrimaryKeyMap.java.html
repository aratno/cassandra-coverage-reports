<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SkinnyPrimaryKeyMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.index.sai.disk.v1</a> &gt; <span class="el_source">SkinnyPrimaryKeyMap.java</span></div><h1>SkinnyPrimaryKeyMap.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.index.sai.disk.v1;

import java.io.IOException;
import java.util.Arrays;
import javax.annotation.concurrent.NotThreadSafe;
import javax.annotation.concurrent.ThreadSafe;

import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.dht.IPartitioner;
import org.apache.cassandra.index.sai.disk.PrimaryKeyMap;
import org.apache.cassandra.index.sai.disk.format.IndexComponent;
import org.apache.cassandra.index.sai.disk.format.IndexDescriptor;
import org.apache.cassandra.index.sai.disk.v1.bitpack.BlockPackedReader;
import org.apache.cassandra.index.sai.disk.v1.bitpack.MonotonicBlockPackedReader;
import org.apache.cassandra.index.sai.disk.v1.bitpack.NumericValuesMeta;
import org.apache.cassandra.index.sai.disk.v1.keystore.KeyLookupMeta;
import org.apache.cassandra.index.sai.disk.v1.keystore.KeyLookup;
import org.apache.cassandra.index.sai.utils.PrimaryKey;
import org.apache.cassandra.io.sstable.format.SSTableReader;
import org.apache.cassandra.io.util.FileHandle;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.utils.Throwables;

/**
 * A {@link PrimaryKeyMap} for skinny tables (those with no clustering columns).
 * &lt;p&gt;
 * This uses the following on-disk structures:
 * &lt;ul&gt;
 *     &lt;li&gt;A block-packed structure for rowId to token lookups using {@link BlockPackedReader}.
 *     Uses the {@link IndexComponent#TOKEN_VALUES} component&lt;/li&gt;
 *     &lt;li&gt;A monotonic block packed structure for rowId to partitionId lookups using {@link MonotonicBlockPackedReader}.
 *     Uses the {@link IndexComponent#PARTITION_SIZES} component&lt;/li&gt;
 *     &lt;li&gt;A key store for rowId to {@link PrimaryKey} and {@link PrimaryKey} to rowId lookups using
 *     {@link KeyLookup}. Uses the {@link IndexComponent#PARTITION_KEY_BLOCKS} and
 *     {@link IndexComponent#PARTITION_KEY_BLOCK_OFFSETS} components&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * While the {@link Factory} is threadsafe, individual instances of the {@link SkinnyPrimaryKeyMap}
 * are not.
 */
@NotThreadSafe
public class SkinnyPrimaryKeyMap implements PrimaryKeyMap
{
    @ThreadSafe
    public static class Factory implements PrimaryKeyMap.Factory
    {
        protected final MetadataSource metadataSource;
        protected final LongArray.Factory tokenReaderFactory;
        protected final LongArray.Factory partitionReaderFactory;
        protected final KeyLookup partitionKeyReader;
        protected final IPartitioner partitioner;
        protected final PrimaryKey.Factory primaryKeyFactory;

        private final FileHandle tokensFile;
        private final FileHandle partitionsFile;
        private final FileHandle partitionKeyBlockOffsetsFile;
        private final FileHandle partitionKeyBlocksFile;

        public Factory(IndexDescriptor indexDescriptor, SSTableReader sstable)
<span class="fc" id="L78">        {</span>
<span class="fc" id="L79">            this.tokensFile = indexDescriptor.createPerSSTableFileHandle(IndexComponent.TOKEN_VALUES, this::close);</span>
<span class="fc" id="L80">            this.partitionsFile = indexDescriptor.createPerSSTableFileHandle(IndexComponent.PARTITION_SIZES, this::close);</span>
<span class="fc" id="L81">            this.partitionKeyBlockOffsetsFile = indexDescriptor.createPerSSTableFileHandle(IndexComponent.PARTITION_KEY_BLOCK_OFFSETS, this::close);</span>
<span class="fc" id="L82">            this.partitionKeyBlocksFile = indexDescriptor.createPerSSTableFileHandle(IndexComponent.PARTITION_KEY_BLOCKS, this::close);</span>
            try
            {
<span class="fc" id="L85">                this.metadataSource = MetadataSource.loadGroupMetadata(indexDescriptor);</span>
<span class="fc" id="L86">                NumericValuesMeta tokensMeta = new NumericValuesMeta(metadataSource.get(indexDescriptor.componentName(IndexComponent.TOKEN_VALUES)));</span>
<span class="fc" id="L87">                this.tokenReaderFactory = new BlockPackedReader(tokensFile, tokensMeta);</span>
<span class="fc" id="L88">                NumericValuesMeta partitionsMeta = new NumericValuesMeta(metadataSource.get(indexDescriptor.componentName(IndexComponent.PARTITION_SIZES)));</span>
<span class="fc" id="L89">                this.partitionReaderFactory = new MonotonicBlockPackedReader(partitionsFile, partitionsMeta);</span>
<span class="fc" id="L90">                NumericValuesMeta partitionKeyBlockOffsetsMeta = new NumericValuesMeta(metadataSource.get(indexDescriptor.componentName(IndexComponent.PARTITION_KEY_BLOCK_OFFSETS)));</span>
<span class="fc" id="L91">                KeyLookupMeta partitionKeysMeta = new KeyLookupMeta(metadataSource.get(indexDescriptor.componentName(IndexComponent.PARTITION_KEY_BLOCKS)));</span>
<span class="fc" id="L92">                this.partitionKeyReader = new KeyLookup(partitionKeyBlocksFile, partitionKeyBlockOffsetsFile, partitionKeysMeta, partitionKeyBlockOffsetsMeta);</span>
<span class="fc" id="L93">                this.partitioner = sstable.metadata().partitioner;</span>
<span class="fc" id="L94">                this.primaryKeyFactory = indexDescriptor.primaryKeyFactory;</span>
            }
<span class="nc" id="L96">            catch (Throwable t)</span>
            {
<span class="nc" id="L98">                throw Throwables.unchecked(t);</span>
<span class="fc" id="L99">            }</span>
<span class="fc" id="L100">        }</span>

        @Override
        @SuppressWarnings({&quot;resource&quot;, &quot;RedundantSuppression&quot;})
        public PrimaryKeyMap newPerSSTablePrimaryKeyMap() throws IOException
        {
<span class="fc" id="L106">            LongArray rowIdToToken = new LongArray.DeferredLongArray(tokenReaderFactory::open);</span>
<span class="fc" id="L107">            LongArray rowIdToPartitionId = new LongArray.DeferredLongArray(partitionReaderFactory::open);</span>
<span class="fc" id="L108">            return new SkinnyPrimaryKeyMap(rowIdToToken,</span>
                                           rowIdToPartitionId,
<span class="fc" id="L110">                                           partitionKeyReader.openCursor(),</span>
                                           partitioner,
                                           primaryKeyFactory);
        }

        @Override
        public void close()
        {
<span class="nc" id="L118">            FileUtils.closeQuietly(Arrays.asList(tokensFile, partitionsFile, partitionKeyBlocksFile, partitionKeyBlockOffsetsFile));</span>
<span class="nc" id="L119">        }</span>
    }

    protected final LongArray tokenArray;
    protected final LongArray partitionArray;
    protected final KeyLookup.Cursor partitionKeyCursor;
    protected final IPartitioner partitioner;
    protected final PrimaryKey.Factory primaryKeyFactory;

    protected SkinnyPrimaryKeyMap(LongArray tokenArray,
                                  LongArray partitionArray,
                                  KeyLookup.Cursor partitionKeyCursor,
                                  IPartitioner partitioner,
                                  PrimaryKey.Factory primaryKeyFactory)
<span class="fc" id="L133">    {</span>
<span class="fc" id="L134">        this.tokenArray = tokenArray;</span>
<span class="fc" id="L135">        this.partitionArray = partitionArray;</span>
<span class="fc" id="L136">        this.partitionKeyCursor = partitionKeyCursor;</span>
<span class="fc" id="L137">        this.partitioner = partitioner;</span>
<span class="fc" id="L138">        this.primaryKeyFactory = primaryKeyFactory;</span>
<span class="fc" id="L139">    }</span>

    @Override
    public PrimaryKey primaryKeyFromRowId(long sstableRowId)
    {
<span class="fc" id="L144">        return primaryKeyFactory.create(readPartitionKey(sstableRowId));</span>
    }

    @Override
    public long rowIdFromPrimaryKey(PrimaryKey primaryKey)
    {
<span class="fc" id="L150">        long rowId = tokenArray.indexOf(primaryKey.token().getLongValue());</span>
        // If the key is token only, the token is out of range, we are at the end of our keys, or we have skipped a token
        // we can return straight away.
<span class="pc bpc" id="L153" title="3 of 4 branches missed.">        if (primaryKey.kind() == PrimaryKey.Kind.TOKEN ||</span>
            rowId &lt; 0 ||
<span class="nc bnc" id="L155" title="All 4 branches missed.">            rowId + 1 == tokenArray.length() || tokenArray.get(rowId) != primaryKey.token().getLongValue())</span>
<span class="fc" id="L156">            return rowId;</span>
        // Otherwise we need to check for token collision.
<span class="nc" id="L158">        return tokenCollisionDetection(primaryKey, rowId);</span>
    }

    @Override
    public void close()
    {
<span class="fc" id="L164">        FileUtils.closeQuietly(Arrays.asList(partitionKeyCursor, tokenArray, partitionArray));</span>
<span class="fc" id="L165">    }</span>

    // Look for token collision by if the ajacent token in the token array matches the
    // current token. If we find a collision we need to compare the partition key instead.
    protected long tokenCollisionDetection(PrimaryKey primaryKey, long rowId)
    {
        // Look for collisions while we haven't reached the end of the tokens and the tokens don't collide
<span class="nc bnc" id="L172" title="All 4 branches missed.">        while (rowId + 1 &lt; tokenArray.length() &amp;&amp; primaryKey.token().getLongValue() == tokenArray.get(rowId + 1))</span>
        {
            // If we had a collision then see if the partition key for this row is &gt;= to the lookup partition key
<span class="nc bnc" id="L175" title="All 2 branches missed.">            if (readPartitionKey(rowId).compareTo(primaryKey.partitionKey()) &gt;= 0)</span>
<span class="nc" id="L176">                return rowId;</span>

<span class="nc" id="L178">            rowId++;</span>
        }
        // Note: We would normally expect to get here without going into the while loop
<span class="nc" id="L181">        return rowId;</span>
    }

    protected DecoratedKey readPartitionKey(long sstableRowId)
    {
<span class="fc" id="L186">        return primaryKeyFactory.partitionKeyFromComparableBytes(partitionKeyCursor.seekToPointId(partitionArray.get(sstableRowId)));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>