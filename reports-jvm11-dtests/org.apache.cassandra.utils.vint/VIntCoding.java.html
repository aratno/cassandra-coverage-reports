<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VIntCoding.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.utils.vint</a> &gt; <span class="el_source">VIntCoding.java</span></div><h1>VIntCoding.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
package org.apache.cassandra.utils.vint;

import java.io.DataInput;
import java.io.IOException;
import java.nio.ByteBuffer;

import io.netty.util.concurrent.FastThreadLocal;
import net.nicoulaj.compilecommand.annotations.Inline;
import org.apache.cassandra.db.marshal.ValueAccessor;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;

/**
 * Borrows idea from
 * https://developers.google.com/protocol-buffers/docs/encoding#varints
 */
<span class="nc" id="L63">public class VIntCoding</span>
{

<span class="fc" id="L66">    protected static final FastThreadLocal&lt;byte[]&gt; encodingBuffer = new FastThreadLocal&lt;byte[]&gt;()</span>
<span class="fc" id="L67">    {</span>
        @Override
        public byte[] initialValue()
        {
<span class="nc" id="L71">            return new byte[9];</span>
        }
    };

    public static final int MAX_SIZE = 10;

    /**
     * Throw when attempting to decode a vint and the output type
     * doesn't have enough space to fit the value that was decoded
     */
    public static class VIntOutOfRangeException extends RuntimeException
    {
        public final long value;

        private VIntOutOfRangeException(long value)
        {
<span class="nc" id="L87">            super(value + &quot; is out of range for a 32-bit integer&quot;);</span>
<span class="nc" id="L88">            this.value = value;</span>
<span class="nc" id="L89">        }</span>
    }

    public static long readUnsignedVInt(DataInput input) throws IOException
    {
<span class="fc" id="L94">        int firstByte = input.readByte();</span>

        //Bail out early if this is one byte, necessary or it fails later
<span class="fc bfc" id="L97" title="All 2 branches covered.">        if (firstByte &gt;= 0)</span>
<span class="fc" id="L98">            return firstByte;</span>

<span class="fc" id="L100">        int size = numberOfExtraBytesToRead(firstByte);</span>
<span class="fc" id="L101">        long retval = firstByte &amp; firstByteValueMask(size);</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">        for (int ii = 0; ii &lt; size; ii++)</span>
        {
<span class="fc" id="L104">            byte b = input.readByte();</span>
<span class="fc" id="L105">            retval &lt;&lt;= 8;</span>
<span class="fc" id="L106">            retval |= b &amp; 0xff;</span>
        }

<span class="fc" id="L109">        return retval;</span>
    }

    public static void skipUnsignedVInt(DataInputPlus input) throws IOException
    {
<span class="fc" id="L114">        int firstByte = input.readByte();</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (firstByte &lt; 0)</span>
<span class="fc" id="L116">            input.skipBytesFully(numberOfExtraBytesToRead(firstByte));</span>
<span class="fc" id="L117">    }</span>

    /**
     * Read up to a 32-bit integer back, using the unsigned (no zigzag) encoding.
     *
     * Note this method is the same as {@link #readUnsignedVInt(DataInput)},
     * except that we do *not* block if there are not enough bytes in the buffer
     * to reconstruct the value.
     *
     * @throws VIntOutOfRangeException If the vint doesn't fit into a 32-bit integer
     */
    public static int getUnsignedVInt32(ByteBuffer input, int readerIndex)
    {
<span class="fc" id="L130">        return checkedCast(getUnsignedVInt(input, readerIndex));</span>
    }

    public static int getVInt32(ByteBuffer input, int readerIndex)
    {
<span class="nc" id="L135">        return checkedCast(decodeZigZag64(getUnsignedVInt(input, readerIndex)));</span>
    }

    public static long getVInt(ByteBuffer input, int readerIndex)
    {
<span class="nc" id="L140">        return decodeZigZag64(getUnsignedVInt(input, readerIndex));</span>
    }

    public static long getUnsignedVInt(ByteBuffer input, int readerIndex)
    {
<span class="fc" id="L145">        return getUnsignedVInt(input, readerIndex, input.limit());</span>
    }
    public static long getUnsignedVInt(ByteBuffer input, int readerIndex, int readerLimit)
    {
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        if (readerIndex &lt; 0)</span>
<span class="nc" id="L150">            throw new IllegalArgumentException(&quot;Reader index should be non-negative, but was &quot; + readerIndex);</span>

<span class="pc bpc" id="L152" title="1 of 2 branches missed.">        if (readerIndex &gt;= readerLimit)</span>
<span class="nc" id="L153">            return -1;</span>

<span class="fc" id="L155">        int firstByte = input.get(readerIndex++);</span>

        //Bail out early if this is one byte, necessary or it fails later
<span class="fc bfc" id="L158" title="All 2 branches covered.">        if (firstByte &gt;= 0)</span>
<span class="fc" id="L159">            return firstByte;</span>

<span class="fc" id="L161">        int size = numberOfExtraBytesToRead(firstByte);</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">        if (readerIndex + size &gt; readerLimit)</span>
<span class="nc" id="L163">            return -1;</span>

<span class="fc" id="L165">        long retval = firstByte &amp; firstByteValueMask(size);</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">        for (int ii = 0; ii &lt; size; ii++)</span>
        {
<span class="fc" id="L168">            byte b = input.get(readerIndex++);</span>
<span class="fc" id="L169">            retval &lt;&lt;= 8;</span>
<span class="fc" id="L170">            retval |= b &amp; 0xff;</span>
        }

<span class="fc" id="L173">        return retval;</span>
    }

    public static &lt;V&gt; int getUnsignedVInt32(V input, ValueAccessor&lt;V&gt; accessor, int readerIndex)
    {
<span class="nc" id="L178">        return checkedCast(getUnsignedVInt(input, accessor, readerIndex));</span>
    }

    public static &lt;V&gt; int getVInt32(V input, ValueAccessor&lt;V&gt; accessor, int readerIndex)
    {
<span class="nc" id="L183">        return checkedCast(decodeZigZag64(getUnsignedVInt(input, accessor, readerIndex)));</span>
    }

    public static &lt;V&gt; long getVInt(V input, ValueAccessor&lt;V&gt; accessor, int readerIndex)
    {
<span class="nc" id="L188">        return decodeZigZag64(getUnsignedVInt(input, accessor, readerIndex));</span>
    }

    public static &lt;V&gt; long getUnsignedVInt(V input, ValueAccessor&lt;V&gt; accessor, int readerIndex)
    {
<span class="nc" id="L193">        return getUnsignedVInt(input, accessor, readerIndex, accessor.size(input));</span>
    }

    public static &lt;V&gt; long getUnsignedVInt(V input, ValueAccessor&lt;V&gt; accessor, int readerIndex, int readerLimit)
    {
<span class="nc bnc" id="L198" title="All 2 branches missed.">        if (readerIndex &lt; 0)</span>
<span class="nc" id="L199">            throw new IllegalArgumentException(&quot;Reader index should be non-negative, but was &quot; + readerIndex);</span>

<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (readerIndex &gt;= readerLimit)</span>
<span class="nc" id="L202">            return -1;</span>

<span class="nc" id="L204">        int firstByte = accessor.getByte(input, readerIndex++);</span>

        //Bail out early if this is one byte, necessary or it fails later
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (firstByte &gt;= 0)</span>
<span class="nc" id="L208">            return firstByte;</span>

<span class="nc" id="L210">        int size = numberOfExtraBytesToRead(firstByte);</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">        if (readerIndex + size &gt; readerLimit)</span>
<span class="nc" id="L212">            return -1;</span>

<span class="nc" id="L214">        long retval = firstByte &amp; firstByteValueMask(size);</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">        for (int ii = 0; ii &lt; size; ii++)</span>
        {
<span class="nc" id="L217">            byte b = accessor.getByte(input, readerIndex++);</span>
<span class="nc" id="L218">            retval &lt;&lt;= 8;</span>
<span class="nc" id="L219">            retval |= b &amp; 0xff;</span>
        }

<span class="nc" id="L222">        return retval;</span>
    }

    /**
     * Computes size of an unsigned vint that starts at readerIndex of the provided ByteBuf.
     *
     * @return -1 if there are not enough bytes in the input to calculate the size; else, the vint unsigned value size in bytes.
     */
    public static int computeUnsignedVIntSize(ByteBuffer input, int readerIndex)
    {
<span class="nc" id="L232">        return computeUnsignedVIntSize(input, readerIndex, input.limit());</span>
    }
    public static int computeUnsignedVIntSize(ByteBuffer input, int readerIndex, int readerLimit)
    {
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">        if (readerIndex &gt;= readerLimit)</span>
<span class="nc" id="L237">            return -1;</span>

<span class="fc" id="L239">        int firstByte = input.get(readerIndex);</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">        return 1 + ((firstByte &gt;= 0) ? 0 : numberOfExtraBytesToRead(firstByte));</span>
    }

    public static long readVInt(DataInput input) throws IOException
    {
<span class="nc" id="L245">        return decodeZigZag64(readUnsignedVInt(input));</span>
    }

    /**
     * Read up to a signed 32-bit integer back.
     *
     * Assumes the vint was written using {@link #writeVInt32(int, DataOutputPlus)} or similar
     * that zigzag encodes the integer.
     *
     * @throws VIntOutOfRangeException If the vint doesn't fit into a 32-bit integer
     */
    public static int readVInt32(DataInput input) throws IOException
    {
<span class="nc" id="L258">        return checkedCast(decodeZigZag64(readUnsignedVInt(input)));</span>
    }

    /**
     * Read up to a 32-bit integer.
     *
     * This method assumes the original integer was written using {@link #writeUnsignedVInt32(int, DataOutputPlus)}
     * or similar that doesn't zigzag encodes the vint.
     *
     * @throws VIntOutOfRangeException If the vint doesn't fit into a 32-bit integer
     */
    public static int readUnsignedVInt32(DataInput input) throws IOException
    {
<span class="fc" id="L271">        return checkedCast(readUnsignedVInt(input));</span>
    }

    // &amp; this with the first byte to give the value part for a given extraBytesToRead encoded in the byte
    public static int firstByteValueMask(int extraBytesToRead)
    {
        // by including the known 0bit in the mask, we can use this for encodeExtraBytesToRead
<span class="fc" id="L278">        return 0xff &gt;&gt; extraBytesToRead;</span>
    }

    public static int encodeExtraBytesToRead(int extraBytesToRead)
    {
        // because we have an extra bit in the value mask, we just need to invert it
<span class="fc" id="L284">        return ~firstByteValueMask(extraBytesToRead);</span>
    }

    public static int numberOfExtraBytesToRead(int firstByte)
    {
        // we count number of set upper bits; so if we simply invert all of the bits, we're golden
        // this is aided by the fact that we only work with negative numbers, so when upcast to an int all
        // of the new upper bits are also set, so by inverting we set all of them to zero
<span class="fc" id="L292">        return Integer.numberOfLeadingZeros(~firstByte) - 24;</span>
    }

    @Deprecated
    public static void writeUnsignedVInt(int value, DataOutputPlus output) throws IOException
    {
<span class="nc" id="L298">        throw new UnsupportedOperationException(&quot;Use writeUnsignedVInt32/readUnsignedVInt32&quot;);</span>
    }

    @Inline
    public static void writeUnsignedVInt(long value, DataOutputPlus output) throws IOException
    {
<span class="fc" id="L304">        int size = VIntCoding.computeUnsignedVIntSize(value);</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">        if (size == 1)</span>
        {
<span class="fc" id="L307">            output.writeByte((int) value);</span>
        }
<span class="fc bfc" id="L309" title="All 2 branches covered.">        else if (size &lt; 9)</span>
        {
<span class="fc" id="L311">            int shift = (8 - size) &lt;&lt; 3;</span>
<span class="fc" id="L312">            int extraBytes = size - 1;</span>
<span class="fc" id="L313">            long mask = (long)VIntCoding.encodeExtraBytesToRead(extraBytes) &lt;&lt; 56;</span>
<span class="fc" id="L314">            long register = (value &lt;&lt; shift) | mask;</span>
<span class="fc" id="L315">            output.writeMostSignificantBytes(register, size);</span>
<span class="fc" id="L316">        }</span>
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">        else if (size == 9)</span>
        {
<span class="fc" id="L319">            output.write((byte) 0xFF);</span>
<span class="fc" id="L320">            output.writeLong(value);</span>
        }
        else
        {
<span class="nc" id="L324">            throw new AssertionError();</span>
        }
<span class="fc" id="L326">    }</span>

    public static void writeUnsignedVInt32(int value, DataOutputPlus output) throws IOException
    {
<span class="fc" id="L330">        writeUnsignedVInt((long)value, output);</span>
<span class="fc" id="L331">    }</span>

    @Deprecated
    public static void writeUnsignedVInt(int value, ByteBuffer output) throws IOException
    {
<span class="nc" id="L336">        throw new UnsupportedOperationException(&quot;Use writeUnsignedVInt32/getUnsignedVInt32&quot;);</span>
    }

    @Inline
    public static void writeUnsignedVInt(long value, ByteBuffer output)
    {
<span class="nc" id="L342">        int size = VIntCoding.computeUnsignedVIntSize(value);</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (size == 1)</span>
        {
<span class="nc" id="L345">            output.put((byte) (value));</span>
        }
<span class="nc bnc" id="L347" title="All 2 branches missed.">        else if (size &lt; 9)</span>
        {
<span class="nc" id="L349">            int limit = output.limit();</span>
<span class="nc" id="L350">            int pos = output.position();</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">            if (limit - pos &gt;= 8)</span>
            {
<span class="nc" id="L353">                int shift = (8 - size) &lt;&lt; 3;</span>
<span class="nc" id="L354">                int extraBytes = size - 1;</span>
<span class="nc" id="L355">                long mask = (long)VIntCoding.encodeExtraBytesToRead(extraBytes) &lt;&lt; 56;</span>
<span class="nc" id="L356">                long register = (value &lt;&lt; shift) | mask;</span>
<span class="nc" id="L357">                output.putLong(pos, register);</span>
<span class="nc" id="L358">                output.position(pos + size);</span>
<span class="nc" id="L359">            }</span>
            else
            {
<span class="nc" id="L362">                output.put(VIntCoding.encodeUnsignedVInt(value, size), 0, size);</span>
            }
<span class="nc" id="L364">        }</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">        else if (size == 9)</span>
        {
<span class="nc" id="L367">            output.put((byte) 0xFF);</span>
<span class="nc" id="L368">            output.putLong(value);</span>
        }
        else
        {
<span class="nc" id="L372">            throw new AssertionError();</span>
        }
<span class="nc" id="L374">    }</span>

    @Inline
    public static &lt;V&gt; int writeVInt(long value, V output, int offset, ValueAccessor&lt;V&gt; accessor)
    {
<span class="nc" id="L379">        return writeUnsignedVInt(encodeZigZag64(value), output, offset, accessor);</span>
    }

    @Inline
    public static  &lt;V&gt; int writeVInt32(int value, V output, int offset, ValueAccessor&lt;V&gt; accessor)
    {
<span class="nc" id="L385">        return writeVInt(value, output, offset, accessor);</span>
    }

    @Inline
    public static &lt;V&gt; int writeUnsignedVInt32(int value, V output, int offset, ValueAccessor&lt;V&gt; accessor)
    {
<span class="nc" id="L391">        return writeUnsignedVInt(value, output, offset, accessor);</span>
    }

    @Inline
    public static &lt;V&gt; int writeUnsignedVInt(long value, V output, int offset, ValueAccessor&lt;V&gt; accessor)
    {
<span class="nc" id="L397">        int size = VIntCoding.computeUnsignedVIntSize(value);</span>
<span class="nc" id="L398">        int written = 0;</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">        if (size == 1)</span>
        {
<span class="nc" id="L401">            written += accessor.putByte(output, offset, (byte) (value));</span>
        }
<span class="nc bnc" id="L403" title="All 2 branches missed.">        else if (size &lt; 9)</span>
        {
<span class="nc bnc" id="L405" title="All 2 branches missed.">            if (accessor.remaining(output, offset) &gt;= 8)</span>
            {
<span class="nc" id="L407">                int shift = (8 - size) &lt;&lt; 3;</span>
<span class="nc" id="L408">                int extraBytes = size - 1;</span>
<span class="nc" id="L409">                long mask = (long)VIntCoding.encodeExtraBytesToRead(extraBytes) &lt;&lt; 56;</span>
<span class="nc" id="L410">                long register = (value &lt;&lt; shift) | mask;</span>
<span class="nc" id="L411">                accessor.putLong(output, offset, register);</span>
<span class="nc" id="L412">                written += size;</span>
<span class="nc" id="L413">            }</span>
            else
            {
<span class="nc" id="L416">                written += accessor.putBytes(output, offset, VIntCoding.encodeUnsignedVInt(value, size), 0, size);</span>
            }
        }
<span class="nc bnc" id="L419" title="All 2 branches missed.">        else if (size == 9)</span>
        {
<span class="nc" id="L421">            written += accessor.putByte(output, offset, (byte) 0xFF);</span>
<span class="nc" id="L422">            written += accessor.putLong(output, offset + written, value);</span>
        }
        else
        {
<span class="nc" id="L426">            throw new AssertionError();</span>
        }
<span class="nc" id="L428">        return written;</span>
    }

    @Inline
    public static void writeUnsignedVInt32(int value, ByteBuffer output)
    {
<span class="nc" id="L434">        writeUnsignedVInt((long)value, output);</span>
<span class="nc" id="L435">    }</span>

    @Deprecated
    public static void writeVInt(int value, DataOutputPlus output) throws IOException
    {
<span class="nc" id="L440">        throw new UnsupportedOperationException(&quot;Use writeVInt32/readVInt32&quot;);</span>
    }

    @Inline
    public static void writeVInt(long value, DataOutputPlus output) throws IOException
    {
<span class="fc" id="L446">        writeUnsignedVInt(encodeZigZag64(value), output);</span>
<span class="fc" id="L447">    }</span>

    @Inline
    public static void writeVInt32(int value, DataOutputPlus output) throws IOException
    {
<span class="nc" id="L452">        writeVInt((long)value, output);</span>
<span class="nc" id="L453">    }</span>

    @Deprecated
    public static void writeVInt(int value, ByteBuffer output)
    {
<span class="nc" id="L458">        throw new UnsupportedOperationException(&quot;Use writeVInt32/getVInt32&quot;);</span>
    }

    @Inline
    public static void writeVInt(long value, ByteBuffer output)
    {
<span class="nc" id="L464">        writeUnsignedVInt(encodeZigZag64(value), output);</span>
<span class="nc" id="L465">    }</span>

    @Inline
    public static void writeVInt32(int value, ByteBuffer output)
    {
<span class="nc" id="L470">        writeVInt((long)value, output);</span>
<span class="nc" id="L471">    }</span>

    /**
     * @return a TEMPORARY THREAD LOCAL BUFFER containing the encoded bytes of the value
     * This byte[] must be discarded by the caller immediately, and synchronously
     */
    @Inline
    private static byte[] encodeUnsignedVInt(long value, int size)
    {
<span class="nc" id="L480">        byte[] encodingSpace = encodingBuffer.get();</span>

<span class="nc" id="L482">        int extraBytes = size - 1;</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">        for (int i = extraBytes ; i &gt;= 0; --i)</span>
        {
<span class="nc" id="L485">            encodingSpace[i] = (byte) value;</span>
<span class="nc" id="L486">            value &gt;&gt;= 8;</span>
        }
<span class="nc" id="L488">        encodingSpace[0] |= VIntCoding.encodeExtraBytesToRead(extraBytes);</span>

<span class="nc" id="L490">        return encodingSpace;</span>
    }

    /**
     * Decode a ZigZag-encoded 64-bit value.  ZigZag encodes signed integers
     * into values that can be efficiently encoded with varint.  (Otherwise,
     * negative values must be sign-extended to 64 bits to be varint encoded,
     * thus always taking 10 bytes on the wire.)
     *
     * @param n An unsigned 64-bit integer, stored in a signed int because
     *          Java has no explicit unsigned support.
     * @return A signed 64-bit integer.
     */
    public static long decodeZigZag64(final long n)
    {
<span class="fc" id="L505">        return (n &gt;&gt;&gt; 1) ^ -(n &amp; 1);</span>
    }

    /**
     * Encode a ZigZag-encoded 64-bit value.  ZigZag encodes signed integers
     * into values that can be efficiently encoded with varint.  (Otherwise,
     * negative values must be sign-extended to 64 bits to be varint encoded,
     * thus always taking 10 bytes on the wire.)
     *
     * @param n A signed 64-bit integer.
     * @return An unsigned 64-bit integer, stored in a signed int because
     *         Java has no explicit unsigned support.
     */
    public static long encodeZigZag64(final long n)
    {
        // Note:  the right-shift must be arithmetic
<span class="fc" id="L521">        return (n &lt;&lt; 1) ^ (n &gt;&gt; 63);</span>
    }

    /** Compute the number of bytes that would be needed to encode a varint. */
    public static int computeVIntSize(final long param)
    {
<span class="fc" id="L527">        return computeUnsignedVIntSize(encodeZigZag64(param));</span>
    }

    /** Compute the number of bytes that would be needed to encode an unsigned varint. */
    public static int computeUnsignedVIntSize(final long value)
    {
<span class="fc" id="L533">        int magnitude = Long.numberOfLeadingZeros(value | 1); // | with 1 to ensure magntiude &lt;= 63, so (63 - 1) / 7 &lt;= 8</span>
        // the formula below is hand-picked to match the original 9 - ((magnitude - 1) / 7)
<span class="fc" id="L535">        return (639 - magnitude * 9) &gt;&gt; 6;</span>
    }

    public static int checkedCast(long value)
    {
<span class="fc" id="L540">        int result = (int)value;</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">        if ((long)result != value)</span>
<span class="nc" id="L542">            throw new VIntOutOfRangeException(value);</span>
<span class="fc" id="L543">        return result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>