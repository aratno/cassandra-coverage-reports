<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TypeUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.index.sai.utils</a> &gt; <span class="el_source">TypeUtil.java</span></div><h1>TypeUtil.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.index.sai.utils;

import java.math.BigInteger;
import java.net.InetAddress;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Iterator;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import com.googlecode.concurrenttrees.radix.ConcurrentRadixTree;
import org.apache.cassandra.cql3.statements.schema.IndexTarget;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.marshal.BooleanType;
import org.apache.cassandra.db.marshal.ByteBufferAccessor;
import org.apache.cassandra.db.marshal.CollectionType;
import org.apache.cassandra.db.marshal.CompositeType;
import org.apache.cassandra.db.marshal.DecimalType;
import org.apache.cassandra.db.marshal.InetAddressType;
import org.apache.cassandra.db.marshal.IntegerType;
import org.apache.cassandra.db.marshal.LongType;
import org.apache.cassandra.db.marshal.ReversedType;
import org.apache.cassandra.db.marshal.StringType;
import org.apache.cassandra.db.rows.Cell;
import org.apache.cassandra.db.rows.ComplexColumnData;
import org.apache.cassandra.index.sai.plan.Expression;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.serializers.MarshalException;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.FastByteOperations;
import org.apache.cassandra.utils.bytecomparable.ByteComparable;
import org.apache.cassandra.utils.bytecomparable.ByteSource;
import org.apache.cassandra.utils.bytecomparable.ByteSourceInverse;

public class TypeUtil
{
<span class="fc" id="L56">    private static final byte[] IPV4_PREFIX = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1 };</span>

    /**
     * DecimalType / BigDecimal values are indexed by truncating their asComparableBytes representation to this size,
     * padding on the right with zero-value-bytes until this size is reached (if necessary).  This causes
     * false-positives that must be filtered in a separate step after hitting the index and reading the associated
     * (full) values.
     */
    public static final int DECIMAL_APPROXIMATION_BYTES = 24;

    public static final int BIG_INTEGER_APPROXIMATION_BYTES = 20;

    public static final int INET_ADDRESS_SIZE = 16;

    public static final int DEFAULT_FIXED_LENGTH = 16;

    private TypeUtil() {}

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if given buffer would pass the {@link AbstractType#validate(ByteBuffer)}
     * check. False otherwise.
     */
    public static boolean isValid(ByteBuffer term, AbstractType&lt;?&gt; validator)
    {
        try
        {
<span class="fc" id="L82">            validator.validate(term);</span>
<span class="fc" id="L83">            return true;</span>
        }
<span class="nc" id="L85">        catch (MarshalException e)</span>
        {
<span class="nc" id="L87">            return false;</span>
        }
    }

    /**
     * Indicates if the type encoding supports rounding of the raw value.
     *
     * This is significant in range searches where we have to make all range
     * queries inclusive when searching the indexes in order to avoid excluding
     * rounded values. Excluded values are removed by post-filtering.
     */
    public static boolean supportsRounding(AbstractType&lt;?&gt; type)
    {
<span class="pc bpc" id="L100" title="2 of 4 branches missed.">        return isBigInteger(type) || isBigDecimal(type);</span>
    }

    /**
     * Returns the smaller of two {@code ByteBuffer} values, based on the result of {@link
     * #compare(ByteBuffer, ByteBuffer, AbstractType)} comparision.
     */
    public static ByteBuffer min(ByteBuffer a, ByteBuffer b, AbstractType&lt;?&gt; type)
    {
<span class="pc bpc" id="L109" title="1 of 6 branches missed.">        return a == null ? b : (b == null || compare(b, a, type) &gt; 0) ? a : b;</span>
    }

    /**
     * Returns the greater of two {@code ByteBuffer} values, based on the result of {@link
     * #compare(ByteBuffer, ByteBuffer, AbstractType)} comparision.
     */
    public static ByteBuffer max(ByteBuffer a, ByteBuffer b, AbstractType&lt;?&gt; type)
    {
<span class="pc bpc" id="L118" title="1 of 6 branches missed.">        return a == null ? b : (b == null || compare(b, a, type) &lt; 0) ? a : b;</span>
    }

    /**
     * Returns the lesser of two {@code ByteComparable} values, based on the result of {@link
     * ByteComparable#compare(ByteComparable, ByteComparable, ByteComparable.Version)} comparision.
     */
    public static ByteComparable min(ByteComparable a, ByteComparable b)
    {
<span class="nc bnc" id="L127" title="All 6 branches missed.">        return a == null ? b : (b == null || ByteComparable.compare(b, a, ByteComparable.Version.OSS50) &gt; 0) ? a : b;</span>
    }

    /**
     * Returns the greater of two {@code ByteComparable} values, based on the result of {@link
     * ByteComparable#compare(ByteComparable, ByteComparable, ByteComparable.Version)} comparision.
     */
    public static ByteComparable max(ByteComparable a, ByteComparable b)
    {
<span class="nc bnc" id="L136" title="All 6 branches missed.">        return a == null ? b : (b == null || ByteComparable.compare(b, a, ByteComparable.Version.OSS50) &lt; 0) ? a : b;</span>
    }

    /**
     * Returns the value length for the given {@link AbstractType}, selecting 16 for types
     * that officially use VARIABLE_LENGTH but are, in fact, of a fixed length.
     */
    public static int fixedSizeOf(AbstractType&lt;?&gt; type)
    {
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">        if (type.isValueLengthFixed())</span>
<span class="fc" id="L146">            return type.valueLengthIfFixed();</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">        else if (isInetAddress(type))</span>
<span class="nc" id="L148">            return INET_ADDRESS_SIZE;</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">        else if (isBigInteger(type))</span>
<span class="nc" id="L150">            return BIG_INTEGER_APPROXIMATION_BYTES;</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">        else if (isBigDecimal(type))</span>
<span class="nc" id="L152">            return DECIMAL_APPROXIMATION_BYTES;</span>
<span class="nc" id="L153">        return DEFAULT_FIXED_LENGTH;</span>
    }

    public static AbstractType&lt;?&gt; cellValueType(ColumnMetadata columnMetadata, IndexTarget.Type indexType)
    {
<span class="fc" id="L158">        AbstractType&lt;?&gt; type = columnMetadata.type;</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">        if (isNonFrozenCollection(type))</span>
        {
<span class="nc" id="L161">            CollectionType&lt;?&gt; collection = ((CollectionType&lt;?&gt;) type);</span>
<span class="nc bnc" id="L162" title="All 4 branches missed.">            switch (collection.kind)</span>
            {
                case LIST:
<span class="nc" id="L165">                    return collection.valueComparator();</span>
                case SET:
<span class="nc" id="L167">                    return collection.nameComparator();</span>
                case MAP:
<span class="nc bnc" id="L169" title="All 4 branches missed.">                    switch (indexType)</span>
                    {
                        case KEYS:
<span class="nc" id="L172">                            return collection.nameComparator();</span>
                        case VALUES:
<span class="nc" id="L174">                            return collection.valueComparator();</span>
                        case KEYS_AND_VALUES:
<span class="nc" id="L176">                            return CompositeType.getInstance(collection.nameComparator(), collection.valueComparator());</span>
                    }
            }
        }
<span class="fc" id="L180">        return type;</span>
    }

    /**
     * Allows overriding the default getString method for {@link CompositeType}. It is
     * a requirement of the {@link ConcurrentRadixTree} that the keys are strings but
     * the getString method of {@link CompositeType} does not return a string that compares
     * in the same order as the underlying {@link ByteBuffer}. To get round this we convert
     * the {@link CompositeType} bytes to a hex string.
     */
    public static String getString(ByteBuffer value, AbstractType&lt;?&gt; type)
    {
<span class="nc bnc" id="L192" title="All 2 branches missed.">        if (isComposite(type))</span>
<span class="nc" id="L193">            return ByteBufferUtil.bytesToHex(value);</span>
<span class="nc" id="L194">        return type.getString(value);</span>
    }

    /**
     * The inverse of the above method. Overrides the fromString method on {@link CompositeType}
     * in order to convert the hex string to bytes.
     */
    public static ByteBuffer fromString(String value, AbstractType&lt;?&gt; type)
    {
<span class="nc bnc" id="L203" title="All 2 branches missed.">        if (isComposite(type))</span>
<span class="nc" id="L204">            return ByteBufferUtil.hexToBytes(value);</span>
<span class="nc" id="L205">        return type.fromString(value);</span>
    }

    public static ByteSource asComparableBytes(ByteBuffer value, AbstractType&lt;?&gt; type, ByteComparable.Version version)
    {
<span class="pc bpc" id="L210" title="3 of 6 branches missed.">        if (type instanceof InetAddressType || type instanceof IntegerType || type instanceof DecimalType)</span>
<span class="nc" id="L211">            return ByteSource.optionalFixedLength(ByteBufferAccessor.instance, value);</span>
        // The LongType.asComparableBytes uses variableLengthInteger which doesn't play well with
        // the balanced tree because it is expecting fixed length data. So for SAI we use a optionalSignedFixedLengthNumber
        // to keep all comparable values the same length
<span class="fc bfc" id="L215" title="All 2 branches covered.">        else if (type instanceof LongType)</span>
<span class="fc" id="L216">            return ByteSource.optionalSignedFixedLengthNumber(ByteBufferAccessor.instance, value);</span>
<span class="fc" id="L217">        return type.asComparableBytes(value, version);</span>
    }

    /**
     * Fills a byte array with the comparable bytes for a type.
     * &lt;p&gt;
     * This method expects a {@code value} parameter generated by calling {@link #asIndexBytes(ByteBuffer, AbstractType)}.
     * It is not generally safe to pass the output of other serialization methods to this method.  For instance, it is
     * not generally safe to pass the output of {@link AbstractType#decompose(Object)} as the {@code value} parameter
     * (there are certain types for which this is technically OK, but that doesn't hold for all types).
     *
     * @param value a value buffer returned by {@link #asIndexBytes(ByteBuffer, AbstractType)}
     * @param type the type associated with the encoded {@code value} parameter
     * @param bytes this method's output
     */
    public static void toComparableBytes(ByteBuffer value, AbstractType&lt;?&gt; type, byte[] bytes)
    {
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">        if (isInetAddress(type))</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">            ByteBufferUtil.copyBytes(value, value.hasArray() ? value.arrayOffset() + value.position() : value.position(), bytes, 0, INET_ADDRESS_SIZE);</span>
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">        else if (isBigInteger(type))</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">            ByteBufferUtil.copyBytes(value, value.hasArray() ? value.arrayOffset() + value.position() : value.position(), bytes, 0, BIG_INTEGER_APPROXIMATION_BYTES);</span>
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">        else if (isBigDecimal(type))</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">            ByteBufferUtil.copyBytes(value, value.hasArray() ? value.arrayOffset() + value.position() : value.position(), bytes, 0, DECIMAL_APPROXIMATION_BYTES);</span>
        else
<span class="fc" id="L241">            ByteSourceInverse.copyBytes(asComparableBytes(value, type, ByteComparable.Version.OSS50), bytes);</span>
<span class="fc" id="L242">    }</span>

    /**
     * Translates the external value of specific types into a format used by the index.
     */
    public static ByteBuffer asIndexBytes(ByteBuffer value, AbstractType&lt;?&gt; type)
    {
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">        if (value == null)</span>
<span class="nc" id="L250">            return null;</span>

<span class="pc bpc" id="L252" title="1 of 2 branches missed.">        if (isInetAddress(type))</span>
<span class="nc" id="L253">            return encodeInetAddress(value);</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">        else if (isBigInteger(type))</span>
<span class="nc" id="L255">            return encodeBigInteger(value);</span>
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">        else if (type instanceof DecimalType)</span>
<span class="nc" id="L257">            return encodeDecimal(value);</span>
<span class="fc" id="L258">        return value;</span>
    }

    /**
     * Compare two terms based on their type. This is used in place of {@link AbstractType#compare(ByteBuffer, ByteBuffer)}
     * so that the default comparison can be overridden for specific types.
     *
     * Note: This should be used for all term comparison
     */
    public static int compare(ByteBuffer b1, ByteBuffer b2, AbstractType&lt;?&gt; type)
    {
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">        if (isInetAddress(type))</span>
<span class="nc" id="L270">            return compareInet(b1, b2);</span>
        // BigInteger values, frozen types and composite types (map entries) use compareUnsigned to maintain
        // a consistent order between the in-memory index and the on-disk index.
<span class="pc bpc" id="L273" title="3 of 6 branches missed.">        else if (isBigInteger(type) || isBigDecimal(type) || isCompositeOrFrozen(type))</span>
<span class="nc" id="L274">            return FastByteOperations.compareUnsigned(b1, b2);</span>

<span class="fc" id="L276">        return type.compare(b1, b2 );</span>
    }

    /**
     * This is used for value comparison in post-filtering - {@link Expression#isSatisfiedBy(ByteBuffer)}.
     *
     * This allows types to decide whether they should be compared based on their encoded value or their
     * raw value. At present only {@link InetAddressType} values are compared by their encoded values to
     * allow for ipv4 -&gt; ipv6 equivalency in searches.
     */
    public static int comparePostFilter(Expression.Value requestedValue, Expression.Value columnValue, AbstractType&lt;?&gt; type)
    {
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">        if (isInetAddress(type))</span>
<span class="nc" id="L289">            return compareInet(requestedValue.encoded, columnValue.encoded);</span>
        // Override comparisons for frozen collections and composite types (map entries)
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">        else if (isCompositeOrFrozen(type))</span>
<span class="nc" id="L292">            return FastByteOperations.compareUnsigned(requestedValue.raw, columnValue.raw);</span>

<span class="fc" id="L294">        return type.compare(requestedValue.raw, columnValue.raw);</span>
    }

    public static Iterator&lt;ByteBuffer&gt; collectionIterator(AbstractType&lt;?&gt; validator,
                                                          ComplexColumnData cellData,
                                                          ColumnMetadata columnMetadata,
                                                          IndexTarget.Type indexType,
                                                          long nowInSecs)
    {
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (cellData == null)</span>
<span class="nc" id="L304">            return null;</span>

<span class="nc bnc" id="L306" title="All 4 branches missed.">        Stream&lt;ByteBuffer&gt; stream = StreamSupport.stream(cellData.spliterator(), false).filter(cell -&gt; cell != null &amp;&amp; cell.isLive(nowInSecs))</span>
<span class="nc" id="L307">                                                 .map(cell -&gt; cellValue(columnMetadata, indexType, cell));</span>

<span class="nc bnc" id="L309" title="All 2 branches missed.">        if (isInetAddress(validator))</span>
<span class="nc" id="L310">            stream = stream.sorted((c1, c2) -&gt; compareInet(encodeInetAddress(c1), encodeInetAddress(c2)));</span>

<span class="nc" id="L312">        return stream.iterator();</span>
    }

    public static Comparator&lt;ByteBuffer&gt; comparator(AbstractType&lt;?&gt; type)
    {
        // Override the comparator for BigInteger, frozen collections and composite types
<span class="pc bpc" id="L318" title="3 of 6 branches missed.">        if (isBigInteger(type) || isBigDecimal(type) || isCompositeOrFrozen(type))</span>
<span class="nc" id="L319">            return FastByteOperations::compareUnsigned;</span>

<span class="fc" id="L321">        return type;</span>
    }

    private static ByteBuffer cellValue(ColumnMetadata columnMetadata, IndexTarget.Type indexType, Cell&lt;?&gt; cell)
    {
<span class="nc bnc" id="L326" title="All 4 branches missed.">        if (columnMetadata.type.isCollection() &amp;&amp; columnMetadata.type.isMultiCell())</span>
        {
<span class="nc bnc" id="L328" title="All 4 branches missed.">            switch (((CollectionType&lt;?&gt;) columnMetadata.type).kind)</span>
            {
                case LIST:
<span class="nc" id="L331">                    return cell.buffer();</span>
                case SET:
<span class="nc" id="L333">                    return cell.path().get(0);</span>
                case MAP:
<span class="nc bnc" id="L335" title="All 4 branches missed.">                    switch (indexType)</span>
                    {
                        case KEYS:
<span class="nc" id="L338">                            return cell.path().get(0);</span>
                        case VALUES:
<span class="nc" id="L340">                            return cell.buffer();</span>
                        case KEYS_AND_VALUES:
<span class="nc" id="L342">                            return CompositeType.build(ByteBufferAccessor.instance, cell.path().get(0), cell.buffer());</span>
                    }
            }
        }
<span class="nc" id="L346">        return cell.buffer();</span>
    }

    /**
     * Compares 2 InetAddress terms by ensuring that both addresses are represented as
     * ipv6 addresses.
     */
    private static int compareInet(ByteBuffer b1, ByteBuffer b2)
    {
<span class="nc bnc" id="L355" title="All 4 branches missed.">        assert isIPv6(b1) &amp;&amp; isIPv6(b2);</span>

<span class="nc" id="L357">        return FastByteOperations.compareUnsigned(b1, b2);</span>
    }

    private static boolean isIPv6(ByteBuffer address)
    {
<span class="nc bnc" id="L362" title="All 2 branches missed.">        return address.remaining() == INET_ADDRESS_SIZE;</span>
    }

    /**
     * Encode a {@link InetAddress} into a fixed width 16 byte encoded value.
     *
     * The encoded value is byte comparable and prefix compressible.
     *
     * The encoding is done by converting ipv4 addresses to their ipv6 equivalent.
     */
    private static ByteBuffer encodeInetAddress(ByteBuffer value)
    {
<span class="nc bnc" id="L374" title="All 2 branches missed.">        if (value.remaining() == 4)</span>
        {
<span class="nc bnc" id="L376" title="All 2 branches missed.">            int position = value.hasArray() ? value.arrayOffset() + value.position() : value.position();</span>
<span class="nc" id="L377">            ByteBuffer mapped = ByteBuffer.allocate(INET_ADDRESS_SIZE);</span>
<span class="nc" id="L378">            System.arraycopy(IPV4_PREFIX, 0, mapped.array(), 0, IPV4_PREFIX.length);</span>
<span class="nc" id="L379">            ByteBufferUtil.copyBytes(value, position, mapped, IPV4_PREFIX.length, value.remaining());</span>
<span class="nc" id="L380">            return mapped;</span>
        }
<span class="nc" id="L382">        return value;</span>
    }

    /**
     * Encode a {@link BigInteger} into a fixed width 20 byte encoded value.
     *
     * The encoded value is byte comparable and prefix compressible.
     *
     * The format of the encoding is:
     *
     *  The first 4 bytes contain the integer length of the {@link BigInteger} byte array
     *  with the top bit flipped for positive values.
     *
     *  The remaining 16 bytes contain the 16 most significant bytes of the
     *  {@link BigInteger} byte array.
     *
     *  For {@link BigInteger} values whose underlying byte array is less than
     *  16 bytes, the encoded value is sign extended.
     */
    public static ByteBuffer encodeBigInteger(ByteBuffer value)
    {
<span class="nc" id="L403">        int size = value.remaining();</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">        int position = value.hasArray() ? value.arrayOffset() + value.position() : value.position();</span>
<span class="nc" id="L405">        byte[] bytes = new byte[BIG_INTEGER_APPROXIMATION_BYTES];</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">        if (size &lt; BIG_INTEGER_APPROXIMATION_BYTES - Integer.BYTES)</span>
        {
<span class="nc" id="L408">            ByteBufferUtil.copyBytes(value, position, bytes, bytes.length - size, size);</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">            if ((bytes[bytes.length - size] &amp; 0x80) != 0)</span>
<span class="nc" id="L410">                Arrays.fill(bytes, Integer.BYTES, bytes.length - size, (byte)0xff);</span>
            else
<span class="nc" id="L412">                Arrays.fill(bytes, Integer.BYTES, bytes.length - size, (byte)0x00);</span>
        }
        else
        {
<span class="nc" id="L416">            ByteBufferUtil.copyBytes(value, position, bytes, Integer.BYTES, BIG_INTEGER_APPROXIMATION_BYTES - Integer.BYTES);</span>
        }
<span class="nc bnc" id="L418" title="All 2 branches missed.">        if ((bytes[4] &amp; 0x80) != 0)</span>
        {
<span class="nc" id="L420">            size = -size;</span>
        }
<span class="nc" id="L422">        bytes[0] = (byte)(size &gt;&gt; 24 &amp; 0xff);</span>
<span class="nc" id="L423">        bytes[1] = (byte)(size &gt;&gt; 16 &amp; 0xff);</span>
<span class="nc" id="L424">        bytes[2] = (byte)(size &gt;&gt; 8 &amp; 0xff);</span>
<span class="nc" id="L425">        bytes[3] = (byte)(size &amp; 0xff);</span>
<span class="nc" id="L426">        bytes[0] ^= 0x80;</span>
<span class="nc" id="L427">        return ByteBuffer.wrap(bytes);</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if values of the given {@link AbstractType} should be indexed as literals.
     */
    public static boolean isLiteral(AbstractType&lt;?&gt; type)
    {
<span class="pc bpc" id="L435" title="2 of 6 branches missed.">        return isString(type) || isCompositeOrFrozen(type) || baseType(type) instanceof BooleanType;</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if given {@link AbstractType} is based on a string, e.g. UTF8 or Ascii
     */
    public static boolean isString(AbstractType&lt;?&gt; type)
    {
<span class="fc" id="L443">        type = baseType(type);</span>
<span class="fc" id="L444">        return type instanceof StringType;</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if given {@link AbstractType} is a Composite(map entry) or frozen.
     */
    public static boolean isCompositeOrFrozen(AbstractType&lt;?&gt; type)
    {
<span class="fc" id="L452">        type = baseType(type);</span>
<span class="pc bpc" id="L453" title="2 of 4 branches missed.">        return type instanceof CompositeType || isFrozen(type);</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if given {@link AbstractType} is frozen.
     */
    public static boolean isFrozen(AbstractType&lt;?&gt; type)
    {
<span class="fc" id="L461">        type = baseType(type);</span>
<span class="pc bpc" id="L462" title="3 of 4 branches missed.">        return !type.subTypes().isEmpty() &amp;&amp; !type.isMultiCell();</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if given {@link AbstractType} is a frozen collection.
     */
    public static boolean isFrozenCollection(AbstractType&lt;?&gt; type)
    {
<span class="nc" id="L470">        type = baseType(type);</span>
<span class="nc bnc" id="L471" title="All 4 branches missed.">        return type.isCollection() &amp;&amp; !type.isMultiCell();</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if given {@link AbstractType} is a non-frozen collection.
     */
    public static boolean isNonFrozenCollection(AbstractType&lt;?&gt; type)
    {
<span class="fc" id="L479">        type = baseType(type);</span>
<span class="pc bpc" id="L480" title="3 of 4 branches missed.">        return type.isCollection() &amp;&amp; type.isMultiCell();</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if given {@link AbstractType} is {@link InetAddressType}
     */
    private static boolean isInetAddress(AbstractType&lt;?&gt; type)
    {
<span class="fc" id="L488">        type = baseType(type);</span>
<span class="fc" id="L489">        return type instanceof InetAddressType;</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if given {@link AbstractType} is {@link IntegerType}
     */
    private static boolean isBigInteger(AbstractType&lt;?&gt; type)
    {
<span class="fc" id="L497">        type = baseType(type);</span>
<span class="fc" id="L498">        return type instanceof IntegerType;</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if given {@link AbstractType} is {@link DecimalType}
     */
    private static boolean isBigDecimal(AbstractType&lt;?&gt; type)
    {
<span class="fc" id="L506">        type = baseType(type);</span>
<span class="fc" id="L507">        return type instanceof DecimalType;</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if given {@link AbstractType} is {@link CompositeType}
     */
    public static boolean isComposite(AbstractType&lt;?&gt; type)
    {
<span class="fc" id="L515">        type = baseType(type);</span>
<span class="fc" id="L516">        return type instanceof CompositeType;</span>
    }

    /**
     * @return base type if given type is reversed, otherwise return itself
     */
    private static AbstractType&lt;?&gt; baseType(AbstractType&lt;?&gt; type)
    {
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">        return type.isReversed() ? ((ReversedType&lt;?&gt;) type).baseType : type;</span>
    }

    public static ByteBuffer encodeDecimal(ByteBuffer value)
    {
<span class="nc" id="L529">        ByteSource bs = DecimalType.instance.asComparableBytes(value, ByteComparable.Version.OSS50);</span>
<span class="nc" id="L530">        bs = ByteSource.cutOrRightPad(bs, DECIMAL_APPROXIMATION_BYTES, 0);</span>
<span class="nc" id="L531">        return ByteBuffer.wrap(ByteSourceInverse.readBytes(bs, DECIMAL_APPROXIMATION_BYTES));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>