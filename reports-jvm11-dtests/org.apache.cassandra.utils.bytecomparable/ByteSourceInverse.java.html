<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ByteSourceInverse.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.utils.bytecomparable</a> &gt; <span class="el_source">ByteSourceInverse.java</span></div><h1>ByteSourceInverse.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.utils.bytecomparable;

import java.nio.charset.StandardCharsets;
import java.util.Arrays;

import com.google.common.base.Preconditions;

import org.apache.cassandra.db.marshal.ValueAccessor;

/**
 * Contains inverse transformation utilities for {@link ByteSource}s.
 *
 * See ByteComparable.md for details about the encoding scheme.
 */
<span class="pc" id="L32">public final class ByteSourceInverse</span>
{
    private static final int INITIAL_BUFFER_CAPACITY = 32;
    private static final int BYTE_ALL_BITS = 0xFF;
    private static final int BYTE_NO_BITS = 0x00;
    private static final int BYTE_SIGN_BIT = 1 &lt;&lt; 7;
    private static final int SHORT_SIGN_BIT = 1 &lt;&lt; 15;
    private static final int INT_SIGN_BIT = 1 &lt;&lt; 31;
    private static final long LONG_SIGN_BIT = 1L &lt;&lt; 63;

    /**
     * Consume the given number of bytes and produce a long from them, effectively treating the bytes as a big-endian
     * unsigned encoding of the number.
     */
    public static long getUnsignedFixedLengthAsLong(ByteSource byteSource, int length)
    {
<span class="nc" id="L48">        Preconditions.checkNotNull(byteSource);</span>
<span class="nc bnc" id="L49" title="All 4 branches missed.">        Preconditions.checkArgument(length &gt;= 1 &amp;&amp; length &lt;= 8, &quot;Between 1 and 8 bytes can be read at a time&quot;);</span>

<span class="nc" id="L51">        long result = 0;</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">        for (int i = 0; i &lt; length; ++i)</span>
<span class="nc" id="L53">            result = (result &lt;&lt; 8) | getAndCheckByte(byteSource, i, length);  // note: this must use the unsigned byte value</span>

<span class="nc" id="L55">        return result;</span>
    }

    /**
     * Produce the bytes for an encoded signed fixed-length number.
     * The first byte has its sign bit inverted, and the rest are passed unchanged.
     */
    public static &lt;V&gt; V getSignedFixedLength(ValueAccessor&lt;V&gt; accessor, ByteSource byteSource, int length)
    {
<span class="fc" id="L64">        Preconditions.checkNotNull(byteSource);</span>
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">        Preconditions.checkArgument(length &gt;= 1, &quot;At least 1 byte should be read&quot;);</span>

<span class="fc" id="L67">        V result = accessor.allocate(length);</span>
        // The first byte needs to have its sign flipped
<span class="fc" id="L69">        accessor.putByte(result, 0, (byte) (getAndCheckByte(byteSource, 0, length) ^ BYTE_SIGN_BIT));</span>
        // and the rest can be retrieved unchanged.
<span class="fc bfc" id="L71" title="All 2 branches covered.">        for (int i = 1; i &lt; length; ++i)</span>
<span class="fc" id="L72">            accessor.putByte(result, i, (byte) getAndCheckByte(byteSource, i, length));</span>
<span class="fc" id="L73">        return result;</span>
    }

    /**
     * Produce the bytes for an encoded signed fixed-length number, also translating null to empty buffer.
     * The first byte has its sign bit inverted, and the rest are passed unchanged.
     */
    public static &lt;V&gt; V getOptionalSignedFixedLength(ValueAccessor&lt;V&gt; accessor, ByteSource byteSource, int length)
    {
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">        return byteSource == null ? accessor.empty() : getSignedFixedLength(accessor, byteSource, length);</span>
    }

    /**
     * Produce the bytes for an encoded signed fixed-length floating-point number.
     * If sign bit is on, returns negated bytes. If not, clears the sign bit and passes the rest of the bytes unchanged.
     */
    public static &lt;V&gt; V getSignedFixedLengthFloat(ValueAccessor&lt;V&gt; accessor, ByteSource byteSource, int length)
    {
<span class="nc" id="L91">        Preconditions.checkNotNull(byteSource);</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">        Preconditions.checkArgument(length &gt;= 1, &quot;At least 1 byte should be read&quot;);</span>

<span class="nc" id="L94">        V result = accessor.allocate(length);</span>

        int xor;
<span class="nc" id="L97">        int first = getAndCheckByte(byteSource, 0, length);</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">        if (first &lt; 0x80)</span>
        {
            // Negative number. Invert all bits.
<span class="nc" id="L101">            xor = BYTE_ALL_BITS;</span>
<span class="nc" id="L102">            first ^= xor;</span>
        }
        else
        {
            // Positive number. Invert only the sign bit.
<span class="nc" id="L107">            xor = BYTE_NO_BITS;</span>
<span class="nc" id="L108">            first ^= BYTE_SIGN_BIT;</span>
        }
<span class="nc" id="L110">        accessor.putByte(result, 0, (byte) first);</span>

        // xor is now applied to the rest of the bytes to flip their bits if necessary.
<span class="nc bnc" id="L113" title="All 2 branches missed.">        for (int i = 1; i &lt; length; ++i)</span>
<span class="nc" id="L114">            accessor.putByte(result, i, (byte) (getAndCheckByte(byteSource, i, length) ^ xor));</span>

<span class="nc" id="L116">        return result;</span>
    }

    /**
     * Produce the bytes for an encoded signed fixed-length floating-point number, also translating null to an empty
     * buffer.
     * If sign bit is on, returns negated bytes. If not, clears the sign bit and passes the rest of the bytes unchanged.
     */
    public static &lt;V&gt; V getOptionalSignedFixedLengthFloat(ValueAccessor&lt;V&gt; accessor, ByteSource byteSource, int length)
    {
<span class="nc bnc" id="L126" title="All 2 branches missed.">        return byteSource == null ? accessor.empty() : getSignedFixedLengthFloat(accessor, byteSource, length);</span>
    }

    /**
     * Consume the next length bytes from the source unchanged.
     */
    public static &lt;V&gt; V getFixedLength(ValueAccessor&lt;V&gt; accessor, ByteSource byteSource, int length)
    {
<span class="nc" id="L134">        Preconditions.checkNotNull(byteSource);</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">        Preconditions.checkArgument(length &gt;= 1, &quot;At least 1 byte should be read&quot;);</span>

<span class="nc" id="L137">        V result = accessor.allocate(length);</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">        for (int i = 0; i &lt; length; ++i)</span>
<span class="nc" id="L139">            accessor.putByte(result, i, (byte) getAndCheckByte(byteSource, i, length));</span>
<span class="nc" id="L140">        return result;</span>
    }

    /**
     * Consume the next length bytes from the source unchanged, also translating null to an empty buffer.
     */
    public static &lt;V&gt; V getOptionalFixedLength(ValueAccessor&lt;V&gt; accessor, ByteSource byteSource, int length)
    {
<span class="nc bnc" id="L148" title="All 2 branches missed.">        return byteSource == null ? accessor.empty() : getFixedLength(accessor, byteSource, length);</span>
    }

    /**
     * Consume the next {@code int} from the current position of the given {@link ByteSource}. The source position is
     * modified accordingly (moved 4 bytes forward).
     * &lt;p&gt;
     * The source is not strictly required to represent just the encoding of an {@code int} value, so theoretically
     * this API could be used for reading data in 4-byte strides. Nevertheless its usage is fairly limited because:
     * &lt;ol&gt;
     *     &lt;li&gt;...it presupposes signed fixed-length encoding for the encoding of the original value&lt;/li&gt;
     *     &lt;li&gt;...it decodes the data returned on each stride as an {@code int} (i.e. it inverts its leading bit)&lt;/li&gt;
     *     &lt;li&gt;...it doesn't provide any meaningful guarantees (with regard to throwing) in case there are not enough
     *     bytes to read, in case a special escape value was not interpreted as such, etc.&lt;/li&gt;
     * &lt;/ol&gt;
     * &lt;/p&gt;
     *
     * @param byteSource A non-null byte source, containing at least 4 bytes.
     */
    public static int getSignedInt(ByteSource byteSource)
    {
<span class="nc" id="L169">        return (int) getUnsignedFixedLengthAsLong(byteSource, 4) ^ INT_SIGN_BIT;</span>
    }

    /**
     * Consume the next {@code long} from the current position of the given {@link ByteSource}. The source position is
     * modified accordingly (moved 8 bytes forward).
     * &lt;p&gt;
     * The source is not strictly required to represent just the encoding of a {@code long} value, so theoretically
     * this API could be used for reading data in 8-byte strides. Nevertheless its usage is fairly limited because:
     * &lt;ol&gt;
     *     &lt;li&gt;...it presupposes signed fixed-length encoding for the encoding of the original value&lt;/li&gt;
     *     &lt;li&gt;...it decodes the data returned on each stride as a {@code long} (i.e. it inverts its leading bit)&lt;/li&gt;
     *     &lt;li&gt;...it doesn't provide any meaningful guarantees (with regard to throwing) in case there are not enough
     *     bytes to read, in case a special escape value was not interpreted as such, etc.&lt;/li&gt;
     * &lt;/ol&gt;
     * &lt;/p&gt;
     *
     * @param byteSource A non-null byte source, containing at least 8 bytes.
     */
    public static long getSignedLong(ByteSource byteSource)
    {
<span class="nc" id="L190">        return getUnsignedFixedLengthAsLong(byteSource, 8) ^ LONG_SIGN_BIT;</span>
    }

    /**
     * Converts the given {@link ByteSource} to a {@code byte}.
     *
     * @param byteSource A non-null byte source, containing at least 1 byte.
     */
    public static byte getSignedByte(ByteSource byteSource)
    {
<span class="nc" id="L200">        return (byte) (getAndCheckByte(Preconditions.checkNotNull(byteSource), 0, 1) ^ BYTE_SIGN_BIT);</span>
    }

    /**
     * Converts the given {@link ByteSource} to a {@code short}. All terms and conditions valid for
     * {@link #getSignedInt(ByteSource)} and {@link #getSignedLong(ByteSource)} translate to this as well.
     *
     * @param byteSource A non-null byte source, containing at least 2 bytes.
     *
     * @see #getSignedInt(ByteSource)
     * @see #getSignedLong(ByteSource)
     */
    public static short getSignedShort(ByteSource byteSource)
    {
<span class="nc" id="L214">        return (short) (getUnsignedFixedLengthAsLong(byteSource, 2) ^ SHORT_SIGN_BIT);</span>
    }

    /**
     * Decode a variable-length signed integer.
     */
    public static long getVariableLengthInteger(ByteSource byteSource)
    {
<span class="nc" id="L222">        int signAndMask = getAndCheckByte(byteSource);</span>

<span class="nc" id="L224">        long sum = 0;</span>
        int bytes;
        // For every bit after the sign that matches the sign, read one more byte.
<span class="nc bnc" id="L227" title="All 4 branches missed.">        for (bytes = 0; bytes &lt; 7 &amp;&amp; sameByteSign(signAndMask &lt;&lt; (bytes + 1), signAndMask); ++bytes)</span>
<span class="nc" id="L228">            sum = (sum &lt;&lt; 8) | getAndCheckByte(byteSource);</span>

        // The eighth length bit is stored in the second byte.
<span class="nc bnc" id="L231" title="All 4 branches missed.">        if (bytes == 7 &amp;&amp; sameByteSign((int) (sum &gt;&gt; 48), signAndMask))</span>
<span class="nc" id="L232">            return ((sum &lt;&lt; 8) | getAndCheckByte(byteSource)) ^ LONG_SIGN_BIT;    // 9-byte encoding, use bytes 2-9 with inverted sign</span>
        else
        {
<span class="nc" id="L235">            sum |= (((long) signAndMask) &lt;&lt; bytes * 8);     // add the rest of the bits</span>
<span class="nc" id="L236">            long signMask = -0x40L &lt;&lt; bytes * 7;            // mask of the bits that should be replaced by the sign</span>
<span class="nc" id="L237">            long sign = (byte) (signAndMask ^ 0x80) &gt;&gt; 7;   // -1 if negative (0 leading bit), 0 otherwise</span>
<span class="nc" id="L238">            return sum &amp; ~signMask | sign &amp; signMask;</span>
        }
    }

    /**
     * Decode a variable-length unsigned integer, passing all bytes read through XOR with the given xorWith parameter.
     *
     * Used in BigInteger encoding to read number length, where negative numbers have their length negated
     * (i.e. xorWith = 0xFF) to ensure correct ordering.
     */
    public static long getVariableLengthUnsignedIntegerXoring(ByteSource byteSource, int xorWith)
    {
<span class="nc" id="L250">        int signAndMask = getAndCheckByte(byteSource) ^ xorWith;</span>

<span class="nc" id="L252">        long sum = 0;</span>
        int bytes;
        // Read an extra byte while the next most significant bit is 1.
<span class="nc bnc" id="L255" title="All 4 branches missed.">        for (bytes = 0; bytes &lt;= 7 &amp;&amp; ((signAndMask &lt;&lt; bytes) &amp; 0x80) != 0; ++bytes)</span>
<span class="nc" id="L256">            sum = (sum &lt;&lt; 8) | getAndCheckByte(byteSource) ^ xorWith;</span>

        // Strip the length bits from the leading byte.
<span class="nc" id="L259">        signAndMask &amp;= ~(-256 &gt;&gt; bytes);</span>
<span class="nc" id="L260">        return sum | (((long) signAndMask) &lt;&lt; bytes * 8);     // Add the rest of the bits of the leading byte.</span>
    }

    /** Returns true if the two parameters treated as bytes have the same sign. */
    private static boolean sameByteSign(int a, int b)
    {
<span class="nc bnc" id="L266" title="All 2 branches missed.">        return ((a ^ b) &amp; 0x80) == 0;</span>
    }


    private static int getAndCheckByte(ByteSource byteSource)
    {
<span class="nc" id="L272">        return getAndCheckByte(byteSource, -1, -1);</span>
    }

    private static int getAndCheckByte(ByteSource byteSource, int pos, int length)
    {
<span class="fc" id="L277">        int data = byteSource.next();</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if (data == ByteSource.END_OF_STREAM)</span>
<span class="nc" id="L279">            throw new IllegalArgumentException(</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">                length &gt; 0 ? String.format(&quot;Unexpected end of stream reached after %d bytes (expected &gt;= %d)&quot;, pos, length)</span>
<span class="nc" id="L281">                           : &quot;Unexpected end of stream&quot;);</span>
<span class="pc bpc" id="L282" title="2 of 4 branches missed.">        assert data &gt;= BYTE_NO_BITS &amp;&amp; data &lt;= BYTE_ALL_BITS</span>
            : &quot;A ByteSource must produce unsigned bytes and end in END_OF_STREAM&quot;;
<span class="fc" id="L284">        return data;</span>
    }

    /**
     * Reads a single variable-length byte sequence (blob, string, ...) encoded according to the scheme described
     * in ByteComparable.md, decoding it back to its original, unescaped form.
     *
     * @param byteSource The source of the variable-length bytes sequence.
     * @return A byte array containing the original, unescaped bytes of the given source. Unescaped here means
     * not including any of the escape sequences of the encoding scheme used for variable-length byte sequences.
     */
    public static byte[] getUnescapedBytes(ByteSource.Peekable byteSource)
    {
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">        return byteSource == null ? null : readBytes(unescape(byteSource));</span>
    }

    /**
     * As above, but converts the result to a ByteSource.
     */
    public static ByteSource unescape(ByteSource.Peekable byteSource)
    {
<span class="fc" id="L305">        return new ByteSource() {</span>
<span class="fc" id="L306">            boolean escaped = false;</span>

            @Override
            public int next()
            {
<span class="fc bfc" id="L311" title="All 2 branches covered.">                if (!escaped)</span>
                {
<span class="fc" id="L313">                    int data = byteSource.next(); // we consume this byte no matter what it is</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">                    if (data &gt; ByteSource.ESCAPE)</span>
<span class="fc" id="L315">                        return data;        // most used path leads here</span>

<span class="pc bpc" id="L317" title="1 of 2 branches missed.">                    assert data != ByteSource.END_OF_STREAM : &quot;Invalid escaped byte sequence&quot;;</span>
<span class="fc" id="L318">                    escaped = true;</span>
                }

<span class="fc" id="L321">                int next = byteSource.peek();</span>
<span class="fc bfc" id="L322" title="All 4 branches covered.">                switch (next)</span>
                {
                    case END_OF_STREAM:
                        // The end of a byte-comparable outside of a multi-component sequence. No matter what we have
                        // seen or peeked before, we should stop now.
<span class="fc" id="L327">                        byteSource.next();</span>
<span class="fc" id="L328">                        return END_OF_STREAM;</span>
                    case ESCAPED_0_DONE:
                        // The end of 1 or more consecutive 0x00 value bytes.
<span class="fc" id="L331">                        escaped = false;</span>
<span class="fc" id="L332">                        byteSource.next();</span>
<span class="fc" id="L333">                        return ESCAPE;</span>
                    case ESCAPED_0_CONT:
                        // Escaped sequence continues
<span class="fc" id="L336">                        byteSource.next();</span>
<span class="fc" id="L337">                        return ESCAPE;</span>
                    default:
                        // An ESCAPE or ESCAPED_0_CONT won't be followed by either another ESCAPED_0_CONT, an
                        // ESCAPED_0_DONE, or an END_OF_STREAM only when the byte-comparable is part of a multi-component
                        // sequence and we have reached the end of the encoded byte-comparable. In this case, the byte
                        // we have just peeked is the separator or terminator byte between or at the end of components
                        // (which by contact must be 0x10 - 0xFE, which cannot conflict with our special bytes).
<span class="pc bpc" id="L344" title="2 of 4 branches missed.">                        assert next &gt;= ByteSource.MIN_SEPARATOR &amp;&amp; next &lt;= ByteSource.MAX_SEPARATOR : next;</span>
                        // Unlike above, we don't consume this byte (the sequence decoding needs it).
<span class="fc" id="L346">                        return END_OF_STREAM;</span>
                }
            }
        };
    }

    /**
     * Reads the bytes of the given source into a byte array. Doesn't do any transformation on the bytes, just reads
     * them until it reads an {@link ByteSource#END_OF_STREAM} byte, after which it returns an array of all the read
     * bytes, &lt;strong&gt;excluding the {@link ByteSource#END_OF_STREAM}&lt;/strong&gt;.
     * &lt;p&gt;
     * This method sizes a tentative internal buffer array at {@code initialBufferCapacity}.  However, if
     * {@code byteSource} exceeds this size, the buffer array is recreated with doubled capacity as many times as
     * necessary.  If, after {@code byteSource} is fully exhausted, the number of bytes read from it does not exactly
     * match the current size of the tentative buffer array, then it is copied into another array sized to fit the
     * number of bytes read; otherwise, it is returned without that final copy step.
     *
     * @param byteSource The source which bytes we're interested in.
     * @param initialBufferCapacity The initial size of the internal buffer.
     * @return A byte array containing exactly all the read bytes. In case of a {@code null} source, the returned byte
     * array will be empty.
     */
    public static byte[] readBytes(ByteSource byteSource, final int initialBufferCapacity)
    {
<span class="fc" id="L370">        Preconditions.checkNotNull(byteSource);</span>

<span class="fc" id="L372">        int readBytes = 0;</span>
<span class="fc" id="L373">        byte[] buf = new byte[initialBufferCapacity];</span>
        int data;
<span class="fc bfc" id="L375" title="All 2 branches covered.">        while ((data = byteSource.next()) != ByteSource.END_OF_STREAM)</span>
        {
<span class="fc" id="L377">            buf = ensureCapacity(buf, readBytes);</span>
<span class="fc" id="L378">            buf[readBytes++] = (byte) data;</span>
        }

<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        if (readBytes != buf.length)</span>
        {
<span class="fc" id="L383">            buf = Arrays.copyOf(buf, readBytes);</span>
        }
<span class="fc" id="L385">        return buf;</span>
    }

    /**
     * Reads the bytes of the given source into a byte array. Doesn't do any transformation on the bytes, just reads
     * them until it reads an {@link ByteSource#END_OF_STREAM} byte, after which it returns an array of all the read
     * bytes, &lt;strong&gt;excluding the {@link ByteSource#END_OF_STREAM}&lt;/strong&gt;.
     * &lt;p&gt;
     * This is equivalent to {@link #readBytes(ByteSource, int)} where the second actual parameter is
     * {@linkplain #INITIAL_BUFFER_CAPACITY} ({@value INITIAL_BUFFER_CAPACITY}).
     *
     * @param byteSource The source which bytes we're interested in.
     * @return A byte array containing exactly all the read bytes. In case of a {@code null} source, the returned byte
     * array will be empty.
     */
    public static byte[] readBytes(ByteSource byteSource)
    {
<span class="fc" id="L402">        return readBytes(byteSource, INITIAL_BUFFER_CAPACITY);</span>
    }

    public static void copyBytes(ByteSource byteSource, byte[] bytes)
    {
<span class="fc" id="L407">        int readBytes = 0;</span>

        int data;
<span class="fc bfc" id="L410" title="All 2 branches covered.">        while ((data = byteSource.next()) != ByteSource.END_OF_STREAM)</span>
        {
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">            if (bytes.length == readBytes)</span>
<span class="nc" id="L413">                throw new ArrayIndexOutOfBoundsException(String.format(&quot;Number of bytes read, %d, exceeds the buffer size of %d.&quot;, readBytes + 1, bytes.length));</span>
<span class="fc" id="L414">            bytes[readBytes++] = (byte) data;</span>
        }
<span class="fc" id="L416">    }</span>

    /**
     * Ensures the given buffer has capacity for taking data with the given length - if it doesn't, it returns a copy
     * of the buffer, but with double the capacity.
     */
    private static byte[] ensureCapacity(byte[] buf, int dataLengthInBytes)
    {
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">        if (dataLengthInBytes == buf.length)</span>
            // We won't gain much with guarding against overflow. We'll overflow when dataLengthInBytes &gt;= 1 &lt;&lt; 30,
            // and if we do guard, we'll be able to extend the capacity to Integer.MAX_VALUE (which is 1 &lt;&lt; 31 - 1).
            // Controlling the exception that will be thrown shouldn't matter that much, and  in practice, we almost
            // surely won't be reading gigabytes of ByteSource data at once.
<span class="nc" id="L429">            return Arrays.copyOf(buf, dataLengthInBytes * 2);</span>
        else
<span class="fc" id="L431">            return buf;</span>
    }

    /**
     * Converts the given {@link ByteSource} to a UTF-8 {@link String}.
     *
     * @param byteSource The source we're interested in.
     * @return A UTF-8 string corresponding to the given source.
     */
    public static String getString(ByteSource.Peekable byteSource)
    {
<span class="nc bnc" id="L442" title="All 2 branches missed.">        if (byteSource == null)</span>
<span class="nc" id="L443">            return null;</span>

<span class="nc" id="L445">        byte[] data = getUnescapedBytes(byteSource);</span>

<span class="nc" id="L447">        return new String(data, StandardCharsets.UTF_8);</span>
    }

    /*
     * Multi-component sequence utilities.
     */

    /**
     * A utility for consuming components from a peekable multi-component sequence.
     * It uses the component separators, so the given sequence needs to have its last component fully consumed, in
     * order for the next consumable byte to be a separator. Identifying the end of the component that will then be
     * consumed is the responsibility of the consumer (the user of this method).
     * @param source A peekable multi-component sequence, which next byte is a component separator.
     * @return the given multi-component sequence if its next component is not null, or {@code null} if it is.
     */
    public static ByteSource.Peekable nextComponentSource(ByteSource.Peekable source)
    {
<span class="fc" id="L464">        return nextComponentSource(source, source.next());</span>
    }

    /**
     * A utility for consuming components from a peekable multi-component sequence, very similar to
     * {@link #nextComponentSource(ByteSource.Peekable)} - the difference being that here the separator can be passed
     * in case it had to be consumed beforehand.
     */
    public static ByteSource.Peekable nextComponentSource(ByteSource.Peekable source, int separator)
    {
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">        return nextComponentNull(separator)</span>
<span class="nc" id="L475">               ? null</span>
<span class="fc" id="L476">               : source;</span>
    }

    public static boolean nextComponentNull(int separator)
    {
<span class="pc bpc" id="L481" title="3 of 6 branches missed.">        return separator == ByteSource.NEXT_COMPONENT_NULL || separator == ByteSource.NEXT_COMPONENT_EMPTY</span>
               || separator == ByteSource.NEXT_COMPONENT_EMPTY_REVERSED;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>