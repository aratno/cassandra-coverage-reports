<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClusteringIndexNamesFilter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.filter</a> &gt; <span class="el_source">ClusteringIndexNamesFilter.java</span></div><h1>ClusteringIndexNamesFilter.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.filter;

import java.io.IOException;
import java.util.*;

import org.apache.cassandra.cql3.Operator;
import org.apache.cassandra.db.*;
import org.apache.cassandra.db.partitions.*;
import org.apache.cassandra.db.rows.*;
import org.apache.cassandra.db.transform.Transformation;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.utils.btree.BTree;
import org.apache.cassandra.utils.btree.BTreeSet;

/**
 * A filter selecting rows given their clustering value.
 */
public class ClusteringIndexNamesFilter extends AbstractClusteringIndexFilter
{
<span class="fc" id="L40">    static final InternalDeserializer deserializer = new NamesDeserializer();</span>

    // This could be empty if selectedColumns only has static columns (in which case the filter still
    // selects the static row)
    private final NavigableSet&lt;Clustering&lt;?&gt;&gt; clusterings;

    // clusterings is always in clustering order (because we need it that way in some methods), but we also
    // sometimes need those clustering in &quot;query&quot; order (i.e. in reverse clustering order if the query is
    // reversed), so we keep that too for simplicity.
    private final NavigableSet&lt;Clustering&lt;?&gt;&gt; clusteringsInQueryOrder;

    public ClusteringIndexNamesFilter(NavigableSet&lt;Clustering&lt;?&gt;&gt; clusterings, boolean reversed)
    {
<span class="fc" id="L53">        super(reversed);</span>
<span class="pc bpc" id="L54" title="1 of 2 branches missed.">        assert !clusterings.contains(Clustering.STATIC_CLUSTERING);</span>
<span class="fc" id="L55">        this.clusterings = clusterings;</span>
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">        this.clusteringsInQueryOrder = reversed ? clusterings.descendingSet() : clusterings;</span>
<span class="fc" id="L57">    }</span>

    /**
     * The set of requested rows.
     *
     * Please note that this can be empty if only the static row is requested.
     *
     * @return the set of requested clustering in clustering order (note that
     * this is always in clustering order even if the query is reversed).
     */
    public NavigableSet&lt;Clustering&lt;?&gt;&gt; requestedRows()
    {
<span class="fc" id="L69">        return clusterings;</span>
    }

    public boolean selectsAllPartition()
    {
        // if the clusterings set is empty we are selecting a static row and in this case we want to count
        // static rows so we return true
<span class="fc" id="L76">        return clusterings.isEmpty();</span>
    }

    public boolean selects(Clustering&lt;?&gt; clustering)
    {
<span class="fc" id="L81">        return clusterings.contains(clustering);</span>
    }

    public ClusteringIndexNamesFilter forPaging(ClusteringComparator comparator, Clustering&lt;?&gt; lastReturned, boolean inclusive)
    {
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">        NavigableSet&lt;Clustering&lt;?&gt;&gt; newClusterings = reversed ?</span>
<span class="nc" id="L87">                                                     clusterings.headSet(lastReturned, inclusive) :</span>
<span class="fc" id="L88">                                                     clusterings.tailSet(lastReturned, inclusive);</span>

<span class="fc" id="L90">        return new ClusteringIndexNamesFilter(newClusterings, reversed);</span>
    }

    public boolean isFullyCoveredBy(CachedPartition partition)
    {
<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (partition.isEmpty())</span>
<span class="nc" id="L96">            return false;</span>

        // 'partition' contains all columns, so it covers our filter if our last clusterings
        // is smaller than the last in the cache
<span class="nc bnc" id="L100" title="All 2 branches missed.">        return clusterings.comparator().compare(clusterings.last(), partition.lastRow().clustering()) &lt;= 0;</span>
    }

    public boolean isHeadFilter()
    {
<span class="nc" id="L105">        return false;</span>
    }

    // Given another iterator, only return the rows that match this filter
    public UnfilteredRowIterator filterNotIndexed(ColumnFilter columnFilter, UnfilteredRowIterator iterator)
    {
        // Note that we don't filter markers because that's a bit trickier (we don't know in advance until when
        // the range extend) and it's harmless to left them.
<span class="nc" id="L113">        class FilterNotIndexed extends Transformation</span>
        {
            @Override
            public Row applyToStatic(Row row)
            {
<span class="nc bnc" id="L118" title="All 2 branches missed.">                return columnFilter.fetchedColumns().statics.isEmpty() ? null : row.filter(columnFilter, iterator.metadata());</span>
            }

            @Override
            public Row applyToRow(Row row)
            {
<span class="nc bnc" id="L124" title="All 2 branches missed.">                return clusterings.contains(row.clustering()) ? row.filter(columnFilter, iterator.metadata()) : null;</span>
            }
        }
<span class="nc" id="L127">        return Transformation.apply(iterator, new FilterNotIndexed());</span>
    }

    public Slices getSlices(TableMetadata metadata)
    {
<span class="fc" id="L132">        Slices.Builder builder = new Slices.Builder(metadata.comparator, clusteringsInQueryOrder.size());</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">        for (Clustering&lt;?&gt; clustering : clusteringsInQueryOrder)</span>
<span class="fc" id="L134">            builder.add(Slice.make(clustering));</span>
<span class="fc" id="L135">        return builder.build();</span>
    }

    public UnfilteredRowIterator getUnfilteredRowIterator(final ColumnFilter columnFilter, final Partition partition)
    {
<span class="fc" id="L140">        return partition.unfilteredIterator(columnFilter, clusteringsInQueryOrder, isReversed());</span>
    }

    public boolean intersects(ClusteringComparator comparator, Slice slice)
    {
<span class="fc bfc" id="L145" title="All 2 branches covered.">        for (Clustering&lt;?&gt; clustering : clusterings)</span>
        {
<span class="fc bfc" id="L147" title="All 2 branches covered.">            if (slice.includes(comparator, clustering))</span>
<span class="fc" id="L148">                return true;</span>
<span class="fc" id="L149">        }</span>
<span class="fc" id="L150">        return false;</span>
    }

    public String toString(TableMetadata metadata)
    {
<span class="fc" id="L155">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L156">        sb.append(&quot;names(&quot;);</span>
<span class="fc" id="L157">        int i = 0;</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">        for (Clustering&lt;?&gt; clustering : clusterings)</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">            sb.append(i++ == 0 ? &quot;&quot; : &quot;, &quot;).append(clustering.toString(metadata));</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        if (reversed)</span>
<span class="nc" id="L161">            sb.append(&quot;, reversed&quot;);</span>
<span class="fc" id="L162">        return sb.append(')').toString();</span>
    }

    @Override
    public String toCQLString(TableMetadata metadata, RowFilter rowFilter)
    {
<span class="pc bpc" id="L168" title="3 of 4 branches missed.">        if (metadata.clusteringColumns().isEmpty() || clusterings.isEmpty())</span>
<span class="fc" id="L169">            return rowFilter.toCQLString();</span>

<span class="nc bnc" id="L171" title="All 2 branches missed.">        boolean isSingleColumn = metadata.clusteringColumns().size() == 1;</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">        boolean isSingleClustering = clusterings.size() == 1;</span>

<span class="nc" id="L174">        StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">        sb.append(isSingleColumn ? &quot;&quot; : '(')</span>
<span class="nc" id="L176">          .append(ColumnMetadata.toCQLString(metadata.clusteringColumns()))</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">          .append(isSingleColumn ? &quot;&quot; : ')');</span>

<span class="nc bnc" id="L179" title="All 2 branches missed.">        sb.append(isSingleClustering ? &quot; = &quot; : &quot; IN (&quot;);</span>
<span class="nc" id="L180">        int i = 0;</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">        for (Clustering&lt;?&gt; clustering : clusterings)</span>
        {
<span class="nc bnc" id="L183" title="All 2 branches missed.">            sb.append(i++ == 0 ? &quot;&quot; : &quot;, &quot;)</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">              .append(isSingleColumn ? &quot;&quot; : '(')</span>
<span class="nc" id="L185">              .append(clustering.toCQLString(metadata))</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">              .append(isSingleColumn ? &quot;&quot; : ')');</span>

<span class="nc bnc" id="L188" title="All 2 branches missed.">            for (int j = 0; j &lt; clustering.size(); j++)</span>
<span class="nc" id="L189">                rowFilter = rowFilter.without(metadata.clusteringColumns().get(j), Operator.EQ, clustering.bufferAt(j));</span>
<span class="nc" id="L190">        }</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">        sb.append(isSingleClustering ? &quot;&quot; : &quot;)&quot;);</span>

<span class="nc bnc" id="L193" title="All 2 branches missed.">        if (!rowFilter.isEmpty())</span>
<span class="nc" id="L194">            sb.append(&quot; AND &quot;).append(rowFilter.toCQLString());</span>

<span class="nc" id="L196">        appendOrderByToCQLString(metadata, sb);</span>
<span class="nc" id="L197">        return sb.toString();</span>
    }

    public boolean equals(Object o)
    {
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (this == o) return true;</span>
<span class="nc bnc" id="L203" title="All 4 branches missed.">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="nc" id="L204">        ClusteringIndexNamesFilter that = (ClusteringIndexNamesFilter) o;</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">        return Objects.equals(clusterings, that.clusterings) &amp;&amp;</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">               Objects.equals(reversed, that.reversed);</span>
    }

    public int hashCode()
    {
<span class="nc" id="L211">        return Objects.hash(clusterings, reversed);</span>
    }

    public Kind kind()
    {
<span class="fc" id="L216">        return Kind.NAMES;</span>
    }

    protected void serializeInternal(DataOutputPlus out, int version) throws IOException
    {
<span class="fc" id="L221">        ClusteringComparator comparator = (ClusteringComparator)clusterings.comparator();</span>
<span class="fc" id="L222">        out.writeUnsignedVInt32(clusterings.size());</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">        for (Clustering&lt;?&gt; clustering : clusterings)</span>
<span class="fc" id="L224">            Clustering.serializer.serialize(clustering, out, version, comparator.subtypes());</span>
<span class="fc" id="L225">    }</span>

    protected long serializedSizeInternal(int version)
    {
<span class="fc" id="L229">        ClusteringComparator comparator = (ClusteringComparator)clusterings.comparator();</span>
<span class="fc" id="L230">        long size = TypeSizes.sizeofUnsignedVInt(clusterings.size());</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">        for (Clustering&lt;?&gt; clustering : clusterings)</span>
<span class="fc" id="L232">            size += Clustering.serializer.serializedSize(clustering, version, comparator.subtypes());</span>
<span class="fc" id="L233">        return size;</span>
    }

    private static class NamesDeserializer implements InternalDeserializer
    {
        public ClusteringIndexFilter deserialize(DataInputPlus in, int version, TableMetadata metadata, boolean reversed) throws IOException
        {
<span class="fc" id="L240">            ClusteringComparator comparator = metadata.comparator;</span>
<span class="fc" id="L241">            int size = in.readUnsignedVInt32();</span>
<span class="fc" id="L242">            try (BTree.FastBuilder&lt;Clustering&lt;?&gt;&gt; builder = BTree.fastBuilder())</span>
            {
<span class="fc bfc" id="L244" title="All 2 branches covered.">                for (int i = 0; i &lt; size; i++)</span>
<span class="fc" id="L245">                    builder.add(Clustering.serializer.deserialize(in, version, comparator.subtypes()));</span>
<span class="fc" id="L246">                BTreeSet&lt;Clustering&lt;?&gt;&gt; clusterings = BTreeSet.wrap(builder.build(), comparator);</span>
<span class="fc" id="L247">                return new ClusteringIndexNamesFilter(clusterings, reversed);</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>