<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BTree.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.utils.btree</a> &gt; <span class="el_source">BTree.java</span></div><h1>BTree.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cassandra.utils.btree;

import java.util.*;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.Iterators;
import com.google.common.collect.Ordering;

import org.apache.cassandra.utils.BiLongAccumulator;
import org.apache.cassandra.utils.BulkIterator;
import org.apache.cassandra.utils.LongAccumulator;
import org.apache.cassandra.utils.ObjectSizes;
import org.apache.cassandra.utils.caching.TinyThreadLocalPool;

import static java.lang.Math.max;
import static java.lang.Math.min;
import static org.apache.cassandra.config.CassandraRelevantProperties.BTREE_BRANCH_SHIFT;

<span class="nc" id="L42">public class BTree</span>
{
    /**
     * The {@code BRANCH_FACTOR} is defined as the maximum number of children of each branch, with between
     * BRANCH_FACTOR/2-1 and BRANCH_FACTOR-1 keys being stored in every node. This yields a minimum tree size of
     * {@code (BRANCH_FACTOR/2)^height - 1} and a maximum tree size of {@code BRANCH_FACTOR^height - 1}.
     * &lt;p&gt;
     * Branches differ from leaves only in that they contain a suffix region containing the child nodes that occur
     * either side of the keys, and a sizeMap in the last position, permitting seeking by index within the tree.
     * Nodes are disambiguated by the length of the array that represents them: an even number is a branch, odd a leaf.
     * &lt;p&gt;
     * Leaf Nodes are represented by an odd-length array of keys, with the final element possibly null, i.e.
     * Object[V1, V2, ...,null?]
     * &lt;p&gt;
     * Branch nodes: Object[V1, V2, ..., child[&amp;lt;V1.key], child[&amp;lt;V2.key], ..., child[&amp;lt; Inf], sizeMap]
     * Each child is either a branch or leaf, i.e., always an Object[].
     * The key elements in a branch node occupy the first half of the array (minus one)
     * &lt;p&gt;
     * BTrees are immutable; updating one returns a new tree that reuses unmodified nodes.
     * &lt;p&gt;
     * There are no references back to a parent node from its children (this would make it impossible to re-use
     * subtrees when modifying the tree, since the modified tree would need new parent references).
     * Instead, we store these references in a Path as needed when navigating the tree.
     */
<span class="fc" id="L66">    public static final int BRANCH_SHIFT = BTREE_BRANCH_SHIFT.getInt();</span>

<span class="fc" id="L68">    private static final int BRANCH_FACTOR = 1 &lt;&lt; BRANCH_SHIFT;</span>
<span class="fc" id="L69">    public static final int MIN_KEYS = BRANCH_FACTOR / 2 - 1;</span>
<span class="fc" id="L70">    public static final int MAX_KEYS = BRANCH_FACTOR - 1;</span>

    // An empty BTree Leaf - which is the same as an empty BTree
<span class="fc" id="L73">    private static final Object[] EMPTY_LEAF = new Object[1];</span>

<span class="fc" id="L75">    private static final int[][] DENSE_SIZE_MAPS = buildBalancedSizeMaps(BRANCH_SHIFT);</span>
<span class="fc" id="L76">    private static final long[] PERFECT_DENSE_SIZE_ON_HEAP = sizeOnHeapOfPerfectTrees(BRANCH_SHIFT);</span>

    /**
     * Represents the direction of iteration.
     */
<span class="fc" id="L81">    public enum Dir</span>
    {
<span class="fc" id="L83">        ASC, DESC;</span>

        public Dir invert()
        {
<span class="nc bnc" id="L87" title="All 2 branches missed.">            return this == ASC ? DESC : ASC;</span>
        }

        public static Dir desc(boolean desc)
        {
<span class="fc bfc" id="L92" title="All 2 branches covered.">            return desc ? DESC : ASC;</span>
        }
    }

    /**
     * Returns an empty BTree
     *
     * @return an empty BTree
     */
    public static Object[] empty()
    {
<span class="fc" id="L103">        return EMPTY_LEAF;</span>
    }

    /**
     * Create a BTree containing only the specified object
     *
     * @return an new BTree containing only the specified object
     */
    public static Object[] singleton(Object value)
    {
<span class="fc" id="L113">        return new Object[]{ value };</span>
    }

    @Deprecated
    public static &lt;C, K extends C, V extends C&gt; Object[] build(Collection&lt;K&gt; source)
    {
<span class="fc" id="L119">        return build(source, UpdateFunction.noOp());</span>
    }

    @Deprecated
    public static &lt;C, K extends C, V extends C&gt; Object[] build(Collection&lt;K&gt; source, UpdateFunction&lt;K, V&gt; updateF)
    {
<span class="fc" id="L125">        return build(BulkIterator.of(source.iterator()), source.size(), updateF);</span>
    }

    public static &lt;C, I extends C, O extends C&gt; Object[] build(BulkIterator&lt;I&gt; source, int size, UpdateFunction&lt;I, O&gt; updateF)
    {
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">        assert size &gt;= 0;</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">        if (size == 0)</span>
<span class="fc" id="L132">            return EMPTY_LEAF;</span>

<span class="fc bfc" id="L134" title="All 2 branches covered.">        if (size &lt;= MAX_KEYS)</span>
<span class="fc" id="L135">            return buildLeaf(source, size, updateF);</span>

<span class="fc" id="L137">        return buildRoot(source, size, updateF);</span>
    }

    /**
     * Build a leaf with {@code size} elements taken in bulk from {@code insert}, and apply {@code updateF} to these elements
     */
    private static &lt;C, I extends C, O extends C&gt; Object[] buildLeaf(BulkIterator&lt;I&gt; insert,
                                                                    int size,
                                                                    UpdateFunction&lt;I, O&gt; updateF)
    {
<span class="fc" id="L147">        Object[] values = new Object[size | 1]; // ensure that we have an odd-length array</span>
<span class="fc" id="L148">        insert.fetch(values, 0, size);</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        if (!isSimple(updateF))</span>
        {
<span class="nc" id="L151">            updateF.onAllocatedOnHeap(ObjectSizes.sizeOfReferenceArray(values.length));</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">            for (int i = 0; i &lt; size; i++)</span>
<span class="nc" id="L153">                values[i] = updateF.insert((I) values[i]);</span>
        }
<span class="fc" id="L155">        return values;</span>
    }

    /**
     * Build a leaf with {@code size} elements taken in bulk from {@code insert}, and apply {@code updateF} to these elements
     * Do not invoke {@code updateF.onAllocated}.  Used by {@link #buildPerfectDenseWithoutSizeTracking} which
     * track the size for the entire tree they build in order to save on work.
     */
    private static &lt;C, I extends C, O extends C&gt; Object[] buildLeafWithoutSizeTracking(BulkIterator&lt;I&gt; insert, int size, UpdateFunction&lt;I, O&gt; updateF)
    {
<span class="nc" id="L165">        Object[] values = new Object[size | 1]; // ensure that we have an odd-length array</span>
<span class="nc" id="L166">        insert.fetch(values, 0, size);</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">        if (!isSimple(updateF))</span>
        {
<span class="nc bnc" id="L169" title="All 2 branches missed.">            for (int i = 0; i &lt; size; i++)</span>
<span class="nc" id="L170">                values[i] = updateF.insert((I) values[i]);</span>
        }
<span class="nc" id="L172">        return values;</span>
    }

    /**
     * Build a root node from the first {@code size} elements from {@code source}, applying {@code updateF} to those elements.
     * A root node is permitted to have as few as two children, if a branch (i.e. if {@code size &gt; MAX_SIZE}.
     */
    private static &lt;C, I extends C, O extends C&gt; Object[] buildRoot(BulkIterator&lt;I&gt; source, int size, UpdateFunction&lt;I, O&gt; updateF)
    {
        // first calculate the minimum height needed for this size of tree
<span class="fc" id="L182">        int height = minHeight(size);</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">        assert height &gt; 1;</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        assert height * BRANCH_SHIFT &lt; 32;</span>

<span class="fc" id="L186">        int denseChildSize = denseSize(height - 1);</span>
        // Divide the size by the child size + 1, adjusting size by +1 to compensate for not having an upper key on the
        // last child and rounding up, i.e. (size + 1 + div - 1) / div == size / div + 1 where div = childSize + 1
<span class="fc" id="L189">        int childCount = size / (denseChildSize + 1) + 1;</span>

<span class="fc" id="L191">        return buildMaximallyDense(source, childCount, size, height, updateF);</span>
    }

    /**
     * Build a tree containing only dense nodes except at most two on any level. This matches the structure that
     * a FastBuilder would create, with some optimizations in constructing the dense nodes.
     * &lt;p&gt;
     * We do this by repeatedly constructing fully dense children until we reach a threshold, chosen so that we would
     * not be able to create another child with fully dense children and at least MIN_KEYS keys. After the threshold,
     * the remainder may fit a single node, or is otherwise split roughly halfway to create one child with at least
     * MIN_KEYS+1 fully dense children, and one that has at least MIN_KEYS-1 fully dense and up to two non-dense.
     */
    private static &lt;C, I extends C, O extends C&gt; Object[] buildMaximallyDense(BulkIterator&lt;I&gt; source,
                                                                              int childCount,
                                                                              int size,
                                                                              int height,
                                                                              UpdateFunction&lt;I, O&gt; updateF)
    {
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">        assert childCount &lt;= MAX_KEYS + 1;</span>

<span class="fc" id="L211">        int keyCount = childCount - 1;</span>
<span class="fc" id="L212">        int[] sizeMap = new int[childCount];</span>
<span class="fc" id="L213">        Object[] branch = new Object[childCount * 2];</span>

<span class="pc bpc" id="L215" title="1 of 2 branches missed.">        if (height == 2)</span>
        {
            // we use the _exact same logic_ as below, only we invoke buildLeaf
<span class="fc" id="L218">            int remaining = size;</span>
<span class="fc" id="L219">            int threshold = MAX_KEYS + 1 + MIN_KEYS;</span>
<span class="fc" id="L220">            int i = 0;</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">            while (remaining &gt;= threshold)</span>
            {
<span class="fc" id="L223">                branch[keyCount + i] = buildLeaf(source, MAX_KEYS, updateF);</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">                branch[i] = isSimple(updateF) ? source.next() : updateF.insert(source.next());</span>
<span class="fc" id="L225">                remaining -= MAX_KEYS + 1;</span>
<span class="fc" id="L226">                sizeMap[i++] = size - remaining - 1;</span>
            }
<span class="fc bfc" id="L228" title="All 2 branches covered.">            if (remaining &gt; MAX_KEYS)</span>
            {
<span class="fc" id="L230">                int childSize = remaining / 2;</span>
<span class="fc" id="L231">                branch[keyCount + i] = buildLeaf(source, childSize, updateF);</span>
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">                branch[i] = isSimple(updateF) ? source.next() : updateF.insert(source.next());</span>
<span class="fc" id="L233">                remaining -= childSize + 1;</span>
<span class="fc" id="L234">                sizeMap[i++] = size - remaining - 1;</span>
            }
<span class="fc" id="L236">            branch[keyCount + i] = buildLeaf(source, remaining, updateF);</span>
<span class="fc" id="L237">            sizeMap[i++] = size;</span>
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">            assert i == childCount;</span>
<span class="fc" id="L239">        }</span>
        else
        {
<span class="nc" id="L242">            --height;</span>
<span class="nc" id="L243">            int denseChildSize = denseSize(height);</span>
<span class="nc" id="L244">            int denseGrandChildSize = denseSize(height - 1);</span>
            // The threshold is the point after which we can't add a dense child and still add another child with
            // at least MIN_KEYS fully dense children plus at least one more key.
<span class="nc" id="L247">            int threshold = denseChildSize + 1 + MIN_KEYS * (denseGrandChildSize + 1);</span>
<span class="nc" id="L248">            int remaining = size;</span>
<span class="nc" id="L249">            int i = 0;</span>
            // Add dense children until we reach the threshold.
<span class="nc bnc" id="L251" title="All 2 branches missed.">            while (remaining &gt;= threshold)</span>
            {
<span class="nc" id="L253">                branch[keyCount + i] = buildPerfectDense(source, height, updateF);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">                branch[i] = isSimple(updateF) ? source.next() : updateF.insert(source.next());</span>
<span class="nc" id="L255">                remaining -= denseChildSize + 1;</span>
<span class="nc" id="L256">                sizeMap[i++] = size - remaining - 1;</span>
            }
            // At this point the remainder either fits in one child, or too much for one but too little for one
            // perfectly dense and a second child with enough grandchildren to be valid. In the latter case, the
            // remainder should be split roughly in half, where the first child only has dense grandchildren.
<span class="nc bnc" id="L261" title="All 2 branches missed.">            if (remaining &gt; denseChildSize)</span>
            {
<span class="nc" id="L263">                int grandChildCount = remaining / ((denseGrandChildSize + 1) * 2);</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">                assert grandChildCount &gt;= MIN_KEYS + 1;</span>
<span class="nc" id="L265">                int childSize = grandChildCount * (denseGrandChildSize + 1) - 1;</span>
<span class="nc" id="L266">                branch[keyCount + i] = buildMaximallyDense(source, grandChildCount, childSize, height, updateF);</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">                branch[i] = isSimple(updateF) ? source.next() : updateF.insert(source.next());</span>
<span class="nc" id="L268">                remaining -= childSize + 1;</span>
<span class="nc" id="L269">                sizeMap[i++] = size - remaining - 1;</span>
            }
            // Put the remainder in the last child, it is now guaranteed to fit and have the required minimum of children.
<span class="nc" id="L272">            int grandChildCount = remaining / (denseGrandChildSize + 1) + 1;</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">            assert grandChildCount &gt;= MIN_KEYS + 1;</span>
<span class="nc" id="L274">            int childSize = remaining;</span>
<span class="nc" id="L275">            branch[keyCount + i] = buildMaximallyDense(source, grandChildCount, childSize, height, updateF);</span>
<span class="nc" id="L276">            sizeMap[i++] = size;</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">            assert i == childCount;</span>
        }

<span class="fc" id="L280">        branch[2 * keyCount + 1] = sizeMap;</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">        if (!isSimple(updateF))</span>
<span class="nc" id="L282">            updateF.onAllocatedOnHeap(ObjectSizes.sizeOfArray(branch) + ObjectSizes.sizeOfArray(sizeMap));</span>

<span class="fc" id="L284">        return branch;</span>
    }

    private static &lt;C, I extends C, O extends C&gt; Object[] buildPerfectDense(BulkIterator&lt;I&gt; source, int height, UpdateFunction&lt;I, O&gt; updateF)
    {
<span class="nc" id="L289">        Object[] result = buildPerfectDenseWithoutSizeTracking(source, height, updateF);</span>
<span class="nc" id="L290">        updateF.onAllocatedOnHeap(PERFECT_DENSE_SIZE_ON_HEAP[height]);</span>
<span class="nc" id="L291">        return result;</span>
    }

    /**
     * Build a tree of size precisely {@code branchFactor^height - 1}
     */
    private static &lt;C, I extends C, O extends C&gt; Object[] buildPerfectDenseWithoutSizeTracking(BulkIterator&lt;I&gt; source, int height, UpdateFunction&lt;I, O&gt; updateF)
    {
<span class="nc" id="L299">        int keyCount = (1 &lt;&lt; BRANCH_SHIFT) - 1;</span>
<span class="nc" id="L300">        Object[] node = new Object[(1 &lt;&lt; BRANCH_SHIFT) * 2];</span>

<span class="nc bnc" id="L302" title="All 2 branches missed.">        if (height == 2)</span>
        {
<span class="nc" id="L304">            int childSize = treeSize2n(1, BRANCH_SHIFT);</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">            for (int i = 0; i &lt; keyCount; i++)</span>
            {
<span class="nc" id="L307">                node[keyCount + i] = buildLeafWithoutSizeTracking(source, childSize, updateF);</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">                node[i] = isSimple(updateF) ? source.next() : updateF.insert(source.next());</span>
            }
<span class="nc" id="L310">            node[2 * keyCount] = buildLeafWithoutSizeTracking(source, childSize, updateF);</span>
<span class="nc" id="L311">        }</span>
        else
        {
<span class="nc bnc" id="L314" title="All 2 branches missed.">            for (int i = 0; i &lt; keyCount; i++)</span>
            {
<span class="nc" id="L316">                Object[] child = buildPerfectDenseWithoutSizeTracking(source, height - 1, updateF);</span>
<span class="nc" id="L317">                node[keyCount + i] = child;</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">                node[i] = isSimple(updateF) ? source.next() : updateF.insert(source.next());</span>
            }
<span class="nc" id="L320">            node[2 * keyCount] = buildPerfectDenseWithoutSizeTracking(source, height - 1, updateF);</span>
        }
<span class="nc" id="L322">        node[keyCount * 2 + 1] = DENSE_SIZE_MAPS[height - 2];</span>

<span class="nc" id="L324">        return node;</span>
    }

    public static &lt;Compare&gt; Object[] update(Object[] toUpdate, Object[] insert, Comparator&lt;? super Compare&gt; comparator)
    {
<span class="fc" id="L329">        return BTree.&lt;Compare, Compare, Compare&gt;update(toUpdate, insert, comparator, UpdateFunction.noOp());</span>
    }

    /**
     * Inserts {@code insert} into {@code update}, applying {@code updateF} to each new item in {@code insert},
     * as well as any matched items in {@code update}.
     * &lt;p&gt;
     * Note that {@code UpdateFunction.noOp} is assumed to indicate a lack of interest in which value survives.
     */
    public static &lt;Compare, Existing extends Compare, Insert extends Compare&gt; Object[] update(Object[] toUpdate,
                                                                                              Object[] insert,
                                                                                              Comparator&lt;? super Compare&gt; comparator,
                                                                                              UpdateFunction&lt;Insert, Existing&gt; updateF)
    {
        // perform some initial obvious optimisations
<span class="fc bfc" id="L344" title="All 2 branches covered.">        if (isEmpty(insert))</span>
<span class="fc" id="L345">            return toUpdate; // do nothing if update is empty</span>


<span class="fc bfc" id="L348" title="All 2 branches covered.">        if (isEmpty(toUpdate))</span>
        {
<span class="fc bfc" id="L350" title="All 2 branches covered.">            if (isSimple(updateF))</span>
<span class="fc" id="L351">                return insert; // if update is empty and updateF is trivial, return our new input</span>

            // if update is empty and updateF is non-trivial, perform a simple fast transformation of the input tree
<span class="fc" id="L354">            insert = BTree.transform(insert, updateF::insert);</span>
<span class="fc" id="L355">            updateF.onAllocatedOnHeap(sizeOnHeapOf(insert));</span>
<span class="fc" id="L356">            return insert;</span>
        }

<span class="pc bpc" id="L359" title="1 of 4 branches missed.">        if (isLeaf(toUpdate) &amp;&amp; isLeaf(insert))</span>
        {
            // if both are leaves, perform a tight-loop leaf variant of update
            // possibly flipping the input order if sizes suggest and updateF permits
<span class="fc bfc" id="L363" title="All 4 branches covered.">            if (updateF == (UpdateFunction) UpdateFunction.noOp &amp;&amp; toUpdate.length &lt; insert.length)</span>
            {
<span class="fc" id="L365">                Object[] tmp = toUpdate;</span>
<span class="fc" id="L366">                toUpdate = insert;</span>
<span class="fc" id="L367">                insert = tmp;</span>
            }
<span class="fc" id="L369">            Object[] merged = updateLeaves(toUpdate, insert, comparator, updateF);</span>
<span class="fc" id="L370">            updateF.onAllocatedOnHeap(sizeOnHeapOf(merged) - sizeOnHeapOf(toUpdate));</span>
<span class="fc" id="L371">            return merged;</span>
        }

<span class="pc bpc" id="L374" title="1 of 4 branches missed.">        if (!isLeaf(insert) &amp;&amp; isSimple(updateF))</span>
        {
            // consider flipping the order of application, if update is much larger than insert and applying unary no-op
<span class="nc" id="L377">            int updateSize = size(toUpdate);</span>
<span class="nc" id="L378">            int insertSize = size(insert);</span>
<span class="nc" id="L379">            int scale = Integer.numberOfLeadingZeros(updateSize) - Integer.numberOfLeadingZeros(insertSize);</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">            if (scale &gt;= 4)</span>
            {
                // i.e. at roughly 16x the size, or one tier deeper - very arbitrary, should pick more carefully
                // experimentally, at least at 64x the size the difference in performance is ~10x
<span class="nc" id="L384">                Object[] tmp = insert;</span>
<span class="nc" id="L385">                insert = toUpdate;</span>
<span class="nc" id="L386">                toUpdate = tmp;</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">                if (updateF != (UpdateFunction) UpdateFunction.noOp)</span>
<span class="nc" id="L388">                    updateF = ((UpdateFunction.Simple) updateF).flip();</span>
            }
        }

<span class="fc" id="L392">        try (Updater&lt;Compare, Existing, Insert&gt; updater = Updater.get())</span>
        {
<span class="fc" id="L394">            return updater.update(toUpdate, insert, comparator, updateF);</span>
        }
    }

    /**
     * A fast tight-loop variant of updating one btree with another, when both are leaves.
     */
    public static &lt;Compare, Existing extends Compare, Insert extends Compare&gt; Object[] updateLeaves(Object[] unode,
                                                                                                    Object[] inode,
                                                                                                    Comparator&lt;? super Compare&gt; comparator,
                                                                                                    UpdateFunction&lt;Insert, Existing&gt; updateF)
    {
<span class="fc" id="L406">        int upos = -1, usz = sizeOfLeaf(unode);</span>
<span class="fc" id="L407">        Existing uk = (Existing) unode[0];</span>
<span class="fc" id="L408">        int ipos = 0, isz = sizeOfLeaf(inode);</span>
<span class="fc" id="L409">        Insert ik = (Insert) inode[0];</span>

<span class="fc" id="L411">        Existing merged = null;</span>
<span class="fc" id="L412">        int c = -1;</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">        while (c &lt;= 0) // optimistic: find the first point in the original leaf that is modified (if any)</span>
        {
<span class="fc bfc" id="L415" title="All 2 branches covered.">            if (c &lt; 0)</span>
            {
<span class="fc" id="L417">                upos = exponentialSearch(comparator, unode, upos + 1, usz, ik);</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">                c = upos &lt; 0 ? 1 : 0; // positive or zero</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">                if (upos &lt; 0)</span>
<span class="fc" id="L420">                    upos = -(1 + upos);</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">                if (upos == usz)</span>
<span class="fc" id="L422">                    break;</span>
<span class="fc" id="L423">                uk = (Existing) unode[upos];</span>
            }
            else // c == 0
            {
<span class="fc" id="L427">                merged = updateF.merge(uk, ik);</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">                if (merged != uk)</span>
<span class="fc" id="L429">                    break;</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">                if (++ipos == isz)</span>
<span class="fc" id="L431">                    return unode;</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">                if (++upos == usz)</span>
<span class="fc" id="L433">                    break;</span>
<span class="fc" id="L434">                c = comparator.compare(uk = (Existing) unode[upos], ik = (Insert) inode[ipos]);</span>
            }
        }

        // exit conditions: c == 0 &amp;&amp; merged != uk
        //              or: c &gt;  0
        //              or: upos == usz

<span class="fc" id="L442">        try (FastBuilder&lt;Existing&gt; builder = fastBuilder())</span>
        {
<span class="fc bfc" id="L444" title="All 2 branches covered.">            if (upos &gt; 0)</span>
            {
                // copy any initial section that is unmodified
<span class="fc" id="L447">                builder.leaf().copy(unode, 0, upos);</span>
            }

            // handle prior loop's exit condition
            // we always have either an ik, or an ik merged with uk, to handle
<span class="fc bfc" id="L452" title="All 2 branches covered.">            if (upos &lt; usz)</span>
            {
<span class="fc bfc" id="L454" title="All 2 branches covered.">                if (c == 0)</span>
                {
<span class="fc" id="L456">                    builder.add(merged);</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">                    if (++upos &lt; usz)</span>
<span class="fc" id="L458">                        uk = (Existing) unode[upos];</span>
                }
                else // c &gt; 0
                {
<span class="fc" id="L462">                    builder.add(updateF.insert(ik));</span>
                }
<span class="fc bfc" id="L464" title="All 2 branches covered.">                if (++ipos &lt; isz)</span>
<span class="fc" id="L465">                    ik = (Insert) inode[ipos];</span>

<span class="fc bfc" id="L467" title="All 4 branches covered.">                if (upos &lt; usz &amp;&amp; ipos &lt; isz)</span>
                {
                    // note: this code is _identical_ to equivalent section in FastUpdater
<span class="fc" id="L470">                    c = comparator.compare(uk, ik);</span>
                    while (true)
                    {
<span class="fc bfc" id="L473" title="All 2 branches covered.">                        if (c == 0)</span>
                        {
<span class="fc" id="L475">                            builder.leaf().addKey(updateF.merge(uk, ik));</span>
<span class="fc" id="L476">                            ++upos;</span>
<span class="fc" id="L477">                            ++ipos;</span>
<span class="fc bfc" id="L478" title="All 4 branches covered.">                            if (upos == usz || ipos == isz)</span>
<span class="fc" id="L479">                                break;</span>
<span class="fc" id="L480">                            c = comparator.compare(uk = (Existing) unode[upos], ik = (Insert) inode[ipos]);</span>
                        }
<span class="fc bfc" id="L482" title="All 2 branches covered.">                        else if (c &lt; 0)</span>
                        {
<span class="fc" id="L484">                            int until = exponentialSearch(comparator, unode, upos + 1, usz, ik);</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">                            c = until &lt; 0 ? 1 : 0; // must find greater or equal; set &gt;= 0 (equal) to 0; set &lt; 0 (greater) to c=+ve</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">                            if (until &lt; 0)</span>
<span class="fc" id="L487">                                until = -(1 + until);</span>
<span class="fc" id="L488">                            builder.leaf().copy(unode, upos, until - upos);</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">                            if ((upos = until) == usz)</span>
<span class="fc" id="L490">                                break;</span>
<span class="fc" id="L491">                            uk = (Existing) unode[upos];</span>
<span class="fc" id="L492">                        }</span>
                        else
                        {
<span class="fc" id="L495">                            int until = exponentialSearch(comparator, inode, ipos + 1, isz, uk);</span>
<span class="fc" id="L496">                            c = until &amp; 0x80000000; // must find less or equal; set &gt;= 0 (equal) to 0, otherwise leave intact</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">                            if (until &lt; 0)</span>
<span class="fc" id="L498">                                until = -(1 + until);</span>
<span class="fc" id="L499">                            builder.leaf().copy(inode, ipos, until - ipos, updateF);</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">                            if ((ipos = until) == isz)</span>
<span class="fc" id="L501">                                break;</span>
<span class="fc" id="L502">                            ik = (Insert) inode[ipos];</span>
<span class="fc" id="L503">                        }</span>
                    }
                }
<span class="fc bfc" id="L506" title="All 2 branches covered.">                if (upos &lt; usz)</span>
                {
                    // ipos == isz
<span class="fc" id="L509">                    builder.leaf().copy(unode, upos, usz - upos);</span>
                }
            }
<span class="fc bfc" id="L512" title="All 2 branches covered.">            if (ipos &lt; isz)</span>
            {
                // upos == usz
<span class="fc" id="L515">                builder.leaf().copy(inode, ipos, isz - ipos, updateF);</span>
            }
<span class="fc" id="L517">            return builder.build();</span>
        }
    }

    public static void reverseInSitu(Object[] tree)
    {
<span class="nc" id="L523">        reverseInSitu(tree, height(tree), true);</span>
<span class="nc" id="L524">    }</span>

    /**
     * The internal implementation of {@link #reverseInSitu(Object[])}.
     * Takes two arguments that help minimise garbage generation, by testing sizeMaps against
     * known globallyl shared sizeMap for dense nodes that do not need to be modified, and
     * for permitting certain users (namely FastBuilder) to declare that non-matching sizeMap
     * can be mutated directly without allocating {@code new int[]}
     *
     * @param tree         the tree to reverse in situ
     * @param height       the height of the tree
     * @param copySizeMaps whether or not to copy any non-globally-shared sizeMap before reversing them
     */
    private static void reverseInSitu(Object[] tree, int height, boolean copySizeMaps)
    {
<span class="nc bnc" id="L539" title="All 2 branches missed.">        if (isLeaf(tree))</span>
        {
<span class="nc" id="L541">            reverse(tree, 0, sizeOfLeaf(tree));</span>
        }
        else
        {
<span class="nc" id="L545">            int keyCount = shallowSizeOfBranch(tree);</span>
<span class="nc" id="L546">            reverse(tree, 0, keyCount);</span>
<span class="nc" id="L547">            reverse(tree, keyCount, keyCount * 2 + 1);</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">            for (int i = keyCount; i &lt;= keyCount * 2; ++i)</span>
<span class="nc" id="L549">                reverseInSitu((Object[]) tree[i], height - 1, copySizeMaps);</span>

<span class="nc" id="L551">            int[] sizeMap = (int[]) tree[2 * keyCount + 1];</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">            if (sizeMap != DENSE_SIZE_MAPS[height - 2]) // no need to reverse a dense map; same in both directions</span>
            {
<span class="nc bnc" id="L554" title="All 2 branches missed.">                if (copySizeMaps)</span>
<span class="nc" id="L555">                    sizeMap = sizeMap.clone();</span>
<span class="nc" id="L556">                sizeMapToSizes(sizeMap);</span>
<span class="nc" id="L557">                reverse(sizeMap, 0, sizeMap.length);</span>
<span class="nc" id="L558">                sizesToSizeMap(sizeMap);</span>
            }
        }
<span class="nc" id="L561">    }</span>

    public static &lt;V&gt; Iterator&lt;V&gt; iterator(Object[] btree)
    {
<span class="fc" id="L565">        return iterator(btree, Dir.ASC);</span>
    }

    public static &lt;V&gt; Iterator&lt;V&gt; iterator(Object[] btree, Dir dir)
    {
<span class="fc bfc" id="L570" title="All 2 branches covered.">        return isLeaf(btree) ? new LeafBTreeSearchIterator&lt;&gt;(btree, null, dir)</span>
<span class="fc" id="L571">                             : new FullBTreeSearchIterator&lt;&gt;(btree, null, dir);</span>
    }

    public static &lt;V&gt; Iterator&lt;V&gt; iterator(Object[] btree, int lb, int ub, Dir dir)
    {
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">        return isLeaf(btree) ? new LeafBTreeSearchIterator&lt;&gt;(btree, null, dir, lb, ub)</span>
<span class="nc" id="L577">                             : new FullBTreeSearchIterator&lt;&gt;(btree, null, dir, lb, ub);</span>
    }

    public static &lt;V&gt; Iterable&lt;V&gt; iterable(Object[] btree)
    {
<span class="nc" id="L582">        return iterable(btree, Dir.ASC);</span>
    }

    public static &lt;V&gt; Iterable&lt;V&gt; iterable(Object[] btree, Dir dir)
    {
<span class="nc" id="L587">        return () -&gt; iterator(btree, dir);</span>
    }

    public static &lt;V&gt; Iterable&lt;V&gt; iterable(Object[] btree, int lb, int ub, Dir dir)
    {
<span class="nc" id="L592">        return () -&gt; iterator(btree, lb, ub, dir);</span>
    }

    /**
     * Returns an Iterator over the entire tree
     *
     * @param btree the tree to iterate over
     * @param dir   direction of iteration
     * @param &lt;V&gt;
     * @return
     */
    public static &lt;K, V&gt; BTreeSearchIterator&lt;K, V&gt; slice(Object[] btree, Comparator&lt;? super K&gt; comparator, Dir dir)
    {
<span class="fc bfc" id="L605" title="All 2 branches covered.">        return isLeaf(btree) ? new LeafBTreeSearchIterator&lt;&gt;(btree, comparator, dir)</span>
<span class="fc" id="L606">                             : new FullBTreeSearchIterator&lt;&gt;(btree, comparator, dir);</span>
    }

    /**
     * @param btree      the tree to iterate over
     * @param comparator the comparator that defines the ordering over the items in the tree
     * @param start      the beginning of the range to return, inclusive (in ascending order)
     * @param end        the end of the range to return, exclusive (in ascending order)
     * @param dir        if false, the iterator will start at the last item and move backwards
     * @return an Iterator over the defined sub-range of the tree
     */
    public static &lt;K, V extends K&gt; BTreeSearchIterator&lt;K, V&gt; slice(Object[] btree, Comparator&lt;? super K&gt; comparator, K start, K end, Dir dir)
    {
<span class="nc" id="L619">        return slice(btree, comparator, start, true, end, false, dir);</span>
    }

    /**
     * @param btree      the tree to iterate over
     * @param comparator the comparator that defines the ordering over the items in the tree
     * @param startIndex the start index of the range to return, inclusive
     * @param endIndex   the end index of the range to return, inclusive
     * @param dir        if false, the iterator will start at the last item and move backwards
     * @return an Iterator over the defined sub-range of the tree
     */
    public static &lt;K, V extends K&gt; BTreeSearchIterator&lt;K, V&gt; slice(Object[] btree, Comparator&lt;? super K&gt; comparator, int startIndex, int endIndex, Dir dir)
    {
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">        return isLeaf(btree) ? new LeafBTreeSearchIterator&lt;&gt;(btree, comparator, dir, startIndex, endIndex)</span>
<span class="nc" id="L633">                             : new FullBTreeSearchIterator&lt;&gt;(btree, comparator, dir, startIndex, endIndex);</span>
    }

    /**
     * @param btree          the tree to iterate over
     * @param comparator     the comparator that defines the ordering over the items in the tree
     * @param start          low bound of the range
     * @param startInclusive inclusivity of lower bound
     * @param end            high bound of the range
     * @param endInclusive   inclusivity of higher bound
     * @param dir            direction of iteration
     * @return an Iterator over the defined sub-range of the tree
     */
    public static &lt;K, V extends K&gt; BTreeSearchIterator&lt;K, V&gt; slice(Object[] btree, Comparator&lt;? super K&gt; comparator, K start, boolean startInclusive, K end, boolean endInclusive, Dir dir)
    {
<span class="fc" id="L648">        int inclusiveLowerBound = max(0,</span>
<span class="fc bfc" id="L649" title="All 2 branches covered.">                                      start == null ? Integer.MIN_VALUE</span>
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">                                                    : startInclusive ? ceilIndex(btree, comparator, start)</span>
<span class="nc" id="L651">                                                                     : higherIndex(btree, comparator, start));</span>
<span class="fc" id="L652">        int inclusiveUpperBound = min(size(btree) - 1,</span>
<span class="fc bfc" id="L653" title="All 2 branches covered.">                                      end == null ? Integer.MAX_VALUE</span>
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">                                                  : endInclusive ? floorIndex(btree, comparator, end)</span>
<span class="nc" id="L655">                                                                 : lowerIndex(btree, comparator, end));</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">        return isLeaf(btree) ? new LeafBTreeSearchIterator&lt;&gt;(btree, comparator, dir, inclusiveLowerBound, inclusiveUpperBound)</span>
<span class="fc" id="L657">                             : new FullBTreeSearchIterator&lt;&gt;(btree, comparator, dir, inclusiveLowerBound, inclusiveUpperBound);</span>
    }

    /**
     * @return the item in the tree that sorts as equal to the search argument, or null if no such item
     */
    public static &lt;V&gt; V find(Object[] node, Comparator&lt;? super V&gt; comparator, V find)
    {
        while (true)
        {
<span class="fc" id="L667">            int keyEnd = getKeyEnd(node);</span>
<span class="fc" id="L668">            int i = Arrays.binarySearch((V[]) node, 0, keyEnd, find, comparator);</span>

<span class="fc bfc" id="L670" title="All 2 branches covered.">            if (i &gt;= 0)</span>
<span class="fc" id="L671">                return (V) node[i];</span>

<span class="pc bpc" id="L673" title="1 of 2 branches missed.">            if (isLeaf(node))</span>
<span class="fc" id="L674">                return null;</span>

<span class="nc" id="L676">            i = -1 - i;</span>
<span class="nc" id="L677">            node = (Object[]) node[keyEnd + i];</span>
<span class="nc" id="L678">        }</span>
    }

    /**
     * Modifies the provided btree directly. THIS SHOULD NOT BE USED WITHOUT EXTREME CARE as BTrees are meant to be immutable.
     * Finds and replaces the item provided by index in the tree.
     */
    public static &lt;V&gt; void replaceInSitu(Object[] tree, int index, V replace)
    {
        // WARNING: if semantics change, see also InternalCursor.seekTo, which mirrors this implementation
<span class="nc bnc" id="L688" title="All 6 branches missed.">        if ((index &lt; 0) | (index &gt;= size(tree)))</span>
<span class="nc" id="L689">            throw new IndexOutOfBoundsException(index + &quot; not in range [0..&quot; + size(tree) + &quot;)&quot;);</span>

<span class="nc bnc" id="L691" title="All 2 branches missed.">        while (!isLeaf(tree))</span>
        {
<span class="nc" id="L693">            final int[] sizeMap = getSizeMap(tree);</span>
<span class="nc" id="L694">            int boundary = Arrays.binarySearch(sizeMap, index);</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">            if (boundary &gt;= 0)</span>
            {
                // exact match, in this branch node
<span class="nc bnc" id="L698" title="All 2 branches missed.">                assert boundary &lt; sizeMap.length - 1;</span>
<span class="nc" id="L699">                tree[boundary] = replace;</span>
<span class="nc" id="L700">                return;</span>
            }

<span class="nc" id="L703">            boundary = -1 - boundary;</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">            if (boundary &gt; 0)</span>
            {
<span class="nc bnc" id="L706" title="All 2 branches missed.">                assert boundary &lt; sizeMap.length;</span>
<span class="nc" id="L707">                index -= (1 + sizeMap[boundary - 1]);</span>
            }
<span class="nc" id="L709">            tree = (Object[]) tree[getChildStart(tree) + boundary];</span>
<span class="nc" id="L710">        }</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">        assert index &lt; getLeafKeyEnd(tree);</span>
<span class="nc" id="L712">        tree[index] = replace;</span>
<span class="nc" id="L713">    }</span>

    /**
     * Modifies the provided btree directly. THIS SHOULD NOT BE USED WITHOUT EXTREME CARE as BTrees are meant to be immutable.
     * Finds and replaces the provided item in the tree. Both should sort as equal to each other (although this is not enforced)
     */
    public static &lt;V&gt; void replaceInSitu(Object[] node, Comparator&lt;? super V&gt; comparator, V find, V replace)
    {
        while (true)
        {
<span class="fc" id="L723">            int keyEnd = getKeyEnd(node);</span>
<span class="fc" id="L724">            int i = Arrays.binarySearch((V[]) node, 0, keyEnd, find, comparator);</span>

<span class="pc bpc" id="L726" title="1 of 2 branches missed.">            if (i &gt;= 0)</span>
            {
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">                assert find == node[i];</span>
<span class="fc" id="L729">                node[i] = replace;</span>
<span class="fc" id="L730">                return;</span>
            }

<span class="nc bnc" id="L733" title="All 2 branches missed.">            if (isLeaf(node))</span>
<span class="nc" id="L734">                throw new NoSuchElementException();</span>

<span class="nc" id="L736">            i = -1 - i;</span>
<span class="nc" id="L737">            node = (Object[]) node[keyEnd + i];</span>
<span class="nc" id="L738">        }</span>
    }

    /**
     * Honours result semantics of {@link Arrays#binarySearch}, as though it were performed on the tree flattened into an array
     *
     * @return index of item in tree, or &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt; if not present
     */
    public static &lt;V&gt; int findIndex(Object[] node, Comparator&lt;? super V&gt; comparator, V find)
    {
<span class="fc" id="L748">        int lb = 0;</span>
        while (true)
        {
<span class="fc" id="L751">            int keyEnd = getKeyEnd(node);</span>
<span class="fc" id="L752">            int i = Arrays.binarySearch((V[]) node, 0, keyEnd, find, comparator);</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">            boolean exact = i &gt;= 0;</span>

<span class="fc bfc" id="L755" title="All 2 branches covered.">            if (isLeaf(node))</span>
<span class="fc bfc" id="L756" title="All 2 branches covered.">                return exact ? lb + i : i - lb;</span>

<span class="pc bpc" id="L758" title="1 of 2 branches missed.">            if (!exact)</span>
<span class="fc" id="L759">                i = -1 - i;</span>

<span class="fc" id="L761">            int[] sizeMap = getSizeMap(node);</span>
<span class="pc bpc" id="L762" title="1 of 2 branches missed.">            if (exact)</span>
<span class="nc" id="L763">                return lb + sizeMap[i];</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">            else if (i &gt; 0)</span>
<span class="fc" id="L765">                lb += sizeMap[i - 1] + 1;</span>

<span class="fc" id="L767">            node = (Object[]) node[keyEnd + i];</span>
<span class="fc" id="L768">        }</span>
    }

    /**
     * @return the value at the index'th position in the tree, in tree order
     */
    public static &lt;V&gt; V findByIndex(Object[] tree, int index)
    {
        // WARNING: if semantics change, see also InternalCursor.seekTo, which mirrors this implementation
<span class="pc bpc" id="L777" title="3 of 6 branches missed.">        if ((index &lt; 0) | (index &gt;= size(tree)))</span>
<span class="nc" id="L778">            throw new IndexOutOfBoundsException(index + &quot; not in range [0..&quot; + size(tree) + &quot;)&quot;);</span>

<span class="fc" id="L780">        Object[] node = tree;</span>
        while (true)
        {
<span class="fc bfc" id="L783" title="All 2 branches covered.">            if (isLeaf(node))</span>
            {
<span class="fc" id="L785">                int keyEnd = getLeafKeyEnd(node);</span>
<span class="pc bpc" id="L786" title="1 of 2 branches missed.">                assert index &lt; keyEnd;</span>
<span class="fc" id="L787">                return (V) node[index];</span>
            }

<span class="fc" id="L790">            int[] sizeMap = getSizeMap(node);</span>
<span class="fc" id="L791">            int boundary = Arrays.binarySearch(sizeMap, index);</span>
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">            if (boundary &gt;= 0)</span>
            {
                // exact match, in this branch node
<span class="nc bnc" id="L795" title="All 2 branches missed.">                assert boundary &lt; sizeMap.length - 1;</span>
<span class="nc" id="L796">                return (V) node[boundary];</span>
            }

<span class="fc" id="L799">            boundary = -1 - boundary;</span>
<span class="pc bpc" id="L800" title="1 of 2 branches missed.">            if (boundary &gt; 0)</span>
            {
<span class="pc bpc" id="L802" title="1 of 2 branches missed.">                assert boundary &lt; sizeMap.length;</span>
<span class="fc" id="L803">                index -= (1 + sizeMap[boundary - 1]);</span>
            }
<span class="fc" id="L805">            node = (Object[]) node[getChildStart(node) + boundary];</span>
<span class="fc" id="L806">        }</span>
    }

    /* since we have access to binarySearch semantics within indexOf(), we can use this to implement
     * lower/upper/floor/higher very trivially
     *
     * this implementation is *not* optimal; it requires two logarithmic traversals, although the second is much cheaper
     * (having less height, and operating over only primitive arrays), and the clarity is compelling
     */

    public static &lt;V&gt; int lowerIndex(Object[] btree, Comparator&lt;? super V&gt; comparator, V find)
    {
<span class="nc" id="L818">        int i = findIndex(btree, comparator, find);</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">        if (i &lt; 0)</span>
<span class="nc" id="L820">            i = -1 - i;</span>
<span class="nc" id="L821">        return i - 1;</span>
    }

    public static &lt;V&gt; V lower(Object[] btree, Comparator&lt;? super V&gt; comparator, V find)
    {
<span class="nc" id="L826">        int i = lowerIndex(btree, comparator, find);</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">        return i &gt;= 0 ? findByIndex(btree, i) : null;</span>
    }

    public static &lt;V&gt; int floorIndex(Object[] btree, Comparator&lt;? super V&gt; comparator, V find)
    {
<span class="fc" id="L832">        int i = findIndex(btree, comparator, find);</span>
<span class="pc bpc" id="L833" title="1 of 2 branches missed.">        if (i &lt; 0)</span>
<span class="fc" id="L834">            i = -2 - i;</span>
<span class="fc" id="L835">        return i;</span>
    }

    public static &lt;V&gt; V floor(Object[] btree, Comparator&lt;? super V&gt; comparator, V find)
    {
<span class="nc" id="L840">        int i = floorIndex(btree, comparator, find);</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">        return i &gt;= 0 ? findByIndex(btree, i) : null;</span>
    }

    public static &lt;V&gt; int higherIndex(Object[] btree, Comparator&lt;? super V&gt; comparator, V find)
    {
<span class="fc" id="L846">        int i = findIndex(btree, comparator, find);</span>
<span class="pc bpc" id="L847" title="1 of 2 branches missed.">        if (i &lt; 0)</span>
<span class="nc" id="L848">            i = -1 - i;</span>
        else
<span class="fc" id="L850">            i++;</span>
<span class="fc" id="L851">        return i;</span>
    }

    public static &lt;V&gt; V higher(Object[] btree, Comparator&lt;? super V&gt; comparator, V find)
    {
<span class="nc" id="L856">        int i = higherIndex(btree, comparator, find);</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">        return i &lt; size(btree) ? findByIndex(btree, i) : null;</span>
    }

    public static &lt;V&gt; int ceilIndex(Object[] btree, Comparator&lt;? super V&gt; comparator, V find)
    {
<span class="fc" id="L862">        int i = findIndex(btree, comparator, find);</span>
<span class="pc bpc" id="L863" title="1 of 2 branches missed.">        if (i &lt; 0)</span>
<span class="fc" id="L864">            i = -1 - i;</span>
<span class="fc" id="L865">        return i;</span>
    }

    public static &lt;V&gt; V ceil(Object[] btree, Comparator&lt;? super V&gt; comparator, V find)
    {
<span class="nc" id="L870">        int i = ceilIndex(btree, comparator, find);</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">        return i &lt; size(btree) ? findByIndex(btree, i) : null;</span>
    }

    // UTILITY METHODS

    // get the upper bound we should search in for keys in the node
    static int getKeyEnd(Object[] node)
    {
<span class="fc bfc" id="L879" title="All 2 branches covered.">        if (isLeaf(node))</span>
<span class="fc" id="L880">            return getLeafKeyEnd(node);</span>
        else
<span class="fc" id="L882">            return getBranchKeyEnd(node);</span>
    }

    // get the last index that is non-null in the leaf node
    static int getLeafKeyEnd(Object[] node)
    {
<span class="fc" id="L888">        int len = node.length;</span>
<span class="fc bfc" id="L889" title="All 2 branches covered.">        return node[len - 1] == null ? len - 1 : len;</span>
    }

    // return the boundary position between keys/children for the branch node
    // == number of keys, as they are indexed from zero
    static int getBranchKeyEnd(Object[] branchNode)
    {
<span class="fc" id="L896">        return (branchNode.length / 2) - 1;</span>
    }

    /**
     * @return first index in a branch node containing child nodes
     */
    static int getChildStart(Object[] branchNode)
    {
<span class="fc" id="L904">        return getBranchKeyEnd(branchNode);</span>
    }

    /**
     * @return last index + 1 in a branch node containing child nodes
     */
    static int getChildEnd(Object[] branchNode)
    {
<span class="fc" id="L912">        return branchNode.length - 1;</span>
    }

    /**
     * @return number of children in a branch node
     */
    static int getChildCount(Object[] branchNode)
    {
<span class="nc" id="L920">        return branchNode.length / 2;</span>
    }

    /**
     * @return the size map for the branch node
     */
    static int[] getSizeMap(Object[] branchNode)
    {
<span class="fc" id="L928">        return (int[]) branchNode[getChildEnd(branchNode)];</span>
    }

    /**
     * @return the size map for the branch node
     */
    static int lookupSizeMap(Object[] branchNode, int index)
    {
<span class="fc" id="L936">        return getSizeMap(branchNode)[index];</span>
    }

    // get the size from the btree's index (fails if not present)
    public static int size(Object[] tree)
    {
<span class="fc bfc" id="L942" title="All 2 branches covered.">        if (isLeaf(tree))</span>
<span class="fc" id="L943">            return getLeafKeyEnd(tree);</span>
<span class="fc" id="L944">        int length = tree.length;</span>
        // length - 1 == getChildEnd == getPositionOfSizeMap
        // (length / 2) - 1 == getChildCount - 1 == position of full tree size
        // hard code this, as will be used often;
<span class="fc" id="L948">        return ((int[]) tree[length - 1])[(length / 2) - 1];</span>
    }

    public static long sizeOfStructureOnHeap(Object[] tree)
    {
<span class="fc bfc" id="L953" title="All 2 branches covered.">        if (tree == EMPTY_LEAF)</span>
<span class="fc" id="L954">            return 0;</span>

<span class="fc" id="L956">        long size = ObjectSizes.sizeOfArray(tree);</span>
<span class="pc bpc" id="L957" title="1 of 2 branches missed.">        if (isLeaf(tree))</span>
<span class="fc" id="L958">            return size;</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">        for (int i = getChildStart(tree); i &lt; getChildEnd(tree); i++)</span>
<span class="nc" id="L960">            size += sizeOfStructureOnHeap((Object[]) tree[i]);</span>
<span class="nc" id="L961">        return size;</span>
    }

    /**
     * Checks is the node is a leaf.
     *
     * @return {@code true} if the provided node is a leaf, {@code false} if it is a branch.
     */
    public static boolean isLeaf(Object[] node)
    {
        // Nodes are disambiguated by the length of the array that represents them: an even number is a branch, odd a leaf
<span class="fc bfc" id="L972" title="All 2 branches covered.">        return (node.length &amp; 1) == 1;</span>
    }

    public static boolean isEmpty(Object[] tree)
    {
<span class="fc bfc" id="L977" title="All 2 branches covered.">        return tree == EMPTY_LEAF;</span>
    }

    // get the upper bound we should search in for keys in the node
    static int shallowSize(Object[] node)
    {
<span class="nc bnc" id="L983" title="All 2 branches missed.">        if (isLeaf(node))</span>
<span class="nc" id="L984">            return sizeOfLeaf(node);</span>
        else
<span class="nc" id="L986">            return shallowSizeOfBranch(node);</span>
    }

    static int sizeOfLeaf(Object[] leaf)
    {
<span class="fc" id="L991">        int len = leaf.length;</span>
<span class="fc bfc" id="L992" title="All 2 branches covered.">        return leaf[len - 1] == null ? len - 1 : len;</span>
    }

    // return the boundary position between keys/children for the branch node
    // == number of keys, as they are indexed from zero
    static int shallowSizeOfBranch(Object[] branch)
    {
<span class="fc" id="L999">        return (branch.length / 2) - 1;</span>
    }

    /**
     * @return first index in a branch node containing child nodes
     */
    static int childOffset(Object[] branch)
    {
<span class="fc" id="L1007">        return shallowSizeOfBranch(branch);</span>
    }

    /**
     * @return last index + 1 in a branch node containing child nodes
     */
    static int childEndOffset(Object[] branch)
    {
<span class="fc" id="L1015">        return branch.length - 1;</span>
    }

    public static int depth(Object[] tree)
    {
<span class="fc" id="L1020">        int depth = 1;</span>
<span class="fc bfc" id="L1021" title="All 2 branches covered.">        while (!isLeaf(tree))</span>
        {
<span class="fc" id="L1023">            depth++;</span>
<span class="fc" id="L1024">            tree = (Object[]) tree[getKeyEnd(tree)];</span>
        }
<span class="fc" id="L1026">        return depth;</span>
    }

    /**
     * Fill the target array with the contents of the provided subtree, in ascending order, starting at targetOffset
     *
     * @param tree         source
     * @param target       array
     * @param targetOffset offset in target array
     * @return number of items copied (size of tree)
     */
    public static int toArray(Object[] tree, Object[] target, int targetOffset)
    {
<span class="fc" id="L1039">        return toArray(tree, 0, size(tree), target, targetOffset);</span>
    }

    public static int toArray(Object[] tree, int treeStart, int treeEnd, Object[] target, int targetOffset)
    {
<span class="pc bpc" id="L1044" title="1 of 2 branches missed.">        if (isLeaf(tree))</span>
        {
<span class="fc" id="L1046">            int count = treeEnd - treeStart;</span>
<span class="fc" id="L1047">            System.arraycopy(tree, treeStart, target, targetOffset, count);</span>
<span class="fc" id="L1048">            return count;</span>
        }

<span class="nc" id="L1051">        int newTargetOffset = targetOffset;</span>
<span class="nc" id="L1052">        int childCount = getChildCount(tree);</span>
<span class="nc" id="L1053">        int childOffset = getChildStart(tree);</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">        for (int i = 0; i &lt; childCount; i++)</span>
        {
<span class="nc" id="L1056">            int childStart = treeIndexOffsetOfChild(tree, i);</span>
<span class="nc" id="L1057">            int childEnd = treeIndexOfBranchKey(tree, i);</span>
<span class="nc bnc" id="L1058" title="All 4 branches missed.">            if (childStart &lt;= treeEnd &amp;&amp; childEnd &gt;= treeStart)</span>
            {
<span class="nc" id="L1060">                newTargetOffset += toArray((Object[]) tree[childOffset + i], max(0, treeStart - childStart), min(childEnd, treeEnd) - childStart,</span>
                                           target, newTargetOffset);
<span class="nc bnc" id="L1062" title="All 4 branches missed.">                if (treeStart &lt;= childEnd &amp;&amp; treeEnd &gt; childEnd) // this check will always fail for the non-existent key</span>
<span class="nc" id="L1063">                    target[newTargetOffset++] = tree[i];</span>
            }
        }
<span class="nc" id="L1066">        return newTargetOffset - targetOffset;</span>
    }

    /**
     * An efficient transformAndFilter implementation suitable for a tree consisting of a single leaf root
     * NOTE: codewise *identical* to {@link #transformAndFilterLeaf(Object[], BiFunction, Object)}
     */
    private static &lt;I, O&gt; Object[] transformAndFilterLeaf(Object[] leaf, Function&lt;? super I, ? extends O&gt; apply)
    {
<span class="fc" id="L1075">        int i = 0, sz = sizeOfLeaf(leaf);</span>
        I in;
        O out;
        do // optimistic loop, looking for first point transformation modifies the input (if any)
        {
<span class="fc" id="L1080">            in = (I) leaf[i];</span>
<span class="fc" id="L1081">            out = apply.apply(in);</span>
<span class="fc bfc" id="L1082" title="All 4 branches covered.">        } while (in == out &amp;&amp; ++i &lt; sz);</span>

        // in == out -&gt; i == sz
        // otherwise   in == leaf[i]
<span class="fc" id="L1086">        int identicalUntil = i;</span>

<span class="fc bfc" id="L1088" title="All 4 branches covered.">        if (out == null &amp;&amp; ++i &lt; sz)</span>
        {
            // optimistic loop, looking for first key {@code apply} modifies without removing it (if any)
            do
            {
<span class="fc" id="L1093">                in = (I) leaf[i];</span>
<span class="fc" id="L1094">                out = apply.apply(in);</span>
<span class="fc bfc" id="L1095" title="All 4 branches covered.">            } while (null == out &amp;&amp; ++i &lt; sz);</span>
        }
        // out == null -&gt; i == sz
        // otherwise      out == apply.apply(leaf[i])

<span class="fc bfc" id="L1100" title="All 2 branches covered.">        if (i == sz)</span>
        {
            // if we have reached the end of the input, we're either:
            //   1) returning input unmodified; or
            //   2) copying some (possibly empty) prefix of it

<span class="fc bfc" id="L1106" title="All 2 branches covered.">            if (identicalUntil == sz)</span>
<span class="fc" id="L1107">                return leaf;</span>

<span class="fc bfc" id="L1109" title="All 2 branches covered.">            if (identicalUntil == 0)</span>
<span class="fc" id="L1110">                return empty();</span>

<span class="fc" id="L1112">            Object[] copy = new Object[identicalUntil | 1];</span>
<span class="fc" id="L1113">            System.arraycopy(leaf, 0, copy, 0, identicalUntil);</span>
<span class="fc" id="L1114">            return copy;</span>
        }

<span class="fc" id="L1117">        try (FastBuilder&lt;O&gt; builder = fastBuilder())</span>
        {
            // otherwise copy the initial part that was unmodified, insert the non-null modified key, and continue
<span class="fc bfc" id="L1120" title="All 2 branches covered.">            if (identicalUntil &gt; 0)</span>
<span class="fc" id="L1121">                builder.leaf().copyNoOverflow(leaf, 0, identicalUntil);</span>
<span class="fc" id="L1122">            builder.leaf().addKeyNoOverflow(out);</span>

<span class="fc bfc" id="L1124" title="All 2 branches covered.">            while (++i &lt; sz)</span>
            {
<span class="fc" id="L1126">                in = (I) leaf[i];</span>
<span class="fc" id="L1127">                out = apply.apply(in);</span>
<span class="fc bfc" id="L1128" title="All 2 branches covered.">                if (out != null)</span>
<span class="fc" id="L1129">                    builder.leaf().addKeyNoOverflow(out);</span>
            }

<span class="fc" id="L1132">            return builder.build();</span>
        }
    }

    /**
     * Takes a tree and transforms it using the provided function, filtering out any null results.
     * The result of any transformation must sort identically as their originals, wrt other results.
     * &lt;p&gt;
     * If no modifications are made, the original is returned.
     * NOTE: codewise *identical* to {@link #transformAndFilter(Object[], Function)}
     */
    public static &lt;I, I2, O&gt; Object[] transformAndFilter(Object[] tree, BiFunction&lt;? super I, ? super I2, ? extends O&gt; apply, I2 param)
    {
<span class="nc bnc" id="L1145" title="All 2 branches missed.">        if (isEmpty(tree))</span>
<span class="nc" id="L1146">            return tree;</span>

<span class="nc bnc" id="L1148" title="All 2 branches missed.">        if (isLeaf(tree))</span>
<span class="nc" id="L1149">            return transformAndFilterLeaf(tree, apply, param);</span>

<span class="nc" id="L1151">        try (BiTransformer&lt;I, I2, O&gt; transformer = BiTransformer.get(apply, param))</span>
        {
<span class="nc" id="L1153">            return transformer.apply(tree);</span>
        }
    }

    /**
     * Takes a tree and transforms it using the provided function, filtering out any null results.
     * The result of any transformation must sort identically as their originals, wrt other results.
     * &lt;p&gt;
     * If no modifications are made, the original is returned.
     * &lt;p&gt;
     * An efficient transformAndFilter implementation suitable for a tree consisting of a single leaf root
     * NOTE: codewise *identical* to {@link #transformAndFilter(Object[], BiFunction, Object)}
     */
    public static &lt;I, O&gt; Object[] transformAndFilter(Object[] tree, Function&lt;? super I, ? extends O&gt; apply)
    {
<span class="fc bfc" id="L1168" title="All 2 branches covered.">        if (isEmpty(tree))</span>
<span class="fc" id="L1169">            return tree;</span>

<span class="pc bpc" id="L1171" title="1 of 2 branches missed.">        if (isLeaf(tree))</span>
<span class="fc" id="L1172">            return transformAndFilterLeaf(tree, apply);</span>

<span class="nc" id="L1174">        try (Transformer&lt;I, O&gt; transformer = Transformer.get(apply))</span>
        {
<span class="nc" id="L1176">            return transformer.apply(tree);</span>
        }
    }

    /**
     * An efficient transformAndFilter implementation suitable for a tree consisting of a single leaf root
     * NOTE: codewise *identical* to {@link #transformAndFilterLeaf(Object[], Function)}
     */
    private static &lt;I, I2, O&gt; Object[] transformAndFilterLeaf(Object[] leaf, BiFunction&lt;? super I, ? super I2, ? extends O&gt; apply, I2 param)
    {
<span class="nc" id="L1186">        int i = 0, sz = sizeOfLeaf(leaf);</span>
        I in;
        O out;
        do // optimistic loop, looking for first point transformation modifies the input (if any)
        {
<span class="nc" id="L1191">            in = (I) leaf[i];</span>
<span class="nc" id="L1192">            out = apply.apply(in, param);</span>
<span class="nc bnc" id="L1193" title="All 4 branches missed.">        } while (in == out &amp;&amp; ++i &lt; sz);</span>

        // in == out -&gt; i == sz
        // otherwise   in == leaf[i]
<span class="nc" id="L1197">        int identicalUntil = i;</span>

<span class="nc bnc" id="L1199" title="All 4 branches missed.">        if (out == null &amp;&amp; ++i &lt; sz)</span>
        {
            // optimistic loop, looking for first key {@code apply} modifies without removing it (if any)
            do
            {
<span class="nc" id="L1204">                in = (I) leaf[i];</span>
<span class="nc" id="L1205">                out = apply.apply(in, param);</span>
<span class="nc bnc" id="L1206" title="All 4 branches missed.">            } while (null == out &amp;&amp; ++i &lt; sz);</span>
        }
        // out == null -&gt; i == sz
        // otherwise      out == apply.apply(leaf[i])

<span class="nc bnc" id="L1211" title="All 2 branches missed.">        if (i == sz)</span>
        {
            // if we have reached the end of the input, we're either:
            //   1) returning input unmodified; or
            //   2) copying some (possibly empty) prefix of it

<span class="nc bnc" id="L1217" title="All 2 branches missed.">            if (identicalUntil == sz)</span>
<span class="nc" id="L1218">                return leaf;</span>

<span class="nc bnc" id="L1220" title="All 2 branches missed.">            if (identicalUntil == 0)</span>
<span class="nc" id="L1221">                return empty();</span>

<span class="nc" id="L1223">            Object[] copy = new Object[identicalUntil | 1];</span>
<span class="nc" id="L1224">            System.arraycopy(leaf, 0, copy, 0, identicalUntil);</span>
<span class="nc" id="L1225">            return copy;</span>
        }

<span class="nc" id="L1228">        try (FastBuilder&lt;O&gt; builder = fastBuilder())</span>
        {
            // otherwise copy the initial part that was unmodified, insert the non-null modified key, and continue
<span class="nc bnc" id="L1231" title="All 2 branches missed.">            if (identicalUntil &gt; 0)</span>
<span class="nc" id="L1232">                builder.leaf().copyNoOverflow(leaf, 0, identicalUntil);</span>
<span class="nc" id="L1233">            builder.leaf().addKeyNoOverflow(out);</span>

<span class="nc bnc" id="L1235" title="All 2 branches missed.">            while (++i &lt; sz)</span>
            {
<span class="nc" id="L1237">                in = (I) leaf[i];</span>
<span class="nc" id="L1238">                out = apply.apply(in, param);</span>
<span class="nc bnc" id="L1239" title="All 2 branches missed.">                if (out != null)</span>
<span class="nc" id="L1240">                    builder.leaf().addKeyNoOverflow(out);</span>
            }

<span class="nc" id="L1243">            return builder.build();</span>
        }
    }

    /**
     * Takes a tree and transforms it using the provided function.
     * The result of any transformation must sort identically as their originals, wrt other results.
     * &lt;p&gt;
     * If no modifications are made, the original is returned.
     */
    public static &lt;I, O&gt; Object[] transform(Object[] tree, Function&lt;? super I, ? extends O&gt; function)
    {
<span class="fc bfc" id="L1255" title="All 2 branches covered.">        if (isEmpty(tree)) // isEmpty determined by identity; must return input</span>
<span class="fc" id="L1256">            return tree;</span>

<span class="fc bfc" id="L1258" title="All 2 branches covered.">        if (isLeaf(tree)) // escape hatch for fast leaf transformation</span>
<span class="fc" id="L1259">            return transformLeaf(tree, function);</span>

<span class="fc" id="L1261">        Object[] result = tree; // optimistically assume we'll return our input unmodified</span>
<span class="fc" id="L1262">        int keyCount = shallowSizeOfBranch(tree);</span>
<span class="fc bfc" id="L1263" title="All 2 branches covered.">        for (int i = 0; i &lt; keyCount; ++i)</span>
        {
            // operate on a pair of (child,key) each loop
<span class="fc" id="L1266">            Object[] curChild = (Object[]) tree[keyCount + i];</span>
<span class="fc" id="L1267">            Object[] updChild = transform(curChild, function);</span>
<span class="fc" id="L1268">            Object curKey = tree[i];</span>
<span class="fc" id="L1269">            Object updKey = function.apply((I) curKey);</span>
<span class="fc bfc" id="L1270" title="All 2 branches covered.">            if (result == tree)</span>
            {
<span class="pc bpc" id="L1272" title="3 of 4 branches missed.">                if (curChild == updChild &amp;&amp; curKey == updKey)</span>
<span class="nc" id="L1273">                    continue; // if output still same as input, loop</span>

                // otherwise initialise output to a copy of input up to this point
<span class="fc" id="L1276">                result = transformCopyBranchHelper(tree, keyCount, i, i);</span>
            }
<span class="fc" id="L1278">            result[keyCount + i] = updChild;</span>
<span class="fc" id="L1279">            result[i] = updKey;</span>
        }
        // final unrolled copy of loop for last child only (unbalanced with keys)
<span class="fc" id="L1282">        Object[] curChild = (Object[]) tree[2 * keyCount];</span>
<span class="fc" id="L1283">        Object[] updChild = transform(curChild, function);</span>
<span class="pc bpc" id="L1284" title="1 of 2 branches missed.">        if (result == tree)</span>
        {
<span class="nc bnc" id="L1286" title="All 2 branches missed.">            if (curChild == updChild)</span>
<span class="nc" id="L1287">                return tree;</span>
<span class="nc" id="L1288">            result = transformCopyBranchHelper(tree, keyCount, keyCount, keyCount);</span>
        }
<span class="fc" id="L1290">        result[2 * keyCount] = updChild;</span>
<span class="fc" id="L1291">        result[2 * keyCount + 1] = tree[2 * keyCount + 1]; // take the original sizeMap, as we are exactly the same shape</span>
<span class="fc" id="L1292">        return result;</span>
    }

    // create a copy of a branch, with the exact same size, copying the specified number of keys and children
    private static Object[] transformCopyBranchHelper(Object[] branch, int keyCount, int copyKeyCount, int copyChildCount)
    {
<span class="fc" id="L1298">        Object[] result = new Object[branch.length];</span>
<span class="fc" id="L1299">        System.arraycopy(branch, 0, result, 0, copyKeyCount);</span>
<span class="fc" id="L1300">        System.arraycopy(branch, keyCount, result, keyCount, copyChildCount);</span>
<span class="fc" id="L1301">        return result;</span>
    }

    // an efficient transformAndFilter implementation suitable for a tree consisting of a single leaf root
    private static &lt;I, O&gt; Object[] transformLeaf(Object[] leaf, Function&lt;? super I, ? extends O&gt; apply)
    {
<span class="fc" id="L1307">        Object[] result = leaf; // optimistically assume we'll return our input unmodified</span>
<span class="fc" id="L1308">        int size = sizeOfLeaf(leaf);</span>
<span class="fc bfc" id="L1309" title="All 2 branches covered.">        for (int i = 0; i &lt; size; ++i)</span>
        {
<span class="fc" id="L1311">            Object current = leaf[i];</span>
<span class="fc" id="L1312">            Object updated = apply.apply((I) current);</span>
<span class="fc bfc" id="L1313" title="All 2 branches covered.">            if (result == leaf)</span>
            {
<span class="fc bfc" id="L1315" title="All 2 branches covered.">                if (current == updated)</span>
<span class="fc" id="L1316">                    continue; // if output still same as input, loop</span>

                // otherwise initialise output to a copy of input up to this point
<span class="fc" id="L1319">                result = new Object[leaf.length];</span>
<span class="fc" id="L1320">                System.arraycopy(leaf, 0, result, 0, i);</span>
            }
<span class="fc" id="L1322">            result[i] = updated;</span>
        }
<span class="fc" id="L1324">        return result;</span>
    }

    public static boolean equals(Object[] a, Object[] b)
    {
<span class="fc bfc" id="L1329" title="All 4 branches covered.">        return size(a) == size(b) &amp;&amp; Iterators.elementsEqual(iterator(a), iterator(b));</span>
    }

    public static int hashCode(Object[] btree)
    {
        // we can't just delegate to Arrays.deepHashCode(),
        // because two equivalent trees may be represented by differently shaped trees
<span class="nc" id="L1336">        int result = 1;</span>
<span class="nc bnc" id="L1337" title="All 2 branches missed.">        for (Object v : iterable(btree))</span>
<span class="nc" id="L1338">            result = 31 * result + Objects.hashCode(v);</span>
<span class="nc" id="L1339">        return result;</span>
    }

    public static String toString(Object[] btree)
    {
<span class="nc" id="L1344">        return appendBranchOrLeaf(new StringBuilder().append('['), btree).append(']').toString();</span>
    }

    private static StringBuilder appendBranchOrLeaf(StringBuilder builder, Object[] node)
    {
<span class="nc bnc" id="L1349" title="All 2 branches missed.">        return isLeaf(node) ? appendLeaf(builder, node) : appendBranch(builder, node);</span>
    }

    private static StringBuilder appendBranch(StringBuilder builder, Object[] branch)
    {
<span class="nc" id="L1354">        int childCount = branch.length / 2;</span>
<span class="nc" id="L1355">        int keyCount = childCount - 1;</span>
        // add keys
<span class="nc bnc" id="L1357" title="All 2 branches missed.">        for (int i = 0; i &lt; keyCount; i++)</span>
        {
<span class="nc bnc" id="L1359" title="All 2 branches missed.">            if (i != 0)</span>
<span class="nc" id="L1360">                builder.append(&quot;, &quot;);</span>
<span class="nc" id="L1361">            builder.append(branch[i]);</span>
        }
        // add children
<span class="nc bnc" id="L1364" title="All 2 branches missed.">        for (int i = keyCount, m = branch.length - 1; i &lt; m; i++)</span>
        {
<span class="nc" id="L1366">            builder.append(&quot;, &quot;);</span>
<span class="nc" id="L1367">            appendBranchOrLeaf(builder, (Object[]) branch[i]);</span>
        }
        // add sizeMap
<span class="nc" id="L1370">        builder.append(&quot;, &quot;).append(Arrays.toString((int[]) branch[branch.length - 1]));</span>
<span class="nc" id="L1371">        return builder;</span>
    }

    private static StringBuilder appendLeaf(StringBuilder builder, Object[] leaf)
    {
<span class="nc" id="L1376">        return builder.append(Arrays.toString(leaf));</span>
    }

    /**
     * tree index =&gt; index of key wrt all items in the tree laid out serially
     * &lt;p&gt;
     * This version of the method permits requesting out-of-bounds indexes, -1 and size
     *
     * @param root     to calculate tree index within
     * @param keyIndex root-local index of key to calculate tree-index
     * @return the number of items preceding the key in the whole tree of root
     */
    public static int treeIndexOfKey(Object[] root, int keyIndex)
    {
<span class="pc bpc" id="L1390" title="1 of 2 branches missed.">        if (isLeaf(root))</span>
<span class="nc" id="L1391">            return keyIndex;</span>
<span class="fc" id="L1392">        int[] sizeMap = getSizeMap(root);</span>
<span class="pc bpc" id="L1393" title="3 of 6 branches missed.">        if ((keyIndex &gt;= 0) &amp; (keyIndex &lt; sizeMap.length))</span>
<span class="fc" id="L1394">            return sizeMap[keyIndex];</span>
        // we support asking for -1 or size, so that we can easily use this for iterator bounds checking
<span class="nc bnc" id="L1396" title="All 2 branches missed.">        if (keyIndex &lt; 0)</span>
<span class="nc" id="L1397">            return -1;</span>
<span class="nc" id="L1398">        return sizeMap[keyIndex - 1] + 1;</span>
    }

    /**
     * @param keyIndex node-local index of the key to calculate index of
     * @return keyIndex; this method is here only for symmetry and clarity
     */
    public static int treeIndexOfLeafKey(int keyIndex)
    {
<span class="fc" id="L1407">        return keyIndex;</span>
    }

    /**
     * @param root     to calculate tree-index within
     * @param keyIndex root-local index of key to calculate tree-index of
     * @return the number of items preceding the key in the whole tree of root
     */
    public static int treeIndexOfBranchKey(Object[] root, int keyIndex)
    {
<span class="nc" id="L1417">        return lookupSizeMap(root, keyIndex);</span>
    }

    /**
     * @param root       to calculate tree-index within
     * @param childIndex root-local index of *child* to calculate tree-index of
     * @return the number of items preceding the child in the whole tree of root
     */
    public static int treeIndexOffsetOfChild(Object[] root, int childIndex)
    {
<span class="fc bfc" id="L1427" title="All 2 branches covered.">        if (childIndex == 0)</span>
<span class="fc" id="L1428">            return 0;</span>
<span class="fc" id="L1429">        return 1 + lookupSizeMap(root, childIndex - 1);</span>
    }

    public static &lt;V&gt; Builder&lt;V&gt; builder(Comparator&lt;? super V&gt; comparator)
    {
<span class="fc" id="L1434">        return new Builder&lt;&gt;(comparator);</span>
    }

    public static &lt;V&gt; Builder&lt;V&gt; builder(Comparator&lt;? super V&gt; comparator, int initialCapacity)
    {
<span class="fc" id="L1439">        return new Builder&lt;&gt;(comparator, initialCapacity);</span>
    }

<span class="fc" id="L1442">    public static class Builder&lt;V&gt;</span>
    {
        // a user-defined bulk resolution, to be applied manually via resolve()
        public static interface Resolver
        {
            // can return a different output type to input, so long as sort order is maintained
            // if a resolver is present, this method will be called for every sequence of equal inputs
            // even those with only one item
            Object resolve(Object[] array, int lb, int ub);
        }

        // a user-defined resolver that is applied automatically on encountering two duplicate values
        public static interface QuickResolver&lt;V&gt;
        {
            // can return a different output type to input, so long as sort order is maintained
            // if a resolver is present, this method will be called for every sequence of equal inputs
            // even those with only one item
            V resolve(V a, V b);
        }

        Comparator&lt;? super V&gt; comparator;
        Object[] values;
        int count;
<span class="pc" id="L1465">        boolean detected = true; // true if we have managed to cheaply ensure sorted (+ filtered, if resolver == null) as we have added</span>
<span class="pc" id="L1466">        boolean auto = true; // false if the user has promised to enforce the sort order and resolve any duplicates</span>
        QuickResolver&lt;V&gt; quickResolver;

        protected Builder(Comparator&lt;? super V&gt; comparator)
        {
<span class="fc" id="L1471">            this(comparator, 16);</span>
<span class="fc" id="L1472">        }</span>

        protected Builder(Comparator&lt;? super V&gt; comparator, int initialCapacity)
<span class="fc" id="L1475">        {</span>
<span class="fc bfc" id="L1476" title="All 2 branches covered.">            if (initialCapacity == 0)</span>
<span class="fc" id="L1477">                initialCapacity = 16;</span>
<span class="fc" id="L1478">            this.comparator = comparator;</span>
<span class="fc" id="L1479">            this.values = new Object[initialCapacity];</span>
<span class="fc" id="L1480">        }</span>

        @VisibleForTesting
        public Builder()
<span class="nc" id="L1484">        {</span>
<span class="nc" id="L1485">            this.values = new Object[16];</span>
<span class="nc" id="L1486">        }</span>

        private Builder(Builder&lt;V&gt; builder)
<span class="fc" id="L1489">        {</span>
<span class="fc" id="L1490">            this.comparator = builder.comparator;</span>
<span class="fc" id="L1491">            this.values = Arrays.copyOf(builder.values, builder.values.length);</span>
<span class="fc" id="L1492">            this.count = builder.count;</span>
<span class="fc" id="L1493">            this.detected = builder.detected;</span>
<span class="fc" id="L1494">            this.auto = builder.auto;</span>
<span class="fc" id="L1495">            this.quickResolver = builder.quickResolver;</span>
<span class="fc" id="L1496">        }</span>

        /**
         * Creates a copy of this {@code Builder}.
         *
         * @return a copy of this {@code Builder}.
         */
        public Builder&lt;V&gt; copy()
        {
<span class="fc" id="L1505">            return new Builder&lt;&gt;(this);</span>
        }

        public Builder&lt;V&gt; setQuickResolver(QuickResolver&lt;V&gt; quickResolver)
        {
<span class="fc" id="L1510">            this.quickResolver = quickResolver;</span>
<span class="fc" id="L1511">            return this;</span>
        }

        public void reuse()
        {
<span class="fc" id="L1516">            reuse(comparator);</span>
<span class="fc" id="L1517">        }</span>

        public void reuse(Comparator&lt;? super V&gt; comparator)
        {
<span class="fc" id="L1521">            this.comparator = comparator;</span>
<span class="fc" id="L1522">            Arrays.fill(values, null);</span>
<span class="fc" id="L1523">            count = 0;</span>
<span class="fc" id="L1524">            detected = true;</span>
<span class="fc" id="L1525">        }</span>

        public Builder&lt;V&gt; auto(boolean auto)
        {
<span class="fc" id="L1529">            this.auto = auto;</span>
<span class="fc" id="L1530">            return this;</span>
        }

        public Builder&lt;V&gt; add(V v)
        {
<span class="fc bfc" id="L1535" title="All 2 branches covered.">            if (count == values.length)</span>
<span class="fc" id="L1536">                values = Arrays.copyOf(values, count * 2);</span>

<span class="fc" id="L1538">            Object[] values = this.values;</span>
<span class="fc" id="L1539">            int prevCount = this.count++;</span>
<span class="fc" id="L1540">            values[prevCount] = v;</span>

<span class="fc bfc" id="L1542" title="All 6 branches covered.">            if (auto &amp;&amp; detected &amp;&amp; prevCount &gt; 0)</span>
            {
<span class="fc" id="L1544">                V prev = (V) values[prevCount - 1];</span>
<span class="fc" id="L1545">                int c = comparator.compare(prev, v);</span>
<span class="pc bpc" id="L1546" title="1 of 4 branches missed.">                if (c == 0 &amp;&amp; auto)</span>
                {
<span class="fc" id="L1548">                    count = prevCount;</span>
<span class="fc bfc" id="L1549" title="All 2 branches covered.">                    if (quickResolver != null)</span>
<span class="fc" id="L1550">                        values[prevCount - 1] = quickResolver.resolve(prev, v);</span>
                }
<span class="fc bfc" id="L1552" title="All 2 branches covered.">                else if (c &gt; 0)</span>
                {
<span class="fc" id="L1554">                    detected = false;</span>
                }
            }

<span class="fc" id="L1558">            return this;</span>
        }

        public Builder&lt;V&gt; addAll(Collection&lt;V&gt; add)
        {
<span class="pc bpc" id="L1563" title="4 of 6 branches missed.">            if (auto &amp;&amp; add instanceof SortedSet &amp;&amp; equalComparators(comparator, ((SortedSet) add).comparator()))</span>
            {
                // if we're a SortedSet, permit quick order-preserving addition of items
                // if we collect all duplicates, don't bother as merge will necessarily be more expensive than sorting at end
<span class="nc" id="L1567">                return mergeAll(add, add.size());</span>
            }
<span class="fc" id="L1569">            detected = false;</span>
<span class="pc bpc" id="L1570" title="1 of 2 branches missed.">            if (values.length &lt; count + add.size())</span>
<span class="nc" id="L1571">                values = Arrays.copyOf(values, max(count + add.size(), count * 2));</span>
<span class="fc bfc" id="L1572" title="All 2 branches covered.">            for (V v : add)</span>
<span class="fc" id="L1573">                values[count++] = v;</span>
<span class="fc" id="L1574">            return this;</span>
        }

        private static boolean equalComparators(Comparator&lt;?&gt; a, Comparator&lt;?&gt; b)
        {
<span class="nc bnc" id="L1579" title="All 6 branches missed.">            return a == b || (isNaturalComparator(a) &amp;&amp; isNaturalComparator(b));</span>
        }

        private static boolean isNaturalComparator(Comparator&lt;?&gt; a)
        {
<span class="nc bnc" id="L1584" title="All 6 branches missed.">            return a == null || a == Comparator.naturalOrder() || a == Ordering.natural();</span>
        }

        // iter must be in sorted order!
        private Builder&lt;V&gt; mergeAll(Iterable&lt;V&gt; add, int addCount)
        {
<span class="nc bnc" id="L1590" title="All 2 branches missed.">            assert auto;</span>
            // ensure the existing contents are in order
<span class="nc" id="L1592">            autoEnforce();</span>

<span class="nc" id="L1594">            int curCount = count;</span>
            // we make room for curCount * 2 + addCount, so that we can copy the current values to the end
            // if necessary for continuing the merge, and have the new values directly after the current value range
<span class="nc bnc" id="L1597" title="All 2 branches missed.">            if (values.length &lt; curCount * 2 + addCount)</span>
<span class="nc" id="L1598">                values = Arrays.copyOf(values, max(curCount * 2 + addCount, curCount * 3));</span>

<span class="nc bnc" id="L1600" title="All 2 branches missed.">            if (add instanceof BTreeSet)</span>
            {
                // use btree set's fast toArray method, to append directly
<span class="nc" id="L1603">                ((BTreeSet) add).toArray(values, curCount);</span>
            }
            else
            {
                // consider calling toArray() and System.arraycopy
<span class="nc" id="L1608">                int i = curCount;</span>
<span class="nc bnc" id="L1609" title="All 2 branches missed.">                for (V v : add)</span>
<span class="nc" id="L1610">                    values[i++] = v;</span>
            }
<span class="nc" id="L1612">            return mergeAll(addCount);</span>
        }

        private Builder&lt;V&gt; mergeAll(int addCount)
        {
<span class="nc" id="L1617">            Object[] a = values;</span>
<span class="nc" id="L1618">            int addOffset = count;</span>

<span class="nc" id="L1620">            int i = 0, j = addOffset;</span>
<span class="nc" id="L1621">            int curEnd = addOffset, addEnd = addOffset + addCount;</span>

            // save time in cases where we already have a subset, by skipping dir
<span class="nc bnc" id="L1624" title="All 4 branches missed.">            while (i &lt; curEnd &amp;&amp; j &lt; addEnd)</span>
            {
<span class="nc" id="L1626">                V ai = (V) a[i], aj = (V) a[j];</span>
                // in some cases, such as Columns, we may have identity supersets, so perform a cheap object-identity check
<span class="nc bnc" id="L1628" title="All 2 branches missed.">                int c = ai == aj ? 0 : comparator.compare(ai, aj);</span>
<span class="nc bnc" id="L1629" title="All 2 branches missed.">                if (c &gt; 0)</span>
<span class="nc" id="L1630">                    break;</span>
<span class="nc bnc" id="L1631" title="All 2 branches missed.">                else if (c == 0)</span>
                {
<span class="nc bnc" id="L1633" title="All 2 branches missed.">                    if (quickResolver != null)</span>
<span class="nc" id="L1634">                        a[i] = quickResolver.resolve(ai, aj);</span>
<span class="nc" id="L1635">                    j++;</span>
                }
<span class="nc" id="L1637">                i++;</span>
<span class="nc" id="L1638">            }</span>

<span class="nc bnc" id="L1640" title="All 2 branches missed.">            if (j == addEnd)</span>
<span class="nc" id="L1641">                return this; // already a superset of the new values</span>

            // otherwise, copy the remaining existing values to the very end, freeing up space for merge result
<span class="nc" id="L1644">            int newCount = i;</span>
<span class="nc" id="L1645">            System.arraycopy(a, i, a, addEnd, count - i);</span>
<span class="nc" id="L1646">            curEnd = addEnd + (count - i);</span>
<span class="nc" id="L1647">            i = addEnd;</span>

<span class="nc bnc" id="L1649" title="All 4 branches missed.">            while (i &lt; curEnd &amp;&amp; j &lt; addEnd)</span>
            {
<span class="nc" id="L1651">                V ai = (V) a[i];</span>
<span class="nc" id="L1652">                V aj = (V) a[j];</span>
                // could avoid one comparison if we cared, but would make this ugly
<span class="nc" id="L1654">                int c = comparator.compare(ai, aj);</span>
<span class="nc bnc" id="L1655" title="All 2 branches missed.">                if (c == 0)</span>
                {
<span class="nc bnc" id="L1657" title="All 2 branches missed.">                    Object newValue = quickResolver == null ? ai : quickResolver.resolve(ai, aj);</span>
<span class="nc" id="L1658">                    a[newCount++] = newValue;</span>
<span class="nc" id="L1659">                    i++;</span>
<span class="nc" id="L1660">                    j++;</span>
<span class="nc" id="L1661">                }</span>
                else
                {
<span class="nc bnc" id="L1664" title="All 2 branches missed.">                    a[newCount++] = c &lt; 0 ? a[i++] : a[j++];</span>
                }
<span class="nc" id="L1666">            }</span>

            // exhausted one of the inputs; fill in remainder of the other
<span class="nc bnc" id="L1669" title="All 2 branches missed.">            if (i &lt; curEnd)</span>
            {
<span class="nc" id="L1671">                System.arraycopy(a, i, a, newCount, curEnd - i);</span>
<span class="nc" id="L1672">                newCount += curEnd - i;</span>
            }
<span class="nc bnc" id="L1674" title="All 2 branches missed.">            else if (j &lt; addEnd)</span>
            {
<span class="nc bnc" id="L1676" title="All 2 branches missed.">                if (j != newCount)</span>
<span class="nc" id="L1677">                    System.arraycopy(a, j, a, newCount, addEnd - j);</span>
<span class="nc" id="L1678">                newCount += addEnd - j;</span>
            }
<span class="nc" id="L1680">            count = newCount;</span>
<span class="nc" id="L1681">            return this;</span>
        }

        public boolean isEmpty()
        {
<span class="fc bfc" id="L1686" title="All 2 branches covered.">            return count == 0;</span>
        }

        public Builder&lt;V&gt; reverse()
        {
<span class="nc bnc" id="L1691" title="All 2 branches missed.">            assert !auto;</span>
<span class="nc" id="L1692">            int mid = count / 2;</span>
<span class="nc bnc" id="L1693" title="All 2 branches missed.">            for (int i = 0; i &lt; mid; i++)</span>
            {
<span class="nc" id="L1695">                Object t = values[i];</span>
<span class="nc" id="L1696">                values[i] = values[count - (1 + i)];</span>
<span class="nc" id="L1697">                values[count - (1 + i)] = t;</span>
            }
<span class="nc" id="L1699">            return this;</span>
        }

        public Builder&lt;V&gt; sort()
        {
<span class="fc" id="L1704">            Arrays.sort((V[]) values, 0, count, comparator);</span>
<span class="fc" id="L1705">            return this;</span>
        }

        // automatically enforce sorted+filtered
        private void autoEnforce()
        {
<span class="fc bfc" id="L1711" title="All 4 branches covered.">            if (!detected &amp;&amp; count &gt; 1)</span>
            {
<span class="fc" id="L1713">                sort();</span>
<span class="fc" id="L1714">                int prevIdx = 0;</span>
<span class="fc" id="L1715">                V prev = (V) values[0];</span>
<span class="fc bfc" id="L1716" title="All 2 branches covered.">                for (int i = 1; i &lt; count; i++)</span>
                {
<span class="fc" id="L1718">                    V next = (V) values[i];</span>
<span class="fc bfc" id="L1719" title="All 2 branches covered.">                    if (comparator.compare(prev, next) != 0)</span>
<span class="fc" id="L1720">                        values[++prevIdx] = prev = next;</span>
<span class="pc bpc" id="L1721" title="1 of 2 branches missed.">                    else if (quickResolver != null)</span>
<span class="nc" id="L1722">                        values[prevIdx] = prev = quickResolver.resolve(prev, next);</span>
                }
<span class="fc" id="L1724">                count = prevIdx + 1;</span>
            }
<span class="fc" id="L1726">            detected = true;</span>
<span class="fc" id="L1727">        }</span>

        public Builder&lt;V&gt; resolve(Resolver resolver)
        {
<span class="fc bfc" id="L1731" title="All 2 branches covered.">            if (count &gt; 0)</span>
            {
<span class="fc" id="L1733">                int c = 0;</span>
<span class="fc" id="L1734">                int prev = 0;</span>
<span class="fc bfc" id="L1735" title="All 2 branches covered.">                for (int i = 1; i &lt; count; i++)</span>
                {
<span class="fc bfc" id="L1737" title="All 2 branches covered.">                    if (comparator.compare((V) values[i], (V) values[prev]) != 0)</span>
                    {
<span class="fc" id="L1739">                        values[c++] = resolver.resolve((V[]) values, prev, i);</span>
<span class="fc" id="L1740">                        prev = i;</span>
                    }
                }
<span class="fc" id="L1743">                values[c++] = resolver.resolve((V[]) values, prev, count);</span>
<span class="fc" id="L1744">                count = c;</span>
            }
<span class="fc" id="L1746">            return this;</span>
        }

        public Object[] build()
        {
<span class="fc bfc" id="L1751" title="All 2 branches covered.">            if (auto)</span>
<span class="fc" id="L1752">                autoEnforce();</span>
<span class="fc" id="L1753">            try (BulkIterator&lt;V&gt; iterator = BulkIterator.of(values, 0))</span>
            {
<span class="fc" id="L1755">                return BTree.build(iterator, count, UpdateFunction.noOp());</span>
            }
        }
    }

    private static &lt;V, A&gt; void applyValue(V value, BiConsumer&lt;A, V&gt; function, A argument)
    {
<span class="fc" id="L1762">        function.accept(argument, value);</span>
<span class="fc" id="L1763">    }</span>

    public static &lt;V, A&gt; void applyLeaf(Object[] btree, BiConsumer&lt;A, V&gt; function, A argument)
    {
<span class="fc" id="L1767">        Preconditions.checkArgument(isLeaf(btree));</span>
<span class="fc" id="L1768">        int limit = getLeafKeyEnd(btree);</span>
<span class="fc bfc" id="L1769" title="All 2 branches covered.">        for (int i = 0; i &lt; limit; i++)</span>
<span class="fc" id="L1770">            applyValue((V) btree[i], function, argument);</span>
<span class="fc" id="L1771">    }</span>

    /**
     * Simple method to walk the btree forwards and apply a function till a stop condition is reached
     * &lt;p&gt;
     * Private method
     *
     * @param btree
     * @param function
     */
    public static &lt;V, A&gt; void apply(Object[] btree, BiConsumer&lt;A, V&gt; function, A argument)
    {
<span class="pc bpc" id="L1783" title="1 of 2 branches missed.">        if (isLeaf(btree))</span>
        {
<span class="fc" id="L1785">            applyLeaf(btree, function, argument);</span>
<span class="fc" id="L1786">            return;</span>
        }

<span class="nc" id="L1789">        int childOffset = getChildStart(btree);</span>
<span class="nc" id="L1790">        int limit = btree.length - 1 - childOffset;</span>
<span class="nc bnc" id="L1791" title="All 2 branches missed.">        for (int i = 0; i &lt; limit; i++)</span>
        {

<span class="nc" id="L1794">            apply((Object[]) btree[childOffset + i], function, argument);</span>

<span class="nc bnc" id="L1796" title="All 2 branches missed.">            if (i &lt; childOffset)</span>
<span class="nc" id="L1797">                applyValue((V) btree[i], function, argument);</span>
        }
<span class="nc" id="L1799">    }</span>

    /**
     * Simple method to walk the btree forwards and apply a function till a stop condition is reached
     * &lt;p&gt;
     * Private method
     *
     * @param btree
     * @param function
     */
    public static &lt;V&gt; void apply(Object[] btree, Consumer&lt;V&gt; function)
    {
<span class="fc" id="L1811">        BTree.&lt;V, Consumer&lt;V&gt;&gt;apply(btree, Consumer::accept, function);</span>
<span class="fc" id="L1812">    }</span>

    private static &lt;V&gt; int find(Object[] btree, V from, Comparator&lt;V&gt; comparator)
    {
        // find the start index in iteration order
<span class="fc" id="L1817">        Preconditions.checkNotNull(comparator);</span>
<span class="fc" id="L1818">        int keyEnd = getKeyEnd(btree);</span>
<span class="fc" id="L1819">        return Arrays.binarySearch((V[]) btree, 0, keyEnd, from, comparator);</span>
    }

    private static boolean isStopSentinel(long v)
    {
<span class="pc bpc" id="L1824" title="1 of 2 branches missed.">        return v == Long.MAX_VALUE;</span>
    }

    private static &lt;V, A&gt; long accumulateLeaf(Object[] btree, BiLongAccumulator&lt;A, V&gt; accumulator, A arg, Comparator&lt;V&gt; comparator, V from, long initialValue)
    {
<span class="fc" id="L1829">        Preconditions.checkArgument(isLeaf(btree));</span>
<span class="fc" id="L1830">        long value = initialValue;</span>
<span class="fc" id="L1831">        int limit = getLeafKeyEnd(btree);</span>

<span class="fc" id="L1833">        int startIdx = 0;</span>
<span class="fc bfc" id="L1834" title="All 2 branches covered.">        if (from != null)</span>
        {
<span class="fc" id="L1836">            int i = find(btree, from, comparator);</span>
<span class="pc bpc" id="L1837" title="1 of 2 branches missed.">            boolean isExact = i &gt;= 0;</span>
<span class="pc bpc" id="L1838" title="1 of 2 branches missed.">            startIdx = isExact ? i : (-1 - i);</span>
        }

<span class="fc bfc" id="L1841" title="All 2 branches covered.">        for (int i = startIdx; i &lt; limit; i++)</span>
        {
<span class="fc" id="L1843">            value = accumulator.apply(arg, (V) btree[i], value);</span>

<span class="pc bpc" id="L1845" title="1 of 2 branches missed.">            if (isStopSentinel(value))</span>
<span class="nc" id="L1846">                break;</span>
        }
<span class="fc" id="L1848">        return value;</span>
    }

    /**
     * Walk the btree and accumulate a long value using the supplied accumulator function. Iteration will stop if the
     * accumulator function returns the sentinel values Long.MIN_VALUE or Long.MAX_VALUE
     * &lt;p&gt;
     * If the optional from argument is not null, iteration will start from that value (or the one after it's insertion
     * point if an exact match isn't found)
     */
    public static &lt;V, A&gt; long accumulate(Object[] btree, BiLongAccumulator&lt;A, V&gt; accumulator, A arg, Comparator&lt;V&gt; comparator, V from, long initialValue)
    {
<span class="pc bpc" id="L1860" title="1 of 2 branches missed.">        if (isLeaf(btree))</span>
<span class="fc" id="L1861">            return accumulateLeaf(btree, accumulator, arg, comparator, from, initialValue);</span>

<span class="nc" id="L1863">        long value = initialValue;</span>
<span class="nc" id="L1864">        int childOffset = getChildStart(btree);</span>

<span class="nc" id="L1866">        int startChild = 0;</span>
<span class="nc bnc" id="L1867" title="All 2 branches missed.">        if (from != null)</span>
        {
<span class="nc" id="L1869">            int i = find(btree, from, comparator);</span>
<span class="nc bnc" id="L1870" title="All 2 branches missed.">            boolean isExact = i &gt;= 0;</span>

<span class="nc bnc" id="L1872" title="All 2 branches missed.">            startChild = isExact ? i + 1 : -1 - i;</span>

<span class="nc bnc" id="L1874" title="All 2 branches missed.">            if (isExact)</span>
            {
<span class="nc" id="L1876">                value = accumulator.apply(arg, (V) btree[i], value);</span>
<span class="nc bnc" id="L1877" title="All 2 branches missed.">                if (isStopSentinel(value))</span>
<span class="nc" id="L1878">                    return value;</span>
<span class="nc" id="L1879">                from = null;</span>
            }
        }

<span class="nc" id="L1883">        int limit = btree.length - 1 - childOffset;</span>
<span class="nc bnc" id="L1884" title="All 2 branches missed.">        for (int i = startChild; i &lt; limit; i++)</span>
        {
<span class="nc" id="L1886">            value = accumulate((Object[]) btree[childOffset + i], accumulator, arg, comparator, from, value);</span>

<span class="nc bnc" id="L1888" title="All 2 branches missed.">            if (isStopSentinel(value))</span>
<span class="nc" id="L1889">                break;</span>

<span class="nc bnc" id="L1891" title="All 2 branches missed.">            if (i &lt; childOffset)</span>
            {
<span class="nc" id="L1893">                value = accumulator.apply(arg, (V) btree[i], value);</span>
                // stop if a sentinel stop value was returned
<span class="nc bnc" id="L1895" title="All 2 branches missed.">                if (isStopSentinel(value))</span>
<span class="nc" id="L1896">                    break;</span>
            }

<span class="nc bnc" id="L1899" title="All 2 branches missed.">            if (from != null)</span>
<span class="nc" id="L1900">                from = null;</span>
        }
<span class="nc" id="L1902">        return value;</span>
    }

    public static &lt;V&gt; long accumulate(Object[] btree, LongAccumulator&lt;V&gt; accumulator, Comparator&lt;V&gt; comparator, V from, long initialValue)
    {
<span class="fc" id="L1907">        return accumulate(btree, LongAccumulator::apply, accumulator, comparator, from, initialValue);</span>
    }

    public static &lt;V&gt; long accumulate(Object[] btree, LongAccumulator&lt;V&gt; accumulator, long initialValue)
    {
<span class="fc" id="L1912">        return accumulate(btree, accumulator, null, null, initialValue);</span>
    }

    public static &lt;V, A&gt; long accumulate(Object[] btree, BiLongAccumulator&lt;A, V&gt; accumulator, A arg, long initialValue)
    {
<span class="fc" id="L1917">        return accumulate(btree, accumulator, arg, null, null, initialValue);</span>
    }

    /**
     * Calculate the minimum height needed for this size of tree
     *
     * @param size the tree size
     * @return the minimum height needed for this size of tree
     */
    private static int minHeight(int size)
    {
<span class="fc" id="L1928">        return heightAtSize2n(size, BRANCH_SHIFT);</span>
    }

    private static int heightAtSize2n(int size, int branchShift)
    {
        //    branch factor                 =  1 &lt;&lt;  branchShift
        // =&gt; full size at height            = (1 &lt;&lt; (branchShift * height)) - 1
        // =&gt; full size at height + 1        =  1 &lt;&lt; (branchShift * height)
        // =&gt; shift(full size at height + 1) = branchShift * height
        // =&gt; shift(full size at height + 1) / branchShift = height
<span class="fc" id="L1938">        int lengthInBinary = 64 - Long.numberOfLeadingZeros(size);</span>
<span class="fc" id="L1939">        return (branchShift - 1 + lengthInBinary) / branchShift;</span>
    }

    private static int[][] buildBalancedSizeMaps(int branchShift)
    {
<span class="fc" id="L1944">        int count = (32 / branchShift) - 1;</span>
<span class="fc" id="L1945">        int childCount = 1 &lt;&lt; branchShift;</span>
<span class="fc" id="L1946">        int[][] sizeMaps = new int[count][childCount];</span>
<span class="fc bfc" id="L1947" title="All 2 branches covered.">        for (int height = 0; height &lt; count; ++height)</span>
        {
<span class="fc" id="L1949">            int childSize = treeSize2n(height + 1, branchShift);</span>
<span class="fc" id="L1950">            int size = 0;</span>
<span class="fc" id="L1951">            int[] sizeMap = sizeMaps[height];</span>
<span class="fc bfc" id="L1952" title="All 2 branches covered.">            for (int i = 0; i &lt; childCount; ++i)</span>
            {
<span class="fc" id="L1954">                sizeMap[i] = size += childSize;</span>
<span class="fc" id="L1955">                size += 1;</span>
            }
        }
<span class="fc" id="L1958">        return sizeMaps;</span>
    }

    // simply utility to reverse the contents of array[from..to)
    private static void reverse(Object[] array, int from, int to)
    {
<span class="nc" id="L1964">        int mid = (from + to) / 2;</span>
<span class="nc bnc" id="L1965" title="All 2 branches missed.">        for (int i = from; i &lt; mid; i++)</span>
        {
<span class="nc" id="L1967">            int j = to - (1 + i - from);</span>
<span class="nc" id="L1968">            Object tmp = array[i];</span>
<span class="nc" id="L1969">            array[i] = array[j];</span>
<span class="nc" id="L1970">            array[j] = tmp;</span>
        }
<span class="nc" id="L1972">    }</span>

    // simply utility to reverse the contents of array[from..to)
    private static void reverse(int[] array, int from, int to)
    {
<span class="nc" id="L1977">        int mid = (from + to) / 2;</span>
<span class="nc bnc" id="L1978" title="All 2 branches missed.">        for (int i = from; i &lt; mid; i++)</span>
        {
<span class="nc" id="L1980">            int j = to - (1 + i - from);</span>
<span class="nc" id="L1981">            int tmp = array[i];</span>
<span class="nc" id="L1982">            array[i] = array[j];</span>
<span class="nc" id="L1983">            array[j] = tmp;</span>
        }
<span class="nc" id="L1985">    }</span>

    /**
     * Mutate an array of child sizes into a cumulative sizeMap, returning the total size
     */
    private static int sizesToSizeMap(int[] sizeMap)
    {
<span class="fc" id="L1992">        int total = sizeMap[0];</span>
<span class="fc bfc" id="L1993" title="All 2 branches covered.">        for (int i = 1; i &lt; sizeMap.length; ++i)</span>
<span class="fc" id="L1994">            sizeMap[i] = total += 1 + sizeMap[i];</span>
<span class="fc" id="L1995">        return total;</span>
    }

    private static int sizesToSizeMap(int[] sizes, int count)
    {
<span class="fc" id="L2000">        int total = sizes[0];</span>
<span class="fc bfc" id="L2001" title="All 2 branches covered.">        for (int i = 1; i &lt; count; ++i)</span>
<span class="fc" id="L2002">            sizes[i] = total += 1 + sizes[i];</span>
<span class="fc" id="L2003">        return total;</span>
    }

    /**
     * Mutate an array of child sizes into a cumulative sizeMap, returning the total size
     */
    private static void sizeMapToSizes(int[] sizeMap)
    {
<span class="nc bnc" id="L2011" title="All 2 branches missed.">        for (int i = sizeMap.length; i &gt; 1; --i)</span>
<span class="nc" id="L2012">            sizeMap[i] -= 1 + sizeMap[i - 1];</span>
<span class="nc" id="L2013">    }</span>

    /**
     * A simple utility method to handle a null upper bound that we treat as infinity
     */
    private static &lt;Compare&gt; int compareWithMaybeInfinity(Comparator&lt;? super Compare&gt; comparator, Compare key, Compare ub)
    {
<span class="pc bpc" id="L2020" title="1 of 2 branches missed.">        if (ub == null)</span>
<span class="fc" id="L2021">            return -1;</span>
<span class="nc" id="L2022">        return comparator.compare(key, ub);</span>
    }

    /**
     * Perform {@link #exponentialSearch} on {@code in[from..to)}, treating a {@code find} of {@code null} as infinity.
     */
    static &lt;Compare&gt; int exponentialSearchForMaybeInfinity(Comparator&lt;? super Compare&gt; comparator, Object[] in, int from, int to, Compare find)
    {
<span class="fc bfc" id="L2030" title="All 2 branches covered.">        if (find == null)</span>
<span class="fc" id="L2031">            return -(1 + to);</span>
<span class="fc" id="L2032">        return exponentialSearch(comparator, in, from, to, find);</span>
    }

    /**
     * Equivalent to {@link Arrays#binarySearch}, only more efficient algorithmically for linear merges.
     * Binary search has worst case complexity {@code O(n.lg n)} for a linear merge, whereas exponential search
     * has a worst case of {@code O(n)}. However compared to a simple linear merge, the best case for exponential
     * search is {@code O(lg(n))} instead of {@code O(n)}.
     */
    private static &lt;Compare&gt; int exponentialSearch(Comparator&lt;? super Compare&gt; comparator, Object[] in, int from, int to, Compare find)
    {
<span class="fc" id="L2043">        int step = 0;</span>
<span class="fc bfc" id="L2044" title="All 2 branches covered.">        while (from + step &lt; to)</span>
        {
<span class="fc" id="L2046">            int i = from + step;</span>
<span class="fc" id="L2047">            int c = comparator.compare(find, (Compare) in[i]);</span>
<span class="fc bfc" id="L2048" title="All 2 branches covered.">            if (c &lt; 0)</span>
            {
<span class="fc" id="L2050">                to = i;</span>
<span class="fc" id="L2051">                break;</span>
            }
<span class="fc bfc" id="L2053" title="All 2 branches covered.">            if (c == 0)</span>
<span class="fc" id="L2054">                return i;</span>
<span class="fc" id="L2055">            from = i + 1;</span>
<span class="fc" id="L2056">            step = step * 2 + 1; // jump in perfect binary search increments</span>
<span class="fc" id="L2057">        }</span>
<span class="fc" id="L2058">        return Arrays.binarySearch((Compare[]) in, from, to, find, comparator);</span>
    }

    /**
     * Perform {@link #exponentialSearch} on {@code in[from..to)}; if the value falls outside of the range of these
     * elements, test against {@code ub} as though it occurred at position {@code to}
     *
     * @return same as {@link Arrays#binarySearch} if {@code find} occurs in the range {@code [in[from]..in[to])};
     * otherwise the insertion position {@code -(1+to)} if {@code find} is less than {@code ub}, and {@code -(2+t)}
     * if it is greater than or equal to.
     * &lt;p&gt;
     * {@code ub} may be {@code null}, representing infinity.
     */
    static &lt;Compare&gt; int exponentialSearchWithUpperBound(Comparator&lt;? super Compare&gt; comparator, Object[] in, int from, int to, Compare ub, Compare find)
    {
<span class="fc" id="L2073">        int step = 0;</span>
        while (true)
        {
<span class="fc" id="L2076">            int i = from + step;</span>
<span class="fc bfc" id="L2077" title="All 2 branches covered.">            if (i &gt;= to)</span>
            {
<span class="fc" id="L2079">                int c = compareWithMaybeInfinity(comparator, find, ub);</span>
<span class="pc bpc" id="L2080" title="1 of 2 branches missed.">                if (c &gt;= 0)</span>
<span class="nc" id="L2081">                    return -(2 + to);</span>
                break;
            }
<span class="fc" id="L2084">            int c = comparator.compare(find, (Compare) in[i]);</span>
<span class="fc bfc" id="L2085" title="All 2 branches covered.">            if (c &lt; 0)</span>
            {
<span class="fc" id="L2087">                to = i;</span>
<span class="fc" id="L2088">                break;</span>
            }
<span class="fc bfc" id="L2090" title="All 2 branches covered.">            if (c == 0)</span>
<span class="fc" id="L2091">                return i;</span>
<span class="fc" id="L2092">            from = i + 1;</span>
<span class="fc" id="L2093">            step = step * 2 + 1; // jump in perfect binary search increments</span>
<span class="fc" id="L2094">        }</span>
<span class="fc" id="L2095">        return Arrays.binarySearch((Compare[]) in, from, to, find, comparator);</span>
    }

    /**
     * Compute the size-in-bytes of full trees of cardinality {@code branchFactor^height - 1}
     */
    private static long[] sizeOnHeapOfPerfectTrees(int branchShift)
    {
<span class="fc" id="L2103">        long[] result = new long[heightAtSize2n(Integer.MAX_VALUE, branchShift)];</span>
<span class="fc" id="L2104">        int branchFactor = 1 &lt;&lt; branchShift;</span>
<span class="fc" id="L2105">        result[0] = branchFactor - 1;</span>
<span class="fc bfc" id="L2106" title="All 2 branches covered.">        for (int i = 1; i &lt; result.length; ++i)</span>
<span class="fc" id="L2107">            result[i] = sizeOnHeapOfPerfectTree(i + 1, branchFactor);</span>
<span class="fc" id="L2108">        return result;</span>
    }

    /**
     * Compute the size-in-bytes of a full tree of cardinality {@code branchFactor^height - 1}
     * TODO: test
     */
    private static long sizeOnHeapOfPerfectTree(int height, int branchShift)
    {
<span class="fc" id="L2117">        int branchFactor = 1 &lt;&lt; branchShift;</span>
<span class="fc" id="L2118">        long branchSize = ObjectSizes.sizeOfReferenceArray(branchFactor * 2);</span>
<span class="fc bfc" id="L2119" title="All 2 branches covered.">        int branchCount = height == 2 ? 1 : 2 + treeSize2n(height - 2, branchShift);</span>
<span class="fc" id="L2120">        long leafSize = ObjectSizes.sizeOfReferenceArray((branchFactor - 1) | 1);</span>
<span class="fc" id="L2121">        int leafCount = 1 + treeSize2n(height - 1, branchShift);</span>
<span class="fc" id="L2122">        return (branchSize * branchCount) + (leafSize * leafCount);</span>
    }

    /**
     * @return the actual height of {@code tree}
     */
    public static int height(Object[] tree)
    {
<span class="nc bnc" id="L2130" title="All 2 branches missed.">        if (isLeaf(tree))</span>
<span class="nc" id="L2131">            return 1;</span>

<span class="nc" id="L2133">        int height = 1;</span>
<span class="nc bnc" id="L2134" title="All 2 branches missed.">        while (!isLeaf(tree))</span>
        {
<span class="nc" id="L2136">            height++;</span>
<span class="nc" id="L2137">            tree = (Object[]) tree[shallowSizeOfBranch(tree)];</span>
        }
<span class="nc" id="L2139">        return height;</span>
    }

    /**
     * @return the maximum representable size at {@code height}.
     */
    private static int denseSize(int height)
    {
<span class="fc" id="L2147">        return treeSize2n(height, BRANCH_SHIFT);</span>
    }

    /**
     * @return the maximum representable size at {@code height}.
     */
    private static int checkedDenseSize(int height)
    {
<span class="nc bnc" id="L2155" title="All 2 branches missed.">        assert height * BRANCH_SHIFT &lt; 32;</span>
<span class="nc" id="L2156">        return denseSize(height);</span>
    }

    /**
     * Computes the number of nodes in a full tree of height {@code height}
     * and with {@code 2^branchShift} branch factor.
     * i.e. computes {@code (2^branchShift)^height - 1}
     */
    private static int treeSize2n(int height, int branchShift)
    {
<span class="fc" id="L2166">        return (1 &lt;&lt; (branchShift * height)) - 1;</span>
    }

    // TODO: test
    private static int maxRootHeight(int size)
    {
<span class="pc bpc" id="L2172" title="1 of 2 branches missed.">        if (size &lt;= BRANCH_FACTOR)</span>
<span class="fc" id="L2173">            return 1;</span>
<span class="nc" id="L2174">        return 1 + heightAtSize2n((size - 1) / 2, BRANCH_SHIFT - 1);</span>
    }

    private static int sizeOfBranch(Object[] branch)
    {
<span class="fc" id="L2179">        int length = branch.length;</span>
        // length - 1 == getChildEnd == getPositionOfSizeMap
        // (length / 2) - 1 == getChildCount - 1 == position of full tree size
        // hard code this, as will be used often;
<span class="fc" id="L2183">        return ((int[]) branch[length - 1])[(length / 2) - 1];</span>
    }

    /**
     * Checks if the UpdateFunction is an instance of {@code UpdateFunction.Simple}.
     */
    private static boolean isSimple(UpdateFunction&lt;?, ?&gt; updateF)
    {
<span class="fc" id="L2191">        return updateF instanceof UpdateFunction.Simple;</span>
    }

    /**
     * @return the size map for the branch node
     */
    static int[] sizeMap(Object[] branch)
    {
<span class="fc" id="L2199">        return (int[]) branch[branch.length - 1];</span>
    }

    public static long sizeOnHeapOf(Object[] tree)
    {
<span class="fc bfc" id="L2204" title="All 2 branches covered.">        if (isEmpty(tree))</span>
<span class="fc" id="L2205">            return 0;</span>

<span class="fc" id="L2207">        long size = ObjectSizes.sizeOfArray(tree);</span>
<span class="fc bfc" id="L2208" title="All 2 branches covered.">        if (isLeaf(tree))</span>
<span class="fc" id="L2209">            return size;</span>
<span class="fc bfc" id="L2210" title="All 2 branches covered.">        for (int i = childOffset(tree); i &lt; childEndOffset(tree); i++)</span>
<span class="fc" id="L2211">            size += sizeOnHeapOf((Object[]) tree[i]);</span>
<span class="fc" id="L2212">        size += ObjectSizes.sizeOfArray(sizeMap(tree)); // may overcount, since we share size maps</span>
<span class="fc" id="L2213">        return size;</span>
    }

    private static long sizeOnHeapOfLeaf(Object[] tree)
    {
<span class="pc bpc" id="L2218" title="1 of 2 branches missed.">        if (isEmpty(tree))</span>
<span class="nc" id="L2219">            return 0;</span>

<span class="fc" id="L2221">        return ObjectSizes.sizeOfArray(tree);</span>
    }

    // Arbitrary boundaries
<span class="fc" id="L2225">    private static Object POSITIVE_INFINITY = new Object();</span>
<span class="fc" id="L2226">    private static Object NEGATIVE_INFINITY = new Object();</span>

    /**
     * simple static wrapper to calls to cmp.compare() which checks if either a or b are Special (i.e. represent an infinity)
     */
    private static &lt;V&gt; int compareWellFormed(Comparator&lt;V&gt; cmp, Object a, Object b)
    {
<span class="nc bnc" id="L2233" title="All 2 branches missed.">        if (a == b)</span>
<span class="nc" id="L2234">            return 0;</span>
<span class="nc bnc" id="L2235" title="All 6 branches missed.">        if (a == NEGATIVE_INFINITY | b == POSITIVE_INFINITY)</span>
<span class="nc" id="L2236">            return -1;</span>
<span class="nc bnc" id="L2237" title="All 6 branches missed.">        if (b == NEGATIVE_INFINITY | a == POSITIVE_INFINITY)</span>
<span class="nc" id="L2238">            return 1;</span>
<span class="nc" id="L2239">        return cmp.compare((V) a, (V) b);</span>
    }

    public static boolean isWellFormed(Object[] btree, Comparator&lt;?&gt; cmp)
    {
<span class="nc bnc" id="L2244" title="All 2 branches missed.">        return isWellFormedReturnHeight(cmp, btree, true, NEGATIVE_INFINITY, POSITIVE_INFINITY) &gt;= 0;</span>
    }

    private static int isWellFormedReturnHeight(Comparator&lt;?&gt; cmp, Object[] node, boolean isRoot, Object min, Object max)
    {
<span class="nc bnc" id="L2249" title="All 2 branches missed.">        if (isEmpty(node))</span>
<span class="nc" id="L2250">            return 0;</span>

<span class="nc bnc" id="L2252" title="All 4 branches missed.">        if (cmp != null &amp;&amp; !isNodeWellFormed(cmp, node, min, max))</span>
<span class="nc" id="L2253">            return -1;</span>

<span class="nc" id="L2255">        int keyCount = shallowSize(node);</span>
<span class="nc bnc" id="L2256" title="All 2 branches missed.">        if (keyCount &lt; 1)</span>
<span class="nc" id="L2257">            return -1;</span>
<span class="nc bnc" id="L2258" title="All 4 branches missed.">        if (!isRoot &amp;&amp; keyCount &lt; BRANCH_FACTOR / 2 - 1)</span>
<span class="nc" id="L2259">            return -1;</span>
<span class="nc bnc" id="L2260" title="All 2 branches missed.">        if (keyCount &gt;= BRANCH_FACTOR)</span>
<span class="nc" id="L2261">            return -1;</span>

<span class="nc bnc" id="L2263" title="All 2 branches missed.">        if (isLeaf(node))</span>
<span class="nc" id="L2264">            return 0;</span>

<span class="nc" id="L2266">        int[] sizeMap = sizeMap(node);</span>
<span class="nc" id="L2267">        int size = 0;</span>
<span class="nc" id="L2268">        int childHeight = -1;</span>
        // compare each child node with the branch element at the head of this node it corresponds with
<span class="nc bnc" id="L2270" title="All 2 branches missed.">        for (int i = childOffset(node); i &lt; childEndOffset(node); i++)</span>
        {
<span class="nc" id="L2272">            Object[] child = (Object[]) node[i];</span>
<span class="nc bnc" id="L2273" title="All 2 branches missed.">            Object localmax = i &lt; node.length - 2 ? node[i - childOffset(node)] : max;</span>
<span class="nc" id="L2274">            int height = isWellFormedReturnHeight(cmp, child, false, min, localmax);</span>
<span class="nc bnc" id="L2275" title="All 2 branches missed.">            if (height == -1)</span>
<span class="nc" id="L2276">                return -1;</span>
<span class="nc bnc" id="L2277" title="All 2 branches missed.">            if (childHeight == -1)</span>
<span class="nc" id="L2278">                childHeight = height;</span>
<span class="nc bnc" id="L2279" title="All 2 branches missed.">            if (childHeight != height)</span>
<span class="nc" id="L2280">                return -1;</span>

<span class="nc" id="L2282">            min = localmax;</span>
<span class="nc" id="L2283">            size += size(child);</span>
<span class="nc bnc" id="L2284" title="All 2 branches missed.">            if (sizeMap[i - childOffset(node)] != size)</span>
<span class="nc" id="L2285">                return -1;</span>
<span class="nc" id="L2286">            size += 1;</span>
        }

<span class="nc" id="L2289">        return childHeight + 1;</span>
    }

    private static boolean isNodeWellFormed(Comparator&lt;?&gt; cmp, Object[] node, Object min, Object max)
    {
<span class="nc" id="L2294">        Object previous = min;</span>
<span class="nc" id="L2295">        int end = shallowSize(node);</span>
<span class="nc bnc" id="L2296" title="All 2 branches missed.">        for (int i = 0; i &lt; end; i++)</span>
        {
<span class="nc" id="L2298">            Object current = node[i];</span>
<span class="nc bnc" id="L2299" title="All 2 branches missed.">            if (compareWellFormed(cmp, previous, current) &gt;= 0)</span>
<span class="nc" id="L2300">                return false;</span>

<span class="nc" id="L2302">            previous = current;</span>
        }
<span class="nc bnc" id="L2304" title="All 2 branches missed.">        return compareWellFormed(cmp, previous, max) &lt; 0;</span>
    }

    /**
     * Build a tree of unknown size, in order.
     * &lt;p&gt;
     * Can be used with {@link #reverseInSitu} to build a tree in reverse.
     */
    public static &lt;V&gt; FastBuilder&lt;V&gt; fastBuilder()
    {
<span class="fc" id="L2314">        TinyThreadLocalPool.TinyPool&lt;FastBuilder&lt;?&gt;&gt; pool = FastBuilder.POOL.get();</span>
<span class="fc" id="L2315">        FastBuilder&lt;V&gt; builder = (FastBuilder&lt;V&gt;) pool.poll();</span>
<span class="fc bfc" id="L2316" title="All 2 branches covered.">        if (builder == null)</span>
<span class="fc" id="L2317">            builder = new FastBuilder&lt;&gt;();</span>
<span class="fc" id="L2318">        builder.pool = pool;</span>
<span class="fc" id="L2319">        return builder;</span>
    }

    /**
     * Base class for AbstractFastBuilder.BranchBuilder, LeafBuilder and AbstractFastBuilder,
     * containing shared behaviour and declaring some useful abstract methods.
     */
    private static abstract class LeafOrBranchBuilder
    {
        final int height;
        final LeafOrBranchBuilder child;
        BranchBuilder parent;

        /**
         * The current buffer contents (if any) of the leaf or branch - always sized to contain a complete
         * node of the form being constructed.  Always non-null, except briefly during overflow.
         */
        Object[] buffer;
        /**
         * The number of keys in our buffer, whether or not we are building a leaf or branch; if we are building
         * a branch, we will ordinarily have the same number of children as well, except temporarily when finishing
         * the construction of the node.
         */
        int count;

        /**
         * either
         * 1) an empty leftover buffer from a past usage, which can be used when we exhaust {@code buffer}; or
         * 2) a full {@code buffer} that has been parked until we next overflow, so we can steal some back
         * if we finish before reaching MIN_KEYS in {@code buffer}
         */
        Object[] savedBuffer;
        /**
         * The key we overflowed on when populating savedBuffer.  If null, {@link #savedBuffer} is logically empty.
         */
        Object savedNextKey;

        LeafOrBranchBuilder(LeafOrBranchBuilder child)
<span class="fc" id="L2357">        {</span>
<span class="fc bfc" id="L2358" title="All 2 branches covered.">            this.height = child == null ? 1 : 1 + child.height;</span>
<span class="fc" id="L2359">            this.child = child;</span>
<span class="fc" id="L2360">        }</span>

        /**
         * Do we have enough keys in the builder to construct at least one balanced node?
         * We could have enough to build two.
         */
        final boolean isSufficient()
        {
<span class="nc bnc" id="L2368" title="All 4 branches missed.">            return hasOverflow() || count &gt;= MIN_KEYS;</span>
        }

        /**
         * Do we have an already constructed node saved, that we can propagate or redistribute?
         * This implies we are building two nodes, since {@link #savedNextKey} would overflow {@link #savedBuffer}
         */
        final boolean hasOverflow()
        {
<span class="fc bfc" id="L2377" title="All 2 branches covered.">            return savedNextKey != null;</span>
        }

        /**
         * Do we have an already constructed node saved AND insufficient keys in our buffer, so
         * that we need to share the contents of {@link #savedBuffer} with {@link #buffer} to construct
         * our results?
         */
        final boolean mustRedistribute()
        {
<span class="fc bfc" id="L2387" title="All 4 branches covered.">            return hasOverflow() &amp;&amp; count &lt; MIN_KEYS;</span>
        }

        /**
         * Are we empty, i.e. we have no contents in either {@link #buffer} or {@link #savedBuffer}
         */
        final boolean isEmpty()
        {
<span class="nc bnc" id="L2395" title="All 4 branches missed.">            return count == 0 &amp;&amp; savedNextKey == null;</span>
        }

        /**
         * Drain the contents of this builder and build up to two nodes, as necessary.
         * If {@code unode != null} and we are building a single node that is identical to it, use {@code unode} instead.
         * If {@code propagateTo != null} propagate any nodes we build to it.
         *
         * @return the last node we construct
         */
        abstract Object[] drainAndPropagate(Object[] unode, BranchBuilder propagateTo);

        /**
         * Drain the contents of this builder and build at most one node.
         * Requires {@code !hasOverflow()}
         *
         * @return the node we construct
         */
        abstract Object[] drain();

        /**
         * Complete the build. Drains the node and any used or newly-required parent and returns the root of the
         * resulting tree.
         *
         * @return the root of the constructed tree.
         */
        public Object[] completeBuild()
        {
<span class="fc" id="L2423">            LeafOrBranchBuilder level = this;</span>
            while (true)
            {
<span class="fc bfc" id="L2426" title="All 2 branches covered.">                if (!level.hasOverflow())</span>
<span class="fc" id="L2427">                    return level.drain();</span>

<span class="fc" id="L2429">                BranchBuilder parent = level.ensureParent();</span>
<span class="fc" id="L2430">                level.drainAndPropagate(null, parent);</span>
<span class="fc bfc" id="L2431" title="All 2 branches covered.">                if (level.savedBuffer != null)</span>
<span class="fc" id="L2432">                    Arrays.fill(level.savedBuffer, null);</span>
<span class="fc" id="L2433">                level = parent;</span>
<span class="fc" id="L2434">            }</span>
        }

        /**
         * Takes a node that would logically occur directly preceding the current buffer contents,
         * and the key that would separate them in a parent node, and prepends their contents
         * to the current buffer's contents.  This can be used to redistribute already-propagated
         * contents to a parent in cases where this is convenient (i.e. when transforming)
         *
         * @param predecessor        directly preceding node
         * @param predecessorNextKey key that would have separated predecessor from buffer contents
         */
        abstract void prepend(Object[] predecessor, Object predecessorNextKey);

        /**
         * Indicates if this builder produces dense nodes, i.e. those that are populated with MAX_KEYS
         * at every level.  Only the last two children of any branch may be non-dense, and in some cases only
         * the last two nodes in any tier of the tree.
         * &lt;p&gt;
         * This flag switches whether or not we maintain a buffer of sizes, or use the globally shared contents of
         * DENSE_SIZE_MAPS.
         */
        abstract boolean producesOnlyDense();

        /**
         * Ensure there is a {@code branch.parent}, and return it
         */
        final BranchBuilder ensureParent()
        {
<span class="fc bfc" id="L2463" title="All 2 branches covered.">            if (parent == null)</span>
<span class="fc" id="L2464">                parent = new BranchBuilder(this);</span>
<span class="fc" id="L2465">            parent.inUse = true;</span>
<span class="fc" id="L2466">            return parent;</span>
        }

        /**
         * Mark a branch builder as utilised, so that we must clear it when resetting any {@link AbstractFastBuilder}
         *
         * @return {@code branch}
         */
        static BranchBuilder markUsed(BranchBuilder branch)
        {
<span class="nc" id="L2476">            branch.inUse = true;</span>
<span class="nc" id="L2477">            return branch;</span>
        }

        /**
         * A utility method for comparing a range of two arrays
         */
        static boolean areIdentical(Object[] a, int aOffset, Object[] b, int bOffset, int count)
        {
<span class="fc bfc" id="L2485" title="All 2 branches covered.">            for (int i = 0; i &lt; count; ++i)</span>
            {
<span class="fc bfc" id="L2487" title="All 2 branches covered.">                if (a[i + aOffset] != b[i + bOffset])</span>
<span class="fc" id="L2488">                    return false;</span>
            }
<span class="fc" id="L2490">            return true;</span>
        }

        /**
         * A utility method for comparing a range of two arrays
         */
        static boolean areIdentical(int[] a, int aOffset, int[] b, int bOffset, int count)
        {
<span class="pc bpc" id="L2498" title="1 of 2 branches missed.">            for (int i = 0; i &lt; count; ++i)</span>
            {
<span class="fc bfc" id="L2500" title="All 2 branches covered.">                if (a[i + aOffset] != b[i + bOffset])</span>
<span class="fc" id="L2501">                    return false;</span>
            }
<span class="nc" id="L2503">            return true;</span>
        }
    }

    /**
     * LeafBuilder for methods pertaining specifically to building a leaf in an {@link AbstractFastBuilder}.
     * Note that {@link AbstractFastBuilder} extends this class directly, however it is convenient to maintain
     * distinct classes in the hierarchy for clarity of behaviour and intent.
     */
<span class="fc" id="L2512">    private static abstract class LeafBuilder extends LeafOrBranchBuilder</span>
    {
        long allocated;

        LeafBuilder()
        {
<span class="fc" id="L2518">            super(null);</span>
<span class="fc" id="L2519">            buffer = new Object[MAX_KEYS];</span>
<span class="fc" id="L2520">        }</span>

        /**
         * Add {@code nextKey} to the buffer, overflowing if necessary
         */
        public void addKey(Object nextKey)
        {
<span class="fc bfc" id="L2527" title="All 2 branches covered.">            if (count == MAX_KEYS)</span>
<span class="fc" id="L2528">                overflow(nextKey);</span>
            else
<span class="fc" id="L2530">                buffer[count++] = nextKey;</span>
<span class="fc" id="L2531">        }</span>

        /**
         * Add {@code nextKey} to the buffer; the caller specifying overflow is unnecessary
         */
        public void addKeyNoOverflow(Object nextKey)
        {
<span class="fc" id="L2538">            buffer[count++] = nextKey;</span>
<span class="fc" id="L2539">        }</span>

        /**
         * Add {@code nextKey} to the buffer; the caller specifying overflow is unnecessary
         */
        public void maybeAddKeyNoOverflow(Object nextKey)
        {
<span class="nc" id="L2546">            buffer[count] = nextKey;</span>
<span class="nc bnc" id="L2547" title="All 2 branches missed.">            count += nextKey != null ? 1 : 0;</span>
<span class="nc" id="L2548">        }</span>

        /**
         * Add {@code nextKey} to the buffer; the caller specifying overflow is unnecessary
         */
        public void maybeAddKey(Object nextKey)
        {
<span class="nc bnc" id="L2555" title="All 2 branches missed.">            if (count == MAX_KEYS)</span>
            {
<span class="nc bnc" id="L2557" title="All 2 branches missed.">                if (nextKey != null)</span>
<span class="nc" id="L2558">                    overflow(nextKey);</span>
            }
            else
            {
<span class="nc" id="L2562">                buffer[count] = nextKey;</span>
<span class="nc bnc" id="L2563" title="All 2 branches missed.">                count += nextKey != null ? 1 : 0;</span>
            }
<span class="nc" id="L2565">        }</span>

        /**
         * Copy the contents of {@code source[from..to)} to {@code buffer}, overflowing as necessary.
         */
        void copy(Object[] source, int offset, int length)
        {
<span class="fc bfc" id="L2572" title="All 2 branches covered.">            if (count + length &gt; MAX_KEYS)</span>
            {
<span class="fc" id="L2574">                int copy = MAX_KEYS - count;</span>
<span class="fc" id="L2575">                System.arraycopy(source, offset, buffer, count, copy);</span>
<span class="fc" id="L2576">                offset += copy;</span>
//              implicitly:  count = MAX_KEYS;
<span class="fc" id="L2578">                overflow(source[offset++]);</span>
<span class="fc" id="L2579">                length -= 1 + copy;</span>
            }
<span class="fc" id="L2581">            System.arraycopy(source, offset, buffer, count, length);</span>
<span class="fc" id="L2582">            count += length;</span>
<span class="fc" id="L2583">        }</span>

        /**
         * Copy the contents of {@code source[from..to)} to {@code buffer}; the caller specifying overflow is unnecessary
         */
        void copyNoOverflow(Object[] source, int offset, int length)
        {
<span class="fc" id="L2590">            System.arraycopy(source, offset, buffer, count, length);</span>
<span class="fc" id="L2591">            count += length;</span>
<span class="fc" id="L2592">        }</span>

        /**
         * Copy the contents of the data to {@code buffer}, overflowing as necessary.
         */
        &lt;Insert, Existing&gt; void copy(Object[] source, int offset, int length, UpdateFunction&lt;Insert, Existing&gt; apply)
        {
<span class="fc bfc" id="L2599" title="All 2 branches covered.">            if (isSimple(apply))</span>
            {
<span class="fc" id="L2601">                copy(source, offset, length);</span>
<span class="fc" id="L2602">                return;</span>
            }

<span class="fc bfc" id="L2605" title="All 2 branches covered.">            if (count + length &gt; MAX_KEYS)</span>
            {
<span class="fc" id="L2607">                int copy = MAX_KEYS - count;</span>
<span class="pc bpc" id="L2608" title="1 of 2 branches missed.">                for (int i = 0; i &lt; copy; ++i)</span>
<span class="nc" id="L2609">                    buffer[count + i] = apply.insert((Insert) source[offset + i]);</span>
<span class="fc" id="L2610">                offset += copy;</span>
//              implicitly:  leaf().count = MAX_KEYS;
<span class="fc" id="L2612">                overflow(apply.insert((Insert) source[offset++]));</span>
<span class="fc" id="L2613">                length -= 1 + copy;</span>
            }

<span class="fc bfc" id="L2616" title="All 2 branches covered.">            for (int i = 0; i &lt; length; ++i)</span>
<span class="fc" id="L2617">                buffer[count + i] = apply.insert((Insert) source[offset + i]);</span>
<span class="fc" id="L2618">            count += length;</span>

<span class="fc" id="L2620">        }</span>

        /**
         * {@link #buffer} is full, and we need to make room either by populating {@link #savedBuffer},
         * propagating its current contents, if any, to {@link #parent}
         */
        void overflow(Object nextKey)
        {
<span class="fc bfc" id="L2628" title="All 2 branches covered.">            if (hasOverflow())</span>
<span class="fc" id="L2629">                propagateOverflow();</span>

            // precondition: count == MAX_KEYS and savedNextKey == null

<span class="fc" id="L2633">            Object[] newBuffer = savedBuffer;</span>
<span class="fc bfc" id="L2634" title="All 2 branches covered.">            if (newBuffer == null)</span>
<span class="fc" id="L2635">                newBuffer = new Object[MAX_KEYS];</span>

<span class="fc" id="L2637">            savedBuffer = buffer;</span>
<span class="fc" id="L2638">            savedNextKey = nextKey;</span>
<span class="fc" id="L2639">            buffer = newBuffer;</span>
<span class="fc" id="L2640">            count = 0;</span>
<span class="fc" id="L2641">        }</span>

        /**
         * Redistribute the contents of {@link #savedBuffer} into {@link #buffer}, finalise {@link #savedBuffer} and flush upwards.
         * Invoked when we are building from {@link #buffer}, have insufficient values but a complete leaf in {@link #savedBuffer}
         *
         * @return the size of the leaf we flushed to our parent from {@link #savedBuffer}
         */
        Object[] redistributeOverflowAndDrain()
        {
<span class="fc" id="L2651">            Object[] newLeaf = redistributeAndDrain(savedBuffer, MAX_KEYS, savedNextKey);</span>
<span class="fc" id="L2652">            savedNextKey = null;</span>
<span class="fc" id="L2653">            return newLeaf;</span>
        }

        /**
         * Redistribute the contents of {@link #buffer} and an immediate predecessor into a new leaf,
         * then construct a new predecessor with the remaining contents and propagate up to our parent
         * Invoked when we are building from {@link #buffer}, have insufficient values but either a complete
         * leaf in {@link #savedBuffer} or can exfiltrate one from our parent to redistribute.
         *
         * @return the second of the two new leaves
         */
        Object[] redistributeAndDrain(Object[] pred, int predSize, Object predNextKey)
        {
            // precondition: savedLeafCount == MAX_KEYS &amp;&amp; leaf().count &lt; MIN_KEYS
            // ensure we have at least MIN_KEYS in leaf().buffer
            // first shift leaf().buffer and steal some keys from leaf().savedBuffer and leaf().savedBufferNextKey
<span class="fc" id="L2669">            int steal = MIN_KEYS - count;</span>
<span class="fc" id="L2670">            Object[] newLeaf = new Object[MIN_KEYS];</span>
<span class="fc" id="L2671">            System.arraycopy(pred, predSize - (steal - 1), newLeaf, 0, steal - 1);</span>
<span class="fc" id="L2672">            newLeaf[steal - 1] = predNextKey;</span>
<span class="fc" id="L2673">            System.arraycopy(buffer, 0, newLeaf, steal, count);</span>

            // then create a leaf out of the remainder of savedBuffer
<span class="fc" id="L2676">            int newPredecessorCount = predSize - steal;</span>
<span class="fc" id="L2677">            Object[] newPredecessor = new Object[newPredecessorCount | 1];</span>
<span class="fc" id="L2678">            System.arraycopy(pred, 0, newPredecessor, 0, newPredecessorCount);</span>
<span class="fc bfc" id="L2679" title="All 2 branches covered.">            if (allocated &gt;= 0)</span>
<span class="fc" id="L2680">                allocated += ObjectSizes.sizeOfReferenceArray(newPredecessorCount | 1);</span>
<span class="fc" id="L2681">            ensureParent().addChildAndNextKey(newPredecessor, newPredecessorCount, pred[newPredecessorCount]);</span>
<span class="fc" id="L2682">            return newLeaf;</span>
        }

        /**
         * Invoked to fill our {@link #buffer} to &gt;= MIN_KEYS with data ocurring before {@link #buffer};
         * possibly instead fills {@link #savedBuffer}
         *
         * @param pred        directly preceding node
         * @param predNextKey key that would have separated predecessor from buffer contents
         */
        void prepend(Object[] pred, Object predNextKey)
        {
<span class="nc bnc" id="L2694" title="All 2 branches missed.">            assert !hasOverflow();</span>
<span class="nc" id="L2695">            int predSize = sizeOfLeaf(pred);</span>
<span class="nc" id="L2696">            int newKeys = 1 + predSize;</span>
<span class="nc bnc" id="L2697" title="All 2 branches missed.">            if (newKeys + count &lt;= MAX_KEYS)</span>
            {
<span class="nc" id="L2699">                System.arraycopy(buffer, 0, buffer, newKeys, count);</span>
<span class="nc" id="L2700">                System.arraycopy(pred, 0, buffer, 0, predSize);</span>
<span class="nc" id="L2701">                buffer[predSize] = predNextKey;</span>
<span class="nc" id="L2702">                count += newKeys;</span>
            }
            else
            {
<span class="nc bnc" id="L2706" title="All 2 branches missed.">                if (savedBuffer == null)</span>
<span class="nc" id="L2707">                    savedBuffer = new Object[MAX_KEYS];</span>
<span class="nc" id="L2708">                System.arraycopy(pred, 0, savedBuffer, 0, predSize);</span>
<span class="nc bnc" id="L2709" title="All 2 branches missed.">                if (predSize == MAX_KEYS)</span>
                {
<span class="nc" id="L2711">                    savedNextKey = predNextKey;</span>
                }
                else
                {
<span class="nc" id="L2715">                    int removeKeys = MAX_KEYS - predSize;</span>
<span class="nc" id="L2716">                    count -= removeKeys;</span>
<span class="nc" id="L2717">                    savedBuffer[predSize] = predNextKey;</span>
<span class="nc" id="L2718">                    System.arraycopy(buffer, 0, savedBuffer, predSize + 1, MAX_KEYS - newKeys);</span>
<span class="nc" id="L2719">                    savedNextKey = buffer[MAX_KEYS - newKeys];</span>
<span class="nc" id="L2720">                    System.arraycopy(buffer, removeKeys, buffer, 0, count);</span>
                }
            }
<span class="nc" id="L2723">        }</span>

        /**
         * Invoked when we want to add a key to the leaf buffer, but it is full
         */
        void propagateOverflow()
        {
            // propagate the leaf we have saved in savedBuffer
            // precondition: savedLeafCount == MAX_KEYS
<span class="pc bpc" id="L2732" title="1 of 2 branches missed.">            if (allocated &gt;= 0)</span>
<span class="nc" id="L2733">                allocated += ObjectSizes.sizeOfReferenceArray(MAX_KEYS);</span>
<span class="fc" id="L2734">            ensureParent().addChildAndNextKey(savedBuffer, MAX_KEYS, savedNextKey);</span>
<span class="fc" id="L2735">            savedBuffer = null;</span>
<span class="fc" id="L2736">            savedNextKey = null;</span>
<span class="fc" id="L2737">        }</span>

        /**
         * Construct a new leaf from the contents of {@link #buffer}, unless the contents have not changed
         * from {@code unode}, in which case return {@code unode} to avoid allocating unnecessary objects.
         *
         * This is only called when we have enough data to complete the node, i.e. we have MIN_KEYS or more items added
         * or the node is the BTree's root.
         */
        Object[] drainAndPropagate(Object[] unode, BranchBuilder propagateTo)
        {
            Object[] leaf;
            int sizeOfLeaf;
<span class="fc bfc" id="L2750" title="All 2 branches covered.">            if (mustRedistribute())</span>
            {
                // we have too few items, so spread the two buffers across two new nodes
<span class="fc" id="L2753">                leaf = redistributeOverflowAndDrain();</span>
<span class="fc" id="L2754">                sizeOfLeaf = MIN_KEYS;</span>
            }
<span class="pc bpc" id="L2756" title="2 of 8 branches missed.">            else if (!hasOverflow() &amp;&amp; unode != null &amp;&amp; count == sizeOfLeaf(unode) &amp;&amp; areIdentical(buffer, 0, unode, 0, count))</span>
            {
                // we have exactly the same contents as the original node, so reuse it
<span class="nc" id="L2759">                leaf = unode;</span>
<span class="nc" id="L2760">                sizeOfLeaf = count;</span>
            }
            else
            {
                // we have maybe one saved full buffer, and one buffer with sufficient contents to copy
<span class="fc bfc" id="L2765" title="All 2 branches covered.">                if (hasOverflow())</span>
<span class="fc" id="L2766">                    propagateOverflow();</span>

<span class="fc" id="L2768">                sizeOfLeaf = count;</span>
<span class="fc" id="L2769">                leaf = drain();</span>
<span class="pc bpc" id="L2770" title="1 of 4 branches missed.">                if (allocated &gt;= 0 &amp;&amp; sizeOfLeaf &gt; 0)</span>
<span class="pc bpc" id="L2771" title="1 of 2 branches missed.">                    allocated += ObjectSizes.sizeOfReferenceArray(sizeOfLeaf | 1) - (unode == null ? 0 : sizeOnHeapOfLeaf(unode));</span>
            }

<span class="fc" id="L2774">            count = 0;</span>
<span class="pc bpc" id="L2775" title="1 of 2 branches missed.">            if (propagateTo != null)</span>
<span class="fc" id="L2776">                propagateTo.addChild(leaf, sizeOfLeaf);</span>
<span class="fc" id="L2777">            return leaf;</span>
        }

        /**
         * Construct a new leaf from the contents of {@code leaf().buffer}, assuming that the node does not overflow.
         */
        Object[] drain()
        {
            // the number of children here may be smaller than MIN_KEYS if this is the root node
<span class="pc bpc" id="L2786" title="1 of 2 branches missed.">            assert !hasOverflow();</span>
<span class="fc bfc" id="L2787" title="All 2 branches covered.">            if (count == 0)</span>
<span class="fc" id="L2788">                return empty();</span>

<span class="fc" id="L2790">            Object[] newLeaf = new Object[count | 1];</span>
<span class="fc" id="L2791">            System.arraycopy(buffer, 0, newLeaf, 0, count);</span>
<span class="fc" id="L2792">            count = 0;</span>
<span class="fc" id="L2793">            return newLeaf;</span>
        }
    }

<span class="fc" id="L2797">    static class BranchBuilder extends LeafOrBranchBuilder</span>
    {
        final LeafBuilder leaf;

        /**
         * sizes of the children in {@link #buffer}. If null, we only produce dense nodes.
         */
        int[] sizes;
        /**
         * sizes of the children in {@link #savedBuffer}
         */
        int[] savedSizes;
        /**
         * marker to limit unnecessary work with unused levels, esp. on reset
         */
        boolean inUse;

        BranchBuilder(LeafOrBranchBuilder child)
        {
<span class="fc" id="L2816">            super(child);</span>
<span class="fc" id="L2817">            buffer = new Object[2 * (MAX_KEYS + 1)];</span>
<span class="fc bfc" id="L2818" title="All 2 branches covered.">            if (!child.producesOnlyDense())</span>
<span class="fc" id="L2819">                sizes = new int[MAX_KEYS + 1];</span>
<span class="fc bfc" id="L2820" title="All 2 branches covered.">            this.leaf = child instanceof LeafBuilder ? (LeafBuilder) child : ((BranchBuilder) child).leaf;</span>
<span class="fc" id="L2821">        }</span>

        /**
         * Ensure there is room to add another key to {@code branchBuffers[branchIndex]}, and add it;
         * invoke {@link #overflow} if necessary
         */
        void addKey(Object key)
        {
<span class="fc bfc" id="L2829" title="All 2 branches covered.">            if (count == MAX_KEYS)</span>
<span class="fc" id="L2830">                overflow(key);</span>
            else
<span class="fc" id="L2832">                buffer[count++] = key;</span>
<span class="fc" id="L2833">        }</span>

        /**
         * To be invoked when there's a key already inserted to the buffer that requires a corresponding
         * right-hand child, for which the buffers are sized to ensure there is always room.
         */
        void addChild(Object[] child, int sizeOfChild)
        {
<span class="fc" id="L2841">            buffer[MAX_KEYS + count] = child;</span>
<span class="fc" id="L2842">            recordSizeOfChild(sizeOfChild);</span>
<span class="fc" id="L2843">        }</span>

        void recordSizeOfChild(int sizeOfChild)
        {
<span class="fc bfc" id="L2847" title="All 2 branches covered.">            if (sizes != null)</span>
<span class="fc" id="L2848">                sizes[count] = sizeOfChild;</span>
<span class="fc" id="L2849">        }</span>

        /**
         * See {@link BranchBuilder#addChild(Object[], int)}
         */
        void addChild(Object[] child)
        {
<span class="pc bpc" id="L2856" title="1 of 2 branches missed.">            addChild(child, sizes == null ? 0 : size(child));</span>
<span class="fc" id="L2857">        }</span>

        /**
         * Insert a new child into a parent branch, when triggered by {@code overflowLeaf} or {@code overflowBranch}
         */
        void addChildAndNextKey(Object[] newChild, int newChildSize, Object nextKey)
        {
            // we should always have room for a child to the right of any key we have previously inserted
<span class="fc" id="L2865">            buffer[MAX_KEYS + count] = newChild;</span>
<span class="fc" id="L2866">            recordSizeOfChild(newChildSize);</span>
            // but there may not be room for another key
<span class="fc" id="L2868">            addKey(nextKey);</span>
<span class="fc" id="L2869">        }</span>

        /**
         * Invoked when we want to add a key to the leaf buffer, but it is full
         */
        void propagateOverflow()
        {
            // propagate the leaf we have saved in leaf().savedBuffer
<span class="nc bnc" id="L2877" title="All 2 branches missed.">            if (leaf.allocated &gt;= 0)</span>
<span class="nc" id="L2878">                leaf.allocated += ObjectSizes.sizeOfReferenceArray(2 * (1 + MAX_KEYS));</span>
<span class="nc" id="L2879">            int size = setOverflowSizeMap(savedBuffer, MAX_KEYS);</span>
<span class="nc" id="L2880">            ensureParent().addChildAndNextKey(savedBuffer, size, savedNextKey);</span>
<span class="nc" id="L2881">            savedBuffer = null;</span>
<span class="nc" id="L2882">            savedNextKey = null;</span>
<span class="nc" id="L2883">        }</span>

        /**
         * Invoked when a branch already contains {@code MAX_KEYS}, and another child is ready to be added.
         * Creates a new neighbouring node containing MIN_KEYS items, shifting back the remaining MIN_KEYS+1
         * items to the start of the buffer(s).
         */
        void overflow(Object nextKey)
        {
<span class="pc bpc" id="L2892" title="1 of 2 branches missed.">            if (hasOverflow())</span>
<span class="nc" id="L2893">                propagateOverflow();</span>

<span class="fc" id="L2895">            Object[] restoreBuffer = savedBuffer;</span>
<span class="fc" id="L2896">            int[] restoreSizes = savedSizes;</span>

<span class="fc" id="L2898">            savedBuffer = buffer;</span>
<span class="fc" id="L2899">            savedSizes = sizes;</span>
<span class="fc" id="L2900">            savedNextKey = nextKey;</span>

<span class="pc bpc" id="L2902" title="1 of 4 branches missed.">            sizes = restoreSizes == null &amp;&amp; savedSizes != null ? new int[MAX_KEYS + 1] : restoreSizes;</span>
<span class="fc bfc" id="L2903" title="All 2 branches covered.">            buffer = restoreBuffer == null ? new Object[2 * (MAX_KEYS + 1)] : restoreBuffer;</span>
<span class="fc" id="L2904">            count = 0;</span>
<span class="fc" id="L2905">        }</span>

        /**
         * Redistribute the contents of branch.savedBuffer into branch.buffer, finalise savedBuffer and flush upwards.
         * Invoked when we are building from branch, have insufficient values but a complete branch in savedBuffer.
         *
         * @return the size of the branch we flushed to our parent from savedBuffer
         */
        Object[] redistributeOverflowAndDrain()
        {
            // now ensure we have at least MIN_KEYS in buffer
            // both buffer and savedBuffer should be balanced, so that we have count+1 and MAX_KEYS+1 children respectively
            // we need to utilise savedNextKey, so  we want to take {@code steal-1} keys from savedBuffer, {@code steal) children
            // and the dangling key we use in place of savedNextKey for our parent key.
<span class="fc" id="L2919">            int steal = MIN_KEYS - count;</span>
<span class="fc" id="L2920">            Object[] newBranch = new Object[2 * (MIN_KEYS + 1)];</span>
<span class="fc" id="L2921">            System.arraycopy(savedBuffer, MAX_KEYS - (steal - 1), newBranch, 0, steal - 1);</span>
<span class="fc" id="L2922">            newBranch[steal - 1] = savedNextKey;</span>
<span class="fc" id="L2923">            System.arraycopy(buffer, 0, newBranch, steal, count);</span>
<span class="fc" id="L2924">            System.arraycopy(savedBuffer, 2 * MAX_KEYS + 1 - steal, newBranch, MIN_KEYS, steal);</span>
<span class="fc" id="L2925">            System.arraycopy(buffer, MAX_KEYS, newBranch, MIN_KEYS + steal, count + 1);</span>
<span class="fc" id="L2926">            setRedistributedSizeMap(newBranch, steal);</span>

            // then create a branch out of the remainder of savedBuffer
<span class="fc" id="L2929">            int savedBranchCount = MAX_KEYS - steal;</span>
<span class="fc" id="L2930">            Object[] savedBranch = new Object[2 * (savedBranchCount + 1)];</span>
<span class="fc" id="L2931">            System.arraycopy(savedBuffer, 0, savedBranch, 0, savedBranchCount);</span>
<span class="fc" id="L2932">            System.arraycopy(savedBuffer, MAX_KEYS, savedBranch, savedBranchCount, savedBranchCount + 1);</span>
<span class="fc" id="L2933">            int savedBranchSize = setOverflowSizeMap(savedBranch, savedBranchCount);</span>
<span class="pc bpc" id="L2934" title="1 of 2 branches missed.">            if (leaf.allocated &gt;= 0)</span>
<span class="fc" id="L2935">                leaf.allocated += ObjectSizes.sizeOfReferenceArray(2 * (1 + savedBranchCount));</span>
<span class="fc" id="L2936">            ensureParent().addChildAndNextKey(savedBranch, savedBranchSize, savedBuffer[savedBranchCount]);</span>
<span class="fc" id="L2937">            savedNextKey = null;</span>

<span class="fc" id="L2939">            return newBranch;</span>
        }

        /**
         * See {@link LeafOrBranchBuilder#prepend(Object[], Object)}
         */
        void prepend(Object[] pred, Object predNextKey)
        {
<span class="nc bnc" id="L2947" title="All 2 branches missed.">            assert !hasOverflow();</span>
            // assumes sizes != null, since only makes sense to use this method in that context

<span class="nc" id="L2950">            int predKeys = shallowSizeOfBranch(pred);</span>
<span class="nc" id="L2951">            int[] sizeMap = (int[]) pred[2 * predKeys + 1];</span>
<span class="nc" id="L2952">            int newKeys = 1 + predKeys;</span>
<span class="nc bnc" id="L2953" title="All 2 branches missed.">            if (newKeys + count &lt;= MAX_KEYS)</span>
            {
<span class="nc" id="L2955">                System.arraycopy(buffer, 0, buffer, newKeys, count);</span>
<span class="nc" id="L2956">                System.arraycopy(sizes, 0, sizes, newKeys, count + 1);</span>
<span class="nc" id="L2957">                System.arraycopy(buffer, MAX_KEYS, buffer, MAX_KEYS + newKeys, count + 1);</span>

<span class="nc" id="L2959">                System.arraycopy(pred, 0, buffer, 0, predKeys);</span>
<span class="nc" id="L2960">                buffer[predKeys] = predNextKey;</span>
<span class="nc" id="L2961">                System.arraycopy(pred, predKeys, buffer, MAX_KEYS, predKeys + 1);</span>
<span class="nc" id="L2962">                copySizeMapToSizes(sizeMap, 0, sizes, 0, predKeys + 1);</span>
<span class="nc" id="L2963">                count += newKeys;</span>
            }
            else
            {
<span class="nc bnc" id="L2967" title="All 2 branches missed.">                if (savedBuffer == null)</span>
                {
<span class="nc" id="L2969">                    savedBuffer = new Object[2 * (1 + MAX_KEYS)];</span>
<span class="nc" id="L2970">                    savedSizes = new int[1 + MAX_KEYS];</span>
                }

<span class="nc" id="L2973">                System.arraycopy(pred, 0, savedBuffer, 0, predKeys);</span>
<span class="nc" id="L2974">                System.arraycopy(pred, predKeys, savedBuffer, MAX_KEYS, predKeys + 1);</span>
<span class="nc" id="L2975">                copySizeMapToSizes(sizeMap, 0, savedSizes, 0, predKeys + 1);</span>
<span class="nc bnc" id="L2976" title="All 2 branches missed.">                if (newKeys == MAX_KEYS + 1)</span>
                {
<span class="nc" id="L2978">                    savedNextKey = predNextKey;</span>
                }
                else
                {
<span class="nc" id="L2982">                    int removeKeys = (1 + MAX_KEYS - newKeys);</span>
<span class="nc" id="L2983">                    int remainingKeys = count - removeKeys;</span>

<span class="nc" id="L2985">                    savedBuffer[predKeys] = predNextKey;</span>
<span class="nc" id="L2986">                    System.arraycopy(buffer, 0, savedBuffer, newKeys, MAX_KEYS - newKeys);</span>
<span class="nc" id="L2987">                    savedNextKey = buffer[MAX_KEYS - newKeys];</span>
<span class="nc" id="L2988">                    System.arraycopy(sizes, 0, savedSizes, newKeys, MAX_KEYS + 1 - newKeys);</span>
<span class="nc" id="L2989">                    System.arraycopy(buffer, MAX_KEYS, savedBuffer, MAX_KEYS + newKeys, MAX_KEYS + 1 - newKeys);</span>
<span class="nc" id="L2990">                    System.arraycopy(buffer, removeKeys, buffer, 0, remainingKeys);</span>
<span class="nc" id="L2991">                    System.arraycopy(buffer, MAX_KEYS + removeKeys, buffer, MAX_KEYS, remainingKeys + 1);</span>
<span class="nc" id="L2992">                    System.arraycopy(sizes, removeKeys, sizes, 0, remainingKeys + 1);</span>
<span class="nc" id="L2993">                    count = remainingKeys;</span>
                }
            }
<span class="nc" id="L2996">        }</span>

        boolean producesOnlyDense()
        {
<span class="fc bfc" id="L3000" title="All 2 branches covered.">            return sizes == null;</span>
        }

        /**
         * Construct a new branch from the contents of {@code branchBuffers[branchIndex]}, unless the contents have
         * not changed from {@code unode}, in which case return {@code unode} to avoid allocating unnecessary objects.
         *
         * This is only called when we have enough data to complete the node, i.e. we have MIN_KEYS or more items added
         * or the node is the BTree's root.
         */
        Object[] drainAndPropagate(Object[] unode, BranchBuilder propagateTo)
        {
            int sizeOfBranch;
            Object[] branch;
<span class="fc bfc" id="L3014" title="All 2 branches covered.">            if (mustRedistribute())</span>
            {
<span class="fc" id="L3016">                branch = redistributeOverflowAndDrain();</span>
<span class="fc" id="L3017">                sizeOfBranch = sizeOfBranch(branch);</span>
            }
            else
            {
<span class="pc bpc" id="L3021" title="1 of 2 branches missed.">                int usz = unode != null ? shallowSizeOfBranch(unode) : -1;</span>
<span class="pc bpc" id="L3022" title="1 of 4 branches missed.">                if (!hasOverflow() &amp;&amp; usz == count</span>
<span class="pc bpc" id="L3023" title="1 of 2 branches missed.">                    &amp;&amp; areIdentical(buffer, 0, unode, 0, usz)</span>
<span class="pc bpc" id="L3024" title="1 of 2 branches missed.">                    &amp;&amp; areIdentical(buffer, MAX_KEYS, unode, usz, usz + 1))</span>
                {
<span class="nc" id="L3026">                    branch = unode;</span>
<span class="nc" id="L3027">                    sizeOfBranch = sizeOfBranch(branch);</span>
                }
                else
                {
<span class="pc bpc" id="L3031" title="1 of 2 branches missed.">                    if (hasOverflow())</span>
<span class="nc" id="L3032">                        propagateOverflow();</span>

                    // the number of children here may be smaller than MIN_KEYS if this is the root node, but there must
                    // be at least one key / two children.
<span class="pc bpc" id="L3036" title="1 of 2 branches missed.">                    assert count &gt; 0;</span>
<span class="fc" id="L3037">                    branch = new Object[2 * (count + 1)];</span>
<span class="fc" id="L3038">                    System.arraycopy(buffer, 0, branch, 0, count);</span>
<span class="fc" id="L3039">                    System.arraycopy(buffer, MAX_KEYS, branch, count, count + 1);</span>
<span class="fc" id="L3040">                    sizeOfBranch = setDrainSizeMap(unode, usz, branch, count);</span>
                }
            }

<span class="fc" id="L3044">            count = 0;</span>
<span class="pc bpc" id="L3045" title="1 of 2 branches missed.">            if (propagateTo != null)</span>
<span class="fc" id="L3046">                propagateTo.addChild(branch, sizeOfBranch);</span>

<span class="fc" id="L3048">            return branch;</span>
        }

        /**
         * Construct a new branch from the contents of {@code buffer}, assuming that the node does not overflow.
         */
        Object[] drain()
        {
<span class="pc bpc" id="L3056" title="1 of 2 branches missed.">            assert !hasOverflow();</span>
<span class="fc" id="L3057">            int keys = count;</span>
<span class="fc" id="L3058">            count = 0;</span>

<span class="fc" id="L3060">            Object[] branch = new Object[2 * (keys + 1)];</span>
<span class="fc bfc" id="L3061" title="All 2 branches covered.">            if (keys == MAX_KEYS)</span>
            {
<span class="fc" id="L3063">                Object[] tmp = buffer;</span>
<span class="fc" id="L3064">                buffer = branch;</span>
<span class="fc" id="L3065">                branch = tmp;</span>
<span class="fc" id="L3066">            }</span>
            else
            {
<span class="fc" id="L3069">                System.arraycopy(buffer, 0, branch, 0, keys);</span>
<span class="fc" id="L3070">                System.arraycopy(buffer, MAX_KEYS, branch, keys, keys + 1);</span>
            }
<span class="fc" id="L3072">            setDrainSizeMap(null, -1, branch, keys);</span>
<span class="fc" id="L3073">            return branch;</span>
        }

        /**
         * Compute (or fetch from cache) and set the sizeMap in {@code branch}, knowing that it
         * was constructed from for the contents of {@code buffer}.
         * &lt;p&gt;
         * For {@link FastBuilder} these are mostly the same, so they are fetched from a global cache and
         * resized accordingly, but for {@link AbstractUpdater} we maintain a buffer of sizes.
         */
        int setDrainSizeMap(Object[] original, int keysInOriginal, Object[] branch, int keysInBranch)
        {
<span class="fc bfc" id="L3085" title="All 2 branches covered.">            if (producesOnlyDense())</span>
<span class="fc" id="L3086">                return setImperfectSizeMap(branch, keysInBranch);</span>

            // first convert our buffer contents of sizes to represent a sizeMap
<span class="fc" id="L3089">            int size = sizesToSizeMap(this.sizes, keysInBranch + 1);</span>
            // then attempt to reuse the sizeMap from the original node, by comparing the buffer's contents with it
            int[] sizeMap;
<span class="pc bpc" id="L3092" title="1 of 4 branches missed.">            if (keysInOriginal != keysInBranch || !areIdentical(sizeMap = sizeMap(original), 0, this.sizes, 0, keysInBranch + 1))</span>
            {
                // if we cannot, then we either take the buffer wholesale and replace its buffer, or copy a prefix
<span class="fc" id="L3095">                sizeMap = this.sizes;</span>
<span class="fc bfc" id="L3096" title="All 2 branches covered.">                if (keysInBranch &lt; MAX_KEYS)</span>
<span class="fc" id="L3097">                    sizeMap = Arrays.copyOf(sizeMap, keysInBranch + 1);</span>
                else
<span class="fc" id="L3099">                    this.sizes = new int[MAX_KEYS + 1];</span>
            }
<span class="fc" id="L3101">            branch[2 * keysInBranch + 1] = sizeMap;</span>
<span class="fc" id="L3102">            return size;</span>
        }

        /**
         * Compute (or fetch from cache) and set the sizeMap in {@code branch}, knowing that it
         * was constructed from for the contents of {@code savedBuffer}.
         * &lt;p&gt;
         * For {@link FastBuilder} these are always the same size, so they are fetched from a global cache,
         * but for {@link AbstractUpdater} we maintain a buffer of sizes.
         *
         * @return the size of {@code branch}
         */
        int setOverflowSizeMap(Object[] branch, int keys)
        {
<span class="pc bpc" id="L3116" title="1 of 2 branches missed.">            if (producesOnlyDense())</span>
            {
<span class="nc" id="L3118">                int[] sizeMap = DENSE_SIZE_MAPS[height - 2];</span>
<span class="nc bnc" id="L3119" title="All 2 branches missed.">                if (keys &lt; MAX_KEYS)</span>
<span class="nc" id="L3120">                    sizeMap = Arrays.copyOf(sizeMap, keys + 1);</span>
<span class="nc" id="L3121">                branch[2 * keys + 1] = sizeMap;</span>
<span class="nc bnc" id="L3122" title="All 2 branches missed.">                return keys &lt; MAX_KEYS ? sizeMap[keys] : checkedDenseSize(height + 1);</span>
            }
            else
            {
<span class="fc" id="L3126">                int[] sizes = savedSizes;</span>
<span class="pc bpc" id="L3127" title="1 of 2 branches missed.">                if (keys &lt; MAX_KEYS)</span>
<span class="fc" id="L3128">                    sizes = Arrays.copyOf(sizes, keys + 1);</span>
                else
<span class="nc" id="L3130">                    savedSizes = null;</span>
<span class="fc" id="L3131">                branch[2 * keys + 1] = sizes;</span>
<span class="fc" id="L3132">                return sizesToSizeMap(sizes);</span>
            }
        }

        /**
         * Compute (or fetch from cache) and set the sizeMap in {@code branch}, knowing that it
         * was constructed from the contents of both {@code savedBuffer} and {@code buffer}
         * &lt;p&gt;
         * For {@link FastBuilder} these are mostly the same size, so they are fetched from a global cache
         * and only the last items updated, but for {@link AbstractUpdater} we maintain a buffer of sizes.
         */
        void setRedistributedSizeMap(Object[] branch, int steal)
        {
<span class="pc bpc" id="L3145" title="1 of 2 branches missed.">            if (producesOnlyDense())</span>
            {
<span class="nc" id="L3147">                setImperfectSizeMap(branch, MIN_KEYS);</span>
            }
            else
            {
<span class="fc" id="L3151">                int[] sizeMap = new int[MIN_KEYS + 1];</span>
<span class="fc" id="L3152">                System.arraycopy(sizes, 0, sizeMap, steal, count + 1);</span>
<span class="fc" id="L3153">                System.arraycopy(savedSizes, MAX_KEYS + 1 - steal, sizeMap, 0, steal);</span>
<span class="fc" id="L3154">                branch[2 * MIN_KEYS + 1] = sizeMap;</span>
<span class="fc" id="L3155">                sizesToSizeMap(sizeMap);</span>
            }
<span class="fc" id="L3157">        }</span>

        /**
         * Like {@link #setOverflowSizeMap}, but used for building the sizeMap of a node whose
         * last two children may have had their contents redistributed; uses the perfect size map
         * for all but the final two children, and queries the size of the last children directly
         */
        private int setImperfectSizeMap(Object[] branch, int keys)
        {
<span class="fc" id="L3166">            int[] sizeMap = Arrays.copyOf(DENSE_SIZE_MAPS[height - 2], keys + 1);</span>
<span class="fc bfc" id="L3167" title="All 2 branches covered.">            int size = keys == 1 ? 0 : 1 + sizeMap[keys - 2];</span>
<span class="fc" id="L3168">            sizeMap[keys - 1] = size += size((Object[]) branch[2 * keys - 1]);</span>
<span class="fc" id="L3169">            sizeMap[keys] = size += 1 + size((Object[]) branch[2 * keys]);</span>
<span class="fc" id="L3170">            branch[2 * keys + 1] = sizeMap;</span>
<span class="fc" id="L3171">            return size;</span>
        }

        /**
         * Copy the contents of {@code unode} into {@code branchBuffers[branchIndex]},
         * starting at the child before key with index {@code offset} up to and
         * including the key with index {@code offset + length - 1}.
         */
        void copyPreceding(Object[] unode, int usz, int offset, int length)
        {
<span class="fc" id="L3181">            int[] uszmap = sizeMap(unode);</span>
<span class="pc bpc" id="L3182" title="1 of 2 branches missed.">            if (count + length &gt; MAX_KEYS)</span>
            {
                // we will overflow, so copy to MAX_KEYS and trigger overflow
<span class="nc" id="L3185">                int copy = MAX_KEYS - count;</span>
<span class="nc" id="L3186">                copyPrecedingNoOverflow(unode, usz, uszmap, offset, copy);</span>
<span class="nc" id="L3187">                offset += copy;</span>

                // copy last child that fits
<span class="nc" id="L3190">                buffer[MAX_KEYS + MAX_KEYS] = unode[usz + offset];</span>
<span class="nc bnc" id="L3191" title="All 2 branches missed.">                sizes[MAX_KEYS] = uszmap[offset] - (offset &gt; 0 ? (1 + uszmap[offset - 1]) : 0);</span>

<span class="nc" id="L3193">                overflow(unode[offset]);</span>

<span class="nc" id="L3195">                length -= 1 + copy;</span>
<span class="nc" id="L3196">                ++offset;</span>
            }

<span class="fc" id="L3199">            copyPrecedingNoOverflow(unode, usz, uszmap, offset, length);</span>
<span class="fc" id="L3200">        }</span>

        /**
         * Copy the contents of {@code unode} into {@code branchBuffers[branchIndex]},
         * between keys {@code from} and {@code to}, with the caller declaring overflow is unnecessary.
         * {@code from} may be {@code -1}, representing the first child only;
         * all other indices represent the key/child pairs that follow (i.e. a key and its right-hand child).
         */
        private void copyPrecedingNoOverflow(Object[] unode, int usz, int[] uszmap, int offset, int length)
        {
<span class="fc bfc" id="L3210" title="All 2 branches covered.">            if (length &lt;= 1)</span>
            {
<span class="fc bfc" id="L3212" title="All 2 branches covered.">                if (length == 0)</span>
<span class="fc" id="L3213">                    return;</span>

<span class="fc" id="L3215">                buffer[count] = unode[offset];</span>
<span class="fc" id="L3216">                buffer[MAX_KEYS + count] = unode[usz + offset];</span>
<span class="fc bfc" id="L3217" title="All 2 branches covered.">                sizes[count] = uszmap[offset] - (offset &gt; 0 ? (1 + uszmap[offset - 1]) : 0);</span>
<span class="fc" id="L3218">                ++count;</span>
            }
            else
            {
<span class="fc" id="L3222">                System.arraycopy(unode, offset, buffer, count, length);</span>
<span class="fc" id="L3223">                System.arraycopy(unode, usz + offset, buffer, MAX_KEYS + count, length);</span>
<span class="fc" id="L3224">                copySizeMapToSizes(uszmap, offset, sizes, count, length);</span>
<span class="fc" id="L3225">                count += length;</span>
            }
<span class="fc" id="L3227">        }</span>

        /**
         * Copy a region of a cumulative sizeMap into an array of plain sizes
         */
        static void copySizeMapToSizes(int[] in, int inOffset, int[] out, int outOffset, int count)
        {
<span class="pc bpc" id="L3234" title="1 of 2 branches missed.">            assert count &gt; 0;</span>
<span class="fc bfc" id="L3235" title="All 2 branches covered.">            if (inOffset == 0)</span>
            {
                // we don't need to subtract anything from the first node, so just copy it so we can keep the rest of the loop simple
<span class="fc" id="L3238">                out[outOffset++] = in[inOffset++];</span>
<span class="fc" id="L3239">                --count;</span>
            }
<span class="fc bfc" id="L3241" title="All 2 branches covered.">            for (int i = 0; i &lt; count; ++i)</span>
<span class="fc" id="L3242">                out[outOffset + i] = in[inOffset + i] - (1 + in[inOffset + i - 1]);</span>
<span class="fc" id="L3243">        }</span>
    }

    /**
     * Shared parent of {@link FastBuilder} and {@link Updater}, both of which
     * construct their trees in order without knowing the resultant size upfront.
     * &lt;p&gt;
     * Maintains a simple stack of buffers that we provide utilities to navigate and update.
     */
    private static abstract class AbstractFastBuilder extends LeafBuilder
    {
        final boolean producesOnlyDense()
        {
<span class="fc bfc" id="L3256" title="All 2 branches covered.">            return getClass() == FastBuilder.class;</span>
        }

        /**
         * An aesthetic convenience for declaring when we are interacting with the leaf, instead of invoking {@code this} directly
         */
        final LeafBuilder leaf()
        {
<span class="fc" id="L3264">            return this;</span>
        }

        /**
         * Clear any references we might still retain, to avoid holding onto memory.
         * &lt;p&gt;
         * While this method is not strictly  necessary, it exists to
         * ensure the implementing classes are aware they must handle it.
         */
        abstract void reset();
    }

    /**
     * A pooled builder for constructing a tree in-order, and without needing any reconciliation.
     * &lt;p&gt;
     * Constructs whole nodes in place, so that a flush of a complete node can take its buffer entirely.
     * Since we build trees of a predictable shape (i.e. perfectly dense) we do not construct a size map.
     */
    public static class FastBuilder&lt;V&gt; extends AbstractFastBuilder implements AutoCloseable
    {
<span class="fc" id="L3284">        private static final TinyThreadLocalPool&lt;FastBuilder&lt;?&gt;&gt; POOL = new TinyThreadLocalPool&lt;&gt;();</span>
        private TinyThreadLocalPool.TinyPool&lt;FastBuilder&lt;?&gt;&gt; pool;

        FastBuilder()
<span class="fc" id="L3288">        {</span>
<span class="fc" id="L3289">            allocated = -1;</span>
<span class="fc" id="L3290">        } // disable allocation tracking</span>

        public void add(V value)
        {
<span class="fc" id="L3294">            leaf().addKey(value);</span>
<span class="fc" id="L3295">        }</span>

        public void add(Object[] from, int offset, int count)
        {
<span class="nc" id="L3299">            leaf().copy(from, offset, count);</span>
<span class="nc" id="L3300">        }</span>

        public Object[] build()
        {
<span class="fc" id="L3304">            return leaf().completeBuild();</span>
        }

        public Object[] buildReverse()
        {
<span class="nc" id="L3309">            Object[] result = build();</span>
<span class="nc" id="L3310">            reverseInSitu(result, height(result), false);</span>
<span class="nc" id="L3311">            return result;</span>
        }

        @Override
        public void close()
        {
<span class="fc" id="L3317">            reset();</span>
<span class="fc" id="L3318">            pool.offer(this);</span>
<span class="fc" id="L3319">            pool = null;</span>
<span class="fc" id="L3320">        }</span>

        @Override
        void reset()
        {
            // we clear precisely to leaf().count and branch.count because, in the case of a builder,
            // if we ever fill the buffer we will consume it entirely for the tree we are building
            // so the last count should match the number of non-null entries
<span class="fc" id="L3328">            Arrays.fill(leaf().buffer, 0, leaf().count, null);</span>
<span class="fc" id="L3329">            leaf().count = 0;</span>
<span class="fc" id="L3330">            BranchBuilder branch = leaf().parent;</span>
<span class="fc bfc" id="L3331" title="All 4 branches covered.">            while (branch != null &amp;&amp; branch.inUse)</span>
            {
<span class="fc" id="L3333">                Arrays.fill(branch.buffer, 0, branch.count, null);</span>
<span class="fc" id="L3334">                Arrays.fill(branch.buffer, MAX_KEYS, MAX_KEYS + 1 + branch.count, null);</span>
<span class="fc" id="L3335">                branch.count = 0;</span>
<span class="fc" id="L3336">                branch.inUse = false;</span>
<span class="fc" id="L3337">                branch = branch.parent;</span>
            }
<span class="fc" id="L3339">        }</span>
    }

<span class="fc" id="L3342">    private static abstract class AbstractUpdater extends AbstractFastBuilder implements AutoCloseable</span>
    {
        void reset()
        {
<span class="pc bpc" id="L3346" title="1 of 2 branches missed.">            assert leaf().count == 0;</span>
<span class="fc" id="L3347">            clearLeafBuffer(leaf().buffer);</span>
<span class="fc bfc" id="L3348" title="All 2 branches covered.">            if (leaf().savedBuffer != null)</span>
<span class="fc" id="L3349">                Arrays.fill(leaf().savedBuffer, null);</span>

<span class="fc" id="L3351">            BranchBuilder branch = leaf().parent;</span>
<span class="fc bfc" id="L3352" title="All 4 branches covered.">            while (branch != null &amp;&amp; branch.inUse)</span>
            {
<span class="pc bpc" id="L3354" title="1 of 2 branches missed.">                assert branch.count == 0;</span>
<span class="fc" id="L3355">                clearBranchBuffer(branch.buffer);</span>
<span class="fc bfc" id="L3356" title="All 4 branches covered.">                if (branch.savedBuffer != null &amp;&amp; branch.savedBuffer[0] != null)</span>
<span class="fc" id="L3357">                    Arrays.fill(branch.savedBuffer, null); // by definition full, if non-empty</span>
<span class="fc" id="L3358">                branch.inUse = false;</span>
<span class="fc" id="L3359">                branch = branch.parent;</span>
            }
<span class="fc" id="L3361">        }</span>

        /**
         * Clear the contents of a branch buffer, aborting once we encounter a null entry
         * to save time on small trees
         */
        private void clearLeafBuffer(Object[] array)
        {
<span class="fc bfc" id="L3369" title="All 2 branches covered.">            if (array[0] == null)</span>
<span class="fc" id="L3370">                return;</span>
            // find first null entry; loop from beginning, to amortise cost over size of working set
<span class="fc" id="L3372">            int i = 1;</span>
<span class="fc bfc" id="L3373" title="All 4 branches covered.">            while (i &lt; array.length &amp;&amp; array[i] != null)</span>
<span class="fc" id="L3374">                ++i;</span>
<span class="fc" id="L3375">            Arrays.fill(array, 0, i, null);</span>
<span class="fc" id="L3376">        }</span>

        /**
         * Clear the contents of a branch buffer, aborting once we encounter a null entry
         * to save time on small trees
         */
        private void clearBranchBuffer(Object[] array)
        {
<span class="fc bfc" id="L3384" title="All 2 branches covered.">            if (array[0] == null)</span>
<span class="fc" id="L3385">                return;</span>

            // find first null entry; loop from beginning, to amortise cost over size of working set
<span class="fc" id="L3388">            int i = 1;</span>
<span class="fc bfc" id="L3389" title="All 4 branches covered.">            while (i &lt; MAX_KEYS &amp;&amp; array[i] != null)</span>
<span class="fc" id="L3390">                ++i;</span>
<span class="fc" id="L3391">            Arrays.fill(array, 0, i, null);</span>
<span class="fc" id="L3392">            Arrays.fill(array, MAX_KEYS, MAX_KEYS + i + 1, null);</span>
<span class="fc" id="L3393">        }</span>
    }

    /**
     * A pooled object for modifying an existing tree with a new (typically smaller) tree.
     * &lt;p&gt;
     * Constructs the new tree around the shape of the existing tree, as though we had performed inserts in
     * order, copying as much of the original tree as possible.  We achieve this by simply merging leaf nodes
     * up to the immediately following key in an ancestor, maintaining up to two complete nodes in a buffer until
     * this happens, and flushing any nodes we produce in excess of this immediately into the parent buffer.
     * &lt;p&gt;
     * We construct whole nodes in place, except the size map, so that a flush of a complete node can take its buffer
     * entirely.
     * &lt;p&gt;
     * Searches within both trees to accelerate the process of modification, instead of performing a simple
     * iteration over the new tree.
     */
<span class="fc" id="L3410">    private static class Updater&lt;Compare, Existing extends Compare, Insert extends Compare&gt; extends AbstractUpdater implements AutoCloseable</span>
    {
<span class="fc" id="L3412">        static final TinyThreadLocalPool&lt;Updater&gt; POOL = new TinyThreadLocalPool&lt;&gt;();</span>
        TinyThreadLocalPool.TinyPool&lt;Updater&gt; pool;

        // the new tree we navigate linearly, and are always on a key or at the end
<span class="fc" id="L3416">        final SimpleTreeKeysIterator&lt;Compare, Insert&gt; insert = new SimpleTreeKeysIterator&lt;&gt;();</span>

        Comparator&lt;? super Compare&gt; comparator;
        UpdateFunction&lt;Insert, Existing&gt; updateF;


        static &lt;Compare, Existing extends Compare, Insert extends Compare&gt; Updater&lt;Compare, Existing, Insert&gt; get()
        {
<span class="fc" id="L3424">            TinyThreadLocalPool.TinyPool&lt;Updater&gt; pool = POOL.get();</span>
<span class="fc" id="L3425">            Updater&lt;Compare, Existing, Insert&gt; updater = pool.poll();</span>
<span class="fc bfc" id="L3426" title="All 2 branches covered.">            if (updater == null)</span>
<span class="fc" id="L3427">                updater = new Updater&lt;&gt;();</span>
<span class="fc" id="L3428">            updater.pool = pool;</span>
<span class="fc" id="L3429">            return updater;</span>
        }

        /**
         * Precondition: {@code update} should not be empty.
         * &lt;p&gt;
         * Inserts {@code insert} into {@code update}, after applying {@code updateF} to each item, or matched item pairs.
         */
        Object[] update(Object[] update, Object[] insert, Comparator&lt;? super Compare&gt; comparator, UpdateFunction&lt;Insert, Existing&gt; updateF)
        {
<span class="fc" id="L3439">            this.insert.init(insert);</span>
<span class="fc" id="L3440">            this.updateF = updateF;</span>
<span class="fc" id="L3441">            this.comparator = comparator;</span>
<span class="pc bpc" id="L3442" title="1 of 2 branches missed.">            this.allocated = isSimple(updateF) ? -1 : 0;</span>
<span class="fc" id="L3443">            int leafDepth = BTree.depth(update) - 1;</span>
<span class="fc" id="L3444">            LeafOrBranchBuilder builder = leaf();</span>
<span class="fc bfc" id="L3445" title="All 2 branches covered.">            for (int i = 0; i &lt; leafDepth; ++i)</span>
<span class="fc" id="L3446">                builder = builder.ensureParent();</span>

<span class="fc" id="L3448">            Insert ik = this.insert.next();</span>
<span class="fc" id="L3449">            ik = updateRecursive(ik, update, null, builder);</span>
<span class="pc bpc" id="L3450" title="1 of 2 branches missed.">            assert ik == null;</span>
<span class="fc" id="L3451">            Object[] result = builder.completeBuild();</span>

<span class="fc bfc" id="L3453" title="All 2 branches covered.">            if (allocated &gt; 0)</span>
<span class="fc" id="L3454">                updateF.onAllocatedOnHeap(allocated);</span>

<span class="fc" id="L3456">            return result;</span>
        }

        /**
         * Merge a BTree recursively with the contents of {@code insert} up to the given upper bound.
         *
         * @param ik      The next key from the inserted data.
         * @param unode   The source branch to update.
         * @param uub     The branch's upper bound
         * @param builder The builder that will receive the data. It needs to be at the same level of the hierarchy
         *                as the source unode.
         * @return The next key from the inserted data, &gt;= uub.
         */
        private Insert updateRecursive(Insert ik, Object[] unode, Existing uub, LeafOrBranchBuilder builder)
        {
<span class="fc bfc" id="L3471" title="All 2 branches covered.">            return builder == leaf()</span>
<span class="fc" id="L3472">                   ? updateRecursive(ik, unode, uub, (LeafBuilder) builder)</span>
<span class="fc" id="L3473">                   : updateRecursive(ik, unode, uub, (BranchBuilder) builder);</span>
        }

        private Insert updateRecursive(Insert ik, Object[] unode, Existing uub, BranchBuilder builder)
        {
<span class="fc" id="L3478">            int upos = 0;</span>
<span class="fc" id="L3479">            int usz = shallowSizeOfBranch(unode);</span>

<span class="fc bfc" id="L3481" title="All 2 branches covered.">            while (ik != null)</span>
            {
<span class="fc" id="L3483">                int find = exponentialSearchWithUpperBound(comparator, unode, upos, usz, uub, ik);</span>
<span class="fc" id="L3484">                int c = searchResultToComparison(find);</span>
<span class="fc bfc" id="L3485" title="All 2 branches covered.">                if (find &lt; 0)</span>
<span class="fc" id="L3486">                    find = -1 - find;</span>

<span class="pc bpc" id="L3488" title="1 of 2 branches missed.">                if (find &gt; usz)</span>
<span class="nc" id="L3489">                    break;  // nothing else needs to be inserted in this branch</span>
<span class="fc bfc" id="L3490" title="All 2 branches covered.">                if (find &gt; upos)</span>
<span class="fc" id="L3491">                    builder.copyPreceding(unode, usz, upos, find - upos);</span>

<span class="fc bfc" id="L3493" title="All 2 branches covered.">                final Existing nextUKey = find &lt; usz ? (Existing) unode[find] : uub;</span>
<span class="fc" id="L3494">                final Object[] childUNode = (Object[]) unode[find + usz];</span>

                // process next child
<span class="fc bfc" id="L3497" title="All 2 branches covered.">                if (c &lt; 0)</span>
                {
                    // ik fall inside it -- recursively merge the child with the update, using next key as an upper bound
<span class="fc" id="L3500">                    LeafOrBranchBuilder childBuilder = builder.child;</span>
<span class="fc" id="L3501">                    ik = updateRecursive(ik, childUNode, nextUKey, childBuilder);</span>
<span class="fc" id="L3502">                    childBuilder.drainAndPropagate(childUNode, builder);</span>
<span class="fc bfc" id="L3503" title="All 2 branches covered.">                    if (find == usz)    // this was the right-most child, branch is complete and we can return immediately</span>
<span class="fc" id="L3504">                        return ik;</span>
<span class="fc bfc" id="L3505" title="All 2 branches covered.">                    c = ik != null ? comparator.compare(nextUKey, ik) : -1;</span>
<span class="fc" id="L3506">                }</span>
                else
<span class="fc" id="L3508">                    builder.addChild(childUNode);</span>

                // process next key
<span class="fc bfc" id="L3511" title="All 2 branches covered.">                if (c == 0)</span>
                {
                    // ik matches next key
<span class="fc" id="L3514">                    builder.addKey(updateF.merge(nextUKey, ik));</span>
<span class="fc" id="L3515">                    ik = insert.next();</span>
                }
                else
<span class="fc" id="L3518">                    builder.addKey(nextUKey);</span>

<span class="fc" id="L3520">                upos = find + 1;</span>
<span class="fc" id="L3521">            }</span>
            // copy the rest of the branch and exit
<span class="pc bpc" id="L3523" title="1 of 2 branches missed.">            if (upos &lt;= usz)</span>
            {
<span class="fc" id="L3525">                builder.copyPreceding(unode, usz, upos, usz - upos);</span>
<span class="fc" id="L3526">                builder.addChild((Object[]) unode[usz + usz]);</span>
            }

<span class="fc" id="L3529">            return ik;</span>
        }

        private Insert updateRecursive(Insert ik, Object[] unode, Existing uub, LeafBuilder builder)
        {
<span class="fc" id="L3534">            int upos = 0;</span>
<span class="fc" id="L3535">            int usz = sizeOfLeaf(unode);</span>
<span class="fc" id="L3536">            Existing uk = (Existing) unode[upos];</span>
<span class="fc" id="L3537">            int c = comparator.compare(uk, ik);</span>

            while (true)
            {
<span class="fc bfc" id="L3541" title="All 2 branches covered.">                if (c == 0)</span>
                {
<span class="fc" id="L3543">                    leaf().addKey(updateF.merge(uk, ik));</span>
<span class="fc bfc" id="L3544" title="All 2 branches covered.">                    if (++upos &lt; usz)</span>
<span class="fc" id="L3545">                        uk = (Existing) unode[upos];</span>
<span class="fc" id="L3546">                    ik = insert.next();</span>
<span class="fc bfc" id="L3547" title="All 2 branches covered.">                    if (ik == null)</span>
                    {
<span class="fc" id="L3549">                        builder.copy(unode, upos, usz - upos);</span>
<span class="fc" id="L3550">                        return null;</span>
                    }
<span class="fc bfc" id="L3552" title="All 2 branches covered.">                    if (upos == usz)</span>
<span class="fc" id="L3553">                        break;</span>
<span class="fc" id="L3554">                    c = comparator.compare(uk, ik);</span>
                }
<span class="fc bfc" id="L3556" title="All 2 branches covered.">                else if (c &lt; 0)</span>
                {
<span class="fc" id="L3558">                    int ulim = exponentialSearch(comparator, unode, upos + 1, usz, ik);</span>
<span class="fc" id="L3559">                    c = -searchResultToComparison(ulim); // 0 if match, 1 otherwise</span>
<span class="fc bfc" id="L3560" title="All 2 branches covered.">                    if (ulim &lt; 0)</span>
<span class="fc" id="L3561">                        ulim = -(1 + ulim);</span>
<span class="fc" id="L3562">                    builder.copy(unode, upos, ulim - upos);</span>
<span class="fc bfc" id="L3563" title="All 2 branches covered.">                    if ((upos = ulim) == usz)</span>
<span class="fc" id="L3564">                        break;</span>
<span class="fc" id="L3565">                    uk = (Existing) unode[upos];</span>
<span class="fc" id="L3566">                }</span>
                else
                {
<span class="pc bpc" id="L3569" title="1 of 2 branches missed.">                    builder.addKey(isSimple(updateF) ? ik : updateF.insert(ik));</span>
<span class="fc" id="L3570">                    c = insert.copyKeysSmallerThan(uk, comparator, builder, updateF); // 0 on match, -1 otherwise</span>
<span class="fc" id="L3571">                    ik = insert.next();</span>
<span class="pc bpc" id="L3572" title="1 of 2 branches missed.">                    if (ik == null)</span>
                    {
<span class="fc" id="L3574">                        builder.copy(unode, upos, usz - upos);</span>
<span class="fc" id="L3575">                        return null;</span>
                    }
                }
            }
<span class="fc bfc" id="L3579" title="All 4 branches covered.">            if (uub == null || comparator.compare(ik, uub) &lt; 0)</span>
            {
<span class="pc bpc" id="L3581" title="1 of 2 branches missed.">                builder.addKey(isSimple(updateF) ? ik : updateF.insert(ik));</span>
<span class="fc" id="L3582">                insert.copyKeysSmallerThan(uub, comparator, builder, updateF); // 0 on match, -1 otherwise</span>
<span class="fc" id="L3583">                ik = insert.next();</span>
            }
<span class="fc" id="L3585">            return ik;</span>
        }


        public void close()
        {
<span class="fc" id="L3591">            reset();</span>
<span class="fc" id="L3592">            pool.offer(this);</span>
<span class="fc" id="L3593">            pool = null;</span>
<span class="fc" id="L3594">        }</span>

        void reset()
        {
<span class="fc" id="L3598">            super.reset();</span>
<span class="fc" id="L3599">            insert.reset();</span>
<span class="fc" id="L3600">        }</span>
    }

    static int searchResultToComparison(int searchResult)
    {
<span class="fc" id="L3605">        return searchResult &gt;&gt; 31;</span>
    }

    /**
     * Attempts to perform a clean transformation of the original tree into a new tree,
     * by replicating its original shape as far as possible.
     * &lt;p&gt;
     * We do this by attempting to flush our buffers whenever we finish a source-branch at the given level;
     * if there are too few contents, we wait until we finish another node at the same level.
     * &lt;p&gt;
     * This way, we are always resetting at the earliest point we might be able to reuse more parts of the original
     * tree, maximising potential reuse.
     * &lt;p&gt;
     * This can permit us to build unbalanced right-most nodes at each level, in which case we simply rebalance
     * when done.
     * &lt;p&gt;
     * The approach taken here hopefully balances simplicity, garbage generation and execution time.
     */
    private static abstract class AbstractTransformer&lt;I, O&gt; extends AbstractUpdater implements AutoCloseable
    {
        /**
         * An iterator over the tree we are updating
         */
        final SimpleTreeIterator update = new SimpleTreeIterator();

        /**
         * A queue of nodes from update that we are ready to &quot;finish&quot; if we have buffered enough data from them
         * The stack pointer is maintained inside of {@link #apply()}
         */
        Object[][] queuedToFinish = new Object[1][];

        AbstractTransformer()
        {
            allocated = -1;
            ensureParent();
            parent.inUse = false;
        }

        abstract O apply(I v);

        Object[] apply(Object[] update)
        {
            int height = this.update.init(update);
            if (queuedToFinish.length &lt; height - 1)
                queuedToFinish = new Object[height - 1][];
            return apply();
        }

        /**
         * We base our operation on the shape of {@code update}, trying to steal as much of the original tree as
         * possible for our new tree
         */
        private Object[] apply()
        {
            Object[] unode = update.node();
            int upos = update.position(), usz = sizeOfLeaf(unode);

            while (true)
            {
                // we always start the loop on a leaf node, for both input and output
                boolean propagatedOriginalLeaf = false;
                if (leaf().count == 0)
                {
                    if (upos == 0)
                    {   // fast path - buffer is empty and input unconsumed, so may be able to propagate original
                        I in;
                        O out;
                        do
                        {   // optimistic loop - find first point the transformation modified our input
                            in = (I) unode[upos];
                            out = apply(in);
                        } while (in == out &amp;&amp; ++upos &lt; usz);

                        if ((propagatedOriginalLeaf = (upos == usz)))
                        {
                            // if input is unmodified by transformation, propagate the input node
                            markUsed(parent).addChild(unode, usz);
                        }
                        else
                        {
                            // otherwise copy up to the first modified portion,
                            // and fall-through to our below condition for transforming the remainder
                            leaf().copyNoOverflow(unode, 0, upos++);
                            if (out != null)
                                leaf().addKeyNoOverflow(out);
                        }
                    }

                    if (!propagatedOriginalLeaf)
                        transformLeafNoOverflow(unode, upos, usz);
                }
                else
                {
                    transformLeaf(unode, upos, usz);
                }

                // we've finished a leaf, and have to hand it to a parent alongside its right-hand key
                // so now we try to do two things:
                //    1) find the next unfiltered key from our unfinished parent
                //    2) determine how many parents are &quot;finished&quot; and whose buffers we should also attempt to propagate
                // we do (1) unconditionally, because:
                //    a) we need to handle the branch keys somewhere, and it may as well happen in one place
                //    b) we either need more keys for our incomplete leaf; or
                //    c) we need a key to go after our last propagated node in any unfinished parent

                int finishToHeight = 0;
                O nextKey;
                do
                {
                    update.ascendToParent(); // always have a node above leaf level, else we'd invoke transformLeaf
                    BranchBuilder level = parent;
                    unode = update.node();
                    upos = update.position();
                    usz = shallowSizeOfBranch(unode);

                    while (upos == usz)
                    {
                        queuedToFinish[level.height - 2] = unode;
                        finishToHeight = max(finishToHeight, level.height);

                        if (!update.ascendToParent())
                            return finishAndDrain(propagatedOriginalLeaf);

                        level = level.ensureParent();
                        unode = update.node();
                        upos = update.position();
                        usz = shallowSizeOfBranch(unode);
                    }

                    nextKey = apply((I) unode[upos]);
                    if (nextKey == null &amp;&amp; leaf().count &gt; MIN_KEYS) // if we don't have a key, try to steal from leaf().buffer
                        nextKey = (O) leaf().buffer[--leaf().count];

                    update.descendIntoNextLeaf(unode, upos, usz);
                    unode = update.node();
                    upos = update.position();
                    usz = sizeOfLeaf(unode);

                    // nextKey might have been filtered, so we may need to look in this next leaf for it
                    while (nextKey == null &amp;&amp; upos &lt; usz)
                        nextKey = apply((I) unode[upos++]);

                    // if we still found no key loop and try again on the next parent, leaf, parent... ad infinitum
                } while (nextKey == null);

                // we always end with unode a leaf, though it may be that upos == usz and that we will do nothing with it

                // we've found a non-null key, now decide what to do with it:
                //   1) if we have insufficient keys in our leaf, simply append to the leaf and continue;
                //   2) otherwise, walk our parent branches finishing those *before* {@code finishTo}
                //   2a) if any cannot be finished, append our new key to it and stop finishing further parents; they
                //   will be finished the next time we ascend to their level with a complete chain of finishable branches
                //   2b) otherwise, add our new key to {@code finishTo}

                if (!propagatedOriginalLeaf &amp;&amp; !finish(leaf(), null))
                {
                    leaf().addKeyNoOverflow(nextKey);
                    continue;
                }

                BranchBuilder finish = parent;
                while (true)
                {
                    if (finish.height &lt;= finishToHeight)
                    {
                        Object[] originalNode = queuedToFinish[finish.height - 2];
                        if (finish(finish, originalNode))
                        {
                            finish = finish.parent;
                            continue;
                        }
                    }

                    // add our key to the last unpropagated parent branch buffer
                    finish.addKey(nextKey);
                    break;
                }
            }
        }

        private void transformLeafNoOverflow(Object[] unode, int upos, int usz)
        {
            while (upos &lt; usz)
            {
                O v = apply((I) unode[upos++]);
                leaf().maybeAddKeyNoOverflow(v);
            }
        }

        private void transformLeaf(Object[] unode, int upos, int usz)
        {
            while (upos &lt; usz)
            {
                O v = apply((I) unode[upos++]);
                leaf().maybeAddKey(v);
            }
        }

        /**
         * Invoked when we are finished transforming a branch.  If the buffer contains insufficient elements,
         * we refuse to construct a leaf and return null.  Otherwise we propagate the branch to its parent's buffer
         * and return the branch we have constructed.
         */
        private boolean finish(LeafOrBranchBuilder level, Object[] unode)
        {
            if (!level.isSufficient())
                return false;

            level.drainAndPropagate(unode, level.ensureParent());
            return true;
        }

        /**
         * Invoked once we have consumed all input.
         * &lt;p&gt;
         * Completes all unfinished buffers. If they do not contain enough keys, data is stolen from the preceding
         * node to the left on the same level. This is easy if our parent already contains a completed child; if it
         * does not, we recursively apply the stealing procedure to obtain a non-empty parent. If this process manages
         * to reach the root and still find no preceding branch, this will result in making this branch the new root.
         */
        private Object[] finishAndDrain(boolean skipLeaf)
        {
            LeafOrBranchBuilder level = leaf();
            if (skipLeaf)
            {
                level = nonEmptyParentMaybeSteal(level);
                // handle an edge case, where we have propagated a single complete leaf but have no other contents in any parent
                if (level == null)
                    return (Object[]) leaf().parent.buffer[MAX_KEYS];
            }
            while (true)
            {
                BranchBuilder parent = nonEmptyParentMaybeSteal(level);
                if (parent != null &amp;&amp; !level.isSufficient())
                {
                    Object[] result = stealAndMaybeRepropagate(level, parent);
                    if (result != null)
                        return result;
                }
                else
                {

                    Object[] originalNode = level == leaf() ? null : queuedToFinish[level.height - 2];
                    Object[] result = level.drainAndPropagate(originalNode, parent);
                    if (parent == null)
                        return result;
                }
                level = parent;
            }
        }

        BranchBuilder nonEmptyParentMaybeSteal(LeafOrBranchBuilder level)
        {
            if (level.hasOverflow())
                return level.ensureParent();
            BranchBuilder parent = level.parent;
            if (parent == null || !parent.inUse || (parent.isEmpty() &amp;&amp; !tryPrependFromParent(parent)))
                return null;
            return parent;
        }

        /**
         * precondition: {@code fill.parentInUse()} must return {@code fill.parent}
         * &lt;p&gt;
         * Steal some data from our ancestors, if possible.
         * 1) If no ancestor has any data to steal, simply drain and return the current contents.
         * 2) If we exhaust all of our ancestors, and are not now ourselves overflowing, drain and return
         * 3) Otherwise propagate the redistributed contents to our parent and return null, indicating we can continue to parent
         *
         * @return {@code null} if {@code parent} is still logicallly in use after we execute;
         * otherwise the return value is the final result
         */
        private Object[] stealAndMaybeRepropagate(LeafOrBranchBuilder fill, BranchBuilder parent)
        {
            // parent already stole, we steal one from it
            prependFromParent(fill, parent);

            // if we've emptied our parent, attempt to restore it from our grandparent,
            // this is so that we can determine an accurate exhausted status
            boolean exhausted = !fill.hasOverflow() &amp;&amp; parent.isEmpty() &amp;&amp; !tryPrependFromParent(parent);
            if (exhausted)
                return fill.drain();

            fill.drainAndPropagate(null, parent);
            return null;
        }

        private boolean tryPrependFromParent(BranchBuilder parent)
        {
            BranchBuilder grandparent = nonEmptyParentMaybeSteal(parent);
            if (grandparent == null)
                return false;
            prependFromParent(parent, grandparent);
            return true;
        }

        // should only be invoked with parent = parentIfStillInUse(fill), if non-null result
        private void prependFromParent(LeafOrBranchBuilder fill, BranchBuilder parent)
        {
            assert !parent.isEmpty();

            Object[] predecessor;
            Object predecessorNextKey;
            // parent will have same number of children as shallow key count (and may be empty)
            if (parent.count == 0 &amp;&amp; parent.hasOverflow())
            {
                // use the saved buffer instead of going to our parent
                predecessorNextKey = parent.savedNextKey;
                predecessor = (Object[]) parent.savedBuffer[2 * MAX_KEYS];
                Object[] tmpBuffer = parent.savedBuffer;
                int[] tmpSizes = parent.savedSizes;
                parent.savedBuffer = parent.buffer;
                parent.savedSizes = parent.sizes;
                parent.buffer = tmpBuffer;
                parent.sizes = tmpSizes;
                parent.savedNextKey = null;
                parent.count = MAX_KEYS;
                // end with MAX_KEYS keys and children in parent, having stolen MAX_KEYS+1 child and savedNextKey
            }
            else
            {
                --parent.count;
                predecessor = (Object[]) parent.buffer[MAX_KEYS + parent.count];
                predecessorNextKey = parent.buffer[parent.count];
            }

            fill.prepend(predecessor, predecessorNextKey);
        }

        void reset()
        {
            Arrays.fill(queuedToFinish, 0, update.leafDepth, null);
            update.reset();
            super.reset();
        }
    }


    private static class Transformer&lt;I, O&gt; extends AbstractTransformer&lt;I, O&gt;
    {
        static final TinyThreadLocalPool&lt;Transformer&gt; POOL = new TinyThreadLocalPool&lt;&gt;();
        TinyThreadLocalPool.TinyPool&lt;Transformer&gt; pool;

        Function&lt;? super I, ? extends O&gt; apply;

        O apply(I v)
        {
            return apply.apply(v);
        }

        static &lt;I, O&gt; Transformer&lt;I, O&gt; get(Function&lt;? super I, ? extends O&gt; apply)
        {
            TinyThreadLocalPool.TinyPool&lt;Transformer&gt; pool = POOL.get();
            Transformer&lt;I, O&gt; transformer = pool.poll();
            if (transformer == null)
                transformer = new Transformer&lt;&gt;();
            transformer.pool = pool;
            transformer.apply = apply;
            return transformer;
        }

        public void close()
        {
            apply = null;
            reset();
            pool.offer(this);
            pool = null;
        }
    }

    private static class BiTransformer&lt;I, I2, O&gt; extends AbstractTransformer&lt;I, O&gt;
    {
        static final TinyThreadLocalPool&lt;BiTransformer&gt; POOL = new TinyThreadLocalPool&lt;&gt;();

        BiFunction&lt;? super I, ? super I2, ? extends O&gt; apply;
        I2 i2;
        TinyThreadLocalPool.TinyPool&lt;BiTransformer&gt; pool;

        O apply(I i1)
        {
            return apply.apply(i1, i2);
        }

        static &lt;I, I2, O&gt; BiTransformer&lt;I, I2, O&gt; get(BiFunction&lt;? super I, ? super I2, ? extends O&gt; apply, I2 i2)
        {
            TinyThreadLocalPool.TinyPool&lt;BiTransformer&gt; pool = POOL.get();
            BiTransformer&lt;I, I2, O&gt; transformer = pool.poll();
            if (transformer == null)
                transformer = new BiTransformer&lt;&gt;();
            transformer.pool = pool;
            transformer.apply = apply;
            transformer.i2 = i2;
            return transformer;
        }

        public void close()
        {
            apply = null;
            i2 = null;
            reset();
            pool.offer(this);
            pool = null;
        }
    }

    /**
     * A base class for very simple walks of a tree without recursion, supporting reuse
     */
    private static abstract class SimpleTreeStack
    {
        // stack we have descended, with 0 the root node
        Object[][] nodes;
        /**
         * the child node we are in, if at lower height, or the key we are on otherwise
         * can be &lt; 0, indicating we have not yet entered the contents of the node, and are deliberating
         * whether we descend or consume the contents without descending
         */
        int[] positions;
        int depth, leafDepth;

        void reset()
        {
            Arrays.fill(nodes, 0, leafDepth + 1, null);
            // positions gets zero'd during descent
        }

        Object[] node()
        {
            return nodes[depth];
        }

        int position()
        {
            return positions[depth];
        }
    }

    // Similar to SimpleTreeNavigator, but visits values eagerly
    // (the exception being ascendToParent(), which permits iterating through finished parents).
    // Begins by immediately descending to first leaf; if empty terminates immediately.
    private static class SimpleTreeIterator extends SimpleTreeStack
    {
        int init(Object[] tree)
        {
            int maxHeight = maxRootHeight(size(tree));
            if (positions == null || maxHeight &gt;= positions.length)
            {
                positions = new int[maxHeight + 1];
                nodes = new Object[maxHeight + 1][];
            }
            nodes[0] = tree;
            if (isEmpty(tree))
            {
                // already done
                leafDepth = 0;
                depth = -1;
            }
            else
            {
                depth = 0;
                positions[0] = 0;
                while (!isLeaf(tree))
                {
                    tree = (Object[]) tree[shallowSizeOfBranch(tree)];
                    nodes[++depth] = tree;
                    positions[depth] = 0;
                }
                leafDepth = depth;
            }
            return leafDepth + 1;
        }

        void descendIntoNextLeaf(Object[] node, int pos, int sz)
        {
            positions[depth] = ++pos;
            ++depth;
            nodes[depth] = node = (Object[]) node[sz + pos];
            positions[depth] = 0;
            while (depth &lt; leafDepth)
            {
                ++depth;
                nodes[depth] = node = (Object[]) node[shallowSizeOfBranch(node)];
                positions[depth] = 0;
            }
        }

        boolean ascendToParent()
        {
            if (depth &lt; 0)
                return false;
            return --depth &gt;= 0;
        }
    }


    private static class SimpleTreeKeysIterator&lt;Compare, Insert extends Compare&gt;
    {
        int leafSize;
        int leafPos;
        Object[] leaf;
        Object[][] nodes;
        int[] positions;
        int depth;

        void init(Object[] tree)
        {
<span class="fc" id="L4111">            int maxHeight = maxRootHeight(size(tree));</span>
<span class="pc bpc" id="L4112" title="1 of 4 branches missed.">            if (positions == null || maxHeight &gt;= positions.length)</span>
            {
<span class="fc" id="L4114">                positions = new int[maxHeight + 1];</span>
<span class="fc" id="L4115">                nodes = new Object[maxHeight + 1][];</span>
            }
<span class="fc" id="L4117">            depth = 0;</span>
<span class="fc" id="L4118">            descendToLeaf(tree);</span>
<span class="fc" id="L4119">        }</span>

        void reset()
        {
<span class="fc" id="L4123">            leaf = null;</span>
<span class="fc" id="L4124">            Arrays.fill(nodes, 0, nodes.length, null);</span>
<span class="fc" id="L4125">        }</span>

        Insert next()
        {
<span class="fc bfc" id="L4129" title="All 2 branches covered.">            if (leafPos &lt; leafSize) // fast path</span>
<span class="fc" id="L4130">                return (Insert) leaf[leafPos++];</span>

<span class="fc bfc" id="L4132" title="All 2 branches covered.">            if (depth == 0)</span>
<span class="fc" id="L4133">                return null;</span>

<span class="fc" id="L4135">            Object[] node = nodes[depth - 1];</span>
<span class="fc" id="L4136">            final int position = positions[depth - 1];</span>
<span class="fc" id="L4137">            Insert result = (Insert) node[position];</span>
<span class="fc" id="L4138">            advanceBranch(node, position + 1);</span>
<span class="fc" id="L4139">            return result;</span>
        }

        private void advanceBranch(Object[] node, int position)
        {
<span class="fc" id="L4144">            int count = shallowSizeOfBranch(node);</span>
<span class="pc bpc" id="L4145" title="1 of 2 branches missed.">            if (position &lt; count)</span>
<span class="nc" id="L4146">                positions[depth - 1] = position;</span>
            else
<span class="fc" id="L4148">                --depth;  // no more children in this branch, remove from stack</span>
<span class="fc" id="L4149">            descendToLeaf((Object[]) node[count + position]);</span>
<span class="fc" id="L4150">        }</span>

        void descendToLeaf(Object[] node)
        {
<span class="fc bfc" id="L4154" title="All 2 branches covered.">            while (!isLeaf(node))</span>
            {
<span class="fc" id="L4156">                nodes[depth] = node;</span>
<span class="fc" id="L4157">                positions[depth] = 0;</span>
<span class="fc" id="L4158">                node = (Object[]) node[shallowSizeOfBranch(node)];</span>
<span class="fc" id="L4159">                ++depth;</span>
            }
<span class="fc" id="L4161">            leaf = node;</span>
<span class="fc" id="L4162">            leafPos = 0;</span>
<span class="fc" id="L4163">            leafSize = sizeOfLeaf(node);</span>
<span class="fc" id="L4164">        }</span>

        &lt;Update&gt; int copyKeysSmallerThan(Compare bound, Comparator&lt;? super Compare&gt; comparator, LeafBuilder builder, UpdateFunction&lt;Insert, Update&gt; transformer)
        {
            while (true)
            {
<span class="fc" id="L4170">                int lim = exponentialSearchForMaybeInfinity(comparator, leaf, leafPos, leafSize, bound);</span>
<span class="pc bpc" id="L4171" title="1 of 2 branches missed.">                int end = lim &gt;= 0 ? lim : -1 - lim;</span>
<span class="pc bpc" id="L4172" title="1 of 2 branches missed.">                if (end &gt; leafPos)</span>
                {
<span class="nc" id="L4174">                    builder.copy(leaf, leafPos, end - leafPos, transformer);</span>
<span class="nc" id="L4175">                    leafPos = end;</span>
                }
<span class="pc bpc" id="L4177" title="1 of 2 branches missed.">                if (end &lt; leafSize)</span>
<span class="nc" id="L4178">                    return searchResultToComparison(lim);    // 0 if next is a match for bound, -1 otherwise</span>

<span class="pc bpc" id="L4180" title="1 of 2 branches missed.">                if (depth == 0)</span>
<span class="fc" id="L4181">                    return -1;</span>

<span class="nc" id="L4183">                Object[] node = nodes[depth - 1];</span>
<span class="nc" id="L4184">                final int position = positions[depth - 1];</span>
<span class="nc" id="L4185">                Insert branchKey = (Insert) node[position];</span>
<span class="nc" id="L4186">                int cmp = compareWithMaybeInfinity(comparator, branchKey, bound);</span>
<span class="nc bnc" id="L4187" title="All 2 branches missed.">                if (cmp &gt;= 0)</span>
<span class="nc" id="L4188">                    return -cmp;</span>
<span class="nc bnc" id="L4189" title="All 2 branches missed.">                builder.addKey(isSimple(transformer) ? branchKey : transformer.insert(branchKey));</span>
<span class="nc" id="L4190">                advanceBranch(node, position + 1);</span>
<span class="nc" id="L4191">            }</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>