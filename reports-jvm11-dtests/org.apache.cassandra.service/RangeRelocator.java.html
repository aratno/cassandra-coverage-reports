<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RangeRelocator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.service</a> &gt; <span class="el_source">RangeRelocator.java</span></div><h1>RangeRelocator.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.service;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.concurrent.Future;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Multimap;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.Keyspace;
import org.apache.cassandra.dht.Range;
import org.apache.cassandra.dht.RangeStreamer;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.gms.FailureDetector;
import org.apache.cassandra.locator.AbstractReplicationStrategy;
import org.apache.cassandra.locator.EndpointsByReplica;
import org.apache.cassandra.locator.EndpointsForRange;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.locator.RangesAtEndpoint;
import org.apache.cassandra.locator.RangesByEndpoint;
import org.apache.cassandra.locator.Replica;
import org.apache.cassandra.locator.TokenMetadata;
import org.apache.cassandra.streaming.StreamOperation;
import org.apache.cassandra.streaming.StreamPlan;
import org.apache.cassandra.streaming.StreamState;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.Pair;

@VisibleForTesting
public class RangeRelocator
{
<span class="fc" id="L57">    private static final Logger logger = LoggerFactory.getLogger(StorageService.class);</span>

<span class="pc" id="L59">    private final StreamPlan streamPlan = new StreamPlan(StreamOperation.RELOCATION);</span>
<span class="pc" id="L60">    private final InetAddressAndPort localAddress = FBUtilities.getBroadcastAddressAndPort();</span>
    private final TokenMetadata tokenMetaCloneAllSettled;
    // clone to avoid concurrent modification in calculateNaturalReplicas
    private final TokenMetadata tokenMetaClone;
    private final Collection&lt;Token&gt; tokens;
    private final List&lt;String&gt; keyspaceNames;


    RangeRelocator(Collection&lt;Token&gt; tokens, List&lt;String&gt; keyspaceNames, TokenMetadata tmd)
<span class="fc" id="L69">    {</span>
<span class="fc" id="L70">        this.tokens = tokens;</span>
<span class="fc" id="L71">        this.keyspaceNames = keyspaceNames;</span>
<span class="fc" id="L72">        this.tokenMetaCloneAllSettled = tmd.cloneAfterAllSettled();</span>
        // clone to avoid concurrent modification in calculateNaturalReplicas
<span class="fc" id="L74">        this.tokenMetaClone = tmd.cloneOnlyTokenMap();</span>
<span class="fc" id="L75">    }</span>

    @VisibleForTesting
    public RangeRelocator()
<span class="nc" id="L79">    {</span>
<span class="nc" id="L80">        this.tokens = null;</span>
<span class="nc" id="L81">        this.keyspaceNames = null;</span>
<span class="nc" id="L82">        this.tokenMetaCloneAllSettled = null;</span>
<span class="nc" id="L83">        this.tokenMetaClone = null;</span>
<span class="nc" id="L84">    }</span>

    /**
     * Wrapper that supplies accessors to the real implementations of the various dependencies for this method
     */
    private static Multimap&lt;InetAddressAndPort, RangeStreamer.FetchReplica&gt; calculateRangesToFetchWithPreferredEndpoints(RangesAtEndpoint fetchRanges,
                                                                                                                         AbstractReplicationStrategy strategy,
                                                                                                                         String keyspace,
                                                                                                                         TokenMetadata tmdBefore,
                                                                                                                         TokenMetadata tmdAfter)
    {
        EndpointsByReplica preferredEndpoints =
<span class="fc" id="L96">        RangeStreamer.calculateRangesToFetchWithPreferredEndpoints(DatabaseDescriptor.getEndpointSnitch()::sortedByProximity,</span>
                                                                   strategy,
                                                                   fetchRanges,
                                                                   StorageService.useStrictConsistency,
                                                                   tmdBefore,
                                                                   tmdAfter,
                                                                   keyspace,
<span class="fc" id="L103">                                                                   Arrays.asList(new RangeStreamer.FailureDetectorSourceFilter(FailureDetector.instance),</span>
                                                                                 new RangeStreamer.ExcludeLocalNodeFilter()));
<span class="fc" id="L105">        return RangeStreamer.convertPreferredEndpointsToWorkMap(preferredEndpoints);</span>
    }

    /**
     * calculating endpoints to stream current ranges to if needed
     * in some situations node will handle current ranges as part of the new ranges
     **/
    public static RangesByEndpoint calculateRangesToStreamWithEndpoints(RangesAtEndpoint streamRanges,
                                                                        AbstractReplicationStrategy strat,
                                                                        TokenMetadata tmdBefore,
                                                                        TokenMetadata tmdAfter)
    {
<span class="fc" id="L117">        RangesByEndpoint.Builder endpointRanges = new RangesByEndpoint.Builder();</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">        for (Replica toStream : streamRanges)</span>
        {
            //If the range we are sending is full only send it to the new full replica
            //There will also be a new transient replica we need to send the data to, but not
            //the repaired data
<span class="fc" id="L123">            EndpointsForRange oldEndpoints = strat.calculateNaturalReplicas(toStream.range().right, tmdBefore);</span>
<span class="fc" id="L124">            EndpointsForRange newEndpoints = strat.calculateNaturalReplicas(toStream.range().right, tmdAfter);</span>
<span class="fc" id="L125">            logger.debug(&quot;Need to stream {}, current endpoints {}, new endpoints {}&quot;, toStream, oldEndpoints, newEndpoints);</span>

<span class="fc bfc" id="L127" title="All 2 branches covered.">            for (Replica newEndpoint : newEndpoints)</span>
            {
<span class="fc" id="L129">                Replica oldEndpoint = oldEndpoints.byEndpoint().get(newEndpoint.endpoint());</span>

                // Nothing to do
<span class="fc bfc" id="L132" title="All 2 branches covered.">                if (newEndpoint.equals(oldEndpoint))</span>
<span class="fc" id="L133">                    continue;</span>

                // Completely new range for this endpoint
<span class="fc bfc" id="L136" title="All 2 branches covered.">                if (oldEndpoint == null)</span>
                {
<span class="pc bpc" id="L138" title="3 of 4 branches missed.">                    if (toStream.isTransient() &amp;&amp; newEndpoint.isFull())</span>
<span class="nc" id="L139">                        throw new AssertionError(String.format(&quot;Need to stream %s, but only have %s which is transient and not full&quot;, newEndpoint, toStream));</span>

<span class="fc bfc" id="L141" title="All 2 branches covered.">                    for (Range&lt;Token&gt; intersection : newEndpoint.range().intersectionWith(toStream.range()))</span>
                    {
<span class="fc" id="L143">                        endpointRanges.put(newEndpoint.endpoint(), newEndpoint.decorateSubrange(intersection));</span>
<span class="fc" id="L144">                    }</span>
                }
                else
                {
<span class="fc" id="L148">                    Set&lt;Range&lt;Token&gt;&gt; subsToStream = Collections.singleton(toStream.range());</span>

                    //First subtract what we already have
<span class="pc bpc" id="L151" title="3 of 4 branches missed.">                    if (oldEndpoint.isFull() == newEndpoint.isFull() || oldEndpoint.isFull())</span>
<span class="fc" id="L152">                        subsToStream = toStream.range().subtract(oldEndpoint.range());</span>

                    //Now we only stream what is still replicated
<span class="fc" id="L155">                    subsToStream.stream()</span>
<span class="pc" id="L156">                                .flatMap(range -&gt; range.intersectionWith(newEndpoint.range()).stream())</span>
<span class="pc" id="L157">                                .forEach(tokenRange -&gt; endpointRanges.put(newEndpoint.endpoint(), newEndpoint.decorateSubrange(tokenRange)));</span>
                }
<span class="fc" id="L159">            }</span>
<span class="fc" id="L160">        }</span>
<span class="fc" id="L161">        return endpointRanges.build();</span>
    }

    public void calculateToFromStreams()
    {
<span class="fc" id="L166">        logger.debug(&quot;Current tmd: {}, Updated tmd: {}&quot;, tokenMetaClone, tokenMetaCloneAllSettled);</span>

<span class="fc bfc" id="L168" title="All 2 branches covered.">        for (String keyspace : keyspaceNames)</span>
        {
            // replication strategy of the current keyspace
<span class="fc" id="L171">            AbstractReplicationStrategy strategy = Keyspace.open(keyspace).getReplicationStrategy();</span>

<span class="fc" id="L173">            logger.info(&quot;Calculating ranges to stream and request for keyspace {}&quot;, keyspace);</span>
            //From what I have seen we only ever call this with a single token from StorageService.move(Token)
<span class="fc bfc" id="L175" title="All 2 branches covered.">            for (Token newToken : tokens)</span>
            {
<span class="fc" id="L177">                Collection&lt;Token&gt; currentTokens = tokenMetaClone.getTokens(localAddress);</span>
<span class="pc bpc" id="L178" title="2 of 4 branches missed.">                if (currentTokens.size() &gt; 1 || currentTokens.isEmpty())</span>
                {
<span class="nc" id="L180">                    throw new AssertionError(&quot;Unexpected current tokens: &quot; + currentTokens);</span>
                }

                // calculated parts of the ranges to request/stream from/to nodes in the ring
                Pair&lt;RangesAtEndpoint, RangesAtEndpoint&gt; streamAndFetchOwnRanges;

                //In the single node token move there is nothing to do and Range subtraction is broken
                //so it's easier to just identify this case up front.
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">                if (tokenMetaClone.getTopology().getDatacenterEndpoints().get(DatabaseDescriptor.getEndpointSnitch().getLocalDatacenter()).size() &gt; 1)</span>
                {
                    // getting collection of the currently used ranges by this keyspace
<span class="fc" id="L191">                    RangesAtEndpoint currentReplicas = strategy.getAddressReplicas(localAddress);</span>

                    // collection of ranges which this node will serve after move to the new token
<span class="fc" id="L194">                    RangesAtEndpoint updatedReplicas = strategy.getPendingAddressRanges(tokenMetaClone, newToken, localAddress);</span>

<span class="fc" id="L196">                    streamAndFetchOwnRanges = calculateStreamAndFetchRanges(currentReplicas, updatedReplicas);</span>
<span class="fc" id="L197">                }</span>
                else
                {
<span class="nc" id="L200">                     streamAndFetchOwnRanges = Pair.create(RangesAtEndpoint.empty(localAddress), RangesAtEndpoint.empty(localAddress));</span>
                }

<span class="fc" id="L203">                RangesByEndpoint rangesToStream = calculateRangesToStreamWithEndpoints(streamAndFetchOwnRanges.left, strategy, tokenMetaClone, tokenMetaCloneAllSettled);</span>
<span class="fc" id="L204">                logger.info(&quot;Endpoint ranges to stream to &quot; + rangesToStream);</span>

                // stream ranges
<span class="fc bfc" id="L207" title="All 2 branches covered.">                for (InetAddressAndPort address : rangesToStream.keySet())</span>
                {
<span class="fc" id="L209">                    logger.debug(&quot;Will stream range {} of keyspace {} to endpoint {}&quot;, rangesToStream.get(address), keyspace, address);</span>
<span class="fc" id="L210">                    RangesAtEndpoint ranges = rangesToStream.get(address);</span>
<span class="fc" id="L211">                    streamPlan.transferRanges(address, keyspace, ranges);</span>
<span class="fc" id="L212">                }</span>

<span class="fc" id="L214">                Multimap&lt;InetAddressAndPort, RangeStreamer.FetchReplica&gt; rangesToFetch = calculateRangesToFetchWithPreferredEndpoints(streamAndFetchOwnRanges.right, strategy, keyspace, tokenMetaClone, tokenMetaCloneAllSettled);</span>

                // stream requests
<span class="fc" id="L217">                rangesToFetch.asMap().forEach((address, sourceAndOurReplicas) -&gt; {</span>
<span class="fc" id="L218">                    RangesAtEndpoint full = sourceAndOurReplicas.stream()</span>
<span class="fc" id="L219">                            .filter(pair -&gt; pair.remote.isFull())</span>
<span class="fc" id="L220">                            .map(pair -&gt; pair.local)</span>
<span class="fc" id="L221">                            .collect(RangesAtEndpoint.collector(localAddress));</span>
<span class="fc" id="L222">                    RangesAtEndpoint trans = sourceAndOurReplicas.stream()</span>
<span class="fc" id="L223">                            .filter(pair -&gt; pair.remote.isTransient())</span>
<span class="pc" id="L224">                            .map(pair -&gt; pair.local)</span>
<span class="fc" id="L225">                            .collect(RangesAtEndpoint.collector(localAddress));</span>
<span class="fc" id="L226">                    logger.debug(&quot;Will request range {} of keyspace {} from endpoint {}&quot;, rangesToFetch.get(address), keyspace, address);</span>
<span class="fc" id="L227">                    streamPlan.requestRanges(address, keyspace, full, trans);</span>
<span class="fc" id="L228">                });</span>

<span class="fc" id="L230">                logger.debug(&quot;Keyspace {}: work map {}.&quot;, keyspace, rangesToFetch);</span>
<span class="fc" id="L231">            }</span>
<span class="fc" id="L232">        }</span>
<span class="fc" id="L233">    }</span>

    /**
     * Calculate pair of ranges to stream/fetch for given two range collections
     * (current ranges for keyspace and ranges after move to new token)
     *
     * With transient replication the added wrinkle is that if a range transitions from full to transient then
     * we need to stream the range despite the fact that we are retaining it as transient. Some replica
     * somewhere needs to transition from transient to full and we will be the source.
     *
     * If the range is transient and is transitioning to full then always fetch even if the range was already transient
     * since a transiently replicated obviously needs to fetch data to become full.
     *
     * This why there is a continue after checking for instersection because intersection is not sufficient reason
     * to do the subtraction since we might need to stream/fetch data anyways.
     *
     * @param currentRanges collection of the ranges by current token
     * @param updatedRanges collection of the ranges after token is changed
     * @return pair of ranges to stream/fetch for given current and updated range collections
     */
    public static Pair&lt;RangesAtEndpoint, RangesAtEndpoint&gt; calculateStreamAndFetchRanges(RangesAtEndpoint currentRanges, RangesAtEndpoint updatedRanges)
    {
<span class="fc" id="L255">        RangesAtEndpoint.Builder toStream = RangesAtEndpoint.builder(currentRanges.endpoint());</span>
<span class="fc" id="L256">        RangesAtEndpoint.Builder toFetch  = RangesAtEndpoint.builder(currentRanges.endpoint());</span>
<span class="fc" id="L257">        logger.debug(&quot;Calculating toStream&quot;);</span>
<span class="fc" id="L258">        computeRanges(currentRanges, updatedRanges, toStream);</span>

<span class="fc" id="L260">        logger.debug(&quot;Calculating toFetch&quot;);</span>
<span class="fc" id="L261">        computeRanges(updatedRanges, currentRanges, toFetch);</span>

<span class="fc" id="L263">        logger.debug(&quot;To stream {}&quot;, toStream);</span>
<span class="fc" id="L264">        logger.debug(&quot;To fetch {}&quot;, toFetch);</span>
<span class="fc" id="L265">        return Pair.create(toStream.build(), toFetch.build());</span>
    }

    private static void computeRanges(RangesAtEndpoint srcRanges, RangesAtEndpoint dstRanges, RangesAtEndpoint.Builder ranges)
    {
<span class="fc bfc" id="L270" title="All 2 branches covered.">        for (Replica src : srcRanges)</span>
        {
<span class="fc" id="L272">            boolean intersect = false;</span>
<span class="fc" id="L273">            RangesAtEndpoint remainder = null;</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">            for (Replica dst : dstRanges)</span>
            {
<span class="fc" id="L276">                logger.debug(&quot;Comparing {} and {}&quot;, src, dst);</span>
                // Stream the full range if there's no intersection
<span class="fc bfc" id="L278" title="All 2 branches covered.">                if (!src.intersectsOnRange(dst))</span>
<span class="fc" id="L279">                    continue;</span>

                // If we're transitioning from full to transient
<span class="pc bpc" id="L282" title="2 of 4 branches missed.">                if (src.isFull() &amp;&amp; dst.isTransient())</span>
<span class="nc" id="L283">                    continue;</span>

<span class="fc bfc" id="L285" title="All 2 branches covered.">                if (remainder == null)</span>
                {
<span class="fc" id="L287">                    remainder = src.subtractIgnoreTransientStatus(dst.range());</span>
                }
                else
                {
                    // Re-subtract ranges to avoid overstreaming in cases when the single range is split or merged
<span class="fc" id="L292">                    RangesAtEndpoint.Builder newRemainder = new RangesAtEndpoint.Builder(remainder.endpoint());</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">                    for (Replica replica : remainder)</span>
<span class="fc" id="L294">                        newRemainder.addAll(replica.subtractIgnoreTransientStatus(dst.range()));</span>
<span class="fc" id="L295">                    remainder = newRemainder.build();</span>
                }
<span class="fc" id="L297">                intersect = true;</span>
<span class="fc" id="L298">            }</span>

<span class="fc bfc" id="L300" title="All 2 branches covered.">            if (!intersect)</span>
            {
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">                assert remainder == null;</span>
<span class="fc" id="L303">                logger.debug(&quot;    Doesn't intersect adding {}&quot;, src);</span>
<span class="fc" id="L304">                ranges.add(src); // should stream whole old range</span>
            }
            else
            {
<span class="fc" id="L308">                ranges.addAll(remainder);</span>
<span class="fc" id="L309">                logger.debug(&quot;    Intersects adding {}&quot;, remainder);</span>
            }
<span class="fc" id="L311">        }</span>
<span class="fc" id="L312">    }</span>

    public Future&lt;StreamState&gt; stream()
    {
<span class="fc" id="L316">        return streamPlan.execute();</span>
    }

    public boolean streamsNeeded()
    {
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">        return !streamPlan.isEmpty();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>