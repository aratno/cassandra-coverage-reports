<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Expression.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.index.sai.plan</a> &gt; <span class="el_source">Expression.java</span></div><h1>Expression.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.index.sai.plan;

import java.nio.ByteBuffer;
import java.util.Objects;

import com.google.common.annotations.VisibleForTesting;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.cql3.Operator;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.index.sai.IndexContext;
import org.apache.cassandra.index.sai.analyzer.AbstractAnalyzer;
import org.apache.cassandra.index.sai.utils.TypeUtil;

public class Expression
{
<span class="fc" id="L37">    private static final Logger logger = LoggerFactory.getLogger(Expression.class);</span>

<span class="fc" id="L39">    public enum IndexOperator</span>
    {
<span class="fc" id="L41">        EQ, RANGE, CONTAINS_KEY, CONTAINS_VALUE;</span>

        public static IndexOperator valueOf(Operator operator)
        {
<span class="pc bpc" id="L45" title="3 of 5 branches missed.">            switch (operator)</span>
            {
                case EQ:
<span class="fc" id="L48">                    return EQ;</span>

                case CONTAINS:
<span class="nc" id="L51">                    return CONTAINS_VALUE; // non-frozen map: value contains term;</span>

                case CONTAINS_KEY:
<span class="nc" id="L54">                    return CONTAINS_KEY; // non-frozen map: value contains key term;</span>

                case LT:
                case GT:
                case LTE:
                case GTE:
<span class="fc" id="L60">                    return RANGE;</span>

                default:
<span class="nc" id="L63">                    return null;</span>
            }
        }

        public boolean isEquality()
        {
<span class="pc bpc" id="L69" title="2 of 6 branches missed.">            return this == EQ || this == CONTAINS_KEY || this == CONTAINS_VALUE;</span>
        }

        public boolean isEqualityOrRange()
        {
<span class="pc bpc" id="L74" title="1 of 4 branches missed.">            return isEquality() || this == RANGE;</span>
        }
    }

    public final AbstractAnalyzer.AnalyzerFactory analyzerFactory;

    public final IndexContext context;
    public final AbstractType&lt;?&gt; validator;

    @VisibleForTesting
    protected IndexOperator operator;

    public Bound lower, upper;
    // The upperInclusive and lowerInclusive flags are maintained separately to the inclusive flags
    // in the upper and lower bounds because the upper and lower bounds have their inclusivity relaxed
    // if the datatype being filtered is rounded in the index. These flags are used in the post-filtering
    // process to remove values equal to the bounds.
    public boolean upperInclusive, lowerInclusive;

    public Expression(IndexContext indexContext)
<span class="fc" id="L94">    {</span>
<span class="fc" id="L95">        this.context = indexContext;</span>
<span class="fc" id="L96">        this.analyzerFactory = indexContext.getAnalyzerFactory();</span>
<span class="fc" id="L97">        this.validator = indexContext.getValidator();</span>
<span class="fc" id="L98">    }</span>

    /**
     * This adds an operation to the current {@link Expression} instance and
     * returns the current instance.
     *
     * @param op the CQL3 operation
     * @param value the expression value
     * @return the current expression with the added operation
     */
    public Expression add(Operator op, ByteBuffer value)
    {
        boolean lowerInclusive, upperInclusive;
        // If the type supports rounding then we need to make sure that index
        // range search is always inclusive, otherwise we run the risk of
        // missing values that are within the exclusive range but are rejected
        // because their rounded value is the same as the value being queried.
<span class="fc" id="L115">        lowerInclusive = upperInclusive = TypeUtil.supportsRounding(validator);</span>
<span class="pc bpc" id="L116" title="3 of 6 branches missed.">        switch (op)</span>
        {
            case EQ:
            case CONTAINS:
            case CONTAINS_KEY:
<span class="fc" id="L121">                lower = new Bound(value, validator, true);</span>
<span class="fc" id="L122">                upper = lower;</span>
<span class="fc" id="L123">                operator = IndexOperator.valueOf(op);</span>
<span class="fc" id="L124">                break;</span>

            case LTE:
<span class="nc bnc" id="L127" title="All 2 branches missed.">                if (context.getDefinition().isReversedType())</span>
                {
<span class="nc" id="L129">                    this.lowerInclusive = true;</span>
<span class="nc" id="L130">                    lowerInclusive = true;</span>
                }
                else
                {
<span class="nc" id="L134">                    this.upperInclusive = true;</span>
<span class="nc" id="L135">                    upperInclusive = true;</span>
                }
            case LT:
<span class="fc" id="L138">                operator = IndexOperator.RANGE;</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">                if (context.getDefinition().isReversedType())</span>
<span class="nc" id="L140">                    lower = new Bound(value, validator, lowerInclusive);</span>
                else
<span class="fc" id="L142">                    upper = new Bound(value, validator, upperInclusive);</span>
<span class="fc" id="L143">                break;</span>

            case GTE:
<span class="nc bnc" id="L146" title="All 2 branches missed.">                if (context.getDefinition().isReversedType())</span>
                {
<span class="nc" id="L148">                    this.upperInclusive = true;</span>
<span class="nc" id="L149">                    upperInclusive = true;</span>
                }
                else
                {
<span class="nc" id="L153">                    this.lowerInclusive = true;</span>
<span class="nc" id="L154">                    lowerInclusive = true;</span>
                }
            case GT:
<span class="fc" id="L157">                operator = IndexOperator.RANGE;</span>
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">                if (context.getDefinition().isReversedType())</span>
<span class="nc" id="L159">                    upper = new Bound(value, validator, upperInclusive);</span>
                else
<span class="fc" id="L161">                    lower = new Bound(value, validator, lowerInclusive);</span>
                break;
        }

<span class="pc bpc" id="L165" title="1 of 2 branches missed.">        assert operator != null;</span>

<span class="fc" id="L167">        return this;</span>
    }

    /**
     * Used in post-filtering to determine is an indexed value matches the expression
     */
    public boolean isSatisfiedBy(ByteBuffer columnValue)
    {
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">        if (!TypeUtil.isValid(columnValue, validator))</span>
        {
<span class="nc" id="L177">            logger.error(context.logMessage(&quot;Value is not valid for indexed column {} with {}&quot;), context.getColumnName(), validator);</span>
<span class="nc" id="L178">            return false;</span>
        }

<span class="fc" id="L181">        Value value = new Value(columnValue, validator);</span>

<span class="pc bpc" id="L183" title="1 of 2 branches missed.">        if (lower != null)</span>
        {
            // suffix check
<span class="fc bfc" id="L186" title="All 2 branches covered.">            if (TypeUtil.isLiteral(validator))</span>
<span class="fc" id="L187">                return validateStringValue(value.raw, lower.value.raw);</span>
            else
            {
                // range or (not-)equals - (mainly) for numeric values
<span class="fc" id="L191">                int cmp = TypeUtil.comparePostFilter(lower.value, value, validator);</span>

                // in case of EQ lower == upper
<span class="pc bpc" id="L194" title="2 of 6 branches missed.">                if (operator == IndexOperator.EQ || operator == IndexOperator.CONTAINS_KEY || operator == IndexOperator.CONTAINS_VALUE)</span>
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">                    return cmp == 0;</span>

<span class="pc bpc" id="L197" title="4 of 6 branches missed.">                if (cmp &gt; 0 || (cmp == 0 &amp;&amp; !lowerInclusive))</span>
<span class="nc" id="L198">                    return false;</span>
            }
        }

<span class="pc bpc" id="L202" title="1 of 4 branches missed.">        if (upper != null &amp;&amp; lower != upper)</span>
        {
            // string (prefix or suffix) check
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">            if (TypeUtil.isLiteral(validator))</span>
<span class="nc" id="L206">                return validateStringValue(value.raw, upper.value.raw);</span>
            else
            {
                // range - mainly for numeric values
<span class="fc" id="L210">                int cmp = TypeUtil.comparePostFilter(upper.value, value, validator);</span>
<span class="pc bpc" id="L211" title="5 of 6 branches missed.">                return (cmp &gt; 0 || (cmp == 0 &amp;&amp; upperInclusive));</span>
            }
        }

<span class="fc" id="L215">        return true;</span>
    }

    private boolean validateStringValue(ByteBuffer columnValue, ByteBuffer requestedValue)
    {
<span class="fc" id="L220">        AbstractAnalyzer analyzer = analyzerFactory.create();</span>
<span class="fc" id="L221">        analyzer.reset(columnValue.duplicate());</span>
        try
        {
<span class="fc bfc" id="L224" title="All 2 branches covered.">            while (analyzer.hasNext())</span>
            {
<span class="fc" id="L226">                final ByteBuffer term = analyzer.next();</span>

<span class="fc" id="L228">                boolean isMatch = false;</span>
<span class="pc bpc" id="L229" title="2 of 3 branches missed.">                switch (operator)</span>
                {
                    case EQ:
                    case CONTAINS_KEY:
                    case CONTAINS_VALUE:
<span class="fc bfc" id="L234" title="All 2 branches covered.">                        isMatch = validator.compare(term, requestedValue) == 0;</span>
<span class="fc" id="L235">                        break;</span>
                    case RANGE:
<span class="nc bnc" id="L237" title="All 4 branches missed.">                        isMatch = isLowerSatisfiedBy(term) &amp;&amp; isUpperSatisfiedBy(term);</span>
                        break;
                }

<span class="fc bfc" id="L241" title="All 2 branches covered.">                if (isMatch)</span>
<span class="fc" id="L242">                    return true;</span>
<span class="fc" id="L243">            }</span>
<span class="fc" id="L244">            return false;</span>
        }
        finally
        {
<span class="fc" id="L248">            analyzer.end();</span>
        }
    }

    public IndexOperator getOp()
    {
<span class="fc" id="L254">        return operator;</span>
    }

    private boolean hasLower()
    {
<span class="nc bnc" id="L259" title="All 2 branches missed.">        return lower != null;</span>
    }

    private boolean hasUpper()
    {
<span class="nc bnc" id="L264" title="All 2 branches missed.">        return upper != null;</span>
    }

    private boolean isLowerSatisfiedBy(ByteBuffer value)
    {
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (!hasLower())</span>
<span class="nc" id="L270">            return true;</span>

<span class="nc" id="L272">        int cmp = validator.compare(value, lower.value.raw);</span>
<span class="nc bnc" id="L273" title="All 6 branches missed.">        return cmp &gt; 0 || cmp == 0 &amp;&amp; lower.inclusive;</span>
    }

    private boolean isUpperSatisfiedBy(ByteBuffer value)
    {
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (!hasUpper())</span>
<span class="nc" id="L279">            return true;</span>

<span class="nc" id="L281">        int cmp = validator.compare(value, upper.value.raw);</span>
<span class="nc bnc" id="L282" title="All 6 branches missed.">        return cmp &lt; 0 || cmp == 0 &amp;&amp; upper.inclusive;</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L288">        return String.format(&quot;Expression{name: %s, op: %s, lower: (%s, %s), upper: (%s, %s)}&quot;,</span>
<span class="nc" id="L289">                             context.getColumnName(),</span>
                             operator,
<span class="nc bnc" id="L291" title="All 6 branches missed.">                             lower == null ? &quot;null&quot; : validator.getString(lower.value.raw),</span>
<span class="nc" id="L292">                             lower != null &amp;&amp; lower.inclusive,</span>
<span class="nc bnc" id="L293" title="All 6 branches missed.">                             upper == null ? &quot;null&quot; : validator.getString(upper.value.raw),</span>
<span class="nc" id="L294">                             upper != null &amp;&amp; upper.inclusive);</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L300">        return new HashCodeBuilder().append(context.getColumnName())</span>
<span class="nc" id="L301">                                    .append(operator)</span>
<span class="nc" id="L302">                                    .append(validator)</span>
<span class="nc" id="L303">                                    .append(lower).append(upper).build();</span>
    }

    @Override
    public boolean equals(Object other)
    {
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">        if (!(other instanceof Expression))</span>
<span class="nc" id="L310">            return false;</span>

<span class="pc bpc" id="L312" title="1 of 2 branches missed.">        if (this == other)</span>
<span class="fc" id="L313">            return true;</span>

<span class="nc" id="L315">        Expression o = (Expression) other;</span>

<span class="nc bnc" id="L317" title="All 2 branches missed.">        return Objects.equals(context.getColumnName(), o.context.getColumnName())</span>
<span class="nc bnc" id="L318" title="All 4 branches missed.">               &amp;&amp; validator.equals(o.validator)</span>
               &amp;&amp; operator == o.operator
<span class="nc bnc" id="L320" title="All 2 branches missed.">               &amp;&amp; Objects.equals(lower, o.lower)</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">               &amp;&amp; Objects.equals(upper, o.upper);</span>
    }

    /**
     * A representation of a column value in its raw and encoded form.
     */
    public static class Value
    {
        public final ByteBuffer raw;
        public final ByteBuffer encoded;

        public Value(ByteBuffer value, AbstractType&lt;?&gt; type)
<span class="fc" id="L333">        {</span>
<span class="fc" id="L334">            this.raw = value;</span>
<span class="fc" id="L335">            this.encoded = TypeUtil.asIndexBytes(value, type);</span>
<span class="fc" id="L336">        }</span>

        @Override
        public boolean equals(Object other)
        {
<span class="nc bnc" id="L341" title="All 2 branches missed.">            if (!(other instanceof Value))</span>
<span class="nc" id="L342">                return false;</span>

<span class="nc" id="L344">            Value o = (Value) other;</span>
<span class="nc bnc" id="L345" title="All 4 branches missed.">            return raw.equals(o.raw) &amp;&amp; encoded.equals(o.encoded);</span>
        }

        @Override
        public int hashCode()
        {
<span class="nc" id="L351">            HashCodeBuilder builder = new HashCodeBuilder();</span>
<span class="nc" id="L352">            builder.append(raw);</span>
<span class="nc" id="L353">            builder.append(encoded);</span>
<span class="nc" id="L354">            return builder.toHashCode();</span>
        }
    }

    public static class Bound
    {
        public final Value value;
        public final boolean inclusive;

        public Bound(ByteBuffer value, AbstractType&lt;?&gt; type, boolean inclusive)
<span class="fc" id="L364">        {</span>
<span class="fc" id="L365">            this.value = new Value(value, type);</span>
<span class="fc" id="L366">            this.inclusive = inclusive;</span>
<span class="fc" id="L367">        }</span>

        @Override
        public boolean equals(Object other)
        {
<span class="nc bnc" id="L372" title="All 2 branches missed.">            if (!(other instanceof Bound))</span>
<span class="nc" id="L373">                return false;</span>

<span class="nc" id="L375">            Bound o = (Bound) other;</span>
<span class="nc bnc" id="L376" title="All 4 branches missed.">            return value.equals(o.value) &amp;&amp; inclusive == o.inclusive;</span>
        }

        @Override
        public int hashCode()
        {
<span class="nc" id="L382">            HashCodeBuilder builder = new HashCodeBuilder();</span>
<span class="nc" id="L383">            builder.append(value);</span>
<span class="nc" id="L384">            builder.append(inclusive);</span>
<span class="nc" id="L385">            return builder.toHashCode();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>