<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PaxosRows.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.service.paxos.uncommitted</a> &gt; <span class="el_source">PaxosRows.java</span></div><h1>PaxosRows.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.service.paxos.uncommitted;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.UUID;

import javax.annotation.Nullable;

import com.google.common.collect.Lists;

import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.SystemKeyspace;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.marshal.BytesType;
import org.apache.cassandra.db.marshal.Int32Type;
import org.apache.cassandra.db.marshal.TimeUUIDType;
import org.apache.cassandra.db.marshal.UUIDType;
import org.apache.cassandra.db.marshal.ValueAccessor;
import org.apache.cassandra.db.partitions.PartitionUpdate;
import org.apache.cassandra.db.partitions.UnfilteredPartitionIterator;
import org.apache.cassandra.db.rows.Cell;
import org.apache.cassandra.db.rows.DeserializationHelper;
import org.apache.cassandra.db.rows.Row;
import org.apache.cassandra.db.rows.UnfilteredRowIterator;
import org.apache.cassandra.net.MessagingService;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.SchemaConstants;
import org.apache.cassandra.schema.TableId;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.service.paxos.Ballot;
import org.apache.cassandra.service.paxos.Commit;
import org.apache.cassandra.service.paxos.Commit.Accepted;
import org.apache.cassandra.service.paxos.Commit.AcceptedWithTTL;
import org.apache.cassandra.service.paxos.Commit.Committed;
import org.apache.cassandra.service.paxos.Commit.CommittedWithTTL;
import org.apache.cassandra.utils.AbstractIterator;
import org.apache.cassandra.utils.CloseableIterator;
import org.apache.cassandra.utils.JVMStabilityInspector;

import static org.apache.cassandra.db.partitions.PartitionUpdate.PartitionUpdateSerializer.*;
import static org.apache.cassandra.service.paxos.Commit.isAfter;
import static org.apache.cassandra.service.paxos.Commit.latest;

@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
public class PaxosRows
{
<span class="fc" id="L65">    private static final ColumnMetadata WRITE_PROMISE = paxosColumn(&quot;in_progress_ballot&quot;, TimeUUIDType.instance);</span>
<span class="fc" id="L66">    private static final ColumnMetadata READ_PROMISE = paxosColumn(&quot;in_progress_read_ballot&quot;, TimeUUIDType.instance);</span>
<span class="fc" id="L67">    private static final ColumnMetadata PROPOSAL = paxosColumn(&quot;proposal_ballot&quot;, TimeUUIDType.instance);</span>
<span class="fc" id="L68">    private static final ColumnMetadata PROPOSAL_UPDATE = paxosColumn(&quot;proposal&quot;, BytesType.instance);</span>
<span class="fc" id="L69">    private static final ColumnMetadata PROPOSAL_VERSION = paxosColumn(&quot;proposal_version&quot;, Int32Type.instance);</span>
<span class="fc" id="L70">    private static final ColumnMetadata COMMIT = paxosColumn(&quot;most_recent_commit_at&quot;, TimeUUIDType.instance);</span>
<span class="fc" id="L71">    private static final ColumnMetadata COMMIT_UPDATE = paxosColumn(&quot;most_recent_commit&quot;, BytesType.instance);</span>
<span class="fc" id="L72">    private static final ColumnMetadata COMMIT_VERSION = paxosColumn(&quot;most_recent_commit_version&quot;, Int32Type.instance);</span>

    private PaxosRows() {}

    private static ColumnMetadata paxosColumn(String name, AbstractType&lt;?&gt; type)
    {
<span class="fc" id="L78">        return ColumnMetadata.regularColumn(SchemaConstants.SYSTEM_KEYSPACE_NAME, SystemKeyspace.PAXOS, name, type);</span>
    }

    public static Ballot getPromise(Row row)
    {
<span class="fc" id="L83">        return getBallot(row, READ_PROMISE, Ballot.none());</span>
    }

    public static Ballot getWritePromise(Row row)
    {
<span class="fc" id="L88">        return getBallot(row, WRITE_PROMISE, Ballot.none());</span>
    }

    public static Accepted getAccepted(Row row)
    {
<span class="fc" id="L93">        Cell ballotCell = row.getCell(PROPOSAL);</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">        if (ballotCell == null)</span>
<span class="fc" id="L95">            return null;</span>

<span class="fc" id="L97">        Ballot ballot = ballotCell.accessor().toBallot(ballotCell.value());</span>
<span class="fc" id="L98">        int version = getInt(row, PROPOSAL_VERSION, MessagingService.VERSION_40);</span>
<span class="fc" id="L99">        PartitionUpdate update = getUpdate(row, PROPOSAL_UPDATE, version);</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">        return ballotCell.isExpiring()</span>
<span class="fc" id="L101">               ? new AcceptedWithTTL(ballot, update, ballotCell.localDeletionTime())</span>
<span class="fc" id="L102">               : new Accepted(ballot, update);</span>
    }

    public static Committed getCommitted(TableMetadata metadata, DecoratedKey partitionKey, Row row)
    {
<span class="fc" id="L107">        Cell ballotCell = row.getCell(COMMIT);</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">        if (ballotCell == null)</span>
<span class="fc" id="L109">            return Committed.none(partitionKey, metadata);</span>

<span class="fc" id="L111">        Ballot ballot = ballotCell.accessor().toBallot(ballotCell.value());</span>
<span class="fc" id="L112">        int version = getInt(row, COMMIT_VERSION, MessagingService.VERSION_40);</span>
<span class="fc" id="L113">        PartitionUpdate update = getUpdate(row, COMMIT_UPDATE, version);</span>
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        return ballotCell.isExpiring()</span>
<span class="fc" id="L115">               ? new CommittedWithTTL(ballot, update, ballotCell.localDeletionTime())</span>
<span class="nc" id="L116">               : new Committed(ballot, update);</span>
    }

    public static TableId getTableId(Row row)
    {
<span class="fc" id="L121">        return TableId.fromUUID(UUIDType.instance.compose(row.clustering().get(0), (ValueAccessor)row.clustering().accessor()));</span>
    }

    public static UUID getTableUuid(Row row)
    {
<span class="fc" id="L126">        return UUIDType.instance.compose(row.clustering().get(0), (ValueAccessor)row.clustering().accessor());</span>
    }

    private static int getInt(Row row, ColumnMetadata cmeta, @SuppressWarnings(&quot;SameParameterValue&quot;) int ifNull)
    {
<span class="fc" id="L131">        Cell cell = row.getCell(cmeta);</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if (cell == null)</span>
<span class="nc" id="L133">            return ifNull;</span>
<span class="fc" id="L134">        return Int32Type.instance.compose(cell.value(), cell.accessor());</span>
    }

    private static PartitionUpdate getUpdate(Row row, ColumnMetadata cmeta, int version)
    {
<span class="fc" id="L139">        Cell cell = row.getCell(cmeta);</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">        if (cell == null)</span>
<span class="nc" id="L141">            throw new IllegalStateException();</span>

<span class="fc" id="L143">        return PartitionUpdate.fromBytes(cell.buffer(), version);</span>
    }

    private static Ballot getBallot(Row row, ColumnMetadata cmeta)
    {
<span class="fc" id="L148">        return getBallot(row, cmeta, null);</span>
    }

    private static Ballot getBallot(Row row, ColumnMetadata cmeta, Ballot ifNull)
    {
<span class="fc" id="L153">        Cell cell = row.getCell(cmeta);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">        if (cell == null)</span>
<span class="fc" id="L155">            return ifNull;</span>
<span class="fc" id="L156">        return cell.accessor().toBallot(cell.value());</span>
    }

    private static boolean proposalIsEmpty(Row row, DecoratedKey key)
    {
        try
        {
<span class="fc" id="L163">            Cell proposalVersionCell = row.getCell(PROPOSAL_VERSION);</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">            if (proposalVersionCell == null)</span>
<span class="nc" id="L165">                return true;</span>
<span class="fc" id="L166">            Integer proposalVersion = Int32Type.instance.compose(proposalVersionCell.value(), proposalVersionCell.accessor());</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">            if (proposalVersion == null)</span>
<span class="nc" id="L168">                return true;</span>

<span class="fc" id="L170">            Cell proposal = row.getCell(PROPOSAL_UPDATE);</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">            if (proposal == null)</span>
<span class="nc" id="L172">                return true;</span>

<span class="fc" id="L174">            ByteBuffer proposalValue = proposal.buffer();</span>
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">            if (!proposalValue.hasRemaining())</span>
<span class="nc" id="L176">                return true;</span>

<span class="fc" id="L178">            return isEmpty(proposalValue, DeserializationHelper.Flag.LOCAL, key);</span>
        }
<span class="nc" id="L180">        catch (IOException e)</span>
        {
<span class="nc" id="L182">            JVMStabilityInspector.inspectThrowable(e);</span>
<span class="nc" id="L183">            throw new RuntimeException(e);</span>
        }
    }

    private static long getTimestamp(Row row, ColumnMetadata cmeta)
    {
<span class="fc" id="L189">        Cell cell = row.getCell(cmeta);</span>
<span class="fc bfc" id="L190" title="All 4 branches covered.">        if (cell == null || cell.valueSize() == 0)</span>
<span class="fc" id="L191">            return Long.MIN_VALUE;</span>
<span class="fc" id="L192">        return cell.timestamp();</span>
    }

    static PaxosKeyState getCommitState(DecoratedKey key, Row row, TableId targetTableId)
    {
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (row == null)</span>
<span class="nc" id="L198">            return null;</span>

<span class="fc" id="L200">        UUID tableUuid = getTableUuid(row);</span>
<span class="pc bpc" id="L201" title="1 of 4 branches missed.">        if (targetTableId != null &amp;&amp; !targetTableId.asUUID().equals(tableUuid))</span>
<span class="nc" id="L202">            return null;</span>

<span class="fc" id="L204">        Ballot promise = latest(getBallot(row, WRITE_PROMISE), getBallot(row, READ_PROMISE));</span>
<span class="fc" id="L205">        Ballot proposal = getBallot(row, PROPOSAL);</span>
<span class="fc" id="L206">        Ballot commit = getBallot(row, COMMIT);</span>

<span class="fc" id="L208">        Ballot inProgress = null;</span>
<span class="fc" id="L209">        Ballot committed = null;</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">        if (isAfter(promise, proposal))</span>
        {
<span class="fc bfc" id="L212" title="All 2 branches covered.">            if (isAfter(promise, commit))</span>
<span class="fc" id="L213">                inProgress = promise;</span>
            else
<span class="fc" id="L215">                committed = commit;</span>
        }
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">        else if (isAfter(proposal, commit))</span>
        {
<span class="fc bfc" id="L219" title="All 2 branches covered.">            if (proposalIsEmpty(row, key))</span>
<span class="fc" id="L220">                committed = proposal;</span>
            else
<span class="fc" id="L222">                inProgress = proposal;</span>
        }
        else
        {
<span class="nc" id="L226">            committed = commit;</span>
        }

<span class="fc" id="L229">        TableId tableId = TableId.fromUUID(tableUuid);</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">        return inProgress != null ?</span>
<span class="fc" id="L231">               new PaxosKeyState(tableId, key, inProgress, false) :</span>
<span class="fc" id="L232">               new PaxosKeyState(tableId, key, committed, true);</span>
    }

    private static class PaxosMemtableToKeyStateIterator extends AbstractIterator&lt;PaxosKeyState&gt; implements CloseableIterator&lt;PaxosKeyState&gt;
    {
        private final UnfilteredPartitionIterator partitions;
        private UnfilteredRowIterator partition;
        private final @Nullable TableId filterByTableId; // if unset, return records for all tables

        private PaxosMemtableToKeyStateIterator(UnfilteredPartitionIterator partitions, TableId filterByTableId)
<span class="fc" id="L242">        {</span>
<span class="fc" id="L243">            this.partitions = partitions;</span>
<span class="fc" id="L244">            this.filterByTableId = filterByTableId;</span>
<span class="fc" id="L245">        }</span>

        protected PaxosKeyState computeNext()
        {
            while (true)
            {
<span class="fc bfc" id="L251" title="All 4 branches covered.">                if (partition != null &amp;&amp; partition.hasNext())</span>
                {
<span class="fc" id="L253">                    PaxosKeyState commitState = PaxosRows.getCommitState(partition.partitionKey(),</span>
<span class="fc" id="L254">                                                                         (Row) partition.next(),</span>
                                                                         filterByTableId);
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">                    if (commitState == null)</span>
<span class="nc" id="L257">                        continue;</span>

<span class="fc" id="L259">                    return commitState;</span>
                }
<span class="fc bfc" id="L261" title="All 2 branches covered.">                else if (partition != null)</span>
                {
<span class="fc" id="L263">                    partition.close();</span>
<span class="fc" id="L264">                    partition = null;</span>
                }

<span class="fc bfc" id="L267" title="All 2 branches covered.">                if (partitions.hasNext())</span>
                {
<span class="fc" id="L269">                    partition = partitions.next();</span>
                }
                else
                {
<span class="fc" id="L273">                    partitions.close();</span>
<span class="fc" id="L274">                    return endOfData();</span>
                }
            }
        }

        public void close()
        {
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">            if (partition != null)</span>
<span class="nc" id="L282">                partition.close();</span>
<span class="fc" id="L283">            partitions.close();</span>
<span class="fc" id="L284">        }</span>
    }

    static CloseableIterator&lt;PaxosKeyState&gt; toIterator(UnfilteredPartitionIterator partitions, TableId filterBytableId, boolean materializeLazily)
    {
<span class="fc" id="L289">        CloseableIterator&lt;PaxosKeyState&gt; iter = new PaxosMemtableToKeyStateIterator(partitions, filterBytableId);</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">        if (materializeLazily)</span>
<span class="fc" id="L291">            return iter;</span>

        try
        {
            // eagerly materialize key states for repairs so we're not referencing memtables for the entire repair
<span class="fc" id="L296">            return CloseableIterator.wrap(Lists.newArrayList(iter).iterator());</span>
        }
        finally
        {
<span class="fc" id="L300">            iter.close();</span>
        }
    }

    public static Ballot getHighBallot(Row row, Ballot current)
    {
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">        long maxUnixMicros = current != null ? current.unixMicros() : Long.MIN_VALUE;</span>
<span class="fc" id="L307">        ColumnMetadata maxCol = null;</span>

<span class="fc" id="L309">        long inProgressRead = getTimestamp(row, READ_PROMISE);</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">        if (inProgressRead &gt; maxUnixMicros)</span>
        {
<span class="fc" id="L312">            maxUnixMicros = inProgressRead;</span>
<span class="fc" id="L313">            maxCol = READ_PROMISE;</span>
        }

<span class="fc" id="L316">        long inProgressWrite = getTimestamp(row, WRITE_PROMISE);</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">        if (inProgressWrite &gt; maxUnixMicros)</span>
        {
<span class="fc" id="L319">            maxUnixMicros = inProgressWrite;</span>
<span class="fc" id="L320">            maxCol = WRITE_PROMISE;</span>
        }

<span class="fc" id="L323">        long proposal = getTimestamp(row, PROPOSAL);</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">        if (proposal &gt; maxUnixMicros)</span>
        {
<span class="fc" id="L326">            maxUnixMicros = proposal;</span>
<span class="fc" id="L327">            maxCol = PROPOSAL;</span>
        }

<span class="fc" id="L330">        long commit = getTimestamp(row, COMMIT);</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">        if (commit &gt; maxUnixMicros)</span>
<span class="fc" id="L332">            maxCol = COMMIT;</span>

<span class="fc bfc" id="L334" title="All 2 branches covered.">        return maxCol == null ? current : getBallot(row, maxCol);</span>
    }

    public static boolean hasBallotBeforeOrEqualTo(Row row, Ballot ballot)
    {
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">        return !Commit.isAfter(ballot, getBallot(row, WRITE_PROMISE))</span>
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">            &amp;&amp; !Commit.isAfter(ballot, getBallot(row, READ_PROMISE))</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">            &amp;&amp; !Commit.isAfter(ballot, getBallot(row, PROPOSAL))</span>
<span class="pc bnc" id="L342" title="All 2 branches missed.">            &amp;&amp; !Commit.isAfter(ballot, getBallot(row, COMMIT));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>