<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataStorageSpec.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.config</a> &gt; <span class="el_source">DataStorageSpec.java</span></div><h1>DataStorageSpec.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.config;

import java.util.Arrays;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import com.google.common.primitives.Ints;

import static org.apache.cassandra.config.DataStorageSpec.DataStorageUnit.BYTES;
import static org.apache.cassandra.config.DataStorageSpec.DataStorageUnit.KIBIBYTES;
import static org.apache.cassandra.config.DataStorageSpec.DataStorageUnit.MEBIBYTES;

/**
 * Represents an amount of data storage. Wrapper class for Cassandra configuration parameters, providing to the
 * users the opportunity to be able to provide config with a unit of their choice in cassandra.yaml as per the available
 * options. (CASSANDRA-15234)
 */
public abstract class DataStorageSpec
{
    /**
     * The Regexp used to parse the storage provided as String.
     */
<span class="fc" id="L42">    private static final Pattern UNITS_PATTERN = Pattern.compile(&quot;^(\\d+)(GiB|MiB|KiB|B)$&quot;);</span>

    private final long quantity;

    private final DataStorageUnit unit;

    private DataStorageSpec(long quantity, DataStorageUnit unit, DataStorageUnit minUnit, long max, String value)
<span class="fc" id="L49">    {</span>
<span class="fc" id="L50">        this.quantity = quantity;</span>
<span class="fc" id="L51">        this.unit = unit;</span>

<span class="fc" id="L53">        validateMinUnit(unit, minUnit, value);</span>
<span class="fc" id="L54">        validateQuantity(quantity, unit, minUnit, max);</span>
<span class="fc" id="L55">    }</span>

    private DataStorageSpec(String value, DataStorageUnit minUnit)
<span class="fc" id="L58">    {</span>
        //parse the string field value
<span class="fc" id="L60">        Matcher matcher = UNITS_PATTERN.matcher(value);</span>

<span class="pc bpc" id="L62" title="1 of 2 branches missed.">        if (matcher.find())</span>
        {
<span class="fc" id="L64">            quantity = Long.parseLong(matcher.group(1));</span>
<span class="fc" id="L65">            unit = DataStorageUnit.fromSymbol(matcher.group(2));</span>

            // this constructor is used only by extended classes for min unit; upper bound and min unit are guarded there accordingly
        }
        else
        {
<span class="nc" id="L71">            throw new IllegalArgumentException(&quot;Invalid data storage: &quot; + value + &quot; Accepted units:&quot; + acceptedUnits(minUnit) +</span>
                                               &quot; where case matters and only non-negative values are accepted&quot;);
        }
<span class="fc" id="L74">    }</span>

    private DataStorageSpec(String value, DataStorageUnit minUnit, long max)
    {
<span class="fc" id="L78">        this(value, minUnit);</span>

<span class="fc" id="L80">        validateMinUnit(unit, minUnit, value);</span>
<span class="fc" id="L81">        validateQuantity(value, quantity(), unit(), minUnit, max);</span>
<span class="fc" id="L82">    }</span>

    private static void validateMinUnit(DataStorageUnit sourceUnit, DataStorageUnit minUnit, String value)
    {
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">        if (sourceUnit.compareTo(minUnit) &lt; 0)</span>
<span class="nc" id="L87">            throw new IllegalArgumentException(String.format(&quot;Invalid data storage: %s Accepted units:%s&quot;, value, acceptedUnits(minUnit)));</span>
<span class="fc" id="L88">    }</span>

    private static String acceptedUnits(DataStorageUnit minUnit)
    {
<span class="nc" id="L92">        DataStorageUnit[] units = DataStorageUnit.values();</span>
<span class="nc" id="L93">        return Arrays.toString(Arrays.copyOfRange(units, minUnit.ordinal(), units.length));</span>
    }

    private static void validateQuantity(String value, long quantity, DataStorageUnit sourceUnit, DataStorageUnit minUnit, long max)
    {
        // no need to validate for negatives as they are not allowed at first place from the regex

<span class="pc bpc" id="L100" title="1 of 2 branches missed.">        if (minUnit.convert(quantity, sourceUnit) &gt;= max)</span>
<span class="nc" id="L101">            throw new IllegalArgumentException(&quot;Invalid data storage: &quot; + value + &quot;. It shouldn't be more than &quot; +</span>
<span class="nc" id="L102">                                               (max - 1) + &quot; in &quot; + minUnit.name().toLowerCase());</span>
<span class="fc" id="L103">    }</span>

    private static void validateQuantity(long quantity, DataStorageUnit sourceUnit, DataStorageUnit minUnit, long max)
    {
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">        if (quantity &lt; 0)</span>
<span class="nc" id="L108">            throw new IllegalArgumentException(&quot;Invalid data storage: value must be non-negative&quot;);</span>

<span class="pc bpc" id="L110" title="1 of 2 branches missed.">        if (minUnit.convert(quantity, sourceUnit) &gt;= max)</span>
<span class="nc" id="L111">            throw new IllegalArgumentException(String.format(&quot;Invalid data storage: %d %s. It shouldn't be more than %d in %s&quot;,</span>
<span class="nc" id="L112">                                                             quantity, sourceUnit.name().toLowerCase(),</span>
<span class="nc" id="L113">                                                             max - 1, minUnit.name().toLowerCase()));</span>
<span class="fc" id="L114">    }</span>

    // get vs no-get prefix is not consistent in the code base, but for classes involved with config parsing, it is
    // imporant to be explicit about get/set as this changes how parsing is done; this class is a data-type, so is
    // not nested, having get/set can confuse parsing thinking this is a nested type
    /**
     * @return the data storage quantity.
     */
    public long quantity()
    {
<span class="fc" id="L124">        return quantity;</span>
    }

    /**
     * @return the data storage unit.
     */
    public DataStorageUnit unit()
    {
<span class="fc" id="L132">        return unit;</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L138">        return Objects.hash(unit.toKibibytes(quantity));</span>
    }

    @Override
    public boolean equals(Object obj)
    {
<span class="nc bnc" id="L144" title="All 2 branches missed.">        if (this == obj)</span>
<span class="nc" id="L145">            return true;</span>

<span class="nc bnc" id="L147" title="All 2 branches missed.">        if (!(obj instanceof DataStorageSpec))</span>
<span class="nc" id="L148">            return false;</span>

<span class="nc" id="L150">        DataStorageSpec other = (DataStorageSpec) obj;</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">        if (unit == other.unit)</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">            return quantity == other.quantity;</span>

        // Due to overflows we can only guarantee that the 2 storages are equal if we get the same results
        // doing the convertion in both directions.
<span class="nc bnc" id="L156" title="All 4 branches missed.">        return unit.convert(other.quantity, other.unit) == quantity &amp;&amp; other.unit.convert(quantity, unit) == other.quantity;</span>
    }

    @Override
    public String toString()
    {
<span class="fc" id="L162">        return quantity + unit.symbol;</span>
    }

    /**
     * Represents a data storage quantity used for Cassandra configuration. The bound is [0, Long.MAX_VALUE) in bytes.
     * If the user sets a different unit - we still validate that converted to bytes the quantity will not exceed
     * that upper bound. (CASSANDRA-17571)
     */
    public final static class LongBytesBound extends DataStorageSpec
    {
        /**
         * Creates a {@code DataStorageSpec.LongBytesBound} of the specified amount.
         *
         * @param value the data storage
         */
        public LongBytesBound(String value)
        {
<span class="fc" id="L179">            super(value, BYTES, Long.MAX_VALUE);</span>
<span class="fc" id="L180">        }</span>

        /**
         * Creates a {@code DataStorageSpec.LongBytesBound} of the specified amount in the specified unit.
         *
         * @param quantity where quantity shouldn't be bigger than Long.MAX_VALUE - 1 in bytes
         * @param unit in which the provided quantity is
         */
        public LongBytesBound(long quantity, DataStorageUnit unit)
        {
<span class="fc" id="L190">            super(quantity, unit, BYTES, Long.MAX_VALUE, quantity + unit.symbol);</span>
<span class="fc" id="L191">        }</span>

        /**
         * Creates a {@code DataStorageSpec.LongBytesBound} of the specified amount in bytes.
         *
         * @param bytes where bytes shouldn't be bigger than Long.MAX_VALUE-1
         */
        public LongBytesBound(long bytes)
        {
<span class="fc" id="L200">            this(bytes, BYTES);</span>
<span class="fc" id="L201">        }</span>

        /**
         * @return the amount of data storage in bytes
         */
        public long toBytes()
        {
<span class="fc" id="L208">            return unit().toBytes(quantity());</span>
        }

        /**
         * @return the amount of data storage in mebibytes
         */
        public int toMebibytesInt()
        {
<span class="nc" id="L216">            return Ints.saturatedCast(unit().toMebibytes(quantity()));</span>
        }
    }

    /**
     * Represents a data storage quantity used for Cassandra configuration. The bound is [0, Integer.MAX_VALUE) in bytes.
     * If the user sets a different unit - we still validate that converted to bytes the quantity will not exceed
     * that upper bound. (CASSANDRA-17571)
     */
    public final static class IntBytesBound extends DataStorageSpec
    {
        /**
         * Creates a {@code DataStorageSpec.IntBytesBound} of the specified amount.
         *
         * @param value the data storage
         */
        public IntBytesBound(String value)
        {
<span class="fc" id="L234">            super(value, BYTES, Integer.MAX_VALUE);</span>
<span class="fc" id="L235">        }</span>

        /**
         * Creates a {@code DataStorageSpec.IntBytesBound} of the specified amount in the specified unit.
         *
         * @param quantity where quantity shouldn't be bigger than Integer.MAX_VALUE - 1 in bytes
         * @param unit in which the provided quantity is
         */
        public IntBytesBound(long quantity, DataStorageUnit unit)
        {
<span class="fc" id="L245">            super(quantity, unit, BYTES, Integer.MAX_VALUE, quantity + unit.symbol);</span>
<span class="fc" id="L246">        }</span>

        /**
         * Creates a {@code DataStorageSpec.IntBytesBound} of the specified amount in bytes.
         *
         * @param bytes where bytes shouldn't be bigger than Integer.MAX_VALUE-1
         */
        public IntBytesBound(long bytes)
        {
<span class="fc" id="L255">            this(bytes, BYTES);</span>
<span class="fc" id="L256">        }</span>

        /**
         * Returns the amount of data storage in bytes as an {@code int}
         *
         * @return the amount of data storage in bytes or {@code Integer.MAX_VALUE} if the number of bytes is too large.
         */
        public int toBytes()
        {
<span class="fc" id="L265">            return Ints.saturatedCast(unit().toBytes(quantity()));</span>
        }
    }

    /**
     * Represents a data storage quantity used for Cassandra configuration. The bound is [0, Integer.MAX_VALUE) in kibibytes.
     * If the user sets a different unit - we still validate that converted to kibibytes the quantity will not exceed
     * that upper bound. (CASSANDRA-17571)
     */
    public final static class IntKibibytesBound extends DataStorageSpec
    {
        /**
         * Creates a {@code DataStorageSpec.IntKibibytesBound} of the specified amount.
         *
         * @param value the data storage
         */
        public IntKibibytesBound(String value)
        {
<span class="fc" id="L283">            super(value, KIBIBYTES, Integer.MAX_VALUE);</span>
<span class="fc" id="L284">        }</span>

        /**
         * Creates a {@code DataStorageSpec.IntKibibytesBound} of the specified amount in the specified unit.
         *
         * @param quantity where quantity shouldn't be bigger than Integer.MAX_VALUE - 1 in kibibytes
         * @param unit in which the provided quantity is
         */
        public IntKibibytesBound(long quantity, DataStorageUnit unit)
        {
<span class="fc" id="L294">            super(quantity, unit, KIBIBYTES, Integer.MAX_VALUE, quantity + unit.symbol);</span>
<span class="fc" id="L295">        }</span>

        /**
         * Creates a {@code DataStorageSpec.IntKibibytesBound} of the specified amount in kibibytes.
         *
         * @param kibibytes where kibibytes shouldn't be bigger than Integer.MAX_VALUE-1
         */
        public IntKibibytesBound(long kibibytes)
        {
<span class="fc" id="L304">            this(kibibytes, KIBIBYTES);</span>
<span class="fc" id="L305">        }</span>

        /**
         * Returns the amount of data storage in bytes as an {@code int}
         *
         * @return the amount of data storage in bytes or {@code Integer.MAX_VALUE} if the number of bytes is too large.
         */
        public int toBytes()
        {
<span class="fc" id="L314">            return Ints.saturatedCast(unit().toBytes(quantity()));</span>
        }

        /**
         * Returns the amount of data storage in kibibytes as an {@code int}
         *
         * @return the amount of data storage in kibibytes or {@code Integer.MAX_VALUE} if the number of kibibytes is too large.
         */
        public int toKibibytes()
        {
<span class="fc" id="L324">            return Ints.saturatedCast(unit().toKibibytes(quantity()));</span>
        }

        /**
         * @return the amount of data storage in bytes.
         */
        public long toBytesInLong()
        {
<span class="fc" id="L332">           return unit().toBytes(quantity());</span>
        }
    }

    /**
     * Represents a data storage quantity used for Cassandra configuration. The bound is [0, Long.MAX_VALUE) in mebibytes.
     * If the user sets a different unit - we still validate that converted to mebibytes the quantity will not exceed
     * that upper bound. (CASSANDRA-17571)
     */
    public final static class LongMebibytesBound extends DataStorageSpec
    {
        /**
         * Creates a {@code DataStorageSpec.LongMebibytesBound} of the specified amount.
         *
         * @param value the data storage
         */
        public LongMebibytesBound(String value)
        {
<span class="fc" id="L350">            super(value, MEBIBYTES, Long.MAX_VALUE);</span>
<span class="fc" id="L351">        }</span>

        /**
         * Creates a {@code DataStorageSpec.LongMebibytesBound} of the specified amount in the specified unit.
         *
         * @param quantity where quantity shouldn't be bigger than Long.MAX_VALUE - 1 in mebibytes
         * @param unit in which the provided quantity is
         */
        public LongMebibytesBound(long quantity, DataStorageUnit unit)
        {
<span class="fc" id="L361">            super(quantity, unit, MEBIBYTES, Long.MAX_VALUE, quantity + unit.symbol);</span>
<span class="fc" id="L362">        }</span>

        /**
         * Creates a {@code DataStorageSpec.LongMebibytesBound} of the specified amount in mebibytes.
         *
         * @param mebibytes where mebibytes shouldn't be bigger than Long.MAX_VALUE-1
         */
        public LongMebibytesBound(long mebibytes)
        {
<span class="fc" id="L371">            this(mebibytes, MEBIBYTES);</span>
<span class="fc" id="L372">        }</span>

        /**
         * @return the amount of data storage in bytes
         */
        public long toBytes()
        {
<span class="nc" id="L379">            return unit().toBytes(quantity());</span>
        }

        /**
         * @return the amount of data storage in kibibytes
         */
        public long toKibibytes()
        {
<span class="nc" id="L387">            return unit().toKibibytes(quantity());</span>
        }

        /**
         * @return the amount of data storage in mebibytes
         */
        public long toMebibytes()
        {
<span class="fc" id="L395">            return unit().toMebibytes(quantity());</span>
        }
    }

    /**
     * Represents a data storage quantity used for Cassandra configuration. The bound is [0, Integer.MAX_VALUE) in mebibytes.
     * If the user sets a different unit - we still validate that converted to mebibytes the quantity will not exceed
     * that upper bound. (CASSANDRA-17571)
     */
    public final static class IntMebibytesBound extends DataStorageSpec
    {
        /**
         * Creates a {@code DataStorageSpec.IntMebibytesBound} of the specified amount.
         *
         * @param value the data storage
         */
        public IntMebibytesBound(String value)
        {
<span class="fc" id="L413">            super(value, MEBIBYTES, Integer.MAX_VALUE);</span>
<span class="fc" id="L414">        }</span>

        /**
         * Creates a {@code DataStorageSpec.IntMebibytesBound} of the specified amount in the specified unit.
         *
         * @param quantity where quantity shouldn't be bigger than Integer.MAX_VALUE - 1 in mebibytes
         * @param unit in which the provided quantity is
         */
        public IntMebibytesBound(long quantity, DataStorageUnit unit)
        {
<span class="fc" id="L424">            super(quantity, unit, MEBIBYTES, Integer.MAX_VALUE, quantity + unit.symbol);</span>
<span class="fc" id="L425">        }</span>

        /**
         * Creates a {@code DataStorageSpec.IntMebibytesBound} of the specified amount in mebibytes.
         *
         * @param mebibytes where mebibytes shouldn't be bigger than Integer.MAX_VALUE-1
         */
        public IntMebibytesBound(long mebibytes)
        {
<span class="fc" id="L434">            this(mebibytes, MEBIBYTES);</span>
<span class="fc" id="L435">        }</span>

        /**
         * Returns the amount of data storage in bytes as an {@code int}
         *
         * @return the amount of data storage in bytes or {@code Integer.MAX_VALUE} if the number of bytes is too large.
         */
        public int toBytes()
        {
<span class="fc" id="L444">            return Ints.saturatedCast(unit().toBytes(quantity()));</span>
        }

        /**
         * Returns the amount of data storage in kibibytes as an {@code int}
         *
         * @return the amount of data storage in kibibytes or {@code Integer.MAX_VALUE} if the number of kibibytes is too large.
         */
        public int toKibibytes()
        {
<span class="fc" id="L454">            return Ints.saturatedCast(unit().toKibibytes(quantity()));</span>
        }

        /**
         * Returns the amount of data storage in mebibytes as an {@code int}
         *
         * @return the amount of data storage in mebibytes or {@code Integer.MAX_VALUE} if the number of mebibytes is too large.
         */
        public int toMebibytes()
        {
<span class="fc" id="L464">            return Ints.saturatedCast(unit().toMebibytes(quantity()));</span>
        }

        /**
         * Returns the amount of data storage in bytes as {@code long}
         *
         * @return the amount of data storage in bytes.
         */
        public long toBytesInLong()
        {
<span class="fc" id="L474">            return unit().toBytes(quantity());</span>
        }
    }

<span class="fc" id="L478">    public enum DataStorageUnit</span>
    {
<span class="fc" id="L480">        BYTES(&quot;B&quot;)</span>
        {
            public long toBytes(long d)
            {
<span class="fc" id="L484">                return d;</span>
            }

            public long toKibibytes(long d)
            {
<span class="nc" id="L489">                return (d / 1024L);</span>
            }

            public long toMebibytes(long d)
            {
<span class="nc" id="L494">                return (d / (1024L * 1024));</span>
            }

            public long toGibibytes(long d)
            {
<span class="nc" id="L499">                return (d / (1024L * 1024 * 1024));</span>
            }

            public long convert(long source, DataStorageUnit sourceUnit)
            {
<span class="fc" id="L504">                return sourceUnit.toBytes(source);</span>
            }
        },
<span class="fc" id="L507">        KIBIBYTES(&quot;KiB&quot;)</span>
        {
            public long toBytes(long d)
            {
<span class="fc" id="L511">                return x(d, 1024L, (MAX / 1024L));</span>
            }

            public long toKibibytes(long d)
            {
<span class="fc" id="L516">                return d;</span>
            }

            public long toMebibytes(long d)
            {
<span class="nc" id="L521">                return (d / 1024L);</span>
            }

            public long toGibibytes(long d)
            {
<span class="nc" id="L526">                return (d / (1024L * 1024));</span>
            }

            public long convert(long source, DataStorageUnit sourceUnit)
            {
<span class="fc" id="L531">                return sourceUnit.toKibibytes(source);</span>
            }
        },
<span class="fc" id="L534">        MEBIBYTES(&quot;MiB&quot;)</span>
        {
            public long toBytes(long d)
            {
<span class="fc" id="L538">                return x(d, (1024L * 1024), MAX / (1024L * 1024));</span>
            }

            public long toKibibytes(long d)
            {
<span class="fc" id="L543">                return x(d, 1024L, (MAX / 1024L));</span>
            }

            public long toMebibytes(long d)
            {
<span class="fc" id="L548">                return d;</span>
            }

            public long toGibibytes(long d)
            {
<span class="nc" id="L553">                return (d / 1024L);</span>
            }

            public long convert(long source, DataStorageUnit sourceUnit)
            {
<span class="fc" id="L558">                return sourceUnit.toMebibytes(source);</span>
            }
        },
<span class="fc" id="L561">        GIBIBYTES(&quot;GiB&quot;)</span>
        {
            public long toBytes(long d)
            {
<span class="nc" id="L565">                return x(d, (1024L * 1024 * 1024), MAX / (1024L * 1024 * 1024));</span>
            }

            public long toKibibytes(long d)
            {
<span class="nc" id="L570">                return x(d, (1024L * 1024), MAX / (1024L * 1024));</span>
            }

            public long toMebibytes(long d)
            {
<span class="nc" id="L575">                return x(d, 1024L, (MAX / 1024L));</span>
            }

            public long toGibibytes(long d)
            {
<span class="nc" id="L580">                return d;</span>
            }

            public long convert(long source, DataStorageUnit sourceUnit)
            {
<span class="nc" id="L585">                return sourceUnit.toGibibytes(source);</span>
            }
        };

        /**
         * Scale d by m, checking for overflow. This has a short name to make above code more readable.
         */
        static long x(long d, long m, long over)
        {
<span class="pc bpc" id="L594" title="3 of 6 branches missed.">            assert (over &gt; 0) &amp;&amp; (over &lt; (MAX-1L)) &amp;&amp; (over == (MAX / m));</span>

<span class="pc bpc" id="L596" title="1 of 2 branches missed.">            if (d &gt; over)</span>
<span class="nc" id="L597">                return Long.MAX_VALUE;</span>
<span class="fc" id="L598">            return Math.multiplyExact(d, m);</span>
        }

        /**
         * @param symbol the unit symbol
         * @return the memory unit corresponding to the given symbol
         */
        public static DataStorageUnit fromSymbol(String symbol)
        {
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">            for (DataStorageUnit value : values())</span>
            {
<span class="fc bfc" id="L609" title="All 2 branches covered.">                if (value.symbol.equalsIgnoreCase(symbol))</span>
<span class="fc" id="L610">                    return value;</span>
            }
<span class="nc" id="L612">            throw new IllegalArgumentException(String.format(&quot;Unsupported data storage unit: %s. Supported units are: %s&quot;,</span>
<span class="nc" id="L613">                                                           symbol, Arrays.stream(values())</span>
<span class="nc" id="L614">                                                                         .map(u -&gt; u.symbol)</span>
<span class="nc" id="L615">                                                                         .collect(Collectors.joining(&quot;, &quot;))));</span>
        }

        static final long MAX = Long.MAX_VALUE;

        /**
         * The unit symbol
         */
        private final String symbol;

        DataStorageUnit(String symbol)
<span class="fc" id="L626">        {</span>
<span class="fc" id="L627">            this.symbol = symbol;</span>
<span class="fc" id="L628">        }</span>

        public long toBytes(long d)
        {
<span class="nc" id="L632">            throw new AbstractMethodError();</span>
        }

        public long toKibibytes(long d)
        {
<span class="nc" id="L637">            throw new AbstractMethodError();</span>
        }

        public long toMebibytes(long d)
        {
<span class="nc" id="L642">            throw new AbstractMethodError();</span>
        }

        public long toGibibytes(long d)
        {
<span class="nc" id="L647">            throw new AbstractMethodError();</span>
        }

        public long convert(long source, DataStorageUnit sourceUnit)
        {
<span class="nc" id="L652">            throw new AbstractMethodError();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>