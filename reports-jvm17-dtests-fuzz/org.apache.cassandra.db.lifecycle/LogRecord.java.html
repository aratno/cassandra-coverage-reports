<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LogRecord.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.lifecycle</a> &gt; <span class="el_source">LogRecord.java</span></div><h1>LogRecord.java</h1><pre class="source lang-java linenums">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.cassandra.db.lifecycle;


import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.TreeSet;
import java.util.function.BiPredicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.zip.CRC32;

import org.apache.cassandra.io.sstable.Component;
import org.apache.cassandra.io.sstable.SSTable;
import org.apache.cassandra.io.sstable.format.SSTableReader;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.io.util.PathUtils;
import org.apache.cassandra.utils.FBUtilities;

/**
 * A decoded line in a transaction log file replica.
 *
 * @see LogReplica and LogFile.
 */
final class LogRecord
{
<span class="fc" id="L56">    public enum Type</span>
    {
<span class="fc" id="L58">        UNKNOWN, // a record that cannot be parsed</span>
<span class="fc" id="L59">        ADD,    // new files to be retained on commit</span>
<span class="fc" id="L60">        REMOVE, // old files to be retained on abort</span>
<span class="fc" id="L61">        COMMIT, // commit flag</span>
<span class="fc" id="L62">        ABORT;  // abort flag</span>

        public static Type fromPrefix(String prefix)
        {
<span class="nc" id="L66">            return valueOf(prefix.toUpperCase());</span>
        }

        public boolean hasFile()
        {
<span class="pc bpc" id="L71" title="1 of 4 branches missed.">            return this == Type.ADD || this == Type.REMOVE;</span>
        }

        public boolean matches(LogRecord record)
        {
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">            return this == record.type;</span>
        }

<span class="nc bnc" id="L79" title="All 4 branches missed.">        public boolean isFinal() { return this == Type.COMMIT || this == Type.ABORT; }</span>
    }

    /**
     * The status of a record after it has been verified, any parsing errors
     * are also store here.
     */
<span class="fc" id="L86">    public final static class Status</span>
    {
        // if there are any errors, they end up here
<span class="fc" id="L89">        Optional&lt;String&gt; error = Optional.empty();</span>

        // if the record was only partially matched across files this is true
<span class="fc" id="L92">        boolean partial = false;</span>

        // if the status of this record on disk is required (e.g. existing files), it is
        // stored here for caching
        LogRecord onDiskRecord;

        void setError(String error)
        {
<span class="nc bnc" id="L100" title="All 2 branches missed.">            if (!this.error.isPresent())</span>
<span class="nc" id="L101">                this.error = Optional.of(error);</span>
<span class="nc" id="L102">        }</span>

        boolean hasError()
        {
<span class="fc" id="L106">            return error.isPresent();</span>
        }
    }

    // the type of record, see Type
    public final Type type;
    // for sstable records, the absolute path of the table desc
    public final Optional&lt;String&gt; absolutePath;
    // for sstable records, the last update time of all files (may not be available for NEW records)
    public final long updateTime;
    // for sstable records, the total number of files (may not be accurate for NEW records)
    public final int numFiles;
    // the raw string as written or read from a file
    public final String raw;
    // the checksum of this record, written at the end of the record string
    public final long checksum;
    // the status of this record, @see Status class
    public final Status status;

    // (add|remove|commit|abort):[*,*,*][checksum]
<span class="fc" id="L126">    static Pattern REGEX = Pattern.compile(&quot;^(add|remove|commit|abort):\\[([^,]*),?([^,]*),?([^,]*)\\]\\[(\\d*)\\]$&quot;, Pattern.CASE_INSENSITIVE);</span>

    public static LogRecord make(String line)
    {
        try
        {
<span class="nc" id="L132">            Matcher matcher = REGEX.matcher(line);</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">            if (!matcher.matches())</span>
<span class="nc" id="L134">                return new LogRecord(Type.UNKNOWN, null, 0, 0, 0, line)</span>
<span class="nc" id="L135">                       .setError(String.format(&quot;Failed to parse [%s]&quot;, line));</span>

<span class="nc" id="L137">            Type type = Type.fromPrefix(matcher.group(1));</span>
<span class="nc" id="L138">            return new LogRecord(type,</span>
<span class="nc" id="L139">                                 matcher.group(2),</span>
<span class="nc" id="L140">                                 Long.parseLong(matcher.group(3)),</span>
<span class="nc" id="L141">                                 Integer.parseInt(matcher.group(4)),</span>
<span class="nc" id="L142">                                 Long.parseLong(matcher.group(5)),</span>
                                 line);
        }
<span class="nc" id="L145">        catch (IllegalArgumentException e)</span>
        {
<span class="nc" id="L147">            return new LogRecord(Type.UNKNOWN, null, 0, 0, 0, line)</span>
<span class="nc" id="L148">                   .setError(String.format(&quot;Failed to parse line: %s&quot;, e.getMessage()));</span>
        }
    }

    public static LogRecord makeCommit(long updateTime)
    {
<span class="fc" id="L154">        return new LogRecord(Type.COMMIT, updateTime);</span>
    }

    public static LogRecord makeAbort(long updateTime)
    {
<span class="nc" id="L159">        return new LogRecord(Type.ABORT, updateTime);</span>
    }

    public static LogRecord make(Type type, SSTable table)
    {
<span class="fc" id="L164">        String absoluteTablePath = absolutePath(table.descriptor.baseFile());</span>
<span class="fc" id="L165">        return make(type, getExistingFiles(absoluteTablePath), table.getAllFilePaths().size(), absoluteTablePath);</span>
    }

    public static Map&lt;SSTable, LogRecord&gt; make(Type type, Iterable&lt;SSTableReader&gt; tables)
    {
        // contains a mapping from sstable absolute path (everything up until the 'Data'/'Index'/etc part of the filename) to the sstable
<span class="fc" id="L171">        Map&lt;String, SSTable&gt; absolutePaths = new HashMap&lt;&gt;();</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">        for (SSTableReader table : tables)</span>
<span class="nc" id="L173">            absolutePaths.put(absolutePath(table.descriptor.baseFile()), table);</span>

        // maps sstable base file name to the actual files on disk
<span class="fc" id="L176">        Map&lt;String, List&lt;File&gt;&gt; existingFiles = getExistingFiles(absolutePaths.keySet());</span>
<span class="fc" id="L177">        Map&lt;SSTable, LogRecord&gt; records = new HashMap&lt;&gt;(existingFiles.size());</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        for (Map.Entry&lt;String, List&lt;File&gt;&gt; entry : existingFiles.entrySet())</span>
        {
<span class="nc" id="L180">            List&lt;File&gt; filesOnDisk = entry.getValue();</span>
<span class="nc" id="L181">            String baseFileName = entry.getKey();</span>
<span class="nc" id="L182">            SSTable sstable = absolutePaths.get(baseFileName);</span>
<span class="nc" id="L183">            records.put(sstable, make(type, filesOnDisk, sstable.getAllFilePaths().size(), baseFileName));</span>
<span class="nc" id="L184">        }</span>
<span class="fc" id="L185">        return records;</span>
    }

    private static String absolutePath(File baseFile)
    {
<span class="fc" id="L190">        return baseFile.withSuffix(String.valueOf(Component.separator)).canonicalPath();</span>
    }

    public LogRecord withExistingFiles(List&lt;File&gt; existingFiles)
    {
<span class="nc" id="L195">        return make(type, existingFiles, 0, absolutePath.get());</span>
    }

    public static LogRecord make(Type type, List&lt;File&gt; files, int minFiles, String absolutePath)
    {
        // CASSANDRA-11889: File.lastModified() returns a positive value only if the file exists, therefore
        // we filter by positive values to only consider the files that still exists right now, in case things
        // changed on disk since getExistingFiles() was called
<span class="pc bnc" id="L203" title="All 2 branches missed.">        List&lt;Long&gt; positiveModifiedTimes = files.stream().map(File::lastModified).filter(lm -&gt; lm &gt; 0).collect(Collectors.toList());</span>
<span class="fc" id="L204">        long lastModified = positiveModifiedTimes.stream().reduce(0L, Long::max);</span>
<span class="fc" id="L205">        return new LogRecord(type, absolutePath, lastModified, Math.max(minFiles, positiveModifiedTimes.size()));</span>
    }

    private LogRecord(Type type, long updateTime)
    {
<span class="fc" id="L210">        this(type, null, updateTime, 0, 0, null);</span>
<span class="fc" id="L211">    }</span>

    private LogRecord(Type type,
                      String absolutePath,
                      long updateTime,
                      int numFiles)
    {
<span class="fc" id="L218">        this(type, absolutePath, updateTime, numFiles, 0, null);</span>
<span class="fc" id="L219">    }</span>

    private LogRecord(Type type,
                      String absolutePath,
                      long updateTime,
                      int numFiles,
                      long checksum,
                      String raw)
<span class="fc" id="L227">    {</span>
<span class="pc bpc" id="L228" title="1 of 4 branches missed.">        assert !type.hasFile() || absolutePath != null : &quot;Expected file path for file records&quot;;</span>

<span class="fc" id="L230">        this.type = type;</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">        this.absolutePath = type.hasFile() ? Optional.of(absolutePath) : Optional.&lt;String&gt;empty();</span>
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">        this.updateTime = type == Type.REMOVE ? updateTime : 0;</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">        this.numFiles = type.hasFile() ? numFiles : 0;</span>
<span class="fc" id="L234">        this.status = new Status();</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">        if (raw == null)</span>
        {
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">            assert checksum == 0;</span>
<span class="fc" id="L238">            this.checksum = computeChecksum();</span>
<span class="fc" id="L239">            this.raw = format();</span>
        }
        else
        {
<span class="nc" id="L243">            this.checksum = checksum;</span>
<span class="nc" id="L244">            this.raw = raw;</span>
        }
<span class="fc" id="L246">    }</span>

    LogRecord setError(String error)
    {
<span class="nc" id="L250">        status.setError(error);</span>
<span class="nc" id="L251">        return this;</span>
    }

    String error()
    {
<span class="nc" id="L256">        return status.error.orElse(&quot;&quot;);</span>
    }

    void setPartial()
    {
<span class="nc" id="L261">        status.partial = true;</span>
<span class="nc" id="L262">    }</span>

    boolean partial()
    {
<span class="nc" id="L266">        return status.partial;</span>
    }

    boolean isValid()
    {
<span class="pc bpc" id="L271" title="2 of 4 branches missed.">        return !status.hasError() &amp;&amp; type != Type.UNKNOWN;</span>
    }

    boolean isInvalid()
    {
<span class="nc bnc" id="L276" title="All 2 branches missed.">        return !isValid();</span>
    }

    boolean isInvalidOrPartial()
    {
<span class="nc bnc" id="L281" title="All 4 branches missed.">        return isInvalid() || partial();</span>
    }

    private String format()
    {
<span class="fc" id="L286">        return String.format(&quot;%s:[%s,%d,%d][%d]&quot;,</span>
<span class="fc" id="L287">                             type.toString(),</span>
<span class="fc" id="L288">                             absolutePath(),</span>
<span class="fc" id="L289">                             updateTime,</span>
<span class="fc" id="L290">                             numFiles,</span>
<span class="fc" id="L291">                             checksum);</span>
    }

    public static List&lt;File&gt; getExistingFiles(String absoluteFilePath)
    {
<span class="fc" id="L296">        File file = new File(absoluteFilePath);</span>
<span class="fc" id="L297">        File[] files = file.parent().tryList((dir, name) -&gt; name.startsWith(file.name()));</span>
        // files may be null if the directory does not exist yet, e.g. when tracking new files
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        return files == null ? Collections.emptyList() : Arrays.asList(files);</span>
    }

    /**
     * absoluteFilePaths contains full file parts up to (but excluding) the component name
     *
     * This method finds all files on disk beginning with any of the paths in absoluteFilePaths
     *
     * @return a map from absoluteFilePath to actual file on disk.
     */
    public static Map&lt;String, List&lt;File&gt;&gt; getExistingFiles(Set&lt;String&gt; absoluteFilePaths)
    {
<span class="fc" id="L311">        Map&lt;String, List&lt;File&gt;&gt; fileMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L312">        Map&lt;File, TreeSet&lt;String&gt;&gt; dirToFileNamePrefix = new HashMap&lt;&gt;();</span>
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        for (String absolutePath : absoluteFilePaths)</span>
        {
<span class="nc" id="L315">            Path fullPath = new File(absolutePath).toPath();</span>
<span class="nc" id="L316">            Path path = fullPath.getParent();</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">            if (path != null)</span>
<span class="nc" id="L318">                dirToFileNamePrefix.computeIfAbsent(new File(path), (k) -&gt; new TreeSet&lt;&gt;()).add(fullPath.getFileName().toString());</span>
<span class="nc" id="L319">        }</span>

<span class="fc" id="L321">        BiPredicate&lt;File, String&gt; ff = (dir, name) -&gt; {</span>
<span class="nc" id="L322">            TreeSet&lt;String&gt; dirSet = dirToFileNamePrefix.get(dir);</span>
            // if the set contains a prefix of the current file name, the file name we have here should sort directly
            // after the prefix in the tree set, which means we can use 'floor' to get the prefix (returns the largest
            // of the smaller strings in the set). Also note that the prefixes always end with '-' which means we won't
            // have &quot;xy-1111-Data.db&quot;.startsWith(&quot;xy-11&quot;) below (we'd get &quot;xy-1111-Data.db&quot;.startsWith(&quot;xy-11-&quot;))
<span class="nc" id="L327">            String baseName = dirSet.floor(name);</span>
<span class="nc bnc" id="L328" title="All 4 branches missed.">            if (baseName != null &amp;&amp; name.startsWith(baseName))</span>
            {
<span class="nc" id="L330">                String absolutePath = new File(dir, baseName).path();</span>
<span class="nc" id="L331">                fileMap.computeIfAbsent(absolutePath, k -&gt; new ArrayList&lt;&gt;()).add(new File(dir, name));</span>
            }
<span class="nc" id="L333">            return false;</span>
        };

        // populate the file map:
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">        for (File f : dirToFileNamePrefix.keySet())</span>
<span class="nc" id="L338">            f.tryList(ff);</span>

<span class="fc" id="L340">        return fileMap;</span>
    }


    public boolean isFinal()
    {
<span class="nc" id="L346">        return type.isFinal();</span>
    }

    String fileName()
    {
<span class="nc bnc" id="L351" title="All 2 branches missed.">        return absolutePath.isPresent() ? new File(absolutePath.get()).name() : &quot;&quot;;</span>
    }

    boolean isInFolder(Path folder)
    {
<span class="nc bnc" id="L356" title="All 4 branches missed.">        return absolutePath.isPresent() &amp;&amp; PathUtils.isContained(folder, new File(absolutePath.get()).toPath());</span>
    }

    String absolutePath()
    {
<span class="fc bfc" id="L361" title="All 2 branches covered.">        return absolutePath.isPresent() ? absolutePath.get() : &quot;&quot;;</span>
    }

    @Override
    public int hashCode()
    {
        // see comment in equals
<span class="fc" id="L368">        return Objects.hash(type, absolutePath, numFiles, updateTime);</span>
    }

    @Override
    public boolean equals(Object obj)
    {
<span class="nc bnc" id="L374" title="All 2 branches missed.">        if (!(obj instanceof LogRecord))</span>
<span class="nc" id="L375">            return false;</span>

<span class="nc" id="L377">        final LogRecord other = (LogRecord)obj;</span>

        // we exclude on purpose checksum, error and full file path
        // since records must match across log file replicas on different disks
<span class="nc bnc" id="L381" title="All 2 branches missed.">        return type == other.type &amp;&amp;</span>
<span class="nc bnc" id="L382" title="All 6 branches missed.">               absolutePath.equals(other.absolutePath) &amp;&amp;</span>
               numFiles == other.numFiles &amp;&amp;
               updateTime == other.updateTime;
    }

    @Override
    public String toString()
    {
<span class="fc" id="L390">        return raw;</span>
    }

    long computeChecksum()
    {
<span class="fc" id="L395">        CRC32 crc32 = new CRC32();</span>
<span class="fc" id="L396">        crc32.update((absolutePath()).getBytes(FileUtils.CHARSET));</span>
<span class="fc" id="L397">        crc32.update(type.toString().getBytes(FileUtils.CHARSET));</span>
<span class="fc" id="L398">        FBUtilities.updateChecksumInt(crc32, (int) updateTime);</span>
<span class="fc" id="L399">        FBUtilities.updateChecksumInt(crc32, (int) (updateTime &gt;&gt;&gt; 32));</span>
<span class="fc" id="L400">        FBUtilities.updateChecksumInt(crc32, numFiles);</span>
<span class="fc" id="L401">        return crc32.getValue() &amp; (Long.MAX_VALUE);</span>
    }

    LogRecord asType(Type type)
    {
<span class="nc" id="L406">        return new LogRecord(type, absolutePath.orElse(null), updateTime, numFiles);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>