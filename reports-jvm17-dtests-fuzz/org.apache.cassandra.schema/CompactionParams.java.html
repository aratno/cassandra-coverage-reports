<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CompactionParams.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.schema</a> &gt; <span class="el_source">CompactionParams.java</span></div><h1>CompactionParams.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.schema;

import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

import com.google.common.base.MoreObjects;
import com.google.common.collect.ImmutableMap;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.config.ParameterizedClass;
import org.apache.cassandra.db.compaction.AbstractCompactionStrategy;
import org.apache.cassandra.db.compaction.LeveledCompactionStrategy;
import org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy;
import org.apache.cassandra.db.compaction.TimeWindowCompactionStrategy;
import org.apache.cassandra.db.compaction.UnifiedCompactionStrategy;
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.utils.FBUtilities;

import static java.lang.String.format;
import static org.apache.cassandra.config.CassandraRelevantProperties.DEFAULT_PROVIDE_OVERLAPPING_TOMBSTONES;

public final class CompactionParams
{
<span class="fc" id="L48">    private static final Logger logger = LoggerFactory.getLogger(CompactionParams.class);</span>

<span class="fc" id="L50">    public enum Option</span>
    {
<span class="fc" id="L52">        CLASS,</span>
<span class="fc" id="L53">        ENABLED,</span>
<span class="fc" id="L54">        MIN_THRESHOLD,</span>
<span class="fc" id="L55">        MAX_THRESHOLD,</span>
<span class="fc" id="L56">        PROVIDE_OVERLAPPING_TOMBSTONES;</span>

        @Override
        public String toString()
        {
<span class="fc" id="L61">            return name().toLowerCase();</span>
        }
    }

<span class="fc" id="L65">    public enum TombstoneOption</span>
    {
<span class="fc" id="L67">        NONE,</span>
<span class="fc" id="L68">        ROW,</span>
<span class="fc" id="L69">        CELL;</span>

<span class="fc" id="L71">        private static final TombstoneOption[] copyOfValues = values();</span>

        public static Optional&lt;TombstoneOption&gt; forName(String name)
        {
<span class="fc" id="L75">            return Arrays.stream(copyOfValues).filter(x -&gt; x.name().equals(name)).findFirst();</span>
        }
    }

    public static final int DEFAULT_MIN_THRESHOLD = 4;
    public static final int DEFAULT_MAX_THRESHOLD = 32;

    public static final boolean DEFAULT_ENABLED = true;
<span class="fc" id="L83">    public static final TombstoneOption DEFAULT_PROVIDE_OVERLAPPING_TOMBSTONES_PROPERTY_VALUE =</span>
<span class="fc" id="L84">        DEFAULT_PROVIDE_OVERLAPPING_TOMBSTONES.getEnum(TombstoneOption.NONE);</span>

<span class="fc" id="L86">    public static final Map&lt;String, String&gt; DEFAULT_THRESHOLDS =</span>
<span class="fc" id="L87">        ImmutableMap.of(Option.MIN_THRESHOLD.toString(), Integer.toString(DEFAULT_MIN_THRESHOLD),</span>
<span class="fc" id="L88">                        Option.MAX_THRESHOLD.toString(), Integer.toString(DEFAULT_MAX_THRESHOLD));</span>

    public static final CompactionParams DEFAULT;
    static
    {
<span class="fc" id="L93">        ParameterizedClass defaultCompaction = DatabaseDescriptor.getDefaultCompaction();</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">        if (defaultCompaction == null)</span>
        {
<span class="fc" id="L96">            DEFAULT = new CompactionParams(SizeTieredCompactionStrategy.class,</span>
                                           DEFAULT_THRESHOLDS,
                                           DEFAULT_ENABLED,
                                           DEFAULT_PROVIDE_OVERLAPPING_TOMBSTONES_PROPERTY_VALUE);
        }
        else
        {
<span class="nc" id="L103">            DEFAULT = create(classFromName(defaultCompaction.class_name),</span>
                             defaultCompaction.parameters);
        }
<span class="fc" id="L106">    }</span>

    private final Class&lt;? extends AbstractCompactionStrategy&gt; klass;
    private final ImmutableMap&lt;String, String&gt; options;
    private final boolean isEnabled;
    private final TombstoneOption tombstoneOption;

    private CompactionParams(Class&lt;? extends AbstractCompactionStrategy&gt; klass, Map&lt;String, String&gt; options, boolean isEnabled, TombstoneOption tombstoneOption)
<span class="fc" id="L114">    {</span>
<span class="fc" id="L115">        this.klass = klass;</span>
<span class="fc" id="L116">        this.options = ImmutableMap.copyOf(options);</span>
<span class="fc" id="L117">        this.isEnabled = isEnabled;</span>
<span class="fc" id="L118">        this.tombstoneOption = tombstoneOption;</span>
<span class="fc" id="L119">    }</span>

    public static CompactionParams create(Class&lt;? extends AbstractCompactionStrategy&gt; klass, Map&lt;String, String&gt; options)
    {
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">        boolean isEnabled = options.containsKey(Option.ENABLED.toString())</span>
<span class="nc" id="L124">                          ? Boolean.parseBoolean(options.get(Option.ENABLED.toString()))</span>
<span class="fc" id="L125">                          : DEFAULT_ENABLED;</span>
<span class="fc" id="L126">        String overlappingTombstoneParm = options.getOrDefault(Option.PROVIDE_OVERLAPPING_TOMBSTONES.toString(),</span>
<span class="fc" id="L127">                                                               DEFAULT_PROVIDE_OVERLAPPING_TOMBSTONES_PROPERTY_VALUE.toString()).toUpperCase();</span>
<span class="fc" id="L128">        Optional&lt;TombstoneOption&gt; tombstoneOptional = TombstoneOption.forName(overlappingTombstoneParm);</span>
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">        if (!tombstoneOptional.isPresent())</span>
        {
<span class="nc" id="L131">            throw new ConfigurationException(format(&quot;Invalid value %s for 'provide_overlapping_tombstones' compaction sub-option - must be one of the following [%s].&quot;,</span>
                                                    overlappingTombstoneParm,
<span class="nc" id="L133">                                                    StringUtils.join(TombstoneOption.values(), &quot;, &quot;)));</span>
        }
<span class="fc" id="L135">        TombstoneOption tombstoneOption = tombstoneOptional.get();</span>

<span class="fc" id="L137">        Map&lt;String, String&gt; allOptions = new HashMap&lt;&gt;(options);</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">        if (supportsThresholdParams(klass))</span>
        {
<span class="fc" id="L140">            allOptions.putIfAbsent(Option.MIN_THRESHOLD.toString(), Integer.toString(DEFAULT_MIN_THRESHOLD));</span>
<span class="fc" id="L141">            allOptions.putIfAbsent(Option.MAX_THRESHOLD.toString(), Integer.toString(DEFAULT_MAX_THRESHOLD));</span>
        }

<span class="fc" id="L144">        return new CompactionParams(klass, allOptions, isEnabled, tombstoneOption);</span>
    }

    public static CompactionParams stcs(Map&lt;String, String&gt; options)
    {
<span class="fc" id="L149">        return create(SizeTieredCompactionStrategy.class, options);</span>
    }

    public static CompactionParams lcs(Map&lt;String, String&gt; options)
    {
<span class="fc" id="L154">        return create(LeveledCompactionStrategy.class, options);</span>
    }

    public static CompactionParams ucs(Map&lt;String, String&gt; options)
    {
<span class="nc" id="L159">        return create(UnifiedCompactionStrategy.class, options);</span>
    }

    public static CompactionParams twcs(Map&lt;String, String&gt; options)
    {
<span class="nc" id="L164">        return create(TimeWindowCompactionStrategy.class, options);</span>
    }

    public int minCompactionThreshold()
    {
<span class="fc" id="L169">        String threshold = options.get(Option.MIN_THRESHOLD.toString());</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        return threshold == null</span>
<span class="nc" id="L171">             ? DEFAULT_MIN_THRESHOLD</span>
<span class="fc" id="L172">             : Integer.parseInt(threshold);</span>
    }

    public int maxCompactionThreshold()
    {
<span class="fc" id="L177">        String threshold = options.get(Option.MAX_THRESHOLD.toString());</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        return threshold == null</span>
<span class="nc" id="L179">             ? DEFAULT_MAX_THRESHOLD</span>
<span class="fc" id="L180">             : Integer.parseInt(threshold);</span>
    }

    public TombstoneOption tombstoneOption()
    {
<span class="nc" id="L185">        return tombstoneOption;</span>
    }

    public void validate()
    {
        try
        {
<span class="fc" id="L192">            Map&lt;?, ?&gt; unknownOptions = (Map) klass.getMethod(&quot;validateOptions&quot;, Map.class).invoke(null, options);</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">            if (!unknownOptions.isEmpty())</span>
            {
<span class="nc" id="L195">                throw new ConfigurationException(format(&quot;Properties specified %s are not understood by %s&quot;,</span>
<span class="nc" id="L196">                                                        unknownOptions.keySet(),</span>
<span class="nc" id="L197">                                                        klass.getSimpleName()));</span>
            }
        }
<span class="nc" id="L200">        catch (NoSuchMethodException e)</span>
        {
<span class="nc" id="L202">            logger.warn(&quot;Compaction strategy {} does not have a static validateOptions method. Validation ignored&quot;,</span>
<span class="nc" id="L203">                        klass.getName());</span>
        }
<span class="nc" id="L205">        catch (InvocationTargetException e)</span>
        {
<span class="nc bnc" id="L207" title="All 2 branches missed.">            if (e.getTargetException() instanceof ConfigurationException)</span>
<span class="nc" id="L208">                throw (ConfigurationException) e.getTargetException();</span>

<span class="nc bnc" id="L210" title="All 2 branches missed.">            Throwable cause = e.getCause() == null</span>
<span class="nc" id="L211">                            ? e</span>
<span class="nc" id="L212">                            : e.getCause();</span>

<span class="nc" id="L214">            throw new ConfigurationException(format(&quot;%s.validateOptions() threw an error: %s %s&quot;,</span>
<span class="nc" id="L215">                                                    klass.getName(),</span>
<span class="nc" id="L216">                                                    cause.getClass().getName(),</span>
<span class="nc" id="L217">                                                    cause.getMessage()),</span>
                                             e);
        }
<span class="nc" id="L220">        catch (IllegalAccessException e)</span>
        {
<span class="nc" id="L222">            throw new ConfigurationException(&quot;Cannot access method validateOptions in &quot; + klass.getName(), e);</span>
<span class="pc" id="L223">        }</span>

<span class="fc" id="L225">        String minThreshold = options.get(Option.MIN_THRESHOLD.toString());</span>
<span class="pc bpc" id="L226" title="2 of 4 branches missed.">        if (minThreshold != null &amp;&amp; !StringUtils.isNumeric(minThreshold))</span>
        {
<span class="nc" id="L228">            throw new ConfigurationException(format(&quot;Invalid value %s for '%s' compaction sub-option - must be an integer&quot;,</span>
                                                    minThreshold,
                                                    Option.MIN_THRESHOLD));
        }

<span class="fc" id="L233">        String maxThreshold = options.get(Option.MAX_THRESHOLD.toString());</span>
<span class="pc bpc" id="L234" title="2 of 4 branches missed.">        if (maxThreshold != null &amp;&amp; !StringUtils.isNumeric(maxThreshold))</span>
        {
<span class="nc" id="L236">            throw new ConfigurationException(format(&quot;Invalid value %s for '%s' compaction sub-option - must be an integer&quot;,</span>
                                                    maxThreshold,
                                                    Option.MAX_THRESHOLD));
        }

<span class="pc bpc" id="L241" title="2 of 4 branches missed.">        if (minCompactionThreshold() &lt;= 0 || maxCompactionThreshold() &lt;= 0)</span>
        {
<span class="nc" id="L243">            throw new ConfigurationException(&quot;Disabling compaction by setting compaction thresholds to 0 has been removed,&quot;</span>
                                             + &quot; set the compaction option 'enabled' to false instead.&quot;);
        }

<span class="pc bpc" id="L247" title="1 of 2 branches missed.">        if (minCompactionThreshold() &lt;= 1)</span>
        {
<span class="nc" id="L249">            throw new ConfigurationException(format(&quot;Min compaction threshold cannot be less than 2 (got %d)&quot;,</span>
<span class="nc" id="L250">                                                    minCompactionThreshold()));</span>
        }

<span class="pc bpc" id="L253" title="1 of 2 branches missed.">        if (minCompactionThreshold() &gt; maxCompactionThreshold())</span>
        {
<span class="nc" id="L255">            throw new ConfigurationException(format(&quot;Min compaction threshold (got %d) cannot be greater than max compaction threshold (got %d)&quot;,</span>
<span class="nc" id="L256">                                                    minCompactionThreshold(),</span>
<span class="nc" id="L257">                                                    maxCompactionThreshold()));</span>
        }
<span class="fc" id="L259">    }</span>

    double defaultBloomFilterFbChance()
    {
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        return klass.equals(LeveledCompactionStrategy.class) ? 0.1 : 0.01;</span>
    }

    public Class&lt;? extends AbstractCompactionStrategy&gt; klass()
    {
<span class="fc" id="L268">        return klass;</span>
    }

    /**
     * All strategy options - excluding 'class'.
     */
    public Map&lt;String, String&gt; options()
    {
<span class="fc" id="L276">        return options;</span>
    }

    public boolean isEnabled()
    {
<span class="fc" id="L281">        return isEnabled;</span>
    }

    public static CompactionParams fromMap(Map&lt;String, String&gt; map)
    {
<span class="nc" id="L286">        Map&lt;String, String&gt; options = new HashMap&lt;&gt;(map);</span>

<span class="nc" id="L288">        String className = options.remove(Option.CLASS.toString());</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">        if (className == null)</span>
        {
<span class="nc" id="L291">            throw new ConfigurationException(format(&quot;Missing sub-option '%s' for the '%s' option&quot;,</span>
                                                    Option.CLASS,
                                                    TableParams.Option.COMPACTION));
        }

<span class="nc" id="L296">        return create(classFromName(className), options);</span>
    }

    public static Class&lt;? extends AbstractCompactionStrategy&gt; classFromName(String name)
    {
<span class="nc bnc" id="L301" title="All 2 branches missed.">        String className = name.contains(&quot;.&quot;)</span>
<span class="nc" id="L302">                         ? name</span>
<span class="nc" id="L303">                         : &quot;org.apache.cassandra.db.compaction.&quot; + name;</span>
<span class="nc" id="L304">        Class&lt;AbstractCompactionStrategy&gt; strategyClass = FBUtilities.classForName(className, &quot;compaction strategy&quot;);</span>

<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (!AbstractCompactionStrategy.class.isAssignableFrom(strategyClass))</span>
        {
<span class="nc" id="L308">            throw new ConfigurationException(format(&quot;Compaction strategy class %s is not derived from AbstractReplicationStrategy&quot;,</span>
                                                    className));
        }

<span class="nc" id="L312">        return strategyClass;</span>
    }

    /*
     * LCS doesn't, STCS and DTCS do
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static boolean supportsThresholdParams(Class&lt;? extends AbstractCompactionStrategy&gt; klass)
    {
        try
        {
<span class="fc" id="L323">            Map&lt;String, String&gt; unrecognizedOptions =</span>
<span class="fc" id="L324">                (Map&lt;String, String&gt;) klass.getMethod(&quot;validateOptions&quot;, Map.class)</span>
<span class="fc" id="L325">                                           .invoke(null, DEFAULT_THRESHOLDS);</span>

<span class="fc" id="L327">            return unrecognizedOptions.isEmpty();</span>
        }
<span class="nc" id="L329">        catch (Exception e)</span>
        {
<span class="nc" id="L331">            throw new RuntimeException(e);</span>
        }
    }

    public Map&lt;String, String&gt; asMap()
    {
<span class="fc" id="L337">        Map&lt;String, String&gt; map = new HashMap&lt;&gt;(options());</span>
<span class="fc" id="L338">        map.put(Option.CLASS.toString(), klass.getName());</span>
<span class="fc" id="L339">        return map;</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L345">        return MoreObjects.toStringHelper(this)</span>
<span class="nc" id="L346">                          .add(&quot;class&quot;, klass.getName())</span>
<span class="nc" id="L347">                          .add(&quot;options&quot;, options)</span>
<span class="nc" id="L348">                          .toString();</span>
    }

    @Override
    public boolean equals(Object o)
    {
<span class="nc bnc" id="L354" title="All 2 branches missed.">        if (this == o)</span>
<span class="nc" id="L355">            return true;</span>

<span class="nc bnc" id="L357" title="All 2 branches missed.">        if (!(o instanceof CompactionParams))</span>
<span class="nc" id="L358">            return false;</span>

<span class="nc" id="L360">        CompactionParams cp = (CompactionParams) o;</span>

<span class="nc bnc" id="L362" title="All 4 branches missed.">        return klass.equals(cp.klass) &amp;&amp; options.equals(cp.options);</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L368">        return Objects.hash(klass, options);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>