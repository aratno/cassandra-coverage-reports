<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReadCommand.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db</a> &gt; <span class="el_source">ReadCommand.java</span></div><h1>ReadCommand.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.function.BiFunction;
import java.util.function.LongPredicate;
import java.util.function.Function;
import java.util.stream.Collectors;

import javax.annotation.Nullable;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.Iterables;
import com.google.common.collect.Sets;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.netty.util.concurrent.FastThreadLocal;
import org.apache.cassandra.config.*;
import org.apache.cassandra.db.filter.*;
import org.apache.cassandra.exceptions.QueryCancelledException;
import org.apache.cassandra.net.MessageFlag;
import org.apache.cassandra.net.MessagingService;
import org.apache.cassandra.net.ParamType;
import org.apache.cassandra.net.Verb;
import org.apache.cassandra.db.partitions.*;
import org.apache.cassandra.db.rows.*;
import org.apache.cassandra.db.transform.RTBoundCloser;
import org.apache.cassandra.db.transform.RTBoundValidator;
import org.apache.cassandra.db.transform.RTBoundValidator.Stage;
import org.apache.cassandra.db.transform.StoppingTransformation;
import org.apache.cassandra.db.transform.Transformation;
import org.apache.cassandra.exceptions.UnknownIndexException;
import org.apache.cassandra.index.Index;
import org.apache.cassandra.io.IVersionedSerializer;
import org.apache.cassandra.io.sstable.format.SSTableReader;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.locator.Replica;
import org.apache.cassandra.metrics.TableMetrics;
import org.apache.cassandra.net.Message;
import org.apache.cassandra.schema.IndexMetadata;
import org.apache.cassandra.schema.Schema;
import org.apache.cassandra.schema.SchemaConstants;
import org.apache.cassandra.schema.TableId;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.schema.SchemaProvider;
import org.apache.cassandra.service.ActiveRepairService;
import org.apache.cassandra.service.ClientWarn;
import org.apache.cassandra.tracing.Tracing;
import org.apache.cassandra.utils.CassandraUInt;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.ObjectSizes;
import org.apache.cassandra.utils.TimeUUID;

import static com.google.common.collect.Iterables.any;
import static com.google.common.collect.Iterables.filter;
import static org.apache.cassandra.utils.Clock.Global.nanoTime;
import static org.apache.cassandra.utils.MonotonicClock.Global.approxTime;
import static org.apache.cassandra.db.partitions.UnfilteredPartitionIterators.MergeListener.NOOP;

/**
 * General interface for storage-engine read commands (common to both range and
 * single partition commands).
 * &lt;p&gt;
 * This contains all the informations needed to do a local read.
 */
public abstract class ReadCommand extends AbstractReadQuery
{
<span class="fc" id="L90">    private static final int TEST_ITERATION_DELAY_MILLIS = CassandraRelevantProperties.TEST_READ_ITERATION_DELAY_MS.getInt();</span>

<span class="fc" id="L92">    protected static final Logger logger = LoggerFactory.getLogger(ReadCommand.class);</span>
<span class="fc" id="L93">    public static final IVersionedSerializer&lt;ReadCommand&gt; serializer = new Serializer();</span>

    // Expose the active command running so transitive calls can lookup this command.
    // This is useful for a few reasons, but mainly because the CQL query is here.
<span class="fc" id="L97">    private static final FastThreadLocal&lt;ReadCommand&gt; COMMAND = new FastThreadLocal&lt;&gt;();</span>

    private final Kind kind;

    private final boolean isDigestQuery;
    private final boolean acceptsTransient;
    // if a digest query, the version for which the digest is expected. Ignored if not a digest.
    private int digestVersion;

    private boolean trackWarnings;

    @Nullable
    private final Index.QueryPlan indexQueryPlan;

<span class="fc" id="L111">    protected static abstract class SelectionDeserializer</span>
    {
        public abstract ReadCommand deserialize(DataInputPlus in,
                                                int version,
                                                boolean isDigest,
                                                int digestVersion,
                                                boolean acceptsTransient,
                                                TableMetadata metadata,
                                                long nowInSec,
                                                ColumnFilter columnFilter,
                                                RowFilter rowFilter,
                                                DataLimits limits,
                                                Index.QueryPlan indexQueryPlan) throws IOException;
    }

<span class="fc" id="L126">    protected enum Kind</span>
    {
<span class="fc" id="L128">        SINGLE_PARTITION (SinglePartitionReadCommand.selectionDeserializer),</span>
<span class="fc" id="L129">        PARTITION_RANGE  (PartitionRangeReadCommand.selectionDeserializer);</span>

        private final SelectionDeserializer selectionDeserializer;

        Kind(SelectionDeserializer selectionDeserializer)
<span class="fc" id="L134">        {</span>
<span class="fc" id="L135">            this.selectionDeserializer = selectionDeserializer;</span>
<span class="fc" id="L136">        }</span>
    }

    protected ReadCommand(Kind kind,
                          boolean isDigestQuery,
                          int digestVersion,
                          boolean acceptsTransient,
                          TableMetadata metadata,
                          long nowInSec,
                          ColumnFilter columnFilter,
                          RowFilter rowFilter,
                          DataLimits limits,
                          Index.QueryPlan indexQueryPlan,
                          boolean trackWarnings)
    {
<span class="fc" id="L151">        super(metadata, nowInSec, columnFilter, rowFilter, limits);</span>
<span class="pc bpc" id="L152" title="3 of 4 branches missed.">        if (acceptsTransient &amp;&amp; isDigestQuery)</span>
<span class="nc" id="L153">            throw new IllegalArgumentException(&quot;Attempted to issue a digest response to transient replica&quot;);</span>

<span class="fc" id="L155">        this.kind = kind;</span>
<span class="fc" id="L156">        this.isDigestQuery = isDigestQuery;</span>
<span class="fc" id="L157">        this.digestVersion = digestVersion;</span>
<span class="fc" id="L158">        this.acceptsTransient = acceptsTransient;</span>
<span class="fc" id="L159">        this.indexQueryPlan = indexQueryPlan;</span>
<span class="fc" id="L160">        this.trackWarnings = trackWarnings;</span>
<span class="fc" id="L161">    }</span>

    public static ReadCommand getCommand()
    {
<span class="nc" id="L165">        return COMMAND.get();</span>
    }

    protected abstract void serializeSelection(DataOutputPlus out, int version) throws IOException;
    protected abstract long selectionSerializedSize(int version);

    public abstract boolean isLimitedToOnePartition();

    public abstract boolean isRangeRequest();

    /**
     * Creates a new &lt;code&gt;ReadCommand&lt;/code&gt; instance with new limits.
     *
     * @param newLimits the new limits
     * @return a new &lt;code&gt;ReadCommand&lt;/code&gt; with the updated limits
     */
    public abstract ReadCommand withUpdatedLimit(DataLimits newLimits);

    /**
     * The configured timeout for this command.
     *
     * @return the configured timeout for this command.
     */
    public abstract long getTimeout(TimeUnit unit);

    /**
     * Whether this query is a digest one or not.
     *
     * @return Whether this query is a digest query.
     */
    public boolean isDigestQuery()
    {
<span class="nc" id="L197">        return isDigestQuery;</span>
    }

    /**
     * If the query is a digest one, the requested digest version.
     *
     * @return the requested digest version if the query is a digest. Otherwise, this can return
     * anything.
     */
    public int digestVersion()
    {
<span class="nc" id="L208">        return digestVersion;</span>
    }

    /**
     * Sets the digest version, for when digest for that command is requested.
     * &lt;p&gt;
     * Note that we allow setting this independently of setting the command as a digest query as
     * this allows us to use the command as a carrier of the digest version even if we only call
     * setIsDigestQuery on some copy of it.
     *
     * @param digestVersion the version for the digest is this command is used for digest query..
     * @return this read command.
     */
    public ReadCommand setDigestVersion(int digestVersion)
    {
<span class="nc" id="L223">        this.digestVersion = digestVersion;</span>
<span class="nc" id="L224">        return this;</span>
    }

    /**
     * @return Whether this query expects only a transient data response, or a full response
     */
    public boolean acceptsTransient()
    {
<span class="nc" id="L232">        return acceptsTransient;</span>
    }

    @Override
    public void trackWarnings()
    {
<span class="nc" id="L238">        trackWarnings = true;</span>
<span class="nc" id="L239">    }</span>

    public boolean isTrackingWarnings()
    {
<span class="nc" id="L243">        return trackWarnings;</span>
    }

    /**
     * Index query plan chosen for this query. Can be null.
     *
     * @return index query plan chosen for this query
     */
    @Nullable
    public Index.QueryPlan indexQueryPlan()
    {
<span class="fc" id="L254">        return indexQueryPlan;</span>
    }

    @VisibleForTesting
    public Index.Searcher indexSearcher()
    {
<span class="nc bnc" id="L260" title="All 2 branches missed.">        return indexQueryPlan == null ? null : indexQueryPlan.searcherFor(this);</span>
    }

    /**
     * The clustering index filter this command to use for the provided key.
     * &lt;p&gt;
     * Note that that method should only be called on a key actually queried by this command
     * and in practice, this will almost always return the same filter, but for the sake of
     * paging, the filter on the first key of a range command might be slightly different.
     *
     * @param key a partition key queried by this command.
     *
     * @return the {@code ClusteringIndexFilter} to use for the partition of key {@code key}.
     */
    public abstract ClusteringIndexFilter clusteringIndexFilter(DecoratedKey key);

    /**
     * Returns a copy of this command.
     *
     * @return a copy of this command.
     */
    public abstract ReadCommand copy();

    /**
     * Returns a copy of this command with acceptsTransient set to true.
     */
    public ReadCommand copyAsTransientQuery(Replica replica)
    {
<span class="nc" id="L288">        Preconditions.checkArgument(replica.isTransient(),</span>
                                    &quot;Can't make a transient request on a full replica: &quot; + replica);
<span class="nc" id="L290">        return copyAsTransientQuery();</span>
    }

    /**
     * Returns a copy of this command with acceptsTransient set to true.
     */
    public ReadCommand copyAsTransientQuery(Iterable&lt;Replica&gt; replicas)
    {
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (any(replicas, Replica::isFull))</span>
<span class="nc" id="L299">            throw new IllegalArgumentException(&quot;Can't make a transient request on full replicas: &quot; + Iterables.toString(filter(replicas, Replica::isFull)));</span>
<span class="nc" id="L300">        return copyAsTransientQuery();</span>
    }

    protected abstract ReadCommand copyAsTransientQuery();

    /**
     * Returns a copy of this command with isDigestQuery set to true.
     */
    public ReadCommand copyAsDigestQuery(Replica replica)
    {
<span class="nc" id="L310">        Preconditions.checkArgument(replica.isFull(),</span>
                                    &quot;Can't make a digest request on a transient replica &quot; + replica);
<span class="nc" id="L312">        return copyAsDigestQuery();</span>
    }

    /**
     * Returns a copy of this command with isDigestQuery set to true.
     */
    public ReadCommand copyAsDigestQuery(Iterable&lt;Replica&gt; replicas)
    {
<span class="nc bnc" id="L320" title="All 2 branches missed.">        if (any(replicas, Replica::isTransient))</span>
<span class="nc" id="L321">            throw new IllegalArgumentException(&quot;Can't make a digest request on a transient replica &quot; + Iterables.toString(filter(replicas, Replica::isTransient)));</span>

<span class="nc" id="L323">        return copyAsDigestQuery();</span>
    }

    protected abstract ReadCommand copyAsDigestQuery();

    protected abstract UnfilteredPartitionIterator queryStorage(ColumnFamilyStore cfs, ReadExecutionController executionController);

    /**
     * Whether the underlying {@code ClusteringIndexFilter} is reversed or not.
     *
     * @return whether the underlying {@code ClusteringIndexFilter} is reversed or not.
     */
    public abstract boolean isReversed();

    @SuppressWarnings(&quot;resource&quot;)
    public ReadResponse createResponse(UnfilteredPartitionIterator iterator, RepairedDataInfo rdi)
    {
        // validate that the sequence of RT markers is correct: open is followed by close, deletion times for both
        // ends equal, and there are no dangling RT bound in any partition.
<span class="nc" id="L342">        iterator = RTBoundValidator.validate(iterator, Stage.PROCESSED, true);</span>

<span class="nc bnc" id="L344" title="All 2 branches missed.">        return isDigestQuery()</span>
<span class="nc" id="L345">               ? ReadResponse.createDigestResponse(iterator, this)</span>
<span class="nc" id="L346">               : ReadResponse.createDataResponse(iterator, this, rdi);</span>
    }

    @SuppressWarnings(&quot;resource&quot;) // We don't need to close an empty iterator.
    public ReadResponse createEmptyResponse()
    {
<span class="nc" id="L352">        UnfilteredPartitionIterator iterator = EmptyIterators.unfilteredPartition(metadata());</span>
        
<span class="nc bnc" id="L354" title="All 2 branches missed.">        return isDigestQuery()</span>
<span class="nc" id="L355">               ? ReadResponse.createDigestResponse(iterator, this)</span>
<span class="nc" id="L356">               : ReadResponse.createDataResponse(iterator, this, RepairedDataInfo.NO_OP_REPAIRED_DATA_INFO);</span>
    }

    long indexSerializedSize(int version)
    {
<span class="nc bnc" id="L361" title="All 2 branches missed.">        return null != indexQueryPlan</span>
<span class="nc" id="L362">             ? IndexMetadata.serializer.serializedSize(indexQueryPlan.getFirst().getIndexMetadata(), version)</span>
<span class="nc" id="L363">             : 0;</span>
    }

    static Index.QueryPlan findIndexQueryPlan(TableMetadata table, RowFilter rowFilter)
    {
<span class="pc bpc" id="L368" title="3 of 4 branches missed.">        if (table.indexes.isEmpty() || rowFilter.isEmpty())</span>
<span class="fc" id="L369">            return null;</span>

<span class="nc" id="L371">        ColumnFamilyStore cfs = Keyspace.openAndGetStore(table);</span>

<span class="nc" id="L373">        return cfs.indexManager.getBestIndexQueryPlanFor(rowFilter);</span>
    }

    /**
     * If the index manager for the CFS determines that there's an applicable
     * 2i that can be used to execute this command, call its (optional)
     * validation method to check that nothing in this command's parameters
     * violates the implementation specific validation rules.
     */
    public void maybeValidateIndex()
    {
<span class="nc bnc" id="L384" title="All 2 branches missed.">        if (null != indexQueryPlan)</span>
        {
<span class="nc" id="L386">            indexQueryPlan.validate(this);</span>
        }
<span class="nc" id="L388">    }</span>

    /**
     * Executes this command on the local host.
     *
     * @param executionController the execution controller spanning this command
     *
     * @return an iterator over the result of executing this command locally.
     */
    @SuppressWarnings(&quot;resource&quot;) // The result iterator is closed upon exceptions (we know it's fine to potentially not close the intermediary
                                  // iterators created inside the try as long as we do close the original resultIterator), or by closing the result.
    public UnfilteredPartitionIterator executeLocally(ReadExecutionController executionController)
    {
<span class="fc" id="L401">        long startTimeNanos = nanoTime();</span>

<span class="fc" id="L403">        COMMAND.set(this);</span>
        try
        {
<span class="fc" id="L406">            ColumnFamilyStore cfs = Keyspace.openAndGetStore(metadata());</span>
<span class="fc" id="L407">            Index.QueryPlan indexQueryPlan = indexQueryPlan();</span>

<span class="fc" id="L409">            Index.Searcher searcher = null;</span>
<span class="pc bpc" id="L410" title="1 of 2 branches missed.">            if (indexQueryPlan != null)</span>
            {
<span class="nc" id="L412">                cfs.indexManager.checkQueryability(indexQueryPlan);</span>

<span class="nc" id="L414">                searcher = indexQueryPlan.searcherFor(this);</span>
<span class="nc" id="L415">                Tracing.trace(&quot;Executing read on {}.{} using index{} {}&quot;,</span>
                              cfs.metadata.keyspace,
                              cfs.metadata.name,
<span class="nc bnc" id="L418" title="All 2 branches missed.">                              indexQueryPlan.getIndexes().size() == 1 ? &quot;&quot; : &quot;es&quot;,</span>
<span class="nc" id="L419">                              indexQueryPlan.getIndexes()</span>
<span class="nc" id="L420">                                            .stream()</span>
<span class="nc" id="L421">                                            .map(i -&gt; i.getIndexMetadata().name)</span>
<span class="nc" id="L422">                                            .collect(Collectors.joining(&quot;,&quot;)));</span>
            }

<span class="pc bpc" id="L425" title="1 of 2 branches missed.">            UnfilteredPartitionIterator iterator = (null == searcher) ? queryStorage(cfs, executionController) : searcher.search(executionController);</span>
<span class="fc" id="L426">            iterator = RTBoundValidator.validate(iterator, Stage.MERGED, false);</span>

            try
            {
<span class="fc" id="L430">                iterator = withQuerySizeTracking(iterator);</span>
<span class="fc" id="L431">                iterator = maybeSlowDownForTesting(iterator);</span>
<span class="fc" id="L432">                iterator = withQueryCancellation(iterator);</span>
<span class="fc" id="L433">                iterator = RTBoundValidator.validate(withoutPurgeableTombstones(iterator, cfs, executionController), Stage.PURGED, false);</span>
<span class="fc" id="L434">                iterator = withMetricsRecording(iterator, cfs.metric, startTimeNanos);</span>

                // If we've used a 2ndary index, we know the result already satisfy the primary expression used, so
                // no point in checking it again.
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">                RowFilter filter = (null == searcher) ? rowFilter() : indexQueryPlan.postIndexQueryFilter();</span>

                /*
                 * TODO: We'll currently do filtering by the rowFilter here because it's convenient. However,
                 * we'll probably want to optimize by pushing it down the layer (like for dropped columns) as it
                 * would be more efficient (the sooner we discard stuff we know we don't care, the less useless
                 * processing we do on it).
                 */
<span class="fc" id="L446">                iterator = filter.filter(iterator, nowInSec());</span>

                // apply the limits/row counter; this transformation is stopping and would close the iterator as soon
                // as the count is observed; if that happens in the middle of an open RT, its end bound will not be included.
                // If tracking repaired data, the counter is needed for overreading repaired data, otherwise we can
                // optimise the case where this.limit = DataLimits.NONE which skips an unnecessary transform
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">                if (executionController.isTrackingRepairedStatus())</span>
                {
<span class="nc" id="L454">                    DataLimits.Counter limit =</span>
<span class="nc" id="L455">                    limits().newCounter(nowInSec(), false, selectsFullPartition(), metadata().enforceStrictLiveness());</span>
<span class="nc" id="L456">                    iterator = limit.applyTo(iterator);</span>
                    // ensure that a consistent amount of repaired data is read on each replica. This causes silent
                    // overreading from the repaired data set, up to limits(). The extra data is not visible to
                    // the caller, only iterated to produce the repaired data digest.
<span class="nc" id="L460">                    iterator = executionController.getRepairedDataInfo().extend(iterator, limit);</span>
<span class="nc" id="L461">                }</span>
                else
                {
<span class="fc" id="L464">                    iterator = limits().filter(iterator, nowInSec(), selectsFullPartition());</span>
                }

                // because of the above, we need to append an aritifical end bound if the source iterator was stopped short by a counter.
<span class="fc" id="L468">                return RTBoundCloser.close(iterator);</span>
            }
<span class="nc" id="L470">            catch (RuntimeException | Error e)</span>
            {
<span class="nc" id="L472">                iterator.close();</span>
<span class="nc" id="L473">                throw e;</span>
            }
        }
        finally
        {
<span class="fc" id="L478">            COMMAND.set(null);</span>
        }
    }

    protected abstract void recordLatency(TableMetrics metric, long latencyNanos);

    public ReadExecutionController executionController(boolean trackRepairedStatus)
    {
<span class="nc" id="L486">        return ReadExecutionController.forCommand(this, trackRepairedStatus);</span>
    }

    public ReadExecutionController executionController()
    {
<span class="fc" id="L491">        return ReadExecutionController.forCommand(this, false);</span>
    }

    /**
     * Wraps the provided iterator so that metrics on what is scanned by the command are recorded.
     * This also log warning/trow TombstoneOverwhelmingException if appropriate.
     */
    private UnfilteredPartitionIterator withMetricsRecording(UnfilteredPartitionIterator iter, final TableMetrics metric, final long startTimeNanos)
    {
<span class="fc" id="L500">        class MetricRecording extends Transformation&lt;UnfilteredRowIterator&gt;</span>
        {
<span class="fc" id="L502">            private final int failureThreshold = DatabaseDescriptor.getTombstoneFailureThreshold();</span>
<span class="fc" id="L503">            private final int warningThreshold = DatabaseDescriptor.getTombstoneWarnThreshold();</span>

<span class="pc bpc" id="L505" title="1 of 2 branches missed.">            private final boolean respectTombstoneThresholds = !SchemaConstants.isLocalSystemKeyspace(ReadCommand.this.metadata().keyspace);</span>
<span class="fc" id="L506">            private final boolean enforceStrictLiveness = metadata().enforceStrictLiveness();</span>

<span class="fc" id="L508">            private int liveRows = 0;</span>
<span class="fc" id="L509">            private int lastReportedLiveRows = 0;</span>
<span class="fc" id="L510">            private int tombstones = 0;</span>
<span class="fc" id="L511">            private int lastReportedTombstones = 0;</span>

            private DecoratedKey currentKey;

            @Override
            public UnfilteredRowIterator applyToPartition(UnfilteredRowIterator iter)
            {
<span class="fc" id="L518">                currentKey = iter.partitionKey();</span>
<span class="fc" id="L519">                return Transformation.apply(iter, this);</span>
            }

            @Override
            public Row applyToStatic(Row row)
            {
<span class="fc" id="L525">                return applyToRow(row);</span>
            }

            @Override
            public Row applyToRow(Row row)
            {
<span class="fc" id="L531">                boolean hasTombstones = false;</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">                for (Cell&lt;?&gt; cell : row.cells())</span>
                {
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">                    if (!cell.isLive(ReadCommand.this.nowInSec()))</span>
                    {
<span class="nc" id="L536">                        countTombstone(row.clustering());</span>
<span class="nc" id="L537">                        hasTombstones = true; // allows to avoid counting an extra tombstone if the whole row expired</span>
                    }
<span class="fc" id="L539">                }</span>

<span class="fc bfc" id="L541" title="All 2 branches covered.">                if (row.hasLiveData(ReadCommand.this.nowInSec(), enforceStrictLiveness))</span>
<span class="fc" id="L542">                    ++liveRows;</span>
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">                else if (!row.primaryKeyLivenessInfo().isLive(ReadCommand.this.nowInSec())</span>
<span class="pc bpc" id="L544" title="1 of 4 branches missed.">                        &amp;&amp; row.hasDeletion(ReadCommand.this.nowInSec())</span>
                        &amp;&amp; !hasTombstones)
                {
                    // We're counting primary key deletions only here.
<span class="fc" id="L548">                    countTombstone(row.clustering());</span>
                }

<span class="fc" id="L551">                return row;</span>
            }

            @Override
            public RangeTombstoneMarker applyToMarker(RangeTombstoneMarker marker)
            {
<span class="nc" id="L557">                countTombstone(marker.clustering());</span>
<span class="nc" id="L558">                return marker;</span>
            }

            private void countTombstone(ClusteringPrefix&lt;?&gt; clustering)
            {
<span class="fc" id="L563">                ++tombstones;</span>
<span class="pc bpc" id="L564" title="3 of 4 branches missed.">                if (tombstones &gt; failureThreshold &amp;&amp; respectTombstoneThresholds)</span>
                {
<span class="nc" id="L566">                    String query = ReadCommand.this.toCQLString();</span>
<span class="nc" id="L567">                    Tracing.trace(&quot;Scanned over {} tombstones for query {}; query aborted (see tombstone_failure_threshold)&quot;, failureThreshold, query);</span>
<span class="nc" id="L568">                    metric.tombstoneFailures.inc();</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">                    if (trackWarnings)</span>
                    {
<span class="nc" id="L571">                        MessageParams.remove(ParamType.TOMBSTONE_WARNING);</span>
<span class="nc" id="L572">                        MessageParams.add(ParamType.TOMBSTONE_FAIL, tombstones);</span>
                    }
<span class="nc" id="L574">                    throw new TombstoneOverwhelmingException(tombstones, query, ReadCommand.this.metadata(), currentKey, clustering);</span>
                }
<span class="fc" id="L576">            }</span>

            @Override
            protected void onPartitionClose()
            {
<span class="fc" id="L581">                int lr = liveRows - lastReportedLiveRows;</span>
<span class="fc" id="L582">                int ts = tombstones - lastReportedTombstones;</span>

<span class="fc bfc" id="L584" title="All 2 branches covered.">                if (lr &gt; 0)</span>
<span class="fc" id="L585">                    metric.topReadPartitionRowCount.addSample(currentKey.getKey(), lr);</span>

<span class="fc bfc" id="L587" title="All 2 branches covered.">                if (ts &gt; 0)</span>
<span class="fc" id="L588">                    metric.topReadPartitionTombstoneCount.addSample(currentKey.getKey(), ts);</span>

<span class="fc" id="L590">                lastReportedLiveRows = liveRows;</span>
<span class="fc" id="L591">                lastReportedTombstones = tombstones;</span>
<span class="fc" id="L592">            }</span>

            @Override
            public void onClose()
            {
<span class="fc" id="L597">                recordLatency(metric, nanoTime() - startTimeNanos);</span>

<span class="fc" id="L599">                metric.tombstoneScannedHistogram.update(tombstones);</span>
<span class="fc" id="L600">                metric.liveScannedHistogram.update(liveRows);</span>

<span class="pc bpc" id="L602" title="3 of 4 branches missed.">                boolean warnTombstones = tombstones &gt; warningThreshold &amp;&amp; respectTombstoneThresholds;</span>
<span class="pc bpc" id="L603" title="1 of 2 branches missed.">                if (warnTombstones)</span>
                {
<span class="nc" id="L605">                    String msg = String.format(</span>
                            &quot;Read %d live rows and %d tombstone cells for query %1.512s; token %s (see tombstone_warn_threshold)&quot;,
<span class="nc" id="L607">                            liveRows, tombstones, ReadCommand.this.toCQLString(), currentKey.getToken());</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">                    if (trackWarnings)</span>
<span class="nc" id="L609">                        MessageParams.add(ParamType.TOMBSTONE_WARNING, tombstones);</span>
                    else
<span class="nc" id="L611">                        ClientWarn.instance.warn(msg);</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">                    if (tombstones &lt; failureThreshold)</span>
                    {
<span class="nc" id="L614">                        metric.tombstoneWarnings.inc();</span>
                    }

<span class="nc" id="L617">                    logger.warn(msg);</span>
                }

<span class="fc" id="L620">                Tracing.trace(&quot;Read {} live rows and {} tombstone cells{}&quot;,</span>
<span class="fc" id="L621">                        liveRows, tombstones,</span>
<span class="pc bpc" id="L622" title="1 of 2 branches missed.">                        (warnTombstones ? &quot; (see tombstone_warn_threshold)&quot; : &quot;&quot;));</span>
<span class="fc" id="L623">            }</span>
        }

<span class="fc" id="L626">        return Transformation.apply(iter, new MetricRecording());</span>
    }

    private boolean shouldTrackSize(DataStorageSpec.LongBytesBound warnThresholdBytes, DataStorageSpec.LongBytesBound abortThresholdBytes)
    {
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">        return trackWarnings</span>
<span class="pc bnc" id="L632" title="All 6 branches missed.">               &amp;&amp; !SchemaConstants.isSystemKeyspace(metadata().keyspace)</span>
               &amp;&amp; !(warnThresholdBytes == null &amp;&amp; abortThresholdBytes == null);
    }

    private UnfilteredPartitionIterator withQuerySizeTracking(UnfilteredPartitionIterator iterator)
    {
<span class="fc" id="L638">        DataStorageSpec.LongBytesBound warnThreshold = DatabaseDescriptor.getLocalReadSizeWarnThreshold();</span>
<span class="fc" id="L639">        DataStorageSpec.LongBytesBound failThreshold = DatabaseDescriptor.getLocalReadSizeFailThreshold();</span>
<span class="pc bpc" id="L640" title="1 of 2 branches missed.">        if (!shouldTrackSize(warnThreshold, failThreshold))</span>
<span class="fc" id="L641">            return iterator;</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">        final long warnBytes = warnThreshold == null ? -1 : warnThreshold.toBytes();</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">        final long failBytes = failThreshold == null ? -1 : failThreshold.toBytes();</span>
<span class="nc" id="L644">        class QuerySizeTracking extends Transformation&lt;UnfilteredRowIterator&gt;</span>
        {
<span class="nc" id="L646">            private long sizeInBytes = 0;</span>

            @Override
            public UnfilteredRowIterator applyToPartition(UnfilteredRowIterator iter)
            {
<span class="nc" id="L651">                sizeInBytes += ObjectSizes.sizeOnHeapOf(iter.partitionKey().getKey());</span>
<span class="nc" id="L652">                return Transformation.apply(iter, this);</span>
            }

            @Override
            protected Row applyToStatic(Row row)
            {
<span class="nc" id="L658">                return applyToRow(row);</span>
            }

            @Override
            protected Row applyToRow(Row row)
            {
<span class="nc" id="L664">                addSize(row.unsharedHeapSize());</span>
<span class="nc" id="L665">                return row;</span>
            }

            @Override
            protected RangeTombstoneMarker applyToMarker(RangeTombstoneMarker marker)
            {
<span class="nc" id="L671">                addSize(marker.unsharedHeapSize());</span>
<span class="nc" id="L672">                return marker;</span>
            }

            @Override
            protected DeletionTime applyToDeletion(DeletionTime deletionTime)
            {
<span class="nc" id="L678">                addSize(deletionTime.unsharedHeapSize());</span>
<span class="nc" id="L679">                return deletionTime;</span>
            }

            private void addSize(long size)
            {
<span class="nc" id="L684">                this.sizeInBytes += size;</span>
<span class="nc bnc" id="L685" title="All 4 branches missed.">                if (failBytes != -1 &amp;&amp; this.sizeInBytes &gt;= failBytes)</span>
                {
<span class="nc" id="L687">                    String msg = String.format(&quot;Query %s attempted to read %d bytes but max allowed is %s; query aborted  (see local_read_size_fail_threshold)&quot;,</span>
<span class="nc" id="L688">                                               ReadCommand.this.toCQLString(), this.sizeInBytes, failThreshold);</span>
<span class="nc" id="L689">                    Tracing.trace(msg);</span>
<span class="nc" id="L690">                    MessageParams.remove(ParamType.LOCAL_READ_SIZE_WARN);</span>
<span class="nc" id="L691">                    MessageParams.add(ParamType.LOCAL_READ_SIZE_FAIL, this.sizeInBytes);</span>
<span class="nc" id="L692">                    throw new LocalReadSizeTooLargeException(msg);</span>
                }
<span class="nc bnc" id="L694" title="All 4 branches missed.">                else if (warnBytes != -1 &amp;&amp; this.sizeInBytes &gt;= warnBytes)</span>
                {
<span class="nc" id="L696">                    MessageParams.add(ParamType.LOCAL_READ_SIZE_WARN, this.sizeInBytes);</span>
                }
<span class="nc" id="L698">            }</span>

            @Override
            protected void onClose()
            {
<span class="nc" id="L703">                ColumnFamilyStore cfs = Schema.instance.getColumnFamilyStoreInstance(metadata().id);</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">                if (cfs != null)</span>
<span class="nc" id="L705">                    cfs.metric.localReadSize.update(sizeInBytes);</span>
<span class="nc" id="L706">            }</span>
        }

<span class="nc" id="L709">        iterator = Transformation.apply(iterator, new QuerySizeTracking());</span>
<span class="nc" id="L710">        return iterator;</span>
    }

<span class="fc" id="L713">    private class QueryCancellationChecker extends StoppingTransformation&lt;UnfilteredRowIterator&gt;</span>
    {
<span class="fc" id="L715">        long lastCheckedAt = 0;</span>

        @Override
        protected UnfilteredRowIterator applyToPartition(UnfilteredRowIterator partition)
        {
<span class="fc" id="L720">            maybeCancel();</span>
<span class="fc" id="L721">            return Transformation.apply(partition, this);</span>
        }

        @Override
        protected Row applyToRow(Row row)
        {
<span class="fc" id="L727">            maybeCancel();</span>
<span class="fc" id="L728">            return row;</span>
        }

        private void maybeCancel()
        {
            /*
             * The value returned by approxTime.now() is updated only every
             * {@link org.apache.cassandra.utils.MonotonicClock.SampledClock.CHECK_INTERVAL_MS}, by default 2 millis.
             * Since MonitorableImpl relies on approxTime, we don't need to check unless the approximate time has elapsed.
             */
<span class="fc bfc" id="L738" title="All 2 branches covered.">            if (lastCheckedAt == approxTime.now())</span>
<span class="fc" id="L739">                return;</span>
<span class="fc" id="L740">            lastCheckedAt = approxTime.now();</span>

<span class="pc bpc" id="L742" title="1 of 2 branches missed.">            if (isAborted())</span>
            {
<span class="nc" id="L744">                stop();</span>
<span class="nc" id="L745">                throw new QueryCancelledException(ReadCommand.this);</span>
            }
<span class="fc" id="L747">        }</span>
    }

    private UnfilteredPartitionIterator withQueryCancellation(UnfilteredPartitionIterator iter)
    {
<span class="fc" id="L752">        return Transformation.apply(iter, new QueryCancellationChecker());</span>
    }

    /**
     *  A transformation used for simulating slow queries by tests.
     */
    private static class DelayInjector extends Transformation&lt;UnfilteredRowIterator&gt;
    {
        @Override
        protected UnfilteredRowIterator applyToPartition(UnfilteredRowIterator partition)
        {
<span class="nc" id="L763">            FBUtilities.sleepQuietly(TEST_ITERATION_DELAY_MILLIS);</span>
<span class="nc" id="L764">            return Transformation.apply(partition, this);</span>
        }

        @Override
        protected Row applyToRow(Row row)
        {
<span class="nc" id="L770">            FBUtilities.sleepQuietly(TEST_ITERATION_DELAY_MILLIS);</span>
<span class="nc" id="L771">            return row;</span>
        }
    }

    private UnfilteredPartitionIterator maybeSlowDownForTesting(UnfilteredPartitionIterator iter)
    {
<span class="pc bpc" id="L777" title="3 of 4 branches missed.">        if (TEST_ITERATION_DELAY_MILLIS &gt; 0 &amp;&amp; !SchemaConstants.isSystemKeyspace(metadata().keyspace))</span>
<span class="nc" id="L778">            return Transformation.apply(iter, new DelayInjector());</span>
        else
<span class="fc" id="L780">            return iter;</span>
    }

    /**
     * Creates a message for this command.
     */
    public Message&lt;ReadCommand&gt; createMessage(boolean trackRepairedData)
    {
<span class="nc bnc" id="L788" title="All 2 branches missed.">        Message&lt;ReadCommand&gt; msg = trackRepairedData</span>
<span class="nc" id="L789">                                   ? Message.outWithFlags(verb(), this, MessageFlag.CALL_BACK_ON_FAILURE, MessageFlag.TRACK_REPAIRED_DATA)</span>
<span class="nc" id="L790">                                   : Message.outWithFlag(verb(), this, MessageFlag.CALL_BACK_ON_FAILURE);</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">        if (trackWarnings)</span>
<span class="nc" id="L792">            msg = msg.withFlag(MessageFlag.TRACK_WARNINGS);</span>
<span class="nc" id="L793">        return msg;</span>
    }

    protected abstract boolean intersects(SSTableReader sstable);

    protected boolean hasRequiredStatics(SSTableReader sstable) {
        // If some static columns are queried, we should always include the sstable: the clustering values stats of the sstable
        // don't tell us if the sstable contains static values in particular.
<span class="pc bpc" id="L801" title="3 of 4 branches missed.">        return !columnFilter().fetchedColumns().statics.isEmpty() &amp;&amp; sstable.header.hasStatic();</span>
    }

    protected boolean hasPartitionLevelDeletions(SSTableReader sstable)
    {
<span class="fc" id="L806">        return sstable.getSSTableMetadata().hasPartitionLevelDeletions;</span>
    }

    public abstract Verb verb();

    protected abstract void appendCQLWhereClause(StringBuilder sb);

    // Skip purgeable tombstones. We do this because it's safe to do (post-merge of the memtable and sstable at least), it
    // can save us some bandwith, and avoid making us throw a TombstoneOverwhelmingException for purgeable tombstones (which
    // are to some extend an artefact of compaction lagging behind and hence counting them is somewhat unintuitive).
    protected UnfilteredPartitionIterator withoutPurgeableTombstones(UnfilteredPartitionIterator iterator, 
                                                                     ColumnFamilyStore cfs,
                                                                     ReadExecutionController controller)
    {
        class WithoutPurgeableTombstones extends PurgeFunction
        {
            public WithoutPurgeableTombstones()
<span class="fc" id="L823">            {</span>
<span class="fc" id="L824">                super(nowInSec(), cfs.gcBefore(nowInSec()), controller.oldestUnrepairedTombstone(),</span>
<span class="fc" id="L825">                      cfs.getCompactionStrategyManager().onlyPurgeRepairedTombstones(),</span>
<span class="fc" id="L826">                      iterator.metadata().enforceStrictLiveness());</span>
<span class="fc" id="L827">            }</span>

            protected LongPredicate getPurgeEvaluator()
            {
<span class="nc" id="L831">                return time -&gt; true;</span>
            }
        }
<span class="fc" id="L834">        return Transformation.apply(iterator, new WithoutPurgeableTombstones());</span>
    }

    /**
     * Return the queried token(s) for logging
     */
    public abstract String loggableTokens();

    // Monitorable interface
    public String name()
    {
<span class="nc" id="L845">        return toCQLString();</span>
    }

    @SuppressWarnings(&quot;resource&quot;) // resultant iterators are closed by their callers
    InputCollector&lt;UnfilteredRowIterator&gt; iteratorsForPartition(ColumnFamilyStore.ViewFragment view, ReadExecutionController controller)
    {
<span class="nc" id="L851">        final BiFunction&lt;List&lt;UnfilteredRowIterator&gt;, RepairedDataInfo, UnfilteredRowIterator&gt; merge =</span>
            (unfilteredRowIterators, repairedDataInfo) -&gt; {
<span class="nc" id="L853">                UnfilteredRowIterator repaired = UnfilteredRowIterators.merge(unfilteredRowIterators);</span>
<span class="nc" id="L854">                return repairedDataInfo.withRepairedDataInfo(repaired);</span>
            };

        // For single partition reads, after reading up to the command's DataLimit nothing extra is required.
        // The merged &amp; repaired row iterator will be consumed until it's exhausted or the RepairedDataInfo's
        // internal counter is satisfied
<span class="nc" id="L860">        final Function&lt;UnfilteredRowIterator, UnfilteredPartitionIterator&gt; postLimitPartitions =</span>
<span class="nc" id="L861">            (rows) -&gt; EmptyIterators.unfilteredPartition(metadata());</span>
<span class="nc" id="L862">        return new InputCollector&lt;&gt;(view, controller, merge, postLimitPartitions);</span>
    }

    @SuppressWarnings(&quot;resource&quot;) // resultant iterators are closed by their callers
    InputCollector&lt;UnfilteredPartitionIterator&gt; iteratorsForRange(ColumnFamilyStore.ViewFragment view, ReadExecutionController controller)
    {
<span class="fc" id="L868">        final BiFunction&lt;List&lt;UnfilteredPartitionIterator&gt;, RepairedDataInfo, UnfilteredPartitionIterator&gt; merge =</span>
            (unfilteredPartitionIterators, repairedDataInfo) -&gt; {
<span class="nc" id="L870">                UnfilteredPartitionIterator repaired = UnfilteredPartitionIterators.merge(unfilteredPartitionIterators,</span>
                                                                                          NOOP);
<span class="nc" id="L872">                return repairedDataInfo.withRepairedDataInfo(repaired);</span>
            };

        // Uses identity function to provide additional partitions to be consumed after the command's
        // DataLimits are satisfied. The input to the function will be the iterator of merged, repaired partitions
        // which we'll keep reading until the RepairedDataInfo's internal counter is satisfied.
<span class="fc" id="L878">        return new InputCollector&lt;&gt;(view, controller, merge, Function.identity());</span>
    }

    /**
     * Handles the collation of unfiltered row or partition iterators that comprise the
     * input for a query. Separates them according to repaired status and of repaired
     * status is being tracked, handles the merge and wrapping in a digest generator of
     * the repaired iterators.
     *
     * Intentionally not AutoCloseable so we don't mistakenly use this in ARM blocks
     * as this prematurely closes the underlying iterators
     */
    static class InputCollector&lt;T extends AutoCloseable&gt;
    {
        final RepairedDataInfo repairedDataInfo;
        private final boolean isTrackingRepairedStatus;
        Set&lt;SSTableReader&gt; repairedSSTables;
        BiFunction&lt;List&lt;T&gt;, RepairedDataInfo, T&gt; repairedMerger;
        Function&lt;T, UnfilteredPartitionIterator&gt; postLimitAdditionalPartitions;
        List&lt;T&gt; repairedIters;
        List&lt;T&gt; unrepairedIters;

        InputCollector(ColumnFamilyStore.ViewFragment view,
                       ReadExecutionController controller,
                       BiFunction&lt;List&lt;T&gt;, RepairedDataInfo, T&gt; repairedMerger,
                       Function&lt;T, UnfilteredPartitionIterator&gt; postLimitAdditionalPartitions)
<span class="fc" id="L904">        {</span>
<span class="fc" id="L905">            this.repairedDataInfo = controller.getRepairedDataInfo();</span>
<span class="fc" id="L906">            this.isTrackingRepairedStatus = controller.isTrackingRepairedStatus();</span>
            
<span class="pc bpc" id="L908" title="1 of 2 branches missed.">            if (isTrackingRepairedStatus)</span>
            {
<span class="nc bnc" id="L910" title="All 2 branches missed.">                for (SSTableReader sstable : view.sstables)</span>
                {
<span class="nc bnc" id="L912" title="All 2 branches missed.">                    if (considerRepairedForTracking(sstable))</span>
                    {
<span class="nc bnc" id="L914" title="All 2 branches missed.">                        if (repairedSSTables == null)</span>
<span class="nc" id="L915">                            repairedSSTables = Sets.newHashSetWithExpectedSize(view.sstables.size());</span>
<span class="nc" id="L916">                        repairedSSTables.add(sstable);</span>
                    }
<span class="nc" id="L918">                }</span>
            }
<span class="pc bpc" id="L920" title="1 of 2 branches missed.">            if (repairedSSTables == null)</span>
            {
<span class="fc" id="L922">                repairedIters = Collections.emptyList();</span>
<span class="fc" id="L923">                unrepairedIters = new ArrayList&lt;&gt;(view.sstables.size());</span>
            }
            else
            {
<span class="nc" id="L927">                repairedIters = new ArrayList&lt;&gt;(repairedSSTables.size());</span>
                // when we're done collating, we'll merge the repaired iters and add the
                // result to the unrepaired list, so size that list accordingly
<span class="nc" id="L930">                unrepairedIters = new ArrayList&lt;&gt;((view.sstables.size() - repairedSSTables.size()) + Iterables.size(view.memtables) + 1);</span>
            }
<span class="fc" id="L932">            this.repairedMerger = repairedMerger;</span>
<span class="fc" id="L933">            this.postLimitAdditionalPartitions = postLimitAdditionalPartitions;</span>
<span class="fc" id="L934">        }</span>

        void addMemtableIterator(T iter)
        {
<span class="fc" id="L938">            unrepairedIters.add(iter);</span>
<span class="fc" id="L939">        }</span>

        void addSSTableIterator(SSTableReader sstable, T iter)
        {
<span class="nc bnc" id="L943" title="All 4 branches missed.">            if (repairedSSTables != null &amp;&amp; repairedSSTables.contains(sstable))</span>
<span class="nc" id="L944">                repairedIters.add(iter);</span>
            else
<span class="nc" id="L946">                unrepairedIters.add(iter);</span>
<span class="nc" id="L947">        }</span>

        @SuppressWarnings(&quot;resource&quot;) // the returned iterators are closed by the caller
        List&lt;T&gt; finalizeIterators(ColumnFamilyStore cfs, long nowInSec, long oldestUnrepairedTombstone)
        {
<span class="pc bpc" id="L952" title="1 of 2 branches missed.">            if (repairedIters.isEmpty())</span>
<span class="fc" id="L953">                return unrepairedIters;</span>

            // merge the repaired data before returning, wrapping in a digest generator
<span class="nc" id="L956">            repairedDataInfo.prepare(cfs, nowInSec, oldestUnrepairedTombstone);</span>
<span class="nc" id="L957">            T repairedIter = repairedMerger.apply(repairedIters, repairedDataInfo);</span>
<span class="nc" id="L958">            repairedDataInfo.finalize(postLimitAdditionalPartitions.apply(repairedIter));</span>
<span class="nc" id="L959">            unrepairedIters.add(repairedIter);</span>
<span class="nc" id="L960">            return unrepairedIters;</span>
        }

        boolean isEmpty()
        {
<span class="pc bpc" id="L965" title="2 of 4 branches missed.">            return repairedIters.isEmpty() &amp;&amp; unrepairedIters.isEmpty();</span>
        }

        // For tracking purposes we consider data repaired if the sstable is either:
        // * marked repaired
        // * marked pending, but the local session has been committed. This reduces the window
        //   whereby the tracking is affected by compaction backlog causing repaired sstables to
        //   remain in the pending state
        // If an sstable is involved in a pending repair which is not yet committed, we mark the
        // repaired data info inconclusive, as the same data on other replicas may be in a
        // slightly different state.
        private boolean considerRepairedForTracking(SSTableReader sstable)
        {
<span class="nc bnc" id="L978" title="All 2 branches missed.">            if (!isTrackingRepairedStatus)</span>
<span class="nc" id="L979">                return false;</span>

<span class="nc" id="L981">            TimeUUID pendingRepair = sstable.getPendingRepair();</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">            if (pendingRepair != ActiveRepairService.NO_PENDING_REPAIR)</span>
            {
<span class="nc bnc" id="L984" title="All 2 branches missed.">                if (ActiveRepairService.instance().consistent.local.isSessionFinalized(pendingRepair))</span>
<span class="nc" id="L985">                    return true;</span>

                // In the edge case where compaction is backed up long enough for the session to
                // timeout and be purged by LocalSessions::cleanup, consider the sstable unrepaired
                // as it will be marked unrepaired when compaction catches up
<span class="nc bnc" id="L990" title="All 2 branches missed.">                if (!ActiveRepairService.instance().consistent.local.sessionExists(pendingRepair))</span>
<span class="nc" id="L991">                    return false;</span>

<span class="nc" id="L993">                repairedDataInfo.markInconclusive();</span>
            }

<span class="nc" id="L996">            return sstable.isRepaired();</span>
        }

        void markInconclusive()
        {
<span class="nc" id="L1001">            repairedDataInfo.markInconclusive();</span>
<span class="nc" id="L1002">        }</span>

        public void close() throws Exception
        {
<span class="nc" id="L1006">            FBUtilities.closeAll(unrepairedIters);</span>
<span class="nc" id="L1007">            FBUtilities.closeAll(repairedIters);</span>
<span class="nc" id="L1008">        }</span>
    }

    @VisibleForTesting
    public static class Serializer implements IVersionedSerializer&lt;ReadCommand&gt;
    {
        private final SchemaProvider schema;

        public Serializer()
        {
<span class="fc" id="L1018">            this(Schema.instance);</span>
<span class="fc" id="L1019">        }</span>

        @VisibleForTesting
        public Serializer(SchemaProvider schema)
<span class="fc" id="L1023">        {</span>
<span class="fc" id="L1024">            this.schema = Objects.requireNonNull(schema, &quot;schema&quot;);</span>
<span class="fc" id="L1025">        }</span>

        private static int digestFlag(boolean isDigest)
        {
<span class="nc bnc" id="L1029" title="All 2 branches missed.">            return isDigest ? 0x01 : 0;</span>
        }

        private static boolean isDigest(int flags)
        {
<span class="nc bnc" id="L1034" title="All 2 branches missed.">            return (flags &amp; 0x01) != 0;</span>
        }

        private static boolean acceptsTransient(int flags)
        {
<span class="nc bnc" id="L1039" title="All 2 branches missed.">            return (flags &amp; 0x08) != 0;</span>
        }

        private static int acceptsTransientFlag(boolean acceptsTransient)
        {
<span class="nc bnc" id="L1044" title="All 2 branches missed.">            return acceptsTransient ? 0x08 : 0;</span>
        }

        // We don't set this flag anymore, but still look if we receive a
        // command with it set in case someone is using thrift a mixed 3.0/4.0+
        // cluster (which is unsupported). This is also a reminder for not
        // re-using this flag until we drop 3.0/3.X compatibility (since it's
        // used by these release for thrift and would thus confuse things)
        private static boolean isForThrift(int flags)
        {
<span class="nc bnc" id="L1054" title="All 2 branches missed.">            return (flags &amp; 0x02) != 0;</span>
        }

        private static int indexFlag(boolean hasIndex)
        {
<span class="nc bnc" id="L1059" title="All 2 branches missed.">            return hasIndex ? 0x04 : 0;</span>
        }

        private static boolean hasIndex(int flags)
        {
<span class="nc bnc" id="L1064" title="All 2 branches missed.">            return (flags &amp; 0x04) != 0;</span>
        }

        public void serialize(ReadCommand command, DataOutputPlus out, int version) throws IOException
        {
<span class="nc" id="L1069">            out.writeByte(command.kind.ordinal());</span>
<span class="nc" id="L1070">            out.writeByte(</span>
<span class="nc" id="L1071">                    digestFlag(command.isDigestQuery())</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">                    | indexFlag(null != command.indexQueryPlan())</span>
<span class="nc" id="L1073">                    | acceptsTransientFlag(command.acceptsTransient())</span>
            );
<span class="nc bnc" id="L1075" title="All 2 branches missed.">            if (command.isDigestQuery())</span>
<span class="nc" id="L1076">                out.writeUnsignedVInt32(command.digestVersion());</span>
<span class="nc" id="L1077">            command.metadata().id.serialize(out);</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">            out.writeInt(version &gt;= MessagingService.VERSION_50 ? CassandraUInt.fromLong(command.nowInSec()) : (int) command.nowInSec());</span>
<span class="nc" id="L1079">            ColumnFilter.serializer.serialize(command.columnFilter(), out, version);</span>
<span class="nc" id="L1080">            RowFilter.serializer.serialize(command.rowFilter(), out, version);</span>
<span class="nc" id="L1081">            DataLimits.serializer.serialize(command.limits(), out, version, command.metadata().comparator);</span>
            // Using the name of one of the indexes in the plan to identify the index group because we want
            // to keep compatibility with legacy nodes. Each replica can create its own different index query plan
            // from the index name.
<span class="nc bnc" id="L1085" title="All 2 branches missed.">            if (null != command.indexQueryPlan)</span>
<span class="nc" id="L1086">                IndexMetadata.serializer.serialize(command.indexQueryPlan.getFirst().getIndexMetadata(), out, version);</span>

<span class="nc" id="L1088">            command.serializeSelection(out, version);</span>
<span class="nc" id="L1089">        }</span>

        public ReadCommand deserialize(DataInputPlus in, int version) throws IOException
        {
<span class="nc" id="L1093">            Kind kind = Kind.values()[in.readByte()];</span>
<span class="nc" id="L1094">            int flags = in.readByte();</span>
<span class="nc" id="L1095">            boolean isDigest = isDigest(flags);</span>
<span class="nc" id="L1096">            boolean acceptsTransient = acceptsTransient(flags);</span>
            // Shouldn't happen or it's a user error (see comment above) but
            // better complain loudly than doing the wrong thing.
<span class="nc bnc" id="L1099" title="All 2 branches missed.">            if (isForThrift(flags))</span>
<span class="nc" id="L1100">                throw new IllegalStateException(&quot;Received a command with the thrift flag set. &quot;</span>
                                              + &quot;This means thrift is in use in a mixed 3.0/3.X and 4.0+ cluster, &quot;
                                              + &quot;which is unsupported. Make sure to stop using thrift before &quot;
                                              + &quot;upgrading to 4.0&quot;);

<span class="nc" id="L1105">            boolean hasIndex = hasIndex(flags);</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">            int digestVersion = isDigest ? in.readUnsignedVInt32() : 0;</span>
<span class="nc" id="L1107">            TableMetadata metadata = schema.getExistingTableMetadata(TableId.deserialize(in));</span>
<span class="nc bnc" id="L1108" title="All 2 branches missed.">            long nowInSec = version &gt;= MessagingService.VERSION_50 ? CassandraUInt.toLong(in.readInt()) : in.readInt();</span>
<span class="nc" id="L1109">            ColumnFilter columnFilter = ColumnFilter.serializer.deserialize(in, version, metadata);</span>
<span class="nc" id="L1110">            RowFilter rowFilter = RowFilter.serializer.deserialize(in, version, metadata);</span>
<span class="nc" id="L1111">            DataLimits limits = DataLimits.serializer.deserialize(in, version,  metadata);</span>

<span class="nc" id="L1113">            Index.QueryPlan indexQueryPlan = null;</span>
<span class="nc bnc" id="L1114" title="All 2 branches missed.">            if (hasIndex)</span>
            {
<span class="nc" id="L1116">                IndexMetadata index = deserializeIndexMetadata(in, version, metadata);</span>
<span class="nc" id="L1117">                Index.Group indexGroup =  Keyspace.openAndGetStore(metadata).indexManager.getIndexGroup(index);</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">                if (indexGroup != null)</span>
<span class="nc" id="L1119">                    indexQueryPlan = indexGroup.queryPlanFor(rowFilter);</span>
            }

<span class="nc" id="L1122">            return kind.selectionDeserializer.deserialize(in, version, isDigest, digestVersion, acceptsTransient, metadata, nowInSec, columnFilter, rowFilter, limits, indexQueryPlan);</span>
        }

        private IndexMetadata deserializeIndexMetadata(DataInputPlus in, int version, TableMetadata metadata) throws IOException
        {
            try
            {
<span class="nc" id="L1129">                return IndexMetadata.serializer.deserialize(in, version, metadata);</span>
            }
<span class="nc" id="L1131">            catch (UnknownIndexException e)</span>
            {
<span class="nc" id="L1133">                logger.info(&quot;Couldn't find a defined index on {}.{} with the id {}. &quot; +</span>
                            &quot;If an index was just created, this is likely due to the schema not &quot; +
                            &quot;being fully propagated. Local read will proceed without using the &quot; +
                            &quot;index. Please wait for schema agreement after index creation.&quot;,
                            metadata.keyspace, metadata.name, e.indexId);
<span class="nc" id="L1138">                return null;</span>
            }
        }

        public long serializedSize(ReadCommand command, int version)
        {
<span class="nc" id="L1144">            return 2 // kind + flags</span>
<span class="nc bnc" id="L1145" title="All 2 branches missed.">                   + (command.isDigestQuery() ? TypeSizes.sizeofUnsignedVInt(command.digestVersion()) : 0)</span>
<span class="nc" id="L1146">                   + command.metadata().id.serializedSize()</span>
                   + TypeSizes.INT_SIZE // command.nowInSec() is serialized as uint
<span class="nc" id="L1148">                   + ColumnFilter.serializer.serializedSize(command.columnFilter(), version)</span>
<span class="nc" id="L1149">                   + RowFilter.serializer.serializedSize(command.rowFilter(), version)</span>
<span class="nc" id="L1150">                   + DataLimits.serializer.serializedSize(command.limits(), version, command.metadata().comparator)</span>
<span class="nc" id="L1151">                   + command.selectionSerializedSize(version)</span>
<span class="nc" id="L1152">                   + command.indexSerializedSize(version);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>