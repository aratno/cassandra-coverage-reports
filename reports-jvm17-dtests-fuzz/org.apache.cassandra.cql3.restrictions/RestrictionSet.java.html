<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RestrictionSet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.restrictions</a> &gt; <span class="el_source">RestrictionSet.java</span></div><h1>RestrictionSet.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3.restrictions;

import java.util.*;

import com.google.common.collect.AbstractIterator;

import org.apache.cassandra.index.Index;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.cql3.QueryOptions;
import org.apache.cassandra.cql3.functions.Function;
import org.apache.cassandra.db.filter.RowFilter;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.index.IndexRegistry;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;

/**
 * Sets of column restrictions.
 *
 * &lt;p&gt;This class is immutable.&lt;/p&gt;
 */
final class RestrictionSet implements Restrictions, Iterable&lt;SingleRestriction&gt;
{
    /**
     * The comparator used to sort the &lt;code&gt;Restriction&lt;/code&gt;s.
     */
<span class="fc" id="L44">    private static final Comparator&lt;ColumnMetadata&gt; COLUMN_DEFINITION_COMPARATOR = new Comparator&lt;ColumnMetadata&gt;()</span>
<span class="fc" id="L45">    {</span>
        @Override
        public int compare(ColumnMetadata column, ColumnMetadata otherColumn)
        {
<span class="fc" id="L49">            int value = Integer.compare(column.position(), otherColumn.position());</span>
<span class="fc bfc" id="L50" title="All 2 branches covered.">            return value != 0 ? value : column.name.bytes.compareTo(otherColumn.name.bytes);</span>
        }
    };

<span class="fc" id="L54">    private static final TreeMap&lt;ColumnMetadata, SingleRestriction&gt; EMPTY = new TreeMap&lt;&gt;(COLUMN_DEFINITION_COMPARATOR);</span>

    /**
     * The restrictions per column.
     */
    private final TreeMap&lt;ColumnMetadata, SingleRestriction&gt; restrictions;

    /**
     * {@code true} if it contains multi-column restrictions, {@code false} otherwise.
     */
    private final boolean hasMultiColumnRestrictions;

    private final boolean hasIn;
    private final boolean hasContains;
    private final boolean hasSlice;
    private final boolean hasOnlyEqualityRestrictions;

    public RestrictionSet()
    {
<span class="fc" id="L73">        this(EMPTY, false,</span>
             false,
             false,
             false,
             true);
<span class="fc" id="L78">    }</span>

    private RestrictionSet(TreeMap&lt;ColumnMetadata, SingleRestriction&gt; restrictions,
                           boolean hasMultiColumnRestrictions,
                           boolean hasIn,
                           boolean hasContains,
                           boolean hasSlice,
                           boolean hasOnlyEqualityRestrictions)
<span class="fc" id="L86">    {</span>
<span class="fc" id="L87">        this.restrictions = restrictions;</span>
<span class="fc" id="L88">        this.hasMultiColumnRestrictions = hasMultiColumnRestrictions;</span>
<span class="fc" id="L89">        this.hasIn = hasIn;</span>
<span class="fc" id="L90">        this.hasContains = hasContains;</span>
<span class="fc" id="L91">        this.hasSlice = hasSlice;</span>
<span class="fc" id="L92">        this.hasOnlyEqualityRestrictions = hasOnlyEqualityRestrictions;</span>
<span class="fc" id="L93">    }</span>

    @Override
    public void addToRowFilter(RowFilter filter, IndexRegistry indexRegistry, QueryOptions options) throws InvalidRequestException
    {
<span class="nc bnc" id="L98" title="All 2 branches missed.">        for (Restriction restriction : restrictions.values())</span>
<span class="nc" id="L99">            restriction.addToRowFilter(filter, indexRegistry, options);</span>
<span class="nc" id="L100">    }</span>

    @Override
    public boolean needsFiltering(Index.Group indexGroup)
    {
<span class="nc bnc" id="L105" title="All 2 branches missed.">        for (SingleRestriction restriction : restrictions.values())</span>
        {
<span class="nc bnc" id="L107" title="All 2 branches missed.">            if (restriction.needsFiltering(indexGroup))</span>
<span class="nc" id="L108">                return true;</span>
<span class="nc" id="L109">        }</span>
<span class="nc" id="L110">        return false;</span>
    }

    @Override
    public List&lt;ColumnMetadata&gt; getColumnDefs()
    {
<span class="nc" id="L116">        return new ArrayList&lt;&gt;(restrictions.keySet());</span>
    }

    /**
     * @return a direct reference to the key set from {@link #restrictions} with no defenseive copying
     */
    @Override
    public Collection&lt;ColumnMetadata&gt; getColumnDefinitions()
    {
<span class="nc" id="L125">        return restrictions.keySet();</span>
    }

    @Override
    public void addFunctionsTo(List&lt;Function&gt; functions)
    {
<span class="nc bnc" id="L131" title="All 2 branches missed.">        for (Restriction restriction : this)</span>
<span class="nc" id="L132">            restriction.addFunctionsTo(functions);</span>
<span class="nc" id="L133">    }</span>

    @Override
    public boolean isEmpty()
    {
<span class="fc" id="L138">        return restrictions.isEmpty();</span>
    }

    @Override
    public int size()
    {
<span class="fc" id="L144">        return restrictions.size();</span>
    }

    /**
     * Checks if one of the restrictions applies to a column of the specific kind.
     * @param kind the column kind
     * @return {@code true} if one of the restrictions applies to a column of the specific kind, {@code false} otherwise.
     */
    public boolean hasRestrictionFor(ColumnMetadata.Kind kind)
    {
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">        for (ColumnMetadata column : restrictions.keySet())</span>
        {
<span class="nc bnc" id="L156" title="All 2 branches missed.">            if (column.kind == kind)</span>
<span class="nc" id="L157">                return true;</span>
<span class="nc" id="L158">        }</span>
<span class="fc" id="L159">        return false;</span>
    }

    /**
     * Adds the specified restriction to this set of restrictions.
     *
     * @param restriction the restriction to add
     * @return the new set of restrictions
     */
    public RestrictionSet addRestriction(SingleRestriction restriction)
    {
        // RestrictionSet is immutable so we need to clone the restrictions map.
<span class="fc" id="L171">        TreeMap&lt;ColumnMetadata, SingleRestriction&gt; newRestricitons = new TreeMap&lt;&gt;(this.restrictions);</span>

<span class="pc bpc" id="L173" title="2 of 4 branches missed.">        boolean newHasIn = hasIn || restriction.isIN();</span>
<span class="pc bpc" id="L174" title="2 of 4 branches missed.">        boolean newHasContains = hasContains || restriction.isContains();</span>
<span class="fc bfc" id="L175" title="All 4 branches covered.">        boolean newHasSlice = hasSlice || restriction.isSlice();</span>
<span class="pc bpc" id="L176" title="1 of 6 branches missed.">        boolean newHasOnlyEqualityRestrictions = hasOnlyEqualityRestrictions &amp;&amp; (restriction.isEQ() || restriction.isIN());</span>

<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        return new RestrictionSet(mergeRestrictions(newRestricitons, restriction),</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">                                  hasMultiColumnRestrictions || restriction.isMultiColumn(),</span>
                                  newHasIn,
                                  newHasContains,
                                  newHasSlice,
                                  newHasOnlyEqualityRestrictions);
    }

    private TreeMap&lt;ColumnMetadata, SingleRestriction&gt; mergeRestrictions(TreeMap&lt;ColumnMetadata, SingleRestriction&gt; restrictions,
                                                                         SingleRestriction restriction)
    {
<span class="fc" id="L189">        Collection&lt;ColumnMetadata&gt; columnDefs = restriction.getColumnDefs();</span>
<span class="fc" id="L190">        Set&lt;SingleRestriction&gt; existingRestrictions = getRestrictions(columnDefs);</span>

<span class="fc bfc" id="L192" title="All 2 branches covered.">        if (existingRestrictions.isEmpty())</span>
        {
<span class="fc bfc" id="L194" title="All 2 branches covered.">            for (ColumnMetadata columnDef : columnDefs)</span>
<span class="fc" id="L195">                restrictions.put(columnDef, restriction);</span>
        }
        else
        {
<span class="fc bfc" id="L199" title="All 2 branches covered.">            for (SingleRestriction existing : existingRestrictions)</span>
            {
<span class="fc" id="L201">                SingleRestriction newRestriction = mergeRestrictions(existing, restriction);</span>

<span class="fc bfc" id="L203" title="All 2 branches covered.">                for (ColumnMetadata columnDef : columnDefs)</span>
<span class="fc" id="L204">                    restrictions.put(columnDef, newRestriction);</span>
<span class="fc" id="L205">            }</span>
        }

<span class="fc" id="L208">        return restrictions;</span>
    }

    @Override
    public Set&lt;Restriction&gt; getRestrictions(ColumnMetadata columnDef)
    {
<span class="nc" id="L214">        Restriction existing = restrictions.get(columnDef);</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">        return existing == null ? Collections.emptySet() : Collections.singleton(existing);</span>
    }

    /**
     * Returns all the restrictions applied to the specified columns.
     *
     * @param columnDefs the column definitions
     * @return all the restrictions applied to the specified columns
     */
    private Set&lt;SingleRestriction&gt; getRestrictions(Collection&lt;ColumnMetadata&gt; columnDefs)
    {
<span class="fc" id="L226">        Set&lt;SingleRestriction&gt; set = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">        for (ColumnMetadata columnDef : columnDefs)</span>
        {
<span class="fc" id="L229">            SingleRestriction existing = restrictions.get(columnDef);</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">            if (existing != null)</span>
<span class="fc" id="L231">                set.add(existing);</span>
<span class="fc" id="L232">        }</span>
<span class="fc" id="L233">        return set;</span>
    }

    @Override
    public boolean hasSupportingIndex(IndexRegistry indexRegistry)
    {
<span class="fc bfc" id="L239" title="All 2 branches covered.">        for (Restriction restriction : restrictions.values())</span>
        {
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">            if (restriction.hasSupportingIndex(indexRegistry))</span>
<span class="nc" id="L242">                return true;</span>
<span class="fc" id="L243">        }</span>
<span class="fc" id="L244">        return false;</span>
    }

    /**
     * Returns the column after the specified one.
     *
     * @param columnDef the column for which the next one need to be found
     * @return the column after the specified one.
     */
    ColumnMetadata nextColumn(ColumnMetadata columnDef)
    {
<span class="nc" id="L255">        return restrictions.tailMap(columnDef, false).firstKey();</span>
    }

    @Override
    public ColumnMetadata getFirstColumn()
    {
<span class="nc bnc" id="L261" title="All 2 branches missed.">        return isEmpty() ? null : this.restrictions.firstKey();</span>
    }

    @Override
    public ColumnMetadata getLastColumn()
    {
<span class="nc bnc" id="L267" title="All 2 branches missed.">        return isEmpty() ? null : this.restrictions.lastKey();</span>
    }

    /**
     * Returns the last restriction.
     *
     * @return the last restriction.
     */
    SingleRestriction lastRestriction()
    {
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">        return isEmpty() ? null : this.restrictions.lastEntry().getValue();</span>
    }

    /**
     * Merges the two specified restrictions.
     *
     * @param restriction the first restriction
     * @param otherRestriction the second restriction
     * @return the merged restriction
     * @throws InvalidRequestException if the two restrictions cannot be merged
     */
    private static SingleRestriction mergeRestrictions(SingleRestriction restriction,
                                                       SingleRestriction otherRestriction)
    {
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">        return restriction == null ? otherRestriction</span>
<span class="fc" id="L292">                                   : restriction.mergeWith(otherRestriction);</span>
    }

    @Override
    public Iterator&lt;SingleRestriction&gt; iterator()
    {
<span class="fc" id="L298">        Iterator&lt;SingleRestriction&gt; iterator = restrictions.values().iterator();</span>
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        return hasMultiColumnRestrictions ? new DistinctIterator&lt;&gt;(iterator) : iterator;</span>
    }

    /**
     * Checks if any of the underlying restriction is an IN.
     * @return &lt;code&gt;true&lt;/code&gt; if any of the underlying restriction is an IN, &lt;code&gt;false&lt;/code&gt; otherwise
     */
    public final boolean hasIN()
    {
<span class="fc" id="L308">        return hasIn;</span>
    }

    public boolean hasContains()
    {
<span class="fc" id="L313">        return hasContains;</span>
    }

    public final boolean hasSlice()
    {
<span class="fc" id="L318">        return hasSlice;</span>
    }

    /**
     * Checks if all of the underlying restrictions are EQ or IN restrictions.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if all of the underlying restrictions are EQ or IN restrictions,
     * &lt;code&gt;false&lt;/code&gt; otherwise
     */
    public final boolean hasOnlyEqualityRestrictions()
    {
<span class="fc" id="L329">        return hasOnlyEqualityRestrictions;</span>
    }

    /**
     * {@code Iterator} decorator that removes duplicates in an ordered one.
     *
     * @param &lt;E&gt; the iterator element type.
     */
    private static final class DistinctIterator&lt;E&gt; extends AbstractIterator&lt;E&gt;
    {
        /**
         * The decorated iterator.
         */
        private final Iterator&lt;E&gt; iterator;

        /**
         * The previous element.
         */
        private E previous;

        public DistinctIterator(Iterator&lt;E&gt; iterator)
        {
            this.iterator = iterator;
        }

        protected E computeNext()
        {
            while(iterator.hasNext())
            {
                E next = iterator.next();
                if (!next.equals(previous))
                {
                    previous = next;
                    return next;
                }
            }
            return endOfData();
        }
    }
    
    @Override
    public String toString()
    {
<span class="nc" id="L372">        return ToStringBuilder.reflectionToString(this, ToStringStyle.SHORT_PREFIX_STYLE);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>