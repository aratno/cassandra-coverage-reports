<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SystemKeyspace.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db</a> &gt; <span class="el_source">SystemKeyspace.java</span></div><h1>SystemKeyspace.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db;

import java.io.IOError;
import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.TimeUnit;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;
import javax.management.openmbean.OpenDataException;
import javax.management.openmbean.TabularData;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.SetMultimap;
import com.google.common.collect.Sets;
import com.google.common.io.ByteStreams;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.cql3.QueryProcessor;
import org.apache.cassandra.cql3.UntypedResultSet;
import org.apache.cassandra.cql3.statements.schema.CreateTableStatement;
import org.apache.cassandra.db.commitlog.CommitLog;
import org.apache.cassandra.db.commitlog.CommitLogPosition;
import org.apache.cassandra.db.compaction.CompactionHistoryTabularData;
import org.apache.cassandra.db.marshal.ByteBufferAccessor;
import org.apache.cassandra.db.marshal.BytesType;
import org.apache.cassandra.db.marshal.LongType;
import org.apache.cassandra.db.marshal.TimeUUIDType;
import org.apache.cassandra.db.marshal.TupleType;
import org.apache.cassandra.db.marshal.UTF8Type;
import org.apache.cassandra.db.marshal.UUIDType;
import org.apache.cassandra.db.partitions.PartitionUpdate;
import org.apache.cassandra.db.rows.Row;
import org.apache.cassandra.db.rows.Rows;
import org.apache.cassandra.dht.IPartitioner;
import org.apache.cassandra.dht.LocalPartitioner;
import org.apache.cassandra.dht.Range;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.io.sstable.SSTableId;
import org.apache.cassandra.io.sstable.SequenceBasedSSTableId;
import org.apache.cassandra.io.util.DataInputBuffer;
import org.apache.cassandra.io.util.DataOutputBuffer;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.io.util.RebufferingInputStream;
import org.apache.cassandra.locator.IEndpointSnitch;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.metrics.RestorableMeter;
import org.apache.cassandra.metrics.TopPartitionTracker;
import org.apache.cassandra.net.MessagingService;
import org.apache.cassandra.schema.CompactionParams;
import org.apache.cassandra.schema.KeyspaceMetadata;
import org.apache.cassandra.schema.KeyspaceParams;
import org.apache.cassandra.schema.Schema;
import org.apache.cassandra.schema.SchemaConstants;
import org.apache.cassandra.schema.TableId;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.schema.Tables;
import org.apache.cassandra.schema.Types;
import org.apache.cassandra.schema.UserFunctions;
import org.apache.cassandra.schema.Views;
import org.apache.cassandra.service.StorageService;
import org.apache.cassandra.service.paxos.Ballot;
import org.apache.cassandra.service.paxos.Commit;
import org.apache.cassandra.service.paxos.Commit.Accepted;
import org.apache.cassandra.service.paxos.Commit.AcceptedWithTTL;
import org.apache.cassandra.service.paxos.Commit.Committed;
import org.apache.cassandra.service.paxos.PaxosRepairHistory;
import org.apache.cassandra.service.paxos.PaxosState;
import org.apache.cassandra.service.paxos.uncommitted.PaxosRows;
import org.apache.cassandra.service.paxos.uncommitted.PaxosUncommittedIndex;
import org.apache.cassandra.streaming.StreamOperation;
import org.apache.cassandra.transport.ProtocolVersion;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.CassandraVersion;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.MD5Digest;
import org.apache.cassandra.utils.Pair;
import org.apache.cassandra.utils.TimeUUID;
import org.apache.cassandra.utils.concurrent.Future;

import static java.lang.String.format;
import static java.util.Collections.emptyMap;
import static java.util.Collections.singletonMap;
import static org.apache.cassandra.config.Config.PaxosStatePurging.legacy;
import static org.apache.cassandra.config.DatabaseDescriptor.paxosStatePurging;
import static org.apache.cassandra.cql3.QueryProcessor.executeInternal;
import static org.apache.cassandra.cql3.QueryProcessor.executeInternalWithNowInSec;
import static org.apache.cassandra.cql3.QueryProcessor.executeOnceInternal;
import static org.apache.cassandra.service.paxos.Commit.latest;
import static org.apache.cassandra.utils.CassandraVersion.NULL_VERSION;
import static org.apache.cassandra.utils.CassandraVersion.UNREADABLE_VERSION;
import static org.apache.cassandra.utils.Clock.Global.currentTimeMillis;
import static org.apache.cassandra.utils.FBUtilities.now;

public final class SystemKeyspace
{
    private SystemKeyspace()
    {
    }

<span class="fc" id="L142">    private static final Logger logger = LoggerFactory.getLogger(SystemKeyspace.class);</span>

<span class="fc" id="L144">    public static final CassandraVersion CURRENT_VERSION = new CassandraVersion(FBUtilities.getReleaseVersionString());</span>

    public static final String BATCHES = &quot;batches&quot;;
    public static final String PAXOS = &quot;paxos&quot;;
    public static final String PAXOS_REPAIR_HISTORY = &quot;paxos_repair_history&quot;;
    public static final String PAXOS_REPAIR_STATE = &quot;_paxos_repair_state&quot;;
    public static final String BUILT_INDEXES = &quot;IndexInfo&quot;;
    public static final String LOCAL = &quot;local&quot;;
    public static final String PEERS_V2 = &quot;peers_v2&quot;;
    public static final String PEER_EVENTS_V2 = &quot;peer_events_v2&quot;;
    public static final String COMPACTION_HISTORY = &quot;compaction_history&quot;;
    public static final String SSTABLE_ACTIVITY_V2 = &quot;sstable_activity_v2&quot;; // v2 has modified generation column type (v1 - int, v2 - blob), see CASSANDRA-17048
    public static final String TABLE_ESTIMATES = &quot;table_estimates&quot;;
    public static final String TABLE_ESTIMATES_TYPE_PRIMARY = &quot;primary&quot;;
    public static final String TABLE_ESTIMATES_TYPE_LOCAL_PRIMARY = &quot;local_primary&quot;;
    public static final String AVAILABLE_RANGES_V2 = &quot;available_ranges_v2&quot;;
    public static final String TRANSFERRED_RANGES_V2 = &quot;transferred_ranges_v2&quot;;
    public static final String VIEW_BUILDS_IN_PROGRESS = &quot;view_builds_in_progress&quot;;
    public static final String BUILT_VIEWS = &quot;built_views&quot;;
    public static final String PREPARED_STATEMENTS = &quot;prepared_statements&quot;;
    public static final String REPAIRS = &quot;repairs&quot;;
    public static final String TOP_PARTITIONS = &quot;top_partitions&quot;;

    /**
     * By default the system keyspace tables should be stored in a single data directory to allow the server
     * to handle more gracefully disk failures. Some tables through can be split accross multiple directories
     * as the server can continue operating even if those tables lost some data.
     */
<span class="fc" id="L172">    public static final Set&lt;String&gt; TABLES_SPLIT_ACROSS_MULTIPLE_DISKS = ImmutableSet.of(BATCHES,</span>
                                                                                         PAXOS,
                                                                                         COMPACTION_HISTORY,
                                                                                         PREPARED_STATEMENTS,
                                                                                         REPAIRS);

    @Deprecated public static final String LEGACY_PEERS = &quot;peers&quot;;
    @Deprecated public static final String LEGACY_PEER_EVENTS = &quot;peer_events&quot;;
    @Deprecated public static final String LEGACY_TRANSFERRED_RANGES = &quot;transferred_ranges&quot;;
    @Deprecated public static final String LEGACY_AVAILABLE_RANGES = &quot;available_ranges&quot;;
    @Deprecated public static final String LEGACY_SIZE_ESTIMATES = &quot;size_estimates&quot;;
    @Deprecated public static final String LEGACY_SSTABLE_ACTIVITY = &quot;sstable_activity&quot;;

    // Names of all tables that could have been a part of a system keyspace. Useful for pre-flight checks.
    // For details, see CASSANDRA-17777
<span class="fc" id="L187">    public static final Set&lt;String&gt; ALL_TABLE_NAMES = ImmutableSet.of(</span>
        BATCHES, PAXOS, PAXOS_REPAIR_HISTORY, PAXOS_REPAIR_STATE, BUILT_INDEXES, LOCAL, PEERS_V2, PEER_EVENTS_V2,
        COMPACTION_HISTORY, SSTABLE_ACTIVITY_V2, TABLE_ESTIMATES, TABLE_ESTIMATES_TYPE_PRIMARY,
        TABLE_ESTIMATES_TYPE_LOCAL_PRIMARY, AVAILABLE_RANGES_V2, TRANSFERRED_RANGES_V2, VIEW_BUILDS_IN_PROGRESS,
        BUILT_VIEWS, PREPARED_STATEMENTS, REPAIRS, TOP_PARTITIONS, LEGACY_PEERS, LEGACY_PEER_EVENTS,
        LEGACY_TRANSFERRED_RANGES, LEGACY_AVAILABLE_RANGES, LEGACY_SIZE_ESTIMATES, LEGACY_SSTABLE_ACTIVITY);

<span class="fc" id="L194">    public static final Set&lt;String&gt; TABLE_NAMES = ImmutableSet.of(</span>
        BATCHES, PAXOS, PAXOS_REPAIR_HISTORY, BUILT_INDEXES, LOCAL, PEERS_V2, PEER_EVENTS_V2, 
        COMPACTION_HISTORY, SSTABLE_ACTIVITY_V2, TABLE_ESTIMATES, AVAILABLE_RANGES_V2, TRANSFERRED_RANGES_V2, VIEW_BUILDS_IN_PROGRESS, 
        BUILT_VIEWS, PREPARED_STATEMENTS, REPAIRS, TOP_PARTITIONS, LEGACY_PEERS, LEGACY_PEER_EVENTS, 
        LEGACY_TRANSFERRED_RANGES, LEGACY_AVAILABLE_RANGES, LEGACY_SIZE_ESTIMATES, LEGACY_SSTABLE_ACTIVITY);

<span class="fc" id="L200">    public static final TableMetadata Batches =</span>
<span class="fc" id="L201">        parse(BATCHES,</span>
              &quot;batches awaiting replay&quot;,
              &quot;CREATE TABLE %s (&quot;
              + &quot;id timeuuid,&quot;
              + &quot;mutations list&lt;blob&gt;,&quot;
              + &quot;version int,&quot;
              + &quot;PRIMARY KEY ((id)))&quot;)
<span class="fc" id="L208">              .partitioner(new LocalPartitioner(TimeUUIDType.instance))</span>
<span class="fc" id="L209">              .compaction(CompactionParams.stcs(singletonMap(&quot;min_threshold&quot;, &quot;2&quot;)))</span>
<span class="fc" id="L210">              .build();</span>

<span class="fc" id="L212">    private static final TableMetadata Paxos =</span>
<span class="fc" id="L213">        parse(PAXOS,</span>
                &quot;in-progress paxos proposals&quot;,
                &quot;CREATE TABLE %s (&quot;
                + &quot;row_key blob,&quot;
                + &quot;cf_id UUID,&quot;
                + &quot;in_progress_ballot timeuuid,&quot;
                + &quot;in_progress_read_ballot timeuuid,&quot;
                + &quot;most_recent_commit blob,&quot;
                + &quot;most_recent_commit_at timeuuid,&quot;
                + &quot;most_recent_commit_version int,&quot;
                + &quot;proposal blob,&quot;
                + &quot;proposal_ballot timeuuid,&quot;
                + &quot;proposal_version int,&quot;
                + &quot;PRIMARY KEY ((row_key), cf_id))&quot;)
<span class="fc" id="L227">                .compaction(CompactionParams.lcs(emptyMap()))</span>
<span class="fc" id="L228">                .indexes(PaxosUncommittedIndex.indexes())</span>
<span class="fc" id="L229">                .build();</span>

<span class="fc" id="L231">    private static final TableMetadata BuiltIndexes =</span>
<span class="fc" id="L232">        parse(BUILT_INDEXES,</span>
              &quot;built column indexes&quot;,
              &quot;CREATE TABLE \&quot;%s\&quot; (&quot;
              + &quot;table_name text,&quot; // table_name here is the name of the keyspace - don't be fooled
              + &quot;index_name text,&quot;
              + &quot;value blob,&quot; // Table used to be compact in previous versions
              + &quot;PRIMARY KEY ((table_name), index_name)) &quot;)
<span class="fc" id="L239">              .build();</span>

<span class="fc" id="L241">    private static final TableMetadata PaxosRepairHistoryTable =</span>
<span class="fc" id="L242">        parse(PAXOS_REPAIR_HISTORY,</span>
                &quot;paxos repair history&quot;,
                &quot;CREATE TABLE %s (&quot;
                + &quot;keyspace_name text,&quot;
                + &quot;table_name text,&quot;
                + &quot;points frozen&lt;list&lt;tuple&lt;blob, timeuuid&gt;&gt;&gt;, &quot;
                + &quot;PRIMARY KEY (keyspace_name, table_name))&quot;
                + &quot;WITH COMMENT='Last successful paxos repairs by range'&quot;)
<span class="fc" id="L250">        .build();</span>

<span class="fc" id="L252">    private static final TableMetadata Local =</span>
<span class="fc" id="L253">        parse(LOCAL,</span>
                &quot;information about the local node&quot;,
                &quot;CREATE TABLE %s (&quot;
                + &quot;key text,&quot;
                + &quot;bootstrapped text,&quot;
                + &quot;broadcast_address inet,&quot;
                + &quot;broadcast_port int,&quot;
                + &quot;cluster_name text,&quot;
                + &quot;cql_version text,&quot;
                + &quot;data_center text,&quot;
                + &quot;gossip_generation int,&quot;
                + &quot;host_id uuid,&quot;
                + &quot;listen_address inet,&quot;
                + &quot;listen_port int,&quot;
                + &quot;native_protocol_version text,&quot;
                + &quot;partitioner text,&quot;
                + &quot;rack text,&quot;
                + &quot;release_version text,&quot;
                + &quot;rpc_address inet,&quot;
                + &quot;rpc_port int,&quot;
                + &quot;schema_version uuid,&quot;
                + &quot;tokens set&lt;varchar&gt;,&quot;
                + &quot;truncated_at map&lt;uuid, blob&gt;,&quot;
                + &quot;PRIMARY KEY ((key)))&quot;
<span class="fc" id="L277">                ).recordDeprecatedSystemColumn(&quot;thrift_version&quot;, UTF8Type.instance)</span>
<span class="fc" id="L278">                .build();</span>

<span class="fc" id="L280">    private static final TableMetadata PeersV2 =</span>
<span class="fc" id="L281">        parse(PEERS_V2,</span>
                &quot;information about known peers in the cluster&quot;,
                &quot;CREATE TABLE %s (&quot;
                + &quot;peer inet,&quot;
                + &quot;peer_port int,&quot;
                + &quot;data_center text,&quot;
                + &quot;host_id uuid,&quot;
                + &quot;preferred_ip inet,&quot;
                + &quot;preferred_port int,&quot;
                + &quot;rack text,&quot;
                + &quot;release_version text,&quot;
                + &quot;native_address inet,&quot;
                + &quot;native_port int,&quot;
                + &quot;schema_version uuid,&quot;
                + &quot;tokens set&lt;varchar&gt;,&quot;
                + &quot;PRIMARY KEY ((peer), peer_port))&quot;)
<span class="fc" id="L297">                .build();</span>

<span class="fc" id="L299">    private static final TableMetadata PeerEventsV2 =</span>
<span class="fc" id="L300">        parse(PEER_EVENTS_V2,</span>
                &quot;events related to peers&quot;,
                &quot;CREATE TABLE %s (&quot;
                + &quot;peer inet,&quot;
                + &quot;peer_port int,&quot;
                + &quot;hints_dropped map&lt;timeuuid, int&gt;,&quot;
                + &quot;PRIMARY KEY ((peer), peer_port))&quot;)
<span class="fc" id="L307">                .build();</span>

<span class="fc" id="L309">    private static final TableMetadata CompactionHistory =</span>
<span class="fc" id="L310">        parse(COMPACTION_HISTORY,</span>
                &quot;week-long compaction history&quot;,
                &quot;CREATE TABLE %s (&quot;
                + &quot;id timeuuid,&quot;
                + &quot;bytes_in bigint,&quot;
                + &quot;bytes_out bigint,&quot;
                + &quot;columnfamily_name text,&quot;
                + &quot;compacted_at timestamp,&quot;
                + &quot;keyspace_name text,&quot;
                + &quot;rows_merged map&lt;int, bigint&gt;,&quot;
                + &quot;compaction_properties frozen&lt;map&lt;text, text&gt;&gt;,&quot;
                + &quot;PRIMARY KEY ((id)))&quot;)
<span class="fc" id="L322">                .defaultTimeToLive((int) TimeUnit.DAYS.toSeconds(7))</span>
<span class="fc" id="L323">                .build();</span>

<span class="fc" id="L325">    private static final TableMetadata LegacySSTableActivity =</span>
<span class="fc" id="L326">        parse(LEGACY_SSTABLE_ACTIVITY,</span>
                &quot;historic sstable read rates&quot;,
                &quot;CREATE TABLE %s (&quot;
                + &quot;keyspace_name text,&quot;
                + &quot;columnfamily_name text,&quot;
                + &quot;generation int,&quot;
                + &quot;rate_120m double,&quot;
                + &quot;rate_15m double,&quot;
                + &quot;PRIMARY KEY ((keyspace_name, columnfamily_name, generation)))&quot;)
<span class="fc" id="L335">                .build();</span>

<span class="fc" id="L337">    private static final TableMetadata SSTableActivity =</span>
<span class="fc" id="L338">        parse(SSTABLE_ACTIVITY_V2,</span>
                &quot;historic sstable read rates&quot;,
                &quot;CREATE TABLE %s (&quot;
                + &quot;keyspace_name text,&quot;
                + &quot;table_name text,&quot;
                + &quot;id text,&quot;
                + &quot;rate_120m double,&quot;
                + &quot;rate_15m double,&quot;
                + &quot;PRIMARY KEY ((keyspace_name, table_name, id)))&quot;)
<span class="fc" id="L347">                .build();</span>

    @Deprecated
<span class="fc" id="L350">    private static final TableMetadata LegacySizeEstimates =</span>
<span class="fc" id="L351">        parse(LEGACY_SIZE_ESTIMATES,</span>
              &quot;per-table primary range size estimates, table is deprecated in favor of &quot; + TABLE_ESTIMATES,
                &quot;CREATE TABLE %s (&quot;
                + &quot;keyspace_name text,&quot;
                + &quot;table_name text,&quot;
                + &quot;range_start text,&quot;
                + &quot;range_end text,&quot;
                + &quot;mean_partition_size bigint,&quot;
                + &quot;partitions_count bigint,&quot;
                + &quot;PRIMARY KEY ((keyspace_name), table_name, range_start, range_end))&quot;)
<span class="fc" id="L361">                .build();</span>

<span class="fc" id="L363">    private static final TableMetadata TableEstimates =</span>
<span class="fc" id="L364">        parse(TABLE_ESTIMATES,</span>
              &quot;per-table range size estimates&quot;,
              &quot;CREATE TABLE %s (&quot;
               + &quot;keyspace_name text,&quot;
               + &quot;table_name text,&quot;
               + &quot;range_type text,&quot;
               + &quot;range_start text,&quot;
               + &quot;range_end text,&quot;
               + &quot;mean_partition_size bigint,&quot;
               + &quot;partitions_count bigint,&quot;
               + &quot;PRIMARY KEY ((keyspace_name), table_name, range_type, range_start, range_end))&quot;)
<span class="fc" id="L375">               .build();</span>

<span class="fc" id="L377">    private static final TableMetadata AvailableRangesV2 =</span>
<span class="fc" id="L378">    parse(AVAILABLE_RANGES_V2,</span>
          &quot;available keyspace/ranges during bootstrap/replace that are ready to be served&quot;,
          &quot;CREATE TABLE %s (&quot;
          + &quot;keyspace_name text,&quot;
          + &quot;full_ranges set&lt;blob&gt;,&quot;
          + &quot;transient_ranges set&lt;blob&gt;,&quot;
          + &quot;PRIMARY KEY ((keyspace_name)))&quot;)
<span class="fc" id="L385">    .build();</span>

<span class="fc" id="L387">    private static final TableMetadata TransferredRangesV2 =</span>
<span class="fc" id="L388">        parse(TRANSFERRED_RANGES_V2,</span>
                &quot;record of transferred ranges for streaming operation&quot;,
                &quot;CREATE TABLE %s (&quot;
                + &quot;operation text,&quot;
                + &quot;peer inet,&quot;
                + &quot;peer_port int,&quot;
                + &quot;keyspace_name text,&quot;
                + &quot;ranges set&lt;blob&gt;,&quot;
                + &quot;PRIMARY KEY ((operation, keyspace_name), peer, peer_port))&quot;)
<span class="fc" id="L397">                .build();</span>

<span class="fc" id="L399">    private static final TableMetadata ViewBuildsInProgress =</span>
<span class="fc" id="L400">        parse(VIEW_BUILDS_IN_PROGRESS,</span>
              &quot;views builds current progress&quot;,
              &quot;CREATE TABLE %s (&quot;
              + &quot;keyspace_name text,&quot;
              + &quot;view_name text,&quot;
              + &quot;start_token varchar,&quot;
              + &quot;end_token varchar,&quot;
              + &quot;last_token varchar,&quot;
              + &quot;keys_built bigint,&quot;
              + &quot;PRIMARY KEY ((keyspace_name), view_name, start_token, end_token))&quot;)
<span class="fc" id="L410">              .build();</span>

<span class="fc" id="L412">    private static final TableMetadata BuiltViews =</span>
<span class="fc" id="L413">        parse(BUILT_VIEWS,</span>
                &quot;built views&quot;,
                &quot;CREATE TABLE %s (&quot;
                + &quot;keyspace_name text,&quot;
                + &quot;view_name text,&quot;
                + &quot;status_replicated boolean,&quot;
                + &quot;PRIMARY KEY ((keyspace_name), view_name))&quot;)
<span class="fc" id="L420">                .build();</span>

<span class="fc" id="L422">    private static final TableMetadata TopPartitions =</span>
<span class="fc" id="L423">        parse(TOP_PARTITIONS,</span>
                &quot;Stores the top partitions&quot;,
                &quot;CREATE TABLE  %s (&quot;
                + &quot;keyspace_name text,&quot;
                + &quot;table_name text,&quot;
                + &quot;top_type text,&quot;
                + &quot;top frozen&lt;list&lt;tuple&lt;text, bigint&gt;&gt;&gt;,&quot;
                + &quot;last_update timestamp,&quot;
                + &quot;PRIMARY KEY (keyspace_name, table_name, top_type))&quot;)
<span class="fc" id="L432">                .build();</span>


<span class="fc" id="L435">    private static final TableMetadata PreparedStatements =</span>
<span class="fc" id="L436">        parse(PREPARED_STATEMENTS,</span>
                &quot;prepared statements&quot;,
                &quot;CREATE TABLE %s (&quot;
                + &quot;prepared_id blob,&quot;
                + &quot;logged_keyspace text,&quot;
                + &quot;query_string text,&quot;
                + &quot;PRIMARY KEY ((prepared_id)))&quot;)
<span class="fc" id="L443">                .build();</span>

<span class="fc" id="L445">    private static final TableMetadata Repairs =</span>
<span class="fc" id="L446">        parse(REPAIRS,</span>
          &quot;repairs&quot;,
          &quot;CREATE TABLE %s (&quot;
          + &quot;parent_id timeuuid, &quot;
          + &quot;started_at timestamp, &quot;
          + &quot;last_update timestamp, &quot;
          + &quot;repaired_at timestamp, &quot;
          + &quot;state int, &quot;
          + &quot;coordinator inet, &quot;
          + &quot;coordinator_port int,&quot;
          + &quot;participants set&lt;inet&gt;,&quot;
          + &quot;participants_wp set&lt;text&gt;,&quot;
          + &quot;ranges set&lt;blob&gt;, &quot;
          + &quot;cfids set&lt;uuid&gt;, &quot;
<span class="fc" id="L460">          + &quot;PRIMARY KEY (parent_id))&quot;).build();</span>

    @Deprecated
<span class="fc" id="L463">    private static final TableMetadata LegacyPeers =</span>
<span class="fc" id="L464">        parse(LEGACY_PEERS,</span>
            &quot;information about known peers in the cluster&quot;,
            &quot;CREATE TABLE %s (&quot;
            + &quot;peer inet,&quot;
            + &quot;data_center text,&quot;
            + &quot;host_id uuid,&quot;
            + &quot;preferred_ip inet,&quot;
            + &quot;rack text,&quot;
            + &quot;release_version text,&quot;
            + &quot;rpc_address inet,&quot;
            + &quot;schema_version uuid,&quot;
            + &quot;tokens set&lt;varchar&gt;,&quot;
            + &quot;PRIMARY KEY ((peer)))&quot;)
<span class="fc" id="L477">            .build();</span>

    @Deprecated
<span class="fc" id="L480">    private static final TableMetadata LegacyPeerEvents =</span>
<span class="fc" id="L481">        parse(LEGACY_PEER_EVENTS,</span>
            &quot;events related to peers&quot;,
            &quot;CREATE TABLE %s (&quot;
            + &quot;peer inet,&quot;
            + &quot;hints_dropped map&lt;timeuuid, int&gt;,&quot;
            + &quot;PRIMARY KEY ((peer)))&quot;)
<span class="fc" id="L487">            .build();</span>

    @Deprecated
<span class="fc" id="L490">    private static final TableMetadata LegacyTransferredRanges =</span>
<span class="fc" id="L491">        parse(LEGACY_TRANSFERRED_RANGES,</span>
            &quot;record of transferred ranges for streaming operation&quot;,
            &quot;CREATE TABLE %s (&quot;
            + &quot;operation text,&quot;
            + &quot;peer inet,&quot;
            + &quot;keyspace_name text,&quot;
            + &quot;ranges set&lt;blob&gt;,&quot;
            + &quot;PRIMARY KEY ((operation, keyspace_name), peer))&quot;)
<span class="fc" id="L499">            .build();</span>

    @Deprecated
<span class="fc" id="L502">    private static final TableMetadata LegacyAvailableRanges =</span>
<span class="fc" id="L503">        parse(LEGACY_AVAILABLE_RANGES,</span>
              &quot;available keyspace/ranges during bootstrap/replace that are ready to be served&quot;,
              &quot;CREATE TABLE %s (&quot;
              + &quot;keyspace_name text,&quot;
              + &quot;ranges set&lt;blob&gt;,&quot;
              + &quot;PRIMARY KEY ((keyspace_name)))&quot;)
<span class="fc" id="L509">        .build();</span>

    private static TableMetadata.Builder parse(String table, String description, String cql)
    {
<span class="fc" id="L513">        return CreateTableStatement.parse(format(cql, table), SchemaConstants.SYSTEM_KEYSPACE_NAME)</span>
<span class="fc" id="L514">                                   .id(TableId.forSystemTable(SchemaConstants.SYSTEM_KEYSPACE_NAME, table))</span>
<span class="fc" id="L515">                                   .gcGraceSeconds(0)</span>
<span class="fc" id="L516">                                   .memtableFlushPeriod((int) TimeUnit.HOURS.toMillis(1))</span>
<span class="fc" id="L517">                                   .comment(description);</span>
    }

    public static KeyspaceMetadata metadata()
    {
<span class="fc" id="L522">        return KeyspaceMetadata.create(SchemaConstants.SYSTEM_KEYSPACE_NAME, KeyspaceParams.local(), tables(), Views.none(), Types.none(), UserFunctions.none());</span>
    }

    private static Tables tables()
    {
<span class="fc" id="L527">        return Tables.of(BuiltIndexes,</span>
                         Batches,
                         Paxos,
                         PaxosRepairHistoryTable,
                         Local,
                         PeersV2,
                         LegacyPeers,
                         PeerEventsV2,
                         LegacyPeerEvents,
                         CompactionHistory,
                         LegacySSTableActivity,
                         SSTableActivity,
                         LegacySizeEstimates,
                         TableEstimates,
                         AvailableRangesV2,
                         LegacyAvailableRanges,
                         TransferredRangesV2,
                         LegacyTransferredRanges,
                         ViewBuildsInProgress,
                         BuiltViews,
                         PreparedStatements,
                         Repairs,
                         TopPartitions);
    }

    private static volatile Map&lt;TableId, Pair&lt;CommitLogPosition, Long&gt;&gt; truncationRecords;

<span class="fc" id="L554">    public enum BootstrapState</span>
    {
<span class="fc" id="L556">        NEEDS_BOOTSTRAP,</span>
<span class="fc" id="L557">        COMPLETED,</span>
<span class="fc" id="L558">        IN_PROGRESS,</span>
<span class="fc" id="L559">        DECOMMISSIONED</span>
    }

    public static void persistLocalMetadata()
    {
<span class="fc" id="L564">        persistLocalMetadata(UUID::randomUUID);</span>
<span class="fc" id="L565">    }</span>

    @VisibleForTesting
    public static void persistLocalMetadata(Supplier&lt;UUID&gt; nodeIdSupplier)
    {
<span class="fc" id="L570">        String req = &quot;INSERT INTO system.%s (&quot; +</span>
                     &quot;key,&quot; +
                     &quot;cluster_name,&quot; +
                     &quot;release_version,&quot; +
                     &quot;cql_version,&quot; +
                     &quot;native_protocol_version,&quot; +
                     &quot;data_center,&quot; +
                     &quot;rack,&quot; +
                     &quot;partitioner,&quot; +
                     &quot;rpc_address,&quot; +
                     &quot;rpc_port,&quot; +
                     &quot;broadcast_address,&quot; +
                     &quot;broadcast_port,&quot; +
                     &quot;listen_address,&quot; +
                     &quot;listen_port&quot; +
                     &quot;) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)&quot;;
<span class="fc" id="L586">        IEndpointSnitch snitch = DatabaseDescriptor.getEndpointSnitch();</span>
<span class="fc" id="L587">        executeOnceInternal(format(req, LOCAL),</span>
                            LOCAL,
<span class="fc" id="L589">                            DatabaseDescriptor.getClusterName(),</span>
<span class="fc" id="L590">                            FBUtilities.getReleaseVersionString(),</span>
<span class="fc" id="L591">                            QueryProcessor.CQL_VERSION.toString(),</span>
<span class="fc" id="L592">                            String.valueOf(ProtocolVersion.CURRENT.asInt()),</span>
<span class="fc" id="L593">                            snitch.getLocalDatacenter(),</span>
<span class="fc" id="L594">                            snitch.getLocalRack(),</span>
<span class="fc" id="L595">                            DatabaseDescriptor.getPartitioner().getClass().getName(),</span>
<span class="fc" id="L596">                            FBUtilities.getJustBroadcastNativeAddress(),</span>
<span class="fc" id="L597">                            DatabaseDescriptor.getNativeTransportPort(),</span>
<span class="fc" id="L598">                            FBUtilities.getJustBroadcastAddress(),</span>
<span class="fc" id="L599">                            DatabaseDescriptor.getStoragePort(),</span>
<span class="fc" id="L600">                            FBUtilities.getJustLocalAddress(),</span>
<span class="fc" id="L601">                            DatabaseDescriptor.getStoragePort());</span>

        // We should store host ID as soon as possible in the system.local table and flush that table to disk so that
        // we can be sure that those changes are stored in sstable and not in the commit log (see CASSANDRA-18153).
        // It is very unlikely that when upgrading the host id is not flushed to disk, but if that's the case, we limit
        // this change only to the new installations or the user should just flush system.local table.
<span class="fc bfc" id="L607" title="All 2 branches covered.">        if (!CommitLog.instance.hasFilesToReplay())</span>
<span class="fc" id="L608">            SystemKeyspace.getOrInitializeLocalHostId(nodeIdSupplier);</span>
<span class="fc" id="L609">    }</span>

    public static void updateCompactionHistory(TimeUUID taskId,
                                               String ksname,
                                               String cfname,
                                               long compactedAt,
                                               long bytesIn,
                                               long bytesOut,
                                               Map&lt;Integer, Long&gt; rowsMerged,
                                               Map&lt;String, String&gt; compactionProperties)
    {
        // don't write anything when the history table itself is compacted, since that would in turn cause new compactions
<span class="fc bfc" id="L621" title="All 4 branches covered.">        if (ksname.equals(&quot;system&quot;) &amp;&amp; cfname.equals(COMPACTION_HISTORY))</span>
<span class="fc" id="L622">            return;</span>
<span class="fc" id="L623">        String req = &quot;INSERT INTO system.%s (id, keyspace_name, columnfamily_name, compacted_at, bytes_in, bytes_out, rows_merged, compaction_properties) VALUES (?, ?, ?, ?, ?, ?, ?, ?)&quot;;</span>
<span class="fc" id="L624">        executeInternal(format(req, COMPACTION_HISTORY),</span>
                        taskId,
                        ksname,
                        cfname,
<span class="fc" id="L628">                        ByteBufferUtil.bytes(compactedAt),</span>
<span class="fc" id="L629">                        bytesIn,</span>
<span class="fc" id="L630">                        bytesOut,</span>
                        rowsMerged,
                        compactionProperties);
<span class="fc" id="L633">    }</span>

    public static TabularData getCompactionHistory() throws OpenDataException
    {
<span class="nc" id="L637">        UntypedResultSet queryResultSet = executeInternal(format(&quot;SELECT * from system.%s&quot;, COMPACTION_HISTORY));</span>
<span class="nc" id="L638">        return CompactionHistoryTabularData.from(queryResultSet);</span>
    }

    public static boolean isViewBuilt(String keyspaceName, String viewName)
    {
<span class="nc" id="L643">        String req = &quot;SELECT view_name FROM %s.\&quot;%s\&quot; WHERE keyspace_name=? AND view_name=?&quot;;</span>
<span class="nc" id="L644">        UntypedResultSet result = executeInternal(format(req, SchemaConstants.SYSTEM_KEYSPACE_NAME, BUILT_VIEWS), keyspaceName, viewName);</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">        return !result.isEmpty();</span>
    }

    public static boolean isViewStatusReplicated(String keyspaceName, String viewName)
    {
<span class="nc" id="L650">        String req = &quot;SELECT status_replicated FROM %s.\&quot;%s\&quot; WHERE keyspace_name=? AND view_name=?&quot;;</span>
<span class="nc" id="L651">        UntypedResultSet result = executeInternal(format(req, SchemaConstants.SYSTEM_KEYSPACE_NAME, BUILT_VIEWS), keyspaceName, viewName);</span>

<span class="nc bnc" id="L653" title="All 2 branches missed.">        if (result.isEmpty())</span>
<span class="nc" id="L654">            return false;</span>
<span class="nc" id="L655">        UntypedResultSet.Row row = result.one();</span>
<span class="nc bnc" id="L656" title="All 4 branches missed.">        return row.has(&quot;status_replicated&quot;) &amp;&amp; row.getBoolean(&quot;status_replicated&quot;);</span>
    }

    public static void setViewBuilt(String keyspaceName, String viewName, boolean replicated)
    {
<span class="nc bnc" id="L661" title="All 4 branches missed.">        if (isViewBuilt(keyspaceName, viewName) &amp;&amp; isViewStatusReplicated(keyspaceName, viewName) == replicated)</span>
<span class="nc" id="L662">            return;</span>

<span class="nc" id="L664">        String req = &quot;INSERT INTO %s.\&quot;%s\&quot; (keyspace_name, view_name, status_replicated) VALUES (?, ?, ?)&quot;;</span>
<span class="nc" id="L665">        executeInternal(format(req, SchemaConstants.SYSTEM_KEYSPACE_NAME, BUILT_VIEWS), keyspaceName, viewName, replicated);</span>
<span class="nc" id="L666">        forceBlockingFlush(BUILT_VIEWS);</span>
<span class="nc" id="L667">    }</span>

    public static void setViewRemoved(String keyspaceName, String viewName)
    {
<span class="nc" id="L671">        String buildReq = &quot;DELETE FROM %s.%s WHERE keyspace_name = ? AND view_name = ?&quot;;</span>
<span class="nc" id="L672">        executeInternal(String.format(buildReq, SchemaConstants.SYSTEM_KEYSPACE_NAME, VIEW_BUILDS_IN_PROGRESS), keyspaceName, viewName);</span>

<span class="nc" id="L674">        String builtReq = &quot;DELETE FROM %s.\&quot;%s\&quot; WHERE keyspace_name = ? AND view_name = ? IF EXISTS&quot;;</span>
<span class="nc" id="L675">        executeInternal(String.format(builtReq, SchemaConstants.SYSTEM_KEYSPACE_NAME, BUILT_VIEWS), keyspaceName, viewName);</span>
<span class="nc" id="L676">        forceBlockingFlush(VIEW_BUILDS_IN_PROGRESS, BUILT_VIEWS);</span>
<span class="nc" id="L677">    }</span>

    public static void finishViewBuildStatus(String ksname, String viewName)
    {
        // We flush the view built first, because if we fail now, we'll restart at the last place we checkpointed
        // view build.
        // If we flush the delete first, we'll have to restart from the beginning.
        // Also, if writing to the built_view succeeds, but the view_builds_in_progress deletion fails, we will be able
        // to skip the view build next boot.
<span class="nc" id="L686">        setViewBuilt(ksname, viewName, false);</span>
<span class="nc" id="L687">        executeInternal(String.format(&quot;DELETE FROM system.%s WHERE keyspace_name = ? AND view_name = ?&quot;, VIEW_BUILDS_IN_PROGRESS), ksname, viewName);</span>
<span class="nc" id="L688">        forceBlockingFlush(VIEW_BUILDS_IN_PROGRESS);</span>
<span class="nc" id="L689">    }</span>

    public static void setViewBuiltReplicated(String ksname, String viewName)
    {
<span class="nc" id="L693">        setViewBuilt(ksname, viewName, true);</span>
<span class="nc" id="L694">    }</span>

    public static void updateViewBuildStatus(String ksname, String viewName, Range&lt;Token&gt; range, Token lastToken, long keysBuilt)
    {
<span class="nc" id="L698">        String req = &quot;INSERT INTO system.%s (keyspace_name, view_name, start_token, end_token, last_token, keys_built) VALUES (?, ?, ?, ?, ?, ?)&quot;;</span>
<span class="nc" id="L699">        Token.TokenFactory factory = ViewBuildsInProgress.partitioner.getTokenFactory();</span>
<span class="nc" id="L700">        executeInternal(format(req, VIEW_BUILDS_IN_PROGRESS),</span>
                        ksname,
                        viewName,
<span class="nc" id="L703">                        factory.toString(range.left),</span>
<span class="nc" id="L704">                        factory.toString(range.right),</span>
<span class="nc" id="L705">                        factory.toString(lastToken),</span>
<span class="nc" id="L706">                        keysBuilt);</span>
<span class="nc" id="L707">    }</span>

    public static Map&lt;Range&lt;Token&gt;, Pair&lt;Token, Long&gt;&gt; getViewBuildStatus(String ksname, String viewName)
    {
<span class="nc" id="L711">        String req = &quot;SELECT start_token, end_token, last_token, keys_built FROM system.%s WHERE keyspace_name = ? AND view_name = ?&quot;;</span>
<span class="nc" id="L712">        Token.TokenFactory factory = ViewBuildsInProgress.partitioner.getTokenFactory();</span>
<span class="nc" id="L713">        UntypedResultSet rs = executeInternal(format(req, VIEW_BUILDS_IN_PROGRESS), ksname, viewName);</span>

<span class="nc bnc" id="L715" title="All 4 branches missed.">        if (rs == null || rs.isEmpty())</span>
<span class="nc" id="L716">            return Collections.emptyMap();</span>

<span class="nc" id="L718">        Map&lt;Range&lt;Token&gt;, Pair&lt;Token, Long&gt;&gt; status = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">        for (UntypedResultSet.Row row : rs)</span>
        {
<span class="nc" id="L721">            Token start = factory.fromString(row.getString(&quot;start_token&quot;));</span>
<span class="nc" id="L722">            Token end = factory.fromString(row.getString(&quot;end_token&quot;));</span>
<span class="nc" id="L723">            Range&lt;Token&gt; range = new Range&lt;&gt;(start, end);</span>

<span class="nc bnc" id="L725" title="All 2 branches missed.">            Token lastToken = row.has(&quot;last_token&quot;) ? factory.fromString(row.getString(&quot;last_token&quot;)) : null;</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">            long keysBuilt = row.has(&quot;keys_built&quot;) ? row.getLong(&quot;keys_built&quot;) : 0;</span>

<span class="nc" id="L728">            status.put(range, Pair.create(lastToken, keysBuilt));</span>
<span class="nc" id="L729">        }</span>
<span class="nc" id="L730">        return status;</span>
    }

    public static synchronized void saveTruncationRecord(ColumnFamilyStore cfs, long truncatedAt, CommitLogPosition position)
    {
<span class="fc" id="L735">        String req = &quot;UPDATE system.%s SET truncated_at = truncated_at + ? WHERE key = '%s'&quot;;</span>
<span class="fc" id="L736">        executeInternal(format(req, LOCAL, LOCAL), truncationAsMapEntry(cfs, truncatedAt, position));</span>
<span class="fc" id="L737">        truncationRecords = null;</span>
<span class="fc" id="L738">        forceBlockingFlush(LOCAL);</span>
<span class="fc" id="L739">    }</span>

    /**
     * This method is used to remove information about truncation time for specified column family
     */
    public static synchronized void removeTruncationRecord(TableId id)
    {
<span class="nc" id="L746">        Pair&lt;CommitLogPosition, Long&gt; truncationRecord = getTruncationRecord(id);</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">        if (truncationRecord == null)</span>
<span class="nc" id="L748">            return;</span>

<span class="nc" id="L750">        String req = &quot;DELETE truncated_at[?] from system.%s WHERE key = '%s'&quot;;</span>
<span class="nc" id="L751">        executeInternal(format(req, LOCAL, LOCAL), id.asUUID());</span>
<span class="nc" id="L752">        truncationRecords = null;</span>
<span class="nc" id="L753">        forceBlockingFlush(LOCAL);</span>
<span class="nc" id="L754">    }</span>

    private static Map&lt;UUID, ByteBuffer&gt; truncationAsMapEntry(ColumnFamilyStore cfs, long truncatedAt, CommitLogPosition position)
    {
<span class="fc" id="L758">        try (DataOutputBuffer out = DataOutputBuffer.scratchBuffer.get())</span>
        {
<span class="fc" id="L760">            CommitLogPosition.serializer.serialize(position, out);</span>
<span class="fc" id="L761">            out.writeLong(truncatedAt);</span>
<span class="fc" id="L762">            return singletonMap(cfs.metadata.id.asUUID(), out.asNewBuffer());</span>
        }
<span class="nc" id="L764">        catch (IOException e)</span>
        {
<span class="nc" id="L766">            throw new RuntimeException(e);</span>
        }
    }

    public static CommitLogPosition getTruncatedPosition(TableId id)
    {
<span class="fc" id="L772">        Pair&lt;CommitLogPosition, Long&gt; record = getTruncationRecord(id);</span>
<span class="fc bfc" id="L773" title="All 2 branches covered.">        return record == null ? null : record.left;</span>
    }

    public static long getTruncatedAt(TableId id)
    {
<span class="fc" id="L778">        Pair&lt;CommitLogPosition, Long&gt; record = getTruncationRecord(id);</span>
<span class="fc bfc" id="L779" title="All 2 branches covered.">        return record == null ? Long.MIN_VALUE : record.right;</span>
    }

    private static synchronized Pair&lt;CommitLogPosition, Long&gt; getTruncationRecord(TableId id)
    {
<span class="fc bfc" id="L784" title="All 2 branches covered.">        if (truncationRecords == null)</span>
<span class="fc" id="L785">            truncationRecords = readTruncationRecords();</span>
<span class="fc" id="L786">        return truncationRecords.get(id);</span>
    }

    private static Map&lt;TableId, Pair&lt;CommitLogPosition, Long&gt;&gt; readTruncationRecords()
    {
<span class="fc" id="L791">        UntypedResultSet rows = executeInternal(format(&quot;SELECT truncated_at FROM system.%s WHERE key = '%s'&quot;, LOCAL, LOCAL));</span>

<span class="fc" id="L793">        Map&lt;TableId, Pair&lt;CommitLogPosition, Long&gt;&gt; records = new HashMap&lt;&gt;();</span>

<span class="pc bpc" id="L795" title="2 of 4 branches missed.">        if (!rows.isEmpty() &amp;&amp; rows.one().has(&quot;truncated_at&quot;))</span>
        {
<span class="fc" id="L797">            Map&lt;UUID, ByteBuffer&gt; map = rows.one().getMap(&quot;truncated_at&quot;, UUIDType.instance, BytesType.instance);</span>
<span class="fc bfc" id="L798" title="All 2 branches covered.">            for (Map.Entry&lt;UUID, ByteBuffer&gt; entry : map.entrySet())</span>
<span class="fc" id="L799">                records.put(TableId.fromUUID(entry.getKey()), truncationRecordFromBlob(entry.getValue()));</span>
        }

<span class="fc" id="L802">        return records;</span>
    }

    private static Pair&lt;CommitLogPosition, Long&gt; truncationRecordFromBlob(ByteBuffer bytes)
    {
<span class="fc" id="L807">        try (RebufferingInputStream in = new DataInputBuffer(bytes, true))</span>
        {
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">            return Pair.create(CommitLogPosition.serializer.deserialize(in), in.available() &gt; 0 ? in.readLong() : Long.MIN_VALUE);</span>
        }
<span class="nc" id="L811">        catch (IOException e)</span>
        {
<span class="nc" id="L813">            throw new RuntimeException(e);</span>
        }
    }

    /**
     * Record tokens being used by another node
     */
    public static synchronized void updateTokens(InetAddressAndPort ep, Collection&lt;Token&gt; tokens)
    {
<span class="fc bfc" id="L822" title="All 2 branches covered.">        if (ep.equals(FBUtilities.getBroadcastAddressAndPort()))</span>
<span class="fc" id="L823">            return;</span>

<span class="fc" id="L825">        String req = &quot;INSERT INTO system.%s (peer, tokens) VALUES (?, ?)&quot;;</span>
<span class="fc" id="L826">        executeInternal(String.format(req, LEGACY_PEERS), ep.getAddress(), tokensAsSet(tokens));</span>
<span class="fc" id="L827">        req = &quot;INSERT INTO system.%s (peer, peer_port, tokens) VALUES (?, ?, ?)&quot;;</span>
<span class="fc" id="L828">        executeInternal(String.format(req, PEERS_V2), ep.getAddress(), ep.getPort(), tokensAsSet(tokens));</span>
<span class="fc" id="L829">    }</span>

    public static synchronized boolean updatePreferredIP(InetAddressAndPort ep, InetAddressAndPort preferred_ip)
    {
<span class="nc bnc" id="L833" title="All 2 branches missed.">        if (preferred_ip.equals(getPreferredIP(ep)))</span>
<span class="nc" id="L834">            return false;</span>

<span class="nc" id="L836">        String req = &quot;INSERT INTO system.%s (peer, preferred_ip) VALUES (?, ?)&quot;;</span>
<span class="nc" id="L837">        executeInternal(String.format(req, LEGACY_PEERS), ep.getAddress(), preferred_ip.getAddress());</span>
<span class="nc" id="L838">        req = &quot;INSERT INTO system.%s (peer, peer_port, preferred_ip, preferred_port) VALUES (?, ?, ?, ?)&quot;;</span>
<span class="nc" id="L839">        executeInternal(String.format(req, PEERS_V2), ep.getAddress(), ep.getPort(), preferred_ip.getAddress(), preferred_ip.getPort());</span>
<span class="nc" id="L840">        forceBlockingFlush(LEGACY_PEERS, PEERS_V2);</span>
<span class="nc" id="L841">        return true;</span>
    }

    public static synchronized void updatePeerInfo(InetAddressAndPort ep, String columnName, Object value)
    {
<span class="fc bfc" id="L846" title="All 2 branches covered.">        if (ep.equals(FBUtilities.getBroadcastAddressAndPort()))</span>
<span class="fc" id="L847">            return;</span>

<span class="fc" id="L849">        String req = &quot;INSERT INTO system.%s (peer, %s) VALUES (?, ?)&quot;;</span>
<span class="fc" id="L850">        executeInternal(String.format(req, LEGACY_PEERS, columnName), ep.getAddress(), value);</span>
        //This column doesn't match across the two tables
<span class="fc bfc" id="L852" title="All 2 branches covered.">        if (columnName.equals(&quot;rpc_address&quot;))</span>
        {
<span class="fc" id="L854">            columnName = &quot;native_address&quot;;</span>
        }
<span class="fc" id="L856">        req = &quot;INSERT INTO system.%s (peer, peer_port, %s) VALUES (?, ?, ?)&quot;;</span>
<span class="fc" id="L857">        executeInternal(String.format(req, PEERS_V2, columnName), ep.getAddress(), ep.getPort(), value);</span>
<span class="fc" id="L858">    }</span>

    public static synchronized void updatePeerNativeAddress(InetAddressAndPort ep, InetAddressAndPort address)
    {
<span class="fc bfc" id="L862" title="All 2 branches covered.">        if (ep.equals(FBUtilities.getBroadcastAddressAndPort()))</span>
<span class="fc" id="L863">            return;</span>

<span class="fc" id="L865">        String req = &quot;INSERT INTO system.%s (peer, rpc_address) VALUES (?, ?)&quot;;</span>
<span class="fc" id="L866">        executeInternal(String.format(req, LEGACY_PEERS), ep.getAddress(), address.getAddress());</span>
<span class="fc" id="L867">        req = &quot;INSERT INTO system.%s (peer, peer_port, native_address, native_port) VALUES (?, ?, ?, ?)&quot;;</span>
<span class="fc" id="L868">        executeInternal(String.format(req, PEERS_V2), ep.getAddress(), ep.getPort(), address.getAddress(), address.getPort());</span>
<span class="fc" id="L869">    }</span>


    public static synchronized void updateHintsDropped(InetAddressAndPort ep, TimeUUID timePeriod, int value)
    {
        // with 30 day TTL
<span class="nc" id="L875">        String req = &quot;UPDATE system.%s USING TTL 2592000 SET hints_dropped[ ? ] = ? WHERE peer = ?&quot;;</span>
<span class="nc" id="L876">        executeInternal(String.format(req, LEGACY_PEER_EVENTS), timePeriod, value, ep.getAddress());</span>
<span class="nc" id="L877">        req = &quot;UPDATE system.%s USING TTL 2592000 SET hints_dropped[ ? ] = ? WHERE peer = ? AND peer_port = ?&quot;;</span>
<span class="nc" id="L878">        executeInternal(String.format(req, PEER_EVENTS_V2), timePeriod, value, ep.getAddress(), ep.getPort());</span>
<span class="nc" id="L879">    }</span>

    public static synchronized void updateSchemaVersion(UUID version)
    {
<span class="fc" id="L883">        String req = &quot;INSERT INTO system.%s (key, schema_version) VALUES ('%s', ?)&quot;;</span>
<span class="fc" id="L884">        executeInternal(format(req, LOCAL, LOCAL), version);</span>
<span class="fc" id="L885">    }</span>

    private static Set&lt;String&gt; tokensAsSet(Collection&lt;Token&gt; tokens)
    {
<span class="pc bpc" id="L889" title="1 of 2 branches missed.">        if (tokens.isEmpty())</span>
<span class="nc" id="L890">            return Collections.emptySet();</span>
<span class="fc" id="L891">        Token.TokenFactory factory = StorageService.instance.getTokenFactory();</span>
<span class="fc" id="L892">        Set&lt;String&gt; s = new HashSet&lt;&gt;(tokens.size());</span>
<span class="fc bfc" id="L893" title="All 2 branches covered.">        for (Token tk : tokens)</span>
<span class="fc" id="L894">            s.add(factory.toString(tk));</span>
<span class="fc" id="L895">        return s;</span>
    }

    private static Collection&lt;Token&gt; deserializeTokens(Collection&lt;String&gt; tokensStrings)
    {
<span class="fc" id="L900">        Token.TokenFactory factory = StorageService.instance.getTokenFactory();</span>
<span class="fc" id="L901">        List&lt;Token&gt; tokens = new ArrayList&lt;&gt;(tokensStrings.size());</span>
<span class="fc bfc" id="L902" title="All 2 branches covered.">        for (String tk : tokensStrings)</span>
<span class="fc" id="L903">            tokens.add(factory.fromString(tk));</span>
<span class="fc" id="L904">        return tokens;</span>
    }

    /**
     * Remove stored tokens being used by another node
     */
    public static synchronized void removeEndpoint(InetSocketAddress ep)
    {
<span class="fc" id="L912">        String req = &quot;DELETE FROM system.%s WHERE peer = ?&quot;;</span>
<span class="fc" id="L913">        executeInternal(String.format(req, LEGACY_PEERS), ep.getAddress());</span>
<span class="fc" id="L914">        req = String.format(&quot;DELETE FROM system.%s WHERE peer = ? AND peer_port = ?&quot;, PEERS_V2);</span>
<span class="fc" id="L915">        executeInternal(req, ep.getAddress(), ep.getPort());</span>
<span class="fc" id="L916">        forceBlockingFlush(LEGACY_PEERS, PEERS_V2);</span>
<span class="fc" id="L917">    }</span>

    /**
     * This method is used to update the System Keyspace with the new tokens for this node
     */
    public static synchronized void updateTokens(Collection&lt;Token&gt; tokens)
    {
<span class="pc bpc" id="L924" title="1 of 2 branches missed.">        assert !tokens.isEmpty() : &quot;removeEndpoint should be used instead&quot;;</span>

<span class="fc" id="L926">        Collection&lt;Token&gt; savedTokens = getSavedTokens();</span>
<span class="pc bpc" id="L927" title="1 of 4 branches missed.">        if (tokens.containsAll(savedTokens) &amp;&amp; tokens.size() == savedTokens.size())</span>
<span class="fc" id="L928">            return;</span>

<span class="fc" id="L930">        String req = &quot;INSERT INTO system.%s (key, tokens) VALUES ('%s', ?)&quot;;</span>
<span class="fc" id="L931">        executeInternal(format(req, LOCAL, LOCAL), tokensAsSet(tokens));</span>
<span class="fc" id="L932">        forceBlockingFlush(LOCAL);</span>
<span class="fc" id="L933">    }</span>

    public static void forceBlockingFlush(String ...cfnames)
    {
<span class="pc bpc" id="L937" title="1 of 2 branches missed.">        if (!DatabaseDescriptor.isUnsafeSystem())</span>
        {
<span class="fc" id="L939">            List&lt;Future&lt;CommitLogPosition&gt;&gt; futures = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L941" title="All 2 branches covered.">            for (String cfname : cfnames)</span>
            {
<span class="fc" id="L943">                futures.add(Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME)</span>
<span class="fc" id="L944">                                    .getColumnFamilyStore(cfname)</span>
<span class="fc" id="L945">                                    .forceFlush(ColumnFamilyStore.FlushReason.INTERNALLY_FORCED));</span>
            }
<span class="fc" id="L947">            FBUtilities.waitOnFutures(futures);</span>
        }
<span class="fc" id="L949">    }</span>

    /**
     * Return a map of stored tokens to IP addresses
     *
     */
    public static SetMultimap&lt;InetAddressAndPort, Token&gt; loadTokens()
    {
<span class="fc" id="L957">        SetMultimap&lt;InetAddressAndPort, Token&gt; tokenMap = HashMultimap.create();</span>
<span class="fc bfc" id="L958" title="All 2 branches covered.">        for (UntypedResultSet.Row row : executeInternal(&quot;SELECT peer, peer_port, tokens FROM system.&quot; + PEERS_V2))</span>
        {
<span class="fc" id="L960">            InetAddress address = row.getInetAddress(&quot;peer&quot;);</span>
<span class="fc" id="L961">            Integer port = row.getInt(&quot;peer_port&quot;);</span>
<span class="fc" id="L962">            InetAddressAndPort peer = InetAddressAndPort.getByAddressOverrideDefaults(address, port);</span>
<span class="pc bpc" id="L963" title="1 of 2 branches missed.">            if (row.has(&quot;tokens&quot;))</span>
<span class="fc" id="L964">                tokenMap.putAll(peer, deserializeTokens(row.getSet(&quot;tokens&quot;, UTF8Type.instance)));</span>
<span class="fc" id="L965">        }</span>

<span class="fc" id="L967">        return tokenMap;</span>
    }

    /**
     * Return a map of store host_ids to IP addresses
     *
     */
    public static Map&lt;InetAddressAndPort, UUID&gt; loadHostIds()
    {
<span class="fc" id="L976">        Map&lt;InetAddressAndPort, UUID&gt; hostIdMap = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L977" title="All 2 branches covered.">        for (UntypedResultSet.Row row : executeInternal(&quot;SELECT peer, peer_port, host_id FROM system.&quot; + PEERS_V2))</span>
        {
<span class="fc" id="L979">            InetAddress address = row.getInetAddress(&quot;peer&quot;);</span>
<span class="fc" id="L980">            Integer port = row.getInt(&quot;peer_port&quot;);</span>
<span class="fc" id="L981">            InetAddressAndPort peer = InetAddressAndPort.getByAddressOverrideDefaults(address, port);</span>
<span class="pc bpc" id="L982" title="1 of 2 branches missed.">            if (row.has(&quot;host_id&quot;))</span>
            {
<span class="fc" id="L984">                hostIdMap.put(peer, row.getUUID(&quot;host_id&quot;));</span>
            }
<span class="fc" id="L986">        }</span>
<span class="fc" id="L987">        return hostIdMap;</span>
    }

    /**
     * Get preferred IP for given endpoint if it is known. Otherwise this returns given endpoint itself.
     *
     * @param ep endpoint address to check
     * @return Preferred IP for given endpoint if present, otherwise returns given ep
     */
    public static InetAddressAndPort getPreferredIP(InetAddressAndPort ep)
    {
<span class="fc" id="L998">        Preconditions.checkState(DatabaseDescriptor.isDaemonInitialized()); // Make sure being used as a daemon, not a tool</span>

<span class="fc" id="L1000">        String req = &quot;SELECT preferred_ip, preferred_port FROM system.%s WHERE peer=? AND peer_port = ?&quot;;</span>
<span class="fc" id="L1001">        UntypedResultSet result = executeInternal(String.format(req, PEERS_V2), ep.getAddress(), ep.getPort());</span>
<span class="pc bpc" id="L1002" title="1 of 4 branches missed.">        if (!result.isEmpty() &amp;&amp; result.one().has(&quot;preferred_ip&quot;))</span>
        {
<span class="nc" id="L1004">            UntypedResultSet.Row row = result.one();</span>
<span class="nc" id="L1005">            return InetAddressAndPort.getByAddressOverrideDefaults(row.getInetAddress(&quot;preferred_ip&quot;), row.getInt(&quot;preferred_port&quot;));</span>
        }
<span class="fc" id="L1007">        return ep;</span>
    }

    /**
     * Return a map of IP addresses containing a map of dc and rack info
     */
    public static Map&lt;InetAddressAndPort, Map&lt;String,String&gt;&gt; loadDcRackInfo()
    {
<span class="nc" id="L1015">        Map&lt;InetAddressAndPort, Map&lt;String, String&gt;&gt; result = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">        for (UntypedResultSet.Row row : executeInternal(&quot;SELECT peer, peer_port, data_center, rack from system.&quot; + PEERS_V2))</span>
        {
<span class="nc" id="L1018">            InetAddress address = row.getInetAddress(&quot;peer&quot;);</span>
<span class="nc" id="L1019">            Integer port = row.getInt(&quot;peer_port&quot;);</span>
<span class="nc" id="L1020">            InetAddressAndPort peer = InetAddressAndPort.getByAddressOverrideDefaults(address, port);</span>
<span class="nc bnc" id="L1021" title="All 4 branches missed.">            if (row.has(&quot;data_center&quot;) &amp;&amp; row.has(&quot;rack&quot;))</span>
            {
<span class="nc" id="L1023">                Map&lt;String, String&gt; dcRack = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1024">                dcRack.put(&quot;data_center&quot;, row.getString(&quot;data_center&quot;));</span>
<span class="nc" id="L1025">                dcRack.put(&quot;rack&quot;, row.getString(&quot;rack&quot;));</span>
<span class="nc" id="L1026">                result.put(peer, dcRack);</span>
            }
<span class="nc" id="L1028">        }</span>
<span class="nc" id="L1029">        return result;</span>
    }

    /**
     * Get release version for given endpoint.
     * If release version is unknown, then this returns null.
     *
     * @param ep endpoint address to check
     * @return Release version or null if version is unknown.
     */
    public static CassandraVersion getReleaseVersion(InetAddressAndPort ep)
    {
        try
        {
<span class="nc bnc" id="L1043" title="All 2 branches missed.">            if (FBUtilities.getBroadcastAddressAndPort().equals(ep))</span>
            {
<span class="nc" id="L1045">                return CURRENT_VERSION;</span>
            }
<span class="nc" id="L1047">            String req = &quot;SELECT release_version FROM system.%s WHERE peer=? AND peer_port=?&quot;;</span>
<span class="nc" id="L1048">            UntypedResultSet result = executeInternal(String.format(req, PEERS_V2), ep.getAddress(), ep.getPort());</span>
<span class="nc bnc" id="L1049" title="All 4 branches missed.">            if (result != null &amp;&amp; result.one().has(&quot;release_version&quot;))</span>
            {
<span class="nc" id="L1051">                return new CassandraVersion(result.one().getString(&quot;release_version&quot;));</span>
            }
            // version is unknown
<span class="nc" id="L1054">            return null;</span>
        }
<span class="nc" id="L1056">        catch (IllegalArgumentException e)</span>
        {
            // version string cannot be parsed
<span class="nc" id="L1059">            return null;</span>
        }
    }

    /**
     * One of three things will happen if you try to read the system keyspace:
     * 1. files are present and you can read them: great
     * 2. no files are there: great (new node is assumed)
     * 3. files are present but you can't read them: bad
     * @throws ConfigurationException
     */
    public static void checkHealth() throws ConfigurationException
    {
        Keyspace keyspace;
        try
        {
<span class="fc" id="L1075">            keyspace = Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME);</span>
        }
<span class="nc" id="L1077">        catch (AssertionError err)</span>
        {
            // this happens when a user switches from OPP to RP.
<span class="nc" id="L1080">            ConfigurationException ex = new ConfigurationException(&quot;Could not read system keyspace!&quot;);</span>
<span class="nc" id="L1081">            ex.initCause(err);</span>
<span class="nc" id="L1082">            throw ex;</span>
<span class="fc" id="L1083">        }</span>
<span class="fc" id="L1084">        ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(LOCAL);</span>

<span class="fc" id="L1086">        String req = &quot;SELECT cluster_name FROM system.%s WHERE key='%s'&quot;;</span>
<span class="fc" id="L1087">        UntypedResultSet result = executeInternal(format(req, LOCAL, LOCAL));</span>

<span class="pc bpc" id="L1089" title="1 of 4 branches missed.">        if (result.isEmpty() || !result.one().has(&quot;cluster_name&quot;))</span>
        {
            // this is a brand new node
<span class="pc bpc" id="L1092" title="1 of 2 branches missed.">            if (!cfs.getLiveSSTables().isEmpty())</span>
<span class="nc" id="L1093">                throw new ConfigurationException(&quot;Found system keyspace files, but they couldn't be loaded!&quot;);</span>

            // no system files.  this is a new node.
<span class="fc" id="L1096">            return;</span>
        }

<span class="fc" id="L1099">        String savedClusterName = result.one().getString(&quot;cluster_name&quot;);</span>
<span class="pc bpc" id="L1100" title="1 of 2 branches missed.">        if (!DatabaseDescriptor.getClusterName().equals(savedClusterName))</span>
<span class="nc" id="L1101">            throw new ConfigurationException(&quot;Saved cluster name &quot; + savedClusterName + &quot; != configured name &quot; + DatabaseDescriptor.getClusterName());</span>
<span class="fc" id="L1102">    }</span>

    public static Collection&lt;Token&gt; getSavedTokens()
    {
<span class="fc" id="L1106">        String req = &quot;SELECT tokens FROM system.%s WHERE key='%s'&quot;;</span>
<span class="fc" id="L1107">        UntypedResultSet result = executeInternal(format(req, LOCAL, LOCAL));</span>
<span class="pc bpc" id="L1108" title="1 of 4 branches missed.">        return result.isEmpty() || !result.one().has(&quot;tokens&quot;)</span>
<span class="fc" id="L1109">             ? Collections.&lt;Token&gt;emptyList()</span>
<span class="fc" id="L1110">             : deserializeTokens(result.one().getSet(&quot;tokens&quot;, UTF8Type.instance));</span>
    }

    public static int incrementAndGetGeneration()
    {
<span class="fc" id="L1115">        String req = &quot;SELECT gossip_generation FROM system.%s WHERE key='%s'&quot;;</span>
<span class="fc" id="L1116">        UntypedResultSet result = executeInternal(format(req, LOCAL, LOCAL));</span>

        int generation;
<span class="pc bpc" id="L1119" title="1 of 4 branches missed.">        if (result.isEmpty() || !result.one().has(&quot;gossip_generation&quot;))</span>
        {
            // seconds-since-epoch isn't a foolproof new generation
            // (where foolproof is &quot;guaranteed to be larger than the last one seen at this ip address&quot;),
            // but it's as close as sanely possible
<span class="fc" id="L1124">            generation = (int) (currentTimeMillis() / 1000);</span>
        }
        else
        {
            // Other nodes will ignore gossip messages about a node that have a lower generation than previously seen.
<span class="fc" id="L1129">            final int storedGeneration = result.one().getInt(&quot;gossip_generation&quot;) + 1;</span>
<span class="fc" id="L1130">            final int now = (int) (currentTimeMillis() / 1000);</span>
<span class="pc bpc" id="L1131" title="1 of 2 branches missed.">            if (storedGeneration &gt;= now)</span>
            {
<span class="nc" id="L1133">                logger.warn(&quot;Using stored Gossip Generation {} as it is greater than current system time {}.  See CASSANDRA-3654 if you experience problems&quot;,</span>
<span class="nc" id="L1134">                            storedGeneration, now);</span>
<span class="nc" id="L1135">                generation = storedGeneration;</span>
            }
            else
            {
<span class="fc" id="L1139">                generation = now;</span>
            }
        }

<span class="fc" id="L1143">        req = &quot;INSERT INTO system.%s (key, gossip_generation) VALUES ('%s', ?)&quot;;</span>
<span class="fc" id="L1144">        executeInternal(format(req, LOCAL, LOCAL), generation);</span>
<span class="fc" id="L1145">        forceBlockingFlush(LOCAL);</span>

<span class="fc" id="L1147">        return generation;</span>
    }

    public static BootstrapState getBootstrapState()
    {
<span class="fc" id="L1152">        String req = &quot;SELECT bootstrapped FROM system.%s WHERE key='%s'&quot;;</span>
<span class="fc" id="L1153">        UntypedResultSet result = executeInternal(format(req, LOCAL, LOCAL));</span>

<span class="pc bpc" id="L1155" title="1 of 4 branches missed.">        if (result.isEmpty() || !result.one().has(&quot;bootstrapped&quot;))</span>
<span class="fc" id="L1156">            return BootstrapState.NEEDS_BOOTSTRAP;</span>

<span class="fc" id="L1158">        return BootstrapState.valueOf(result.one().getString(&quot;bootstrapped&quot;));</span>
    }

    public static boolean bootstrapComplete()
    {
<span class="fc bfc" id="L1163" title="All 2 branches covered.">        return getBootstrapState() == BootstrapState.COMPLETED;</span>
    }

    public static boolean bootstrapInProgress()
    {
<span class="fc bfc" id="L1168" title="All 2 branches covered.">        return getBootstrapState() == BootstrapState.IN_PROGRESS;</span>
    }

    public static boolean wasDecommissioned()
    {
<span class="pc bpc" id="L1173" title="1 of 2 branches missed.">        return getBootstrapState() == BootstrapState.DECOMMISSIONED;</span>
    }

    public static void setBootstrapState(BootstrapState state)
    {
<span class="fc bfc" id="L1178" title="All 2 branches covered.">        if (getBootstrapState() == state)</span>
<span class="fc" id="L1179">            return;</span>

<span class="fc" id="L1181">        String req = &quot;INSERT INTO system.%s (key, bootstrapped) VALUES ('%s', ?)&quot;;</span>
<span class="fc" id="L1182">        executeInternal(format(req, LOCAL, LOCAL), state.name());</span>
<span class="fc" id="L1183">        forceBlockingFlush(LOCAL);</span>
<span class="fc" id="L1184">    }</span>

    public static boolean isIndexBuilt(String keyspaceName, String indexName)
    {
<span class="fc" id="L1188">        String req = &quot;SELECT index_name FROM %s.\&quot;%s\&quot; WHERE table_name=? AND index_name=?&quot;;</span>
<span class="fc" id="L1189">        UntypedResultSet result = executeInternal(format(req, SchemaConstants.SYSTEM_KEYSPACE_NAME, BUILT_INDEXES), keyspaceName, indexName);</span>
<span class="pc bpc" id="L1190" title="1 of 2 branches missed.">        return !result.isEmpty();</span>
    }

    public static void setIndexBuilt(String keyspaceName, String indexName)
    {
<span class="fc" id="L1195">        String req = &quot;INSERT INTO %s.\&quot;%s\&quot; (table_name, index_name) VALUES (?, ?) IF NOT EXISTS;&quot;;</span>
<span class="fc" id="L1196">        executeInternal(String.format(req, SchemaConstants.SYSTEM_KEYSPACE_NAME, BUILT_INDEXES), keyspaceName, indexName);</span>
<span class="fc" id="L1197">        forceBlockingFlush(BUILT_INDEXES);</span>
<span class="fc" id="L1198">    }</span>

    public static void setIndexRemoved(String keyspaceName, String indexName)
    {
<span class="nc" id="L1202">        String req = &quot;DELETE FROM %s.\&quot;%s\&quot; WHERE table_name = ? AND index_name = ? IF EXISTS&quot;;</span>
<span class="nc" id="L1203">        executeInternal(String.format(req, SchemaConstants.SYSTEM_KEYSPACE_NAME, BUILT_INDEXES), keyspaceName, indexName);</span>
<span class="nc" id="L1204">        forceBlockingFlush(BUILT_INDEXES);</span>
<span class="nc" id="L1205">    }</span>

    public static List&lt;String&gt; getBuiltIndexes(String keyspaceName, Set&lt;String&gt; indexNames)
    {
<span class="nc" id="L1209">        List&lt;String&gt; names = new ArrayList&lt;&gt;(indexNames);</span>
<span class="nc" id="L1210">        String req = &quot;SELECT index_name from %s.\&quot;%s\&quot; WHERE table_name=? AND index_name IN ?&quot;;</span>
<span class="nc" id="L1211">        UntypedResultSet results = executeInternal(format(req, SchemaConstants.SYSTEM_KEYSPACE_NAME, BUILT_INDEXES), keyspaceName, names);</span>
<span class="nc" id="L1212">        return StreamSupport.stream(results.spliterator(), false)</span>
<span class="nc" id="L1213">                            .map(r -&gt; r.getString(&quot;index_name&quot;))</span>
<span class="nc" id="L1214">                            .collect(Collectors.toList());</span>
    }

    /**
     * Read the host ID from the system keyspace.
     */
    public static UUID getLocalHostId()
    {
<span class="fc" id="L1222">        String req = &quot;SELECT host_id FROM system.%s WHERE key='%s'&quot;;</span>
<span class="fc" id="L1223">        UntypedResultSet result = executeInternal(format(req, LOCAL, LOCAL));</span>

        // Look up the Host UUID (return it if found)
<span class="pc bpc" id="L1226" title="2 of 6 branches missed.">        if (result != null &amp;&amp; !result.isEmpty() &amp;&amp; result.one().has(&quot;host_id&quot;))</span>
<span class="fc" id="L1227">            return result.one().getUUID(&quot;host_id&quot;);</span>

<span class="fc" id="L1229">        return null;</span>
    }

    /**
     * Read the host ID from the system keyspace, creating (and storing) one if
     * none exists.
     */
    public static synchronized UUID getOrInitializeLocalHostId()
    {
<span class="fc" id="L1238">        return getOrInitializeLocalHostId(UUID::randomUUID);</span>
    }

    private static synchronized UUID getOrInitializeLocalHostId(Supplier&lt;UUID&gt; nodeIdSupplier)
    {
<span class="fc" id="L1243">        UUID hostId = getLocalHostId();</span>
<span class="fc bfc" id="L1244" title="All 2 branches covered.">        if (hostId != null)</span>
<span class="fc" id="L1245">            return hostId;</span>

        // ID not found, generate a new one, persist, and then return it.
<span class="fc" id="L1248">        hostId = nodeIdSupplier.get();</span>
<span class="fc" id="L1249">        logger.warn(&quot;No host ID found, created {} (Note: This should happen exactly once per node).&quot;, hostId);</span>
<span class="fc" id="L1250">        return setLocalHostId(hostId);</span>
    }

    /**
     * Sets the local host ID explicitly.  Should only be called outside of SystemTable when replacing a node.
     */
    public static synchronized UUID setLocalHostId(UUID hostId)
    {
<span class="fc" id="L1258">        String req = &quot;INSERT INTO system.%s (key, host_id) VALUES ('%s', ?)&quot;;</span>
<span class="fc" id="L1259">        executeInternal(format(req, LOCAL, LOCAL), hostId);</span>
<span class="fc" id="L1260">        forceBlockingFlush(LOCAL);</span>
<span class="fc" id="L1261">        return hostId;</span>
    }

    /**
     * Gets the schema version or null if missing
     */
    public static UUID getSchemaVersion()
    {
<span class="nc" id="L1269">        String req = &quot;SELECT schema_version FROM system.%s WHERE key='%s'&quot;;</span>
<span class="nc" id="L1270">        UntypedResultSet result = executeInternal(format(req, LOCAL, LOCAL));</span>

<span class="nc bnc" id="L1272" title="All 4 branches missed.">        if (!result.isEmpty() &amp;&amp; result.one().has(&quot;schema_version&quot;))</span>
<span class="nc" id="L1273">            return result.one().getUUID(&quot;schema_version&quot;);</span>

<span class="nc" id="L1275">        return null;</span>
    }

    /**
     * Gets the stored rack for the local node, or null if none have been set yet.
     */
    public static String getRack()
    {
<span class="fc" id="L1283">        String req = &quot;SELECT rack FROM system.%s WHERE key='%s'&quot;;</span>
<span class="fc" id="L1284">        UntypedResultSet result = executeInternal(format(req, LOCAL, LOCAL));</span>

        // Look up the Rack (return it if found)
<span class="pc bpc" id="L1287" title="1 of 4 branches missed.">        if (!result.isEmpty() &amp;&amp; result.one().has(&quot;rack&quot;))</span>
<span class="fc" id="L1288">            return result.one().getString(&quot;rack&quot;);</span>

<span class="fc" id="L1290">        return null;</span>
    }

    /**
     * Gets the stored data center for the local node, or null if none have been set yet.
     */
    public static String getDatacenter()
    {
<span class="fc" id="L1298">        String req = &quot;SELECT data_center FROM system.%s WHERE key='%s'&quot;;</span>
<span class="fc" id="L1299">        UntypedResultSet result = executeInternal(format(req, LOCAL, LOCAL));</span>

        // Look up the Data center (return it if found)
<span class="pc bpc" id="L1302" title="1 of 4 branches missed.">        if (!result.isEmpty() &amp;&amp; result.one().has(&quot;data_center&quot;))</span>
<span class="fc" id="L1303">            return result.one().getString(&quot;data_center&quot;);</span>

<span class="fc" id="L1305">        return null;</span>
    }

    /**
     * Load the current paxos state for the table and key
     */
    public static PaxosState.Snapshot loadPaxosState(DecoratedKey partitionKey, TableMetadata metadata, long nowInSec)
    {
<span class="fc" id="L1313">        String cql = &quot;SELECT * FROM system.&quot; + PAXOS + &quot; WHERE row_key = ? AND cf_id = ?&quot;;</span>
<span class="fc" id="L1314">        List&lt;Row&gt; results = QueryProcessor.executeInternalRawWithNow(nowInSec, cql, partitionKey.getKey(), metadata.id.asUUID()).get(partitionKey);</span>
<span class="pc bpc" id="L1315" title="3 of 4 branches missed.">        if (results == null || results.isEmpty())</span>
        {
<span class="fc" id="L1317">            Committed noneCommitted = Committed.none(partitionKey, metadata);</span>
<span class="fc" id="L1318">            return new PaxosState.Snapshot(Ballot.none(), Ballot.none(), null, noneCommitted);</span>
        }

<span class="nc" id="L1321">        Row row = results.get(0);</span>

<span class="nc" id="L1323">        Ballot promisedWrite = PaxosRows.getWritePromise(row);</span>
<span class="nc" id="L1324">        Ballot promised = latest(promisedWrite, PaxosRows.getPromise(row));</span>

        // either we have both a recently accepted ballot and update or we have neither
<span class="nc" id="L1327">        Accepted accepted = PaxosRows.getAccepted(row);</span>
<span class="nc" id="L1328">        Committed committed = PaxosRows.getCommitted(metadata, partitionKey, row);</span>
        // fix a race with TTL/deletion resolution, where TTL expires after equal deletion is inserted; TTL wins the resolution, and is read using an old ballot's nowInSec
<span class="nc bnc" id="L1330" title="All 4 branches missed.">        if (accepted != null &amp;&amp; !accepted.isAfter(committed))</span>
<span class="nc" id="L1331">            accepted = null;</span>

<span class="nc" id="L1333">        return new PaxosState.Snapshot(promised, promisedWrite, accepted, committed);</span>
    }

    public static int legacyPaxosTtlSec(TableMetadata metadata)
    {
        // keep paxos state around for at least 3h
<span class="fc" id="L1339">        return Math.max(3 * 3600, metadata.params.gcGraceSeconds);</span>
    }

    public static void savePaxosWritePromise(DecoratedKey key, TableMetadata metadata, Ballot ballot)
    {
<span class="pc bpc" id="L1344" title="1 of 2 branches missed.">        if (paxosStatePurging() == legacy)</span>
        {
<span class="fc" id="L1346">            String cql = &quot;UPDATE system.&quot; + PAXOS + &quot; USING TIMESTAMP ? AND TTL ? SET in_progress_ballot = ? WHERE row_key = ? AND cf_id = ?&quot;;</span>
<span class="fc" id="L1347">            executeInternal(cql,</span>
<span class="fc" id="L1348">                            ballot.unixMicros(),</span>
<span class="fc" id="L1349">                            legacyPaxosTtlSec(metadata),</span>
                            ballot,
<span class="fc" id="L1351">                            key.getKey(),</span>
<span class="fc" id="L1352">                            metadata.id.asUUID());</span>
<span class="fc" id="L1353">        }</span>
        else
        {
<span class="nc" id="L1356">            String cql = &quot;UPDATE system.&quot; + PAXOS + &quot; USING TIMESTAMP ? SET in_progress_ballot = ? WHERE row_key = ? AND cf_id = ?&quot;;</span>
<span class="nc" id="L1357">            executeInternal(cql,</span>
<span class="nc" id="L1358">                            ballot.unixMicros(),</span>
                            ballot,
<span class="nc" id="L1360">                            key.getKey(),</span>
<span class="nc" id="L1361">                            metadata.id.asUUID());</span>
        }
<span class="fc" id="L1363">    }</span>

    public static void savePaxosReadPromise(DecoratedKey key, TableMetadata metadata, Ballot ballot)
    {
<span class="nc bnc" id="L1367" title="All 2 branches missed.">        if (paxosStatePurging() == legacy)</span>
        {
<span class="nc" id="L1369">            String cql = &quot;UPDATE system.&quot; + PAXOS + &quot; USING TIMESTAMP ? AND TTL ? SET in_progress_read_ballot = ? WHERE row_key = ? AND cf_id = ?&quot;;</span>
<span class="nc" id="L1370">            executeInternal(cql,</span>
<span class="nc" id="L1371">                            ballot.unixMicros(),</span>
<span class="nc" id="L1372">                            legacyPaxosTtlSec(metadata),</span>
                            ballot,
<span class="nc" id="L1374">                            key.getKey(),</span>
<span class="nc" id="L1375">                            metadata.id.asUUID());</span>
<span class="nc" id="L1376">        }</span>
        else
        {
<span class="nc" id="L1379">            String cql = &quot;UPDATE system.&quot; + PAXOS + &quot; USING TIMESTAMP ? SET in_progress_read_ballot = ? WHERE row_key = ? AND cf_id = ?&quot;;</span>
<span class="nc" id="L1380">            executeInternal(cql,</span>
<span class="nc" id="L1381">                            ballot.unixMicros(),</span>
                            ballot,
<span class="nc" id="L1383">                            key.getKey(),</span>
<span class="nc" id="L1384">                            metadata.id.asUUID());</span>
        }
<span class="nc" id="L1386">    }</span>

    public static void savePaxosProposal(Commit proposal)
    {
<span class="pc bpc" id="L1390" title="1 of 2 branches missed.">        if (proposal instanceof AcceptedWithTTL)</span>
        {
<span class="fc" id="L1392">            long localDeletionTime = ((Commit.AcceptedWithTTL) proposal).localDeletionTime;</span>
<span class="fc" id="L1393">            int ttlInSec = legacyPaxosTtlSec(proposal.update.metadata());</span>
<span class="fc" id="L1394">            long nowInSec = localDeletionTime - ttlInSec;</span>
<span class="fc" id="L1395">            String cql = &quot;UPDATE system.&quot; + PAXOS + &quot; USING TIMESTAMP ? AND TTL ? SET proposal_ballot = ?, proposal = ?, proposal_version = ? WHERE row_key = ? AND cf_id = ?&quot;;</span>
<span class="fc" id="L1396">            executeInternalWithNowInSec(cql,</span>
                                        nowInSec,
<span class="fc" id="L1398">                                        proposal.ballot.unixMicros(),</span>
<span class="fc" id="L1399">                                        ttlInSec,</span>
                                        proposal.ballot,
<span class="fc" id="L1401">                                        PartitionUpdate.toBytes(proposal.update, MessagingService.current_version),</span>
<span class="fc" id="L1402">                                        MessagingService.current_version,</span>
<span class="fc" id="L1403">                                        proposal.update.partitionKey().getKey(),</span>
<span class="fc" id="L1404">                                        proposal.update.metadata().id.asUUID());</span>
<span class="fc" id="L1405">        }</span>
        else
        {
<span class="nc" id="L1408">            String cql = &quot;UPDATE system.&quot; + PAXOS + &quot; USING TIMESTAMP ? SET proposal_ballot = ?, proposal = ?, proposal_version = ? WHERE row_key = ? AND cf_id = ?&quot;;</span>
<span class="nc" id="L1409">            executeInternal(cql,</span>
<span class="nc" id="L1410">                            proposal.ballot.unixMicros(),</span>
                            proposal.ballot,
<span class="nc" id="L1412">                            PartitionUpdate.toBytes(proposal.update, MessagingService.current_version),</span>
<span class="nc" id="L1413">                            MessagingService.current_version,</span>
<span class="nc" id="L1414">                            proposal.update.partitionKey().getKey(),</span>
<span class="nc" id="L1415">                            proposal.update.metadata().id.asUUID());</span>
        }
<span class="fc" id="L1417">    }</span>

    public static void savePaxosCommit(Commit commit)
    {
        // We always erase the last proposal (with the commit timestamp to no erase more recent proposal in case the commit is old)
        // even though that's really just an optimization  since SP.beginAndRepairPaxos will exclude accepted proposal older than the mrc.
<span class="pc bpc" id="L1423" title="1 of 2 branches missed.">        if (commit instanceof Commit.CommittedWithTTL)</span>
        {
<span class="fc" id="L1425">            long localDeletionTime = ((Commit.CommittedWithTTL) commit).localDeletionTime;</span>
<span class="fc" id="L1426">            int ttlInSec = legacyPaxosTtlSec(commit.update.metadata());</span>
<span class="fc" id="L1427">            long nowInSec = localDeletionTime - ttlInSec;</span>
<span class="fc" id="L1428">            String cql = &quot;UPDATE system.&quot; + PAXOS + &quot; USING TIMESTAMP ? AND TTL ? SET proposal_ballot = null, proposal = null, proposal_version = null, most_recent_commit_at = ?, most_recent_commit = ?, most_recent_commit_version = ? WHERE row_key = ? AND cf_id = ?&quot;;</span>
<span class="fc" id="L1429">            executeInternalWithNowInSec(cql,</span>
                            nowInSec,
<span class="fc" id="L1431">                            commit.ballot.unixMicros(),</span>
<span class="fc" id="L1432">                            ttlInSec,</span>
                            commit.ballot,
<span class="fc" id="L1434">                            PartitionUpdate.toBytes(commit.update, MessagingService.current_version),</span>
<span class="fc" id="L1435">                            MessagingService.current_version,</span>
<span class="fc" id="L1436">                            commit.update.partitionKey().getKey(),</span>
<span class="fc" id="L1437">                            commit.update.metadata().id.asUUID());</span>
<span class="fc" id="L1438">        }</span>
        else
        {
<span class="nc" id="L1441">            String cql = &quot;UPDATE system.&quot; + PAXOS + &quot; USING TIMESTAMP ? SET proposal_ballot = null, proposal = null, proposal_version = null, most_recent_commit_at = ?, most_recent_commit = ?, most_recent_commit_version = ? WHERE row_key = ? AND cf_id = ?&quot;;</span>
<span class="nc" id="L1442">            executeInternal(cql,</span>
<span class="nc" id="L1443">                            commit.ballot.unixMicros(),</span>
                            commit.ballot,
<span class="nc" id="L1445">                            PartitionUpdate.toBytes(commit.update, MessagingService.current_version),</span>
<span class="nc" id="L1446">                            MessagingService.current_version,</span>
<span class="nc" id="L1447">                            commit.update.partitionKey().getKey(),</span>
<span class="nc" id="L1448">                            commit.update.metadata().id.asUUID());</span>
        }
<span class="fc" id="L1450">    }</span>

    @VisibleForTesting
    public static void savePaxosRepairHistory(String keyspace, String table, PaxosRepairHistory history, boolean flush)
    {
<span class="nc" id="L1455">        String cql = &quot;INSERT INTO system.%s (keyspace_name, table_name, points) VALUES (?, ?, ?)&quot;;</span>
<span class="nc" id="L1456">        executeInternal(String.format(cql, PAXOS_REPAIR_HISTORY), keyspace, table, history.toTupleBufferList());</span>
<span class="nc bnc" id="L1457" title="All 2 branches missed.">        if (flush)</span>
<span class="nc" id="L1458">            flushPaxosRepairHistory();</span>
<span class="nc" id="L1459">    }</span>

    public static void flushPaxosRepairHistory()
    {
<span class="nc" id="L1463">        Schema.instance.getColumnFamilyStoreInstance(PaxosRepairHistoryTable.id)</span>
<span class="nc" id="L1464">                       .forceBlockingFlush(ColumnFamilyStore.FlushReason.INTERNALLY_FORCED);</span>
<span class="nc" id="L1465">    }</span>

    public static PaxosRepairHistory loadPaxosRepairHistory(String keyspace, String table)
    {
<span class="nc bnc" id="L1469" title="All 2 branches missed.">        if (SchemaConstants.LOCAL_SYSTEM_KEYSPACE_NAMES.contains(keyspace))</span>
<span class="nc" id="L1470">            return PaxosRepairHistory.EMPTY;</span>

<span class="nc" id="L1472">        UntypedResultSet results = executeInternal(String.format(&quot;SELECT * FROM system.%s WHERE keyspace_name=? AND table_name=?&quot;, PAXOS_REPAIR_HISTORY), keyspace, table);</span>
<span class="nc bnc" id="L1473" title="All 2 branches missed.">        if (results.isEmpty())</span>
<span class="nc" id="L1474">            return PaxosRepairHistory.EMPTY;</span>

<span class="nc" id="L1476">        UntypedResultSet.Row row = Iterables.getOnlyElement(results);</span>
<span class="nc" id="L1477">        List&lt;ByteBuffer&gt; points = row.getList(&quot;points&quot;, BytesType.instance);</span>

<span class="nc" id="L1479">        return PaxosRepairHistory.fromTupleBufferList(points);</span>
    }

    /**
     * Returns a RestorableMeter tracking the average read rate of a particular SSTable, restoring the last-seen rate
     * from values in system.sstable_activity if present.
     * @param keyspace the keyspace the sstable belongs to
     * @param table the table the sstable belongs to
     * @param id the generation id for the sstable
     */
    public static RestorableMeter getSSTableReadMeter(String keyspace, String table, SSTableId id)
    {
<span class="fc" id="L1491">        UntypedResultSet results = readSSTableActivity(keyspace, table, id);</span>

<span class="fc bfc" id="L1493" title="All 2 branches covered.">        if (results.isEmpty())</span>
<span class="fc" id="L1494">            return new RestorableMeter();</span>

<span class="fc" id="L1496">        UntypedResultSet.Row row = results.one();</span>
<span class="fc" id="L1497">        double m15rate = row.getDouble(&quot;rate_15m&quot;);</span>
<span class="fc" id="L1498">        double m120rate = row.getDouble(&quot;rate_120m&quot;);</span>
<span class="fc" id="L1499">        return new RestorableMeter(m15rate, m120rate);</span>
    }

    @VisibleForTesting
    public static UntypedResultSet readSSTableActivity(String keyspace, String table, SSTableId id)
    {
<span class="fc" id="L1505">        String cql = &quot;SELECT * FROM system.%s WHERE keyspace_name=? and table_name=? and id=?&quot;;</span>
<span class="fc" id="L1506">        return executeInternal(format(cql, SSTABLE_ACTIVITY_V2), keyspace, table, id.toString());</span>
    }

    /**
     * Writes the current read rates for a given SSTable to system.sstable_activity
     */
    public static void persistSSTableReadMeter(String keyspace, String table, SSTableId id, RestorableMeter meter)
    {
        // Store values with a one-day TTL to handle corner cases where cleanup might not occur
<span class="nc" id="L1515">        String cql = &quot;INSERT INTO system.%s (keyspace_name, table_name, id, rate_15m, rate_120m) VALUES (?, ?, ?, ?, ?) USING TTL 864000&quot;;</span>
<span class="nc" id="L1516">        executeInternal(format(cql, SSTABLE_ACTIVITY_V2),</span>
                        keyspace,
                        table,
<span class="nc" id="L1519">                        id.toString(),</span>
<span class="nc" id="L1520">                        meter.fifteenMinuteRate(),</span>
<span class="nc" id="L1521">                        meter.twoHourRate());</span>

<span class="nc bnc" id="L1523" title="All 4 branches missed.">        if (!DatabaseDescriptor.isUUIDSSTableIdentifiersEnabled() &amp;&amp; id instanceof SequenceBasedSSTableId)</span>
        {
            // we do this in order to make it possible to downgrade until we switch in cassandra.yaml to UUID based ids
            // see the discussion on CASSANDRA-17048
<span class="nc" id="L1527">            cql = &quot;INSERT INTO system.%s (keyspace_name, columnfamily_name, generation, rate_15m, rate_120m) VALUES (?, ?, ?, ?, ?) USING TTL 864000&quot;;</span>
<span class="nc" id="L1528">            executeInternal(format(cql, LEGACY_SSTABLE_ACTIVITY),</span>
                            keyspace,
                            table,
<span class="nc" id="L1531">                            ((SequenceBasedSSTableId) id).generation,</span>
<span class="nc" id="L1532">                            meter.fifteenMinuteRate(),</span>
<span class="nc" id="L1533">                            meter.twoHourRate());</span>
        }
<span class="nc" id="L1535">    }</span>

    /**
     * Clears persisted read rates from system.sstable_activity for SSTables that have been deleted.
     */
    public static void clearSSTableReadMeter(String keyspace, String table, SSTableId id)
    {
<span class="fc" id="L1542">        String cql = &quot;DELETE FROM system.%s WHERE keyspace_name=? AND table_name=? and id=?&quot;;</span>
<span class="fc" id="L1543">        executeInternal(format(cql, SSTABLE_ACTIVITY_V2), keyspace, table, id.toString());</span>
<span class="pc bpc" id="L1544" title="2 of 4 branches missed.">        if (!DatabaseDescriptor.isUUIDSSTableIdentifiersEnabled() &amp;&amp; id instanceof SequenceBasedSSTableId)</span>
        {
            // we do this in order to make it possible to downgrade until we switch in cassandra.yaml to UUID based ids
            // see the discussion on CASSANDRA-17048
<span class="fc" id="L1548">            cql = &quot;DELETE FROM system.%s WHERE keyspace_name=? AND columnfamily_name=? and generation=?&quot;;</span>
<span class="fc" id="L1549">            executeInternal(format(cql, LEGACY_SSTABLE_ACTIVITY), keyspace, table, ((SequenceBasedSSTableId) id).generation);</span>
        }
<span class="fc" id="L1551">    }</span>

    /**
     * Writes the current partition count and size estimates into SIZE_ESTIMATES_CF
     */
    public static void updateSizeEstimates(String keyspace, String table, Map&lt;Range&lt;Token&gt;, Pair&lt;Long, Long&gt;&gt; estimates)
    {
<span class="fc" id="L1558">        long timestamp = FBUtilities.timestampMicros();</span>
<span class="fc" id="L1559">        long nowInSec = FBUtilities.nowInSeconds();</span>
<span class="fc" id="L1560">        PartitionUpdate.Builder update = new PartitionUpdate.Builder(LegacySizeEstimates, UTF8Type.instance.decompose(keyspace), LegacySizeEstimates.regularAndStaticColumns(), estimates.size());</span>
        // delete all previous values with a single range tombstone.
<span class="fc" id="L1562">        update.add(new RangeTombstone(Slice.make(LegacySizeEstimates.comparator, table), DeletionTime.build(timestamp - 1, nowInSec)));</span>

        // add a CQL row for each primary token range.
<span class="fc bfc" id="L1565" title="All 2 branches covered.">        for (Map.Entry&lt;Range&lt;Token&gt;, Pair&lt;Long, Long&gt;&gt; entry : estimates.entrySet())</span>
        {
<span class="fc" id="L1567">            Range&lt;Token&gt; range = entry.getKey();</span>
<span class="fc" id="L1568">            Pair&lt;Long, Long&gt; values = entry.getValue();</span>
<span class="fc" id="L1569">            update.add(Rows.simpleBuilder(LegacySizeEstimates, table, range.left.toString(), range.right.toString())</span>
<span class="fc" id="L1570">                           .timestamp(timestamp)</span>
<span class="fc" id="L1571">                           .add(&quot;partitions_count&quot;, values.left)</span>
<span class="fc" id="L1572">                           .add(&quot;mean_partition_size&quot;, values.right)</span>
<span class="fc" id="L1573">                           .build());</span>
<span class="fc" id="L1574">        }</span>
<span class="fc" id="L1575">        new Mutation(update.build()).apply();</span>
<span class="fc" id="L1576">    }</span>

    /**
     * Writes the current partition count and size estimates into table_estimates
     */
    public static void updateTableEstimates(String keyspace, String table, String type, Map&lt;Range&lt;Token&gt;, Pair&lt;Long, Long&gt;&gt; estimates)
    {
<span class="fc" id="L1583">        long timestamp = FBUtilities.timestampMicros();</span>
<span class="fc" id="L1584">        long nowInSec = FBUtilities.nowInSeconds();</span>
<span class="fc" id="L1585">        PartitionUpdate.Builder update = new PartitionUpdate.Builder(TableEstimates, UTF8Type.instance.decompose(keyspace), TableEstimates.regularAndStaticColumns(), estimates.size());</span>

        // delete all previous values with a single range tombstone.
<span class="fc" id="L1588">        update.add(new RangeTombstone(Slice.make(TableEstimates.comparator, table, type), DeletionTime.build(timestamp - 1, nowInSec)));</span>

        // add a CQL row for each primary token range.
<span class="fc bfc" id="L1591" title="All 2 branches covered.">        for (Map.Entry&lt;Range&lt;Token&gt;, Pair&lt;Long, Long&gt;&gt; entry : estimates.entrySet())</span>
        {
<span class="fc" id="L1593">            Range&lt;Token&gt; range = entry.getKey();</span>
<span class="fc" id="L1594">            Pair&lt;Long, Long&gt; values = entry.getValue();</span>
<span class="fc" id="L1595">            update.add(Rows.simpleBuilder(TableEstimates, table, type, range.left.toString(), range.right.toString())</span>
<span class="fc" id="L1596">                           .timestamp(timestamp)</span>
<span class="fc" id="L1597">                           .add(&quot;partitions_count&quot;, values.left)</span>
<span class="fc" id="L1598">                           .add(&quot;mean_partition_size&quot;, values.right)</span>
<span class="fc" id="L1599">                           .build());</span>
<span class="fc" id="L1600">        }</span>

<span class="fc" id="L1602">        new Mutation(update.build()).apply();</span>
<span class="fc" id="L1603">    }</span>


    /**
     * Clears size estimates for a table (on table drop)
     */
    public static void clearEstimates(String keyspace, String table)
    {
<span class="nc" id="L1611">        String cqlFormat = &quot;DELETE FROM %s WHERE keyspace_name = ? AND table_name = ?&quot;;</span>
<span class="nc" id="L1612">        String cql = format(cqlFormat, LegacySizeEstimates.toString());</span>
<span class="nc" id="L1613">        executeInternal(cql, keyspace, table);</span>
<span class="nc" id="L1614">        cql = String.format(cqlFormat, TableEstimates.toString());</span>
<span class="nc" id="L1615">        executeInternal(cql, keyspace, table);</span>
<span class="nc" id="L1616">    }</span>

    /**
     * truncates size_estimates and table_estimates tables
     */
    public static void clearAllEstimates()
    {
<span class="fc bfc" id="L1623" title="All 2 branches covered.">        for (String table : Arrays.asList(LEGACY_SIZE_ESTIMATES, TABLE_ESTIMATES))</span>
        {
<span class="fc" id="L1625">            ColumnFamilyStore cfs = Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(table);</span>
<span class="fc" id="L1626">            cfs.truncateBlockingWithoutSnapshot();</span>
<span class="fc" id="L1627">        }</span>
<span class="fc" id="L1628">    }</span>

    public static synchronized void updateAvailableRanges(String keyspace, Collection&lt;Range&lt;Token&gt;&gt; completedFullRanges, Collection&lt;Range&lt;Token&gt;&gt; completedTransientRanges)
    {
<span class="fc" id="L1632">        String cql = &quot;UPDATE system.%s SET full_ranges = full_ranges + ?, transient_ranges = transient_ranges + ? WHERE keyspace_name = ?&quot;;</span>
<span class="fc" id="L1633">        executeInternal(format(cql, AVAILABLE_RANGES_V2),</span>
<span class="fc" id="L1634">                        completedFullRanges.stream().map(SystemKeyspace::rangeToBytes).collect(Collectors.toSet()),</span>
<span class="fc" id="L1635">                        completedTransientRanges.stream().map(SystemKeyspace::rangeToBytes).collect(Collectors.toSet()),</span>
                        keyspace);
<span class="fc" id="L1637">    }</span>

    /**
     * List of the streamed ranges, where transientness is encoded based on the source, where range was streamed from.
     */
    public static synchronized AvailableRanges getAvailableRanges(String keyspace, IPartitioner partitioner)
    {
<span class="fc" id="L1644">        String query = &quot;SELECT * FROM system.%s WHERE keyspace_name=?&quot;;</span>
<span class="fc" id="L1645">        UntypedResultSet rs = executeInternal(format(query, AVAILABLE_RANGES_V2), keyspace);</span>

<span class="fc" id="L1647">        ImmutableSet.Builder&lt;Range&lt;Token&gt;&gt; full = new ImmutableSet.Builder&lt;&gt;();</span>
<span class="fc" id="L1648">        ImmutableSet.Builder&lt;Range&lt;Token&gt;&gt; trans = new ImmutableSet.Builder&lt;&gt;();</span>
<span class="fc bfc" id="L1649" title="All 2 branches covered.">        for (UntypedResultSet.Row row : rs)</span>
        {
<span class="fc" id="L1651">            Optional.ofNullable(row.getSet(&quot;full_ranges&quot;, BytesType.instance))</span>
<span class="fc" id="L1652">                    .ifPresent(full_ranges -&gt; full_ranges.stream()</span>
<span class="fc" id="L1653">                            .map(buf -&gt; byteBufferToRange(buf, partitioner))</span>
<span class="fc" id="L1654">                            .forEach(full::add));</span>
<span class="fc" id="L1655">            Optional.ofNullable(row.getSet(&quot;transient_ranges&quot;, BytesType.instance))</span>
<span class="pc" id="L1656">                    .ifPresent(transient_ranges -&gt; transient_ranges.stream()</span>
<span class="nc" id="L1657">                            .map(buf -&gt; byteBufferToRange(buf, partitioner))</span>
<span class="nc" id="L1658">                            .forEach(trans::add));</span>
<span class="fc" id="L1659">        }</span>
<span class="fc" id="L1660">        return new AvailableRanges(full.build(), trans.build());</span>
    }

    public static class AvailableRanges
    {
        public Set&lt;Range&lt;Token&gt;&gt; full;
        public Set&lt;Range&lt;Token&gt;&gt; trans;

        private AvailableRanges(Set&lt;Range&lt;Token&gt;&gt; full, Set&lt;Range&lt;Token&gt;&gt; trans)
<span class="fc" id="L1669">        {</span>
<span class="fc" id="L1670">            this.full = full;</span>
<span class="fc" id="L1671">            this.trans = trans;</span>
<span class="fc" id="L1672">        }</span>
    }

    public static void resetAvailableStreamedRanges()
    {
<span class="fc" id="L1677">        ColumnFamilyStore availableRanges = Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(AVAILABLE_RANGES_V2);</span>
<span class="fc" id="L1678">        availableRanges.truncateBlockingWithoutSnapshot();</span>
<span class="fc" id="L1679">    }</span>

    public static void resetAvailableStreamedRangesForKeyspace(String keyspace)
    {
<span class="fc" id="L1683">        String cql = &quot;DELETE FROM %s.%s WHERE keyspace_name = ?&quot;;</span>
<span class="fc" id="L1684">        executeInternal(format(cql, SchemaConstants.SYSTEM_KEYSPACE_NAME, AVAILABLE_RANGES_V2), keyspace);</span>
<span class="fc" id="L1685">    }</span>

    public static synchronized void updateTransferredRanges(StreamOperation streamOperation,
                                                         InetAddressAndPort peer,
                                                         String keyspace,
                                                         Collection&lt;Range&lt;Token&gt;&gt; streamedRanges)
    {
<span class="fc" id="L1692">        String cql = &quot;UPDATE system.%s SET ranges = ranges + ? WHERE operation = ? AND peer = ? AND keyspace_name = ?&quot;;</span>
<span class="fc" id="L1693">        Set&lt;ByteBuffer&gt; rangesToUpdate = new HashSet&lt;&gt;(streamedRanges.size());</span>
<span class="fc bfc" id="L1694" title="All 2 branches covered.">        for (Range&lt;Token&gt; range : streamedRanges)</span>
        {
<span class="fc" id="L1696">            rangesToUpdate.add(rangeToBytes(range));</span>
<span class="fc" id="L1697">        }</span>
<span class="fc" id="L1698">        executeInternal(format(cql, LEGACY_TRANSFERRED_RANGES), rangesToUpdate, streamOperation.getDescription(), peer.getAddress(), keyspace);</span>
<span class="fc" id="L1699">        cql = &quot;UPDATE system.%s SET ranges = ranges + ? WHERE operation = ? AND peer = ? AND peer_port = ? AND keyspace_name = ?&quot;;</span>
<span class="fc" id="L1700">        executeInternal(String.format(cql, TRANSFERRED_RANGES_V2), rangesToUpdate, streamOperation.getDescription(), peer.getAddress(), peer.getPort(), keyspace);</span>
<span class="fc" id="L1701">    }</span>

    public static synchronized Map&lt;InetAddressAndPort, Set&lt;Range&lt;Token&gt;&gt;&gt; getTransferredRanges(String description, String keyspace, IPartitioner partitioner)
    {
<span class="fc" id="L1705">        Map&lt;InetAddressAndPort, Set&lt;Range&lt;Token&gt;&gt;&gt; result = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1706">        String query = &quot;SELECT * FROM system.%s WHERE operation = ? AND keyspace_name = ?&quot;;</span>
<span class="fc" id="L1707">        UntypedResultSet rs = executeInternal(String.format(query, TRANSFERRED_RANGES_V2), description, keyspace);</span>
<span class="pc bpc" id="L1708" title="1 of 2 branches missed.">        for (UntypedResultSet.Row row : rs)</span>
        {
<span class="nc" id="L1710">            InetAddress peerAddress = row.getInetAddress(&quot;peer&quot;);</span>
<span class="nc" id="L1711">            int port = row.getInt(&quot;peer_port&quot;);</span>
<span class="nc" id="L1712">            InetAddressAndPort peer = InetAddressAndPort.getByAddressOverrideDefaults(peerAddress, port);</span>
<span class="nc" id="L1713">            Set&lt;ByteBuffer&gt; rawRanges = row.getSet(&quot;ranges&quot;, BytesType.instance);</span>
<span class="nc" id="L1714">            Set&lt;Range&lt;Token&gt;&gt; ranges = Sets.newHashSetWithExpectedSize(rawRanges.size());</span>
<span class="nc bnc" id="L1715" title="All 2 branches missed.">            for (ByteBuffer rawRange : rawRanges)</span>
            {
<span class="nc" id="L1717">                ranges.add(byteBufferToRange(rawRange, partitioner));</span>
<span class="nc" id="L1718">            }</span>
<span class="nc" id="L1719">            result.put(peer, ranges);</span>
<span class="nc" id="L1720">        }</span>
<span class="fc" id="L1721">        return ImmutableMap.copyOf(result);</span>
    }

    /**
     * Compare the release version in the system.local table with the one included in the distro.
     * If they don't match, snapshot all tables in the system and schema keyspaces. This is intended
     * to be called at startup to create a backup of the system tables during an upgrade
     *
     * @throws IOException
     */
    public static void snapshotOnVersionChange() throws IOException
    {
<span class="fc" id="L1733">        String previous = getPreviousVersionString();</span>
<span class="fc" id="L1734">        String next = FBUtilities.getReleaseVersionString();</span>

<span class="fc" id="L1736">        FBUtilities.setPreviousReleaseVersionString(previous);</span>

        // if we're restarting after an upgrade, snapshot the system and schema keyspaces
<span class="fc bfc" id="L1739" title="All 4 branches covered.">        if (!previous.equals(NULL_VERSION.toString()) &amp;&amp; !previous.equals(next))</span>

        {
<span class="fc" id="L1742">            logger.info(&quot;Detected version upgrade from {} to {}, snapshotting system keyspaces&quot;, previous, next);</span>
<span class="fc" id="L1743">            String snapshotName = Keyspace.getTimestampedSnapshotName(format(&quot;upgrade-%s-%s&quot;,</span>
                                                                             previous,
                                                                             next));

<span class="fc" id="L1747">            Instant creationTime = now();</span>
<span class="fc bfc" id="L1748" title="All 2 branches covered.">            for (String keyspace : SchemaConstants.LOCAL_SYSTEM_KEYSPACE_NAMES)</span>
<span class="fc" id="L1749">                Keyspace.open(keyspace).snapshot(snapshotName, null, false, null, null, creationTime);</span>
        }
<span class="fc" id="L1751">    }</span>

    /**
     * Try to determine what the previous version, if any, was installed on this node.
     * Primary source of truth is the release version in system.local. If the previous
     * version cannot be determined by looking there then either:
     * * the node never had a C* install before
     * * the was a very old version (pre 1.2) installed, which did not include system.local
     *
     * @return either a version read from the system.local table or one of two special values
     * indicating either no previous version (SystemUpgrade.NULL_VERSION) or an unreadable,
     * legacy version (SystemUpgrade.UNREADABLE_VERSION).
     */
    private static String getPreviousVersionString()
    {
<span class="fc" id="L1766">        String req = &quot;SELECT release_version FROM system.%s WHERE key='%s'&quot;;</span>
<span class="fc" id="L1767">        UntypedResultSet result = executeInternal(format(req, SystemKeyspace.LOCAL, SystemKeyspace.LOCAL));</span>
<span class="pc bpc" id="L1768" title="1 of 4 branches missed.">        if (result.isEmpty() || !result.one().has(&quot;release_version&quot;))</span>
        {
            // it isn't inconceivable that one might try to upgrade a node straight from &lt;= 1.1 to whatever
            // the current version is. If we couldn't read a previous version from system.local we check for
            // the existence of the legacy system.Versions table. We don't actually attempt to read a version
            // from there, but it informs us that this isn't a completely new node.
<span class="fc bfc" id="L1774" title="All 2 branches covered.">            for (File dataDirectory : Directories.getKSChildDirectories(SchemaConstants.SYSTEM_KEYSPACE_NAME))</span>
            {
<span class="pc bpc" id="L1776" title="3 of 4 branches missed.">                if (dataDirectory.name().equals(&quot;Versions&quot;) &amp;&amp; dataDirectory.tryList().length &gt; 0)</span>
                {
<span class="nc" id="L1778">                    logger.trace(&quot;Found unreadable versions info in pre 1.2 system.Versions table&quot;);</span>
<span class="nc" id="L1779">                    return UNREADABLE_VERSION.toString();</span>
                }
<span class="fc" id="L1781">            }</span>

            // no previous version information found, we can assume that this is a new node
<span class="fc" id="L1784">            return NULL_VERSION.toString();</span>
        }
        // report back whatever we found in the system table
<span class="fc" id="L1787">        return result.one().getString(&quot;release_version&quot;);</span>
    }

    @VisibleForTesting
    public static Set&lt;Range&lt;Token&gt;&gt; rawRangesToRangeSet(Set&lt;ByteBuffer&gt; rawRanges, IPartitioner partitioner)
    {
<span class="nc" id="L1793">        return rawRanges.stream().map(buf -&gt; byteBufferToRange(buf, partitioner)).collect(Collectors.toSet());</span>
    }

    @VisibleForTesting
    public static ByteBuffer rangeToBytes(Range&lt;Token&gt; range)
    {
<span class="fc" id="L1799">        try (DataOutputBuffer out = new DataOutputBuffer())</span>
        {
            // The format with which token ranges are serialized in the system tables is the pre-3.0 serialization
            // formot for ranges, so we should maintain that for now. And while we don't really support pre-3.0
            // messaging versions, we know AbstractBounds.Serializer still support it _exactly_ for this use case, so we
            // pass 0 as the version to trigger that legacy code.
            // In the future, it might be worth switching to a stable text format for the ranges to 1) save that and 2)
            // be more user friendly (the serialization format we currently use is pretty custom).
<span class="fc" id="L1807">            Range.tokenSerializer.serialize(range, out, 0);</span>
<span class="fc" id="L1808">            return out.buffer();</span>
        }
<span class="nc" id="L1810">        catch (IOException e)</span>
        {
<span class="nc" id="L1812">            throw new IOError(e);</span>
        }
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private static Range&lt;Token&gt; byteBufferToRange(ByteBuffer rawRange, IPartitioner partitioner)
    {
        try
        {
            // See rangeToBytes above for why version is 0.
<span class="fc" id="L1822">            return (Range&lt;Token&gt;) Range.tokenSerializer.deserialize(ByteStreams.newDataInput(ByteBufferUtil.getArray(rawRange)),</span>
                                                                    partitioner,
                                                                    0);
        }
<span class="nc" id="L1826">        catch (IOException e)</span>
        {
<span class="nc" id="L1828">            throw new IOError(e);</span>
        }
    }

    public static void writePreparedStatement(String loggedKeyspace, MD5Digest key, String cql)
    {
<span class="fc" id="L1834">        executeInternal(format(&quot;INSERT INTO %s (logged_keyspace, prepared_id, query_string) VALUES (?, ?, ?)&quot;,</span>
<span class="fc" id="L1835">                               PreparedStatements.toString()),</span>
<span class="fc" id="L1836">                        loggedKeyspace, key.byteBuffer(), cql);</span>
<span class="fc" id="L1837">        logger.debug(&quot;stored prepared statement for logged keyspace '{}': '{}'&quot;, loggedKeyspace, cql);</span>
<span class="fc" id="L1838">    }</span>

    public static void removePreparedStatement(MD5Digest key)
    {
<span class="fc" id="L1842">        executeInternal(format(&quot;DELETE FROM %s WHERE prepared_id = ?&quot;, PreparedStatements.toString()),</span>
<span class="fc" id="L1843">                        key.byteBuffer());</span>
<span class="fc" id="L1844">    }</span>

    public static void resetPreparedStatements()
    {
<span class="nc" id="L1848">        ColumnFamilyStore preparedStatements = Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(PREPARED_STATEMENTS);</span>
<span class="nc" id="L1849">        preparedStatements.truncateBlockingWithoutSnapshot();</span>
<span class="nc" id="L1850">    }</span>

    public static int loadPreparedStatements(TriFunction&lt;MD5Digest, String, String, Boolean&gt; onLoaded)
    {
<span class="fc" id="L1854">        String query = String.format(&quot;SELECT prepared_id, logged_keyspace, query_string FROM %s.%s&quot;, SchemaConstants.SYSTEM_KEYSPACE_NAME, PREPARED_STATEMENTS);</span>
<span class="fc" id="L1855">        UntypedResultSet resultSet = executeOnceInternal(query);</span>
<span class="fc" id="L1856">        int counter = 0;</span>
<span class="fc bfc" id="L1857" title="All 2 branches covered.">        for (UntypedResultSet.Row row : resultSet)</span>
        {
<span class="fc bfc" id="L1859" title="All 2 branches covered.">            if (onLoaded.accept(MD5Digest.wrap(row.getByteArray(&quot;prepared_id&quot;)),</span>
<span class="fc" id="L1860">                                row.getString(&quot;query_string&quot;),</span>
<span class="fc bfc" id="L1861" title="All 2 branches covered.">                                row.has(&quot;logged_keyspace&quot;) ? row.getString(&quot;logged_keyspace&quot;) : null))</span>
<span class="fc" id="L1862">                counter++;</span>
<span class="fc" id="L1863">        }</span>
<span class="fc" id="L1864">        return counter;</span>
    }

    public static int loadPreparedStatement(MD5Digest digest, TriFunction&lt;MD5Digest, String, String, Boolean&gt; onLoaded)
    {
<span class="nc" id="L1869">        String query = String.format(&quot;SELECT prepared_id, logged_keyspace, query_string FROM %s.%s WHERE prepared_id = ?&quot;, SchemaConstants.SYSTEM_KEYSPACE_NAME, PREPARED_STATEMENTS);</span>
<span class="nc" id="L1870">        UntypedResultSet resultSet = executeOnceInternal(query, digest.byteBuffer());</span>
<span class="nc" id="L1871">        int counter = 0;</span>
<span class="nc bnc" id="L1872" title="All 2 branches missed.">        for (UntypedResultSet.Row row : resultSet)</span>
        {
<span class="nc bnc" id="L1874" title="All 2 branches missed.">            if (onLoaded.accept(MD5Digest.wrap(row.getByteArray(&quot;prepared_id&quot;)),</span>
<span class="nc" id="L1875">                                row.getString(&quot;query_string&quot;),</span>
<span class="nc bnc" id="L1876" title="All 2 branches missed.">                                row.has(&quot;logged_keyspace&quot;) ? row.getString(&quot;logged_keyspace&quot;) : null))</span>
<span class="nc" id="L1877">                counter++;</span>
<span class="nc" id="L1878">        }</span>
<span class="nc" id="L1879">        return counter;</span>
    }

    public static interface TriFunction&lt;A, B, C, D&gt; {
        D accept(A var1, B var2, C var3);
    }

    public static void saveTopPartitions(TableMetadata metadata, String topType, Collection&lt;TopPartitionTracker.TopPartition&gt; topPartitions, long lastUpdate)
    {
<span class="nc" id="L1888">        String cql = String.format(&quot;INSERT INTO %s.%s (keyspace_name, table_name, top_type, top, last_update) values (?, ?, ?, ?, ?)&quot;, SchemaConstants.SYSTEM_KEYSPACE_NAME, TOP_PARTITIONS);</span>
<span class="nc" id="L1889">        List&lt;ByteBuffer&gt; tupleList = new ArrayList&lt;&gt;(topPartitions.size());</span>
<span class="nc" id="L1890">        topPartitions.forEach(tp -&gt; {</span>
<span class="nc" id="L1891">            String key = metadata.partitionKeyType.getString(tp.key.getKey());</span>
<span class="nc" id="L1892">            tupleList.add(TupleType.buildValue(new ByteBuffer[] { UTF8Type.instance.decompose(key),</span>
<span class="nc" id="L1893">                                                                  LongType.instance.decompose(tp.value)}));</span>
<span class="nc" id="L1894">        });</span>
<span class="nc" id="L1895">        executeInternal(cql, metadata.keyspace, metadata.name, topType, tupleList, Date.from(Instant.ofEpochMilli(lastUpdate)));</span>
<span class="nc" id="L1896">    }</span>

    public static TopPartitionTracker.StoredTopPartitions getTopPartitions(TableMetadata metadata, String topType)
    {
        try
        {
<span class="fc" id="L1902">            String cql = String.format(&quot;SELECT top, last_update FROM %s.%s WHERE keyspace_name = ? and table_name = ? and top_type = ?&quot;, SchemaConstants.SYSTEM_KEYSPACE_NAME, TOP_PARTITIONS);</span>
<span class="fc" id="L1903">            UntypedResultSet res = executeInternal(cql, metadata.keyspace, metadata.name, topType);</span>
<span class="pc bpc" id="L1904" title="2 of 4 branches missed.">            if (res == null || res.isEmpty())</span>
<span class="fc" id="L1905">                return TopPartitionTracker.StoredTopPartitions.EMPTY;</span>
<span class="nc" id="L1906">            UntypedResultSet.Row row = res.one();</span>
<span class="nc" id="L1907">            long lastUpdated = row.getLong(&quot;last_update&quot;);</span>
<span class="nc" id="L1908">            List&lt;ByteBuffer&gt; top = row.getList(&quot;top&quot;, BytesType.instance);</span>
<span class="nc bnc" id="L1909" title="All 4 branches missed.">            if (top == null || top.isEmpty())</span>
<span class="nc" id="L1910">                return TopPartitionTracker.StoredTopPartitions.EMPTY;</span>

<span class="nc" id="L1912">            List&lt;TopPartitionTracker.TopPartition&gt; topPartitions = new ArrayList&lt;&gt;(top.size());</span>
<span class="nc" id="L1913">            TupleType tupleType = new TupleType(Lists.newArrayList(UTF8Type.instance, LongType.instance));</span>
<span class="nc bnc" id="L1914" title="All 2 branches missed.">            for (ByteBuffer bb : top)</span>
            {
<span class="nc" id="L1916">                ByteBuffer[] components = tupleType.split(ByteBufferAccessor.instance, bb);</span>
<span class="nc" id="L1917">                String keyStr = UTF8Type.instance.compose(components[0]);</span>
<span class="nc" id="L1918">                long value = LongType.instance.compose(components[1]);</span>
<span class="nc" id="L1919">                topPartitions.add(new TopPartitionTracker.TopPartition(metadata.partitioner.decorateKey(metadata.partitionKeyType.fromString(keyStr)), value));</span>
<span class="nc" id="L1920">            }</span>
<span class="nc" id="L1921">            return new TopPartitionTracker.StoredTopPartitions(topPartitions, lastUpdated);</span>
        }
<span class="nc" id="L1923">        catch (Exception e)</span>
        {
<span class="nc" id="L1925">            logger.warn(&quot;Could not load stored top {} partitions for {}.{}&quot;, topType, metadata.keyspace, metadata.name, e);</span>
<span class="nc" id="L1926">            return TopPartitionTracker.StoredTopPartitions.EMPTY;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>