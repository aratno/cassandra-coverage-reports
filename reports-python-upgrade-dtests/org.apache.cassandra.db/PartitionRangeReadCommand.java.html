<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PartitionRangeReadCommand.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db</a> &gt; <span class="el_source">PartitionRangeReadCommand.java</span></div><h1>PartitionRangeReadCommand.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db;

import java.io.IOException;
import java.util.List;
import java.util.concurrent.TimeUnit;

import com.google.common.annotations.VisibleForTesting;

import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.filter.ClusteringIndexFilter;
import org.apache.cassandra.db.filter.ColumnFilter;
import org.apache.cassandra.db.filter.DataLimits;
import org.apache.cassandra.db.filter.RowFilter;
import org.apache.cassandra.db.lifecycle.View;
import org.apache.cassandra.db.memtable.Memtable;
import org.apache.cassandra.db.partitions.CachedPartition;
import org.apache.cassandra.db.partitions.PartitionIterator;
import org.apache.cassandra.db.partitions.UnfilteredPartitionIterator;
import org.apache.cassandra.db.partitions.UnfilteredPartitionIterators;
import org.apache.cassandra.db.rows.BaseRowIterator;
import org.apache.cassandra.db.rows.UnfilteredRowIterator;
import org.apache.cassandra.db.transform.RTBoundValidator;
import org.apache.cassandra.db.transform.Transformation;
import org.apache.cassandra.db.virtual.VirtualKeyspaceRegistry;
import org.apache.cassandra.db.virtual.VirtualTable;
import org.apache.cassandra.dht.AbstractBounds;
import org.apache.cassandra.dht.Bounds;
import org.apache.cassandra.exceptions.RequestExecutionException;
import org.apache.cassandra.index.Index;
import org.apache.cassandra.io.sstable.SSTableReadsListener;
import org.apache.cassandra.io.sstable.format.SSTableReader;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.metrics.TableMetrics;
import org.apache.cassandra.net.Verb;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.service.ClientState;
import org.apache.cassandra.service.StorageProxy;
import org.apache.cassandra.tracing.Tracing;

/**
 * A read command that selects a (part of a) range of partitions.
 */
public class PartitionRangeReadCommand extends ReadCommand implements PartitionRangeReadQuery
{
<span class="fc" id="L63">    protected static final SelectionDeserializer selectionDeserializer = new Deserializer();</span>

    protected final DataRange dataRange;
    protected final Slices requestedSlices;

    private PartitionRangeReadCommand(boolean isDigest,
                                      int digestVersion,
                                      boolean acceptsTransient,
                                      TableMetadata metadata,
                                      long nowInSec,
                                      ColumnFilter columnFilter,
                                      RowFilter rowFilter,
                                      DataLimits limits,
                                      DataRange dataRange,
                                      Index.QueryPlan indexQueryPlan,
                                      boolean trackWarnings)
    {
<span class="fc" id="L80">        super(Kind.PARTITION_RANGE, isDigest, digestVersion, acceptsTransient, metadata, nowInSec, columnFilter, rowFilter, limits, indexQueryPlan, trackWarnings);</span>
<span class="fc" id="L81">        this.dataRange = dataRange;</span>
<span class="fc" id="L82">        this.requestedSlices = dataRange.clusteringIndexFilter.getSlices(metadata());</span>

<span class="fc" id="L84">    }</span>

    private static PartitionRangeReadCommand create(boolean isDigest,
                                                    int digestVersion,
                                                    boolean acceptsTransient,
                                                    TableMetadata metadata,
                                                    long nowInSec,
                                                    ColumnFilter columnFilter,
                                                    RowFilter rowFilter,
                                                    DataLimits limits,
                                                    DataRange dataRange,
                                                    Index.QueryPlan indexQueryPlan,
                                                    boolean trackWarnings)
    {
<span class="fc bfc" id="L98" title="All 2 branches covered.">        if (metadata.isVirtual())</span>
        {
<span class="fc" id="L100">            return new VirtualTablePartitionRangeReadCommand(isDigest,</span>
                                                             digestVersion,
                                                             acceptsTransient,
                                                             metadata,
                                                             nowInSec,
                                                             columnFilter,
                                                             rowFilter,
                                                             limits,
                                                             dataRange,
                                                             indexQueryPlan,
                                                             trackWarnings);
        }
<span class="fc" id="L112">        return new PartitionRangeReadCommand(isDigest,</span>
                                             digestVersion,
                                             acceptsTransient,
                                             metadata,
                                             nowInSec,
                                             columnFilter,
                                             rowFilter,
                                             limits,
                                             dataRange,
                                             indexQueryPlan,
                                             trackWarnings);
    }

    public static PartitionRangeReadCommand create(TableMetadata metadata,
                                                   long nowInSec,
                                                   ColumnFilter columnFilter,
                                                   RowFilter rowFilter,
                                                   DataLimits limits,
                                                   DataRange dataRange)
    {
<span class="fc" id="L132">        return create(false,</span>
                      0,
                      false,
                      metadata,
                      nowInSec,
                      columnFilter,
                      rowFilter,
                      limits,
                      dataRange,
<span class="fc" id="L141">                      findIndexQueryPlan(metadata, rowFilter),</span>
                      false);
    }

    /**
     * Creates a new read command that query all the data in the table.
     *
     * @param metadata the table to query.
     * @param nowInSec the time in seconds to use are &quot;now&quot; for this query.
     *
     * @return a newly created read command that queries everything in the table.
     */
    public static PartitionRangeReadCommand allDataRead(TableMetadata metadata, long nowInSec)
    {
<span class="fc" id="L155">        return create(false,</span>
                      0,
                      false,
                      metadata,
                      nowInSec,
<span class="fc" id="L160">                      ColumnFilter.all(metadata),</span>
<span class="fc" id="L161">                      RowFilter.none(),</span>
                      DataLimits.NONE,
<span class="fc" id="L163">                      DataRange.allData(metadata.partitioner),</span>
                      null,
                      false);
    }

    public DataRange dataRange()
    {
<span class="fc" id="L170">        return dataRange;</span>
    }

    public ClusteringIndexFilter clusteringIndexFilter(DecoratedKey key)
    {
<span class="nc" id="L175">        return dataRange.clusteringIndexFilter(key);</span>
    }

    public boolean isNamesQuery()
    {
<span class="nc" id="L180">        return dataRange.isNamesQuery();</span>
    }

    /**
     * Returns an equivalent command but that only queries data within the provided range.
     *
     * @param range the sub-range to restrict the command to. This method &lt;b&gt;assumes&lt;/b&gt; that this is a proper sub-range
     * of the command this is applied to.
     * @param isRangeContinuation whether {@code range} is a direct continuation of whatever previous range we have
     * queried. This matters for the {@code DataLimits} that may contain states when we do paging and in the context of
     * parallel queries: that state only make sense if the range queried is indeed the follow-up of whatever range we've
     * previously query (that yield said state). In practice this means that ranges for which {@code isRangeContinuation}
     * is false may have to be slightly pessimistic when counting data and may include a little bit than necessary, and
     * this should be dealt with post-query (in the case of {@code StorageProxy.getRangeSlice()}, which uses this method
     * for replica queries, this is dealt with by re-counting results on the coordinator). Note that if this is the
     * first range we queried, then the {@code DataLimits} will have not state and the value of this parameter doesn't
     * matter.
     */
    public PartitionRangeReadCommand forSubRange(AbstractBounds&lt;PartitionPosition&gt; range, boolean isRangeContinuation)
    {
        // If we're not a continuation of whatever range we've previously queried, we should ignore the states of the
        // DataLimits as it's either useless, or misleading. This is particularly important for GROUP BY queries, where
        // DataLimits.CQLGroupByLimits.GroupByAwareCounter assumes that if GroupingState.hasClustering(), then we're in
        // the middle of a group, but we can't make that assumption if we query and range &quot;in advance&quot; of where we are
        // on the ring.
<span class="fc" id="L205">        return create(isDigestQuery(),</span>
<span class="fc" id="L206">                      digestVersion(),</span>
<span class="fc" id="L207">                      acceptsTransient(),</span>
<span class="fc" id="L208">                      metadata(),</span>
<span class="fc" id="L209">                      nowInSec(),</span>
<span class="fc" id="L210">                      columnFilter(),</span>
<span class="fc" id="L211">                      rowFilter(),</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">                      isRangeContinuation ? limits() : limits().withoutState(),</span>
<span class="fc" id="L213">                      dataRange().forSubRange(range),</span>
<span class="fc" id="L214">                      indexQueryPlan(),</span>
<span class="fc" id="L215">                      isTrackingWarnings());</span>
    }

    public PartitionRangeReadCommand copy()
    {
<span class="nc" id="L220">        return create(isDigestQuery(),</span>
<span class="nc" id="L221">                      digestVersion(),</span>
<span class="nc" id="L222">                      acceptsTransient(),</span>
<span class="nc" id="L223">                      metadata(),</span>
<span class="nc" id="L224">                      nowInSec(),</span>
<span class="nc" id="L225">                      columnFilter(),</span>
<span class="nc" id="L226">                      rowFilter(),</span>
<span class="nc" id="L227">                      limits(),</span>
<span class="nc" id="L228">                      dataRange(),</span>
<span class="nc" id="L229">                      indexQueryPlan(),</span>
<span class="nc" id="L230">                      isTrackingWarnings());</span>
    }

    @Override
    protected PartitionRangeReadCommand copyAsDigestQuery()
    {
<span class="nc" id="L236">        return create(true,</span>
<span class="nc" id="L237">                      digestVersion(),</span>
                      false,
<span class="nc" id="L239">                      metadata(),</span>
<span class="nc" id="L240">                      nowInSec(),</span>
<span class="nc" id="L241">                      columnFilter(),</span>
<span class="nc" id="L242">                      rowFilter(),</span>
<span class="nc" id="L243">                      limits(),</span>
<span class="nc" id="L244">                      dataRange(),</span>
<span class="nc" id="L245">                      indexQueryPlan(),</span>
<span class="nc" id="L246">                      isTrackingWarnings());</span>
    }

    @Override
    protected PartitionRangeReadCommand copyAsTransientQuery()
    {
<span class="nc" id="L252">        return create(false,</span>
                      0,
                      true,
<span class="nc" id="L255">                      metadata(),</span>
<span class="nc" id="L256">                      nowInSec(),</span>
<span class="nc" id="L257">                      columnFilter(),</span>
<span class="nc" id="L258">                      rowFilter(),</span>
<span class="nc" id="L259">                      limits(),</span>
<span class="nc" id="L260">                      dataRange(),</span>
<span class="nc" id="L261">                      indexQueryPlan(),</span>
<span class="nc" id="L262">                      isTrackingWarnings());</span>
    }

    @Override
    public PartitionRangeReadCommand withUpdatedLimit(DataLimits newLimits)
    {
<span class="nc" id="L268">        return create(isDigestQuery(),</span>
<span class="nc" id="L269">                      digestVersion(),</span>
<span class="nc" id="L270">                      acceptsTransient(),</span>
<span class="nc" id="L271">                      metadata(),</span>
<span class="nc" id="L272">                      nowInSec(),</span>
<span class="nc" id="L273">                      columnFilter(),</span>
<span class="nc" id="L274">                      rowFilter(),</span>
                      newLimits,
<span class="nc" id="L276">                      dataRange(),</span>
<span class="nc" id="L277">                      indexQueryPlan(),</span>
<span class="nc" id="L278">                      isTrackingWarnings());</span>
    }

    @Override
    public PartitionRangeReadCommand withUpdatedLimitsAndDataRange(DataLimits newLimits, DataRange newDataRange)
    {
<span class="fc" id="L284">        return create(isDigestQuery(),</span>
<span class="fc" id="L285">                      digestVersion(),</span>
<span class="fc" id="L286">                      acceptsTransient(),</span>
<span class="fc" id="L287">                      metadata(),</span>
<span class="fc" id="L288">                      nowInSec(),</span>
<span class="fc" id="L289">                      columnFilter(),</span>
<span class="fc" id="L290">                      rowFilter(),</span>
                      newLimits,
                      newDataRange,
<span class="fc" id="L293">                      indexQueryPlan(),</span>
<span class="fc" id="L294">                      isTrackingWarnings());</span>
    }

    public long getTimeout(TimeUnit unit)
    {
<span class="fc" id="L299">        return DatabaseDescriptor.getRangeRpcTimeout(unit);</span>
    }

    public boolean isReversed()
    {
<span class="fc" id="L304">        return dataRange.isReversed();</span>
    }

    public PartitionIterator execute(ConsistencyLevel consistency, ClientState state, long queryStartNanoTime) throws RequestExecutionException
    {
<span class="fc" id="L309">        return StorageProxy.getRangeSlice(this, consistency, queryStartNanoTime);</span>
    }

    protected void recordLatency(TableMetrics metric, long latencyNanos)
    {
<span class="fc" id="L314">        metric.rangeLatency.addNano(latencyNanos);</span>
<span class="fc" id="L315">    }</span>

    @VisibleForTesting
    @SuppressWarnings(&quot;resource&quot;)
    public UnfilteredPartitionIterator queryStorage(final ColumnFamilyStore cfs, ReadExecutionController controller)
    {
<span class="fc" id="L321">        ColumnFamilyStore.ViewFragment view = cfs.select(View.selectLive(dataRange().keyRange()));</span>
<span class="fc" id="L322">        Tracing.trace(&quot;Executing seq scan across {} sstables for {}&quot;, view.sstables.size(), dataRange().keyRange().getString(metadata().partitionKeyType));</span>

        // fetch data from current memtable, historical memtables, and SSTables in the correct order.
<span class="fc" id="L325">        InputCollector&lt;UnfilteredPartitionIterator&gt; inputCollector = iteratorsForRange(view, controller);</span>
        try
        {
<span class="fc" id="L328">            SSTableReadsListener readCountUpdater = newReadCountUpdater();</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">            for (Memtable memtable : view.memtables)</span>
            {
                @SuppressWarnings(&quot;resource&quot;) // We close on exception and on closing the result returned by this method
<span class="fc" id="L332">                UnfilteredPartitionIterator iter = memtable.partitionIterator(columnFilter(), dataRange(), readCountUpdater);</span>
<span class="fc" id="L333">                controller.updateMinOldestUnrepairedTombstone(memtable.getMinLocalDeletionTime());</span>
<span class="fc" id="L334">                inputCollector.addMemtableIterator(RTBoundValidator.validate(iter, RTBoundValidator.Stage.MEMTABLE, false));</span>
<span class="fc" id="L335">            }</span>

<span class="fc" id="L337">            int selectedSSTablesCnt = 0;</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">            for (SSTableReader sstable : view.sstables)</span>
            {
<span class="fc" id="L340">                boolean intersects = intersects(sstable);</span>
<span class="fc" id="L341">                boolean hasPartitionLevelDeletions = hasPartitionLevelDeletions(sstable);</span>
<span class="fc" id="L342">                boolean hasRequiredStatics = hasRequiredStatics(sstable);</span>

<span class="pc bpc" id="L344" title="2 of 6 branches missed.">                if (!intersects &amp;&amp; !hasPartitionLevelDeletions &amp;&amp; !hasRequiredStatics)</span>
<span class="nc" id="L345">                    continue;</span>

                @SuppressWarnings(&quot;resource&quot;) // We close on exception and on closing the result returned by this method
<span class="fc" id="L348">                UnfilteredPartitionIterator iter = sstable.partitionIterator(columnFilter(), dataRange(), readCountUpdater);</span>
<span class="fc" id="L349">                inputCollector.addSSTableIterator(sstable, RTBoundValidator.validate(iter, RTBoundValidator.Stage.SSTABLE, false));</span>

<span class="fc bfc" id="L351" title="All 2 branches covered.">                if (!sstable.isRepaired())</span>
<span class="fc" id="L352">                    controller.updateMinOldestUnrepairedTombstone(sstable.getMinLocalDeletionTime());</span>

<span class="fc" id="L354">                selectedSSTablesCnt++;</span>
<span class="fc" id="L355">            }</span>

<span class="fc" id="L357">            final int finalSelectedSSTables = selectedSSTablesCnt;</span>

            // iterators can be empty for offline tools
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">            if (inputCollector.isEmpty())</span>
<span class="nc" id="L361">                return EmptyIterators.unfilteredPartition(metadata());</span>

<span class="fc" id="L363">            List&lt;UnfilteredPartitionIterator&gt; finalizedIterators = inputCollector.finalizeIterators(cfs, nowInSec(), controller.oldestUnrepairedTombstone());</span>
<span class="fc" id="L364">            UnfilteredPartitionIterator merged = UnfilteredPartitionIterators.mergeLazily(finalizedIterators);</span>
<span class="fc" id="L365">            return checkCacheFilter(Transformation.apply(merged, new Transformation&lt;UnfilteredRowIterator&gt;()</span>
<span class="fc" id="L366">            {</span>
                @Override
                protected void onClose()
                {
<span class="fc" id="L370">                    super.onClose();</span>
<span class="fc" id="L371">                    cfs.metric.updateSSTableIteratedInRangeRead(finalSelectedSSTables);</span>
<span class="fc" id="L372">                }</span>
            }), cfs);
        }
<span class="nc" id="L375">        catch (RuntimeException | Error e)</span>
        {
            try
            {
<span class="nc" id="L379">                inputCollector.close();</span>
            }
<span class="nc" id="L381">            catch (Exception e1)</span>
            {
<span class="nc" id="L383">                e.addSuppressed(e1);</span>
<span class="nc" id="L384">            }</span>
<span class="nc" id="L385">            throw e;</span>
        }
    }

    @Override
    protected boolean intersects(SSTableReader sstable)
    {
<span class="fc" id="L392">        return requestedSlices.intersects(sstable.getSSTableMetadata().coveredClustering);</span>
    }

    /**
     * Creates a new {@code SSTableReadsListener} to update the SSTables read counts.
     * @return a new {@code SSTableReadsListener} to update the SSTables read counts.
     */
    private static SSTableReadsListener newReadCountUpdater()
    {
<span class="fc" id="L401">        return new SSTableReadsListener()</span>
<span class="fc" id="L402">                {</span>
                    @Override
                    public void onScanningStarted(SSTableReader sstable)
                    {
<span class="fc" id="L406">                        sstable.incrementReadCount();</span>
<span class="fc" id="L407">                    }</span>
                };
    }

    private UnfilteredPartitionIterator checkCacheFilter(UnfilteredPartitionIterator iter, final ColumnFamilyStore cfs)
    {
<span class="fc" id="L413">        class CacheFilter extends Transformation&lt;BaseRowIterator&lt;?&gt;&gt;</span>
        {
            @Override
            public BaseRowIterator&lt;?&gt; applyToPartition(BaseRowIterator&lt;?&gt; iter)
            {
                // Note that we rely on the fact that until we actually advance 'iter', no really costly operation is actually done
                // (except for reading the partition key from the index file) due to the call to mergeLazily in queryStorage.
<span class="fc" id="L420">                DecoratedKey dk = iter.partitionKey();</span>

                // Check if this partition is in the rowCache and if it is, if  it covers our filter
<span class="fc" id="L423">                CachedPartition cached = cfs.getRawCachedPartition(dk);</span>
<span class="fc" id="L424">                ClusteringIndexFilter filter = dataRange().clusteringIndexFilter(dk);</span>

<span class="pc bpc" id="L426" title="3 of 4 branches missed.">                if (cached != null &amp;&amp; cfs.isFilterFullyCoveredBy(filter,</span>
<span class="nc" id="L427">                                                                 limits(),</span>
                                                                 cached,
<span class="nc" id="L429">                                                                 nowInSec(),</span>
<span class="nc" id="L430">                                                                 iter.metadata().enforceStrictLiveness()))</span>
                {
                    // We won't use 'iter' so close it now.
<span class="nc" id="L433">                    iter.close();</span>

<span class="nc" id="L435">                    return filter.getUnfilteredRowIterator(columnFilter(), cached);</span>
                }

<span class="fc" id="L438">                return iter;</span>
            }
        }
<span class="fc" id="L441">        return Transformation.apply(iter, new CacheFilter());</span>
    }

    @Override
    public Verb verb()
    {
<span class="fc" id="L447">        return Verb.RANGE_REQ;</span>
    }

    protected void appendCQLWhereClause(StringBuilder sb)
    {
<span class="fc" id="L452">        String filterString = dataRange().toCQLString(metadata(), rowFilter());</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">        if (!filterString.isEmpty())</span>
<span class="fc" id="L454">            sb.append(&quot; WHERE &quot;).append(filterString);</span>
<span class="fc" id="L455">    }</span>

    @Override
    public String loggableTokens()
    {
<span class="nc bnc" id="L460" title="All 2 branches missed.">        return &quot;token range: &quot; + (dataRange.keyRange.inclusiveLeft() ? '[' : '(') +</span>
<span class="nc" id="L461">               dataRange.keyRange.left.getToken().toString() + &quot;, &quot; +</span>
<span class="nc" id="L462">               dataRange.keyRange.right.getToken().toString() +</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">               (dataRange.keyRange.inclusiveRight() ? ']' : ')');</span>
    }

    /**
     * Allow to post-process the result of the query after it has been reconciled on the coordinator
     * but before it is passed to the CQL layer to return the ResultSet.
     *
     * See CASSANDRA-8717 for why this exists.
     */
    public PartitionIterator postReconciliationProcessing(PartitionIterator result)
    {
<span class="fc" id="L474">        Index.QueryPlan queryPlan = indexQueryPlan();</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">        return queryPlan == null ? result : queryPlan.postProcessor().apply(result);</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L481">        return String.format(&quot;Read(%s columns=%s rowfilter=%s limits=%s %s)&quot;,</span>
<span class="nc" id="L482">                             metadata().toString(),</span>
<span class="nc" id="L483">                             columnFilter(),</span>
<span class="nc" id="L484">                             rowFilter(),</span>
<span class="nc" id="L485">                             limits(),</span>
<span class="nc" id="L486">                             dataRange().toString(metadata()));</span>
    }

    protected void serializeSelection(DataOutputPlus out, int version) throws IOException
    {
<span class="fc" id="L491">        DataRange.serializer.serialize(dataRange(), out, version, metadata());</span>
<span class="fc" id="L492">    }</span>

    protected long selectionSerializedSize(int version)
    {
<span class="fc" id="L496">        return DataRange.serializer.serializedSize(dataRange(), version, metadata());</span>
    }

    /*
     * We are currently using PartitionRangeReadCommand for most index queries, even if they are explicitly restricted
     * to a single partition key. Return true if that is the case.
     *
     * See CASSANDRA-11617 and CASSANDRA-11872 for details.
     */
    public boolean isLimitedToOnePartition()
    {
<span class="fc bfc" id="L507" title="All 2 branches covered.">        return dataRange.keyRange instanceof Bounds</span>
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">            &amp;&amp; dataRange.startKey().kind() == PartitionPosition.Kind.ROW_KEY</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">            &amp;&amp; dataRange.startKey().equals(dataRange.stopKey());</span>
    }

    public boolean isRangeRequest()
    {
<span class="fc" id="L514">        return true;</span>
    }

    private static class Deserializer extends SelectionDeserializer
    {
        public ReadCommand deserialize(DataInputPlus in,
                                       int version,
                                       boolean isDigest,
                                       int digestVersion,
                                       boolean acceptsTransient,
                                       TableMetadata metadata,
                                       long nowInSec,
                                       ColumnFilter columnFilter,
                                       RowFilter rowFilter,
                                       DataLimits limits,
                                       Index.QueryPlan indexQueryPlan)
        throws IOException
        {
<span class="fc" id="L532">            DataRange range = DataRange.serializer.deserialize(in, version, metadata);</span>
<span class="fc" id="L533">            return PartitionRangeReadCommand.create(isDigest, digestVersion, acceptsTransient, metadata, nowInSec, columnFilter, rowFilter, limits, range, indexQueryPlan, false);</span>
        }
    }

    public static class VirtualTablePartitionRangeReadCommand extends PartitionRangeReadCommand
    {
        private VirtualTablePartitionRangeReadCommand(boolean isDigest,
                                                      int digestVersion,
                                                      boolean acceptsTransient,
                                                      TableMetadata metadata,
                                                      long nowInSec,
                                                      ColumnFilter columnFilter,
                                                      RowFilter rowFilter,
                                                      DataLimits limits,
                                                      DataRange dataRange,
                                                      Index.QueryPlan indexQueryPlan,
                                                      boolean trackWarnings)
        {
<span class="fc" id="L551">            super(isDigest, digestVersion, acceptsTransient, metadata, nowInSec, columnFilter, rowFilter, limits, dataRange, indexQueryPlan, trackWarnings);</span>
<span class="fc" id="L552">        }</span>

        @Override
        public PartitionIterator execute(ConsistencyLevel consistency, ClientState state, long queryStartNanoTime) throws RequestExecutionException
        {
<span class="fc" id="L557">            return executeInternal(executionController());</span>
        }

        @Override
        @SuppressWarnings(&quot;resource&quot;)
        public UnfilteredPartitionIterator executeLocally(ReadExecutionController executionController)
        {
<span class="fc" id="L564">            VirtualTable view = VirtualKeyspaceRegistry.instance.getTableNullable(metadata().id);</span>
<span class="fc" id="L565">            UnfilteredPartitionIterator resultIterator = view.select(dataRange, columnFilter());</span>
<span class="fc" id="L566">            return limits().filter(rowFilter().filter(resultIterator, nowInSec()), nowInSec(), selectsFullPartition());</span>
        }

        @Override
        public ReadExecutionController executionController()
        {
<span class="fc" id="L572">            return ReadExecutionController.empty();</span>
        }

        @Override
        public ReadExecutionController executionController(boolean trackRepairedStatus)
        {
<span class="nc" id="L578">            return executionController();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>