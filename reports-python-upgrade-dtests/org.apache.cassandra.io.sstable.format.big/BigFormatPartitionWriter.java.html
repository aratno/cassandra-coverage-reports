<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BigFormatPartitionWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.io.sstable.format.big</a> &gt; <span class="el_source">BigFormatPartitionWriter.java</span></div><h1>BigFormatPartitionWriter.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.io.sstable.format.big;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.primitives.Ints;

import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.SerializationHeader;
import org.apache.cassandra.db.TypeSizes;
import org.apache.cassandra.db.rows.Unfiltered;
import org.apache.cassandra.io.ISerializer;
import org.apache.cassandra.io.sstable.IndexInfo;
import org.apache.cassandra.io.sstable.format.SortedTablePartitionWriter;
import org.apache.cassandra.io.sstable.format.Version;
import org.apache.cassandra.io.util.DataOutputBuffer;
import org.apache.cassandra.io.util.SequentialWriter;

/**
 * Column index builder used by {@link org.apache.cassandra.io.sstable.format.big.BigTableWriter}.
 * For index entries that exceed {@link org.apache.cassandra.config.Config#column_index_cache_size},
 * this uses the serialization logic as in {@link RowIndexEntry}.
 */
<span class="fc" id="L46">public class BigFormatPartitionWriter extends SortedTablePartitionWriter</span>
{
    @VisibleForTesting
    public static final int DEFAULT_GRANULARITY = 64 * 1024;

    // used, if the row-index-entry reaches config column_index_cache_size
    private DataOutputBuffer buffer;
    // used to track the size of the serialized size of row-index-entry (unused for buffer)
    private int indexSamplesSerializedSize;
    // used, until the row-index-entry reaches config column_index_cache_size
<span class="fc" id="L56">    private final List&lt;IndexInfo&gt; indexSamples = new ArrayList&lt;&gt;();</span>

    private DataOutputBuffer reusableBuffer;

    private int columnIndexCount;
    private int[] indexOffsets;

    private final ISerializer&lt;IndexInfo&gt; idxSerializer;

    private final int cacheSizeThreshold;
    private final int indexSize;

    BigFormatPartitionWriter(SerializationHeader header,
                             SequentialWriter writer,
                             Version version,
                             ISerializer&lt;IndexInfo&gt; indexInfoSerializer)
    {
<span class="fc" id="L73">        this(header, writer, version, indexInfoSerializer, DatabaseDescriptor.getColumnIndexCacheSize(), DatabaseDescriptor.getColumnIndexSize(DEFAULT_GRANULARITY));</span>
<span class="fc" id="L74">    }</span>

    BigFormatPartitionWriter(SerializationHeader header,
                             SequentialWriter writer,
                             Version version,
                             ISerializer&lt;IndexInfo&gt; indexInfoSerializer,
                             int cacheSizeThreshold,
                             int indexSize)
    {
<span class="fc" id="L83">        super(header, writer, version);</span>
<span class="fc" id="L84">        this.idxSerializer = indexInfoSerializer;</span>
<span class="fc" id="L85">        this.cacheSizeThreshold = cacheSizeThreshold;</span>
<span class="fc" id="L86">        this.indexSize = indexSize;</span>
<span class="fc" id="L87">    }</span>

    public void reset()
    {
<span class="fc" id="L91">        super.reset();</span>
<span class="fc" id="L92">        this.columnIndexCount = 0;</span>
<span class="fc" id="L93">        this.indexSamplesSerializedSize = 0;</span>
<span class="fc" id="L94">        this.indexSamples.clear();</span>

<span class="pc bpc" id="L96" title="1 of 2 branches missed.">        if (this.buffer != null)</span>
<span class="nc" id="L97">            this.reusableBuffer = this.buffer;</span>
<span class="fc" id="L98">        this.buffer = null;</span>
<span class="fc" id="L99">    }</span>

    public int getColumnIndexCount()
    {
<span class="fc" id="L103">        return columnIndexCount;</span>
    }

    public ByteBuffer buffer()
    {
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">        return buffer != null ? buffer.buffer() : null;</span>
    }

    public List&lt;IndexInfo&gt; indexSamples()
    {
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        if (indexSamplesSerializedSize + columnIndexCount * TypeSizes.sizeof(0) &lt;= cacheSizeThreshold)</span>
        {
<span class="fc" id="L115">            return indexSamples;</span>
        }

<span class="nc" id="L118">        return null;</span>
    }

    public int[] offsets()
    {
<span class="fc bfc" id="L123" title="All 2 branches covered.">        return indexOffsets != null</span>
<span class="fc" id="L124">               ? Arrays.copyOf(indexOffsets, columnIndexCount)</span>
<span class="fc" id="L125">               : null;</span>
    }

    private void addIndexBlock() throws IOException
    {
<span class="fc" id="L130">        IndexInfo cIndexInfo = new IndexInfo(firstClustering,</span>
                                             lastClustering,
                                             startPosition,
<span class="fc" id="L133">                                             currentPosition() - startPosition,</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">                                             !openMarker.isLive() ? openMarker : null);</span>

        // indexOffsets is used for both shallow (ShallowIndexedEntry) and non-shallow IndexedEntry.
        // For shallow ones, we need it to serialize the offsts in finish().
        // For non-shallow ones, the offsts are passed into IndexedEntry, so we don't have to
        // calculate the offsets again.

        // indexOffsets contains the offsets of the serialized IndexInfo objects.
        // I.e. indexOffsets[0] is always 0 so we don't have to deal with a special handling
        // for index #0 and always subtracting 1 for the index (which could be error-prone).
<span class="fc bfc" id="L144" title="All 2 branches covered.">        if (indexOffsets == null)</span>
<span class="fc" id="L145">            indexOffsets = new int[10];</span>
        else
        {
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">            if (columnIndexCount &gt;= indexOffsets.length)</span>
<span class="nc" id="L149">                indexOffsets = Arrays.copyOf(indexOffsets, indexOffsets.length + 10);</span>

            //the 0th element is always 0
<span class="fc bfc" id="L152" title="All 2 branches covered.">            if (columnIndexCount == 0)</span>
            {
<span class="fc" id="L154">                indexOffsets[columnIndexCount] = 0;</span>
            }
            else
            {
<span class="fc" id="L158">                indexOffsets[columnIndexCount] =</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">                buffer != null</span>
<span class="nc" id="L160">                ? Ints.checkedCast(buffer.position())</span>
<span class="fc" id="L161">                : indexSamplesSerializedSize;</span>
            }
        }
<span class="fc" id="L164">        columnIndexCount++;</span>

        // First, we collect the IndexInfo objects until we reach Config.column_index_cache_size in an ArrayList.
        // When column_index_cache_size is reached, we switch to byte-buffer mode.
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        if (buffer == null)</span>
        {
<span class="fc" id="L170">            indexSamplesSerializedSize += idxSerializer.serializedSize(cIndexInfo);</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">            if (indexSamplesSerializedSize + columnIndexCount * TypeSizes.sizeof(0) &gt; cacheSizeThreshold)</span>
            {
<span class="nc" id="L173">                buffer = reuseOrAllocateBuffer();</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">                for (IndexInfo indexSample : indexSamples)</span>
                {
<span class="nc" id="L176">                    idxSerializer.serialize(indexSample, buffer);</span>
<span class="nc" id="L177">                }</span>
            }
            else
            {
<span class="fc" id="L181">                indexSamples.add(cIndexInfo);</span>
            }
        }
        // don't put an else here since buffer may be allocated in preceding if block
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">        if (buffer != null)</span>
        {
<span class="nc" id="L187">            idxSerializer.serialize(cIndexInfo, buffer);</span>
        }

<span class="fc" id="L190">        firstClustering = null;</span>
<span class="fc" id="L191">    }</span>

    private DataOutputBuffer reuseOrAllocateBuffer()
    {
        // Check whether a reusable DataOutputBuffer already exists for this
        // ColumnIndex instance and return it.
<span class="nc bnc" id="L197" title="All 2 branches missed.">        if (reusableBuffer != null)</span>
        {
<span class="nc" id="L199">            DataOutputBuffer buffer = reusableBuffer;</span>
<span class="nc" id="L200">            buffer.clear();</span>
<span class="nc" id="L201">            return buffer;</span>
        }
        // don't use the standard RECYCLER as that only recycles up to 1MB and requires proper cleanup
<span class="nc" id="L204">        return new DataOutputBuffer(cacheSizeThreshold * 2);</span>
    }

    @Override
    public void addUnfiltered(Unfiltered unfiltered) throws IOException
    {
<span class="fc" id="L210">        super.addUnfiltered(unfiltered);</span>

        // if we hit the column index size that we have to index after, go ahead and index it.
<span class="fc bfc" id="L213" title="All 2 branches covered.">        if (currentPosition() - startPosition &gt;= indexSize)</span>
<span class="fc" id="L214">            addIndexBlock();</span>
<span class="fc" id="L215">    }</span>

    @Override
    public long finish() throws IOException
    {
<span class="fc" id="L220">        long endPosition = super.finish();</span>

        // It's possible we add no rows, just a top level deletion
<span class="fc bfc" id="L223" title="All 2 branches covered.">        if (written == 0)</span>
<span class="fc" id="L224">            return endPosition;</span>

        // the last column may have fallen on an index boundary already.  if not, index it explicitly.
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">        if (firstClustering != null)</span>
<span class="fc" id="L228">            addIndexBlock();</span>

        // If we serialize the IndexInfo objects directly in the code above into 'buffer',
        // we have to write the offsts to these here. The offsets have already been collected
        // in indexOffsets[]. buffer is != null, if it exceeds Config.column_index_cache_size.
        // In the other case, when buffer==null, the offsets are serialized in RowIndexEntry.IndexedEntry.serialize().
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">        if (buffer != null)</span>
        {
<span class="nc bnc" id="L236" title="All 2 branches missed.">            for (int i = 0; i &lt; columnIndexCount; i++)</span>
<span class="nc" id="L237">                buffer.writeInt(indexOffsets[i]);</span>
        }

        // we should always have at least one computed index block, but we only write it out if there is more than that.
<span class="pc bpc" id="L241" title="2 of 4 branches missed.">        assert columnIndexCount &gt; 0 &amp;&amp; getHeaderLength() &gt;= 0;</span>

<span class="fc" id="L243">        return endPosition;</span>
    }

    public int indexInfoSerializedSize()
    {
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        return buffer != null</span>
<span class="nc" id="L249">               ? buffer.buffer().limit()</span>
<span class="fc" id="L250">               : indexSamplesSerializedSize + columnIndexCount * TypeSizes.sizeof(0);</span>
    }

    @Override
    public void close()
    {
        // no-op
<span class="fc" id="L257">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>