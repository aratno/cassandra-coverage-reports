<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SSTableScanner.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.io.sstable.format</a> &gt; <span class="el_source">SSTableScanner.java</span></div><h1>SSTableScanner.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.io.sstable.format;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

import com.google.common.collect.ImmutableSet;

import org.apache.cassandra.db.DataRange;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.PartitionPosition;
import org.apache.cassandra.db.filter.ColumnFilter;
import org.apache.cassandra.db.rows.LazilyInitializedUnfilteredRowIterator;
import org.apache.cassandra.db.rows.UnfilteredRowIterator;
import org.apache.cassandra.dht.AbstractBounds;
import org.apache.cassandra.dht.AbstractBounds.Boundary;
import org.apache.cassandra.dht.Bounds;
import org.apache.cassandra.dht.Range;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.io.sstable.AbstractRowIndexEntry;
import org.apache.cassandra.io.sstable.CorruptSSTableException;
import org.apache.cassandra.io.sstable.ISSTableScanner;
import org.apache.cassandra.io.sstable.SSTableReadsListener;
import org.apache.cassandra.io.util.RandomAccessReader;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.utils.AbstractIterator;

import static org.apache.cassandra.dht.AbstractBounds.isEmpty;
import static org.apache.cassandra.dht.AbstractBounds.maxLeft;
import static org.apache.cassandra.dht.AbstractBounds.minRight;

<span class="fc" id="L53">public abstract class SSTableScanner&lt;S extends SSTableReader,</span>
                                     E extends AbstractRowIndexEntry,
                                     I extends SSTableScanner&lt;S, E, I&gt;.BaseKeyScanningIterator&gt;
implements ISSTableScanner
{
<span class="fc" id="L58">    protected final AtomicBoolean isClosed = new AtomicBoolean(false);</span>
    protected final RandomAccessReader dfile;
    protected final S sstable;

    protected final Iterator&lt;AbstractBounds&lt;PartitionPosition&gt;&gt; rangeIterator;

    protected final ColumnFilter columns;
    protected final DataRange dataRange;
    private final SSTableReadsListener listener;

    protected I iterator;

<span class="fc" id="L70">    protected long startScan = -1;</span>
<span class="fc" id="L71">    protected long bytesScanned = 0;</span>

    protected SSTableScanner(S sstable,
                             ColumnFilter columns,
                             DataRange dataRange,
                             Iterator&lt;AbstractBounds&lt;PartitionPosition&gt;&gt; rangeIterator,
                             SSTableReadsListener listener)
<span class="fc" id="L78">    {</span>
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">        assert sstable != null;</span>

<span class="fc" id="L81">        this.dfile = sstable.openDataReader();</span>
<span class="fc" id="L82">        this.sstable = sstable;</span>
<span class="fc" id="L83">        this.columns = columns;</span>
<span class="fc" id="L84">        this.dataRange = dataRange;</span>
<span class="fc" id="L85">        this.rangeIterator = rangeIterator;</span>
<span class="fc" id="L86">        this.listener = listener;</span>
<span class="fc" id="L87">    }</span>

    protected static List&lt;AbstractBounds&lt;PartitionPosition&gt;&gt; makeBounds(SSTableReader sstable, Collection&lt;Range&lt;Token&gt;&gt; tokenRanges)
    {
<span class="fc" id="L91">        List&lt;AbstractBounds&lt;PartitionPosition&gt;&gt; boundsList = new ArrayList&lt;&gt;(tokenRanges.size());</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">        for (Range&lt;Token&gt; range : Range.normalize(tokenRanges))</span>
<span class="fc" id="L93">            addRange(sstable, Range.makeRowRange(range), boundsList);</span>
<span class="fc" id="L94">        return boundsList;</span>
    }

    protected static List&lt;AbstractBounds&lt;PartitionPosition&gt;&gt; makeBounds(SSTableReader sstable, DataRange dataRange)
    {
<span class="fc" id="L99">        List&lt;AbstractBounds&lt;PartitionPosition&gt;&gt; boundsList = new ArrayList&lt;&gt;(2);</span>
<span class="fc" id="L100">        addRange(sstable, dataRange.keyRange(), boundsList);</span>
<span class="fc" id="L101">        return boundsList;</span>
    }

    protected static AbstractBounds&lt;PartitionPosition&gt; fullRange(SSTableReader sstable)
    {
<span class="fc" id="L106">        return new Bounds&lt;&gt;(sstable.getFirst(), sstable.getLast());</span>
    }

    private static void addRange(SSTableReader sstable, AbstractBounds&lt;PartitionPosition&gt; requested, List&lt;AbstractBounds&lt;PartitionPosition&gt;&gt; boundsList)
    {
<span class="fc bfc" id="L111" title="All 4 branches covered.">        if (requested instanceof Range &amp;&amp; ((Range&lt;?&gt;) requested).isWrapAround())</span>
        {
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">            if (requested.right.compareTo(sstable.getFirst()) &gt;= 0)</span>
            {
                // since we wrap, we must contain the whole sstable prior to stopKey()
<span class="nc" id="L116">                Boundary&lt;PartitionPosition&gt; left = new Boundary&lt;&gt;(sstable.getFirst(), true);</span>
                Boundary&lt;PartitionPosition&gt; right;
<span class="nc" id="L118">                right = requested.rightBoundary();</span>
<span class="nc" id="L119">                right = minRight(right, sstable.getLast(), true);</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">                if (!isEmpty(left, right))</span>
<span class="nc" id="L121">                    boundsList.add(AbstractBounds.bounds(left, right));</span>
            }
<span class="fc bfc" id="L123" title="All 2 branches covered.">            if (requested.left.compareTo(sstable.getLast()) &lt;= 0)</span>
            {
                // since we wrap, we must contain the whole sstable after dataRange.startKey()
<span class="fc" id="L126">                Boundary&lt;PartitionPosition&gt; right = new Boundary&lt;&gt;(sstable.getLast(), true);</span>
                Boundary&lt;PartitionPosition&gt; left;
<span class="fc" id="L128">                left = requested.leftBoundary();</span>
<span class="fc" id="L129">                left = maxLeft(left, sstable.getFirst(), true);</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">                if (!isEmpty(left, right))</span>
<span class="fc" id="L131">                    boundsList.add(AbstractBounds.bounds(left, right));</span>
<span class="fc" id="L132">            }</span>
        }
        else
        {
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">            assert !AbstractBounds.strictlyWrapsAround(requested.left, requested.right);</span>
            Boundary&lt;PartitionPosition&gt; left, right;
<span class="fc" id="L138">            left = requested.leftBoundary();</span>
<span class="fc" id="L139">            right = requested.rightBoundary();</span>
<span class="fc" id="L140">            left = maxLeft(left, sstable.getFirst(), true);</span>
            // apparently isWrapAround() doesn't count Bounds that extend to the limit (min) as wrapping
<span class="fc bfc" id="L142" title="All 2 branches covered.">            right = requested.right.isMinimum() ? new Boundary&lt;&gt;(sstable.getLast(), true)</span>
<span class="fc" id="L143">                                                : minRight(right, sstable.getLast(), true);</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">            if (!isEmpty(left, right))</span>
<span class="fc" id="L145">                boundsList.add(AbstractBounds.bounds(left, right));</span>
        }
<span class="fc" id="L147">    }</span>

    public void close()
    {
        try
        {
<span class="fc bfc" id="L153" title="All 2 branches covered.">            if (isClosed.compareAndSet(false, true))</span>
            {
<span class="fc" id="L155">                markScanned();</span>
<span class="fc" id="L156">                doClose();</span>
            }
        }
<span class="nc" id="L159">        catch (IOException e)</span>
        {
<span class="nc" id="L161">            sstable.markSuspect();</span>
<span class="nc" id="L162">            throw new CorruptSSTableException(e, sstable.getFilename());</span>
<span class="fc" id="L163">        }</span>
<span class="fc" id="L164">    }</span>

    protected abstract void doClose() throws IOException;

    @Override
    public long getLengthInBytes()
    {
<span class="fc" id="L171">        return sstable.uncompressedLength();</span>
    }


    public long getCompressedLengthInBytes()
    {
<span class="fc" id="L177">        return sstable.onDiskLength();</span>
    }

    @Override
    public long getCurrentPosition()
    {
<span class="fc" id="L183">        return dfile.getFilePointer();</span>
    }

    public long getBytesScanned()
    {
<span class="fc" id="L188">        return bytesScanned;</span>
    }

    @Override
    public Set&lt;SSTableReader&gt; getBackingSSTables()
    {
<span class="fc" id="L194">        return ImmutableSet.of(sstable);</span>
    }

    public TableMetadata metadata()
    {
<span class="fc" id="L199">        return sstable.metadata();</span>
    }

    public boolean hasNext()
    {
<span class="fc bfc" id="L204" title="All 2 branches covered.">        if (iterator == null)</span>
<span class="fc" id="L205">            iterator = createIterator();</span>
<span class="fc" id="L206">        return iterator.hasNext();</span>
    }

    public UnfilteredRowIterator next()
    {
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">        if (iterator == null)</span>
<span class="nc" id="L212">            iterator = createIterator();</span>
<span class="fc" id="L213">        return iterator.next();</span>
    }

    public void remove()
    {
<span class="nc" id="L218">        throw new UnsupportedOperationException();</span>
    }

    private I createIterator()
    {
<span class="fc" id="L223">        this.listener.onScanningStarted(sstable);</span>
<span class="fc" id="L224">        return doCreateIterator();</span>
    }

    protected abstract I doCreateIterator();

    private void markScanned()
    {
<span class="fc bfc" id="L231" title="All 2 branches covered.">        if (startScan != -1)</span>
        {
<span class="fc" id="L233">            bytesScanned += dfile.getFilePointer() - startScan;</span>
<span class="fc" id="L234">            startScan = -1;</span>
        }
<span class="fc" id="L236">    }</span>

    @Override
    public String toString()
    {
<span class="nc" id="L241">        return String.format(&quot;%s(dfile=%s sstable=%s)&quot;, getClass().getSimpleName(), dfile, sstable);</span>
    }

<span class="fc" id="L244">    public abstract class BaseKeyScanningIterator extends AbstractIterator&lt;UnfilteredRowIterator&gt;</span>
    {
        protected DecoratedKey currentKey;
        protected E currentEntry;
        private LazilyInitializedUnfilteredRowIterator currentRowIterator;

        protected abstract boolean prepareToIterateRow() throws IOException;

        protected abstract UnfilteredRowIterator getRowIterator(E indexEntry, DecoratedKey key) throws IOException;

        protected UnfilteredRowIterator computeNext()
        {
<span class="pc bpc" id="L256" title="1 of 6 branches missed.">            if (currentRowIterator != null &amp;&amp; currentRowIterator.isOpen() &amp;&amp; currentRowIterator.hasNext())</span>
<span class="nc" id="L257">                throw new IllegalStateException(&quot;The UnfilteredRowIterator returned by the last call to next() was initialized: &quot; +</span>
                                                &quot;it must be closed before calling hasNext() or next() again.&quot;);

            try
            {
<span class="fc" id="L262">                markScanned();</span>

<span class="fc bfc" id="L264" title="All 2 branches covered.">                if (!prepareToIterateRow())</span>
<span class="fc" id="L265">                    return endOfData();</span>

                /*
                 * For a given partition key, we want to avoid hitting the data file unless we're explicitly asked.
                 * This is important for PartitionRangeReadCommand#checkCacheFilter.
                 */
<span class="fc" id="L271">                return currentRowIterator = new LazilyInitializedUnfilteredRowIterator(currentKey)</span>
<span class="fc" id="L272">                {</span>
                    // Store currentEntry reference during object instantiation as later (during initialize) the
                    // reference may point to a different entry.
<span class="fc" id="L275">                    private final E rowIndexEntry = currentEntry;</span>

                    protected UnfilteredRowIterator initializeIterator()
                    {
                        try
                        {
<span class="fc" id="L281">                            startScan = rowIndexEntry.position;</span>
<span class="fc" id="L282">                            return getRowIterator(rowIndexEntry, partitionKey());</span>
                        }
<span class="nc" id="L284">                        catch (CorruptSSTableException | IOException e)</span>
                        {
<span class="nc" id="L286">                            sstable.markSuspect();</span>
<span class="nc" id="L287">                            throw new CorruptSSTableException(e, sstable.getFilename());</span>
                        }
                    }
                };
            }
<span class="nc" id="L292">            catch (CorruptSSTableException | IOException e)</span>
            {
<span class="nc" id="L294">                sstable.markSuspect();</span>
<span class="nc" id="L295">                throw new CorruptSSTableException(e, sstable.getFilename());</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>