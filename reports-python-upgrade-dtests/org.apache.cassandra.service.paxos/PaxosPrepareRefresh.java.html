<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PaxosPrepareRefresh.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.service.paxos</a> &gt; <span class="el_source">PaxosPrepareRefresh.java</span></div><h1>PaxosPrepareRefresh.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.service.paxos;

import java.io.IOException;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.exceptions.RequestFailureReason;
import org.apache.cassandra.exceptions.WriteTimeoutException;
import org.apache.cassandra.io.IVersionedSerializer;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.net.IVerbHandler;
import org.apache.cassandra.net.Message;
import org.apache.cassandra.net.MessagingService;
import org.apache.cassandra.net.RequestCallbackWithFailure;
import org.apache.cassandra.service.paxos.Commit.Agreed;
import org.apache.cassandra.service.paxos.Commit.Committed;
import org.apache.cassandra.tracing.Tracing;

import static org.apache.cassandra.exceptions.RequestFailureReason.TIMEOUT;
import static org.apache.cassandra.exceptions.RequestFailureReason.UNKNOWN;
import static org.apache.cassandra.net.Verb.PAXOS2_PREPARE_REFRESH_REQ;
import static org.apache.cassandra.service.paxos.Commit.isAfter;
import static org.apache.cassandra.service.paxos.PaxosRequestCallback.shouldExecuteOnSelf;
import static org.apache.cassandra.utils.FBUtilities.getBroadcastAddressAndPort;
import static org.apache.cassandra.utils.NullableSerializer.deserializeNullable;
import static org.apache.cassandra.utils.NullableSerializer.serializeNullable;
import static org.apache.cassandra.utils.NullableSerializer.serializedSizeNullable;

/**
 * Nodes that have promised in response to our prepare, may be missing the latestCommit, meaning we cannot be sure the
 * prior round has been committed to the necessary quorum of participants, so that it will be visible to future quorums.
 *
 * To resolve this problem, we submit the latest commit we have seen, and wait for confirmation before continuing
 * (verifying that we are still promised in the process).
 */
public class PaxosPrepareRefresh implements RequestCallbackWithFailure&lt;PaxosPrepareRefresh.Response&gt;
{
<span class="nc" id="L60">    private static final Logger logger = LoggerFactory.getLogger(PaxosPrepareRefresh.class);</span>

<span class="nc" id="L62">    public static final RequestHandler requestHandler = new RequestHandler();</span>
<span class="nc" id="L63">    public static final RequestSerializer requestSerializer = new RequestSerializer();</span>
<span class="nc" id="L64">    public static final ResponseSerializer responseSerializer = new ResponseSerializer();</span>

    interface Callbacks
    {
        void onRefreshFailure(InetAddressAndPort from, RequestFailureReason reason);
        void onRefreshSuccess(Ballot isSupersededBy, InetAddressAndPort from);
    }

    private final Message&lt;Request&gt; send;
    private final Callbacks callbacks;

    public PaxosPrepareRefresh(Ballot prepared, Paxos.Participants participants, Committed latestCommitted, Callbacks callbacks)
<span class="nc" id="L76">    {</span>
<span class="nc" id="L77">        this.callbacks = callbacks;</span>
<span class="nc" id="L78">        this.send = Message.out(PAXOS2_PREPARE_REFRESH_REQ, new Request(prepared, latestCommitted));</span>
<span class="nc" id="L79">    }</span>

    void refresh(List&lt;InetAddressAndPort&gt; refresh)
    {
<span class="nc" id="L83">        boolean executeOnSelf = false;</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">        for (int i = 0, size = refresh.size(); i &lt; size ; ++i)</span>
        {
<span class="nc" id="L86">            InetAddressAndPort destination = refresh.get(i);</span>

<span class="nc bnc" id="L88" title="All 2 branches missed.">            if (logger.isTraceEnabled())</span>
<span class="nc" id="L89">                logger.trace(&quot;Refresh {} and Confirm {} to {}&quot;, send.payload.missingCommit, Ballot.toString(send.payload.promised, &quot;Promise&quot;), destination);</span>

<span class="nc bnc" id="L91" title="All 2 branches missed.">            if (Tracing.isTracing())</span>
<span class="nc" id="L92">                Tracing.trace(&quot;Refresh {} and Confirm {} to {}&quot;, send.payload.missingCommit.ballot, send.payload.promised, destination);</span>

<span class="nc bnc" id="L94" title="All 2 branches missed.">            if (shouldExecuteOnSelf(destination))</span>
<span class="nc" id="L95">                executeOnSelf = true;</span>
            else
<span class="nc" id="L97">                MessagingService.instance().sendWithCallback(send, destination, this);</span>
        }

<span class="nc bnc" id="L100" title="All 2 branches missed.">        if (executeOnSelf)</span>
<span class="nc" id="L101">            PAXOS2_PREPARE_REFRESH_REQ.stage.execute(this::executeOnSelf);</span>
<span class="nc" id="L102">    }</span>

    @Override
    public void onFailure(InetAddressAndPort from, RequestFailureReason reason)
    {
<span class="nc" id="L107">        callbacks.onRefreshFailure(from, reason);</span>
<span class="nc" id="L108">    }</span>

    @Override
    public void onResponse(Message&lt;Response&gt; message)
    {
<span class="nc" id="L113">        onResponse(message.payload, message.from());</span>
<span class="nc" id="L114">    }</span>

    private void executeOnSelf()
    {
        Response response;
        try
        {
<span class="nc" id="L121">            response = RequestHandler.execute(send.payload, getBroadcastAddressAndPort());</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">            if (response == null)</span>
<span class="nc" id="L123">                return;</span>
        }
<span class="nc" id="L125">        catch (Exception ex)</span>
        {
<span class="nc" id="L127">            RequestFailureReason reason = UNKNOWN;</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">            if (ex instanceof WriteTimeoutException) reason = TIMEOUT;</span>
<span class="nc" id="L129">            else logger.error(&quot;Failed to apply paxos refresh-prepare locally&quot;, ex);</span>

<span class="nc" id="L131">            onFailure(getBroadcastAddressAndPort(), reason);</span>
<span class="nc" id="L132">            return;</span>
<span class="nc" id="L133">        }</span>
<span class="nc" id="L134">        onResponse(response, getBroadcastAddressAndPort());</span>
<span class="nc" id="L135">    }</span>

    private void onResponse(Response response, InetAddressAndPort from)
    {
<span class="nc" id="L139">        callbacks.onRefreshSuccess(response.isSupersededBy, from);</span>
<span class="nc" id="L140">    }</span>

    private static class Request
    {
        final Ballot promised;
        final Committed missingCommit;

        Request(Ballot promised, Committed missingCommit)
<span class="nc" id="L148">        {</span>
<span class="nc" id="L149">            this.promised = promised;</span>
<span class="nc" id="L150">            this.missingCommit = missingCommit;</span>
<span class="nc" id="L151">        }</span>
    }

    static class Response
    {
        final Ballot isSupersededBy;
        Response(Ballot isSupersededBy)
<span class="nc" id="L158">        {</span>
<span class="nc" id="L159">            this.isSupersededBy = isSupersededBy;</span>
<span class="nc" id="L160">        }</span>
    }

<span class="nc" id="L163">    public static class RequestHandler implements IVerbHandler&lt;Request&gt;</span>
    {
        @Override
        public void doVerb(Message&lt;Request&gt; message)
        {
<span class="nc" id="L168">            Response response = execute(message.payload, message.from());</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">            if (response == null)</span>
<span class="nc" id="L170">                MessagingService.instance().respondWithFailure(UNKNOWN, message);</span>
            else
<span class="nc" id="L172">                MessagingService.instance().respond(response, message);</span>
<span class="nc" id="L173">        }</span>

        public static Response execute(Request request, InetAddressAndPort from)
        {
<span class="nc" id="L177">            Agreed commit = request.missingCommit;</span>

<span class="nc bnc" id="L179" title="All 2 branches missed.">            if (!Paxos.isInRangeAndShouldProcess(from, commit.update.partitionKey(), commit.update.metadata(), false))</span>
<span class="nc" id="L180">                return null;</span>

<span class="nc" id="L182">            try (PaxosState state = PaxosState.get(commit))</span>
            {
<span class="nc" id="L184">                state.commit(commit);</span>
<span class="nc" id="L185">                Ballot latest = state.current(request.promised).latestWitnessedOrLowBound();</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">                if (isAfter(latest, request.promised))</span>
                {
<span class="nc" id="L188">                    Tracing.trace(&quot;Promise {} rescinded; latest is now {}&quot;, request.promised, latest);</span>
<span class="nc" id="L189">                    return new Response(latest);</span>
                }
                else
                {
<span class="nc" id="L193">                    Tracing.trace(&quot;Promise confirmed for ballot {}&quot;, request.promised);</span>
<span class="nc" id="L194">                    return new Response(null);</span>
                }
<span class="nc bnc" id="L196" title="All 2 branches missed.">            }</span>
        }
    }

<span class="nc" id="L200">    public static class RequestSerializer implements IVersionedSerializer&lt;Request&gt;</span>
    {
        @Override
        public void serialize(Request request, DataOutputPlus out, int version) throws IOException
        {
<span class="nc" id="L205">            request.promised.serialize(out);</span>
<span class="nc" id="L206">            Committed.serializer.serialize(request.missingCommit, out, version);</span>
<span class="nc" id="L207">        }</span>

        @Override
        public Request deserialize(DataInputPlus in, int version) throws IOException
        {
<span class="nc" id="L212">            Ballot promise = Ballot.deserialize(in);</span>
<span class="nc" id="L213">            Committed missingCommit = Committed.serializer.deserialize(in, version);</span>
<span class="nc" id="L214">            return new Request(promise, missingCommit);</span>
        }

        @Override
        public long serializedSize(Request request, int version)
        {
<span class="nc" id="L220">            return Ballot.sizeInBytes()</span>
<span class="nc" id="L221">                   + Committed.serializer.serializedSize(request.missingCommit, version);</span>
        }
    }

<span class="nc" id="L225">    public static class ResponseSerializer implements IVersionedSerializer&lt;Response&gt;</span>
    {
        public void serialize(Response response, DataOutputPlus out, int version) throws IOException
        {
<span class="nc" id="L229">            serializeNullable(Ballot.Serializer.instance, response.isSupersededBy, out, version);</span>
<span class="nc" id="L230">        }</span>

        public Response deserialize(DataInputPlus in, int version) throws IOException
        {
<span class="nc" id="L234">            Ballot isSupersededBy = deserializeNullable(Ballot.Serializer.instance, in, version);</span>
<span class="nc" id="L235">            return new Response(isSupersededBy);</span>
        }

        public long serializedSize(Response response, int version)
        {
<span class="nc" id="L240">            return serializedSizeNullable(Ballot.Serializer.instance, response.isSupersededBy, version);</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>