<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NoSpamLogger.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.utils</a> &gt; <span class="el_source">NoSpamLogger.java</span></div><h1>NoSpamLogger.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.utils;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Supplier;

import org.cliffc.high_scale_lib.NonBlockingHashMap;
import org.slf4j.Logger;

import com.google.common.annotations.VisibleForTesting;

import static org.apache.cassandra.utils.Clock.Global;

/**
 * Logging that limits each log statement to firing based on time since the statement last fired.
 *
 * Every logger has a unique timer per statement. Minimum time between logging is set for each statement
 * the first time it is used and a subsequent attempt to request that statement with a different minimum time will
 * result in the original time being used. No warning is provided if there is a mismatch.
 *
 * If the statement is cached and used to log directly then only a volatile read will be required in the common case.
 * If the Logger is cached then there is a single concurrent hash map lookup + the volatile read.
 * If neither the logger nor the statement is cached then it is two concurrent hash map lookups + the volatile read.
 *
 */
public class NoSpamLogger
{
    /**
     * Levels for programmatically specifying the severity of a log statement
     */
<span class="fc" id="L48">    public enum Level</span>
    {
<span class="fc" id="L50">        INFO, WARN, ERROR</span>
    }

    @VisibleForTesting
    static interface Clock
    {
        long nanoTime();
    }

    @VisibleForTesting
<span class="fc" id="L60">    static Clock CLOCK = new Clock()</span>
<span class="fc" id="L61">    {</span>
        public long nanoTime()
        {
<span class="fc" id="L64">            return Global.nanoTime();</span>
        }
    };

    public class NoSpamLogStatement extends AtomicLong
    {
        private static final long serialVersionUID = 1L;

        private final String statement;
        private final long minIntervalNanos;

        public NoSpamLogStatement(String statement, long minIntervalNanos)
<span class="fc" id="L76">        {</span>
<span class="fc" id="L77">            super(Long.MIN_VALUE);</span>
<span class="fc" id="L78">            this.statement = statement;</span>
<span class="fc" id="L79">            this.minIntervalNanos = minIntervalNanos;</span>
<span class="fc" id="L80">        }</span>

        private boolean shouldLog(long nowNanos)
        {
<span class="fc" id="L84">            long expected = get();</span>
<span class="fc bfc" id="L85" title="All 4 branches covered.">            return nowNanos &gt;= expected &amp;&amp; compareAndSet(expected, nowNanos + minIntervalNanos);</span>
        }

        public boolean log(Level l, long nowNanos, Supplier&lt;Object[]&gt; objects)
        {
<span class="fc bfc" id="L90" title="All 2 branches covered.">            if (!shouldLog(nowNanos)) return false;</span>
<span class="fc" id="L91">            return logNoCheck(l, objects.get());</span>
        }

        public boolean log(Level l, long nowNanos, Object... objects)
        {
<span class="fc bfc" id="L96" title="All 2 branches covered.">            if (!shouldLog(nowNanos)) return false;</span>
<span class="fc" id="L97">            return logNoCheck(l, objects);</span>
        }

        private boolean logNoCheck(Level l, Object... objects)
        {
<span class="pc bpc" id="L102" title="1 of 4 branches missed.">            switch (l)</span>
            {
                case INFO:
<span class="fc" id="L105">                    wrapped.info(statement, objects);</span>
<span class="fc" id="L106">                    break;</span>
                case WARN:
<span class="fc" id="L108">                    wrapped.warn(statement, objects);</span>
<span class="fc" id="L109">                    break;</span>
                case ERROR:
<span class="fc" id="L111">                    wrapped.error(statement, objects);</span>
<span class="fc" id="L112">                    break;</span>
                default:
<span class="nc" id="L114">                    throw new AssertionError();</span>
            }
<span class="fc" id="L116">            return true;</span>
        }

        public boolean info(long nowNanos, Object... objects)
        {
<span class="nc" id="L121">            return NoSpamLogStatement.this.log(Level.INFO, nowNanos, objects);</span>
        }

        public boolean info(Object... objects)
        {
<span class="nc" id="L126">            return NoSpamLogStatement.this.info(CLOCK.nanoTime(), objects);</span>
        }

        public boolean warn(long nowNanos, Object... objects)
        {
<span class="nc" id="L131">            return NoSpamLogStatement.this.log(Level.WARN, nowNanos, objects);</span>
        }

        public boolean warn(Object... objects)
        {
<span class="nc" id="L136">            return NoSpamLogStatement.this.warn(CLOCK.nanoTime(), objects);</span>
        }

        public boolean error(long nowNanos, Object... objects)
        {
<span class="nc" id="L141">            return NoSpamLogStatement.this.log(Level.ERROR, nowNanos, objects);</span>
        }

        public boolean error(Object... objects)
        {
<span class="nc" id="L146">            return NoSpamLogStatement.this.error(CLOCK.nanoTime(), objects);</span>
        }
    }

<span class="fc" id="L150">    private static final NonBlockingHashMap&lt;Logger, NoSpamLogger&gt; wrappedLoggers = new NonBlockingHashMap&lt;&gt;();</span>

    @VisibleForTesting
    static void clearWrappedLoggersForTest()
    {
<span class="nc" id="L155">        wrappedLoggers.clear();</span>
<span class="nc" id="L156">    }</span>

    public static NoSpamLogger getLogger(Logger logger, long minInterval, TimeUnit unit)
    {
<span class="fc" id="L160">        NoSpamLogger wrapped = wrappedLoggers.get(logger);</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (wrapped == null)</span>
        {
<span class="fc" id="L163">            wrapped = new NoSpamLogger(logger, minInterval, unit);</span>
<span class="fc" id="L164">            NoSpamLogger temp = wrappedLoggers.putIfAbsent(logger, wrapped);</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">            if (temp != null)</span>
<span class="nc" id="L166">                wrapped = temp;</span>
        }
<span class="fc" id="L168">        return wrapped;</span>
    }

    public static boolean log(Logger logger, Level level, long minInterval, TimeUnit unit, String message, Object... objects)
    {
<span class="nc" id="L173">        return log(logger, level, message, minInterval, unit, CLOCK.nanoTime(), message, objects);</span>
    }

    public static boolean log(Logger logger, Level level, String key, long minInterval, TimeUnit unit, String message, Object... objects)
    {
<span class="nc" id="L178">        return log(logger, level, key, minInterval, unit, CLOCK.nanoTime(), message, objects);</span>
    }

    public static boolean log(Logger logger, Level level, String key, long minInterval, TimeUnit unit, long nowNanos, String message, Object... objects)
    {
<span class="nc" id="L183">        NoSpamLogger wrapped = getLogger(logger, minInterval, unit);</span>
<span class="nc" id="L184">        NoSpamLogStatement statement = wrapped.getStatement(key, message);</span>
<span class="nc" id="L185">        return statement.log(level, nowNanos, objects);</span>
    }

    public static boolean log(Logger logger, Level level, long minInterval, TimeUnit unit, String message, Supplier&lt;Object[]&gt; objects)
    {
<span class="fc" id="L190">        return log(logger, level, message, minInterval, unit, CLOCK.nanoTime(), message, objects);</span>
    }

    public static boolean log(Logger logger, Level level, String key, long minInterval, TimeUnit unit, String message, Supplier&lt;Object[]&gt; objects)
    {
<span class="nc" id="L195">        return log(logger, level, key, minInterval, unit, CLOCK.nanoTime(), message, objects);</span>
    }

    public static boolean log(Logger logger, Level level, String key, long minInterval, TimeUnit unit, long nowNanos, String message, Supplier&lt;Object[]&gt; objects)
    {
<span class="fc" id="L200">        NoSpamLogger wrapped = getLogger(logger, minInterval, unit);</span>
<span class="fc" id="L201">        NoSpamLogStatement statement = wrapped.getStatement(key, message);</span>
<span class="fc" id="L202">        return statement.log(level, nowNanos, objects);</span>
    }

    public static NoSpamLogStatement getStatement(Logger logger, String message, long minInterval, TimeUnit unit)
    {
<span class="nc" id="L207">        NoSpamLogger wrapped = getLogger(logger, minInterval, unit);</span>
<span class="nc" id="L208">        return wrapped.getStatement(message);</span>
    }

    private final Logger wrapped;
    private final long minIntervalNanos;
<span class="fc" id="L213">    private final NonBlockingHashMap&lt;String, NoSpamLogStatement&gt; lastMessage = new NonBlockingHashMap&lt;&gt;();</span>

    private NoSpamLogger(Logger wrapped, long minInterval, TimeUnit timeUnit)
<span class="fc" id="L216">    {</span>
<span class="fc" id="L217">        this.wrapped = wrapped;</span>
<span class="fc" id="L218">        minIntervalNanos = timeUnit.toNanos(minInterval);</span>
<span class="fc" id="L219">    }</span>

    public boolean info(long nowNanos, String s, Object... objects)
    {
<span class="fc" id="L223">        return NoSpamLogger.this.log( Level.INFO, s, nowNanos, objects);</span>
    }

    public boolean info(String s, Object... objects)
    {
<span class="fc" id="L228">        return NoSpamLogger.this.info(CLOCK.nanoTime(), s, objects);</span>
    }

    public boolean warn(long nowNanos, String s, Object... objects)
    {
<span class="fc" id="L233">        return NoSpamLogger.this.log( Level.WARN, s, nowNanos, objects);</span>
    }

    public boolean warn(String s, Object... objects)
    {
<span class="fc" id="L238">        return NoSpamLogger.this.warn(CLOCK.nanoTime(), s, objects);</span>
    }

    public boolean error(long nowNanos, String s, Object... objects)
    {
<span class="fc" id="L243">        return NoSpamLogger.this.log( Level.ERROR, s, nowNanos, objects);</span>
    }

    public boolean error(String s, Object... objects)
    {
<span class="fc" id="L248">        return NoSpamLogger.this.error(CLOCK.nanoTime(), s, objects);</span>
    }

    public boolean log(Level l, String s, long nowNanos, Object... objects)
    {
<span class="fc" id="L253">        return NoSpamLogger.this.getStatement(s, minIntervalNanos).log(l, nowNanos, objects);</span>
    }

    public NoSpamLogStatement getStatement(String s)
    {
<span class="nc" id="L258">        return NoSpamLogger.this.getStatement(s, minIntervalNanos);</span>
    }

    public NoSpamLogStatement getStatement(String key, String s)
    {
<span class="fc" id="L263">        return NoSpamLogger.this.getStatement(key, s, minIntervalNanos);</span>
    }

    public NoSpamLogStatement getStatement(String s, long minInterval, TimeUnit unit)
    {
<span class="nc" id="L268">        return NoSpamLogger.this.getStatement(s, unit.toNanos(minInterval));</span>
    }

    public NoSpamLogStatement getStatement(String s, long minIntervalNanos)
    {
<span class="fc" id="L273">        return getStatement(s, s, minIntervalNanos);</span>
    }

    public NoSpamLogStatement getStatement(String key, String s, long minIntervalNanos)
    {
<span class="fc" id="L278">        NoSpamLogStatement statement = lastMessage.get(key);</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        if (statement == null)</span>
        {
<span class="fc" id="L281">            statement = new NoSpamLogStatement(s, minIntervalNanos);</span>
<span class="fc" id="L282">            NoSpamLogStatement temp = lastMessage.putIfAbsent(key, statement);</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">            if (temp != null)</span>
<span class="fc" id="L284">                statement = temp;</span>
        }
<span class="fc" id="L286">        return statement;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>