<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Config.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.config</a> &gt; <span class="el_source">Config.java</span></div><h1>Config.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.config;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.function.Supplier;
import javax.annotation.Nullable;

import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.audit.AuditLogOptions;
import org.apache.cassandra.db.ConsistencyLevel;
import org.apache.cassandra.fql.FullQueryLoggerOptions;
import org.apache.cassandra.index.internal.CassandraIndex;
import org.apache.cassandra.io.sstable.format.big.BigFormat;
import org.apache.cassandra.service.StartupChecks.StartupCheckType;
import org.apache.cassandra.utils.StorageCompatibilityMode;

import static org.apache.cassandra.config.CassandraRelevantProperties.AUTOCOMPACTION_ON_STARTUP_ENABLED;
import static org.apache.cassandra.config.CassandraRelevantProperties.FILE_CACHE_ENABLED;
import static org.apache.cassandra.config.CassandraRelevantProperties.SKIP_PAXOS_REPAIR_ON_TOPOLOGY_CHANGE;
import static org.apache.cassandra.config.CassandraRelevantProperties.SKIP_PAXOS_REPAIR_ON_TOPOLOGY_CHANGE_KEYSPACES;

/**
 * A class that contains configuration properties for the cassandra node it runs within.
 * &lt;p&gt;
 * Properties declared as volatile can be mutated via JMX.
 */
<span class="fc" id="L56">public class Config</span>
{
<span class="fc" id="L58">    private static final Logger logger = LoggerFactory.getLogger(Config.class);</span>

    public static Set&lt;String&gt; splitCommaDelimited(String src)
    {
<span class="pc bpc" id="L62" title="1 of 2 branches missed.">        if (src == null)</span>
<span class="fc" id="L63">            return ImmutableSet.of();</span>
<span class="nc" id="L64">        String[] split = src.split(&quot;,\\s*&quot;);</span>
<span class="nc" id="L65">        ImmutableSet.Builder&lt;String&gt; builder = ImmutableSet.builder();</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">        for (String s : split)</span>
        {
<span class="nc" id="L68">            s = s.trim();</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">            if (!s.isEmpty())</span>
<span class="nc" id="L70">                builder.add(s);</span>
        }
<span class="nc" id="L72">        return builder.build();</span>
    }
    /*
     * Prefix for Java properties for internal Cassandra configuration options
     */
    public static final String PROPERTY_PREFIX = &quot;cassandra.&quot;;

<span class="fc" id="L79">    public String cluster_name = &quot;Test Cluster&quot;;</span>
    public ParameterizedClass authenticator;
    public String authorizer;
    public String role_manager;
    public ParameterizedClass crypto_provider;
    public String network_authorizer;
    public ParameterizedClass cidr_authorizer;

<span class="fc" id="L87">    @Replaces(oldName = &quot;permissions_validity_in_ms&quot;, converter = Converters.MILLIS_DURATION_INT, deprecated = true)</span>
    public volatile DurationSpec.IntMillisecondsBound permissions_validity = new DurationSpec.IntMillisecondsBound(&quot;2s&quot;);
<span class="fc" id="L89">    public volatile int permissions_cache_max_entries = 1000;</span>
<span class="fc" id="L90">    @Replaces(oldName = &quot;permissions_update_interval_in_ms&quot;, converter = Converters.MILLIS_CUSTOM_DURATION, deprecated = true)</span>
    public volatile DurationSpec.IntMillisecondsBound permissions_update_interval = null;
<span class="fc" id="L92">    public volatile boolean permissions_cache_active_update = false;</span>
<span class="fc" id="L93">    @Replaces(oldName = &quot;roles_validity_in_ms&quot;, converter = Converters.MILLIS_DURATION_INT, deprecated = true)</span>
    public volatile DurationSpec.IntMillisecondsBound roles_validity = new DurationSpec.IntMillisecondsBound(&quot;2s&quot;);
<span class="fc" id="L95">    public volatile int roles_cache_max_entries = 1000;</span>
<span class="fc" id="L96">    @Replaces(oldName = &quot;roles_update_interval_in_ms&quot;, converter = Converters.MILLIS_CUSTOM_DURATION, deprecated = true)</span>
    public volatile DurationSpec.IntMillisecondsBound roles_update_interval = null;
<span class="fc" id="L98">    public volatile boolean roles_cache_active_update = false;</span>
<span class="fc" id="L99">    @Replaces(oldName = &quot;credentials_validity_in_ms&quot;, converter = Converters.MILLIS_DURATION_INT, deprecated = true)</span>
    public volatile DurationSpec.IntMillisecondsBound credentials_validity = new DurationSpec.IntMillisecondsBound(&quot;2s&quot;);
<span class="fc" id="L101">    public volatile int credentials_cache_max_entries = 1000;</span>
<span class="fc" id="L102">    @Replaces(oldName = &quot;credentials_update_interval_in_ms&quot;, converter = Converters.MILLIS_CUSTOM_DURATION, deprecated = true)</span>
    public volatile DurationSpec.IntMillisecondsBound credentials_update_interval = null;
<span class="fc" id="L104">    public volatile boolean credentials_cache_active_update = false;</span>

    /* Hashing strategy Random or OPHF */
    public String partitioner;

<span class="fc" id="L109">    public boolean auto_bootstrap = true;</span>
<span class="fc" id="L110">    public volatile boolean hinted_handoff_enabled = true;</span>
<span class="fc" id="L111">    public Set&lt;String&gt; hinted_handoff_disabled_datacenters = Sets.newConcurrentHashSet();</span>
<span class="fc" id="L112">    @Replaces(oldName = &quot;max_hint_window_in_ms&quot;, converter = Converters.MILLIS_DURATION_INT, deprecated = true)</span>
    public volatile DurationSpec.IntMillisecondsBound max_hint_window = new DurationSpec.IntMillisecondsBound(&quot;3h&quot;);
    public String hints_directory;
<span class="fc" id="L115">    public boolean hint_window_persistent_enabled = true;</span>

<span class="fc" id="L117">    public volatile boolean force_new_prepared_statement_behaviour = false;</span>

    public ParameterizedClass seed_provider;
<span class="fc" id="L120">    public DiskAccessMode disk_access_mode = DiskAccessMode.auto;</span>

<span class="fc" id="L122">    public DiskFailurePolicy disk_failure_policy = DiskFailurePolicy.ignore;</span>
<span class="fc" id="L123">    public CommitFailurePolicy commit_failure_policy = CommitFailurePolicy.stop;</span>

<span class="fc" id="L125">    public volatile boolean use_deterministic_table_id = false;</span>

    /* initial token in the ring */
    public String initial_token;
    public Integer num_tokens;
    /** Triggers automatic allocation of tokens if set, using the replication strategy of the referenced keyspace */
<span class="fc" id="L131">    public String allocate_tokens_for_keyspace = null;</span>
    /** Triggers automatic allocation of tokens if set, based on the provided replica count for a datacenter */
<span class="fc" id="L133">    public Integer allocate_tokens_for_local_replication_factor = null;</span>

<span class="fc" id="L135">    @Replaces(oldName = &quot;native_transport_idle_timeout_in_ms&quot;, converter = Converters.MILLIS_DURATION_LONG, deprecated = true)</span>
    public DurationSpec.LongMillisecondsBound native_transport_idle_timeout = new DurationSpec.LongMillisecondsBound(&quot;0ms&quot;);

<span class="fc" id="L138">    @Replaces(oldName = &quot;request_timeout_in_ms&quot;, converter = Converters.MILLIS_DURATION_LONG, deprecated = true)</span>
    public volatile DurationSpec.LongMillisecondsBound request_timeout = new DurationSpec.LongMillisecondsBound(&quot;10000ms&quot;);

<span class="fc" id="L141">    @Replaces(oldName = &quot;read_request_timeout_in_ms&quot;, converter = Converters.MILLIS_DURATION_LONG, deprecated = true)</span>
    public volatile DurationSpec.LongMillisecondsBound read_request_timeout = new DurationSpec.LongMillisecondsBound(&quot;5000ms&quot;);

<span class="fc" id="L144">    @Replaces(oldName = &quot;range_request_timeout_in_ms&quot;, converter = Converters.MILLIS_DURATION_LONG, deprecated = true)</span>
    public volatile DurationSpec.LongMillisecondsBound range_request_timeout = new DurationSpec.LongMillisecondsBound(&quot;10000ms&quot;);

<span class="fc" id="L147">    @Replaces(oldName = &quot;write_request_timeout_in_ms&quot;, converter = Converters.MILLIS_DURATION_LONG, deprecated = true)</span>
    public volatile DurationSpec.LongMillisecondsBound write_request_timeout = new DurationSpec.LongMillisecondsBound(&quot;2000ms&quot;);

<span class="fc" id="L150">    @Replaces(oldName = &quot;counter_write_request_timeout_in_ms&quot;, converter = Converters.MILLIS_DURATION_LONG, deprecated = true)</span>
    public volatile DurationSpec.LongMillisecondsBound counter_write_request_timeout = new DurationSpec.LongMillisecondsBound(&quot;5000ms&quot;);

<span class="fc" id="L153">    @Replaces(oldName = &quot;cas_contention_timeout_in_ms&quot;, converter = Converters.MILLIS_DURATION_LONG, deprecated = true)</span>
    public volatile DurationSpec.LongMillisecondsBound cas_contention_timeout = new DurationSpec.LongMillisecondsBound(&quot;1800ms&quot;);

<span class="fc" id="L156">    @Replaces(oldName = &quot;truncate_request_timeout_in_ms&quot;, converter = Converters.MILLIS_DURATION_LONG, deprecated = true)</span>
    public volatile DurationSpec.LongMillisecondsBound truncate_request_timeout = new DurationSpec.LongMillisecondsBound(&quot;60000ms&quot;);

<span class="fc" id="L159">    @Replaces(oldName = &quot;repair_request_timeout_in_ms&quot;, converter = Converters.MILLIS_DURATION_LONG, deprecated = true)</span>
    public volatile DurationSpec.LongMillisecondsBound repair_request_timeout = new DurationSpec.LongMillisecondsBound(&quot;120000ms&quot;);

<span class="fc" id="L162">    public Integer streaming_connections_per_host = 1;</span>
<span class="fc" id="L163">    @Replaces(oldName = &quot;streaming_keep_alive_period_in_secs&quot;, converter = Converters.SECONDS_DURATION, deprecated = true)</span>
    public DurationSpec.IntSecondsBound streaming_keep_alive_period = new DurationSpec.IntSecondsBound(&quot;300s&quot;);

<span class="fc" id="L166">    @Replaces(oldName = &quot;cross_node_timeout&quot;, converter = Converters.IDENTITY, deprecated = true)</span>
    public boolean internode_timeout = true;

<span class="fc" id="L169">    @Replaces(oldName = &quot;slow_query_log_timeout_in_ms&quot;, converter = Converters.MILLIS_DURATION_LONG, deprecated = true)</span>
    public volatile DurationSpec.LongMillisecondsBound slow_query_log_timeout = new DurationSpec.LongMillisecondsBound(&quot;500ms&quot;);

<span class="fc" id="L172">    public volatile DurationSpec.LongMillisecondsBound stream_transfer_task_timeout = new DurationSpec.LongMillisecondsBound(&quot;12h&quot;);</span>

<span class="fc" id="L174">    public volatile double phi_convict_threshold = 8.0;</span>

<span class="fc" id="L176">    public int concurrent_reads = 32;</span>
<span class="fc" id="L177">    public int concurrent_writes = 32;</span>
<span class="fc" id="L178">    public int concurrent_counter_writes = 32;</span>
<span class="fc" id="L179">    public int concurrent_materialized_view_writes = 32;</span>
<span class="fc" id="L180">    public int available_processors = -1;</span>

<span class="fc" id="L182">    @Deprecated</span>
    public Integer concurrent_replicates = null;

<span class="fc" id="L185">    public int memtable_flush_writers = 0;</span>
    @Replaces(oldName = &quot;memtable_heap_space_in_mb&quot;, converter = Converters.MEBIBYTES_DATA_STORAGE_INT, deprecated = true)
    public DataStorageSpec.IntMebibytesBound memtable_heap_space;
    @Replaces(oldName = &quot;memtable_offheap_space_in_mb&quot;, converter = Converters.MEBIBYTES_DATA_STORAGE_INT, deprecated = true)
    public DataStorageSpec.IntMebibytesBound memtable_offheap_space;
<span class="fc" id="L190">    public Float memtable_cleanup_threshold = null;</span>

    public static class MemtableOptions
    {
        public LinkedHashMap&lt;String, InheritingClass&gt; configurations; // order must be preserved

        public MemtableOptions()
<span class="nc" id="L197">        {</span>
<span class="nc" id="L198">        }</span>
    }

    public MemtableOptions memtable;

    // Limit the maximum depth of repair session merkle trees
<span class="fc" id="L204">    @Deprecated</span>
    public volatile Integer repair_session_max_tree_depth = null;
<span class="fc" id="L206">    @Replaces(oldName = &quot;repair_session_space_in_mb&quot;, converter = Converters.MEBIBYTES_DATA_STORAGE_INT, deprecated = true)</span>
    public volatile DataStorageSpec.IntMebibytesBound repair_session_space = null;

<span class="fc" id="L209">    public volatile boolean use_offheap_merkle_trees = true;</span>

<span class="fc" id="L211">    public int storage_port = 7000;</span>
<span class="fc" id="L212">    public int ssl_storage_port = 7001;</span>
    public String listen_address;
    public String listen_interface;
<span class="fc" id="L215">    public boolean listen_interface_prefer_ipv6 = false;</span>
    public String broadcast_address;
<span class="fc" id="L217">    public boolean listen_on_broadcast_address = false;</span>
    public ParameterizedClass internode_authenticator;

<span class="fc" id="L220">    public boolean traverse_auth_from_root = false;</span>

    /*
     * RPC address and interface refer to the address/interface used for the native protocol used to communicate with
     * clients. It's still called RPC in some places even though Thrift RPC is gone. If you see references to native
     * address or native port it's derived from the RPC address configuration.
     *
     * native_transport_port is the port that is paired with RPC address to bind on.
     */
    public String rpc_address;
    public String rpc_interface;
<span class="fc" id="L231">    public boolean rpc_interface_prefer_ipv6 = false;</span>
    public String broadcast_rpc_address;
<span class="fc" id="L233">    public boolean rpc_keepalive = true;</span>

    @Replaces(oldName = &quot;internode_max_message_size_in_bytes&quot;, converter = Converters.BYTES_DATASTORAGE, deprecated=true)
    public DataStorageSpec.IntBytesBound internode_max_message_size;

<span class="fc" id="L238">    @Replaces(oldName = &quot;internode_socket_send_buffer_size_in_bytes&quot;, converter = Converters.BYTES_DATASTORAGE, deprecated = true)</span>
    @Replaces(oldName = &quot;internode_send_buff_size_in_bytes&quot;, converter = Converters.BYTES_DATASTORAGE, deprecated = true)
    public DataStorageSpec.IntBytesBound internode_socket_send_buffer_size = new DataStorageSpec.IntBytesBound(&quot;0B&quot;);
<span class="fc" id="L241">    @Replaces(oldName = &quot;internode_socket_receive_buffer_size_in_bytes&quot;, converter = Converters.BYTES_DATASTORAGE, deprecated = true)</span>
    @Replaces(oldName = &quot;internode_recv_buff_size_in_bytes&quot;, converter = Converters.BYTES_DATASTORAGE, deprecated = true)
    public DataStorageSpec.IntBytesBound internode_socket_receive_buffer_size = new DataStorageSpec.IntBytesBound(&quot;0B&quot;);

    // TODO: derive defaults from system memory settings?
<span class="fc" id="L246">    @Replaces(oldName = &quot;internode_application_send_queue_capacity_in_bytes&quot;, converter = Converters.BYTES_DATASTORAGE, deprecated = true)</span>
    public DataStorageSpec.IntBytesBound internode_application_send_queue_capacity = new DataStorageSpec.IntBytesBound(&quot;4MiB&quot;);
<span class="fc" id="L248">    @Replaces(oldName = &quot;internode_application_send_queue_reserve_endpoint_capacity_in_bytes&quot;, converter = Converters.BYTES_DATASTORAGE, deprecated = true)</span>
    public DataStorageSpec.IntBytesBound internode_application_send_queue_reserve_endpoint_capacity = new DataStorageSpec.IntBytesBound(&quot;128MiB&quot;);
<span class="fc" id="L250">    @Replaces(oldName = &quot;internode_application_send_queue_reserve_global_capacity_in_bytes&quot;, converter = Converters.BYTES_DATASTORAGE, deprecated = true)</span>
    public DataStorageSpec.IntBytesBound internode_application_send_queue_reserve_global_capacity = new DataStorageSpec.IntBytesBound(&quot;512MiB&quot;);

<span class="fc" id="L253">    @Replaces(oldName = &quot;internode_application_receive_queue_capacity_in_bytes&quot;, converter = Converters.BYTES_DATASTORAGE, deprecated = true)</span>
    public DataStorageSpec.IntBytesBound internode_application_receive_queue_capacity = new DataStorageSpec.IntBytesBound(&quot;4MiB&quot;);
<span class="fc" id="L255">    @Replaces(oldName = &quot;internode_application_receive_queue_reserve_endpoint_capacity_in_bytes&quot;, converter = Converters.BYTES_DATASTORAGE, deprecated = true)</span>
    public DataStorageSpec.IntBytesBound internode_application_receive_queue_reserve_endpoint_capacity = new DataStorageSpec.IntBytesBound(&quot;128MiB&quot;);
<span class="fc" id="L257">    @Replaces(oldName = &quot;internode_application_receive_queue_reserve_global_capacity_in_bytes&quot;, converter = Converters.BYTES_DATASTORAGE, deprecated = true)</span>
    public DataStorageSpec.IntBytesBound internode_application_receive_queue_reserve_global_capacity = new DataStorageSpec.IntBytesBound(&quot;512MiB&quot;);

    // Defensive settings for protecting Cassandra from true network partitions. See (CASSANDRA-14358) for details.
    // The amount of time to wait for internode tcp connections to establish.
<span class="fc" id="L262">    @Replaces(oldName = &quot;internode_tcp_connect_timeout_in_ms&quot;, converter = Converters.MILLIS_DURATION_INT, deprecated = true)</span>
    public volatile DurationSpec.IntMillisecondsBound internode_tcp_connect_timeout = new DurationSpec.IntMillisecondsBound(&quot;2s&quot;);
    // The amount of time unacknowledged data is allowed on a connection before we throw out the connection
    // Note this is only supported on Linux + epoll, and it appears to behave oddly above a setting of 30000
    // (it takes much longer than 30s) as of Linux 4.12. If you want something that high set this to 0
    // (which picks up the OS default) and configure the net.ipv4.tcp_retries2 sysctl to be ~8.
<span class="fc" id="L268">    @Replaces(oldName = &quot;internode_tcp_user_timeout_in_ms&quot;, converter = Converters.MILLIS_DURATION_INT, deprecated = true)</span>
    public volatile DurationSpec.IntMillisecondsBound internode_tcp_user_timeout = new DurationSpec.IntMillisecondsBound(&quot;30s&quot;);
    // Similar to internode_tcp_user_timeout but used specifically for streaming connection.
    // The default is 5 minutes. Increase it or set it to 0 in order to increase the timeout.
<span class="fc" id="L272">    @Replaces(oldName = &quot;internode_streaming_tcp_user_timeout_in_ms&quot;, converter = Converters.MILLIS_DURATION_INT, deprecated = true)</span>
    public volatile DurationSpec.IntMillisecondsBound internode_streaming_tcp_user_timeout = new DurationSpec.IntMillisecondsBound(&quot;300s&quot;); // 5 minutes

<span class="fc" id="L275">    public boolean start_native_transport = true;</span>
<span class="fc" id="L276">    public int native_transport_port = 9042;</span>
<span class="fc" id="L277">    public Integer native_transport_port_ssl = null;</span>
<span class="fc" id="L278">    public int native_transport_max_threads = 128;</span>
<span class="fc" id="L279">    @Replaces(oldName = &quot;native_transport_max_frame_size_in_mb&quot;, converter = Converters.MEBIBYTES_DATA_STORAGE_INT, deprecated = true)</span>
    public DataStorageSpec.IntMebibytesBound native_transport_max_frame_size = new DataStorageSpec.IntMebibytesBound(&quot;16MiB&quot;);
    /** do bcrypt hashing in a limited pool to prevent cpu load spikes; note: any value &lt; 1 will be set to 1 on init **/
<span class="fc" id="L282">    public int native_transport_max_auth_threads = 4;</span>
<span class="fc" id="L283">    public volatile long native_transport_max_concurrent_connections = -1L;</span>
<span class="fc" id="L284">    public volatile long native_transport_max_concurrent_connections_per_ip = -1L;</span>
<span class="fc" id="L285">    public boolean native_transport_flush_in_batches_legacy = false;</span>
<span class="fc" id="L286">    public volatile boolean native_transport_allow_older_protocols = true;</span>
    // Below 2 parameters were fixed in 4.0 + to get default value when ==-1 (old name and value format) or ==null(new name and value format),
    // not &lt;=0 as it is in previous versions. Throwing config exceptions on &lt; -1
<span class="fc" id="L289">    @Replaces(oldName = &quot;native_transport_max_concurrent_requests_in_bytes_per_ip&quot;, converter = Converters.BYTES_CUSTOM_DATASTORAGE, deprecated = true)</span>
    public volatile DataStorageSpec.LongBytesBound native_transport_max_request_data_in_flight_per_ip = null;
<span class="fc" id="L291">    @Replaces(oldName = &quot;native_transport_max_concurrent_requests_in_bytes&quot;, converter = Converters.BYTES_CUSTOM_DATASTORAGE, deprecated = true)</span>
    public volatile DataStorageSpec.LongBytesBound native_transport_max_request_data_in_flight = null;
<span class="fc" id="L293">    public volatile boolean native_transport_rate_limiting_enabled = false;</span>
<span class="fc" id="L294">    public volatile int native_transport_max_requests_per_second = 1000000;</span>
<span class="fc" id="L295">    @Replaces(oldName = &quot;native_transport_receive_queue_capacity_in_bytes&quot;, converter = Converters.BYTES_DATASTORAGE, deprecated = true)</span>
    public DataStorageSpec.IntBytesBound native_transport_receive_queue_capacity = new DataStorageSpec.IntBytesBound(&quot;1MiB&quot;);

<span class="fc" id="L298">    @Deprecated</span>
    public Integer native_transport_max_negotiable_protocol_version = null;

    /**
     * Max size of values in SSTables, in MebiBytes.
     * Default is the same as the native protocol frame limit: 256MiB.
     * See AbstractType for how it is used.
     */
<span class="fc" id="L306">    @Replaces(oldName = &quot;max_value_size_in_mb&quot;, converter = Converters.MEBIBYTES_DATA_STORAGE_INT, deprecated = true)</span>
    public DataStorageSpec.IntMebibytesBound max_value_size = new DataStorageSpec.IntMebibytesBound(&quot;256MiB&quot;);

<span class="fc" id="L309">    public boolean snapshot_before_compaction = false;</span>
<span class="fc" id="L310">    public boolean auto_snapshot = true;</span>

    /**
     * When auto_snapshot is true and this property
     * is set, snapshots created by truncation or
     * drop use this TTL.
     */
    public String auto_snapshot_ttl;

<span class="fc" id="L319">    public volatile long snapshot_links_per_second = 0;</span>

    /* if the size of columns or super-columns are more than this, indexing will kick in */
    @Replaces(oldName = &quot;column_index_size_in_kb&quot;, converter = Converters.KIBIBYTES_DATASTORAGE, deprecated = true)
    public volatile DataStorageSpec.IntKibibytesBound column_index_size;
<span class="fc" id="L324">    @Replaces(oldName = &quot;column_index_cache_size_in_kb&quot;, converter = Converters.KIBIBYTES_DATASTORAGE, deprecated = true)</span>
    public volatile DataStorageSpec.IntKibibytesBound column_index_cache_size = new DataStorageSpec.IntKibibytesBound(&quot;2KiB&quot;);
<span class="fc" id="L326">    @Replaces(oldName = &quot;batch_size_warn_threshold_in_kb&quot;, converter = Converters.KIBIBYTES_DATASTORAGE, deprecated = true)</span>
    public volatile DataStorageSpec.IntKibibytesBound batch_size_warn_threshold = new DataStorageSpec.IntKibibytesBound(&quot;5KiB&quot;);
<span class="fc" id="L328">    @Replaces(oldName = &quot;batch_size_fail_threshold_in_kb&quot;, converter = Converters.KIBIBYTES_DATASTORAGE, deprecated = true)</span>
    public volatile DataStorageSpec.IntKibibytesBound batch_size_fail_threshold = new DataStorageSpec.IntKibibytesBound(&quot;50KiB&quot;);

<span class="fc" id="L331">    public Integer unlogged_batch_across_partitions_warn_threshold = 10;</span>
    public volatile Integer concurrent_compactors;
<span class="fc" id="L333">    @Replaces(oldName = &quot;compaction_throughput_mb_per_sec&quot;, converter = Converters.MEBIBYTES_PER_SECOND_DATA_RATE, deprecated = true)</span>
    public volatile DataRateSpec.LongBytesPerSecondBound compaction_throughput = new DataRateSpec.LongBytesPerSecondBound(&quot;64MiB/s&quot;);
<span class="fc" id="L335">    @Replaces(oldName = &quot;min_free_space_per_drive_in_mb&quot;, converter = Converters.MEBIBYTES_DATA_STORAGE_INT, deprecated = true)</span>
    public DataStorageSpec.IntMebibytesBound min_free_space_per_drive = new DataStorageSpec.IntMebibytesBound(&quot;50MiB&quot;);

    // fraction of free disk space available for compaction after min free space is subtracted
<span class="fc" id="L339">    public volatile Double max_space_usable_for_compactions_in_percentage = .95;</span>

<span class="fc" id="L341">    public volatile int concurrent_materialized_view_builders = 1;</span>
<span class="fc" id="L342">    public volatile int reject_repair_compaction_threshold = Integer.MAX_VALUE;</span>

    // The number of executors to use for building secondary indexes
<span class="fc" id="L345">    public int concurrent_index_builders = 2;</span>

    /**
     * @deprecated retry support removed on CASSANDRA-10992
     */
<span class="fc" id="L350">    @Deprecated</span>
    public int max_streaming_retries = 3;

<span class="fc" id="L353">    @Replaces(oldName = &quot;stream_throughput_outbound_megabits_per_sec&quot;, converter = Converters.MEGABITS_TO_BYTES_PER_SECOND_DATA_RATE, deprecated = true)</span>
    public volatile DataRateSpec.LongBytesPerSecondBound stream_throughput_outbound = new DataRateSpec.LongBytesPerSecondBound(&quot;24MiB/s&quot;);
<span class="fc" id="L355">    @Replaces(oldName = &quot;inter_dc_stream_throughput_outbound_megabits_per_sec&quot;, converter = Converters.MEGABITS_TO_BYTES_PER_SECOND_DATA_RATE, deprecated = true)</span>
    public volatile DataRateSpec.LongBytesPerSecondBound inter_dc_stream_throughput_outbound = new DataRateSpec.LongBytesPerSecondBound(&quot;24MiB/s&quot;);

<span class="fc" id="L358">    public volatile DataRateSpec.LongBytesPerSecondBound entire_sstable_stream_throughput_outbound = new DataRateSpec.LongBytesPerSecondBound(&quot;24MiB/s&quot;);</span>
<span class="fc" id="L359">    public volatile DataRateSpec.LongBytesPerSecondBound entire_sstable_inter_dc_stream_throughput_outbound = new DataRateSpec.LongBytesPerSecondBound(&quot;24MiB/s&quot;);</span>

<span class="fc" id="L361">    public String[] data_file_directories = new String[0];</span>

<span class="fc" id="L363">    public static class SSTableConfig</span>
    {
<span class="fc" id="L365">        public String selected_format = BigFormat.NAME;</span>
<span class="fc" id="L366">        public Map&lt;String, Map&lt;String, String&gt;&gt; format = new HashMap&lt;&gt;();</span>
    }

<span class="fc" id="L369">    public final SSTableConfig sstable = new SSTableConfig();</span>

    /**
     * The directory to use for storing the system keyspaces data.
     * If unspecified the data will be stored in the first of the data_file_directories.
     */
    public String local_system_data_file_directory;

    public String saved_caches_directory;

    // Commit Log
    public String commitlog_directory;
    @Replaces(oldName = &quot;commitlog_total_space_in_mb&quot;, converter = Converters.MEBIBYTES_DATA_STORAGE_INT, deprecated = true)
    public DataStorageSpec.IntMebibytesBound commitlog_total_space;
    public CommitLogSync commitlog_sync;
<span class="fc" id="L384">    @Replaces(oldName = &quot;commitlog_sync_group_window_in_ms&quot;, converter = Converters.MILLIS_DURATION_DOUBLE, deprecated = true)</span>
    public DurationSpec.IntMillisecondsBound commitlog_sync_group_window = new DurationSpec.IntMillisecondsBound(&quot;0ms&quot;);
<span class="fc" id="L386">    @Replaces(oldName = &quot;commitlog_sync_period_in_ms&quot;, converter = Converters.MILLIS_DURATION_INT, deprecated = true)</span>
    public DurationSpec.IntMillisecondsBound commitlog_sync_period = new DurationSpec.IntMillisecondsBound(&quot;0ms&quot;);
<span class="fc" id="L388">    @Replaces(oldName = &quot;commitlog_segment_size_in_mb&quot;, converter = Converters.MEBIBYTES_DATA_STORAGE_INT, deprecated = true)</span>
    public DataStorageSpec.IntMebibytesBound commitlog_segment_size = new DataStorageSpec.IntMebibytesBound(&quot;32MiB&quot;);
    public ParameterizedClass commitlog_compression;
<span class="fc" id="L391">    public FlushCompression flush_compression = FlushCompression.fast;</span>
<span class="fc" id="L392">    public int commitlog_max_compression_buffers_in_pool = 3;</span>
    @Replaces(oldName = &quot;periodic_commitlog_sync_lag_block_in_ms&quot;, converter = Converters.MILLIS_DURATION_INT, deprecated = true)
    public DurationSpec.IntMillisecondsBound periodic_commitlog_sync_lag_block;
<span class="fc" id="L395">    public TransparentDataEncryptionOptions transparent_data_encryption_options = new TransparentDataEncryptionOptions();</span>

    @Replaces(oldName = &quot;max_mutation_size_in_kb&quot;, converter = Converters.KIBIBYTES_DATASTORAGE, deprecated = true)
    public DataStorageSpec.IntKibibytesBound max_mutation_size;

    // Change-data-capture logs
<span class="fc" id="L401">    public boolean cdc_enabled = false;</span>
    // When true, new CDC mutations are rejected/blocked when reaching max CDC storage.
    // When false, new CDC mutations can always be added. But it will remove the oldest CDC commit log segment on full.
<span class="fc" id="L404">    public volatile boolean cdc_block_writes = true;</span>
    // When true, CDC data in SSTable go through commit logs during internodes streaming, e.g. repair
    // When false, it behaves the same as normal streaming.
<span class="fc" id="L407">    public volatile boolean cdc_on_repair_enabled = true;</span>
    public String cdc_raw_directory;
<span class="fc" id="L409">    @Replaces(oldName = &quot;cdc_total_space_in_mb&quot;, converter = Converters.MEBIBYTES_DATA_STORAGE_INT, deprecated = true)</span>
    public DataStorageSpec.IntMebibytesBound cdc_total_space = new DataStorageSpec.IntMebibytesBound(&quot;0MiB&quot;);
<span class="fc" id="L411">    @Replaces(oldName = &quot;cdc_free_space_check_interval_ms&quot;, converter = Converters.MILLIS_DURATION_INT, deprecated = true)</span>
    public DurationSpec.IntMillisecondsBound cdc_free_space_check_interval = new DurationSpec.IntMillisecondsBound(&quot;250ms&quot;);

<span class="fc" id="L414">    @Deprecated</span>
    public int commitlog_periodic_queue_size = -1;

    public String endpoint_snitch;
<span class="fc" id="L418">    public boolean dynamic_snitch = true;</span>
<span class="fc" id="L419">    @Replaces(oldName = &quot;dynamic_snitch_update_interval_in_ms&quot;, converter = Converters.MILLIS_DURATION_INT, deprecated = true)</span>
    public DurationSpec.IntMillisecondsBound dynamic_snitch_update_interval = new DurationSpec.IntMillisecondsBound(&quot;100ms&quot;);
<span class="fc" id="L421">    @Replaces(oldName = &quot;dynamic_snitch_reset_interval_in_ms&quot;, converter = Converters.MILLIS_DURATION_INT, deprecated = true)</span>
    public DurationSpec.IntMillisecondsBound dynamic_snitch_reset_interval = new DurationSpec.IntMillisecondsBound(&quot;10m&quot;);
<span class="fc" id="L423">    public double dynamic_snitch_badness_threshold = 1.0;</span>

<span class="fc" id="L425">    public String failure_detector = &quot;FailureDetector&quot;;</span>

<span class="fc" id="L427">    public EncryptionOptions.ServerEncryptionOptions server_encryption_options = new EncryptionOptions.ServerEncryptionOptions();</span>
<span class="fc" id="L428">    public EncryptionOptions client_encryption_options = new EncryptionOptions();</span>

<span class="fc" id="L430">    public InternodeCompression internode_compression = InternodeCompression.none;</span>

<span class="fc" id="L432">    @Replaces(oldName = &quot;hinted_handoff_throttle_in_kb&quot;, converter = Converters.KIBIBYTES_DATASTORAGE, deprecated = true)</span>
    public DataStorageSpec.IntKibibytesBound hinted_handoff_throttle = new DataStorageSpec.IntKibibytesBound(&quot;1024KiB&quot;);
<span class="fc" id="L434">    @Replaces(oldName = &quot;batchlog_replay_throttle_in_kb&quot;, converter = Converters.KIBIBYTES_DATASTORAGE, deprecated = true)</span>
    public DataStorageSpec.IntKibibytesBound batchlog_replay_throttle = new DataStorageSpec.IntKibibytesBound(&quot;1024KiB&quot;);
<span class="fc" id="L436">    public int max_hints_delivery_threads = 2;</span>
<span class="fc" id="L437">    @Replaces(oldName = &quot;hints_flush_period_in_ms&quot;, converter = Converters.MILLIS_DURATION_INT, deprecated = true)</span>
    public DurationSpec.IntMillisecondsBound hints_flush_period = new DurationSpec.IntMillisecondsBound(&quot;10s&quot;);
<span class="fc" id="L439">    @Replaces(oldName = &quot;max_hints_file_size_in_mb&quot;, converter = Converters.MEBIBYTES_DATA_STORAGE_INT, deprecated = true)</span>
    public DataStorageSpec.IntMebibytesBound max_hints_file_size = new DataStorageSpec.IntMebibytesBound(&quot;128MiB&quot;);
<span class="fc" id="L441">    public volatile DataStorageSpec.LongBytesBound max_hints_size_per_host = new DataStorageSpec.LongBytesBound(&quot;0B&quot;); // 0 means disabled</span>

    public ParameterizedClass hints_compression;
<span class="fc" id="L444">    public volatile boolean auto_hints_cleanup_enabled = false;</span>
<span class="fc" id="L445">    public volatile boolean transfer_hints_on_decommission = true;</span>

<span class="fc" id="L447">    public volatile boolean incremental_backups = false;</span>
<span class="fc" id="L448">    public boolean trickle_fsync = false;</span>
<span class="fc" id="L449">    @Replaces(oldName = &quot;trickle_fsync_interval_in_kb&quot;, converter = Converters.KIBIBYTES_DATASTORAGE, deprecated = true)</span>
    public DataStorageSpec.IntKibibytesBound trickle_fsync_interval = new DataStorageSpec.IntKibibytesBound(&quot;10240KiB&quot;);

<span class="fc" id="L452">    @Nullable</span>
    @Replaces(oldName = &quot;sstable_preemptive_open_interval_in_mb&quot;, converter = Converters.NEGATIVE_MEBIBYTES_DATA_STORAGE_INT, deprecated = true)
    public volatile DataStorageSpec.IntMebibytesBound sstable_preemptive_open_interval = new DataStorageSpec.IntMebibytesBound(&quot;50MiB&quot;);

<span class="fc" id="L456">    public volatile boolean key_cache_migrate_during_compaction = true;</span>
<span class="fc" id="L457">    public volatile int key_cache_keys_to_save = Integer.MAX_VALUE;</span>
<span class="fc" id="L458">    @Replaces(oldName = &quot;key_cache_size_in_mb&quot;, converter = Converters.MEBIBYTES_DATA_STORAGE_LONG, deprecated = true)</span>
    public DataStorageSpec.LongMebibytesBound key_cache_size = null;
<span class="fc" id="L460">    @Replaces(oldName = &quot;key_cache_save_period&quot;, converter = Converters.SECONDS_CUSTOM_DURATION)</span>
    public volatile DurationSpec.IntSecondsBound key_cache_save_period = new DurationSpec.IntSecondsBound(&quot;4h&quot;);

<span class="fc" id="L463">    public String row_cache_class_name = &quot;org.apache.cassandra.cache.OHCProvider&quot;;</span>
<span class="fc" id="L464">    @Replaces(oldName = &quot;row_cache_size_in_mb&quot;, converter = Converters.MEBIBYTES_DATA_STORAGE_LONG, deprecated = true)</span>
    public DataStorageSpec.LongMebibytesBound row_cache_size = new DataStorageSpec.LongMebibytesBound(&quot;0MiB&quot;);
<span class="fc" id="L466">    @Replaces(oldName = &quot;row_cache_save_period&quot;, converter = Converters.SECONDS_CUSTOM_DURATION)</span>
    public volatile DurationSpec.IntSecondsBound row_cache_save_period = new DurationSpec.IntSecondsBound(&quot;0s&quot;);
<span class="fc" id="L468">    public volatile int row_cache_keys_to_save = Integer.MAX_VALUE;</span>

<span class="fc" id="L470">    @Replaces(oldName = &quot;counter_cache_size_in_mb&quot;, converter = Converters.MEBIBYTES_DATA_STORAGE_LONG, deprecated = true)</span>
    public DataStorageSpec.LongMebibytesBound counter_cache_size = null;
<span class="fc" id="L472">    @Replaces(oldName = &quot;counter_cache_save_period&quot;, converter = Converters.SECONDS_CUSTOM_DURATION)</span>
    public volatile DurationSpec.IntSecondsBound counter_cache_save_period = new DurationSpec.IntSecondsBound(&quot;7200s&quot;);
<span class="fc" id="L474">    public volatile int counter_cache_keys_to_save = Integer.MAX_VALUE;</span>

<span class="fc" id="L476">    public DataStorageSpec.LongMebibytesBound paxos_cache_size = null;</span>

<span class="fc" id="L478">    @Replaces(oldName = &quot;cache_load_timeout_seconds&quot;, converter = Converters.NEGATIVE_SECONDS_DURATION, deprecated = true)</span>
    public DurationSpec.IntSecondsBound cache_load_timeout = new DurationSpec.IntSecondsBound(&quot;30s&quot;);

<span class="fc" id="L481">    private static boolean isClientMode = false;</span>
<span class="fc" id="L482">    private static Supplier&lt;Config&gt; overrideLoadConfig = null;</span>

    @Replaces(oldName = &quot;networking_cache_size_in_mb&quot;, converter = Converters.MEBIBYTES_DATA_STORAGE_INT, deprecated = true)
    public DataStorageSpec.IntMebibytesBound networking_cache_size;

    @Replaces(oldName = &quot;file_cache_size_in_mb&quot;, converter = Converters.MEBIBYTES_DATA_STORAGE_INT, deprecated = true)
    public DataStorageSpec.IntMebibytesBound file_cache_size;

<span class="fc" id="L490">    public boolean file_cache_enabled = FILE_CACHE_ENABLED.getBoolean();</span>

    /**
     * Because of the current {@link org.apache.cassandra.utils.memory.BufferPool} slab sizes of 64 KiB, we
     * store in the file cache buffers that divide 64 KiB, so we need to round the buffer sizes to powers of two.
     * This boolean controls weather they are rounded up or down. Set it to true to round up to the
     * next power of two, set it to false to round down to the previous power of two. Note that buffer sizes are
     * already rounded to 4 KiB and capped between 4 KiB minimum and 64 kb maximum by the {@link DiskOptimizationStrategy}.
     * By default, this boolean is set to round down when {@link #disk_optimization_strategy} is {@code ssd},
     * and to round up when it is {@code spinning}.
     */
    public Boolean file_cache_round_up;

    @Deprecated
    public boolean buffer_pool_use_heap_if_exhausted;

<span class="fc" id="L506">    public DiskOptimizationStrategy disk_optimization_strategy = DiskOptimizationStrategy.ssd;</span>

<span class="fc" id="L508">    public double disk_optimization_estimate_percentile = 0.95;</span>

<span class="fc" id="L510">    public double disk_optimization_page_cross_chance = 0.1;</span>

<span class="fc" id="L512">    public boolean inter_dc_tcp_nodelay = true;</span>

<span class="fc" id="L514">    public MemtableAllocationType memtable_allocation_type = MemtableAllocationType.heap_buffers;</span>

<span class="fc" id="L516">    public volatile boolean read_thresholds_enabled = false;</span>
<span class="fc" id="L517">    public volatile DataStorageSpec.LongBytesBound coordinator_read_size_warn_threshold = null;</span>
<span class="fc" id="L518">    public volatile DataStorageSpec.LongBytesBound coordinator_read_size_fail_threshold = null;</span>
<span class="fc" id="L519">    public volatile DataStorageSpec.LongBytesBound local_read_size_warn_threshold = null;</span>
<span class="fc" id="L520">    public volatile DataStorageSpec.LongBytesBound local_read_size_fail_threshold = null;</span>
<span class="fc" id="L521">    public volatile DataStorageSpec.LongBytesBound row_index_read_size_warn_threshold = null;</span>
<span class="fc" id="L522">    public volatile DataStorageSpec.LongBytesBound row_index_read_size_fail_threshold = null;</span>

<span class="fc" id="L524">    public volatile int tombstone_warn_threshold = 1000;</span>
<span class="fc" id="L525">    public volatile int tombstone_failure_threshold = 100000;</span>

<span class="fc" id="L527">    public final ReplicaFilteringProtectionOptions replica_filtering_protection = new ReplicaFilteringProtectionOptions();</span>

    @Replaces(oldName = &quot;index_summary_capacity_in_mb&quot;, converter = Converters.MEBIBYTES_DATA_STORAGE_LONG, deprecated = true)
    public volatile DataStorageSpec.LongMebibytesBound index_summary_capacity;
<span class="fc" id="L531">    @Nullable</span>
    @Replaces(oldName = &quot;index_summary_resize_interval_in_minutes&quot;, converter = Converters.MINUTES_CUSTOM_DURATION, deprecated = true)
    public volatile DurationSpec.IntMinutesBound index_summary_resize_interval = new DurationSpec.IntMinutesBound(&quot;60m&quot;);

<span class="fc" id="L535">    @Replaces(oldName = &quot;gc_log_threshold_in_ms&quot;, converter = Converters.MILLIS_DURATION_INT, deprecated = true)</span>
    public volatile DurationSpec.IntMillisecondsBound gc_log_threshold = new DurationSpec.IntMillisecondsBound(&quot;200ms&quot;);
<span class="fc" id="L537">    @Replaces(oldName = &quot;gc_warn_threshold_in_ms&quot;, converter = Converters.MILLIS_DURATION_INT, deprecated = true)</span>
    public volatile DurationSpec.IntMillisecondsBound gc_warn_threshold = new DurationSpec.IntMillisecondsBound(&quot;1s&quot;);

    // TTL for different types of trace events.
<span class="fc" id="L541">    @Replaces(oldName = &quot;tracetype_query_ttl&quot;, converter = Converters.SECONDS_DURATION, deprecated=true)</span>
    public DurationSpec.IntSecondsBound trace_type_query_ttl = new DurationSpec.IntSecondsBound(&quot;1d&quot;);
<span class="fc" id="L543">    @Replaces(oldName = &quot;tracetype_repair_ttl&quot;, converter = Converters.SECONDS_DURATION, deprecated=true)</span>
    public DurationSpec.IntSecondsBound trace_type_repair_ttl = new DurationSpec.IntSecondsBound(&quot;7d&quot;);

    /**
     * Maintain statistics on whether writes achieve the ideal consistency level
     * before expiring and becoming hints
     */
<span class="fc" id="L550">    public volatile ConsistencyLevel ideal_consistency_level = null;</span>

<span class="fc" id="L552">    @Deprecated</span>
    public int windows_timer_interval = 0;

<span class="fc" id="L555">    @Deprecated</span>
    public String otc_coalescing_strategy = &quot;DISABLED&quot;;

    @Deprecated
    public static final int otc_coalescing_window_us_default = 200;
<span class="fc" id="L560">    @Deprecated</span>
    public int otc_coalescing_window_us = otc_coalescing_window_us_default;
<span class="fc" id="L562">    @Deprecated</span>
    public int otc_coalescing_enough_coalesced_messages = 8;
    @Deprecated
    public static final int otc_backlog_expiration_interval_ms_default = 200;
<span class="fc" id="L566">    @Deprecated</span>
    public volatile int otc_backlog_expiration_interval_ms = otc_backlog_expiration_interval_ms_default;

    /**
     * Size of the CQL prepared statements cache in MiB.
     * Defaults to 1/256th of the heap size or 10MiB, whichever is greater.
     */
<span class="fc" id="L573">    @Replaces(oldName = &quot;prepared_statements_cache_size_mb&quot;, converter = Converters.MEBIBYTES_DATA_STORAGE_LONG, deprecated = true)</span>
    public DataStorageSpec.LongMebibytesBound prepared_statements_cache_size = null;

<span class="fc" id="L576">    @Replaces(oldName = &quot;enable_user_defined_functions&quot;, converter = Converters.IDENTITY, deprecated = true)</span>
    public boolean user_defined_functions_enabled = false;

<span class="fc" id="L579">    @Deprecated</span>
    @Replaces(oldName = &quot;enable_scripted_user_defined_functions&quot;, converter = Converters.IDENTITY, deprecated = true)
    public boolean scripted_user_defined_functions_enabled = false;

<span class="fc" id="L583">    @Replaces(oldName = &quot;enable_materialized_views&quot;, converter = Converters.IDENTITY, deprecated = true)</span>
    public boolean materialized_views_enabled = false;

<span class="fc" id="L586">    @Replaces(oldName = &quot;enable_transient_replication&quot;, converter = Converters.IDENTITY, deprecated = true)</span>
    public boolean transient_replication_enabled = false;

<span class="fc" id="L589">    @Replaces(oldName = &quot;enable_sasi_indexes&quot;, converter = Converters.IDENTITY, deprecated = true)</span>
    public boolean sasi_indexes_enabled = false;

<span class="fc" id="L592">    @Replaces(oldName = &quot;enable_drop_compact_storage&quot;, converter = Converters.IDENTITY, deprecated = true)</span>
    public volatile boolean drop_compact_storage_enabled = false;

<span class="fc" id="L595">    public volatile boolean use_statements_enabled = true;</span>

    /**
     * Optionally disable asynchronous UDF execution.
     * Disabling asynchronous UDF execution also implicitly disables the security-manager!
     * By default, async UDF execution is enabled to be able to detect UDFs that run too long / forever and be
     * able to fail fast - i.e. stop the Cassandra daemon, which is currently the only appropriate approach to
     * &quot;tell&quot; a user that there's something really wrong with the UDF.
     * When you disable async UDF execution, users MUST pay attention to read-timeouts since these may indicate
     * UDFs that run too long or forever - and this can destabilize the cluster.
     *
     * This requires allow_insecure_udfs to be true
     */
    // Below parameter is not presented in cassandra.yaml but to be on the safe side that no one was directly using it
    // I still added backward compatibility (CASSANDRA-15234)
<span class="fc" id="L610">    @Replaces(oldName = &quot;enable_user_defined_functions_threads&quot;, converter = Converters.IDENTITY, deprecated = true)</span>
    public boolean user_defined_functions_threads_enabled = true;

    /**
     * Set this to true to allow running insecure UDFs.
     */
<span class="fc" id="L616">    public boolean allow_insecure_udfs = false;</span>

    /**
     * Set this to allow UDFs accessing java.lang.System.* methods, which basically allows UDFs to execute any arbitrary code on the system.
     */
<span class="fc" id="L621">    public boolean allow_extra_insecure_udfs = false;</span>

<span class="fc" id="L623">    public boolean dynamic_data_masking_enabled = false;</span>

    /**
     * Time in milliseconds after a warning will be emitted to the log and to the client that a UDF runs too long.
     * (Only valid, if user_defined_functions_threads_enabled==true)
     */
<span class="fc" id="L629">    @Replaces(oldName = &quot;user_defined_function_warn_timeout&quot;, converter = Converters.MILLIS_DURATION_LONG, deprecated = true)</span>
    public DurationSpec.LongMillisecondsBound user_defined_functions_warn_timeout = new DurationSpec.LongMillisecondsBound(&quot;500ms&quot;);
    /**
     * Time in milliseconds after a fatal UDF run-time situation is detected and action according to
     * user_function_timeout_policy will take place.
     * (Only valid, if user_defined_functions_threads_enabled==true)
     */
<span class="fc" id="L636">    @Replaces(oldName = &quot;user_defined_function_fail_timeout&quot;, converter = Converters.MILLIS_DURATION_LONG, deprecated = true)</span>
    public DurationSpec.LongMillisecondsBound user_defined_functions_fail_timeout = new DurationSpec.LongMillisecondsBound(&quot;1500ms&quot;);
    /**
     * Defines what to do when a UDF ran longer than user_defined_functions_fail_timeout.
     * Possible options are:
     * - 'die' - i.e. it is able to emit a warning to the client before the Cassandra Daemon will shut down.
     * - 'die_immediate' - shut down C* daemon immediately (effectively prevent the chance that the client will receive a warning).
     * - 'ignore' - just log - the most dangerous option.
     * (Only valid, if user_defined_functions_threads_enabled==true)
     */
<span class="fc" id="L646">    public UserFunctionTimeoutPolicy user_function_timeout_policy = UserFunctionTimeoutPolicy.die;</span>

<span class="fc" id="L648">    @Deprecated</span>
    public volatile boolean back_pressure_enabled = false;
    @Deprecated
    public volatile ParameterizedClass back_pressure_strategy;

    public volatile int concurrent_validations;
<span class="fc" id="L654">    public RepairCommandPoolFullStrategy repair_command_pool_full_strategy = RepairCommandPoolFullStrategy.queue;</span>
<span class="fc" id="L655">    public int repair_command_pool_size = concurrent_validations;</span>

    /**
     * When a node first starts up it intially considers all other peers as DOWN and is disconnected from all of them.
     * To be useful as a coordinator (and not introduce latency penalties on restart) this node must have successfully
     * opened all three internode TCP connections (gossip, small, and large messages) before advertising to clients.
     * Due to this, by default, Casssandra will prime these internode TCP connections and wait for all but a single
     * node to be DOWN/disconnected in the local datacenter before offering itself as a coordinator, subject to a
     * timeout. See CASSANDRA-13993 and CASSANDRA-14297 for more details.
     *
     * We provide two tunables to control this behavior as some users may want to block until all datacenters are
     * available (global QUORUM/EACH_QUORUM), some users may not want to block at all (clients that already work
     * around the problem), and some users may want to prime the connections but not delay startup.
     *
     * block_for_peers_timeout_in_secs: controls how long this node will wait to connect to peers. To completely disable
     * any startup connectivity checks set this to -1. To trigger the internode connections but immediately continue
     * startup, set this to to 0. The default is 10 seconds.
     *
     * block_for_peers_in_remote_dcs: controls if this node will consider remote datacenters to wait for. The default
     * is to _not_ wait on remote datacenters.
     */
<span class="fc" id="L676">    public int block_for_peers_timeout_in_secs = 10;</span>
<span class="fc" id="L677">    public boolean block_for_peers_in_remote_dcs = false;</span>

<span class="fc" id="L679">    public volatile boolean automatic_sstable_upgrade = false;</span>
<span class="fc" id="L680">    public volatile int max_concurrent_automatic_sstable_upgrades = 1;</span>
<span class="fc" id="L681">    public boolean stream_entire_sstables = true;</span>

<span class="fc" id="L683">    public volatile boolean skip_stream_disk_space_check = false;</span>

<span class="fc" id="L685">    public volatile AuditLogOptions audit_logging_options = new AuditLogOptions();</span>
<span class="fc" id="L686">    public volatile FullQueryLoggerOptions full_query_logging_options = new FullQueryLoggerOptions();</span>

<span class="fc" id="L688">    public CorruptedTombstoneStrategy corrupted_tombstone_strategy = CorruptedTombstoneStrategy.disabled;</span>

<span class="fc" id="L690">    public volatile boolean diagnostic_events_enabled = false;</span>

    // Default keyspace replication factors allow validation of newly created keyspaces
    // and good defaults if no replication factor is provided by the user
<span class="fc" id="L694">    public volatile int default_keyspace_rf = 1;</span>

    /**
     * flags for enabling tracking repaired state of data during reads
     * separate flags for range &amp; single partition reads as single partition reads are only tracked
     * when CL &gt; 1 and a digest mismatch occurs. Currently, range queries don't use digests so if
     * enabled for range reads, all such reads will include repaired data tracking. As this adds
     * some overhead, operators may wish to disable it whilst still enabling it for partition reads
     */
<span class="fc" id="L703">    public volatile boolean repaired_data_tracking_for_range_reads_enabled = false;</span>
<span class="fc" id="L704">    public volatile boolean repaired_data_tracking_for_partition_reads_enabled = false;</span>
    /* If true, unconfirmed mismatches (those which cannot be considered conclusive proof of out of
     * sync repaired data due to the presence of pending repair sessions, or unrepaired partition
     * deletes) will increment a metric, distinct from confirmed mismatches. If false, unconfirmed
     * mismatches are simply ignored by the coordinator.
     * This is purely to allow operators to avoid potential signal:noise issues as these types of
     * mismatches are considerably less actionable than their confirmed counterparts. Setting this
     * to true only disables the incrementing of the counters when an unconfirmed mismatch is found
     * and has no other effect on the collection or processing of the repaired data.
     */
<span class="fc" id="L714">    public volatile boolean report_unconfirmed_repaired_data_mismatches = false;</span>
    /*
     * If true, when a repaired data mismatch is detected at read time or during a preview repair,
     * a snapshot request will be issued to each particpating replica. These are limited at the replica level
     * so that only a single snapshot per-table per-day can be taken via this method.
     */
<span class="fc" id="L720">    public volatile boolean snapshot_on_repaired_data_mismatch = false;</span>

    /**
     * Number of seconds to set nowInSec into the future when performing validation previews against repaired data
     * this (attempts) to prevent a race where validations on different machines are started on different sides of
     * a tombstone being compacted away
     */

<span class="fc" id="L728">    @Replaces(oldName = &quot;validation_preview_purge_head_start_in_sec&quot;, converter = Converters.NEGATIVE_SECONDS_DURATION, deprecated = true)</span>
    public volatile DurationSpec.IntSecondsBound validation_preview_purge_head_start = new DurationSpec.IntSecondsBound(&quot;3600s&quot;);

<span class="fc" id="L731">    public boolean auth_cache_warming_enabled = false;</span>

    // Using String instead of ConsistencyLevel here to keep static initialization from cascading and starting
    // threads during tool usage mode. See CASSANDRA-12988 and DatabaseDescriptorRefTest for details
<span class="fc" id="L735">    public volatile String auth_read_consistency_level = &quot;LOCAL_QUORUM&quot;;</span>
<span class="fc" id="L736">    public volatile String auth_write_consistency_level = &quot;EACH_QUORUM&quot;;</span>

    /** This feature allows denying access to operations on certain key partitions, intended for use by operators to
     * provide another tool to manage cluster health vs application access. See CASSANDRA-12106 and CEP-13 for more details.
     */
<span class="fc" id="L741">    public volatile boolean partition_denylist_enabled = false;</span>

<span class="fc" id="L743">    public volatile boolean denylist_writes_enabled = true;</span>

<span class="fc" id="L745">    public volatile boolean denylist_reads_enabled = true;</span>

<span class="fc" id="L747">    public volatile boolean denylist_range_reads_enabled = true;</span>

<span class="fc" id="L749">    public DurationSpec.IntSecondsBound denylist_refresh = new DurationSpec.IntSecondsBound(&quot;600s&quot;);</span>

<span class="fc" id="L751">    public DurationSpec.IntSecondsBound denylist_initial_load_retry = new DurationSpec.IntSecondsBound(&quot;5s&quot;);</span>

    /** We cap the number of denylisted keys allowed per table to keep things from growing unbounded. Operators will
     * receive warnings and only denylist_max_keys_per_table in natural query ordering will be processed on overflow.
     */
<span class="fc" id="L756">    public volatile int denylist_max_keys_per_table = 1000;</span>

    /** We cap the total number of denylisted keys allowed in the cluster to keep things from growing unbounded.
     * Operators will receive warnings on initial cache load that there are too many keys and be directed to trim
     * down the entries to within the configured limits.
     */
<span class="fc" id="L762">    public volatile int denylist_max_keys_total = 10000;</span>

    /** Since the denylist in many ways serves to protect the health of the cluster from partitions operators have identified
     * as being in a bad state, we usually want more robustness than just CL.ONE on operations to/from these tables to
     * ensure that these safeguards are in place. That said, we allow users to configure this if they're so inclined.
     */
<span class="fc" id="L768">    public ConsistencyLevel denylist_consistency_level = ConsistencyLevel.QUORUM;</span>

    /**
     * The intial capacity for creating RangeTombstoneList.
     */
<span class="fc" id="L773">    public volatile int initial_range_tombstone_list_allocation_size = 1;</span>
    /**
     * The growth factor to enlarge a RangeTombstoneList.
     */
<span class="fc" id="L777">    public volatile double range_tombstone_list_growth_factor = 1.5;</span>

<span class="fc" id="L779">    public StorageAttachedIndexOptions sai_options = new StorageAttachedIndexOptions();</span>

    /**
     * @deprecated migrate to {@link DatabaseDescriptor#isClientInitialized()}
     */
    @Deprecated
    public static boolean isClientMode()
    {
<span class="fc" id="L787">        return isClientMode;</span>
    }

    /**
     * If true, when rows with duplicate clustering keys are detected during a read or compaction
     * a snapshot will be taken. In the read case, each a snapshot request will be issued to each
     * replica involved in the query, for compaction the snapshot will be created locally.
     * These are limited at the replica level so that only a single snapshot per-day can be taken
     * via this method.
     *
     * This requires check_for_duplicate_rows_during_reads and/or check_for_duplicate_rows_during_compaction
     * below to be enabled
     */
<span class="fc" id="L800">    public volatile boolean snapshot_on_duplicate_row_detection = false;</span>
    /**
     * If these are enabled duplicate keys will get logged, and if snapshot_on_duplicate_row_detection
     * is enabled, the table will get snapshotted for offline investigation
     */
<span class="fc" id="L805">    public volatile boolean check_for_duplicate_rows_during_reads = true;</span>
<span class="fc" id="L806">    public volatile boolean check_for_duplicate_rows_during_compaction = true;</span>

<span class="fc" id="L808">    public boolean autocompaction_on_startup_enabled = AUTOCOMPACTION_ON_STARTUP_ENABLED.getBoolean();</span>

    // see CASSANDRA-3200 / CASSANDRA-16274
<span class="fc" id="L811">    public volatile boolean auto_optimise_inc_repair_streams = false;</span>
<span class="fc" id="L812">    public volatile boolean auto_optimise_full_repair_streams = false;</span>
<span class="fc" id="L813">    public volatile boolean auto_optimise_preview_repair_streams = false;</span>

    // see CASSANDRA-17048 and the comment in cassandra.yaml
<span class="fc" id="L816">    public boolean uuid_sstable_identifiers_enabled = false;</span>

    /**
     * Client mode means that the process is a pure client, that uses C* code base but does
     * not read or write local C* database files.
     *
     * @deprecated migrate to {@link DatabaseDescriptor#clientInitialization(boolean)}
     */
    @Deprecated
    public static void setClientMode(boolean clientMode)
    {
<span class="nc" id="L827">        isClientMode = clientMode;</span>
<span class="nc" id="L828">    }</span>

<span class="fc" id="L830">    public volatile int consecutive_message_errors_threshold = 1;</span>

<span class="fc" id="L832">    public volatile SubnetGroups client_error_reporting_exclusions = new SubnetGroups();</span>
<span class="fc" id="L833">    public volatile SubnetGroups internode_error_reporting_exclusions = new SubnetGroups();</span>

<span class="fc" id="L835">    @Replaces(oldName = &quot;keyspace_count_warn_threshold&quot;, converter = Converters.KEYSPACE_COUNT_THRESHOLD_TO_GUARDRAIL, deprecated = true)</span>
    public volatile int keyspaces_warn_threshold = -1;
<span class="fc" id="L837">    public volatile int keyspaces_fail_threshold = -1;</span>
<span class="fc" id="L838">    @Replaces(oldName = &quot;table_count_warn_threshold&quot;, converter = Converters.TABLE_COUNT_THRESHOLD_TO_GUARDRAIL, deprecated = true)</span>
    public volatile int tables_warn_threshold = -1;
<span class="fc" id="L840">    public volatile int tables_fail_threshold = -1;</span>
<span class="fc" id="L841">    public volatile int columns_per_table_warn_threshold = -1;</span>
<span class="fc" id="L842">    public volatile int columns_per_table_fail_threshold = -1;</span>
<span class="fc" id="L843">    public volatile int secondary_indexes_per_table_warn_threshold = -1;</span>
<span class="fc" id="L844">    public volatile int secondary_indexes_per_table_fail_threshold = -1;</span>
<span class="fc" id="L845">    public volatile int materialized_views_per_table_warn_threshold = -1;</span>
<span class="fc" id="L846">    public volatile int materialized_views_per_table_fail_threshold = -1;</span>
<span class="fc" id="L847">    public volatile int page_size_warn_threshold = -1;</span>
<span class="fc" id="L848">    public volatile int page_size_fail_threshold = -1;</span>
<span class="fc" id="L849">    public volatile int partition_keys_in_select_warn_threshold = -1;</span>
<span class="fc" id="L850">    public volatile int partition_keys_in_select_fail_threshold = -1;</span>
<span class="fc" id="L851">    public volatile int in_select_cartesian_product_warn_threshold = -1;</span>
<span class="fc" id="L852">    public volatile int in_select_cartesian_product_fail_threshold = -1;</span>
<span class="fc" id="L853">    public volatile Set&lt;String&gt; table_properties_warned = Collections.emptySet();</span>
<span class="fc" id="L854">    public volatile Set&lt;String&gt; table_properties_ignored = Collections.emptySet();</span>
<span class="fc" id="L855">    public volatile Set&lt;String&gt; table_properties_disallowed = Collections.emptySet();</span>
<span class="fc" id="L856">    public volatile Set&lt;ConsistencyLevel&gt; read_consistency_levels_warned = Collections.emptySet();</span>
<span class="fc" id="L857">    public volatile Set&lt;ConsistencyLevel&gt; read_consistency_levels_disallowed = Collections.emptySet();</span>
<span class="fc" id="L858">    public volatile Set&lt;ConsistencyLevel&gt; write_consistency_levels_warned = Collections.emptySet();</span>
<span class="fc" id="L859">    public volatile Set&lt;ConsistencyLevel&gt; write_consistency_levels_disallowed = Collections.emptySet();</span>
<span class="fc" id="L860">    public volatile boolean user_timestamps_enabled = true;</span>
<span class="fc" id="L861">    public volatile boolean alter_table_enabled = true;</span>
<span class="fc" id="L862">    public volatile boolean group_by_enabled = true;</span>
<span class="fc" id="L863">    public volatile boolean bulk_load_enabled = true;</span>
<span class="fc" id="L864">    public volatile boolean drop_truncate_table_enabled = true;</span>
<span class="fc" id="L865">    public volatile boolean drop_keyspace_enabled = true;</span>
<span class="fc" id="L866">    public volatile boolean secondary_indexes_enabled = true;</span>

<span class="fc" id="L868">    public volatile String default_secondary_index = CassandraIndex.NAME;</span>
<span class="fc" id="L869">    public volatile boolean default_secondary_index_enabled = true;</span>

<span class="fc" id="L871">    public volatile boolean uncompressed_tables_enabled = true;</span>
<span class="fc" id="L872">    public volatile boolean compact_tables_enabled = true;</span>
<span class="fc" id="L873">    public volatile boolean read_before_write_list_operations_enabled = true;</span>
<span class="fc" id="L874">    public volatile boolean allow_filtering_enabled = true;</span>
<span class="fc" id="L875">    public volatile boolean simplestrategy_enabled = true;</span>
<span class="fc" id="L876">    @Replaces(oldName = &quot;compaction_large_partition_warning_threshold_mb&quot;, converter = Converters.LONG_BYTES_DATASTORAGE_MEBIBYTES_INT, deprecated = true)</span>
    @Replaces(oldName = &quot;compaction_large_partition_warning_threshold&quot;, converter = Converters.LONG_BYTES_DATASTORAGE_MEBIBYTES_DATASTORAGE, deprecated = true)
    public volatile DataStorageSpec.LongBytesBound partition_size_warn_threshold = null;
<span class="fc" id="L879">    public volatile DataStorageSpec.LongBytesBound partition_size_fail_threshold = null;</span>
<span class="fc" id="L880">    @Replaces(oldName = &quot;compaction_tombstone_warning_threshold&quot;, converter = Converters.INTEGER_PRIMITIVE_LONG, deprecated = true)</span>
    public volatile long partition_tombstones_warn_threshold = -1;
<span class="fc" id="L882">    public volatile long partition_tombstones_fail_threshold = -1;</span>
<span class="fc" id="L883">    public volatile DataStorageSpec.LongBytesBound column_value_size_warn_threshold = null;</span>
<span class="fc" id="L884">    public volatile DataStorageSpec.LongBytesBound column_value_size_fail_threshold = null;</span>
<span class="fc" id="L885">    public volatile DataStorageSpec.LongBytesBound collection_size_warn_threshold = null;</span>
<span class="fc" id="L886">    public volatile DataStorageSpec.LongBytesBound collection_size_fail_threshold = null;</span>
<span class="fc" id="L887">    public volatile int items_per_collection_warn_threshold = -1;</span>
<span class="fc" id="L888">    public volatile int items_per_collection_fail_threshold = -1;</span>
<span class="fc" id="L889">    public volatile int fields_per_udt_warn_threshold = -1;</span>
<span class="fc" id="L890">    public volatile int fields_per_udt_fail_threshold = -1;</span>
<span class="fc" id="L891">    public volatile int vector_dimensions_warn_threshold = -1;</span>
<span class="fc" id="L892">    public volatile int vector_dimensions_fail_threshold = -1;</span>
<span class="fc" id="L893">    public volatile int data_disk_usage_percentage_warn_threshold = -1;</span>
<span class="fc" id="L894">    public volatile int data_disk_usage_percentage_fail_threshold = -1;</span>
<span class="fc" id="L895">    public volatile DataStorageSpec.LongBytesBound data_disk_usage_max_disk_size = null;</span>
<span class="fc" id="L896">    public volatile int minimum_replication_factor_warn_threshold = -1;</span>
<span class="fc" id="L897">    public volatile int minimum_replication_factor_fail_threshold = -1;</span>
<span class="fc" id="L898">    public volatile int maximum_replication_factor_warn_threshold = -1;</span>
<span class="fc" id="L899">    public volatile int maximum_replication_factor_fail_threshold = -1;</span>
<span class="fc" id="L900">    public volatile boolean zero_ttl_on_twcs_warned = true;</span>
<span class="fc" id="L901">    public volatile boolean zero_ttl_on_twcs_enabled = true;</span>

<span class="fc" id="L903">    public volatile DurationSpec.LongNanosecondsBound streaming_state_expires = new DurationSpec.LongNanosecondsBound(&quot;3d&quot;);</span>
<span class="fc" id="L904">    public volatile DataStorageSpec.LongBytesBound streaming_state_size = new DataStorageSpec.LongBytesBound(&quot;40MiB&quot;);</span>

<span class="fc" id="L906">    public volatile boolean streaming_stats_enabled = true;</span>
<span class="fc" id="L907">    public volatile DurationSpec.IntSecondsBound streaming_slow_events_log_timeout = new DurationSpec.IntSecondsBound(&quot;10s&quot;);</span>

    /** The configuration of startup checks. */
<span class="fc" id="L910">    public volatile Map&lt;StartupCheckType, Map&lt;String, Object&gt;&gt; startup_checks = new HashMap&lt;&gt;();</span>

<span class="fc" id="L912">    public volatile DurationSpec.LongNanosecondsBound repair_state_expires = new DurationSpec.LongNanosecondsBound(&quot;3d&quot;);</span>
<span class="fc" id="L913">    public volatile int repair_state_size = 100_000;</span>

    /** The configuration of timestamp bounds */
<span class="fc" id="L916">    public volatile DurationSpec.LongMicrosecondsBound maximum_timestamp_warn_threshold = null;</span>
<span class="fc" id="L917">    public volatile DurationSpec.LongMicrosecondsBound maximum_timestamp_fail_threshold = null;</span>
<span class="fc" id="L918">    public volatile DurationSpec.LongMicrosecondsBound minimum_timestamp_warn_threshold = null;</span>
<span class="fc" id="L919">    public volatile DurationSpec.LongMicrosecondsBound minimum_timestamp_fail_threshold = null;</span>

    /**
     * The variants of paxos implementation and semantics supported by Cassandra.
     */
<span class="fc" id="L924">    public enum PaxosVariant</span>
    {
        /**
         * v1 Paxos lacks most optimisations. Expect 4RTs for a write and 2RTs for a read.
         *
         * With legacy semantics for read/read and rejected write linearizability, i.e. not guaranteed.
         */
<span class="fc" id="L931">        v1_without_linearizable_reads_or_rejected_writes,</span>

        /**
         * v1 Paxos lacks most optimisations. Expect 4RTs for a write and 3RTs for a read.
         */
<span class="fc" id="L936">        v1,</span>

        /**
         * v2 Paxos. With PaxosStatePurging.repaired safe to use ANY Commit consistency.
         * Expect 2RTs for a write and 1RT for a read.
         *
         * With legacy semantics for read/read linearizability, i.e. not guaranteed.
         */
<span class="fc" id="L944">        v2_without_linearizable_reads,</span>

        /**
         * v2 Paxos. With PaxosStatePurging.repaired safe to use ANY Commit consistency.
         * Expect 2RTs for a write and 1RT for a read.
         *
         * With legacy semantics for read/read and rejected write linearizability, i.e. not guaranteed.
         */
<span class="fc" id="L952">        v2_without_linearizable_reads_or_rejected_writes,</span>

        /**
         * v2 Paxos. With PaxosStatePurging.repaired safe to use ANY Commit consistency.
         * Expect 2RTs for a write, and either 1RT or 2RT for a read.
         */
<span class="fc" id="L958">        v2</span>
    }

    /**
     * Select the kind of paxos state purging to use. Migration to repaired is recommended, but requires that
     * regular paxos repairs are performed (which by default run as part of incremental repair).
     *
     * Once migrated from legacy it is unsafe to return to legacy, but gc_grace mode may be used in its place
     * and performs a very similar cleanup process.
     *
     * Should only be modified once paxos_variant = v2.
     */
<span class="fc" id="L970">    public enum PaxosStatePurging</span>
    {
        /**
         * system.paxos records are written and garbage collected with TTLs. Unsafe to use with Commit consistency ANY.
         * Once migrated from, cannot be migrated back to safely. Must use gc_grace or repaired instead, as TTLs
         * will not have been set.
         */
<span class="fc" id="L977">        legacy,</span>

        /**
         * Functionally similar to legacy, but the gc_grace expiry is applied at compaction and read time rather than
         * using TTLs, so may be safely enabled at any point.
         */
<span class="fc" id="L983">        gc_grace,</span>

        /**
         * Clears system.paxos records only once they are known to be persisted to a quorum of replica's base tables
         * through the use of paxos repair. Requires that regular paxos repairs are performed on the cluster
         * (which by default are included in incremental repairs if paxos_variant = v2).
         *
         * This setting permits the use of Commit consistency ANY or LOCAL_QUORUM without any loss of durability or consistency,
         * saving 1 RT.
         */
<span class="fc" id="L993">        repaired;</span>

        public static PaxosStatePurging fromBoolean(boolean enabled)
        {
<span class="nc bnc" id="L997" title="All 2 branches missed.">            return enabled ? repaired : gc_grace;</span>
        }
    }

    /**
     * See {@link PaxosVariant}. Defaults to v1, recommend upgrading to v2 at earliest opportunity.
     */
<span class="fc" id="L1004">    public volatile PaxosVariant paxos_variant = PaxosVariant.v1;</span>

    /**
     * If true, paxos topology change repair will not run on a topology change - this option should only be used in
     * rare operation circumstances e.g. where for some reason the repair is impossible to perform (e.g. too few replicas)
     * and an unsafe topology change must be made
     */
<span class="fc" id="L1011">    public volatile boolean skip_paxos_repair_on_topology_change = SKIP_PAXOS_REPAIR_ON_TOPOLOGY_CHANGE.getBoolean();</span>

    /**
     * A safety margin when purging paxos state information that has been safely replicated to a quorum.
     * Data for transactions initiated within this grace period will not be expunged.
     */
<span class="fc" id="L1017">    public volatile DurationSpec.LongSecondsBound paxos_purge_grace_period = new DurationSpec.LongSecondsBound(&quot;60s&quot;);</span>

    /**
     * A safety mechanism for detecting incorrect paxos state, that may be down either to a bug or incorrect usage of LWTs
     * (most likely due to unsafe mixing of SERIAL and LOCAL_SERIAL operations), and rejecting
     */
<span class="fc" id="L1023">    public enum PaxosOnLinearizabilityViolation</span>
    {
        // reject an operation when a linearizability violation is detected.
        // note this does not guarantee a violation has been averted,
        // as it may be a prior operation that invalidated the state.
<span class="fc" id="L1028">        fail,</span>
        // log any detected linearizability violation
<span class="fc" id="L1030">        log,</span>
        // ignore any detected linearizability violation
<span class="fc" id="L1032">        ignore</span>
    }

    /**
     * See {@link PaxosOnLinearizabilityViolation}.
     *
     * Default is to ignore, as applications may readily mix SERIAL and LOCAL_SERIAL and this is the most likely source
     * of linearizability violations. this facility should be activated only for debugging Cassandra or by power users
     * who are investigating their own application behaviour.
     */
<span class="fc" id="L1042">    public volatile PaxosOnLinearizabilityViolation paxos_on_linearizability_violations = PaxosOnLinearizabilityViolation.ignore;</span>

    /**
     * See {@link PaxosStatePurging} default is legacy.
     */
    public volatile PaxosStatePurging paxos_state_purging;

    /**
     * Enable/disable paxos repair. This is a global flag that not only determines default behaviour but overrides
     * explicit paxos repair requests, paxos repair on topology changes and paxos auto repairs.
     */
<span class="fc" id="L1053">    public volatile boolean paxos_repair_enabled = true;</span>

    /**
     * If true, paxos topology change repair only requires a global quorum of live nodes. If false,
     * it requires a global quorum as well as a local quorum for each dc (EACH_QUORUM), with the
     * exception explained in paxos_topology_repair_strict_each_quorum
     */
<span class="fc" id="L1060">    public boolean paxos_topology_repair_no_dc_checks = false;</span>

    /**
     * If true, a quorum will be required for the global and local quorum checks. If false, we will
     * accept a quorum OR n - 1 live nodes. This is to allow for topologies like 2:2:2, where paxos queries
     * always use SERIAL, and a single node down in a dc should not preclude a paxos repair
     */
<span class="fc" id="L1067">    public boolean paxos_topology_repair_strict_each_quorum = false;</span>

    /**
     * If necessary for operational purposes, permit certain keyspaces to be ignored for paxos topology repairs
     */
<span class="fc" id="L1072">    public volatile Set&lt;String&gt; skip_paxos_repair_on_topology_change_keyspaces = splitCommaDelimited(SKIP_PAXOS_REPAIR_ON_TOPOLOGY_CHANGE_KEYSPACES.getString());</span>

    /**
     * See {@link org.apache.cassandra.service.paxos.ContentionStrategy}
     */
    public String paxos_contention_wait_randomizer;

    /**
     * See {@link org.apache.cassandra.service.paxos.ContentionStrategy}
     */
    public String paxos_contention_min_wait;

    /**
     * See {@link org.apache.cassandra.service.paxos.ContentionStrategy}
     */
    public String paxos_contention_max_wait;

    /**
     * See {@link org.apache.cassandra.service.paxos.ContentionStrategy}
     */
    public String paxos_contention_min_delta;

    /**
     * The number of keys we may simultaneously attempt to finish incomplete paxos operations for.
     */
<span class="fc" id="L1097">    public volatile int paxos_repair_parallelism = -1;</span>

<span class="fc" id="L1099">    public volatile boolean sstable_read_rate_persistence_enabled = false;</span>

<span class="fc" id="L1101">    public volatile boolean client_request_size_metrics_enabled = true;</span>

<span class="fc" id="L1103">    public volatile int max_top_size_partition_count = 10;</span>
<span class="fc" id="L1104">    public volatile int max_top_tombstone_partition_count = 10;</span>
<span class="fc" id="L1105">    public volatile DataStorageSpec.LongBytesBound min_tracked_partition_size = new DataStorageSpec.LongBytesBound(&quot;1MiB&quot;);</span>
<span class="fc" id="L1106">    public volatile long min_tracked_partition_tombstone_count = 5000;</span>
<span class="fc" id="L1107">    public volatile boolean top_partitions_enabled = true;</span>

<span class="fc" id="L1109">    public final RepairConfig repair = new RepairConfig();</span>

    /**
     * Default compaction configuration, used if a table does not specify any.
     */
<span class="fc" id="L1114">    public ParameterizedClass default_compaction = null;</span>

    public static Supplier&lt;Config&gt; getOverrideLoadConfig()
    {
<span class="fc" id="L1118">        return overrideLoadConfig;</span>
    }

    public static void setOverrideLoadConfig(Supplier&lt;Config&gt; loadConfig)
    {
<span class="nc" id="L1123">        overrideLoadConfig = loadConfig;</span>
<span class="nc" id="L1124">    }</span>

<span class="fc" id="L1126">    public enum CommitLogSync</span>
    {
<span class="fc" id="L1128">        periodic,</span>
<span class="fc" id="L1129">        batch,</span>
<span class="fc" id="L1130">        group</span>
    }

<span class="fc" id="L1133">    public enum FlushCompression</span>
    {
<span class="fc" id="L1135">        none,</span>
<span class="fc" id="L1136">        fast,</span>
<span class="fc" id="L1137">        table</span>
    }

<span class="fc" id="L1140">    public enum InternodeCompression</span>
    {
<span class="fc" id="L1142">        all, none, dc</span>
    }

<span class="fc" id="L1145">    public enum DiskAccessMode</span>
    {
<span class="fc" id="L1147">        auto,</span>
<span class="fc" id="L1148">        mmap,</span>
<span class="fc" id="L1149">        mmap_index_only,</span>
<span class="fc" id="L1150">        standard,</span>
    }

<span class="fc" id="L1153">    public enum MemtableAllocationType</span>
    {
<span class="fc" id="L1155">        unslabbed_heap_buffers,</span>
<span class="fc" id="L1156">        unslabbed_heap_buffers_logged,</span>
<span class="fc" id="L1157">        heap_buffers,</span>
<span class="fc" id="L1158">        offheap_buffers,</span>
<span class="fc" id="L1159">        offheap_objects</span>
    }

<span class="fc" id="L1162">    public enum DiskFailurePolicy</span>
    {
<span class="fc" id="L1164">        best_effort,</span>
<span class="fc" id="L1165">        stop,</span>
<span class="fc" id="L1166">        ignore,</span>
<span class="fc" id="L1167">        stop_paranoid,</span>
<span class="fc" id="L1168">        die</span>
    }

<span class="fc" id="L1171">    public enum CommitFailurePolicy</span>
    {
<span class="fc" id="L1173">        stop,</span>
<span class="fc" id="L1174">        stop_commit,</span>
<span class="fc" id="L1175">        ignore,</span>
<span class="fc" id="L1176">        die,</span>
    }

<span class="fc" id="L1179">    public enum UserFunctionTimeoutPolicy</span>
    {
<span class="fc" id="L1181">        ignore,</span>
<span class="fc" id="L1182">        die,</span>
<span class="fc" id="L1183">        die_immediate</span>
    }

<span class="fc" id="L1186">    public enum DiskOptimizationStrategy</span>
    {
<span class="fc" id="L1188">        ssd,</span>
<span class="fc" id="L1189">        spinning</span>
    }

<span class="fc" id="L1192">    public enum RepairCommandPoolFullStrategy</span>
    {
<span class="fc" id="L1194">        queue,</span>
<span class="fc" id="L1195">        reject</span>
    }

<span class="fc" id="L1198">    public enum CorruptedTombstoneStrategy</span>
    {
<span class="fc" id="L1200">        disabled,</span>
<span class="fc" id="L1201">        warn,</span>
<span class="fc" id="L1202">        exception</span>
    }

<span class="fc" id="L1205">    private static final Set&lt;String&gt; SENSITIVE_KEYS = new HashSet&lt;String&gt;() {{</span>
<span class="fc" id="L1206">        add(&quot;client_encryption_options&quot;);</span>
<span class="fc" id="L1207">        add(&quot;server_encryption_options&quot;);</span>
<span class="fc" id="L1208">    }};</span>

    public static void log(Config config)
    {
<span class="fc" id="L1212">        Map&lt;String, String&gt; configMap = new TreeMap&lt;&gt;();</span>
<span class="fc bfc" id="L1213" title="All 2 branches covered.">        for (Field field : Config.class.getFields())</span>
        {
            // ignore the constants
<span class="fc bfc" id="L1216" title="All 2 branches covered.">            if (Modifier.isFinal(field.getModifiers()))</span>
<span class="fc" id="L1217">                continue;</span>

<span class="fc" id="L1219">            String name = field.getName();</span>
<span class="fc bfc" id="L1220" title="All 2 branches covered.">            if (SENSITIVE_KEYS.contains(name))</span>
            {
<span class="fc" id="L1222">                configMap.put(name, &quot;&lt;REDACTED&gt;&quot;);</span>
<span class="fc" id="L1223">                continue;</span>
            }

            String value;
            try
            {
                // Field.get() can throw NPE if the value of the field is null
<span class="fc" id="L1230">                value = field.get(config).toString();</span>
            }
<span class="fc" id="L1232">            catch (NullPointerException | IllegalAccessException npe)</span>
            {
<span class="fc" id="L1234">                value = &quot;null&quot;;</span>
<span class="fc" id="L1235">            }</span>
<span class="fc" id="L1236">            configMap.put(name, value);</span>
        }

<span class="fc" id="L1239">        logger.info(&quot;Node configuration:[{}]&quot;, Joiner.on(&quot;; &quot;).join(configMap.entrySet()));</span>
<span class="fc" id="L1240">    }</span>

<span class="fc" id="L1242">    public volatile boolean dump_heap_on_uncaught_exception = false;</span>
<span class="fc" id="L1243">    public String heap_dump_path = &quot;heapdump&quot;;</span>


<span class="fc" id="L1246">    public double severity_during_decommission = 0;</span>

<span class="fc" id="L1248">    public StorageCompatibilityMode storage_compatibility_mode = StorageCompatibilityMode.CASSANDRA_4;</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>