<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TupleType.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.marshal</a> &gt; <span class="el_source">TupleType.java</span></div><h1>TupleType.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.marshal;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.regex.Pattern;

import com.google.common.base.Objects;
import com.google.common.collect.Lists;

import org.apache.cassandra.cql3.*;
import org.apache.cassandra.db.TypeSizes;
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.exceptions.SyntaxException;
import org.apache.cassandra.serializers.*;
import org.apache.cassandra.transport.ProtocolVersion;
import org.apache.cassandra.utils.JsonUtils;
import org.apache.cassandra.utils.bytecomparable.ByteComparable;
import org.apache.cassandra.utils.bytecomparable.ByteSource;
import org.apache.cassandra.utils.bytecomparable.ByteSourceInverse;

import static com.google.common.collect.Iterables.any;
import static com.google.common.collect.Iterables.transform;

/**
 * This is essentially like a CompositeType, but it's not primarily meant for comparison, just
 * to pack multiple values together so has a more friendly encoding.
 */
public class TupleType extends AbstractType&lt;ByteBuffer&gt;
{
    private static final String COLON = &quot;:&quot;;
<span class="fc" id="L51">    private static final Pattern COLON_PAT = Pattern.compile(COLON);</span>
    private static final String ESCAPED_COLON = &quot;\\\\:&quot;;
<span class="fc" id="L53">    private static final Pattern ESCAPED_COLON_PAT = Pattern.compile(ESCAPED_COLON);</span>
    private static final String AT = &quot;@&quot;;
<span class="fc" id="L55">    private static final Pattern AT_PAT = Pattern.compile(AT);</span>
    private static final String ESCAPED_AT = &quot;\\\\@&quot;;
<span class="fc" id="L57">    private static final Pattern ESCAPED_AT_PAT = Pattern.compile(ESCAPED_AT);</span>
    
    protected final List&lt;AbstractType&lt;?&gt;&gt; types;

    private final TupleSerializer serializer;

    public TupleType(List&lt;AbstractType&lt;?&gt;&gt; types)
    {
<span class="fc" id="L65">        this(types, true);</span>
<span class="fc" id="L66">    }</span>

    protected TupleType(List&lt;AbstractType&lt;?&gt;&gt; types, boolean freezeInner)
    {
<span class="fc" id="L70">        super(ComparisonType.CUSTOM);</span>

<span class="fc bfc" id="L72" title="All 2 branches covered.">        if (freezeInner)</span>
<span class="fc" id="L73">            this.types = Lists.newArrayList(transform(types, AbstractType::freeze));</span>
        else
<span class="fc" id="L75">            this.types = types;</span>
<span class="fc" id="L76">        this.serializer = new TupleSerializer(fieldSerializers(types));</span>
<span class="fc" id="L77">    }</span>

    private static List&lt;TypeSerializer&lt;?&gt;&gt; fieldSerializers(List&lt;AbstractType&lt;?&gt;&gt; types)
    {
<span class="fc" id="L81">        int size = types.size();</span>
<span class="fc" id="L82">        List&lt;TypeSerializer&lt;?&gt;&gt; serializers = new ArrayList&lt;&gt;(size);</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++)</span>
<span class="fc" id="L84">            serializers.add(types.get(i).getSerializer());</span>
<span class="fc" id="L85">        return serializers;</span>
    }

    public static TupleType getInstance(TypeParser parser) throws ConfigurationException, SyntaxException
    {
<span class="nc" id="L90">        List&lt;AbstractType&lt;?&gt;&gt; types = parser.getTypeParameters();</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">        for (int i = 0; i &lt; types.size(); i++)</span>
<span class="nc" id="L92">            types.set(i, types.get(i).freeze());</span>
<span class="nc" id="L93">        return new TupleType(types);</span>
    }

    @Override
    public &lt;V&gt; boolean referencesUserType(V name, ValueAccessor&lt;V&gt; accessor)
    {
<span class="nc" id="L99">        return any(types, t -&gt; t.referencesUserType(name, accessor));</span>
    }

    @Override
    public TupleType withUpdatedUserType(UserType udt)
    {
<span class="nc bnc" id="L105" title="All 2 branches missed.">        return referencesUserType(udt.name)</span>
<span class="nc" id="L106">             ? new TupleType(Lists.newArrayList(transform(types, t -&gt; t.withUpdatedUserType(udt))))</span>
<span class="nc" id="L107">             : this;</span>
    }

    @Override
    public AbstractType&lt;?&gt; expandUserTypes()
    {
<span class="nc" id="L113">        return new TupleType(Lists.newArrayList(transform(types, AbstractType::expandUserTypes)));</span>
    }

    @Override
    public boolean referencesDuration()
    {
<span class="nc" id="L119">        return allTypes().stream().anyMatch(f -&gt; f.referencesDuration());</span>
    }

    public AbstractType&lt;?&gt; type(int i)
    {
<span class="fc" id="L124">        return types.get(i);</span>
    }

    public int size()
    {
<span class="fc" id="L129">        return types.size();</span>
    }

    @Override
    public List&lt;AbstractType&lt;?&gt;&gt; subTypes()
    {
<span class="fc" id="L135">        return types;</span>
    }

    public List&lt;AbstractType&lt;?&gt;&gt; allTypes()
    {
<span class="nc" id="L140">        return types;</span>
    }

    public boolean isTuple()
    {
<span class="nc" id="L145">        return true;</span>
    }

    public &lt;VL, VR&gt; int compareCustom(VL left, ValueAccessor&lt;VL&gt; accessorL, VR right, ValueAccessor&lt;VR&gt; accessorR)
    {
<span class="pc bpc" id="L150" title="2 of 4 branches missed.">        if (accessorL.isEmpty(left) || accessorR.isEmpty(right))</span>
<span class="nc" id="L151">            return Boolean.compare(accessorR.isEmpty(right), accessorL.isEmpty(left));</span>

<span class="fc" id="L153">        int offsetL = 0;</span>
<span class="fc" id="L154">        int offsetR = 0;</span>

<span class="pc bpc" id="L156" title="2 of 6 branches missed.">        for (int i = 0; !accessorL.isEmptyFromOffset(left, offsetL) &amp;&amp; !accessorR.isEmptyFromOffset(right, offsetR) &amp;&amp; i &lt; types.size(); i++)</span>
        {
<span class="fc" id="L158">            AbstractType&lt;?&gt; comparator = types.get(i);</span>

<span class="fc" id="L160">            int sizeL = accessorL.getInt(left, offsetL);</span>
<span class="fc" id="L161">            offsetL += TypeSizes.INT_SIZE;</span>
<span class="fc" id="L162">            int sizeR = accessorR.getInt(right, offsetR);</span>
<span class="fc" id="L163">            offsetR += TypeSizes.INT_SIZE;</span>

            // Handle nulls
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">            if (sizeL &lt; 0)</span>
            {
<span class="nc bnc" id="L168" title="All 2 branches missed.">                if (sizeR &lt; 0)</span>
<span class="nc" id="L169">                    continue;</span>
<span class="nc" id="L170">                return -1;</span>
            }
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">            if (sizeR &lt; 0)</span>
<span class="nc" id="L173">                return 1;</span>

<span class="fc" id="L175">            VL valueL = accessorL.slice(left, offsetL, sizeL);</span>
<span class="fc" id="L176">            offsetL += sizeL;</span>
<span class="fc" id="L177">            VR valueR = accessorR.slice(right, offsetR, sizeR);</span>
<span class="fc" id="L178">            offsetR += sizeR;</span>
<span class="fc" id="L179">            int cmp = comparator.compare(valueL, accessorL, valueR, accessorR);</span>
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">            if (cmp != 0)</span>
<span class="nc" id="L181">                return cmp;</span>
        }

<span class="pc bpc" id="L184" title="2 of 4 branches missed.">        if (allRemainingComponentsAreNull(left, accessorL, offsetL) &amp;&amp; allRemainingComponentsAreNull(right, accessorR, offsetR))</span>
<span class="fc" id="L185">            return 0;</span>

<span class="nc bnc" id="L187" title="All 2 branches missed.">        if (accessorL.isEmptyFromOffset(left, offsetL))</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">            return allRemainingComponentsAreNull(right, accessorR, offsetR) ? 0 : -1;</span>

<span class="nc bnc" id="L190" title="All 2 branches missed.">        return allRemainingComponentsAreNull(left, accessorL, offsetL) ? 0 : 1;</span>
    }

    private &lt;T&gt; boolean allRemainingComponentsAreNull(T v, ValueAccessor&lt;T&gt; accessor, int offset)
    {
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">        while (!accessor.isEmptyFromOffset(v, offset))</span>
        {
<span class="nc" id="L197">            int size = accessor.getInt(v, offset);</span>
<span class="nc" id="L198">            offset += TypeSizes.INT_SIZE;</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">            if (size &gt;= 0)</span>
<span class="nc" id="L200">                return false;</span>
<span class="nc" id="L201">        }</span>
<span class="fc" id="L202">        return true;</span>
    }

    @Override
    public &lt;V&gt; ByteSource asComparableBytes(ValueAccessor&lt;V&gt; accessor, V data, ByteComparable.Version version)
    {
<span class="nc bnc" id="L208" title="All 3 branches missed.">        switch (version)</span>
        {
            case LEGACY:
<span class="nc" id="L211">                return asComparableBytesLegacy(accessor, data);</span>
            case OSS50:
<span class="nc" id="L213">                return asComparableBytesNew(accessor, data, version);</span>
            default:
<span class="nc" id="L215">                throw new AssertionError();</span>
        }
    }

    private &lt;V&gt; ByteSource asComparableBytesLegacy(ValueAccessor&lt;V&gt; accessor, V data)
    {
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (accessor.isEmpty(data))</span>
<span class="nc" id="L222">            return null;</span>

<span class="nc" id="L224">        V[] bufs = split(accessor, data);  // this may be shorter than types.size -- other srcs remain null in that case</span>
<span class="nc" id="L225">        ByteSource[] srcs = new ByteSource[types.size()];</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">        for (int i = 0; i &lt; bufs.length; ++i)</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">            srcs[i] = bufs[i] != null ? types.get(i).asComparableBytes(accessor, bufs[i], ByteComparable.Version.LEGACY) : null;</span>

        // We always have a fixed number of sources, with the trailing ones possibly being nulls.
        // This can only result in a prefix if the last type in the tuple allows prefixes. Since that type is required
        // to be weakly prefix-free, so is the tuple.
<span class="nc" id="L232">        return ByteSource.withTerminatorLegacy(ByteSource.END_OF_STREAM, srcs);</span>
    }

    private &lt;V&gt; ByteSource asComparableBytesNew(ValueAccessor&lt;V&gt; accessor, V data, ByteComparable.Version version)
    {
<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (accessor.isEmpty(data))</span>
<span class="nc" id="L238">            return null;</span>

<span class="nc" id="L240">        V[] bufs = split(accessor, data);</span>
<span class="nc" id="L241">        int lengthWithoutTrailingNulls = 0;</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">        for (int i = 0; i &lt; bufs.length; ++i)</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">            if (bufs[i] != null)</span>
<span class="nc" id="L244">                lengthWithoutTrailingNulls = i + 1;</span>

<span class="nc" id="L246">        ByteSource[] srcs = new ByteSource[lengthWithoutTrailingNulls];</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">        for (int i = 0; i &lt; lengthWithoutTrailingNulls; ++i)</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">            srcs[i] = bufs[i] != null ? types.get(i).asComparableBytes(accessor, bufs[i], version) : null;</span>

        // Because we stop early when there are trailing nulls, there needs to be an explicit terminator to make the
        // type prefix-free.
<span class="nc" id="L252">        return ByteSource.withTerminator(ByteSource.TERMINATOR, srcs);</span>
    }

    @Override
    public &lt;V&gt; V fromComparableBytes(ValueAccessor&lt;V&gt; accessor, ByteSource.Peekable comparableBytes, ByteComparable.Version version)
    {
<span class="nc bnc" id="L258" title="All 2 branches missed.">        assert version == ByteComparable.Version.OSS50; // Reverse translation is not supported for the legacy version.</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">        if (comparableBytes == null)</span>
<span class="nc" id="L260">            return accessor.empty();</span>

<span class="nc" id="L262">        V[] componentBuffers = accessor.createArray(types.size());</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">        for (int i = 0; i &lt; types.size(); ++i)</span>
        {
<span class="nc bnc" id="L265" title="All 2 branches missed.">            if (comparableBytes.peek() == ByteSource.TERMINATOR)</span>
<span class="nc" id="L266">                break;  // the rest of the fields remain null</span>
<span class="nc" id="L267">            AbstractType&lt;?&gt; componentType = types.get(i);</span>
<span class="nc" id="L268">            ByteSource.Peekable component = ByteSourceInverse.nextComponentSource(comparableBytes);</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">            if (component != null)</span>
<span class="nc" id="L270">                componentBuffers[i] = componentType.fromComparableBytes(accessor, component, version);</span>
            else
<span class="nc" id="L272">                componentBuffers[i] = null;</span>
        }
        // consume terminator
<span class="nc" id="L275">        int terminator = comparableBytes.next();</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">        assert terminator == ByteSource.TERMINATOR : String.format(&quot;Expected TERMINATOR (0x%2x) after %d components&quot;,</span>
<span class="nc" id="L277">                                                                   ByteSource.TERMINATOR,</span>
<span class="nc" id="L278">                                                                   types.size());</span>
<span class="nc" id="L279">        return buildValue(accessor, componentBuffers);</span>
    }

    /**
     * Split a tuple value into its component values.
     */
    public &lt;V&gt; V[] split(ValueAccessor&lt;V&gt; accessor, V value)
    {
<span class="fc" id="L287">        return split(accessor, value, size(), this);</span>
    }

    /**
     * Split a tuple value into its component values.
     */
    public static &lt;V&gt; V[] split(ValueAccessor&lt;V&gt; accessor, V value, int numberOfElements, TupleType type)
    {
<span class="fc" id="L295">        V[] components = accessor.createArray(numberOfElements);</span>
<span class="fc" id="L296">        int length = accessor.size(value);</span>
<span class="fc" id="L297">        int position = 0;</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">        for (int i = 0; i &lt; numberOfElements; i++)</span>
        {
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">            if (position == length)</span>
<span class="nc" id="L301">                return Arrays.copyOfRange(components, 0, i);</span>

<span class="pc bpc" id="L303" title="1 of 2 branches missed.">            if (position + 4 &gt; length)</span>
<span class="nc" id="L304">                throw new MarshalException(String.format(&quot;Not enough bytes to read %dth component&quot;, i));</span>

<span class="fc" id="L306">            int size = accessor.getInt(value, position);</span>
<span class="fc" id="L307">            position += 4;</span>

            // size &lt; 0 means null value
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">            if (size &gt;= 0)</span>
            {
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">                if (position + size &gt; length)</span>
<span class="nc" id="L313">                    throw new MarshalException(String.format(&quot;Not enough bytes to read %dth component&quot;, i));</span>

<span class="fc" id="L315">                components[i] = accessor.slice(value, position, size);</span>
<span class="fc" id="L316">                position += size;</span>
            }
            else
<span class="nc" id="L319">                components[i] = null;</span>
        }

        // error out if we got more values in the tuple/UDT than we expected
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">        if (position &lt; length)</span>
        {
<span class="nc" id="L325">            throw new MarshalException(String.format(&quot;Expected %s %s for %s column, but got more&quot;,</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">                                                     numberOfElements, numberOfElements == 1 ? &quot;value&quot; : &quot;values&quot;,</span>
<span class="nc" id="L327">                                                     type.asCQL3Type()));</span>
        }

<span class="fc" id="L330">        return components;</span>
    }

    @SafeVarargs
    public static &lt;V&gt; V buildValue(ValueAccessor&lt;V&gt; accessor, V... components)
    {
<span class="fc" id="L336">        int totalLength = 0;</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">        for (V component : components)</span>
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">            totalLength += 4 + (component == null ? 0 : accessor.size(component));</span>

<span class="fc" id="L340">        int offset = 0;</span>
<span class="fc" id="L341">        V result = accessor.allocate(totalLength);</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">        for (V component : components)</span>
        {
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">            if (component == null)</span>
            {
<span class="nc" id="L346">                offset += accessor.putInt(result, offset, -1);</span>

            }
            else
            {
<span class="fc" id="L351">                offset += accessor.putInt(result, offset, accessor.size(component));</span>
<span class="fc" id="L352">                offset += accessor.copyTo(component, 0, result, accessor, offset, accessor.size(component));</span>
            }
        }
<span class="fc" id="L355">        return result;</span>
    }

    public static ByteBuffer buildValue(ByteBuffer... components)
    {
<span class="fc" id="L360">        return buildValue(ByteBufferAccessor.instance, components);</span>
    }

    @Override
    public &lt;V&gt; String getString(V input, ValueAccessor&lt;V&gt; accessor)
    {
<span class="nc bnc" id="L366" title="All 2 branches missed.">        if (input == null)</span>
<span class="nc" id="L367">            return &quot;null&quot;;</span>

<span class="nc" id="L369">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L370">        int offset = 0;</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">        for (int i = 0; i &lt; size(); i++)</span>
        {
<span class="nc bnc" id="L373" title="All 2 branches missed.">            if (accessor.isEmptyFromOffset(input, offset))</span>
<span class="nc" id="L374">                return sb.toString();</span>

<span class="nc bnc" id="L376" title="All 2 branches missed.">            if (i &gt; 0)</span>
<span class="nc" id="L377">                sb.append(&quot;:&quot;);</span>

<span class="nc" id="L379">            AbstractType&lt;?&gt; type = type(i);</span>
<span class="nc" id="L380">            int size = accessor.getInt(input, offset);</span>
<span class="nc" id="L381">            offset += TypeSizes.INT_SIZE;</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">            if (size &lt; 0)</span>
            {
<span class="nc" id="L384">                sb.append(&quot;@&quot;);</span>
<span class="nc" id="L385">                continue;</span>
            }

<span class="nc" id="L388">            V field = accessor.slice(input, offset, size);</span>
<span class="nc" id="L389">            offset += size;</span>
            // We use ':' as delimiter, and @ to represent null, so escape them in the generated string
<span class="nc" id="L391">            String fld = COLON_PAT.matcher(type.getString(field, accessor)).replaceAll(ESCAPED_COLON);</span>
<span class="nc" id="L392">            fld = AT_PAT.matcher(fld).replaceAll(ESCAPED_AT);</span>
<span class="nc" id="L393">            sb.append(fld);</span>
        }
<span class="nc" id="L395">        return sb.toString();</span>
    }

    public ByteBuffer fromString(String source)
    {
        // Split the input on non-escaped ':' characters
<span class="nc" id="L401">        List&lt;String&gt; fieldStrings = AbstractCompositeType.split(source);</span>

<span class="nc bnc" id="L403" title="All 2 branches missed.">        if (fieldStrings.size() &gt; size())</span>
<span class="nc" id="L404">            throw new MarshalException(String.format(&quot;Invalid tuple literal: too many elements. Type %s expects %d but got %d&quot;,</span>
<span class="nc" id="L405">                                                     asCQL3Type(), size(), fieldStrings.size()));</span>

<span class="nc" id="L407">        ByteBuffer[] fields = new ByteBuffer[fieldStrings.size()];</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">        for (int i = 0; i &lt; fieldStrings.size(); i++)</span>
        {
<span class="nc" id="L410">            String fieldString = fieldStrings.get(i);</span>
            // We use @ to represent nulls
<span class="nc bnc" id="L412" title="All 2 branches missed.">            if (fieldString.equals(&quot;@&quot;))</span>
<span class="nc" id="L413">                continue;</span>

<span class="nc" id="L415">            AbstractType&lt;?&gt; type = type(i);</span>
<span class="nc" id="L416">            fieldString = ESCAPED_COLON_PAT.matcher(fieldString).replaceAll(COLON);</span>
<span class="nc" id="L417">            fieldString = ESCAPED_AT_PAT.matcher(fieldString).replaceAll(AT);</span>
<span class="nc" id="L418">            fields[i] = type.fromString(fieldString);</span>
        }
<span class="nc" id="L420">        return buildValue(fields);</span>
    }

    @Override
    public Term fromJSONObject(Object parsed) throws MarshalException
    {
<span class="nc bnc" id="L426" title="All 2 branches missed.">        if (parsed instanceof String)</span>
<span class="nc" id="L427">            parsed = JsonUtils.decodeJson((String) parsed);</span>

<span class="nc bnc" id="L429" title="All 2 branches missed.">        if (!(parsed instanceof List))</span>
<span class="nc" id="L430">            throw new MarshalException(String.format(</span>
<span class="nc" id="L431">                    &quot;Expected a list representation of a tuple, but got a %s: %s&quot;, parsed.getClass().getSimpleName(), parsed));</span>

<span class="nc" id="L433">        List&lt;?&gt; list = (List&lt;?&gt;) parsed;</span>

<span class="nc bnc" id="L435" title="All 2 branches missed.">        if (list.size() &gt; types.size())</span>
<span class="nc" id="L436">            throw new MarshalException(String.format(&quot;Tuple contains extra items (expected %s): %s&quot;, types.size(), parsed));</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">        else if (types.size() &gt; list.size())</span>
<span class="nc" id="L438">            throw new MarshalException(String.format(&quot;Tuple is missing items (expected %s): %s&quot;, types.size(), parsed));</span>

<span class="nc" id="L440">        List&lt;Term&gt; terms = new ArrayList&lt;&gt;(list.size());</span>
<span class="nc" id="L441">        Iterator&lt;AbstractType&lt;?&gt;&gt; typeIterator = types.iterator();</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">        for (Object element : list)</span>
        {
<span class="nc bnc" id="L444" title="All 2 branches missed.">            if (element == null)</span>
            {
<span class="nc" id="L446">                typeIterator.next();</span>
<span class="nc" id="L447">                terms.add(Constants.NULL_VALUE);</span>
            }
            else
            {
<span class="nc" id="L451">                terms.add(typeIterator.next().fromJSONObject(element));</span>
            }
<span class="nc" id="L453">        }</span>

<span class="nc" id="L455">        return new Tuples.DelayedValue(this, terms);</span>
    }

    @Override
    public String toJSONString(ByteBuffer buffer, ProtocolVersion protocolVersion)
    {
<span class="nc" id="L461">        ByteBuffer duplicated = buffer.duplicate();</span>
<span class="nc" id="L462">        int offset = 0;</span>
<span class="nc" id="L463">        StringBuilder sb = new StringBuilder(&quot;[&quot;);</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">        for (int i = 0; i &lt; types.size(); i++)</span>
        {
<span class="nc bnc" id="L466" title="All 2 branches missed.">            if (i &gt; 0)</span>
<span class="nc" id="L467">                sb.append(&quot;, &quot;);</span>

<span class="nc" id="L469">            ByteBuffer value = CollectionSerializer.readValue(duplicated, ByteBufferAccessor.instance, offset);</span>
<span class="nc" id="L470">            offset += CollectionSerializer.sizeOfValue(value, ByteBufferAccessor.instance);</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">            if (value == null)</span>
<span class="nc" id="L472">                sb.append(&quot;null&quot;);</span>
            else
<span class="nc" id="L474">                sb.append(types.get(i).toJSONString(value, protocolVersion));</span>
        }
<span class="nc" id="L476">        return sb.append(&quot;]&quot;).toString();</span>
    }

    public TypeSerializer&lt;ByteBuffer&gt; getSerializer()
    {
<span class="fc" id="L481">        return serializer;</span>
    }

    @Override
    public boolean isCompatibleWith(AbstractType&lt;?&gt; previous)
    {
<span class="nc bnc" id="L487" title="All 2 branches missed.">        if (!(previous instanceof TupleType))</span>
<span class="nc" id="L488">            return false;</span>

        // Extending with new components is fine, removing is not
<span class="nc" id="L491">        TupleType tt = (TupleType)previous;</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">        if (size() &lt; tt.size())</span>
<span class="nc" id="L493">            return false;</span>

<span class="nc bnc" id="L495" title="All 2 branches missed.">        for (int i = 0; i &lt; tt.size(); i++)</span>
        {
<span class="nc" id="L497">            AbstractType&lt;?&gt; tprev = tt.type(i);</span>
<span class="nc" id="L498">            AbstractType&lt;?&gt; tnew = type(i);</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">            if (!tnew.isCompatibleWith(tprev))</span>
<span class="nc" id="L500">                return false;</span>
        }
<span class="nc" id="L502">        return true;</span>
    }

    @Override
    public boolean isValueCompatibleWithInternal(AbstractType&lt;?&gt; otherType)
    {
<span class="nc bnc" id="L508" title="All 2 branches missed.">        if (!(otherType instanceof TupleType))</span>
<span class="nc" id="L509">            return false;</span>

        // Extending with new components is fine, removing is not
<span class="nc" id="L512">        TupleType tt = (TupleType) otherType;</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">        if (size() &lt; tt.size())</span>
<span class="nc" id="L514">            return false;</span>

<span class="nc bnc" id="L516" title="All 2 branches missed.">        for (int i = 0; i &lt; tt.size(); i++)</span>
        {
<span class="nc" id="L518">            AbstractType&lt;?&gt; tprev = tt.type(i);</span>
<span class="nc" id="L519">            AbstractType&lt;?&gt; tnew = type(i);</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">            if (!tnew.isValueCompatibleWith(tprev))</span>
<span class="nc" id="L521">                return false;</span>
        }
<span class="nc" id="L523">        return true;</span>
    }

    @Override
    public int hashCode()
    {
<span class="fc" id="L529">        return Objects.hashCode(types);</span>
    }

    @Override
    public boolean equals(Object o)
    {
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">        if(!(o instanceof TupleType))</span>
<span class="nc" id="L536">            return false;</span>

<span class="fc" id="L538">        TupleType that = (TupleType)o;</span>
<span class="fc" id="L539">        return types.equals(that.types);</span>
    }

    @Override
    public CQL3Type asCQL3Type()
    {
<span class="fc" id="L545">        return CQL3Type.Tuple.create(this);</span>
    }

    @Override
    public String toString()
    {
<span class="fc" id="L551">        return getClass().getName() + TypeParser.stringifyTypeParameters(types, true);</span>
    }

    @Override
    public ByteBuffer getMaskedValue()
    {
<span class="nc" id="L557">        ByteBuffer[] buffers = new ByteBuffer[types.size()];</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">        for (int i = 0; i &lt; types.size(); i++)</span>
        {
<span class="nc" id="L560">            AbstractType&lt;?&gt; type = types.get(i);</span>
<span class="nc" id="L561">            buffers[i] = type.getMaskedValue();</span>
        }

<span class="nc" id="L564">        return serializer.serialize(buildValue(buffers));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>