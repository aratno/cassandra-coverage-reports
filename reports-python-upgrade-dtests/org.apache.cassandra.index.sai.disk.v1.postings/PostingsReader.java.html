<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PostingsReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.index.sai.disk.v1.postings</a> &gt; <span class="el_source">PostingsReader.java</span></div><h1>PostingsReader.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.index.sai.disk.v1.postings;


import java.io.IOException;
import javax.annotation.concurrent.NotThreadSafe;

import com.google.common.annotations.VisibleForTesting;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.index.sai.disk.v1.DirectReaders;
import org.apache.cassandra.index.sai.postings.OrdinalPostingList;
import org.apache.cassandra.index.sai.postings.PostingList;
import org.apache.cassandra.index.sai.disk.v1.LongArray;
import org.apache.cassandra.index.sai.metrics.QueryEventListener;
import org.apache.cassandra.index.sai.disk.io.SeekingRandomAccessInput;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.lucene.index.CorruptIndexException;
import org.apache.lucene.store.IndexInput;
import org.apache.lucene.util.LongValues;
import org.apache.lucene.util.packed.DirectReader;


/**
 * Reads, decompresses and decodes postings lists written by {@link PostingsWriter}.
 *
 * Holds exactly one posting block in memory at a time. Does binary search over skip table to find a postings block to
 * load.
 */
@NotThreadSafe
public class PostingsReader implements OrdinalPostingList
{
<span class="nc" id="L51">    private static final Logger logger = LoggerFactory.getLogger(PostingsReader.class);</span>

    private final IndexInput input;
    private final SeekingRandomAccessInput seekingInput;
    private final QueryEventListener.PostingListEventListener listener;
    private final BlocksSummary summary;

    // Current block index
    private int blockIndex;
    // Current posting index within block
    private int postingIndex;
    private long totalPostingsRead;
    private long actualPosting;

    private long currentPosition;
    private LongValues currentFoRValues;
<span class="nc" id="L67">    private long postingsDecoded = 0;</span>

    @VisibleForTesting
    public PostingsReader(IndexInput input, long summaryOffset, QueryEventListener.PostingListEventListener listener) throws IOException
    {
<span class="nc" id="L72">        this(input, new BlocksSummary(input, summaryOffset), listener);</span>
<span class="nc" id="L73">    }</span>

    public PostingsReader(IndexInput input, BlocksSummary summary, QueryEventListener.PostingListEventListener listener) throws IOException
<span class="nc" id="L76">    {</span>
<span class="nc" id="L77">        this.input = input;</span>
<span class="nc" id="L78">        this.seekingInput = new SeekingRandomAccessInput(input);</span>
<span class="nc" id="L79">        this.listener = listener;</span>
<span class="nc" id="L80">        this.summary = summary;</span>

<span class="nc" id="L82">        reBuffer();</span>
<span class="nc" id="L83">    }</span>

    @Override
    public long getOrdinal()
    {
<span class="nc" id="L88">        return totalPostingsRead;</span>
    }

    public static class BlocksSummary
    {
        private final IndexInput input;
        final int blockSize;
        final int numPostings;
        final LongArray offsets;
        final LongArray maxValues;

        public BlocksSummary(IndexInput input, long offset) throws IOException
<span class="nc" id="L100">        {</span>
<span class="nc" id="L101">            this.input = input;</span>
<span class="nc" id="L102">            input.seek(offset);</span>
<span class="nc" id="L103">            this.blockSize = input.readVInt();</span>
            //TODO This should need to change because we can potentially end up with postings of more than Integer.MAX_VALUE?
<span class="nc" id="L105">            this.numPostings = input.readVInt();</span>

<span class="nc" id="L107">            SeekingRandomAccessInput randomAccessInput = new SeekingRandomAccessInput(input);</span>
<span class="nc" id="L108">            int numBlocks = input.readVInt();</span>
<span class="nc" id="L109">            long maxBlockValuesLength = input.readVLong();</span>
<span class="nc" id="L110">            long maxBlockValuesOffset = input.getFilePointer() + maxBlockValuesLength;</span>

<span class="nc" id="L112">            byte offsetBitsPerValue = input.readByte();</span>
<span class="nc" id="L113">            DirectReaders.checkBitsPerValue(offsetBitsPerValue, input, () -&gt; &quot;Postings list header&quot;);</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">            LongValues lvOffsets = offsetBitsPerValue == 0 ? LongValues.ZEROES : DirectReader.getInstance(randomAccessInput, offsetBitsPerValue, input.getFilePointer());</span>
<span class="nc" id="L115">            this.offsets = new LongArrayReader(lvOffsets, numBlocks);</span>

<span class="nc" id="L117">            input.seek(maxBlockValuesOffset);</span>
<span class="nc" id="L118">            byte valuesBitsPerValue = input.readByte();</span>
<span class="nc" id="L119">            DirectReaders.checkBitsPerValue(valuesBitsPerValue, input, () -&gt; &quot;Postings list header&quot;);</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">            LongValues lvValues = valuesBitsPerValue == 0 ? LongValues.ZEROES : DirectReader.getInstance(randomAccessInput, valuesBitsPerValue, input.getFilePointer());</span>
<span class="nc" id="L121">            this.maxValues = new LongArrayReader(lvValues, numBlocks);</span>
<span class="nc" id="L122">        }</span>

        void close()
        {
<span class="nc" id="L126">            FileUtils.closeQuietly(input);</span>
<span class="nc" id="L127">        }</span>

        private static class LongArrayReader implements LongArray
        {
            private final LongValues reader;
            private final int length;

            private LongArrayReader(LongValues reader, int length)
<span class="nc" id="L135">            {</span>
<span class="nc" id="L136">                this.reader = reader;</span>
<span class="nc" id="L137">                this.length = length;</span>
<span class="nc" id="L138">            }</span>

            @Override
            public long get(long idx)
            {
<span class="nc" id="L143">                return reader.get(idx);</span>
            }

            @Override
            public long length()
            {
<span class="nc" id="L149">                return length;</span>
            }

            @Override
            public long indexOf(long value)
            {
<span class="nc" id="L155">                throw new UnsupportedOperationException();</span>
            }
        }
    }

    @Override
    public void close()
    {
<span class="nc" id="L163">        listener.postingDecoded(postingsDecoded);</span>
<span class="nc" id="L164">        FileUtils.closeQuietly(input);</span>
<span class="nc" id="L165">        summary.close();</span>
<span class="nc" id="L166">    }</span>

    @Override
    public long size()
    {
<span class="nc" id="L171">        return summary.numPostings;</span>
    }

    /**
     * Advances to the first row ID beyond the current that is greater than or equal to the
     * target, and returns that row ID. Exhausts the iterator and returns {@link #END_OF_STREAM} if
     * the target is greater than the highest row ID.
     *
     * Does binary search over the skip table to find the next block to load into memory.
     *
     * Note: Callers must use the return value of this method before calling {@link #nextPosting()}, as calling
     * that method will return the next posting, not the one to which we have just advanced.
     *
     * @param targetRowID target row ID to advance to
     *
     * @return first segment row ID which is &gt;= the target row ID or {@link PostingList#END_OF_STREAM} if one does not exist
     */
    @Override
    public long advance(long targetRowID) throws IOException
    {
<span class="nc" id="L191">        listener.onAdvance();</span>
<span class="nc" id="L192">        int block = binarySearchBlocks(targetRowID);</span>

<span class="nc bnc" id="L194" title="All 2 branches missed.">        if (block &lt; 0)</span>
        {
<span class="nc" id="L196">            block = -block - 1;</span>
        }

<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (blockIndex == block + 1)</span>
        {
            // we're in the same block, just iterate through
<span class="nc" id="L202">            return slowAdvance(targetRowID);</span>
        }
<span class="nc bnc" id="L204" title="All 2 branches missed.">        assert block &gt; 0;</span>
        // Even if there was an exact match, block might contain duplicates.
        // We iterate to the target token from the beginning.
<span class="nc" id="L207">        lastPosInBlock(block - 1);</span>
<span class="nc" id="L208">        return slowAdvance(targetRowID);</span>
    }

    private long slowAdvance(long targetRowID) throws IOException
    {
<span class="nc bnc" id="L213" title="All 2 branches missed.">        while (totalPostingsRead &lt; summary.numPostings)</span>
        {
<span class="nc" id="L215">            long segmentRowId = peekNext();</span>

<span class="nc" id="L217">            advanceOnePosition(segmentRowId);</span>

<span class="nc bnc" id="L219" title="All 2 branches missed.">            if (segmentRowId &gt;= targetRowID)</span>
            {
<span class="nc" id="L221">                return segmentRowId;</span>
            }
<span class="nc" id="L223">        }</span>
<span class="nc" id="L224">        return END_OF_STREAM;</span>
    }

    // Perform a binary search of the blocks to the find the block index
    // containing the targetRowID, or, in the case of a duplicate value
    // crossing blocks, the preceeding block index
    private int binarySearchBlocks(long targetRowID)
    {
<span class="nc" id="L232">        int lowBlockIndex = blockIndex - 1;</span>
<span class="nc" id="L233">        int highBlockIndex = Math.toIntExact(summary.maxValues.length()) - 1;</span>

        // in current block
<span class="nc bnc" id="L236" title="All 4 branches missed.">        if (lowBlockIndex &lt;= highBlockIndex &amp;&amp; targetRowID &lt;= summary.maxValues.get(lowBlockIndex))</span>
<span class="nc" id="L237">            return lowBlockIndex;</span>

<span class="nc bnc" id="L239" title="All 2 branches missed.">        while (lowBlockIndex &lt;= highBlockIndex)</span>
        {
<span class="nc" id="L241">            int midBlockIndex = lowBlockIndex + ((highBlockIndex - lowBlockIndex) &gt;&gt; 1) ;</span>

<span class="nc" id="L243">            long maxValueOfMidBlock = summary.maxValues.get(midBlockIndex);</span>

<span class="nc bnc" id="L245" title="All 2 branches missed.">            if (maxValueOfMidBlock &lt; targetRowID)</span>
            {
<span class="nc" id="L247">                lowBlockIndex = midBlockIndex + 1;</span>
            }
<span class="nc bnc" id="L249" title="All 2 branches missed.">            else if (maxValueOfMidBlock &gt; targetRowID)</span>
            {
<span class="nc" id="L251">                highBlockIndex = midBlockIndex - 1;</span>
            }
            else
            {
                // At this point the maximum value of the midway block matches our target.
                //
                // This following check is to see if we have a duplicate value in the last entry of the
                // preceeding block. This check is only going to be successful if the entire current
                // block is full of duplicates.
<span class="nc bnc" id="L260" title="All 4 branches missed.">                if (midBlockIndex &gt; 0 &amp;&amp; summary.maxValues.get(midBlockIndex - 1) == targetRowID)</span>
                {
                    // there is a duplicate in the preceeding block so restrict search to finish
                    // at that block
<span class="nc" id="L264">                    highBlockIndex = midBlockIndex - 1;</span>
                }
                else
                {
                    // no duplicates
<span class="nc" id="L269">                    return midBlockIndex;</span>
                }
            }
<span class="nc" id="L272">        }</span>
<span class="nc" id="L273">        return -(lowBlockIndex + 1);  // target not found</span>
    }

    private void lastPosInBlock(int block)
    {
        // blockMaxValues is integer only
<span class="nc" id="L279">        actualPosting = summary.maxValues.get(block);</span>
        //upper bound, since we might've advanced to the last block, but upper bound is enough
<span class="nc" id="L281">        totalPostingsRead += (summary.blockSize - postingIndex) + (block - blockIndex + 1) * (long)summary.blockSize;</span>

<span class="nc" id="L283">        blockIndex = block + 1;</span>
<span class="nc" id="L284">        postingIndex = summary.blockSize;</span>
<span class="nc" id="L285">    }</span>

    @Override
    public long nextPosting() throws IOException
    {
<span class="nc" id="L290">        long next = peekNext();</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">        if (next != END_OF_STREAM)</span>
        {
<span class="nc" id="L293">            advanceOnePosition(next);</span>
        }
<span class="nc" id="L295">        return next;</span>
    }

    private long peekNext() throws IOException
    {
<span class="nc bnc" id="L300" title="All 2 branches missed.">        if (totalPostingsRead &gt;= summary.numPostings)</span>
        {
<span class="nc" id="L302">            return END_OF_STREAM;</span>
        }
<span class="nc bnc" id="L304" title="All 2 branches missed.">        if (postingIndex == summary.blockSize)</span>
        {
<span class="nc" id="L306">            reBuffer();</span>
        }

<span class="nc" id="L309">        return actualPosting + nextFoRValue();</span>
    }

    private int nextFoRValue()
    {
<span class="nc" id="L314">        long id = currentFoRValues.get(postingIndex);</span>
<span class="nc" id="L315">        postingsDecoded++;</span>
<span class="nc" id="L316">        return Math.toIntExact(id);</span>
    }

    private void advanceOnePosition(long nextPosting)
    {
<span class="nc" id="L321">        actualPosting = nextPosting;</span>
<span class="nc" id="L322">        totalPostingsRead++;</span>
<span class="nc" id="L323">        postingIndex++;</span>
<span class="nc" id="L324">    }</span>

    private void reBuffer() throws IOException
    {
<span class="nc" id="L328">        long pointer = summary.offsets.get(blockIndex);</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">        if (pointer &lt; 4)</span>
        {
            // the first 4 bytes must be CODEC_MAGIC
<span class="nc" id="L332">            throw new CorruptIndexException(String.format(&quot;Invalid block offset %d for postings block idx %d&quot;, pointer, blockIndex), input);</span>
        }
<span class="nc" id="L334">        input.seek(pointer);</span>

<span class="nc" id="L336">        long left = summary.numPostings - totalPostingsRead;</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">        assert left &gt; 0;</span>

<span class="nc" id="L339">        readFoRBlock(input);</span>

<span class="nc" id="L341">        blockIndex++;</span>
<span class="nc" id="L342">        postingIndex = 0;</span>
<span class="nc" id="L343">    }</span>

    private void readFoRBlock(IndexInput in) throws IOException
    {
<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (blockIndex == 0)</span>
<span class="nc" id="L348">            actualPosting = in.readVLong();</span>

<span class="nc" id="L350">        byte bitsPerValue = in.readByte();</span>

<span class="nc" id="L352">        currentPosition = in.getFilePointer();</span>

<span class="nc bnc" id="L354" title="All 2 branches missed.">        if (bitsPerValue == 0)</span>
        {
            // If bitsPerValue is 0 then all the values in the block are the same
<span class="nc" id="L357">            currentFoRValues = LongValues.ZEROES;</span>
<span class="nc" id="L358">            return;</span>
        }
<span class="nc bnc" id="L360" title="All 2 branches missed.">        else if (bitsPerValue &gt; 64)</span>
        {
<span class="nc" id="L362">            throw new CorruptIndexException(</span>
<span class="nc" id="L363">            String.format(&quot;Postings list #%s block is corrupted. Bits per value should be no more than 64 and is %d.&quot;, blockIndex, bitsPerValue), input);</span>
        }
<span class="nc" id="L365">        currentFoRValues = DirectReader.getInstance(seekingInput, bitsPerValue, currentPosition);</span>
<span class="nc" id="L366">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>