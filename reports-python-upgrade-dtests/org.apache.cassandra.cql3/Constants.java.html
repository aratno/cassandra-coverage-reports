<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Constants.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3</a> &gt; <span class="el_source">Constants.java</span></div><h1>Constants.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;

import org.apache.cassandra.db.Clustering;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.marshal.*;
import org.apache.cassandra.db.rows.Cell;
import org.apache.cassandra.db.rows.Row;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.serializers.MarshalException;
import org.apache.cassandra.transport.ProtocolVersion;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.FastByteOperations;

/**
 * Static helper methods and classes for constants.
 */
<span class="nc" id="L40">public abstract class Constants</span>
{
<span class="fc" id="L42">    public enum Type</span>
    {
<span class="fc" id="L44">        STRING</span>
        {
            @Override
            public AbstractType&lt;?&gt; getPreferedTypeFor(String text)
            {
<span class="pc bpc" id="L49" title="1 of 2 branches missed.">                 if (StandardCharsets.US_ASCII.newEncoder().canEncode(text))</span>
                 {
<span class="fc" id="L51">                     return AsciiType.instance;</span>
                 }

<span class="nc" id="L54">                 return UTF8Type.instance;</span>
            }
        },
<span class="fc" id="L57">        INTEGER</span>
        {
            @Override
            public AbstractType&lt;?&gt; getPreferedTypeFor(String text)
            {
                // We only try to determine the smallest possible type between int, long and BigInteger
<span class="fc" id="L63">                BigInteger b = new BigInteger(text);</span>

<span class="fc bfc" id="L65" title="All 2 branches covered.">                if (b.equals(BigInteger.valueOf(b.intValue())))</span>
<span class="fc" id="L66">                    return Int32Type.instance;</span>

<span class="pc bpc" id="L68" title="1 of 2 branches missed.">                if (b.equals(BigInteger.valueOf(b.longValue())))</span>
<span class="fc" id="L69">                    return LongType.instance;</span>

<span class="nc" id="L71">                return IntegerType.instance;</span>
            }
        },
<span class="fc" id="L74">        UUID</span>
        {
            @Override
            public AbstractType&lt;?&gt; getPreferedTypeFor(String text)
            {
<span class="fc bfc" id="L79" title="All 2 branches covered.">                return java.util.UUID.fromString(text).version() == 1</span>
<span class="fc" id="L80">                       ? TimeUUIDType.instance</span>
<span class="fc" id="L81">                       : UUIDType.instance;</span>
            }
        },
<span class="fc" id="L84">        FLOAT</span>
        {
            @Override
            public AbstractType&lt;?&gt; getPreferedTypeFor(String text)
            {
<span class="pc bpc" id="L89" title="1 of 8 branches missed.">                if (&quot;NaN&quot;.equals(text) || &quot;-NaN&quot;.equals(text) || &quot;Infinity&quot;.equals(text) || &quot;-Infinity&quot;.equals(text))</span>
<span class="fc" id="L90">                    return DoubleType.instance;</span>

                // We only try to determine the smallest possible type between double and BigDecimal
<span class="fc" id="L93">                BigDecimal b = new BigDecimal(text);</span>

<span class="pc bpc" id="L95" title="1 of 2 branches missed.">                if (b.compareTo(BigDecimal.valueOf(b.doubleValue())) == 0)</span>
<span class="fc" id="L96">                    return DoubleType.instance;</span>

<span class="nc" id="L98">                return DecimalType.instance;</span>
            }
        },
<span class="fc" id="L101">        BOOLEAN</span>
        {
            @Override
            public AbstractType&lt;?&gt; getPreferedTypeFor(String text)
            {
<span class="fc" id="L106">                return BooleanType.instance;</span>
            }
        },
<span class="fc" id="L109">        HEX</span>
        {
            @Override
            public AbstractType&lt;?&gt; getPreferedTypeFor(String text)
            {
<span class="fc" id="L114">                return ByteType.instance;</span>
            }
        },
<span class="fc" id="L117">        DURATION</span>
        {
            @Override
            public AbstractType&lt;?&gt; getPreferedTypeFor(String text)
            {
<span class="nc" id="L122">                return DurationType.instance;</span>
            }
        };

        /**
         * Returns the exact type for the specified text
         *
         * @param text the text for which the type must be determined
         * @return the exact type or {@code null} if it is not known.
         */
        public AbstractType&lt;?&gt; getPreferedTypeFor(String text)
        {
<span class="nc" id="L134">            return null;</span>
        }
    }

    private static class UnsetLiteral extends Term.Raw
    {
        public Term prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
        {
<span class="nc" id="L142">            return UNSET_VALUE;</span>
        }

        public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
        {
<span class="nc" id="L147">            return AssignmentTestable.TestResult.NOT_ASSIGNABLE;</span>
        }

        public String getText()
        {
<span class="nc" id="L152">            return &quot;&quot;;</span>
        }

        public AbstractType&lt;?&gt; getExactTypeIfKnown(String keyspace)
        {
<span class="nc" id="L157">            return null;</span>
        }
    }

    // We don't have &quot;unset&quot; literal in the syntax, but it's used implicitely for JSON &quot;DEFAULT UNSET&quot; option
<span class="fc" id="L162">    public static final UnsetLiteral UNSET_LITERAL = new UnsetLiteral();</span>

<span class="fc" id="L164">    public static final Value UNSET_VALUE = new Value(ByteBufferUtil.UNSET_BYTE_BUFFER);</span>

    private static class NullLiteral extends Term.Raw
    {
        public Term prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
        {
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">            if (!testAssignment(keyspace, receiver).isAssignable())</span>
<span class="nc" id="L171">                throw new InvalidRequestException(&quot;Invalid null value for counter increment/decrement&quot;);</span>

<span class="fc" id="L173">            return NULL_VALUE;</span>
        }

        public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
        {
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">            return receiver.type instanceof CounterColumnType</span>
<span class="nc" id="L179">                 ? AssignmentTestable.TestResult.NOT_ASSIGNABLE</span>
<span class="fc" id="L180">                 : AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;</span>
        }

        public String getText()
        {
<span class="fc" id="L185">            return &quot;NULL&quot;;</span>
        }

        public AbstractType&lt;?&gt; getExactTypeIfKnown(String keyspace)
        {
<span class="nc" id="L190">            return null;</span>
        }
    }

<span class="fc" id="L194">    public static final NullLiteral NULL_LITERAL = new NullLiteral();</span>

<span class="fc" id="L196">    public static final Term.Terminal NULL_VALUE = new Value(null)</span>
<span class="fc" id="L197">    {</span>
        @Override
        public Terminal bind(QueryOptions options)
        {
            // We return null because that makes life easier for collections
<span class="fc" id="L202">            return null;</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L208">            return &quot;null&quot;;</span>
        }
    };

<span class="fc" id="L212">    public static class Literal extends Term.Raw</span>
    {
        private final Type type;
        private final String text;
        private final AbstractType&lt;?&gt; preferedType;

        private Literal(Type type, String text)
<span class="fc" id="L219">        {</span>
<span class="pc bpc" id="L220" title="2 of 4 branches missed.">            assert type != null &amp;&amp; text != null;</span>
<span class="fc" id="L221">            this.type = type;</span>
<span class="fc" id="L222">            this.text = text;</span>
<span class="fc" id="L223">            this.preferedType = type.getPreferedTypeFor(text);</span>
<span class="fc" id="L224">        }</span>

        public static Literal string(String text)
        {
<span class="fc" id="L228">            return new Literal(Type.STRING, text);</span>
        }

        public static Literal integer(String text)
        {
<span class="fc" id="L233">            return new Literal(Type.INTEGER, text);</span>
        }

        public static Literal floatingPoint(String text)
        {
<span class="fc" id="L238">            return new Literal(Type.FLOAT, text);</span>
        }

        public static Literal uuid(String text)
        {
<span class="fc" id="L243">            return new Literal(Type.UUID, text);</span>
        }

        public static Literal bool(String text)
        {
<span class="fc" id="L248">            return new Literal(Type.BOOLEAN, text);</span>
        }

        public static Literal hex(String text)
        {
<span class="fc" id="L253">            return new Literal(Type.HEX, text);</span>
        }

        public static Literal duration(String text)
        {
<span class="nc" id="L258">            return new Literal(Type.DURATION, text);</span>
        }

        public Value prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
        {
<span class="fc bfc" id="L263" title="All 2 branches covered.">            if (!testAssignment(keyspace, receiver).isAssignable())</span>
<span class="fc" id="L264">                throw new InvalidRequestException(String.format(&quot;Invalid %s constant (%s) for \&quot;%s\&quot; of type %s&quot;, type, text, receiver.name, receiver.type.asCQL3Type()));</span>

<span class="fc" id="L266">            return new Value(parsedValue(receiver.type));</span>
        }

        private ByteBuffer parsedValue(AbstractType&lt;?&gt; validator) throws InvalidRequestException
        {
<span class="fc bfc" id="L271" title="All 2 branches covered.">            if (validator instanceof ReversedType&lt;?&gt;)</span>
<span class="fc" id="L272">                validator = ((ReversedType&lt;?&gt;) validator).baseType;</span>
            try
            {
<span class="fc bfc" id="L275" title="All 2 branches covered.">                if (type == Type.HEX)</span>
                    // Note that validator could be BytesType, but it could also be a custom type, so
                    // we hardcode BytesType (rather than using 'validator') in the call below.
                    // Further note that BytesType doesn't want it's input prefixed by '0x', hence the substring.
<span class="fc" id="L279">                    return BytesType.instance.fromString(text.substring(2));</span>

<span class="fc bfc" id="L281" title="All 2 branches covered.">                if (validator instanceof CounterColumnType)</span>
<span class="fc" id="L282">                    return LongType.instance.fromString(text);</span>
<span class="fc" id="L283">                return validator.fromString(text);</span>
            }
<span class="fc" id="L285">            catch (MarshalException e)</span>
            {
<span class="fc" id="L287">                throw new InvalidRequestException(e.getMessage());</span>
            }
        }

        @Override
        public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
        {
<span class="fc" id="L294">            CQL3Type receiverType = receiver.type.asCQL3Type();</span>
<span class="pc bpc" id="L295" title="2 of 4 branches missed.">            if (receiverType.isCollection() || receiverType.isUDT())</span>
<span class="nc" id="L296">                return AssignmentTestable.TestResult.NOT_ASSIGNABLE;</span>

<span class="pc bpc" id="L298" title="1 of 2 branches missed.">            if (!(receiverType instanceof CQL3Type.Native))</span>
                // Skip type validation for custom types. May or may not be a good idea
<span class="nc" id="L300">                return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;</span>

<span class="fc" id="L302">            CQL3Type.Native nt = (CQL3Type.Native)receiverType;</span>

            // If the receiver type match the prefered type we can straight away return an exact match
<span class="fc bfc" id="L305" title="All 2 branches covered.">            if (nt.getType().equals(preferedType))</span>
<span class="fc" id="L306">                return AssignmentTestable.TestResult.EXACT_MATCH;</span>

<span class="pc bpc" id="L308" title="3 of 8 branches missed.">            switch (type)</span>
            {
                case STRING:
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">                    switch (nt)</span>
                    {
                        case ASCII:
                        case TEXT:
                        case INET:
                        case VARCHAR:
                        case DATE:
                        case TIME:
                        case TIMESTAMP:
<span class="fc" id="L320">                            return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;</span>
                    }
<span class="nc" id="L322">                    break;</span>
                case INTEGER:
<span class="fc bfc" id="L324" title="All 2 branches covered.">                    switch (nt)</span>
                    {
                        case BIGINT:
                        case COUNTER:
                        case DATE:
                        case DECIMAL:
                        case DOUBLE:
                        case DURATION:
                        case FLOAT:
                        case INT:
                        case SMALLINT:
                        case TIME:
                        case TIMESTAMP:
                        case TINYINT:
                        case VARINT:
<span class="fc" id="L339">                            return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;</span>
                    }
<span class="fc" id="L341">                    break;</span>
                case UUID:
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">                    switch (nt)</span>
                    {
                        case UUID:
                        case TIMEUUID:
<span class="fc" id="L347">                            return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;</span>
                    }
<span class="nc" id="L349">                    break;</span>
                case FLOAT:
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">                    switch (nt)</span>
                    {
                        case DECIMAL:
                        case DOUBLE:
                        case FLOAT:
<span class="fc" id="L356">                            return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;</span>
                    }
<span class="nc" id="L358">                    break;</span>
                case BOOLEAN:
<span class="nc bnc" id="L360" title="All 2 branches missed.">                    switch (nt)</span>
                    {
                        case BOOLEAN:
<span class="nc" id="L363">                            return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;</span>
                    }
<span class="nc" id="L365">                    break;</span>
                case HEX:
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">                    switch (nt)</span>
                    {
                        case BLOB:
<span class="fc" id="L370">                            return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;</span>
                    }
<span class="nc" id="L372">                    break;</span>
                case DURATION:
<span class="nc bnc" id="L374" title="All 2 branches missed.">                    switch (nt)</span>
                    {
                        case DURATION:
<span class="nc" id="L377">                            return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;</span>
                    }
                    break;
            }
<span class="fc" id="L381">            return AssignmentTestable.TestResult.NOT_ASSIGNABLE;</span>
        }

        public AbstractType&lt;?&gt; getExactTypeIfKnown(String keyspace)
        {
            // Most constant are valid for more than one type (the extreme example being integer constants, which can
            // be use for any numerical type, including date, time, ...) so they don't have an exact type. And in fact,
            // for good or bad, any literal is valid for custom types, so we can never claim an exact type.
            // But really, the reason it's fine to return null here is that getExactTypeIfKnown is only used to
            // implement testAssignment() in Selectable and that method is overriden above.
<span class="nc" id="L391">            return null;</span>
        }

        @Override
        public AbstractType&lt;?&gt; getCompatibleTypeIfKnown(String keyspace)
        {
<span class="nc" id="L397">            return preferedType;</span>
        }

        public String getRawText()
        {
<span class="fc" id="L402">            return text;</span>
        }

        public String getText()
        {
<span class="fc bfc" id="L407" title="All 2 branches covered.">            return type == Type.STRING ? String.format(&quot;'%s'&quot;, text) : text;</span>
        }
    }

    /**
     * A constant value, i.e. a ByteBuffer.
     */
    public static class Value extends Term.Terminal
    {
        public final ByteBuffer bytes;

        public Value(ByteBuffer bytes)
<span class="fc" id="L419">        {</span>
<span class="fc" id="L420">            this.bytes = bytes;</span>
<span class="fc" id="L421">        }</span>

        public ByteBuffer get(ProtocolVersion version)
        {
<span class="fc" id="L425">            return bytes;</span>
        }

        @Override
        public ByteBuffer bindAndGet(QueryOptions options)
        {
<span class="fc" id="L431">            return bytes;</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L437">            return ByteBufferUtil.bytesToHex(bytes);</span>
        }
    }

<span class="fc" id="L441">    public static class Marker extends AbstractMarker</span>
    {
        protected Marker(int bindIndex, ColumnSpecification receiver)
        {
<span class="fc" id="L445">            super(bindIndex, receiver);</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">            assert !receiver.type.isCollection();</span>
<span class="fc" id="L447">        }</span>

        @Override
        public ByteBuffer bindAndGet(QueryOptions options) throws InvalidRequestException
        {
            try
            {
<span class="fc" id="L454">                ByteBuffer value = options.getValues().get(bindIndex);</span>
<span class="pc bpc" id="L455" title="1 of 4 branches missed.">                if (value != null &amp;&amp; value != ByteBufferUtil.UNSET_BYTE_BUFFER)</span>
<span class="fc" id="L456">                    receiver.type.validate(value);</span>
<span class="fc" id="L457">                return value;</span>
            }
<span class="nc" id="L459">            catch (MarshalException e)</span>
            {
<span class="nc" id="L461">                throw new InvalidRequestException(e.getMessage());</span>
            }
        }

        public Value bind(QueryOptions options) throws InvalidRequestException
        {
<span class="nc" id="L467">            ByteBuffer bytes = bindAndGet(options);</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">            if (bytes == null)</span>
<span class="nc" id="L469">                return null;</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">            if (bytes == ByteBufferUtil.UNSET_BYTE_BUFFER)</span>
<span class="nc" id="L471">                return Constants.UNSET_VALUE;</span>
<span class="nc" id="L472">            return new Constants.Value(bytes);</span>
        }
    }

    public static class Setter extends Operation
    {
        public Setter(ColumnMetadata column, Term t)
        {
<span class="fc" id="L480">            super(column, t);</span>
<span class="fc" id="L481">        }</span>

        public void execute(DecoratedKey partitionKey, UpdateParameters params) throws InvalidRequestException
        {
<span class="fc" id="L485">            ByteBuffer value = t.bindAndGet(params.options);</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">            if (value == null)</span>
<span class="fc" id="L487">                params.addTombstone(column);</span>
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">            else if (value != ByteBufferUtil.UNSET_BYTE_BUFFER) // use reference equality and not object equality</span>
<span class="fc" id="L489">                params.addCell(column, value);</span>
<span class="fc" id="L490">        }</span>
    }

    public static class Adder extends Operation
    {
        public Adder(ColumnMetadata column, Term t)
        {
<span class="fc" id="L497">            super(column, t);</span>
<span class="fc" id="L498">        }</span>

        public boolean requiresRead()
        {
<span class="pc bpc" id="L502" title="1 of 2 branches missed.">            return !(column.type instanceof CounterColumnType);</span>
        }

        public void execute(DecoratedKey partitionKey, UpdateParameters params) throws InvalidRequestException
        {
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">            if (column.type instanceof CounterColumnType)</span>
            {
<span class="fc" id="L509">                ByteBuffer bytes = t.bindAndGet(params.options);</span>
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">                if (bytes == null)</span>
<span class="nc" id="L511">                    throw new InvalidRequestException(&quot;Invalid null value for counter increment&quot;);</span>
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">                if (bytes == ByteBufferUtil.UNSET_BYTE_BUFFER)</span>
<span class="nc" id="L513">                    return;</span>

<span class="fc" id="L515">                long increment = ByteBufferUtil.toLong(bytes);</span>
<span class="fc" id="L516">                params.addCounter(column, increment);</span>
<span class="fc" id="L517">            }</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">            else if (column.type instanceof NumberType&lt;?&gt;)</span>
            {
<span class="nc" id="L520">                @SuppressWarnings(&quot;unchecked&quot;) NumberType&lt;Number&gt; type = (NumberType&lt;Number&gt;) column.type;</span>
<span class="nc" id="L521">                ByteBuffer increment = t.bindAndGet(params.options);</span>
<span class="nc" id="L522">                ByteBuffer current = getCurrentCellBuffer(partitionKey, params);</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">                if (current == null)</span>
<span class="nc" id="L524">                    return;</span>
<span class="nc" id="L525">                ByteBuffer newValue = type.add(type.compose(current), type.compose(increment));</span>
<span class="nc" id="L526">                params.addCell(column, newValue);</span>
<span class="nc" id="L527">            }</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">            else if (column.type instanceof StringType)</span>
            {
<span class="nc" id="L530">                ByteBuffer append = t.bindAndGet(params.options);</span>
<span class="nc" id="L531">                ByteBuffer current = getCurrentCellBuffer(partitionKey, params);</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">                if (current == null)</span>
<span class="nc" id="L533">                    return;</span>
<span class="nc" id="L534">                ByteBuffer newValue = ByteBuffer.allocate(current.remaining() + append.remaining());</span>
<span class="nc" id="L535">                FastByteOperations.copy(current, current.position(), newValue, newValue.position(), current.remaining());</span>
<span class="nc" id="L536">                FastByteOperations.copy(append, append.position(), newValue, newValue.position() + current.remaining(), append.remaining());</span>
<span class="nc" id="L537">                params.addCell(column, newValue);</span>
            }
<span class="fc" id="L539">        }</span>

        private ByteBuffer getCurrentCellBuffer(DecoratedKey key, UpdateParameters params)
        {
<span class="nc bnc" id="L543" title="All 2 branches missed.">            Row currentRow = params.getPrefetchedRow(key, column.isStatic() ? Clustering.STATIC_CLUSTERING : params.currentClustering());</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">            Cell&lt;?&gt; currentCell = currentRow == null ? null : currentRow.getCell(column);</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">            return currentCell == null ? null : currentCell.buffer();</span>
        }
    }

    public static class Substracter extends Operation
    {
        public Substracter(ColumnMetadata column, Term t)
        {
<span class="fc" id="L553">            super(column, t);</span>
<span class="fc" id="L554">        }</span>

        public void execute(DecoratedKey partitionKey, UpdateParameters params) throws InvalidRequestException
        {
<span class="fc" id="L558">            ByteBuffer bytes = t.bindAndGet(params.options);</span>
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">            if (bytes == null)</span>
<span class="nc" id="L560">                throw new InvalidRequestException(&quot;Invalid null value for counter increment&quot;);</span>
<span class="pc bpc" id="L561" title="1 of 2 branches missed.">            if (bytes == ByteBufferUtil.UNSET_BYTE_BUFFER)</span>
<span class="nc" id="L562">                return;</span>

<span class="fc" id="L564">            long increment = ByteBufferUtil.toLong(bytes);</span>
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">            if (increment == Long.MIN_VALUE)</span>
<span class="nc" id="L566">                throw new InvalidRequestException(&quot;The negation of &quot; + increment + &quot; overflows supported counter precision (signed 8 bytes integer)&quot;);</span>

<span class="fc" id="L568">            params.addCounter(column, -increment);</span>
<span class="fc" id="L569">        }</span>
    }

    // This happens to also handle collection because it doesn't felt worth
    // duplicating this further
    public static class Deleter extends Operation
    {
        public Deleter(ColumnMetadata column)
        {
<span class="fc" id="L578">            super(column, null);</span>
<span class="fc" id="L579">        }</span>

        public void execute(DecoratedKey partitionKey, UpdateParameters params) throws InvalidRequestException
        {
<span class="fc bfc" id="L583" title="All 2 branches covered.">            if (column.type.isMultiCell())</span>
<span class="fc" id="L584">                params.setComplexDeletionTime(column);</span>
            else
<span class="fc" id="L586">                params.addTombstone(column);</span>
<span class="fc" id="L587">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>