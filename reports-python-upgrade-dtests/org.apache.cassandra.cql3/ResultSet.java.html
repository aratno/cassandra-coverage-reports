<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ResultSet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3</a> &gt; <span class="el_source">ResultSet.java</span></div><h1>ResultSet.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3;

import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.List;
import java.util.Objects;

import com.google.common.annotations.VisibleForTesting;

import io.netty.buffer.ByteBuf;
import org.apache.cassandra.cql3.statements.SelectStatement;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.service.pager.PagingState;
import org.apache.cassandra.transport.CBCodec;
import org.apache.cassandra.transport.CBUtil;
import org.apache.cassandra.transport.DataType;
import org.apache.cassandra.transport.ProtocolVersion;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.MD5Digest;

public class ResultSet
{
<span class="fc" id="L46">    public static final Codec codec = new Codec();</span>

    public final ResultMetadata metadata;
    public final List&lt;List&lt;ByteBuffer&gt;&gt; rows;

    public ResultSet(ResultMetadata resultMetadata)
    {
<span class="nc" id="L53">        this(resultMetadata, new ArrayList&lt;List&lt;ByteBuffer&gt;&gt;());</span>
<span class="nc" id="L54">    }</span>

    public ResultSet(ResultMetadata resultMetadata, List&lt;List&lt;ByteBuffer&gt;&gt; rows)
<span class="fc" id="L57">    {</span>
<span class="fc" id="L58">        this.metadata = resultMetadata;</span>
<span class="fc" id="L59">        this.rows = rows;</span>
<span class="fc" id="L60">    }</span>

    public int size()
    {
<span class="fc" id="L64">        return rows.size();</span>
    }

    public boolean isEmpty()
    {
<span class="fc bfc" id="L69" title="All 2 branches covered.">        return size() == 0;</span>
    }

    public void addRow(List&lt;ByteBuffer&gt; row)
    {
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">        assert row.size() == metadata.valueCount();</span>
<span class="fc" id="L75">        rows.add(row);</span>
<span class="fc" id="L76">    }</span>

    public void addColumnValue(ByteBuffer value)
    {
<span class="nc bnc" id="L80" title="All 4 branches missed.">        if (rows.isEmpty() || lastRow().size() == metadata.valueCount())</span>
<span class="nc" id="L81">            rows.add(new ArrayList&lt;ByteBuffer&gt;(metadata.valueCount()));</span>

<span class="nc" id="L83">        lastRow().add(value);</span>
<span class="nc" id="L84">    }</span>

    private List&lt;ByteBuffer&gt; lastRow()
    {
<span class="nc" id="L88">        return rows.get(rows.size() - 1);</span>
    }

    public void reverse()
    {
<span class="nc" id="L93">        Collections.reverse(rows);</span>
<span class="nc" id="L94">    }</span>

    public void trim(int limit)
    {
<span class="fc" id="L98">        int toRemove = rows.size() - limit;</span>
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">        if (toRemove &gt; 0)</span>
        {
<span class="nc bnc" id="L101" title="All 2 branches missed.">            for (int i = 0; i &lt; toRemove; i++)</span>
<span class="nc" id="L102">                rows.remove(rows.size() - 1);</span>
        }
<span class="fc" id="L104">    }</span>

    @Override
    public String toString()
    {
        try
        {
<span class="nc" id="L111">            StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L112">            sb.append(metadata).append('\n');</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">            for (List&lt;ByteBuffer&gt; row : rows)</span>
            {
<span class="nc bnc" id="L115" title="All 2 branches missed.">                for (int i = 0; i &lt; row.size(); i++)</span>
                {
<span class="nc" id="L117">                    ByteBuffer v = row.get(i);</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">                    if (v == null)</span>
                    {
<span class="nc" id="L120">                        sb.append(&quot; | null&quot;);</span>
                    }
                    else
                    {
<span class="nc" id="L124">                        sb.append(&quot; | &quot;);</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">                        if (metadata.flags.contains(Flag.NO_METADATA))</span>
<span class="nc" id="L126">                            sb.append(&quot;0x&quot;).append(ByteBufferUtil.bytesToHex(v));</span>
                        else
<span class="nc" id="L128">                            sb.append(metadata.names.get(i).type.getString(v));</span>
                    }
                }
<span class="nc" id="L131">                sb.append('\n');</span>
<span class="nc" id="L132">            }</span>
<span class="nc" id="L133">            sb.append(&quot;---&quot;);</span>
<span class="nc" id="L134">            return sb.toString();</span>
        }
<span class="nc" id="L136">        catch (Exception e)</span>
        {
<span class="nc" id="L138">            throw new RuntimeException(e);</span>
        }
    }

<span class="fc" id="L142">    public static class Codec implements CBCodec&lt;ResultSet&gt;</span>
    {
        /*
         * Format:
         *   - metadata
         *   - rows count (4 bytes)
         *   - rows
         */
        public ResultSet decode(ByteBuf body, ProtocolVersion version)
        {
<span class="nc" id="L152">            ResultMetadata m = ResultMetadata.codec.decode(body, version);</span>
<span class="nc" id="L153">            int rowCount = body.readInt();</span>
<span class="nc" id="L154">            ResultSet rs = new ResultSet(m, new ArrayList&lt;List&lt;ByteBuffer&gt;&gt;(rowCount));</span>

            // rows
<span class="nc" id="L157">            int totalValues = rowCount * m.columnCount;</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">            for (int i = 0; i &lt; totalValues; i++)</span>
<span class="nc" id="L159">                rs.addColumnValue(CBUtil.readValue(body));</span>

<span class="nc" id="L161">            return rs;</span>
        }

        public void encode(ResultSet rs, ByteBuf dest, ProtocolVersion version)
        {
<span class="fc" id="L166">            ResultMetadata.codec.encode(rs.metadata, dest, version);</span>
<span class="fc" id="L167">            dest.writeInt(rs.rows.size());</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">            for (List&lt;ByteBuffer&gt; row : rs.rows)</span>
            {
                // Note that we do only want to serialize only the first columnCount values, even if the row
                // as more: see comment on ResultMetadata.names field.
<span class="fc bfc" id="L172" title="All 2 branches covered.">                for (int i = 0; i &lt; rs.metadata.columnCount; i++)</span>
<span class="fc" id="L173">                    CBUtil.writeValue(row.get(i), dest);</span>
<span class="fc" id="L174">            }</span>
<span class="fc" id="L175">        }</span>

        public int encodedSize(ResultSet rs, ProtocolVersion version)
        {
<span class="fc" id="L179">            int size = ResultMetadata.codec.encodedSize(rs.metadata, version) + 4;</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">            for (List&lt;ByteBuffer&gt; row : rs.rows)</span>
            {
<span class="fc bfc" id="L182" title="All 2 branches covered.">                for (int i = 0; i &lt; rs.metadata.columnCount; i++)</span>
<span class="fc" id="L183">                    size += CBUtil.sizeOfValue(row.get(i));</span>
<span class="fc" id="L184">            }</span>
<span class="fc" id="L185">            return size;</span>
        }
    }

    /**
     * The metadata for the results of executing a query or prepared statement.
     */
    public static class ResultMetadata
    {
<span class="fc" id="L194">        public static final CBCodec&lt;ResultMetadata&gt; codec = new Codec();</span>

<span class="fc" id="L196">        public static final ResultMetadata EMPTY = new ResultMetadata(MD5Digest.compute(new byte[0]), EnumSet.of(Flag.NO_METADATA), null, 0, null);</span>

        private final EnumSet&lt;Flag&gt; flags;
        // Please note that columnCount can actually be smaller than names, even if names is not null. This is
        // used to include columns in the resultSet that we need to do post-query re-orderings
        // (SelectStatement.orderResults) but that shouldn't be sent to the user as they haven't been requested
        // (CASSANDRA-4911). So the serialization code will exclude any columns in name whose index is &gt;= columnCount.
        public final List&lt;ColumnSpecification&gt; names;
        private final int columnCount;
        private PagingState pagingState;
        private final MD5Digest resultMetadataId;

        public ResultMetadata(MD5Digest digest, List&lt;ColumnSpecification&gt; names)
        {
<span class="fc" id="L210">            this(digest, EnumSet.noneOf(Flag.class), names, names.size(), null);</span>
<span class="pc bpc" id="L211" title="2 of 4 branches missed.">            if (!names.isEmpty() &amp;&amp; ColumnSpecification.allInSameTable(names))</span>
<span class="fc" id="L212">                flags.add(Flag.GLOBAL_TABLES_SPEC);</span>
<span class="fc" id="L213">        }</span>

        // Problem is that we compute the metadata from the columns on creation;
        // when re-preparing we create the intermediate object
        public ResultMetadata(List&lt;ColumnSpecification&gt; names)
        {
<span class="fc" id="L219">            this(names, null);</span>
<span class="fc" id="L220">        }</span>

        // Problem is that we compute the metadata from the columns on creation;
        // when re-preparing we create the intermediate object
        public ResultMetadata(List&lt;ColumnSpecification&gt; names, PagingState pagingState)
        {
<span class="fc" id="L226">            this(computeResultMetadataId(names), EnumSet.noneOf(Flag.class), names, names.size(), pagingState);</span>
<span class="pc bpc" id="L227" title="2 of 4 branches missed.">            if (!names.isEmpty() &amp;&amp; ColumnSpecification.allInSameTable(names))</span>
<span class="fc" id="L228">                flags.add(Flag.GLOBAL_TABLES_SPEC);</span>
<span class="fc" id="L229">        }</span>

        private ResultMetadata(MD5Digest resultMetadataId, EnumSet&lt;Flag&gt; flags, List&lt;ColumnSpecification&gt; names, int columnCount, PagingState pagingState)
<span class="fc" id="L232">        {</span>
<span class="fc" id="L233">            this.resultMetadataId = resultMetadataId;</span>
<span class="fc" id="L234">            this.flags = flags;</span>
<span class="fc" id="L235">            this.names = names;</span>
<span class="fc" id="L236">            this.columnCount = columnCount;</span>
<span class="fc" id="L237">            this.pagingState = pagingState;</span>
<span class="fc" id="L238">        }</span>

        public ResultMetadata copy()
        {
<span class="fc" id="L242">            return new ResultMetadata(resultMetadataId, EnumSet.copyOf(flags), names, columnCount, pagingState);</span>
        }

        /**
         * Return only the column names requested by the user, excluding those added for post-query re-orderings,
         * see definition of names and columnCount.
         **/
        public List&lt;ColumnSpecification&gt; requestNames()
        {
<span class="fc" id="L251">            return names.subList(0, columnCount);</span>
        }

        // The maximum number of values that the ResultSet can hold. This can be bigger than columnCount due to CASSANDRA-4911
        public int valueCount()
        {
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">            return names == null ? columnCount : names.size();</span>
        }

        @VisibleForTesting
        public EnumSet&lt;Flag&gt; getFlags()
        {
<span class="nc" id="L263">            return flags;</span>
        }

        @VisibleForTesting
        public int getColumnCount()
        {
<span class="nc" id="L269">            return columnCount;</span>
        }

        @VisibleForTesting
        public PagingState getPagingState()
        {
<span class="nc" id="L275">            return pagingState;</span>
        }

        /**
         * Adds the specified columns which will not be serialized.
         *
         * @param columns the columns
         */
        public ResultMetadata addNonSerializedColumns(Collection&lt;? extends ColumnSpecification&gt; columns)
        {
            // See comment above. Because columnCount doesn't account the newly added name, it
            // won't be serialized.
<span class="fc" id="L287">            names.addAll(columns);</span>
<span class="fc" id="L288">            return this;</span>
        }

        public void setHasMorePages(PagingState pagingState)
        {
<span class="fc" id="L293">            this.pagingState = pagingState;</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">            if (pagingState == null)</span>
<span class="nc" id="L295">                flags.remove(Flag.HAS_MORE_PAGES);</span>
            else
<span class="fc" id="L297">                flags.add(Flag.HAS_MORE_PAGES);</span>
<span class="fc" id="L298">        }</span>

        public void setSkipMetadata()
        {
<span class="fc" id="L302">            flags.add(Flag.NO_METADATA);</span>
<span class="fc" id="L303">        }</span>

        public void setMetadataChanged()
        {
<span class="nc" id="L307">            flags.add(Flag.METADATA_CHANGED);</span>
<span class="nc" id="L308">        }</span>

        public MD5Digest getResultMetadataId()
        {
<span class="fc" id="L312">            return resultMetadataId;</span>
        }

        public static ResultMetadata fromPrepared(CQLStatement statement)
        {
<span class="fc bfc" id="L317" title="All 2 branches covered.">            if (statement instanceof SelectStatement)</span>
<span class="fc" id="L318">                return ((SelectStatement)statement).getResultMetadata();</span>

<span class="fc" id="L320">            return ResultSet.ResultMetadata.EMPTY;</span>
        }

        @Override
        public boolean equals(Object other)
        {
<span class="nc bnc" id="L326" title="All 2 branches missed.">            if (this == other)</span>
<span class="nc" id="L327">                return true;</span>

<span class="nc bnc" id="L329" title="All 2 branches missed.">            if (!(other instanceof ResultMetadata))</span>
<span class="nc" id="L330">                return false;</span>

<span class="nc" id="L332">            ResultMetadata that = (ResultMetadata) other;</span>

<span class="nc bnc" id="L334" title="All 2 branches missed.">            return Objects.equals(flags, that.flags)</span>
<span class="nc bnc" id="L335" title="All 4 branches missed.">                   &amp;&amp; Objects.equals(names, that.names)</span>
                   &amp;&amp; columnCount == that.columnCount
<span class="nc bnc" id="L337" title="All 2 branches missed.">                   &amp;&amp; Objects.equals(pagingState, that.pagingState);</span>
        }

        @Override
        public int hashCode()
        {
<span class="nc" id="L343">            return Objects.hash(flags, names, columnCount, pagingState);</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L349">            StringBuilder sb = new StringBuilder();</span>

<span class="nc bnc" id="L351" title="All 2 branches missed.">            if (names == null)</span>
            {
<span class="nc" id="L353">                sb.append(&quot;[&quot;).append(columnCount).append(&quot; columns]&quot;);</span>
            }
            else
            {
<span class="nc bnc" id="L357" title="All 2 branches missed.">                for (ColumnSpecification name : names)</span>
                {
<span class="nc" id="L359">                    sb.append(&quot;[&quot;).append(name.name);</span>
<span class="nc" id="L360">                    sb.append(&quot;(&quot;).append(name.ksName).append(&quot;, &quot;).append(name.cfName).append(&quot;)&quot;);</span>
<span class="nc" id="L361">                    sb.append(&quot;, &quot;).append(name.type).append(&quot;]&quot;);</span>
<span class="nc" id="L362">                }</span>
            }
<span class="nc bnc" id="L364" title="All 2 branches missed.">            if (flags.contains(Flag.HAS_MORE_PAGES))</span>
<span class="nc" id="L365">                sb.append(&quot; (to be continued)&quot;);</span>
<span class="nc" id="L366">            return sb.toString();</span>
        }

<span class="fc" id="L369">        private static class Codec implements CBCodec&lt;ResultMetadata&gt;</span>
        {
            public ResultMetadata decode(ByteBuf body, ProtocolVersion version)
            {
                // flags &amp; column count
<span class="nc" id="L374">                int iflags = body.readInt();</span>
<span class="nc" id="L375">                int columnCount = body.readInt();</span>

<span class="nc" id="L377">                EnumSet&lt;Flag&gt; flags = Flag.deserialize(iflags);</span>

<span class="nc" id="L379">                MD5Digest resultMetadataId = null;</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">                if (flags.contains(Flag.METADATA_CHANGED))</span>
                {
<span class="nc bnc" id="L382" title="All 2 branches missed.">                    assert version.isGreaterOrEqualTo(ProtocolVersion.V5) : &quot;MetadataChanged flag is not supported before native protocol v5&quot;;</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">                    assert !flags.contains(Flag.NO_METADATA) : &quot;MetadataChanged and NoMetadata are mutually exclusive flags&quot;;</span>

<span class="nc" id="L385">                    resultMetadataId = MD5Digest.wrap(CBUtil.readBytes(body));</span>
                }

<span class="nc" id="L388">                PagingState state = null;</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">                if (flags.contains(Flag.HAS_MORE_PAGES))</span>
<span class="nc" id="L390">                    state = PagingState.deserialize(CBUtil.readValueNoCopy(body), version);</span>

<span class="nc bnc" id="L392" title="All 2 branches missed.">                if (flags.contains(Flag.NO_METADATA))</span>
<span class="nc" id="L393">                    return new ResultMetadata(null, flags, null, columnCount, state);</span>

<span class="nc" id="L395">                boolean globalTablesSpec = flags.contains(Flag.GLOBAL_TABLES_SPEC);</span>

<span class="nc" id="L397">                String globalKsName = null;</span>
<span class="nc" id="L398">                String globalCfName = null;</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">                if (globalTablesSpec)</span>
                {
<span class="nc" id="L401">                    globalKsName = CBUtil.readString(body);</span>
<span class="nc" id="L402">                    globalCfName = CBUtil.readString(body);</span>
                }

                // metadata (names/types)
<span class="nc" id="L406">                List&lt;ColumnSpecification&gt; names = new ArrayList&lt;ColumnSpecification&gt;(columnCount);</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">                for (int i = 0; i &lt; columnCount; i++)</span>
                {
<span class="nc bnc" id="L409" title="All 2 branches missed.">                    String ksName = globalTablesSpec ? globalKsName : CBUtil.readString(body);</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">                    String cfName = globalTablesSpec ? globalCfName : CBUtil.readString(body);</span>
<span class="nc" id="L411">                    ColumnIdentifier colName = new ColumnIdentifier(CBUtil.readString(body), true);</span>
<span class="nc" id="L412">                    AbstractType type = DataType.toType(DataType.codec.decodeOne(body, version));</span>
<span class="nc" id="L413">                    names.add(new ColumnSpecification(ksName, cfName, colName, type));</span>
                }
<span class="nc" id="L415">                return new ResultMetadata(resultMetadataId, flags, names, names.size(), state);</span>
            }

            public void encode(ResultMetadata m, ByteBuf dest, ProtocolVersion version)
            {
<span class="fc" id="L420">                boolean noMetadata = m.flags.contains(Flag.NO_METADATA);</span>
<span class="fc" id="L421">                boolean globalTablesSpec = m.flags.contains(Flag.GLOBAL_TABLES_SPEC);</span>
<span class="fc" id="L422">                boolean hasMorePages = m.flags.contains(Flag.HAS_MORE_PAGES);</span>
<span class="fc" id="L423">                boolean metadataChanged = m.flags.contains(Flag.METADATA_CHANGED);</span>
<span class="pc bpc" id="L424" title="5 of 6 branches missed.">                assert version.isGreaterThan(ProtocolVersion.V1) || (!hasMorePages &amp;&amp; !noMetadata)</span>
                    : &quot;version = &quot; + version + &quot;, flags = &quot; + m.flags;

<span class="fc" id="L427">                dest.writeInt(Flag.serialize(m.flags));</span>
<span class="fc" id="L428">                dest.writeInt(m.columnCount);</span>

<span class="fc bfc" id="L430" title="All 2 branches covered.">                if (hasMorePages)</span>
<span class="fc" id="L431">                    CBUtil.writeValue(m.pagingState.serialize(version), dest);</span>

<span class="pc bpc" id="L433" title="1 of 4 branches missed.">                if (version.isGreaterOrEqualTo(ProtocolVersion.V5)  &amp;&amp; metadataChanged)</span>
                {
<span class="nc bnc" id="L435" title="All 2 branches missed.">                    assert !noMetadata : &quot;MetadataChanged and NoMetadata are mutually exclusive flags&quot;;</span>
<span class="nc" id="L436">                    CBUtil.writeBytes(m.getResultMetadataId().bytes, dest);</span>
                }

<span class="fc bfc" id="L439" title="All 2 branches covered.">                if (!noMetadata)</span>
                {
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">                    if (globalTablesSpec)</span>
                    {
<span class="fc" id="L443">                        CBUtil.writeAsciiString(m.names.get(0).ksName, dest);</span>
<span class="fc" id="L444">                        CBUtil.writeAsciiString(m.names.get(0).cfName, dest);</span>
                    }

<span class="fc bfc" id="L447" title="All 2 branches covered.">                    for (int i = 0; i &lt; m.columnCount; i++)</span>
                    {
<span class="fc" id="L449">                        ColumnSpecification name = m.names.get(i);</span>
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">                        if (!globalTablesSpec)</span>
                        {
<span class="nc" id="L452">                            CBUtil.writeAsciiString(name.ksName, dest);</span>
<span class="nc" id="L453">                            CBUtil.writeAsciiString(name.cfName, dest);</span>
                        }
<span class="fc" id="L455">                        CBUtil.writeString(name.name.toString(), dest);</span>
<span class="fc" id="L456">                        DataType.codec.writeOne(DataType.fromType(name.type, version), dest, version);</span>
                    }
                }
<span class="fc" id="L459">            }</span>

            public int encodedSize(ResultMetadata m, ProtocolVersion version)
            {
<span class="fc" id="L463">                boolean noMetadata = m.flags.contains(Flag.NO_METADATA);</span>
<span class="fc" id="L464">                boolean globalTablesSpec = m.flags.contains(Flag.GLOBAL_TABLES_SPEC);</span>
<span class="fc" id="L465">                boolean hasMorePages = m.flags.contains(Flag.HAS_MORE_PAGES);</span>
<span class="fc" id="L466">                boolean metadataChanged = m.flags.contains(Flag.METADATA_CHANGED);</span>

<span class="fc" id="L468">                int size = 8;</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">                if (hasMorePages)</span>
<span class="fc" id="L470">                    size += CBUtil.sizeOfValue(m.pagingState.serializedSize(version));</span>

<span class="pc bpc" id="L472" title="1 of 4 branches missed.">                if (version.isGreaterOrEqualTo(ProtocolVersion.V5) &amp;&amp; metadataChanged)</span>
<span class="nc" id="L473">                    size += CBUtil.sizeOfBytes(m.getResultMetadataId().bytes);</span>

<span class="fc bfc" id="L475" title="All 2 branches covered.">                if (!noMetadata)</span>
                {
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">                    if (globalTablesSpec)</span>
                    {
<span class="fc" id="L479">                        size += CBUtil.sizeOfAsciiString(m.names.get(0).ksName);</span>
<span class="fc" id="L480">                        size += CBUtil.sizeOfAsciiString(m.names.get(0).cfName);</span>
                    }

<span class="fc bfc" id="L483" title="All 2 branches covered.">                    for (int i = 0; i &lt; m.columnCount; i++)</span>
                    {
<span class="fc" id="L485">                        ColumnSpecification name = m.names.get(i);</span>
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">                        if (!globalTablesSpec)</span>
                        {
<span class="nc" id="L488">                            size += CBUtil.sizeOfAsciiString(name.ksName);</span>
<span class="nc" id="L489">                            size += CBUtil.sizeOfAsciiString(name.cfName);</span>
                        }
<span class="fc" id="L491">                        size += CBUtil.sizeOfString(name.name.toString());</span>
<span class="fc" id="L492">                        size += DataType.codec.oneSerializedSize(DataType.fromType(name.type, version), version);</span>
                    }
                }
<span class="fc" id="L495">                return size;</span>
            }
        }
    }

    /**
     * The metadata for the query parameters in a prepared statement.
     */
    public static class PreparedMetadata
    {
<span class="fc" id="L505">        public static final CBCodec&lt;PreparedMetadata&gt; codec = new Codec();</span>

        private final EnumSet&lt;Flag&gt; flags;
        public final List&lt;ColumnSpecification&gt; names;
        private final short[] partitionKeyBindIndexes;

        public PreparedMetadata(List&lt;ColumnSpecification&gt; names, short[] partitionKeyBindIndexes)
        {
<span class="fc" id="L513">            this(EnumSet.noneOf(Flag.class), names, partitionKeyBindIndexes);</span>
<span class="pc bpc" id="L514" title="2 of 4 branches missed.">            if (!names.isEmpty() &amp;&amp; ColumnSpecification.allInSameTable(names))</span>
<span class="fc" id="L515">                flags.add(Flag.GLOBAL_TABLES_SPEC);</span>
<span class="fc" id="L516">        }</span>

        private PreparedMetadata(EnumSet&lt;Flag&gt; flags, List&lt;ColumnSpecification&gt; names, short[] partitionKeyBindIndexes)
<span class="fc" id="L519">        {</span>
<span class="fc" id="L520">            this.flags = flags;</span>
<span class="fc" id="L521">            this.names = names;</span>
<span class="fc" id="L522">            this.partitionKeyBindIndexes = partitionKeyBindIndexes;</span>
<span class="fc" id="L523">        }</span>

        public PreparedMetadata copy()
        {
<span class="nc" id="L527">            return new PreparedMetadata(EnumSet.copyOf(flags), names, partitionKeyBindIndexes);</span>
        }

        @Override
        public boolean equals(Object other)
        {
<span class="nc bnc" id="L533" title="All 2 branches missed.">            if (this == other)</span>
<span class="nc" id="L534">                return true;</span>

<span class="nc bnc" id="L536" title="All 2 branches missed.">            if (!(other instanceof PreparedMetadata))</span>
<span class="nc" id="L537">                return false;</span>

<span class="nc" id="L539">            PreparedMetadata that = (PreparedMetadata) other;</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">            return this.names.equals(that.names) &amp;&amp;</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">                   this.flags.equals(that.flags) &amp;&amp;</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">                   Arrays.equals(this.partitionKeyBindIndexes, that.partitionKeyBindIndexes);</span>
        }

        @Override
        public int hashCode()
        {
<span class="nc" id="L548">            return Objects.hash(names, flags) + Arrays.hashCode(partitionKeyBindIndexes);</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L554">            StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">            for (ColumnSpecification name : names)</span>
            {
<span class="nc" id="L557">                sb.append(&quot;[&quot;).append(name.name);</span>
<span class="nc" id="L558">                sb.append(&quot;(&quot;).append(name.ksName).append(&quot;, &quot;).append(name.cfName).append(&quot;)&quot;);</span>
<span class="nc" id="L559">                sb.append(&quot;, &quot;).append(name.type).append(&quot;]&quot;);</span>
<span class="nc" id="L560">            }</span>

<span class="nc" id="L562">            sb.append(&quot;, bindIndexes=[&quot;);</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">            if (partitionKeyBindIndexes != null)</span>
            {
<span class="nc bnc" id="L565" title="All 2 branches missed.">                for (int i = 0; i &lt; partitionKeyBindIndexes.length; i++)</span>
                {
<span class="nc bnc" id="L567" title="All 2 branches missed.">                    if (i &gt; 0)</span>
<span class="nc" id="L568">                        sb.append(&quot;, &quot;);</span>
<span class="nc" id="L569">                    sb.append(partitionKeyBindIndexes[i]);</span>
                }
            }
<span class="nc" id="L572">            sb.append(&quot;]&quot;);</span>
<span class="nc" id="L573">            return sb.toString();</span>
        }

        public static PreparedMetadata fromPrepared(CQLStatement statement)
        {
<span class="fc" id="L578">            return new PreparedMetadata(statement.getBindVariables(), statement.getPartitionKeyBindVariableIndexes());</span>
        }

        private static class Codec implements CBCodec&lt;PreparedMetadata&gt;
        {
            public PreparedMetadata decode(ByteBuf body, ProtocolVersion version)
            {
                // flags &amp; column count
<span class="nc" id="L586">                int iflags = body.readInt();</span>
<span class="nc" id="L587">                int columnCount = body.readInt();</span>

<span class="nc" id="L589">                EnumSet&lt;Flag&gt; flags = Flag.deserialize(iflags);</span>

<span class="nc" id="L591">                short[] partitionKeyBindIndexes = null;</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">                if (version.isGreaterOrEqualTo(ProtocolVersion.V4))</span>
                {
<span class="nc" id="L594">                    int numPKNames = body.readInt();</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">                    if (numPKNames &gt; 0)</span>
                    {
<span class="nc" id="L597">                        partitionKeyBindIndexes = new short[numPKNames];</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">                        for (int i = 0; i &lt; numPKNames; i++)</span>
<span class="nc" id="L599">                            partitionKeyBindIndexes[i] = body.readShort();</span>
                    }
                }

<span class="nc" id="L603">                boolean globalTablesSpec = flags.contains(Flag.GLOBAL_TABLES_SPEC);</span>

<span class="nc" id="L605">                String globalKsName = null;</span>
<span class="nc" id="L606">                String globalCfName = null;</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">                if (globalTablesSpec)</span>
                {
<span class="nc" id="L609">                    globalKsName = CBUtil.readString(body);</span>
<span class="nc" id="L610">                    globalCfName = CBUtil.readString(body);</span>
                }

                // metadata (names/types)
<span class="nc" id="L614">                List&lt;ColumnSpecification&gt; names = new ArrayList&lt;&gt;(columnCount);</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">                for (int i = 0; i &lt; columnCount; i++)</span>
                {
<span class="nc bnc" id="L617" title="All 2 branches missed.">                    String ksName = globalTablesSpec ? globalKsName : CBUtil.readString(body);</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">                    String cfName = globalTablesSpec ? globalCfName : CBUtil.readString(body);</span>
<span class="nc" id="L619">                    ColumnIdentifier colName = new ColumnIdentifier(CBUtil.readString(body), true);</span>
<span class="nc" id="L620">                    AbstractType type = DataType.toType(DataType.codec.decodeOne(body, version));</span>
<span class="nc" id="L621">                    names.add(new ColumnSpecification(ksName, cfName, colName, type));</span>
                }
<span class="nc" id="L623">                return new PreparedMetadata(flags, names, partitionKeyBindIndexes);</span>
            }

            public void encode(PreparedMetadata m, ByteBuf dest, ProtocolVersion version)
            {
<span class="fc" id="L628">                boolean globalTablesSpec = m.flags.contains(Flag.GLOBAL_TABLES_SPEC);</span>
<span class="fc" id="L629">                dest.writeInt(Flag.serialize(m.flags));</span>
<span class="fc" id="L630">                dest.writeInt(m.names.size());</span>

<span class="fc bfc" id="L632" title="All 2 branches covered.">                if (version.isGreaterOrEqualTo(ProtocolVersion.V4))</span>
                {
                    // there's no point in providing partition key bind indexes if the statements affect multiple tables
<span class="pc bpc" id="L635" title="2 of 4 branches missed.">                    if (m.partitionKeyBindIndexes == null || !globalTablesSpec)</span>
                    {
<span class="nc" id="L637">                        dest.writeInt(0);</span>
                    }
                    else
                    {
<span class="fc" id="L641">                        dest.writeInt(m.partitionKeyBindIndexes.length);</span>
<span class="fc bfc" id="L642" title="All 2 branches covered.">                        for (Short bindIndex : m.partitionKeyBindIndexes)</span>
<span class="fc" id="L643">                            dest.writeShort(bindIndex);</span>
                    }
                }

<span class="pc bpc" id="L647" title="1 of 2 branches missed.">                if (globalTablesSpec)</span>
                {
<span class="fc" id="L649">                    CBUtil.writeAsciiString(m.names.get(0).ksName, dest);</span>
<span class="fc" id="L650">                    CBUtil.writeAsciiString(m.names.get(0).cfName, dest);</span>
                }

<span class="fc bfc" id="L653" title="All 2 branches covered.">                for (ColumnSpecification name : m.names)</span>
                {
<span class="pc bpc" id="L655" title="1 of 2 branches missed.">                    if (!globalTablesSpec)</span>
                    {
<span class="nc" id="L657">                        CBUtil.writeAsciiString(name.ksName, dest);</span>
<span class="nc" id="L658">                        CBUtil.writeAsciiString(name.cfName, dest);</span>
                    }
<span class="fc" id="L660">                    CBUtil.writeString(name.name.toString(), dest);</span>
<span class="fc" id="L661">                    DataType.codec.writeOne(DataType.fromType(name.type, version), dest, version);</span>
<span class="fc" id="L662">                }</span>
<span class="fc" id="L663">            }</span>

            public int encodedSize(PreparedMetadata m, ProtocolVersion version)
            {
<span class="fc" id="L667">                boolean globalTablesSpec = m.flags.contains(Flag.GLOBAL_TABLES_SPEC);</span>
<span class="fc" id="L668">                int size = 8;</span>
<span class="pc bpc" id="L669" title="1 of 2 branches missed.">                if (globalTablesSpec)</span>
                {
<span class="fc" id="L671">                    size += CBUtil.sizeOfAsciiString(m.names.get(0).ksName);</span>
<span class="fc" id="L672">                    size += CBUtil.sizeOfAsciiString(m.names.get(0).cfName);</span>
                }

<span class="pc bpc" id="L675" title="1 of 4 branches missed.">                if (m.partitionKeyBindIndexes != null &amp;&amp; version.isGreaterOrEqualTo(ProtocolVersion.V4))</span>
<span class="fc" id="L676">                    size += 4 + 2 * m.partitionKeyBindIndexes.length;</span>

<span class="fc bfc" id="L678" title="All 2 branches covered.">                for (ColumnSpecification name : m.names)</span>
                {
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">                    if (!globalTablesSpec)</span>
                    {
<span class="nc" id="L682">                        size += CBUtil.sizeOfAsciiString(name.ksName);</span>
<span class="nc" id="L683">                        size += CBUtil.sizeOfAsciiString(name.cfName);</span>
                    }
<span class="fc" id="L685">                    size += CBUtil.sizeOfString(name.name.toString());</span>
<span class="fc" id="L686">                    size += DataType.codec.oneSerializedSize(DataType.fromType(name.type, version), version);</span>
<span class="fc" id="L687">                }</span>
<span class="fc" id="L688">                return size;</span>
            }
        }
    }

<span class="fc" id="L693">    public enum Flag</span>
    {
        // The order of that enum matters!!
<span class="fc" id="L696">        GLOBAL_TABLES_SPEC,</span>
<span class="fc" id="L697">        HAS_MORE_PAGES,</span>
<span class="fc" id="L698">        NO_METADATA,</span>
<span class="fc" id="L699">        METADATA_CHANGED;</span>

        public static EnumSet&lt;Flag&gt; deserialize(int flags)
        {
<span class="nc" id="L703">            EnumSet&lt;Flag&gt; set = EnumSet.noneOf(Flag.class);</span>
<span class="nc" id="L704">            Flag[] values = Flag.values();</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">            for (int n = 0; n &lt; values.length; n++)</span>
            {
<span class="nc bnc" id="L707" title="All 2 branches missed.">                if ((flags &amp; (1 &lt;&lt; n)) != 0)</span>
<span class="nc" id="L708">                    set.add(values[n]);</span>
            }
<span class="nc" id="L710">            return set;</span>
        }

        public static int serialize(EnumSet&lt;Flag&gt; flags)
        {
<span class="fc" id="L715">            int i = 0;</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">            for (Flag flag : flags)</span>
<span class="fc" id="L717">                i |= 1 &lt;&lt; flag.ordinal();</span>
<span class="fc" id="L718">            return i;</span>
        }
    }

    static MD5Digest computeResultMetadataId(List&lt;ColumnSpecification&gt; columnSpecifications)
    {
        // still using the MD5 MessageDigest thread local here instead of a HashingUtils/Guava
        // Hasher, as ResultSet will need to be changed alongside other usages of MD5
        // in the native transport/protocol and it seems to make more sense to do that
        // then than as part of the Guava Hasher refactor which is focused on non-client
        // protocol digests
<span class="fc" id="L729">        MessageDigest md = MD5Digest.threadLocalMD5Digest();</span>

<span class="pc bpc" id="L731" title="1 of 2 branches missed.">        if (columnSpecifications != null)</span>
        {
<span class="fc bfc" id="L733" title="All 2 branches covered.">            for (ColumnSpecification cs : columnSpecifications)</span>
            {
<span class="fc" id="L735">                md.update(cs.name.bytes.duplicate());</span>
<span class="fc" id="L736">                md.update((byte) 0);</span>
<span class="fc" id="L737">                md.update(cs.type.toString().getBytes(StandardCharsets.UTF_8));</span>
<span class="fc" id="L738">                md.update((byte) 0);</span>
<span class="fc" id="L739">                md.update((byte) 0);</span>
<span class="fc" id="L740">            }</span>
        }

<span class="fc" id="L743">        return MD5Digest.wrap(md.digest());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>