<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MultiColumnRelation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3</a> &gt; <span class="el_source">MultiColumnRelation.java</span></div><h1>MultiColumnRelation.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.cql3.Term.MultiColumnRaw;
import org.apache.cassandra.cql3.Term.Raw;
import org.apache.cassandra.cql3.restrictions.MultiColumnRestriction;
import org.apache.cassandra.cql3.restrictions.Restriction;
import org.apache.cassandra.cql3.statements.Bound;
import org.apache.cassandra.exceptions.InvalidRequestException;

import static org.apache.cassandra.cql3.statements.RequestValidations.checkFalse;
import static org.apache.cassandra.cql3.statements.RequestValidations.checkTrue;
import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;

/**
 * A relation using the tuple notation, which typically affects multiple columns.
 * Examples:
 * {@code
 *  - SELECT ... WHERE (a, b, c) &gt; (1, 'a', 10)
 *  - SELECT ... WHERE (a, b, c) IN ((1, 2, 3), (4, 5, 6))
 *  - SELECT ... WHERE (a, b) &lt; ?
 *  - SELECT ... WHERE (a, b) IN ?
 * }
 */
<span class="fc" id="L48">public class MultiColumnRelation extends Relation</span>
{
    private final List&lt;ColumnIdentifier&gt; entities;

    /** A Tuples.Literal or Tuples.Raw marker */
    private final Term.MultiColumnRaw valuesOrMarker;

    /** A list of Tuples.Literal or Tuples.Raw markers */
    private final List&lt;? extends Term.MultiColumnRaw&gt; inValues;

    private final Tuples.INRaw inMarker;

    private MultiColumnRelation(List&lt;ColumnIdentifier&gt; entities, Operator relationType, Term.MultiColumnRaw valuesOrMarker, List&lt;? extends Term.MultiColumnRaw&gt; inValues, Tuples.INRaw inMarker)
<span class="fc" id="L61">    {</span>
<span class="fc" id="L62">        this.entities = entities;</span>
<span class="fc" id="L63">        this.relationType = relationType;</span>
<span class="fc" id="L64">        this.valuesOrMarker = valuesOrMarker;</span>

<span class="fc" id="L66">        this.inValues = inValues;</span>
<span class="fc" id="L67">        this.inMarker = inMarker;</span>
<span class="fc" id="L68">    }</span>

    /**
     * Creates a multi-column EQ, LT, LTE, GT, or GTE relation.
     * {@code
     * For example: &quot;SELECT ... WHERE (a, b) &gt; (0, 1)&quot;
     * }
     * @param entities the columns on the LHS of the relation
     * @param relationType the relation operator
     * @param valuesOrMarker a Tuples.Literal instance or a Tuples.Raw marker
     * @return a new &lt;code&gt;MultiColumnRelation&lt;/code&gt; instance
     */
    public static MultiColumnRelation createNonInRelation(List&lt;ColumnIdentifier&gt; entities, Operator relationType, Term.MultiColumnRaw valuesOrMarker)
    {
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">        assert relationType != Operator.IN;</span>
<span class="fc" id="L83">        return new MultiColumnRelation(entities, relationType, valuesOrMarker, null, null);</span>
    }

    /**
     * Creates a multi-column IN relation with a list of IN values or markers.
     * For example: &quot;SELECT ... WHERE (a, b) IN ((0, 1), (2, 3))&quot;
     * @param entities the columns on the LHS of the relation
     * @param inValues a list of Tuples.Literal instances or a Tuples.Raw markers
     * @return a new &lt;code&gt;MultiColumnRelation&lt;/code&gt; instance
     */
    public static MultiColumnRelation createInRelation(List&lt;ColumnIdentifier&gt; entities, List&lt;? extends Term.MultiColumnRaw&gt; inValues)
    {
<span class="nc" id="L95">        return new MultiColumnRelation(entities, Operator.IN, null, inValues, null);</span>
    }

    /**
     * Creates a multi-column IN relation with a marker for the IN values.
     * For example: &quot;SELECT ... WHERE (a, b) IN ?&quot;
     * @param entities the columns on the LHS of the relation
     * @param inMarker a single IN marker
     * @return a new &lt;code&gt;MultiColumnRelation&lt;/code&gt; instance
     */
    public static MultiColumnRelation createSingleMarkerInRelation(List&lt;ColumnIdentifier&gt; entities, Tuples.INRaw inMarker)
    {
<span class="nc" id="L107">        return new MultiColumnRelation(entities, Operator.IN, null, null, inMarker);</span>
    }

    public List&lt;ColumnIdentifier&gt; getEntities()
    {
<span class="fc" id="L112">        return entities;</span>
    }

    /**
     * For non-IN relations, returns the Tuples.Literal or Tuples.Raw marker for a single tuple.
     * @return a Tuples.Literal for non-IN relations or Tuples.Raw marker for a single tuple.
     */
    public Term.MultiColumnRaw getValue()
    {
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">        return relationType == Operator.IN ? inMarker : valuesOrMarker;</span>
    }

    public List&lt;? extends Term.Raw&gt; getInValues()
    {
<span class="nc bnc" id="L126" title="All 2 branches missed.">        assert relationType == Operator.IN;</span>
<span class="nc" id="L127">        return inValues;</span>
    }

    @Override
    public boolean isMultiColumn()
    {
<span class="nc" id="L133">        return true;</span>
    }

    @Override
    protected Restriction newEQRestriction(TableMetadata table, VariableSpecifications boundNames)
    {
<span class="nc" id="L139">        List&lt;ColumnMetadata&gt; receivers = receivers(table);</span>
<span class="nc" id="L140">        Term term = toTerm(receivers, getValue(), table.keyspace, boundNames);</span>
<span class="nc" id="L141">        return new MultiColumnRestriction.EQRestriction(receivers, term);</span>
    }

    @Override
    protected Restriction newINRestriction(TableMetadata table, VariableSpecifications boundNames)
    {
<span class="nc" id="L147">        List&lt;ColumnMetadata&gt; receivers = receivers(table);</span>
<span class="nc" id="L148">        List&lt;Term&gt; terms = toTerms(receivers, inValues, table.keyspace, boundNames);</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">        if (terms == null)</span>
        {
<span class="nc" id="L151">            Term term = toTerm(receivers, getValue(), table.keyspace, boundNames);</span>
<span class="nc" id="L152">            return new MultiColumnRestriction.InRestrictionWithMarker(receivers, (AbstractMarker) term);</span>
        }

<span class="nc bnc" id="L155" title="All 2 branches missed.">        if (terms.size() == 1)</span>
<span class="nc" id="L156">            return new MultiColumnRestriction.EQRestriction(receivers, terms.get(0));</span>

<span class="nc" id="L158">        return new MultiColumnRestriction.InRestrictionWithValues(receivers, terms);</span>
    }

    @Override
    protected Restriction newSliceRestriction(TableMetadata table, VariableSpecifications boundNames, Bound bound, boolean inclusive)
    {
<span class="fc" id="L164">        List&lt;ColumnMetadata&gt; receivers = receivers(table);</span>
<span class="fc" id="L165">        Term term = toTerm(receivers(table), getValue(), table.keyspace, boundNames);</span>
<span class="fc" id="L166">        return new MultiColumnRestriction.SliceRestriction(receivers, bound, inclusive, term);</span>
    }

    @Override
    protected Restriction newContainsRestriction(TableMetadata table, VariableSpecifications boundNames, boolean isKey)
    {
<span class="nc" id="L172">        throw invalidRequest(&quot;%s cannot be used for multi-column relations&quot;, operator());</span>
    }

    @Override
    protected Restriction newIsNotRestriction(TableMetadata table, VariableSpecifications boundNames)
    {
        // this is currently disallowed by the grammar
<span class="nc" id="L179">        throw new AssertionError(String.format(&quot;%s cannot be used for multi-column relations&quot;, operator()));</span>
    }

    @Override
    protected Restriction newLikeRestriction(TableMetadata table, VariableSpecifications boundNames, Operator operator)
    {
<span class="nc" id="L185">        throw invalidRequest(&quot;%s cannot be used for multi-column relations&quot;, operator());</span>
    }

    @Override
    protected Term toTerm(List&lt;? extends ColumnSpecification&gt; receivers,
                          Raw raw,
                          String keyspace,
                          VariableSpecifications boundNames) throws InvalidRequestException
    {
<span class="fc" id="L194">        Term term = ((MultiColumnRaw) raw).prepare(keyspace, receivers);</span>
<span class="fc" id="L195">        term.collectMarkerSpecification(boundNames);</span>
<span class="fc" id="L196">        return term;</span>
    }

    protected List&lt;ColumnMetadata&gt; receivers(TableMetadata table) throws InvalidRequestException
    {
<span class="fc" id="L201">        List&lt;ColumnMetadata&gt; names = new ArrayList&lt;&gt;(getEntities().size());</span>
<span class="fc" id="L202">        int previousPosition = -1;</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">        for (ColumnIdentifier id : getEntities())</span>
        {
<span class="fc" id="L205">            ColumnMetadata def = table.getExistingColumn(id);</span>
<span class="fc" id="L206">            checkTrue(def.isClusteringColumn(), &quot;Multi-column relations can only be applied to clustering columns but was applied to: %s&quot;, def.name);</span>
<span class="fc" id="L207">            checkFalse(names.contains(def), &quot;Column \&quot;%s\&quot; appeared twice in a relation: %s&quot;, def.name, this);</span>

            // check that no clustering columns were skipped
<span class="fc bfc" id="L210" title="All 4 branches covered.">            checkFalse(previousPosition != -1 &amp;&amp; def.position() != previousPosition + 1,</span>
                       &quot;Clustering columns must appear in the PRIMARY KEY order in multi-column relations: %s&quot;, this);

<span class="fc" id="L213">            names.add(def);</span>
<span class="fc" id="L214">            previousPosition = def.position();</span>
<span class="fc" id="L215">        }</span>
<span class="fc" id="L216">        return names;</span>
    }

    @Override
    public Relation renameIdentifier(ColumnIdentifier from, ColumnIdentifier to)
    {
<span class="nc bnc" id="L222" title="All 2 branches missed.">        if (!entities.contains(from))</span>
<span class="nc" id="L223">            return this;</span>

<span class="nc bnc" id="L225" title="All 2 branches missed.">        List&lt;ColumnIdentifier&gt; newEntities = entities.stream().map(e -&gt; e.equals(from) ? to : e).collect(Collectors.toList());</span>
<span class="nc" id="L226">        return new MultiColumnRelation(newEntities, operator(), valuesOrMarker, inValues, inMarker);</span>
    }

    @Override
    public String toCQLString()
    {
<span class="fc" id="L232">        StringBuilder builder = new StringBuilder(Tuples.tupleToString(entities, ColumnIdentifier::toCQLString));</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">        if (isIN())</span>
        {
<span class="nc" id="L235">            return builder.append(&quot; IN &quot;)</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">                          .append(inMarker != null ? '?' : Tuples.tupleToString(inValues))</span>
<span class="nc" id="L237">                          .toString();</span>
        }
<span class="fc" id="L239">        return builder.append(&quot; &quot;)</span>
<span class="fc" id="L240">                      .append(relationType)</span>
<span class="fc" id="L241">                      .append(&quot; &quot;)</span>
<span class="fc" id="L242">                      .append(valuesOrMarker)</span>
<span class="fc" id="L243">                      .toString();</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L249">        return Objects.hash(relationType, entities, valuesOrMarker, inValues, inMarker);</span>
    }

    @Override
    public boolean equals(Object o)
    {
<span class="nc bnc" id="L255" title="All 2 branches missed.">        if (this == o)</span>
<span class="nc" id="L256">            return true;</span>

<span class="nc bnc" id="L258" title="All 2 branches missed.">        if (!(o instanceof MultiColumnRelation))</span>
<span class="nc" id="L259">            return false;</span>

<span class="nc" id="L261">        MultiColumnRelation mcr = (MultiColumnRelation) o;</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">        return Objects.equals(entities, mcr.entities)</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">            &amp;&amp; Objects.equals(relationType, mcr.relationType)</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">            &amp;&amp; Objects.equals(valuesOrMarker, mcr.valuesOrMarker)</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">            &amp;&amp; Objects.equals(inValues, mcr.inValues)</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">            &amp;&amp; Objects.equals(inMarker, mcr.inMarker);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>