<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CIDR.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3</a> &gt; <span class="el_source">CIDR.java</span></div><h1>CIDR.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3;

import java.net.Inet4Address;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.Objects;

import org.apache.cassandra.utils.Pair;

/**
 * Contains a CIDR, and operations on it
 */
public final class CIDR
{
    private final InetAddress startIpAddress;
    private final InetAddress endIpAddress;
    // max mask value with IPv6 is 128, not easy to handle value 128 using Byte, hence using short
    private final short netMask;

    /**
     * Generates a CIDR from given IP and netmask
     * @param ipAddress IP address of CIDR
     * @param netMask   netmask of CIDR
     */
    public CIDR(InetAddress ipAddress, short netMask)
<span class="nc" id="L44">    {</span>
<span class="nc bnc" id="L45" title="All 2 branches missed.">        if (netMask &gt; maxNetMaskAllowed(ipAddress))</span>
<span class="nc" id="L46">            throw new IllegalArgumentException(&quot;Invalid netmask &quot; + netMask + &quot; for IP &quot; + ipAddress.getHostAddress());</span>

<span class="nc" id="L48">        Pair&lt;InetAddress, InetAddress&gt; ipRange = calcIpRangeOfCidr(ipAddress, netMask);</span>
<span class="nc" id="L49">        this.startIpAddress = ipRange.left();</span>
<span class="nc" id="L50">        this.endIpAddress = ipRange.right();</span>
<span class="nc" id="L51">        this.netMask = netMask;</span>
<span class="nc" id="L52">    }</span>

    /**
     * Generates a CIDR from given string
     * @param cidrStr CIDR as string
     */
    public static CIDR getInstance(String cidrStr)
    {
<span class="nc bnc" id="L60" title="All 4 branches missed.">        if (cidrStr == null || cidrStr.isEmpty())</span>
        {
<span class="nc" id="L62">            throw new IllegalArgumentException(String.format(&quot;%s is not a valid CIDR String&quot;, cidrStr));</span>
        }

<span class="nc" id="L65">        String[] parts = cidrStr.split(&quot;/&quot;);</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">        if (parts.length != 2)</span>
        {
<span class="nc" id="L68">            throw new IllegalArgumentException(String.format(&quot;%s is not a valid CIDR String&quot;, cidrStr));</span>
        }

<span class="nc" id="L71">        short netMask = Short.parseShort(parts[1]);</span>

        InetAddress ipAddress;
        try
        {
<span class="nc" id="L76">            ipAddress = InetAddress.getByName(parts[0]);</span>
<span class="nc bnc" id="L77" title="All 6 branches missed.">            if (ipAddress instanceof Inet4Address &amp;&amp; parts[0].contains(&quot;:&quot;) &amp;&amp; parts[0].contains(&quot;.&quot;))</span>
            {
                // Input string is in IPv4 mapped IPv6 format. InetAddress converted it to IPv4
                // So adjust the net mask accordingly
                // example, 0:0:0:0:0:ffff:192.1.56.10/96 would be converted to 192.1.56.10/0
<span class="nc" id="L82">                netMask -= 96; // 6 * 16 bits</span>
            }
        }
<span class="nc" id="L85">        catch (UnknownHostException e)</span>
        {
<span class="nc" id="L87">            throw new IllegalArgumentException(String.format(&quot;%s is not a valid CIDR String&quot;, cidrStr));</span>
<span class="nc" id="L88">        }</span>

<span class="nc" id="L90">        short maxMaskValue = maxNetMaskAllowed(ipAddress);</span>
<span class="nc bnc" id="L91" title="All 4 branches missed.">        if (netMask &lt; 0 || netMask &gt; maxMaskValue)</span>
        {
<span class="nc" id="L93">            throw new IllegalArgumentException(String.format(&quot;%s is not a valid CIDR String&quot;, cidrStr));</span>
        }

<span class="nc" id="L96">        return new CIDR(ipAddress, netMask);</span>
    }

    private static short maxNetMaskAllowed(InetAddress ipAddress)
    {
<span class="nc bnc" id="L101" title="All 2 branches missed.">        if (ipAddress instanceof Inet6Address)</span>
<span class="nc" id="L102">            return 128;</span>

<span class="nc" id="L104">        return 32;</span>
    }

    /**
     * This function calculates starting and ending IP of a CIDR.
     * For example, for CIDR 10.20.33.40/24, starting IP is 10.20.33.0, ending IP is 10.20.33.255
     * @param ipAddress IP address of the CIDR
     * @param netMask   net mask of the CIDR
     * @return pair of starting and ending IP of the CIDR
     */
    private static Pair&lt;InetAddress, InetAddress&gt; calcIpRangeOfCidr(InetAddress ipAddress, short netMask)
    {
<span class="nc bnc" id="L116" title="All 2 branches missed.">        if (netMask &gt; maxNetMaskAllowed(ipAddress))</span>
<span class="nc" id="L117">            throw new IllegalArgumentException(&quot;Invalid netmask &quot; + netMask + &quot; for IP &quot; + ipAddress.getHostAddress());</span>

        // Starting and ending IP are same as CIDR's IP if net mask is 32 for IPv4, 128 for IPv6
<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (netMask == maxNetMaskAllowed(ipAddress))</span>
<span class="nc" id="L121">            return Pair.create(ipAddress, ipAddress);</span>

<span class="nc" id="L123">        byte[] startIpBytes = ipAddress.getAddress();</span>
<span class="nc" id="L124">        byte[] endIpBytes = ipAddress.getAddress();</span>

        // netmask indicates number of bits to remain unchanged. Let's call that as netmask bit.
        // Calculate the offset of the byte where netmask bit ends
<span class="nc" id="L128">        int byteOffset = netMask / Byte.SIZE;</span>

        // Calculate the bit number within that byte, where netmask bit ends
<span class="nc" id="L131">        int bitOffset = netMask % Byte.SIZE;</span>

        // In that byte, set bits after netmask bit to 0 for starting IP, to 1 for ending IP,
        // keeping bits before including netmask bit as it is
<span class="nc" id="L135">        int unsignedByte = Byte.toUnsignedInt(startIpBytes[byteOffset]);</span>
<span class="nc" id="L136">        startIpBytes[byteOffset] = (byte) (unsignedByte &amp; (0xff &lt;&lt; (Byte.SIZE - bitOffset)));</span>
<span class="nc" id="L137">        endIpBytes[byteOffset] = (byte) (unsignedByte | (0xFF &gt;&gt;&gt; bitOffset));</span>

        // set all remaining bits after netmask to 0
<span class="nc bnc" id="L140" title="All 2 branches missed.">        for (byteOffset += 1; byteOffset &lt; startIpBytes.length; byteOffset++)</span>
        {
<span class="nc" id="L142">            startIpBytes[byteOffset] = 0;</span>
<span class="nc" id="L143">            endIpBytes[byteOffset] = (byte) 0xFF;</span>
        }

        try
        {
<span class="nc" id="L148">            return Pair.create(InetAddress.getByAddress(startIpBytes), InetAddress.getByAddress(endIpBytes));</span>
        }
<span class="nc" id="L150">        catch (UnknownHostException e)</span>
        {
<span class="nc" id="L152">            throw new IllegalStateException(&quot;Invalid bytes for constructing IP&quot;, e);</span>
        }
    }

    /**
     * Get starting IP of the CIDR
     * @return returns IP address
     */
    public InetAddress getStartIpAddress()
    {
<span class="nc" id="L162">        return startIpAddress;</span>
    }

    /**
     * Get ending IP of the CIDR
     * @return returns IP address
     */
    public InetAddress getEndIpAddress()
    {
<span class="nc" id="L171">        return endIpAddress;</span>
    }

    /**
     * Get netmask of the CIDR
     * @return returns netmask as short
     */
    public short getNetMask()
    {
<span class="nc" id="L180">        return netMask;</span>
    }

    /**
     * Tells is this IPv4 format CIDR
     * @return true if IPv4 CIDR, otherwise false
     */
    public boolean isIPv4()
    {
<span class="nc" id="L189">        return (startIpAddress instanceof Inet4Address);</span>
    }

    /**
     * Tells is this IPv6 format CIDR
     * @return true if IPv6 CIDR, otherwise false
     */
    public boolean isIPv6()
    {
<span class="nc" id="L198">        return (startIpAddress instanceof Inet6Address);</span>
    }

    public boolean equals(Object o)
    {
<span class="nc bnc" id="L203" title="All 2 branches missed.">        if (this == o)</span>
<span class="nc" id="L204">            return true;</span>

<span class="nc bnc" id="L206" title="All 4 branches missed.">        if (o == null || getClass() != o.getClass())</span>
<span class="nc" id="L207">            return false;</span>

<span class="nc" id="L209">        CIDR cidr = (CIDR) o;</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">        return netMask == cidr.netMask &amp;&amp;</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">               startIpAddress.equals(cidr.startIpAddress) &amp;&amp;</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">               endIpAddress.equals(cidr.endIpAddress);</span>
    }

    public int hashCode()
    {
<span class="nc" id="L217">        return Objects.hash(startIpAddress, endIpAddress, netMask);</span>
    }

    /**
     * Constructs CIDR as string
     * @return returns CIDR as string
     */
    @Override
    public String toString()
    {
<span class="nc" id="L227">        return this.startIpAddress.getHostAddress() + '/' + this.netMask;</span>
    }

    public String asCqlTupleString()
    {
<span class="nc" id="L232">        return &quot;('&quot; + this.startIpAddress.getHostAddress() + &quot;', &quot; + this.netMask + ')';</span>
    }

    /**
     * Compare 2 IpAddresses objects lexicographically
     * @return true if IP ranges overlap with each other; otherwise, return false
     */
    public static int compareIPs(InetAddress l, InetAddress r)
    {
<span class="nc" id="L241">        byte[] lBytes = l.getAddress();</span>
<span class="nc" id="L242">        byte[] rBytes = r.getAddress();</span>

<span class="nc bnc" id="L244" title="All 2 branches missed.">        for (int i = 0; i &lt; lBytes.length; i++)</span>
        {
<span class="nc" id="L246">            int comp = Byte.toUnsignedInt(lBytes[i]) - Byte.toUnsignedInt(rBytes[i]);</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">            if (comp != 0)</span>
            {
<span class="nc" id="L249">                return comp;</span>
            }
        }
<span class="nc" id="L252">        return 0;</span>
    }

    public static boolean overlaps(CIDR left, CIDR right)
    {
        // Sort IP ranges by the start address
<span class="nc" id="L258">        CIDR lower = left;</span>
<span class="nc" id="L259">        CIDR higher = right;</span>

<span class="nc bnc" id="L261" title="All 2 branches missed.">        if (compareIPs(left.startIpAddress, right.startIpAddress) &gt; 0)</span>
        {
<span class="nc" id="L263">            lower = right;</span>
<span class="nc" id="L264">            higher = left;</span>
        }

        // Overlaps when lower end is &gt;= to higher start address
<span class="nc bnc" id="L268" title="All 2 branches missed.">        return compareIPs(lower.endIpAddress, higher.startIpAddress) &gt;= 0;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>