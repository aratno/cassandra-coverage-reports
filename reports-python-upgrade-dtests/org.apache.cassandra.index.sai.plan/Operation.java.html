<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Operation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.index.sai.plan</a> &gt; <span class="el_source">Operation.java</span></div><h1>Operation.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.index.sai.plan;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.function.BiFunction;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Iterables;
import com.google.common.collect.ListMultimap;

import org.apache.cassandra.cql3.Operator;
import org.apache.cassandra.db.filter.RowFilter;
import org.apache.cassandra.index.sai.IndexContext;
import org.apache.cassandra.index.sai.analyzer.AbstractAnalyzer;
import org.apache.cassandra.index.sai.iterators.KeyRangeIterator;
import org.apache.cassandra.index.sai.utils.TypeUtil;
import org.apache.cassandra.schema.ColumnMetadata;

<span class="nc" id="L40">public class Operation</span>
{
<span class="nc" id="L42">    public enum BooleanOperator</span>
    {
<span class="nc" id="L44">        AND((a, b) -&gt; a &amp; b);</span>

        private final BiFunction&lt;Boolean, Boolean, Boolean&gt; func;

        BooleanOperator(BiFunction&lt;Boolean, Boolean, Boolean&gt; func)
<span class="nc" id="L49">        {</span>
<span class="nc" id="L50">            this.func = func;</span>
<span class="nc" id="L51">        }</span>

        public boolean apply(boolean a, boolean b)
        {
<span class="nc" id="L55">            return func.apply(a, b);</span>
        }
    }

    @VisibleForTesting
    protected static ListMultimap&lt;ColumnMetadata, Expression&gt; buildIndexExpressions(QueryController controller,
                                                                                    BooleanOperator booleanOperator,
                                                                                    List&lt;RowFilter.Expression&gt; expressions)
    {
<span class="nc" id="L64">        ListMultimap&lt;ColumnMetadata, Expression&gt; analyzed = ArrayListMultimap.create();</span>

        // sort all the expressions in the operation by name and priority of the logical operator
        // this gives us an efficient way to handle inequality and combining into ranges without extra processing
        // and converting expressions from one type to another.
<span class="nc" id="L69">        expressions.sort((a, b) -&gt; {</span>
<span class="nc" id="L70">            int cmp = a.column().compareTo(b.column());</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">            return cmp == 0 ? -Integer.compare(getPriority(a.operator()), getPriority(b.operator())) : cmp;</span>
        });

<span class="nc bnc" id="L74" title="All 2 branches missed.">        for (final RowFilter.Expression e : expressions)</span>
        {
<span class="nc" id="L76">            IndexContext indexContext = controller.getContext(e);</span>
<span class="nc" id="L77">            List&lt;Expression&gt; perColumn = analyzed.get(e.column());</span>

<span class="nc" id="L79">            AbstractAnalyzer analyzer = indexContext.getAnalyzerFactory().create();</span>
            try
            {
<span class="nc" id="L82">                analyzer.reset(e.getIndexValue().duplicate());</span>

                // EQ can have multiple expressions e.g. text = &quot;Hello World&quot;,
                // becomes text = &quot;Hello&quot; OR text = &quot;World&quot; because &quot;space&quot; is always interpreted as a split point (by analyzer),
                // CONTAINS/CONTAINS_KEY are always treated as multiple expressions since they currently only targetting
                // collections.
<span class="nc" id="L88">                boolean isMultiExpression = false;</span>
<span class="nc bnc" id="L89" title="All 3 branches missed.">                switch (e.operator())</span>
                {
                    case EQ:
                        // EQ operator will always be a multiple expression because it is being used by
                        // map entries
<span class="nc" id="L94">                        isMultiExpression = indexContext.isNonFrozenCollection();</span>
<span class="nc" id="L95">                        break;</span>

                    case CONTAINS:
                    case CONTAINS_KEY:
<span class="nc" id="L99">                        isMultiExpression = true;</span>
                        break;
                }
<span class="nc bnc" id="L102" title="All 2 branches missed.">                if (isMultiExpression)</span>
                {
<span class="nc bnc" id="L104" title="All 2 branches missed.">                    while (analyzer.hasNext())</span>
                    {
<span class="nc" id="L106">                        final ByteBuffer token = analyzer.next();</span>
<span class="nc" id="L107">                        perColumn.add(new Expression(indexContext).add(e.operator(), token.duplicate()));</span>
<span class="nc" id="L108">                    }</span>
                }
                else
                // &quot;range&quot; or not-equals operator, combines both bounds together into the single expression,
                // if operation of the group is AND, otherwise we are forced to create separate expressions,
                // not-equals is combined with the range iff operator is AND.
                {
                    Expression range;
<span class="nc bnc" id="L116" title="All 4 branches missed.">                    if (perColumn.size() == 0 || booleanOperator != BooleanOperator.AND)</span>
                    {
<span class="nc" id="L118">                        range = new Expression(indexContext);</span>
<span class="nc" id="L119">                        perColumn.add(range);</span>
                    }
                    else
                    {
<span class="nc" id="L123">                        range = Iterables.getLast(perColumn);</span>
                    }

<span class="nc bnc" id="L126" title="All 2 branches missed.">                    if (!TypeUtil.isLiteral(indexContext.getValidator()))</span>
                    {
<span class="nc" id="L128">                        range.add(e.operator(), e.getIndexValue().duplicate());</span>
                    }
                    else
                    {
<span class="nc bnc" id="L132" title="All 2 branches missed.">                        while (analyzer.hasNext())</span>
                        {
<span class="nc" id="L134">                            ByteBuffer term = analyzer.next();</span>
<span class="nc" id="L135">                            range.add(e.operator(), term.duplicate());</span>
<span class="nc" id="L136">                        }</span>
                    }
                }
            }
            finally
            {
<span class="nc" id="L142">                analyzer.end();</span>
            }
<span class="nc" id="L144">        }</span>

<span class="nc" id="L146">        return analyzed;</span>
    }

    private static int getPriority(Operator op)
    {
<span class="nc bnc" id="L151" title="All 4 branches missed.">        switch (op)</span>
        {
            case EQ:
            case CONTAINS:
            case CONTAINS_KEY:
<span class="nc" id="L156">                return 5;</span>

            case GTE:
            case GT:
<span class="nc" id="L160">                return 3;</span>

            case LTE:
            case LT:
<span class="nc" id="L164">                return 2;</span>

            default:
<span class="nc" id="L167">                return 0;</span>
        }
    }

    /**
     * Converts expressions into filter tree for query.
     *
     * @return a KeyRangeIterator over the index query results
     */
    static KeyRangeIterator buildIterator(QueryController controller)
    {
<span class="nc" id="L178">        return Node.buildTree(controller.filterOperation()).analyzeTree(controller).rangeIterator(controller);</span>
    }

    /**
     * Converts expressions into filter tree (which is currently just a single AND).
     *
     * Filter tree allows us to do a couple of important optimizations
     * namely, group flattening for AND operations (query rewrite), expression bounds checks,
     * &quot;satisfies by&quot; checks for resulting rows with an early exit.
     *
     * @return root of the filter tree.
     */
    static FilterTree buildFilter(QueryController controller)
    {
<span class="nc" id="L192">        return Node.buildTree(controller.filterOperation()).buildFilter(controller);</span>
    }

<span class="nc" id="L195">    static abstract class Node</span>
    {
        ListMultimap&lt;ColumnMetadata, Expression&gt; expressionMap;

        boolean canFilter()
        {
<span class="nc bnc" id="L201" title="All 6 branches missed.">            return (expressionMap != null &amp;&amp; !expressionMap.isEmpty()) || !children().isEmpty();</span>
        }

        List&lt;Node&gt; children()
        {
<span class="nc" id="L206">            return Collections.emptyList();</span>
        }

        void add(Node child)
        {
<span class="nc" id="L211">            throw new UnsupportedOperationException();</span>
        }

        RowFilter.Expression expression()
        {
<span class="nc" id="L216">            throw new UnsupportedOperationException();</span>
        }

        abstract void analyze(List&lt;RowFilter.Expression&gt; expressionList, QueryController controller);

        abstract FilterTree filterTree();

        abstract KeyRangeIterator rangeIterator(QueryController controller);

        static Node buildTree(RowFilter filterOperation)
        {
<span class="nc" id="L227">            OperatorNode node = new AndNode();</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">            for (RowFilter.Expression expression : filterOperation.getExpressions())</span>
<span class="nc" id="L229">                node.add(buildExpression(expression));</span>
<span class="nc" id="L230">            return node;</span>
        }

        static Node buildExpression(RowFilter.Expression expression)
        {
<span class="nc" id="L235">            return new ExpressionNode(expression);</span>
        }

        Node analyzeTree(QueryController controller)
        {
<span class="nc" id="L240">            List&lt;RowFilter.Expression&gt; expressionList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L241">            doTreeAnalysis(this, expressionList, controller);</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">            if (!expressionList.isEmpty())</span>
<span class="nc" id="L243">                this.analyze(expressionList, controller);</span>
<span class="nc" id="L244">            return this;</span>
        }

        void doTreeAnalysis(Node node, List&lt;RowFilter.Expression&gt; expressions, QueryController controller)
        {
<span class="nc bnc" id="L249" title="All 2 branches missed.">            if (node.children().isEmpty())</span>
<span class="nc" id="L250">                expressions.add(node.expression());</span>
            else
            {
<span class="nc" id="L253">                List&lt;RowFilter.Expression&gt; expressionList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">                for (Node child : node.children())</span>
<span class="nc" id="L255">                    doTreeAnalysis(child, expressionList, controller);</span>
<span class="nc" id="L256">                node.analyze(expressionList, controller);</span>
            }
<span class="nc" id="L258">        }</span>

        FilterTree buildFilter(QueryController controller)
        {
<span class="nc" id="L262">            analyzeTree(controller);</span>
<span class="nc" id="L263">            FilterTree tree = filterTree();</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">            for (Node child : children())</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">                if (child.canFilter())</span>
<span class="nc" id="L266">                    tree.addChild(child.buildFilter(controller));</span>
<span class="nc" id="L267">            return tree;</span>
        }
    }

<span class="nc" id="L271">    static abstract class OperatorNode extends Node</span>
    {
<span class="nc" id="L273">        final List&lt;Node&gt; children = new ArrayList&lt;&gt;();</span>

        @Override
        public List&lt;Node&gt; children()
        {
<span class="nc" id="L278">            return children;</span>
        }

        @Override
        public void add(Node child)
        {
<span class="nc" id="L284">            children.add(child);</span>
<span class="nc" id="L285">        }</span>
    }

<span class="nc" id="L288">    static class AndNode extends OperatorNode</span>
    {
        @Override
        public void analyze(List&lt;RowFilter.Expression&gt; expressionList, QueryController controller)
        {
<span class="nc" id="L293">            expressionMap = buildIndexExpressions(controller, BooleanOperator.AND, expressionList);</span>
<span class="nc" id="L294">        }</span>

        @Override
        FilterTree filterTree()
        {
<span class="nc" id="L299">            return new FilterTree(BooleanOperator.AND, expressionMap);</span>
        }

        @Override
        KeyRangeIterator rangeIterator(QueryController controller)
        {
<span class="nc" id="L305">            KeyRangeIterator.Builder builder = controller.getIndexQueryResults(expressionMap.values());</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">            for (Node child : children)</span>
            {
<span class="nc" id="L308">                boolean canFilter = child.canFilter();</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">                if (canFilter)</span>
<span class="nc" id="L310">                    builder.add(child.rangeIterator(controller));</span>
<span class="nc" id="L311">            }</span>
<span class="nc" id="L312">            return builder.build();</span>
        }
    }

<span class="nc" id="L316">    static class ExpressionNode extends Node</span>
    {
        final RowFilter.Expression expression;

        @Override
        public void analyze(List&lt;RowFilter.Expression&gt; expressionList, QueryController controller)
        {
<span class="nc" id="L323">            expressionMap = buildIndexExpressions(controller, BooleanOperator.AND, expressionList);</span>
<span class="nc" id="L324">        }</span>

        @Override
        FilterTree filterTree()
        {
<span class="nc" id="L329">            return new FilterTree(BooleanOperator.AND, expressionMap);</span>
        }

        public ExpressionNode(RowFilter.Expression expression)
<span class="nc" id="L333">        {</span>
<span class="nc" id="L334">            this.expression = expression;</span>
<span class="nc" id="L335">        }</span>

        @Override
        public RowFilter.Expression expression()
        {
<span class="nc" id="L340">            return expression;</span>
        }

        @Override
        KeyRangeIterator rangeIterator(QueryController controller)
        {
<span class="nc bnc" id="L346" title="All 2 branches missed.">            assert canFilter() : &quot;Cannot process query with no expressions&quot;;</span>

<span class="nc" id="L348">            return controller.getIndexQueryResults(expressionMap.values()).build();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>