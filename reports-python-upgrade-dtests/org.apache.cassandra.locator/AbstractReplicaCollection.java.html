<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractReplicaCollection.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.locator</a> &gt; <span class="el_source">AbstractReplicaCollection.java</span></div><h1>AbstractReplicaCollection.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.locator;

import com.carrotsearch.hppc.ObjectIntHashMap;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.Iterables;

import java.util.AbstractList;
import java.util.AbstractMap;
import java.util.AbstractSet;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.RandomAccess;
import java.util.Set;
import java.util.Spliterator;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collector;
import java.util.stream.Stream;

/**
 * A collection like class for Replica objects. Since the Replica class contains inetaddress, range, and
 * transient replication status, basic contains and remove methods can be ambiguous. Replicas forces you
 * to be explicit about what you're checking the container for, or removing from it.
 *
 * TODO: there's nothing about this collection that's unique to Replicas, and the implementation
 *       could make a useful general purpose immutable list&lt;-&gt;set
 */
public abstract class AbstractReplicaCollection&lt;C extends AbstractReplicaCollection&lt;C&gt;&gt; implements ReplicaCollection&lt;C&gt;
{
<span class="fc" id="L57">    protected static final ReplicaList EMPTY_LIST = new ReplicaList(); // since immutable, can safely return this to avoid megamorphic callsites</span>

    public static &lt;C extends ReplicaCollection&lt;C&gt;, B extends Builder&lt;C&gt;&gt; Collector&lt;Replica, B, C&gt; collector(Set&lt;Collector.Characteristics&gt; characteristics, Supplier&lt;B&gt; supplier)
    {
<span class="fc" id="L61">        return new Collector&lt;Replica, B, C&gt;()</span>
<span class="fc" id="L62">        {</span>
<span class="fc" id="L63">            private final BiConsumer&lt;B, Replica&gt; accumulator = Builder::add;</span>
<span class="pc" id="L64">            private final BinaryOperator&lt;B&gt; combiner = (a, b) -&gt; { a.addAll(b); return a; };</span>
<span class="fc" id="L65">            private final Function&lt;B, C&gt; finisher = Builder::build;</span>
<span class="fc" id="L66">            public Supplier&lt;B&gt; supplier() { return supplier; }</span>
<span class="fc" id="L67">            public BiConsumer&lt;B, Replica&gt; accumulator() { return accumulator; }</span>
<span class="fc" id="L68">            public BinaryOperator&lt;B&gt; combiner() { return combiner; }</span>
<span class="fc" id="L69">            public Function&lt;B, C&gt; finisher() { return finisher; }</span>
<span class="fc" id="L70">            public Set&lt;Characteristics&gt; characteristics() { return characteristics; }</span>
        };
    }

    /**
     * A simple list with no comodification checks and immutability by default (only append permitted, and only one initial copy)
     * this permits us to reduce the amount of garbage generated, by not wrapping iterators or unnecessarily copying
     * and reduces the amount of indirection necessary, as well as ensuring monomorphic callsites
     *
     * TODO flatten into AbstractReplicaCollection?
     */
    protected final static class ReplicaList implements Iterable&lt;Replica&gt;
    {
<span class="fc" id="L83">        private static final Replica[] EMPTY = new Replica[0];</span>
        Replica[] contents;
        int begin, size;

<span class="fc" id="L87">        public ReplicaList() { this(0); }</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">        public ReplicaList(int capacity) { contents = capacity == 0 ? EMPTY : new Replica[capacity]; }</span>
<span class="fc" id="L89">        public ReplicaList(Replica[] contents, int begin, int size) { this.contents = contents; this.begin = begin; this.size = size; }</span>

        public boolean isSubList(ReplicaList subList)
        {
<span class="fc bfc" id="L93" title="All 2 branches covered.">            return subList.contents == contents;</span>
        }

        public Replica get(int index)
        {
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">            if (index &gt; size)</span>
<span class="nc" id="L99">                throw new IndexOutOfBoundsException();</span>
<span class="fc" id="L100">            return contents[begin + index];</span>
        }

        public void add(Replica replica)
        {
            // can only add to full array - if we have sliced it, we must be a snapshot
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">            if (begin != 0)</span>
<span class="nc" id="L107">                throw new IllegalStateException();</span>

<span class="fc bfc" id="L109" title="All 2 branches covered.">            if (size == contents.length)</span>
            {
                int newSize;
<span class="fc bfc" id="L112" title="All 2 branches covered.">                if (size &lt; 3) newSize = 3;</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">                else if (size &lt; 9) newSize = 9;</span>
<span class="fc" id="L114">                else newSize = size * 2;</span>
<span class="fc" id="L115">                contents = Arrays.copyOf(contents, newSize);</span>
            }
<span class="fc" id="L117">            contents[size++] = replica;</span>
<span class="fc" id="L118">        }</span>

        public int size()
        {
<span class="fc" id="L122">            return size;</span>
        }

        public boolean isEmpty()
        {
<span class="fc bfc" id="L127" title="All 2 branches covered.">            return size == 0;</span>
        }

        public ReplicaList subList(int begin, int end)
        {
<span class="pc bpc" id="L132" title="2 of 4 branches missed.">            if (end &gt; size || begin &gt; end) throw new IndexOutOfBoundsException();</span>
<span class="fc" id="L133">            return new ReplicaList(contents, this.begin + begin, end - begin);</span>
        }

        public ReplicaList sorted(Comparator&lt;? super Replica&gt; comparator)
        {
<span class="fc" id="L138">            Replica[] copy = Arrays.copyOfRange(contents, begin, begin + size);</span>
<span class="fc" id="L139">            Arrays.sort(copy, comparator);</span>
<span class="fc" id="L140">            return new ReplicaList(copy, 0, copy.length);</span>
        }

        public Stream&lt;Replica&gt; stream()
        {
<span class="fc" id="L145">            return Arrays.stream(contents, begin, begin + size);</span>
        }

        @Override
        public void forEach(Consumer&lt;? super Replica&gt; forEach)
        {
<span class="nc bnc" id="L151" title="All 2 branches missed.">            for (int i = begin, end = begin + size ; i &lt; end ; ++i)</span>
<span class="nc" id="L152">                forEach.accept(contents[i]);</span>
<span class="nc" id="L153">        }</span>

        /** see {@link ReplicaCollection#count(Predicate)}*/
        public int count(Predicate&lt;? super Replica&gt; test)
        {
<span class="fc" id="L158">            int count = 0;</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">            for (int i = begin, end = i + size ; i &lt; end ; ++i)</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">                if (test.test(contents[i]))</span>
<span class="nc" id="L161">                    ++count;</span>
<span class="fc" id="L162">            return count;</span>
        }

        public final boolean anyMatch(Predicate&lt;? super Replica&gt; predicate)
        {
<span class="nc bnc" id="L167" title="All 2 branches missed.">            for (int i = begin, end = i + size ; i &lt; end ; ++i)</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">                if (predicate.test(contents[i]))</span>
<span class="nc" id="L169">                    return true;</span>
<span class="nc" id="L170">            return false;</span>
        }

        @Override
        public Spliterator&lt;Replica&gt; spliterator()
        {
<span class="nc" id="L176">            return Arrays.spliterator(contents, begin, begin + size);</span>
        }

        // we implement our own iterator, because it is trivial to do so, and in monomorphic call sites
        // will compile down to almost optimal indexed for loop
        @Override
        public Iterator&lt;Replica&gt; iterator()
        {
<span class="fc" id="L184">            return new Iterator&lt;Replica&gt;()</span>
<span class="fc" id="L185">            {</span>
<span class="fc" id="L186">                final int end = begin + size;</span>
<span class="fc" id="L187">                int i = begin;</span>
                @Override
                public boolean hasNext()
                {
<span class="fc bfc" id="L191" title="All 2 branches covered.">                    return i &lt; end;</span>
                }

                @Override
                public Replica next()
                {
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">                    if (!hasNext()) throw new IllegalStateException();</span>
<span class="fc" id="L198">                    return contents[i++];</span>
                }
            };
        }

        // we implement our own iterator, because it is trivial to do so, and in monomorphic call sites
        // will compile down to almost optimal indexed for loop
        public &lt;K&gt; Iterator&lt;K&gt; transformIterator(Function&lt;? super Replica, ? extends K&gt; function)
        {
<span class="fc" id="L207">            return new Iterator&lt;K&gt;()</span>
<span class="fc" id="L208">            {</span>
<span class="fc" id="L209">                final int end = begin + size;</span>
<span class="fc" id="L210">                int i = begin;</span>
                @Override
                public boolean hasNext()
                {
<span class="fc bfc" id="L214" title="All 2 branches covered.">                    return i &lt; end;</span>
                }

                @Override
                public K next()
                {
<span class="fc" id="L220">                    return function.apply(contents[i++]);</span>
                }
            };
        }

        // we implement our own iterator, because it is trivial to do so, and in monomorphic call sites
        // will compile down to almost optimal indexed for loop
        // in this case, especially, it is impactful versus Iterables.limit(Iterables.filter())
        private Iterator&lt;Replica&gt; filterIterator(Predicate&lt;? super Replica&gt; predicate, int limit)
        {
<span class="fc" id="L230">            return new Iterator&lt;Replica&gt;()</span>
<span class="fc" id="L231">            {</span>
<span class="fc" id="L232">                final int end = begin + size;</span>
<span class="fc" id="L233">                int next = begin;</span>
<span class="fc" id="L234">                int count = 0;</span>
<span class="fc" id="L235">                { updateNext(); }</span>
                void updateNext()
                {
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">                    if (count == limit) next = end;</span>
<span class="fc bfc" id="L239" title="All 4 branches covered.">                    while (next &lt; end &amp;&amp; !predicate.test(contents[next]))</span>
<span class="fc" id="L240">                        ++next;</span>
<span class="fc" id="L241">                    ++count;</span>
<span class="fc" id="L242">                }</span>
                @Override
                public boolean hasNext()
                {
<span class="fc bfc" id="L246" title="All 2 branches covered.">                    return next &lt; end;</span>
                }

                @Override
                public Replica next()
                {
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">                    if (!hasNext()) throw new IllegalStateException();</span>
<span class="fc" id="L253">                    Replica result = contents[next++];</span>
<span class="fc" id="L254">                    updateNext();</span>
<span class="fc" id="L255">                    return result;</span>
                }
            };
        }

        protected &lt;T&gt; void forEach(Function&lt;? super Replica, T&gt; function, Consumer&lt;? super T&gt; action)
        {
<span class="nc bnc" id="L262" title="All 2 branches missed.">            for (int i = begin, end = begin + size ; i &lt; end ; ++i)</span>
<span class="nc" id="L263">                action.accept(function.apply(contents[i]));</span>
<span class="nc" id="L264">        }</span>

        @VisibleForTesting
        public boolean equals(Object to)
        {
<span class="nc bnc" id="L269" title="All 4 branches missed.">            if (to == null || to.getClass() != ReplicaList.class)</span>
<span class="nc" id="L270">                return false;</span>
<span class="nc" id="L271">            ReplicaList that = (ReplicaList) to;</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">            if (this.size != that.size) return false;</span>
<span class="nc" id="L273">            return Iterables.elementsEqual(this, that);</span>
        }
    }

    /**
     * A simple map that ensures the underlying list's iteration order is maintained, and can be shared with
     * subLists (either produced via subList, or via filter that naturally produced a subList).
     * This permits us to reduce the amount of garbage generated, by not unnecessarily copying,
     * reduces the amount of indirection necessary, as well as ensuring monomorphic callsites.
     * The underlying map is also more efficient, particularly for such small collections as we typically produce.
     */
<span class="fc" id="L284">    protected static class ReplicaMap&lt;K&gt; extends AbstractMap&lt;K, Replica&gt;</span>
    {
        private final Function&lt;Replica, K&gt; toKey;
        private final ReplicaList list;
        // we maintain a map of key -&gt; index in our list; this lets us share with subLists (or between Builder and snapshots)
        // since we only need to corroborate that the list index we find is within the bounds of our list
        // (if not, it's a shared map, and the key only occurs in one of our ancestors)
        private final ObjectIntHashMap&lt;K&gt; map;
        private Set&lt;K&gt; keySet;
        private Set&lt;Entry&lt;K, Replica&gt;&gt; entrySet;

<span class="fc" id="L295">        abstract class AbstractImmutableSet&lt;T&gt; extends AbstractSet&lt;T&gt;</span>
        {
            @Override
<span class="nc" id="L298">            public boolean removeAll(Collection&lt;?&gt; c) { throw new UnsupportedOperationException(); }</span>
            @Override
<span class="nc" id="L300">            public boolean remove(Object o) { throw new UnsupportedOperationException(); }</span>
            @Override
<span class="fc" id="L302">            public int size() { return list.size(); }</span>
        }

<span class="fc" id="L305">        class KeySet extends AbstractImmutableSet&lt;K&gt;</span>
        {
            @Override
<span class="fc" id="L308">            public boolean contains(Object o) { return containsKey(o); }</span>
            @Override
<span class="fc" id="L310">            public Iterator&lt;K&gt; iterator() { return list.transformIterator(toKey); }</span>

            @Override
            public void forEach(Consumer&lt;? super K&gt; action)
            {
<span class="nc" id="L315">                list.forEach(toKey, action);</span>
<span class="nc" id="L316">            }</span>
        }

<span class="nc" id="L319">        class EntrySet extends AbstractImmutableSet&lt;Entry&lt;K, Replica&gt;&gt;</span>
        {
            @Override
            public boolean contains(Object o)
            {
<span class="nc" id="L324">                Preconditions.checkNotNull(o);</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">                if (!(o instanceof Entry&lt;?, ?&gt;)) return false;</span>
<span class="nc" id="L326">                return Objects.equals(get(((Entry) o).getKey()), ((Entry) o).getValue());</span>
            }

            @Override
            public Iterator&lt;Entry&lt;K, Replica&gt;&gt; iterator()
            {
<span class="nc" id="L332">                return list.transformIterator(r -&gt; new SimpleImmutableEntry&lt;&gt;(toKey.apply(r), r));</span>
            }
        }

        public ReplicaMap(ReplicaList list, Function&lt;Replica, K&gt; toKey)
<span class="fc" id="L337">        {</span>
            // 8*0.65 =&gt; RF=5; 16*0.65 ==&gt; RF=10
            // use list capacity if empty, otherwise use actual list size
<span class="fc" id="L340">            this.toKey = toKey;</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">            this.map = new ObjectIntHashMap&lt;&gt;(list.size == 0 ? list.contents.length : list.size, 0.65f);</span>
<span class="fc" id="L342">            this.list = list;</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">            for (int i = list.begin ; i &lt; list.begin + list.size ; ++i)</span>
            {
<span class="fc" id="L345">                boolean inserted = internalPutIfAbsent(list.contents[i], i);</span>
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">                assert inserted;</span>
            }
<span class="fc" id="L348">        }</span>

        public ReplicaMap(ReplicaList list, Function&lt;Replica, K&gt; toKey, ObjectIntHashMap&lt;K&gt; map)
<span class="fc" id="L351">        {</span>
<span class="fc" id="L352">            this.toKey = toKey;</span>
<span class="fc" id="L353">            this.list = list;</span>
<span class="fc" id="L354">            this.map = map;</span>
<span class="fc" id="L355">        }</span>

        // to be used only by subclasses of AbstractReplicaCollection
        boolean internalPutIfAbsent(Replica replica, int index)
        {
<span class="fc" id="L360">            K key = toKey.apply(replica);</span>
<span class="fc" id="L361">            int otherIndex = map.put(key, index + 1);</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">            if (otherIndex == 0)</span>
<span class="fc" id="L363">                return true;</span>
<span class="fc" id="L364">            map.put(key, otherIndex);</span>
<span class="fc" id="L365">            return false;</span>
        }

        @Override
        public boolean containsKey(Object key)
        {
<span class="fc" id="L371">            Preconditions.checkNotNull(key);</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">            return get(key) != null;</span>
        }

        public Replica get(Object key)
        {
<span class="fc" id="L377">            Preconditions.checkNotNull(key);</span>
<span class="fc" id="L378">            int index = map.get((K)key) - 1;</span>
            // since this map can be shared between sublists (or snapshots of mutables)
            // we have to first corroborate that the index we've found is actually within our list's bounds
<span class="fc bfc" id="L381" title="All 4 branches covered.">            if (index &lt; list.begin || index &gt;= list.begin + list.size)</span>
<span class="fc" id="L382">                return null;</span>
<span class="fc" id="L383">            return list.contents[index];</span>
        }

        @Override
        public Replica remove(Object key)
        {
<span class="nc" id="L389">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public Set&lt;K&gt; keySet()
        {
<span class="fc" id="L395">            Set&lt;K&gt; ks = keySet;</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">            if (ks == null)</span>
<span class="fc" id="L397">                keySet = ks = new KeySet();</span>
<span class="fc" id="L398">            return ks;</span>
        }

        @Override
        public Set&lt;Entry&lt;K, Replica&gt;&gt; entrySet()
        {
<span class="nc" id="L404">            Set&lt;Entry&lt;K, Replica&gt;&gt; es = entrySet;</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">            if (es == null)</span>
<span class="nc" id="L406">                entrySet = es = new EntrySet();</span>
<span class="nc" id="L407">            return es;</span>
        }

        public int size()
        {
<span class="nc" id="L412">            return list.size();</span>
        }

        ReplicaMap&lt;K&gt; forSubList(ReplicaList subList)
        {
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">            assert subList.contents == list.contents;</span>
<span class="fc" id="L418">            return new ReplicaMap&lt;&gt;(subList, toKey, map);</span>
        }
    }

    static class AsList&lt;T&gt; extends AbstractList&lt;T&gt; implements RandomAccess
    {
        final Function&lt;Replica, T&gt; view;
        final ReplicaList list;

        AsList(Function&lt;Replica, T&gt; view, ReplicaList list)
<span class="fc" id="L428">        {</span>
<span class="fc" id="L429">            this.view = view;</span>
<span class="fc" id="L430">            this.list = list;</span>
<span class="fc" id="L431">        }</span>

        public final T get(int index)
        {
<span class="fc" id="L435">            return view.apply(list.get(index));</span>
        }

        public final int size()
        {
<span class="fc" id="L440">            return list.size;</span>
        }

        @Override
        public final void forEach(Consumer&lt;? super T&gt; forEach)
        {
<span class="nc" id="L446">            list.forEach(view, forEach);</span>
<span class="nc" id="L447">        }</span>
    }


    protected final ReplicaList list;
    AbstractReplicaCollection(ReplicaList list)
<span class="fc" id="L453">    {</span>
<span class="fc" id="L454">        this.list = list;</span>
<span class="fc" id="L455">    }</span>

    /**
     * construct a new Builder of our own type, so that we can concatenate
     * TODO: this isn't terribly pretty, but we need sometimes to select / merge two Endpoints of unknown type;
     */
    public abstract Builder&lt;C&gt; newBuilder(int initialCapacity);

    // return a new &quot;sub-collection&quot; with some sub-selection of the contents of this collection
    abstract C snapshot(ReplicaList newList);
    // return this object, if it is an immutable snapshot, otherwise returns a copy with these properties
    public abstract C snapshot();

    /** see {@link ReplicaCollection#subList(int, int)}*/
    public final C subList(int start, int end)
    {
<span class="fc bfc" id="L471" title="All 4 branches covered.">        if (start == 0 &amp;&amp; end == size())</span>
<span class="fc" id="L472">            return snapshot();</span>

        ReplicaList subList;
<span class="fc bfc" id="L475" title="All 2 branches covered.">        if (start == end) subList = EMPTY_LIST;</span>
<span class="fc" id="L476">        else subList = list.subList(start, end);</span>

<span class="fc" id="L478">        return snapshot(subList);</span>
    }

    public final &lt;T&gt; List&lt;T&gt; asList(Function&lt;Replica, T&gt; view)
    {
<span class="fc" id="L483">        return new AsList&lt;&gt;(view, list);</span>
    }

    /** see {@link ReplicaCollection#count(Predicate)}*/
    public final int count(Predicate&lt;? super Replica&gt; test)
    {
<span class="fc" id="L489">        return list.count(test);</span>
    }

    public final boolean anyMatch(Predicate&lt;? super Replica&gt; test)
    {
<span class="nc" id="L494">        return list.anyMatch(test);</span>
    }

    /** see {@link ReplicaCollection#filter(Predicate)}*/
    public final C filter(Predicate&lt;? super Replica&gt; predicate)
    {
<span class="fc" id="L500">        return filter(predicate, Integer.MAX_VALUE);</span>
    }

    /** see {@link ReplicaCollection#filter(Predicate, int)}*/
    public final C filter(Predicate&lt;? super Replica&gt; predicate, int limit)
    {
<span class="fc bfc" id="L506" title="All 2 branches covered.">        if (isEmpty())</span>
<span class="fc" id="L507">            return snapshot();</span>

<span class="fc" id="L509">        ReplicaList copy = null;</span>
<span class="fc" id="L510">        int beginRun = -1, endRun = -1;</span>
<span class="fc" id="L511">        int i = 0;</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">        for (; i &lt; list.size() ; ++i)</span>
        {
<span class="fc" id="L514">            Replica replica = list.get(i);</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">            if (predicate.test(replica))</span>
            {
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">                if (copy != null)</span>
<span class="nc" id="L518">                    copy.add(replica);</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">                else if (beginRun &lt; 0)</span>
<span class="fc" id="L520">                    beginRun = i;</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">                else if (endRun &gt; 0)</span>
                {
<span class="fc" id="L523">                    copy = new ReplicaList(Math.min(limit, (list.size() - i) + (endRun - beginRun)));</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">                    for (int j = beginRun ; j &lt; endRun ; ++j)</span>
<span class="fc" id="L525">                        copy.add(list.get(j));</span>
<span class="fc" id="L526">                    copy.add(list.get(i));</span>
                }
<span class="fc bfc" id="L528" title="All 2 branches covered.">                if (--limit == 0)</span>
                {
<span class="fc" id="L530">                    ++i;</span>
<span class="fc" id="L531">                    break;</span>
                }
            }
<span class="fc bfc" id="L534" title="All 4 branches covered.">            else if (beginRun &gt;= 0 &amp;&amp; endRun &lt; 0)</span>
<span class="fc" id="L535">                endRun = i;</span>
        }

<span class="fc bfc" id="L538" title="All 2 branches covered.">        if (beginRun &lt; 0)</span>
<span class="fc" id="L539">            beginRun = endRun = 0;</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">        if (endRun &lt; 0)</span>
<span class="fc" id="L541">            endRun = i;</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">        if (copy == null)</span>
<span class="fc" id="L543">            return subList(beginRun, endRun);</span>
<span class="fc" id="L544">        return snapshot(copy);</span>
    }

    /** see {@link ReplicaCollection#filterLazily(Predicate)}*/
    public final Iterable&lt;Replica&gt; filterLazily(Predicate&lt;? super Replica&gt; predicate)
    {
<span class="fc" id="L550">        return filterLazily(predicate, Integer.MAX_VALUE);</span>
    }

    /** see {@link ReplicaCollection#filterLazily(Predicate,int)}*/
    public final Iterable&lt;Replica&gt; filterLazily(Predicate&lt;? super Replica&gt; predicate, int limit)
    {
<span class="fc" id="L556">        return () -&gt; list.filterIterator(predicate, limit);</span>
    }

    /** see {@link ReplicaCollection#sorted(Comparator)}*/
    public final C sorted(Comparator&lt;? super Replica&gt; comparator)
    {
<span class="fc" id="L562">        return snapshot(list.sorted(comparator));</span>
    }

    public final Replica get(int i)
    {
<span class="fc" id="L567">        return list.get(i);</span>
    }

    public final int size()
    {
<span class="fc" id="L572">        return list.size();</span>
    }

    public final boolean isEmpty()
    {
<span class="fc" id="L577">        return list.isEmpty();</span>
    }

    public final Iterator&lt;Replica&gt; iterator()
    {
<span class="fc" id="L582">        return list.iterator();</span>
    }

    public final void forEach(Consumer&lt;? super Replica&gt; forEach)
    {
<span class="nc" id="L587">        list.forEach(forEach);</span>
<span class="nc" id="L588">    }</span>

<span class="fc" id="L590">    public final Stream&lt;Replica&gt; stream() { return list.stream(); }</span>

    /**
     *  &lt;p&gt;
     *  It's not clear whether {@link AbstractReplicaCollection} should implement the order sensitive {@link Object#equals(Object) equals}
     *  of {@link java.util.List} or the order oblivious {@link Object#equals(Object) equals} of {@link java.util.Set}. We never rely on equality
     *  in the database so rather then leave in a potentially surprising implementation we have it throw {@link UnsupportedOperationException}.
     *  &lt;/p&gt;
     *  &lt;p&gt;
     *  Don't implement this and pick one behavior over the other. If you want equality you can static import {@link com.google.common.collect.Iterables#elementsEqual(Iterable, Iterable)}
     *  and use that to get order sensitive equals.
     *  &lt;/p&gt;
     */
    public final boolean equals(Object o)
    {
<span class="nc" id="L605">        throw new UnsupportedOperationException(&quot;AbstractReplicaCollection equals unsupported&quot;);</span>
    }

    /**
     *  &lt;p&gt;
     *  It's not clear whether {@link AbstractReplicaCollection} should implement the order sensitive {@link Object#hashCode() hashCode}
     *  of {@link java.util.List} or the order oblivious {@link Object#hashCode() equals} of {@link java.util.Set}. We never rely on hashCode
     *  in the database so rather then leave in a potentially surprising implementation we have it throw {@link UnsupportedOperationException}.
     *  &lt;/p&gt;
     *  &lt;p&gt;
     *  Don't implement this and pick one behavior over the other.
     *  &lt;/p&gt;
     */
    public final int hashCode()
    {
<span class="nc" id="L620">        throw new UnsupportedOperationException(&quot;AbstractReplicaCollection hashCode unsupported&quot;);</span>
    }

    @Override
    public final String toString()
    {
<span class="fc" id="L626">        return Iterables.toString(list);</span>
    }

    static &lt;C extends AbstractReplicaCollection&lt;C&gt;&gt; C concat(C replicas, C extraReplicas, Builder.Conflict ignoreConflicts)
    {
<span class="fc bfc" id="L631" title="All 2 branches covered.">        if (extraReplicas.isEmpty())</span>
<span class="fc" id="L632">            return replicas;</span>
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">        if (replicas.isEmpty())</span>
<span class="nc" id="L634">            return extraReplicas;</span>
<span class="fc" id="L635">        Builder&lt;C&gt; builder = replicas.newBuilder(replicas.size() + extraReplicas.size());</span>
<span class="fc" id="L636">        builder.addAll(replicas, Builder.Conflict.NONE);</span>
<span class="fc" id="L637">        builder.addAll(extraReplicas, ignoreConflicts);</span>
<span class="fc" id="L638">        return builder.build();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>