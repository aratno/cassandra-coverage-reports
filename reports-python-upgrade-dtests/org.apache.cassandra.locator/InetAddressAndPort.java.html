<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InetAddressAndPort.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.locator</a> &gt; <span class="el_source">InetAddressAndPort.java</span></div><h1>InetAddressAndPort.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.locator;

import java.io.IOException;
import java.io.Serializable;
import java.net.Inet4Address;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.util.regex.Pattern;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.net.HostAndPort;

import org.apache.cassandra.io.IVersionedSerializer;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.net.MessagingService;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.FastByteOperations;

/**
 * A class to replace the usage of InetAddress to identify hosts in the cluster.
 * Opting for a full replacement class so that in the future if we change the nature
 * of the identifier the refactor will be easier in that we don't have to change the type
 * just the methods.
 *
 * Because an IP might contain multiple C* instances the identification must be done
 * using the IP + port. InetSocketAddress is undesirable for a couple of reasons. It's not comparable,
 * it's toString() method doesn't correctly bracket IPv6, it doesn't handle optional default values,
 * and a couple of other minor behaviors that are slightly less troublesome like handling the
 * need to sometimes return a port and sometimes not.
 *
 */
public final class InetAddressAndPort extends InetSocketAddress implements Comparable&lt;InetAddressAndPort&gt;, Serializable
{
    private static final long serialVersionUID = 0;

    //Store these here to avoid requiring DatabaseDescriptor to be loaded. DatabaseDescriptor will set
    //these when it loads the config. A lot of unit tests won't end up loading DatabaseDescriptor.
    //Tools that might use this class also might not load database descriptor. Those tools are expected
    //to always override the defaults.
<span class="fc" id="L66">    static volatile int defaultPort = 7000;</span>

    public final byte[] addressBytes;

    @VisibleForTesting
    InetAddressAndPort(InetAddress address, byte[] addressBytes, int port)
    {
<span class="fc" id="L73">        super(address, port);</span>
<span class="fc" id="L74">        Preconditions.checkNotNull(address);</span>
<span class="fc" id="L75">        Preconditions.checkNotNull(addressBytes);</span>
<span class="fc" id="L76">        validatePortRange(port);</span>
<span class="fc" id="L77">        this.addressBytes = addressBytes;</span>
<span class="fc" id="L78">    }</span>

    public InetAddressAndPort withPort(int port)
    {
<span class="fc" id="L82">        return new InetAddressAndPort(getAddress(), addressBytes, port);</span>
    }

    private static void validatePortRange(int port)
    {
<span class="pc bpc" id="L87" title="3 of 6 branches missed.">        if (port &lt; 0 | port &gt; 65535)</span>
        {
<span class="nc" id="L89">            throw new IllegalArgumentException(&quot;Port &quot; + port + &quot; is not a valid port number in the range 0-65535&quot;);</span>
        }
<span class="fc" id="L91">    }</span>

    @Override
    public int compareTo(InetAddressAndPort o)
    {
<span class="fc" id="L96">        int retval = FastByteOperations.compareUnsigned(addressBytes, 0, addressBytes.length, o.addressBytes, 0, o.addressBytes.length);</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">        if (retval != 0)</span>
        {
<span class="fc" id="L99">            return retval;</span>
        }

<span class="fc" id="L102">        return Integer.compare(getPort(), o.getPort());</span>
    }

    public String getHostAddressAndPort()
    {
<span class="fc" id="L107">        return getHostAddress(true);</span>
    }

<span class="fc" id="L110">    private static final Pattern JMX_INCOMPATIBLE_CHARS = Pattern.compile(&quot;[\\[\\]:]&quot;);</span>


    /**
     * Return a version of getHostAddressAndPort suitable for use in JMX object names without
     * requiring any escaping.  Replaces each character invalid for JMX names with an underscore.
     *
     * @return String with JMX-safe representation of the IP address and port
     */
    public String getHostAddressAndPortForJMX()
    {
<span class="fc" id="L121">        return JMX_INCOMPATIBLE_CHARS.matcher(getHostAddressAndPort()).replaceAll(&quot;_&quot;);</span>
    }

    public String getHostAddress(boolean withPort)
    {
<span class="fc" id="L126">        return hostAddress(this, withPort);</span>
    }

    public String getHostName(boolean withPort)
    {
<span class="nc bnc" id="L131" title="All 2 branches missed.">        return withPort ? String.format(&quot;%s:%s&quot;, getHostName(), getPort()) : getHostName();</span>
    }

    public static String hostAddressAndPort(InetSocketAddress address)
    {
<span class="fc" id="L136">        return hostAddress(address, true);</span>
    }

    public static String hostAddress(InetSocketAddress address, boolean withPort)
    {
<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (withPort)</span>
        {
<span class="fc" id="L143">            return HostAndPort.fromParts(address.getAddress().getHostAddress(), address.getPort()).toString();</span>
        }
        else
        {
<span class="fc" id="L147">            return address.getAddress().getHostAddress();</span>
        }
    }

    @Override
    public String toString()
    {
<span class="fc" id="L154">        return toString(this);</span>
    }

    public String toString(boolean withPort)
    {
<span class="nc" id="L159">        return toString(this, withPort);</span>
    }

    public static String toString(InetSocketAddress address)
    {
<span class="fc" id="L164">        return toString(address, true);</span>
    }

    public static String toString(InetSocketAddress address, boolean withPort)
    {
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">        if (withPort)</span>
        {
<span class="fc" id="L171">            return toString(address.getAddress(), address.getPort());</span>
        }
        else
        {
<span class="nc" id="L175">            return address.getAddress().toString();</span>
        }
    }

    /** Format an InetAddressAndPort in the same style as InetAddress.toString.
     *  The string returned is of the form: hostname / literal IP address : port
     *  (without the whitespace). Literal IPv6 addresses will be wrapped with [ ]
     *  to make the port number clear.
     *
     *  If the host name is unresolved, no reverse name service lookup
     *  is performed. The hostname part will be represented by an empty string.
     *
     * @param address InetAddress to convert String
     * @param port Port number to convert to String
     * @return String representation of the IP address and port
     */
    public static String toString(InetAddress address, int port)
    {
<span class="fc" id="L193">        String addressToString = address.toString(); // cannot use getHostName as it resolves</span>
<span class="fc" id="L194">        int nameLength = addressToString.lastIndexOf('/'); // use last index to prevent ambiguity if host name contains /</span>
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">        assert nameLength &gt;= 0 : &quot;InetAddress.toString format may have changed, expecting /&quot;;</span>

        // Check if need to wrap address with [ ] for IPv6 addresses
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">        if (addressToString.indexOf(':', nameLength) &gt;= 0)</span>
        {
<span class="nc" id="L200">            StringBuilder sb = new StringBuilder(addressToString.length() + 16);</span>
<span class="nc" id="L201">            sb.append(addressToString, 0, nameLength + 1); // append optional host and / char</span>
<span class="nc" id="L202">            sb.append('[');</span>
<span class="nc" id="L203">            sb.append(addressToString, nameLength + 1, addressToString.length());</span>
<span class="nc" id="L204">            sb.append(&quot;]:&quot;);</span>
<span class="nc" id="L205">            sb.append(port);</span>
<span class="nc" id="L206">            return sb.toString();</span>
        }
        else // can just append :port
        {
<span class="fc" id="L210">            StringBuilder sb = new StringBuilder(addressToString); // will have enough capacity for port</span>
<span class="fc" id="L211">            sb.append(&quot;:&quot;);</span>
<span class="fc" id="L212">            sb.append(port);</span>
<span class="fc" id="L213">            return sb.toString();</span>
        }
    }

    public static InetAddressAndPort getByName(String name) throws UnknownHostException
    {
<span class="fc" id="L219">        return getByNameOverrideDefaults(name, null);</span>
    }


    public static List&lt;InetAddressAndPort&gt; getAllByName(String name) throws UnknownHostException
    {
<span class="nc" id="L225">        return getAllByNameOverrideDefaults(name, null);</span>
    }

    /**
     *
     * @param name Hostname + optional ports string
     * @param port Port to connect on, overridden by values in hostname string, defaults to DatabaseDescriptor default if not specified anywhere.
     */
    public static List&lt;InetAddressAndPort&gt; getAllByNameOverrideDefaults(String name, Integer port) throws UnknownHostException
    {
<span class="nc" id="L235">        HostAndPort hap = HostAndPort.fromString(name);</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">        if (hap.hasPort())</span>
        {
<span class="nc" id="L238">            port = hap.getPort();</span>
        }
<span class="nc" id="L240">        Integer finalPort = port;</span>

<span class="nc" id="L242">        return Stream.of(InetAddress.getAllByName(hap.getHost()))</span>
<span class="nc" id="L243">                     .map((address) -&gt; getByAddressOverrideDefaults(address, finalPort))</span>
<span class="nc" id="L244">                     .collect(Collectors.toList());</span>
    }

    /**
     *
     * @param name Hostname + optional ports string
     * @param port Port to connect on, overridden by values in hostname string, defaults to DatabaseDescriptor default if not specified anywhere.
     */
    public static InetAddressAndPort getByNameOverrideDefaults(String name, Integer port) throws UnknownHostException
    {
<span class="fc" id="L254">        HostAndPort hap = HostAndPort.fromString(name);</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">        if (hap.hasPort())</span>
        {
<span class="fc" id="L257">            port = hap.getPort();</span>
        }
<span class="fc" id="L259">        return getByAddressOverrideDefaults(InetAddress.getByName(hap.getHost()), port);</span>
    }

    public static InetAddressAndPort getByAddress(byte[] address) throws UnknownHostException
    {
<span class="nc" id="L264">        return getByAddressOverrideDefaults(InetAddress.getByAddress(address), address, null);</span>
    }

    public static InetAddressAndPort getByAddress(InetAddress address)
    {
<span class="fc" id="L269">        return getByAddressOverrideDefaults(address, null);</span>
    }

    public static InetAddressAndPort getByAddress(InetSocketAddress address)
    {
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">        if (address instanceof InetAddressAndPort)</span>
<span class="fc" id="L275">            return (InetAddressAndPort) address;</span>
<span class="nc" id="L276">        return new InetAddressAndPort(address.getAddress(), address.getAddress().getAddress(), address.getPort());</span>
    }

    public static InetAddressAndPort getByAddressOverrideDefaults(InetAddress address, Integer port)
    {
<span class="fc bfc" id="L281" title="All 2 branches covered.">        if (port == null)</span>
        {
<span class="fc" id="L283">            port = defaultPort;</span>
        }

<span class="fc" id="L286">        return new InetAddressAndPort(address, address.getAddress(), port);</span>
    }

    public static InetAddressAndPort getByAddressOverrideDefaults(InetAddress address, byte[] addressBytes, Integer port)
    {
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">        if (port == null)</span>
        {
<span class="nc" id="L293">            port = defaultPort;</span>
        }

<span class="fc" id="L296">        return new InetAddressAndPort(address, addressBytes, port);</span>
    }

    public static InetAddressAndPort getLoopbackAddress()
    {
<span class="fc" id="L301">        return InetAddressAndPort.getByAddress(InetAddress.getLoopbackAddress());</span>
    }

    public static InetAddressAndPort getLocalHost()
    {
<span class="nc" id="L306">        return FBUtilities.getLocalAddressAndPort();</span>
    }

    public static void initializeDefaultPort(int port)
    {
<span class="fc" id="L311">        defaultPort = port;</span>
<span class="fc" id="L312">    }</span>

    static int getDefaultPort()
    {
<span class="nc" id="L316">        return defaultPort;</span>
    }

    /**
     * As of version 4.0 the endpoint description includes a port number as an unsigned short
     */
    public static final class Serializer implements IVersionedSerializer&lt;InetAddressAndPort&gt;
    {
        public static final int MAXIMUM_SIZE = 19;

        // We put the static instance here, to avoid complexity with dtests.
        // InetAddressAndPort is one of the only classes we share between instances, which is possible cleanly
        // because it has no type-dependencies in its public API, however Serializer requires DataOutputPlus, which requires...
        // and the chain becomes quite unwieldy
<span class="fc" id="L330">        public static final Serializer inetAddressAndPortSerializer = new Serializer();</span>

        private Serializer() {}

        public void serialize(InetAddressAndPort endpoint, DataOutputPlus out, int version) throws IOException
        {
<span class="fc" id="L336">            serialize(endpoint.addressBytes, endpoint.getPort(), out, version);</span>
<span class="fc" id="L337">        }</span>

        public void serialize(InetSocketAddress endpoint, DataOutputPlus out, int version) throws IOException
        {
<span class="nc bnc" id="L341" title="All 2 branches missed.">            byte[] address = endpoint instanceof InetAddressAndPort ? ((InetAddressAndPort) endpoint).addressBytes : endpoint.getAddress().getAddress();</span>
<span class="nc" id="L342">            serialize(address, endpoint.getPort(), out, version);</span>
<span class="nc" id="L343">        }</span>

        void serialize(byte[] address, int port, DataOutputPlus out, int version) throws IOException
        {
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">            assert version &gt;= MessagingService.VERSION_40;</span>
<span class="fc" id="L348">            out.writeByte(address.length + 2);</span>
<span class="fc" id="L349">            out.write(address);</span>
<span class="fc" id="L350">            out.writeShort(port);</span>
<span class="fc" id="L351">        }</span>

        public InetAddressAndPort deserialize(DataInputPlus in, int version) throws IOException
        {
<span class="fc" id="L355">            int size = in.readByte() &amp; 0xFF;</span>
<span class="pc bpc" id="L356" title="2 of 3 branches missed.">            switch(size)</span>
            {
                //The original pre-4.0 serialiation of just an address
                case 4:
                case 16:
<span class="nc" id="L361">                    throw new AssertionError(&quot;pre-4.0 serialization size &quot; + size);</span>
                //Address and one port
                case 6:
                case 18:
                {
<span class="fc" id="L366">                    byte[] bytes = new byte[size - 2];</span>
<span class="fc" id="L367">                    in.readFully(bytes);</span>

<span class="fc" id="L369">                    int port = in.readShort() &amp; 0xFFFF;</span>
<span class="fc" id="L370">                    return getByAddressOverrideDefaults(InetAddress.getByAddress(bytes), bytes, port);</span>
                }
                default:
<span class="nc" id="L373">                    throw new AssertionError(&quot;Unexpected size &quot; + size);</span>

            }
        }

        /**
         * Extract {@link InetAddressAndPort} from the provided {@link ByteBuffer} without altering its state.
         */
        public InetAddressAndPort extract(ByteBuffer buf, int position) throws IOException
        {
<span class="nc" id="L383">            int size = buf.get(position++) &amp; 0xFF;</span>
<span class="nc bnc" id="L384" title="All 4 branches missed.">            if (size == 6 || size == 18)</span>
            {
<span class="nc" id="L386">                byte[] bytes = new byte[size - 2];</span>
<span class="nc" id="L387">                ByteBufferUtil.copyBytes(buf, position, bytes, 0, size - 2);</span>
<span class="nc" id="L388">                position += (size - 2);</span>
<span class="nc" id="L389">                int port = buf.getShort(position) &amp; 0xFFFF;</span>
<span class="nc" id="L390">                return getByAddressOverrideDefaults(InetAddress.getByAddress(bytes), bytes, port);</span>
            }

<span class="nc" id="L393">            throw new AssertionError(&quot;Unexpected pre-4.0 InetAddressAndPort size &quot; + size);</span>
        }

        public long serializedSize(InetAddressAndPort from, int version)
        {
<span class="fc" id="L398">            return serializedSize((InetSocketAddress) from, version);</span>
        }

        public long serializedSize(InetSocketAddress from, int version)
        {
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">            assert version &gt;= MessagingService.VERSION_40;</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">            if (from.getAddress() instanceof Inet4Address)</span>
<span class="fc" id="L405">                return 1 + 4 + 2;</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">            assert from.getAddress() instanceof Inet6Address;</span>
<span class="nc" id="L407">            return 1 + 16 + 2;</span>
        }
    }

    /** Serializer for handling FWD_FRM message parameters. 
     */
    public static final class FwdFrmSerializer implements IVersionedSerializer&lt;InetAddressAndPort&gt;
    {
<span class="fc" id="L415">        public static final FwdFrmSerializer fwdFrmSerializer = new FwdFrmSerializer();</span>
        private FwdFrmSerializer() { }

        public void serialize(InetAddressAndPort endpoint, DataOutputPlus out, int version) throws IOException
        {
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">            assert version &gt;= MessagingService.VERSION_40;</span>
<span class="fc" id="L421">            byte[] buf = endpoint.addressBytes;</span>
<span class="fc" id="L422">            out.writeByte(buf.length + 2);</span>
<span class="fc" id="L423">            out.write(buf);</span>
<span class="fc" id="L424">            out.writeShort(endpoint.getPort());</span>
<span class="fc" id="L425">        }</span>

        public long serializedSize(InetAddressAndPort from, int version)
        {
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">            assert version &gt;= MessagingService.VERSION_40;</span>
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">            if (from.getAddress() instanceof Inet4Address)</span>
<span class="fc" id="L431">                return 1 + 4 + 2;</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">            assert from.getAddress() instanceof Inet6Address;</span>
<span class="nc" id="L433">            return 1 + 16 + 2;</span>
        }

        @Override
        public InetAddressAndPort deserialize(DataInputPlus in, int version) throws IOException
        {
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">            assert version &gt;= MessagingService.VERSION_40 : &quot;FWD_FRM deserializations should be special-cased pre-4.0&quot;;</span>
<span class="fc" id="L440">            int size = in.readByte() &amp; 0xFF;</span>
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">            switch (size)</span>
            {
                //Address and one port
                case 6:
                case 18:
                {
<span class="fc" id="L447">                    byte[] bytes = new byte[size - 2];</span>
<span class="fc" id="L448">                    in.readFully(bytes);</span>

<span class="fc" id="L450">                    int port = in.readShort() &amp; 0xFFFF;</span>
<span class="fc" id="L451">                    return getByAddressOverrideDefaults(InetAddress.getByAddress(bytes), bytes, port);</span>
                }
                default:
<span class="nc" id="L454">                    throw new AssertionError(&quot;Unexpected size &quot; + size);</span>
            }
        }

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>