<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ErrorMessage.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.transport.messages</a> &gt; <span class="el_source">ErrorMessage.java</span></div><h1>ErrorMessage.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.transport.messages;

import java.net.InetAddress;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import io.netty.buffer.ByteBuf;
import io.netty.handler.codec.CodecException;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Predicate;
import com.google.common.collect.ImmutableMap;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.cql3.functions.FunctionName;
import org.apache.cassandra.db.ConsistencyLevel;
import org.apache.cassandra.db.WriteType;
import org.apache.cassandra.exceptions.*;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.transport.*;
import org.apache.cassandra.utils.MD5Digest;

/**
 * Message to indicate an error to the client.
 */
public class ErrorMessage extends Message.Response
{
<span class="fc" id="L46">    private static final Logger logger = LoggerFactory.getLogger(ErrorMessage.class);</span>

<span class="fc" id="L48">    public static final Message.Codec&lt;ErrorMessage&gt; codec = new Message.Codec&lt;ErrorMessage&gt;()</span>
<span class="fc" id="L49">    {</span>
        public ErrorMessage decode(ByteBuf body, ProtocolVersion version)
        {
<span class="nc" id="L52">            ExceptionCode code = ExceptionCode.fromValue(body.readInt());</span>
<span class="nc" id="L53">            String msg = CBUtil.readString(body);</span>

<span class="nc" id="L55">            TransportException te = null;</span>
<span class="nc bnc" id="L56" title="All 19 branches missed.">            switch (code)</span>
            {
                case SERVER_ERROR:
<span class="nc" id="L59">                    te = new ServerError(msg);</span>
<span class="nc" id="L60">                    break;</span>
                case PROTOCOL_ERROR:
<span class="nc" id="L62">                    te = new ProtocolException(msg);</span>
<span class="nc" id="L63">                    break;</span>
                case BAD_CREDENTIALS:
<span class="nc" id="L65">                    te = new AuthenticationException(msg);</span>
<span class="nc" id="L66">                    break;</span>
                case UNAVAILABLE:
                    {
<span class="nc" id="L69">                        ConsistencyLevel cl = CBUtil.readConsistencyLevel(body);</span>
<span class="nc" id="L70">                        int required = body.readInt();</span>
<span class="nc" id="L71">                        int alive = body.readInt();</span>
<span class="nc" id="L72">                        te = UnavailableException.create(cl, required, alive);</span>
                    }
<span class="nc" id="L74">                    break;</span>
                case OVERLOADED:
<span class="nc" id="L76">                    te = new OverloadedException(msg);</span>
<span class="nc" id="L77">                    break;</span>
                case IS_BOOTSTRAPPING:
<span class="nc" id="L79">                    te = new IsBootstrappingException();</span>
<span class="nc" id="L80">                    break;</span>
                case TRUNCATE_ERROR:
<span class="nc" id="L82">                    te = new TruncateException(msg);</span>
<span class="nc" id="L83">                    break;</span>
                case WRITE_FAILURE:
                case READ_FAILURE:
                    {
<span class="nc" id="L87">                        ConsistencyLevel cl = CBUtil.readConsistencyLevel(body);</span>
<span class="nc" id="L88">                        int received = body.readInt();</span>
<span class="nc" id="L89">                        int blockFor = body.readInt();</span>
                        // The number of failures is also present in protocol v5, but used instead to specify the size of the failure map
<span class="nc" id="L91">                        int failure = body.readInt();</span>

                        Map&lt;InetAddressAndPort, RequestFailureReason&gt; failureReasonByEndpoint;
<span class="nc bnc" id="L94" title="All 2 branches missed.">                        if (version.isGreaterOrEqualTo(ProtocolVersion.V5))</span>
                        {
<span class="nc" id="L96">                            ImmutableMap.Builder&lt;InetAddressAndPort, RequestFailureReason&gt; builder = ImmutableMap.builderWithExpectedSize(failure);</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">                            for (int i = 0; i &lt; failure; i++)</span>
                            {
<span class="nc" id="L99">                                InetAddress endpoint = CBUtil.readInetAddr(body);</span>
<span class="nc" id="L100">                                RequestFailureReason failureReason = RequestFailureReason.fromCode(body.readUnsignedShort());</span>
<span class="nc" id="L101">                                builder.put(InetAddressAndPort.getByAddress(endpoint), failureReason);</span>
                            }
<span class="nc" id="L103">                            failureReasonByEndpoint = builder.build();</span>
<span class="nc" id="L104">                        }</span>
                        else
                        {
<span class="nc" id="L107">                            failureReasonByEndpoint = Collections.emptyMap();</span>
                        }

<span class="nc bnc" id="L110" title="All 2 branches missed.">                        if (code == ExceptionCode.WRITE_FAILURE)</span>
                        {
<span class="nc" id="L112">                            WriteType writeType = Enum.valueOf(WriteType.class, CBUtil.readString(body));</span>
<span class="nc" id="L113">                            te = new WriteFailureException(cl, received, blockFor, writeType, failureReasonByEndpoint);</span>
<span class="nc" id="L114">                        }</span>
                        else
                        {
<span class="nc" id="L117">                            byte dataPresent = body.readByte();</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">                            te = new ReadFailureException(cl, received, blockFor, dataPresent != 0, failureReasonByEndpoint);</span>
                        }
                    }
<span class="nc" id="L121">                    break;</span>
                case WRITE_TIMEOUT:
                case READ_TIMEOUT:
                    {
<span class="nc" id="L125">                        ConsistencyLevel cl = CBUtil.readConsistencyLevel(body);</span>
<span class="nc" id="L126">                        int received = body.readInt();</span>
<span class="nc" id="L127">                        int blockFor = body.readInt();</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">                        if (code == ExceptionCode.WRITE_TIMEOUT)</span>
                        {
<span class="nc" id="L130">                            WriteType writeType = Enum.valueOf(WriteType.class, CBUtil.readString(body));</span>
<span class="nc bnc" id="L131" title="All 4 branches missed.">                            if (version.isGreaterOrEqualTo(ProtocolVersion.V5) &amp;&amp; writeType == WriteType.CAS)</span>
                            {
<span class="nc" id="L133">                                int contentions = body.readShort();</span>
<span class="nc" id="L134">                                te = new CasWriteTimeoutException(writeType, cl, received, blockFor, contentions);</span>
<span class="nc" id="L135">                            }</span>
                            else
                            {
<span class="nc" id="L138">                                te = new WriteTimeoutException(writeType, cl, received, blockFor);</span>
                            }
<span class="nc" id="L140">                        }</span>
                        else
                        {
<span class="nc" id="L143">                            byte dataPresent = body.readByte();</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">                            te = new ReadTimeoutException(cl, received, blockFor, dataPresent != 0);</span>
                        }
<span class="nc" id="L146">                        break;</span>
                    }
                case FUNCTION_FAILURE:
<span class="nc" id="L149">                    String fKeyspace = CBUtil.readString(body);</span>
<span class="nc" id="L150">                    String fName = CBUtil.readString(body);</span>
<span class="nc" id="L151">                    List&lt;String&gt; argTypes = CBUtil.readStringList(body);</span>
<span class="nc" id="L152">                    te = FunctionExecutionException.create(new FunctionName(fKeyspace, fName), argTypes, msg);</span>
<span class="nc" id="L153">                    break;</span>
                case UNPREPARED:
                    {
<span class="nc" id="L156">                        MD5Digest id = MD5Digest.wrap(CBUtil.readBytes(body));</span>
<span class="nc" id="L157">                        te = new PreparedQueryNotFoundException(id);</span>
                    }
<span class="nc" id="L159">                    break;</span>
                case SYNTAX_ERROR:
<span class="nc" id="L161">                    te = new SyntaxException(msg);</span>
<span class="nc" id="L162">                    break;</span>
                case UNAUTHORIZED:
<span class="nc" id="L164">                    te = new UnauthorizedException(msg);</span>
<span class="nc" id="L165">                    break;</span>
                case INVALID:
<span class="nc" id="L167">                    te = new InvalidRequestException(msg);</span>
<span class="nc" id="L168">                    break;</span>
                case CONFIG_ERROR:
<span class="nc" id="L170">                    te = new ConfigurationException(msg);</span>
<span class="nc" id="L171">                    break;</span>
                case CDC_WRITE_FAILURE:
<span class="nc" id="L173">                    te = new CDCWriteException(msg);</span>
<span class="nc" id="L174">                    break;</span>
                case ALREADY_EXISTS:
<span class="nc" id="L176">                    String ksName = CBUtil.readString(body);</span>
<span class="nc" id="L177">                    String cfName = CBUtil.readString(body);</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">                    if (cfName.isEmpty())</span>
<span class="nc" id="L179">                        te = new AlreadyExistsException(ksName);</span>
                    else
<span class="nc" id="L181">                        te = new AlreadyExistsException(ksName, cfName);</span>
<span class="nc" id="L182">                    break;</span>
                case CAS_WRITE_UNKNOWN:
<span class="nc bnc" id="L184" title="All 2 branches missed.">                    assert version.isGreaterOrEqualTo(ProtocolVersion.V5);</span>

<span class="nc" id="L186">                    ConsistencyLevel cl = CBUtil.readConsistencyLevel(body);</span>
<span class="nc" id="L187">                    int received = body.readInt();</span>
<span class="nc" id="L188">                    int blockFor = body.readInt();</span>
<span class="nc" id="L189">                    te = new CasWriteUnknownResultException(cl, received, blockFor);</span>
                    break;
            }
<span class="nc" id="L192">            return new ErrorMessage(te);</span>
        }

        public void encode(ErrorMessage msg, ByteBuf dest, ProtocolVersion version)
        {
<span class="fc" id="L197">            final TransportException err = getBackwardsCompatibleException(msg, version);</span>
<span class="fc" id="L198">            dest.writeInt(err.code().value);</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">            String errorString = err.getMessage() == null ? &quot;&quot; : err.getMessage();</span>
<span class="fc" id="L200">            CBUtil.writeString(errorString, dest);</span>

<span class="pc bpc" id="L202" title="5 of 8 branches missed.">            switch (err.code())</span>
            {
                case UNAVAILABLE:
<span class="nc" id="L205">                    UnavailableException ue = (UnavailableException)err;</span>
<span class="nc" id="L206">                    CBUtil.writeConsistencyLevel(ue.consistency, dest);</span>
<span class="nc" id="L207">                    dest.writeInt(ue.required);</span>
<span class="nc" id="L208">                    dest.writeInt(ue.alive);</span>
<span class="nc" id="L209">                    break;</span>
                case WRITE_FAILURE:
                case READ_FAILURE:
                    {
<span class="fc" id="L213">                        RequestFailureException rfe = (RequestFailureException) err;</span>

<span class="fc" id="L215">                        CBUtil.writeConsistencyLevel(rfe.consistency, dest);</span>
<span class="fc" id="L216">                        dest.writeInt(rfe.received);</span>
<span class="fc" id="L217">                        dest.writeInt(rfe.blockFor);</span>
                        // The number of failures is also present in protocol v5, but used instead to specify the size of the failure map
<span class="fc" id="L219">                        dest.writeInt(rfe.failureReasonByEndpoint.size());</span>

<span class="pc bpc" id="L221" title="1 of 2 branches missed.">                        if (version.isGreaterOrEqualTo(ProtocolVersion.V5))</span>
                        {
<span class="fc bfc" id="L223" title="All 2 branches covered.">                            for (Map.Entry&lt;InetAddressAndPort, RequestFailureReason&gt; entry : rfe.failureReasonByEndpoint.entrySet())</span>
                            {
<span class="fc" id="L225">                                CBUtil.writeInetAddr(entry.getKey().getAddress(), dest);</span>
<span class="fc" id="L226">                                dest.writeShort(entry.getValue().code);</span>
<span class="fc" id="L227">                            }</span>
                        }

<span class="pc bpc" id="L230" title="1 of 2 branches missed.">                        if (err.code() == ExceptionCode.WRITE_FAILURE)</span>
<span class="nc" id="L231">                            CBUtil.writeAsciiString(((WriteFailureException) rfe).writeType.toString(), dest);</span>
                        else
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">                            dest.writeByte((byte) (((ReadFailureException) rfe).dataPresent ? 1 : 0));</span>
<span class="fc" id="L234">                        break;</span>
                    }
                case WRITE_TIMEOUT:
                case READ_TIMEOUT:
<span class="nc" id="L238">                    RequestTimeoutException rte = (RequestTimeoutException)err;</span>

<span class="nc" id="L240">                    CBUtil.writeConsistencyLevel(rte.consistency, dest);</span>
<span class="nc" id="L241">                    dest.writeInt(rte.received);</span>
<span class="nc" id="L242">                    dest.writeInt(rte.blockFor);</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">                    if (err.code() == ExceptionCode.WRITE_TIMEOUT)</span>
                    {
<span class="nc" id="L245">                        CBUtil.writeAsciiString(((WriteTimeoutException)rte).writeType.toString(), dest);</span>
                        // CasWriteTimeoutException already implies protocol V5, but double check to be safe.
<span class="nc bnc" id="L247" title="All 4 branches missed.">                        if (version.isGreaterOrEqualTo(ProtocolVersion.V5) &amp;&amp; rte instanceof CasWriteTimeoutException)</span>
<span class="nc" id="L248">                            dest.writeShort(((CasWriteTimeoutException)rte).contentions);</span>
                    }
                    else
                    {
<span class="nc bnc" id="L252" title="All 2 branches missed.">                        dest.writeByte((byte)(((ReadTimeoutException)rte).dataPresent ? 1 : 0));</span>
                    }
<span class="nc" id="L254">                    break;</span>
                case FUNCTION_FAILURE:
<span class="nc" id="L256">                    FunctionExecutionException fee = (FunctionExecutionException)msg.error;</span>
<span class="nc" id="L257">                    CBUtil.writeAsciiString(fee.functionName.keyspace, dest);</span>
<span class="nc" id="L258">                    CBUtil.writeAsciiString(fee.functionName.name, dest);</span>
<span class="nc" id="L259">                    CBUtil.writeStringList(fee.argTypes, dest);</span>
<span class="nc" id="L260">                    break;</span>
                case UNPREPARED:
<span class="nc" id="L262">                    PreparedQueryNotFoundException pqnfe = (PreparedQueryNotFoundException)err;</span>
<span class="nc" id="L263">                    CBUtil.writeBytes(pqnfe.id.bytes, dest);</span>
<span class="nc" id="L264">                    break;</span>
                case ALREADY_EXISTS:
<span class="fc" id="L266">                    AlreadyExistsException aee = (AlreadyExistsException)err;</span>
<span class="fc" id="L267">                    CBUtil.writeAsciiString(aee.ksName, dest);</span>
<span class="fc" id="L268">                    CBUtil.writeAsciiString(aee.cfName, dest);</span>
<span class="fc" id="L269">                    break;</span>
                case CAS_WRITE_UNKNOWN:
<span class="nc bnc" id="L271" title="All 2 branches missed.">                    assert version.isGreaterOrEqualTo(ProtocolVersion.V5);</span>
<span class="nc" id="L272">                    CasWriteUnknownResultException cwue = (CasWriteUnknownResultException)err;</span>
<span class="nc" id="L273">                    CBUtil.writeConsistencyLevel(cwue.consistency, dest);</span>
<span class="nc" id="L274">                    dest.writeInt(cwue.received);</span>
<span class="nc" id="L275">                    dest.writeInt(cwue.blockFor);</span>
            }
<span class="fc" id="L277">        }</span>

        public int encodedSize(ErrorMessage msg, ProtocolVersion version)
        {
<span class="fc" id="L281">            TransportException err = getBackwardsCompatibleException(msg, version);</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">            String errorString = err.getMessage() == null ? &quot;&quot; : err.getMessage();</span>
<span class="fc" id="L283">            int size = 4 + CBUtil.sizeOfString(errorString);</span>
<span class="pc bpc" id="L284" title="5 of 8 branches missed.">            switch (err.code())</span>
            {
                case UNAVAILABLE:
<span class="nc" id="L287">                    UnavailableException ue = (UnavailableException)err;</span>
<span class="nc" id="L288">                    size += CBUtil.sizeOfConsistencyLevel(ue.consistency) + 8;</span>
<span class="nc" id="L289">                    break;</span>
                case WRITE_FAILURE:
                case READ_FAILURE:
                    {
<span class="fc" id="L293">                        RequestFailureException rfe = (RequestFailureException)err;</span>

<span class="fc" id="L295">                        size += CBUtil.sizeOfConsistencyLevel(rfe.consistency) + 4 + 4 + 4;</span>
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">                        if (err.code() == ExceptionCode.WRITE_FAILURE)</span>
<span class="nc" id="L297">                            size += CBUtil.sizeOfAsciiString(((WriteFailureException)rfe).writeType.toString());</span>
                        else
<span class="fc" id="L299">                            size += 1;</span>

<span class="pc bpc" id="L301" title="1 of 2 branches missed.">                        if (version.isGreaterOrEqualTo(ProtocolVersion.V5))</span>
                        {
<span class="fc bfc" id="L303" title="All 2 branches covered.">                            for (Map.Entry&lt;InetAddressAndPort, RequestFailureReason&gt; entry : rfe.failureReasonByEndpoint.entrySet())</span>
                            {
<span class="fc" id="L305">                                size += CBUtil.sizeOfInetAddr(entry.getKey().getAddress());</span>
<span class="fc" id="L306">                                size += 2; // RequestFailureReason code</span>
<span class="fc" id="L307">                            }</span>
                        }
                    }
<span class="fc" id="L310">                    break;</span>
                case WRITE_TIMEOUT:
                case READ_TIMEOUT:
<span class="nc" id="L313">                    RequestTimeoutException rte = (RequestTimeoutException)err;</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">                    boolean isWrite = err.code() == ExceptionCode.WRITE_TIMEOUT;</span>
<span class="nc" id="L315">                    size += CBUtil.sizeOfConsistencyLevel(rte.consistency) + 8;</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">                    if (isWrite)</span>
<span class="nc" id="L317">                        size += CBUtil.sizeOfAsciiString(((WriteTimeoutException)rte).writeType.toString());</span>
                    else
<span class="nc" id="L319">                        size += 1;</span>

                    // CasWriteTimeoutException already implies protocol V5, but double check to be safe.
<span class="nc bnc" id="L322" title="All 6 branches missed.">                    if (isWrite &amp;&amp; version.isGreaterOrEqualTo(ProtocolVersion.V5) &amp;&amp; rte instanceof CasWriteTimeoutException)</span>
<span class="nc" id="L323">                        size += 2; // CasWriteTimeoutException appends a short for contentions occured.</span>
                    break;
                case FUNCTION_FAILURE:
<span class="nc" id="L326">                    FunctionExecutionException fee = (FunctionExecutionException)msg.error;</span>
<span class="nc" id="L327">                    size += CBUtil.sizeOfAsciiString(fee.functionName.keyspace);</span>
<span class="nc" id="L328">                    size += CBUtil.sizeOfAsciiString(fee.functionName.name);</span>
<span class="nc" id="L329">                    size += CBUtil.sizeOfStringList(fee.argTypes);</span>
<span class="nc" id="L330">                    break;</span>
                case UNPREPARED:
<span class="nc" id="L332">                    PreparedQueryNotFoundException pqnfe = (PreparedQueryNotFoundException)err;</span>
<span class="nc" id="L333">                    size += CBUtil.sizeOfBytes(pqnfe.id.bytes);</span>
<span class="nc" id="L334">                    break;</span>
                case ALREADY_EXISTS:
<span class="fc" id="L336">                    AlreadyExistsException aee = (AlreadyExistsException)err;</span>
<span class="fc" id="L337">                    size += CBUtil.sizeOfAsciiString(aee.ksName);</span>
<span class="fc" id="L338">                    size += CBUtil.sizeOfAsciiString(aee.cfName);</span>
<span class="fc" id="L339">                    break;</span>
                case CAS_WRITE_UNKNOWN:
<span class="nc bnc" id="L341" title="All 2 branches missed.">                    assert version.isGreaterOrEqualTo(ProtocolVersion.V5);</span>
<span class="nc" id="L342">                    CasWriteUnknownResultException cwue = (CasWriteUnknownResultException)err;</span>
<span class="nc" id="L343">                    size += CBUtil.sizeOfConsistencyLevel(cwue.consistency) + 4 + 4; // receivedFor: 4, blockFor: 4</span>
                    break;
            }
<span class="fc" id="L346">            return size;</span>
        }
    };

    private static TransportException getBackwardsCompatibleException(ErrorMessage msg, ProtocolVersion version)
    {
<span class="fc bfc" id="L352" title="All 2 branches covered.">        if (version.isSmallerThan(ProtocolVersion.V4))</span>
        {
<span class="pc bpc" id="L354" title="3 of 4 branches missed.">            switch (msg.error.code())</span>
            {
                case READ_FAILURE:
<span class="nc" id="L357">                    ReadFailureException rfe = (ReadFailureException) msg.error;</span>
<span class="nc" id="L358">                    return new ReadTimeoutException(rfe.consistency, rfe.received, rfe.blockFor, rfe.dataPresent);</span>
                case WRITE_FAILURE:
<span class="nc" id="L360">                    WriteFailureException wfe = (WriteFailureException) msg.error;</span>
<span class="nc" id="L361">                    return new WriteTimeoutException(wfe.writeType, wfe.consistency, wfe.received, wfe.blockFor);</span>
                case FUNCTION_FAILURE:
                case CDC_WRITE_FAILURE:
<span class="nc" id="L364">                    return new InvalidRequestException(msg.toString());</span>
            }
        }

<span class="fc bfc" id="L368" title="All 2 branches covered.">        if (version.isSmallerThan(ProtocolVersion.V5))</span>
        {
<span class="pc bpc" id="L370" title="2 of 3 branches missed.">            switch (msg.error.code())</span>
            {
                case WRITE_TIMEOUT:
<span class="nc bnc" id="L373" title="All 2 branches missed.">                    if (msg.error instanceof CasWriteTimeoutException)</span>
                    {
<span class="nc" id="L375">                        CasWriteTimeoutException cwte = (CasWriteTimeoutException) msg.error;</span>
<span class="nc" id="L376">                        return new WriteTimeoutException(WriteType.CAS, cwte.consistency, cwte.received, cwte.blockFor);</span>
                    }
                    break;
                case CAS_WRITE_UNKNOWN:
<span class="nc" id="L380">                    CasWriteUnknownResultException cwue = (CasWriteUnknownResultException) msg.error;</span>
<span class="nc" id="L381">                    return new WriteTimeoutException(WriteType.CAS, cwue.consistency, cwue.received, cwue.blockFor);</span>
            }
        }

<span class="fc" id="L385">        return msg.error;</span>
    }

    // We need to figure error codes out (#3979)
    public final TransportException error;

    private ErrorMessage(TransportException error)
    {
<span class="fc" id="L393">        super(Message.Type.ERROR);</span>
<span class="fc" id="L394">        this.error = error;</span>
<span class="fc" id="L395">    }</span>

    private ErrorMessage(TransportException error, int streamId)
    {
<span class="fc" id="L399">        this(error);</span>
<span class="fc" id="L400">        setStreamId(streamId);</span>
<span class="fc" id="L401">    }</span>

    public static ErrorMessage fromException(Throwable e)
    {
<span class="fc" id="L405">        return fromException(e, null);</span>
    }

    /**
     * @param e the exception
     * @param unexpectedExceptionHandler a callback for handling unexpected exceptions. If null, or if this
     *                                   returns false, the error is logged at ERROR level via sl4fj
     */
    public static ErrorMessage fromException(Throwable e, Predicate&lt;Throwable&gt; unexpectedExceptionHandler)
    {
<span class="fc" id="L415">        int streamId = 0;</span>

        // Netty will wrap exceptions during decoding in a CodecException. If the cause was one of our ProtocolExceptions
        // or some other internal exception, extract that and use it.
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">        if (e instanceof CodecException)</span>
        {
<span class="nc" id="L421">            Throwable cause = e.getCause();</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">            if (cause != null)</span>
            {
<span class="nc bnc" id="L424" title="All 2 branches missed.">                if (cause instanceof WrappedException)</span>
                {
<span class="nc" id="L426">                    streamId = ((WrappedException) cause).streamId;</span>
<span class="nc" id="L427">                    e = cause.getCause();</span>
                }
<span class="nc bnc" id="L429" title="All 2 branches missed.">                else if (cause instanceof TransportException)</span>
                {
<span class="nc" id="L431">                    e = cause;</span>
                }
            }
<span class="nc" id="L434">        }</span>
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">        else if (e instanceof WrappedException)</span>
        {
<span class="nc" id="L437">            streamId = ((WrappedException)e).streamId;</span>
<span class="nc" id="L438">            e = e.getCause();</span>
        }

<span class="fc bfc" id="L441" title="All 2 branches covered.">        if (e instanceof TransportException)</span>
        {
<span class="fc" id="L443">            ErrorMessage message = new ErrorMessage((TransportException) e, streamId);</span>
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">            if (e instanceof ProtocolException)</span>
            {
                // if the driver attempted to connect with a protocol version not supported then
                // respond with the appropiate version, see ProtocolVersion.decode()
<span class="nc" id="L448">                ProtocolVersion forcedProtocolVersion = ((ProtocolException) e).getForcedProtocolVersion();</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">                if (forcedProtocolVersion != null)</span>
<span class="nc" id="L450">                    message.forcedProtocolVersion = forcedProtocolVersion;</span>
            }
<span class="fc" id="L452">            return message;</span>
        }

        // Unexpected exception
<span class="pc bpc" id="L456" title="2 of 4 branches missed.">        if (unexpectedExceptionHandler == null || !unexpectedExceptionHandler.apply(e))</span>
<span class="nc" id="L457">            logger.error(&quot;Unexpected exception during request&quot;, e);</span>

<span class="fc" id="L459">        return new ErrorMessage(new ServerError(e), streamId);</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L465">        return &quot;ERROR &quot; + error.code() + &quot;: &quot; + error.getMessage();</span>
    }

    public static RuntimeException wrap(Throwable t, int streamId)
    {
<span class="nc" id="L470">        return new WrappedException(t, streamId);</span>
    }

    public static class WrappedException extends RuntimeException
    {
        private final int streamId;

        public WrappedException(Throwable cause, int streamId)
        {
<span class="nc" id="L479">            super(cause);</span>
<span class="nc" id="L480">            this.streamId = streamId;</span>
<span class="nc" id="L481">        }</span>

        @VisibleForTesting
        public int getStreamId()
        {
<span class="nc" id="L486">            return this.streamId;</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>