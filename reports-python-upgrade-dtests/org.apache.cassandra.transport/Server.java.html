<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Server.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.transport</a> &gt; <span class="el_source">Server.java</span></div><h1>Server.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.transport;

import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.UnknownHostException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.epoll.EpollEventLoopGroup;
import io.netty.channel.group.ChannelGroup;
import io.netty.channel.group.ChannelMatcher;
import io.netty.channel.group.DefaultChannelGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.util.concurrent.GlobalEventExecutor;
import io.netty.util.internal.logging.InternalLoggerFactory;
import io.netty.util.internal.logging.Slf4JLoggerFactory;
import org.apache.cassandra.auth.AuthenticatedUser;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.config.EncryptionOptions;
import org.apache.cassandra.cql3.functions.UDAggregate;
import org.apache.cassandra.cql3.functions.UDFunction;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.marshal.UserType;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.schema.KeyspaceMetadata;
import org.apache.cassandra.schema.Schema;
import org.apache.cassandra.schema.SchemaChangeListener;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.service.*;
import org.apache.cassandra.transport.messages.EventMessage;
import org.apache.cassandra.utils.FBUtilities;

public class Server implements CassandraDaemon.Server
{
    static
    {
<span class="fc" id="L61">        InternalLoggerFactory.setDefaultFactory(new Slf4JLoggerFactory());</span>
    }

<span class="fc" id="L64">    private static final Logger logger = LoggerFactory.getLogger(Server.class);</span>
<span class="fc" id="L65">    private static final boolean useEpoll = NativeTransportService.useEpoll();</span>

<span class="fc" id="L67">    private final ConnectionTracker connectionTracker = new ConnectionTracker();</span>

<span class="fc" id="L69">    private final Connection.Factory connectionFactory = new Connection.Factory()</span>
<span class="fc" id="L70">    {</span>
        public Connection newConnection(Channel channel, ProtocolVersion version)
        {
<span class="fc" id="L73">            return new ServerConnection(channel, version, connectionTracker);</span>
        }
    };

    public final InetSocketAddress socket;
    public final EncryptionOptions.TlsEncryptionPolicy tlsEncryptionPolicy;
<span class="fc" id="L79">    private final AtomicBoolean isRunning = new AtomicBoolean(false);</span>
    private final PipelineConfigurator pipelineConfigurator;
    private final EventLoopGroup workerGroup;

    private Server (Builder builder)
<span class="fc" id="L84">    {</span>
<span class="fc" id="L85">        this.socket = builder.getSocket();</span>
<span class="fc" id="L86">        this.tlsEncryptionPolicy = builder.tlsEncryptionPolicy;</span>
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">        if (builder.workerGroup != null)</span>
        {
<span class="fc" id="L89">            workerGroup = builder.workerGroup;</span>
        }
        else
        {
<span class="nc bnc" id="L93" title="All 2 branches missed.">            if (useEpoll)</span>
<span class="nc" id="L94">                workerGroup = new EpollEventLoopGroup();</span>
            else
<span class="nc" id="L96">                workerGroup = new NioEventLoopGroup();</span>
        }

<span class="pc bpc" id="L99" title="1 of 2 branches missed.">        pipelineConfigurator = builder.pipelineConfigurator != null</span>
<span class="nc" id="L100">                               ? builder.pipelineConfigurator</span>
<span class="fc" id="L101">                               : new PipelineConfigurator(useEpoll,</span>
<span class="fc" id="L102">                                                          DatabaseDescriptor.getRpcKeepAlive(),</span>
<span class="fc" id="L103">                                                          DatabaseDescriptor.useNativeTransportLegacyFlusher(),</span>
                                                          builder.tlsEncryptionPolicy);

<span class="pc bpc" id="L106" title="1 of 2 branches missed.">        EventNotifier notifier = builder.eventNotifier != null ? builder.eventNotifier : new EventNotifier();</span>
<span class="fc" id="L107">        notifier.registerConnectionTracker(connectionTracker);</span>
<span class="fc" id="L108">        StorageService.instance.register(notifier);</span>
<span class="fc" id="L109">        Schema.instance.registerListener(notifier);</span>
<span class="fc" id="L110">    }</span>

    public void stop()
    {
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        if (isRunning.compareAndSet(true, false))</span>
<span class="fc" id="L115">            close();</span>
<span class="fc" id="L116">    }</span>

    public boolean isRunning()
    {
<span class="fc" id="L120">        return isRunning.get();</span>
    }

    public synchronized void start()
    {
<span class="fc bfc" id="L125" title="All 2 branches covered.">        if(isRunning())</span>
<span class="fc" id="L126">            return;</span>

        // Configure the server.
<span class="fc" id="L129">        ChannelFuture bindFuture = pipelineConfigurator.initializeChannel(workerGroup, socket, connectionFactory);</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">        if (!bindFuture.awaitUninterruptibly().isSuccess())</span>
<span class="nc" id="L131">            throw new IllegalStateException(String.format(&quot;Failed to bind port %d on %s.&quot;, socket.getPort(), socket.getAddress().getHostAddress()),</span>
<span class="nc" id="L132">                                            bindFuture.cause());</span>

<span class="fc" id="L134">        connectionTracker.allChannels.add(bindFuture.channel());</span>
<span class="fc" id="L135">        isRunning.set(true);</span>
<span class="fc" id="L136">    }</span>

    public int countConnectedClients()
    {
<span class="nc" id="L140">        return connectionTracker.countConnectedClients();</span>
    }

    public Map&lt;String, Integer&gt; countConnectedClientsByUser()
    {
<span class="nc" id="L145">        return connectionTracker.countConnectedClientsByUser();</span>
    }

    public List&lt;ConnectedClient&gt; getConnectedClients()
    {
<span class="nc" id="L150">        List&lt;ConnectedClient&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">        for (Channel c : connectionTracker.allChannels)</span>
        {
<span class="nc" id="L153">            Connection conn = c.attr(Connection.attributeKey).get();</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">            if (conn instanceof ServerConnection)</span>
<span class="nc" id="L155">                result.add(new ConnectedClient((ServerConnection) conn));</span>
<span class="nc" id="L156">        }</span>
<span class="nc" id="L157">        return result;</span>
    }

    public List&lt;ClientStat&gt; recentClientStats()
    {
<span class="nc" id="L162">        return connectionTracker.protocolVersionTracker.getAll();</span>
    }

    @Override
    public void clearConnectionHistory()
    {
<span class="nc" id="L168">        connectionTracker.protocolVersionTracker.clear();</span>
<span class="nc" id="L169">    }</span>

    private void close()
    {
        // Close opened connections
<span class="fc" id="L174">        connectionTracker.closeAll();</span>

<span class="fc" id="L176">        logger.info(&quot;Stop listening for CQL clients&quot;);</span>
<span class="fc" id="L177">    }</span>

<span class="fc" id="L179">    public static class Builder</span>
    {
        private EventLoopGroup workerGroup;
<span class="fc" id="L182">        private EncryptionOptions.TlsEncryptionPolicy tlsEncryptionPolicy = EncryptionOptions.TlsEncryptionPolicy.UNENCRYPTED;</span>
        private InetAddress hostAddr;
<span class="fc" id="L184">        private int port = -1;</span>
        private InetSocketAddress socket;
        private PipelineConfigurator pipelineConfigurator;
        private EventNotifier eventNotifier;

        public Builder withTlsEncryptionPolicy(EncryptionOptions.TlsEncryptionPolicy tlsEncryptionPolicy)
        {
<span class="fc" id="L191">            this.tlsEncryptionPolicy = tlsEncryptionPolicy;</span>
<span class="fc" id="L192">            return this;</span>
        }

        public Builder withEventLoopGroup(EventLoopGroup eventLoopGroup)
        {
<span class="fc" id="L197">            this.workerGroup = eventLoopGroup;</span>
<span class="fc" id="L198">            return this;</span>
        }

        public Builder withHost(InetAddress host)
        {
<span class="fc" id="L203">            this.hostAddr = host;</span>
<span class="fc" id="L204">            this.socket = null;</span>
<span class="fc" id="L205">            return this;</span>
        }

        public Builder withPort(int port)
        {
<span class="fc" id="L210">            this.port = port;</span>
<span class="fc" id="L211">            this.socket = null;</span>
<span class="fc" id="L212">            return this;</span>
        }

        public Builder withPipelineConfigurator(PipelineConfigurator configurator)
        {
<span class="nc" id="L217">            this.pipelineConfigurator = configurator;</span>
<span class="nc" id="L218">            return this;</span>
        }

        public Builder withEventNotifier(EventNotifier eventNotifier)
        {
<span class="nc" id="L223">            this.eventNotifier = eventNotifier;</span>
<span class="nc" id="L224">            return this;</span>
        }

        public Server build()
        {
<span class="fc" id="L229">            return new Server(this);</span>
        }

        private InetSocketAddress getSocket()
        {
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">            if (this.socket != null)</span>
<span class="nc" id="L235">                return this.socket;</span>
            else
            {
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">                if (this.port == -1)</span>
<span class="nc" id="L239">                    throw new IllegalStateException(&quot;Missing port number&quot;);</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">                if (this.hostAddr != null)</span>
<span class="fc" id="L241">                    this.socket = new InetSocketAddress(this.hostAddr, this.port);</span>
                else
<span class="nc" id="L243">                    throw new IllegalStateException(&quot;Missing host&quot;);</span>
<span class="fc" id="L244">                return this.socket;</span>
            }
        }
    }

    public static class ConnectionTracker implements Connection.Tracker
    {
<span class="fc" id="L251">        private static final ChannelMatcher PRE_V5_CHANNEL = channel -&gt; channel.attr(Connection.attributeKey)</span>
<span class="fc" id="L252">                                                                               .get()</span>
<span class="fc" id="L253">                                                                               .getVersion()</span>
<span class="fc" id="L254">                                                                               .isSmallerThan(ProtocolVersion.V5);</span>

        // TODO: should we be using the GlobalEventExecutor or defining our own?
<span class="fc" id="L257">        public final ChannelGroup allChannels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span>
<span class="fc" id="L258">        private final EnumMap&lt;Event.Type, ChannelGroup&gt; groups = new EnumMap&lt;&gt;(Event.Type.class);</span>
<span class="fc" id="L259">        private final ProtocolVersionTracker protocolVersionTracker = new ProtocolVersionTracker();</span>

        public ConnectionTracker()
<span class="fc" id="L262">        {</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">            for (Event.Type type : Event.Type.values())</span>
<span class="fc" id="L264">                groups.put(type, new DefaultChannelGroup(type.toString(), GlobalEventExecutor.INSTANCE));</span>
<span class="fc" id="L265">        }</span>

        public void addConnection(Channel ch, Connection connection)
        {
<span class="fc" id="L269">            allChannels.add(ch);</span>

<span class="pc bpc" id="L271" title="1 of 2 branches missed.">            if (ch.remoteAddress() instanceof InetSocketAddress)</span>
<span class="fc" id="L272">                protocolVersionTracker.addConnection(((InetSocketAddress) ch.remoteAddress()).getAddress(), connection.getVersion());</span>
<span class="fc" id="L273">        }</span>

        public void register(Event.Type type, Channel ch)
        {
<span class="fc" id="L277">            groups.get(type).add(ch);</span>
<span class="fc" id="L278">        }</span>

        public void send(Event event)
        {
<span class="fc" id="L282">            ChannelGroup registered = groups.get(event.type);</span>
<span class="fc" id="L283">            EventMessage message = new EventMessage(event);</span>

            // Deliver event to pre-v5 channels
<span class="fc" id="L286">            registered.writeAndFlush(message, PRE_V5_CHANNEL);</span>

            // Deliver event to post-v5 channels
<span class="fc bfc" id="L289" title="All 2 branches covered.">            for (Channel c : registered)</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">                if (!PRE_V5_CHANNEL.matches(c))</span>
<span class="fc" id="L291">                    c.attr(Dispatcher.EVENT_DISPATCHER).get().accept(message);</span>
<span class="fc" id="L292">        }</span>

        void closeAll()
        {
<span class="fc" id="L296">            allChannels.close().awaitUninterruptibly();</span>
<span class="fc" id="L297">        }</span>

        int countConnectedClients()
        {
            /*
              - When server is running: allChannels contains all clients' connections (channels)
                plus one additional channel used for the server's own bootstrap.
               - When server is stopped: the size is 0
            */
<span class="nc bnc" id="L306" title="All 2 branches missed.">            return allChannels.size() != 0 ? allChannels.size() - 1 : 0;</span>
        }

        Map&lt;String, Integer&gt; countConnectedClientsByUser()
        {
<span class="nc" id="L311">            Map&lt;String, Integer&gt; result = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">            for (Channel c : allChannels)</span>
            {
<span class="nc" id="L314">                Connection connection = c.attr(Connection.attributeKey).get();</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">                if (connection instanceof ServerConnection)</span>
                {
<span class="nc" id="L317">                    ServerConnection conn = (ServerConnection) connection;</span>
<span class="nc" id="L318">                    AuthenticatedUser user = conn.getClientState().getUser();</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">                    String name = (null != user) ? user.getName() : null;</span>
<span class="nc" id="L320">                    result.put(name, result.getOrDefault(name, 0) + 1);</span>
                }
<span class="nc" id="L322">            }</span>
<span class="nc" id="L323">            return result;</span>
        }

    }

    private static class LatestEvent
    {
        public final Event.StatusChange.Status status;
        public final Event.TopologyChange.Change topology;

        private LatestEvent(Event.StatusChange.Status status, Event.TopologyChange.Change topology)
<span class="fc" id="L334">        {</span>
<span class="fc" id="L335">            this.status = status;</span>
<span class="fc" id="L336">            this.topology = topology;</span>
<span class="fc" id="L337">        }</span>

        @Override
        public String toString()
        {
<span class="nc" id="L342">            return String.format(&quot;Status %s, Topology %s&quot;, status, topology);</span>
        }

        public static LatestEvent forStatusChange(Event.StatusChange.Status status, LatestEvent prev)
        {
<span class="fc" id="L347">            return new LatestEvent(status,</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">                                   prev == null ?</span>
<span class="fc" id="L349">                                           null :</span>
<span class="pc" id="L350">                                           prev.topology);</span>
        }

        public static LatestEvent forTopologyChange(Event.TopologyChange.Change change, LatestEvent prev)
        {
<span class="fc bfc" id="L355" title="All 2 branches covered.">            return new LatestEvent(prev == null ?</span>
<span class="fc" id="L356">                                           null :</span>
<span class="fc" id="L357">                                           prev.status,</span>
                                           change);
        }
    }

<span class="fc" id="L362">    public static class EventNotifier implements SchemaChangeListener, IEndpointLifecycleSubscriber</span>
    {
        private ConnectionTracker connectionTracker;

        // We keep track of the latest status change events we have sent to avoid sending duplicates
        // since StorageService may send duplicate notifications (CASSANDRA-7816, CASSANDRA-8236, CASSANDRA-9156)
<span class="fc" id="L368">        private final Map&lt;InetAddressAndPort, LatestEvent&gt; latestEvents = new ConcurrentHashMap&lt;&gt;();</span>
        // We also want to delay delivering a NEW_NODE notification until the new node has set its RPC ready
        // state. This tracks the endpoints which have joined, but not yet signalled they're ready for clients
<span class="fc" id="L371">        private final Set&lt;InetAddressAndPort&gt; endpointsPendingJoinedNotification = ConcurrentHashMap.newKeySet();</span>

        private void registerConnectionTracker(ConnectionTracker connectionTracker)
        {
<span class="fc" id="L375">            this.connectionTracker = connectionTracker;</span>
<span class="fc" id="L376">        }</span>

        private InetAddressAndPort getNativeAddress(InetAddressAndPort endpoint)
        {
            try
            {
<span class="fc" id="L382">                return InetAddressAndPort.getByName(StorageService.instance.getNativeaddress(endpoint, true));</span>
            }
<span class="nc" id="L384">            catch (UnknownHostException e)</span>
            {
                // That should not happen, so log an error, but return the
                // endpoint address since there's a good change this is right
<span class="nc" id="L388">                logger.error(&quot;Problem retrieving RPC address for {}&quot;, endpoint, e);</span>
<span class="nc" id="L389">                return InetAddressAndPort.getByAddressOverrideDefaults(endpoint.getAddress(), DatabaseDescriptor.getNativeTransportPort());</span>
            }
        }

        private void send(InetAddressAndPort endpoint, Event.NodeEvent event)
        {
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">            if (logger.isTraceEnabled())</span>
<span class="nc" id="L396">                logger.trace(&quot;Sending event for endpoint {}, rpc address {}&quot;, endpoint, event.nodeAddressAndPort());</span>

            // If the endpoint is not the local node, extract the node address
            // and if it is the same as our own RPC broadcast address (which defaults to the rcp address)
            // then don't send the notification. This covers the case of rpc_address set to &quot;localhost&quot;,
            // which is not useful to any driver and in fact may cauase serious problems to some drivers,
            // see CASSANDRA-10052
<span class="fc bfc" id="L403" title="All 2 branches covered.">            if (!endpoint.equals(FBUtilities.getBroadcastAddressAndPort()) &amp;&amp;</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">                event.nodeAddressAndPort().equals(FBUtilities.getBroadcastNativeAddressAndPort()))</span>
<span class="nc" id="L405">                return;</span>

<span class="fc" id="L407">            send(event);</span>
<span class="fc" id="L408">        }</span>

        private void send(Event event)
        {
<span class="fc" id="L412">            connectionTracker.send(event);</span>
<span class="fc" id="L413">        }</span>

        @Override
        public void onJoinCluster(InetAddressAndPort endpoint)
        {
<span class="fc bfc" id="L418" title="All 2 branches covered.">            if (!StorageService.instance.isRpcReady(endpoint))</span>
<span class="fc" id="L419">                endpointsPendingJoinedNotification.add(endpoint);</span>
            else
<span class="fc" id="L421">                onTopologyChange(endpoint, Event.TopologyChange.newNode(getNativeAddress(endpoint)));</span>
<span class="fc" id="L422">        }</span>

        @Override
        public void onLeaveCluster(InetAddressAndPort endpoint)
        {
<span class="fc" id="L427">            onTopologyChange(endpoint, Event.TopologyChange.removedNode(getNativeAddress(endpoint)));</span>
<span class="fc" id="L428">        }</span>

        @Override
        public void onMove(InetAddressAndPort endpoint)
        {
<span class="nc" id="L433">            onTopologyChange(endpoint, Event.TopologyChange.movedNode(getNativeAddress(endpoint)));</span>
<span class="nc" id="L434">        }</span>

        @Override
        public void onUp(InetAddressAndPort endpoint)
        {
<span class="fc bfc" id="L439" title="All 2 branches covered.">            if (endpointsPendingJoinedNotification.remove(endpoint))</span>
<span class="fc" id="L440">                onJoinCluster(endpoint);</span>

<span class="fc" id="L442">            onStatusChange(endpoint, Event.StatusChange.nodeUp(getNativeAddress(endpoint)));</span>
<span class="fc" id="L443">        }</span>

        @Override
        public void onDown(InetAddressAndPort endpoint)
        {
<span class="fc" id="L448">            onStatusChange(endpoint, Event.StatusChange.nodeDown(getNativeAddress(endpoint)));</span>
<span class="fc" id="L449">        }</span>

        private void onTopologyChange(InetAddressAndPort endpoint, Event.TopologyChange event)
        {
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">            if (logger.isTraceEnabled())</span>
<span class="nc" id="L454">                logger.trace(&quot;Topology changed event : {}, {}&quot;, endpoint, event.change);</span>

<span class="fc" id="L456">            LatestEvent prev = latestEvents.get(endpoint);</span>
<span class="fc bfc" id="L457" title="All 4 branches covered.">            if (prev == null || prev.topology != event.change)</span>
            {
<span class="fc" id="L459">                LatestEvent ret = latestEvents.put(endpoint, LatestEvent.forTopologyChange(event.change, prev));</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">                if (ret == prev)</span>
<span class="fc" id="L461">                    send(endpoint, event);</span>
            }
<span class="fc" id="L463">        }</span>

        private void onStatusChange(InetAddressAndPort endpoint, Event.StatusChange event)
        {
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">            if (logger.isTraceEnabled())</span>
<span class="nc" id="L468">                logger.trace(&quot;Status changed event : {}, {}&quot;, endpoint, event.status);</span>

<span class="fc" id="L470">            LatestEvent prev = latestEvents.get(endpoint);</span>
<span class="fc bfc" id="L471" title="All 4 branches covered.">            if (prev == null || prev.status != event.status)</span>
            {
<span class="fc" id="L473">                LatestEvent ret = latestEvents.put(endpoint, LatestEvent.forStatusChange(event.status, null));</span>
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">                if (ret == prev)</span>
<span class="fc" id="L475">                    send(endpoint, event);</span>
            }
<span class="fc" id="L477">        }</span>

        @Override
        public void onCreateKeyspace(KeyspaceMetadata keyspace)
        {
<span class="fc" id="L482">            send(new Event.SchemaChange(Event.SchemaChange.Change.CREATED, keyspace.name));</span>
<span class="fc" id="L483">        }</span>

        @Override
        public void onCreateTable(TableMetadata table)
        {
<span class="fc" id="L488">            send(new Event.SchemaChange(Event.SchemaChange.Change.CREATED, Event.SchemaChange.Target.TABLE, table.keyspace, table.name));</span>
<span class="fc" id="L489">        }</span>

        @Override
        public void onCreateType(UserType type)
        {
<span class="fc" id="L494">            send(new Event.SchemaChange(Event.SchemaChange.Change.CREATED, Event.SchemaChange.Target.TYPE, type.keyspace, type.getNameAsString()));</span>
<span class="fc" id="L495">        }</span>

        @Override
        public void onCreateFunction(UDFunction function)
        {
<span class="nc" id="L500">            send(new Event.SchemaChange(Event.SchemaChange.Change.CREATED, Event.SchemaChange.Target.FUNCTION,</span>
<span class="nc" id="L501">                                        function.name().keyspace, function.name().name, AbstractType.asCQLTypeStringList(function.argTypes())));</span>
<span class="nc" id="L502">        }</span>

        @Override
        public void onCreateAggregate(UDAggregate aggregate)
        {
<span class="nc" id="L507">            send(new Event.SchemaChange(Event.SchemaChange.Change.CREATED, Event.SchemaChange.Target.AGGREGATE,</span>
<span class="nc" id="L508">                                        aggregate.name().keyspace, aggregate.name().name, AbstractType.asCQLTypeStringList(aggregate.argTypes())));</span>
<span class="nc" id="L509">        }</span>

        @Override
        public void onAlterKeyspace(KeyspaceMetadata before, KeyspaceMetadata after)
        {
<span class="fc" id="L514">            send(new Event.SchemaChange(Event.SchemaChange.Change.UPDATED, after.name));</span>
<span class="fc" id="L515">        }</span>

        @Override
        public void onAlterTable(TableMetadata before, TableMetadata after, boolean affectsStatements)
        {
<span class="fc" id="L520">            send(new Event.SchemaChange(Event.SchemaChange.Change.UPDATED, Event.SchemaChange.Target.TABLE, after.keyspace, after.name));</span>
<span class="fc" id="L521">        }</span>

        @Override
        public void onAlterType(UserType before, UserType after)
        {
<span class="nc" id="L526">            send(new Event.SchemaChange(Event.SchemaChange.Change.UPDATED, Event.SchemaChange.Target.TYPE, after.keyspace, after.getNameAsString()));</span>
<span class="nc" id="L527">        }</span>

        @Override
        public void onAlterFunction(UDFunction before, UDFunction after)
        {
<span class="nc" id="L532">            send(new Event.SchemaChange(Event.SchemaChange.Change.UPDATED, Event.SchemaChange.Target.FUNCTION,</span>
<span class="nc" id="L533">                                        after.name().keyspace, after.name().name, AbstractType.asCQLTypeStringList(after.argTypes())));</span>
<span class="nc" id="L534">        }</span>

        @Override
        public void onAlterAggregate(UDAggregate before, UDAggregate after)
        {
<span class="nc" id="L539">            send(new Event.SchemaChange(Event.SchemaChange.Change.UPDATED, Event.SchemaChange.Target.AGGREGATE,</span>
<span class="nc" id="L540">                                        after.name().keyspace, after.name().name, AbstractType.asCQLTypeStringList(after.argTypes())));</span>
<span class="nc" id="L541">        }</span>

        @Override
        public void onDropKeyspace(KeyspaceMetadata keyspace, boolean dropData)
        {
<span class="nc" id="L546">            send(new Event.SchemaChange(Event.SchemaChange.Change.DROPPED, keyspace.name));</span>
<span class="nc" id="L547">        }</span>

        @Override
        public void onDropTable(TableMetadata table, boolean dropData)
        {
<span class="nc" id="L552">            send(new Event.SchemaChange(Event.SchemaChange.Change.DROPPED, Event.SchemaChange.Target.TABLE, table.keyspace, table.name));</span>
<span class="nc" id="L553">        }</span>

        @Override
        public void onDropType(UserType type)
        {
<span class="nc" id="L558">            send(new Event.SchemaChange(Event.SchemaChange.Change.DROPPED, Event.SchemaChange.Target.TYPE, type.keyspace, type.getNameAsString()));</span>
<span class="nc" id="L559">        }</span>

        @Override
        public void onDropFunction(UDFunction function)
        {
<span class="nc" id="L564">            send(new Event.SchemaChange(Event.SchemaChange.Change.DROPPED, Event.SchemaChange.Target.FUNCTION,</span>
<span class="nc" id="L565">                                        function.name().keyspace, function.name().name, AbstractType.asCQLTypeStringList(function.argTypes())));</span>
<span class="nc" id="L566">        }</span>

        @Override
        public void onDropAggregate(UDAggregate aggregate)
        {
<span class="nc" id="L571">            send(new Event.SchemaChange(Event.SchemaChange.Change.DROPPED, Event.SchemaChange.Target.AGGREGATE,</span>
<span class="nc" id="L572">                                        aggregate.name().keyspace, aggregate.name().name, AbstractType.asCQLTypeStringList(aggregate.argTypes())));</span>
<span class="nc" id="L573">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>