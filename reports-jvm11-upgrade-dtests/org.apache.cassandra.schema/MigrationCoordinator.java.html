<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MigrationCoordinator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.schema</a> &gt; <span class="el_source">MigrationCoordinator.java</span></div><h1>MigrationCoordinator.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.schema;

import java.lang.management.ManagementFactory;
import java.net.UnknownHostException;
import java.time.Duration;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiConsumer;
import java.util.function.LongSupplier;
import java.util.function.Supplier;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.concurrent.ExecutorPlus;
import org.apache.cassandra.concurrent.FutureTask;
import org.apache.cassandra.concurrent.ScheduledExecutors;
import org.apache.cassandra.config.CassandraRelevantProperties;
import org.apache.cassandra.db.Mutation;
import org.apache.cassandra.exceptions.RequestFailureReason;
import org.apache.cassandra.gms.ApplicationState;
import org.apache.cassandra.gms.EndpointState;
import org.apache.cassandra.gms.Gossiper;
import org.apache.cassandra.gms.VersionedValue;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.net.Message;
import org.apache.cassandra.net.MessagingService;
import org.apache.cassandra.net.NoPayload;
import org.apache.cassandra.net.RequestCallback;
import org.apache.cassandra.net.Verb;
import org.apache.cassandra.service.StorageService;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.NoSpamLogger;
import org.apache.cassandra.utils.Pair;
import org.apache.cassandra.utils.Simulate;
import org.apache.cassandra.utils.concurrent.Future;
import org.apache.cassandra.utils.concurrent.ImmediateFuture;
import org.apache.cassandra.utils.concurrent.WaitQueue;

import static org.apache.cassandra.config.CassandraRelevantProperties.IGNORED_SCHEMA_CHECK_ENDPOINTS;
import static org.apache.cassandra.config.CassandraRelevantProperties.IGNORED_SCHEMA_CHECK_VERSIONS;
import static org.apache.cassandra.config.CassandraRelevantProperties.SCHEMA_PULL_INTERVAL_MS;
import static org.apache.cassandra.net.Verb.SCHEMA_PUSH_REQ;
import static org.apache.cassandra.utils.Clock.Global.nanoTime;
import static org.apache.cassandra.utils.Simulate.With.MONITORS;
import static org.apache.cassandra.utils.concurrent.WaitQueue.newWaitQueue;

/**
 * Migration coordinator is responsible for tracking schema versions on various nodes and, if needed, synchronize the
 * schema. It performs periodic checks and if there is a schema version mismatch between the current node and the other
 * node, it pulls the schema and applies the changes locally through the callback.
 *
 * In particular the Migration Coordinator keeps track of all schema versions reported from each node in the cluster.
 * As long as a certain version is advertised by some node, it is being tracked. As long as a version is tracked,
 * the migration coordinator tries to fetch it by its periodic job.
 *
 * It works in close cooperation with {@link DefaultSchemaUpdateHandler} which is responsible for maintaining local
 * schema metadata stored in {@link SchemaKeyspace}.
 */
@Simulate(with = MONITORS)
public class MigrationCoordinator
{
<span class="fc" id="L100">    private static final Logger logger = LoggerFactory.getLogger(MigrationCoordinator.class);</span>
<span class="fc" id="L101">    private static final NoSpamLogger noSpamLogger = NoSpamLogger.getLogger(MigrationCoordinator.logger, 1, TimeUnit.MINUTES);</span>
<span class="fc" id="L102">    private static final Future&lt;Void&gt; FINISHED_FUTURE = ImmediateFuture.success(null);</span>

<span class="pc" id="L104">    private static LongSupplier getUptimeFn = () -&gt; ManagementFactory.getRuntimeMXBean().getUptime();</span>

    @VisibleForTesting
    public static void setUptimeFn(LongSupplier supplier)
    {
<span class="fc" id="L109">        getUptimeFn = supplier;</span>
<span class="fc" id="L110">    }</span>

<span class="fc" id="L112">    private static final int MIGRATION_DELAY_IN_MS = CassandraRelevantProperties.MIGRATION_DELAY.getInt();</span>
    public static final int MAX_OUTSTANDING_VERSION_REQUESTS = 3;

    private static ImmutableSet&lt;UUID&gt; getIgnoredVersions()
    {
<span class="fc" id="L117">        String s = IGNORED_SCHEMA_CHECK_VERSIONS.getString();</span>
<span class="pc bpc" id="L118" title="3 of 4 branches missed.">        if (s == null || s.isEmpty())</span>
<span class="fc" id="L119">            return ImmutableSet.of();</span>

<span class="nc" id="L121">        ImmutableSet.Builder&lt;UUID&gt; versions = ImmutableSet.builder();</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">        for (String version : s.split(&quot;,&quot;))</span>
        {
<span class="nc" id="L124">            versions.add(UUID.fromString(version));</span>
        }

<span class="nc" id="L127">        return versions.build();</span>
    }

<span class="fc" id="L130">    private static final Set&lt;UUID&gt; IGNORED_VERSIONS = getIgnoredVersions();</span>

    private static Set&lt;InetAddressAndPort&gt; getIgnoredEndpoints()
    {
<span class="fc" id="L134">        Set&lt;InetAddressAndPort&gt; endpoints = new HashSet&lt;&gt;();</span>

<span class="fc" id="L136">        String s = IGNORED_SCHEMA_CHECK_ENDPOINTS.getString();</span>
<span class="pc bpc" id="L137" title="3 of 4 branches missed.">        if (s == null || s.isEmpty())</span>
<span class="fc" id="L138">            return endpoints;</span>

<span class="nc bnc" id="L140" title="All 2 branches missed.">        for (String endpoint : s.split(&quot;,&quot;))</span>
        {
            try
            {
<span class="nc" id="L144">                endpoints.add(InetAddressAndPort.getByName(endpoint));</span>
            }
<span class="nc" id="L146">            catch (UnknownHostException e)</span>
            {
<span class="nc" id="L148">                throw new RuntimeException(e);</span>
<span class="nc" id="L149">            }</span>
        }

<span class="nc" id="L152">        return endpoints;</span>
    }

    static class VersionInfo
    {
        final UUID version;

        /**
         * The set of endpoints containing this schema version
         */
<span class="fc" id="L162">        final Set&lt;InetAddressAndPort&gt; endpoints           = Sets.newConcurrentHashSet();</span>
        /**
         * The set of endpoints from which we are already fetching the schema
         */
<span class="fc" id="L166">        final Set&lt;InetAddressAndPort&gt; outstandingRequests = Sets.newConcurrentHashSet();</span>
        /**
         * The queue of endpoints from which we are going to fetch the schema
         */
<span class="fc" id="L170">        final Deque&lt;InetAddressAndPort&gt; requestQueue      = new ArrayDeque&lt;&gt;();</span>

        /**
         * Threads waiting for schema synchronization are waiting until this object is signalled
         */
<span class="fc" id="L175">        private final WaitQueue waitQueue = newWaitQueue();</span>

        /**
         * Whether this schema version have been received
         */
        volatile boolean receivedSchema;

        VersionInfo(UUID version)
<span class="fc" id="L183">        {</span>
<span class="fc" id="L184">            this.version = version;</span>
<span class="fc" id="L185">        }</span>

        WaitQueue.Signal register()
        {
<span class="nc" id="L189">            return waitQueue.register();</span>
        }

        void markReceived()
        {
<span class="fc bfc" id="L194" title="All 2 branches covered.">            if (receivedSchema)</span>
<span class="fc" id="L195">                return;</span>

<span class="fc" id="L197">            receivedSchema = true;</span>
<span class="fc" id="L198">            waitQueue.signalAll();</span>
<span class="fc" id="L199">        }</span>

        boolean wasReceived()
        {
<span class="fc" id="L203">            return receivedSchema;</span>
        }

        @Override
        public String toString()
        {
<span class="fc" id="L209">            return &quot;VersionInfo{&quot; +</span>
                   &quot;version=&quot; + version +
                   &quot;, outstandingRequests=&quot; + outstandingRequests +
                   &quot;, requestQueue=&quot; + requestQueue +
<span class="fc" id="L213">                   &quot;, waitQueue.waiting=&quot; + waitQueue.getWaiting() +</span>
                   &quot;, receivedSchema=&quot; + receivedSchema +
                   '}';
        }
    }

<span class="fc" id="L219">    private final Map&lt;UUID, VersionInfo&gt; versionInfo = new HashMap&lt;&gt;();</span>
<span class="fc" id="L220">    private final Map&lt;InetAddressAndPort, UUID&gt; endpointVersions = new HashMap&lt;&gt;();</span>
<span class="fc" id="L221">    private final Set&lt;InetAddressAndPort&gt; ignoredEndpoints = getIgnoredEndpoints();</span>
    private final ScheduledExecutorService periodicCheckExecutor;
    private final MessagingService messagingService;
<span class="fc" id="L224">    private final AtomicReference&lt;ScheduledFuture&lt;?&gt;&gt; periodicPullTask = new AtomicReference&lt;&gt;();</span>
    private final int maxOutstandingVersionRequests;
    private final Gossiper gossiper;
    private final Supplier&lt;UUID&gt; schemaVersion;
    private final BiConsumer&lt;InetAddressAndPort, Collection&lt;Mutation&gt;&gt; schemaUpdateCallback;

    final ExecutorPlus executor;

    /**
     * Creates but does not start migration coordinator instance.
     * @param messagingService      messaging service instance used to communicate with other nodes for pulling schema
     *                              and pushing changes
     * @param periodicCheckExecutor executor on which the periodic checks are scheduled
     */
    MigrationCoordinator(MessagingService messagingService,
                         ExecutorPlus executor,
                         ScheduledExecutorService periodicCheckExecutor,
                         int maxOutstandingVersionRequests,
                         Gossiper gossiper,
                         Supplier&lt;UUID&gt; schemaVersionSupplier,
                         BiConsumer&lt;InetAddressAndPort, Collection&lt;Mutation&gt;&gt; schemaUpdateCallback)
<span class="fc" id="L245">    {</span>
<span class="fc" id="L246">        this.messagingService = messagingService;</span>
<span class="fc" id="L247">        this.executor = executor;</span>
<span class="fc" id="L248">        this.periodicCheckExecutor = periodicCheckExecutor;</span>
<span class="fc" id="L249">        this.maxOutstandingVersionRequests = maxOutstandingVersionRequests;</span>
<span class="fc" id="L250">        this.gossiper = gossiper;</span>
<span class="fc" id="L251">        this.schemaVersion = schemaVersionSupplier;</span>
<span class="fc" id="L252">        this.schemaUpdateCallback = schemaUpdateCallback;</span>
<span class="fc" id="L253">    }</span>

    void start()
    {
<span class="fc" id="L257">        long interval = SCHEMA_PULL_INTERVAL_MS.getLong();</span>
<span class="fc" id="L258">        logger.info(&quot;Starting migration coordinator and scheduling pulling schema versions every {}&quot;, Duration.ofMillis(interval));</span>
<span class="fc" id="L259">        announce(schemaVersion.get());</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">        periodicPullTask.updateAndGet(curTask -&gt; curTask == null</span>
<span class="fc" id="L261">                                                 ? periodicCheckExecutor.scheduleWithFixedDelay(this::pullUnreceivedSchemaVersions, interval, interval, TimeUnit.MILLISECONDS)</span>
<span class="nc" id="L262">                                                 : curTask);</span>
<span class="fc" id="L263">    }</span>

    private synchronized void pullUnreceivedSchemaVersions()
    {
<span class="fc" id="L267">        logger.debug(&quot;Pulling unreceived schema versions...&quot;);</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">        for (VersionInfo info : versionInfo.values())</span>
        {
<span class="pc bpc" id="L270" title="1 of 4 branches missed.">            if (info.wasReceived() || info.outstandingRequests.size() &gt; 0)</span>
            {
<span class="fc" id="L272">                logger.trace(&quot;Skipping pull of schema {} because it has been already recevied, or it is being received ({})&quot;, info.version, info);</span>
<span class="fc" id="L273">                continue;</span>
            }

<span class="fc" id="L276">            maybePullSchema(info);</span>
<span class="fc" id="L277">        }</span>
<span class="fc" id="L278">    }</span>

    private synchronized Future&lt;Void&gt; maybePullSchema(VersionInfo info)
    {
<span class="fc bfc" id="L282" title="All 6 branches covered.">        if (info.endpoints.isEmpty() || info.wasReceived() || !shouldPullSchema(info.version))</span>
        {
<span class="fc" id="L284">            logger.trace(&quot;Not pulling schema {} because it was received, there is no endpoint to provide it, or we should not pull it ({})&quot;, info.version, info);</span>
<span class="fc" id="L285">            return FINISHED_FUTURE;</span>
        }

<span class="pc bpc" id="L288" title="1 of 2 branches missed.">        if (info.outstandingRequests.size() &gt;= maxOutstandingVersionRequests)</span>
        {
<span class="nc" id="L290">            logger.trace(&quot;Not pulling schema {} because the number of outstanding requests has been exceeded ({} &gt;= {})&quot;, info.version, info.outstandingRequests.size(), maxOutstandingVersionRequests);</span>
<span class="nc" id="L291">            return FINISHED_FUTURE;</span>
        }

<span class="fc bfc" id="L294" title="All 2 branches covered.">        for (int i = 0, isize = info.requestQueue.size(); i &lt; isize; i++)</span>
        {
<span class="fc" id="L296">            InetAddressAndPort endpoint = info.requestQueue.remove();</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">            if (!info.endpoints.contains(endpoint))</span>
            {
<span class="fc" id="L299">                logger.trace(&quot;Skipping request of schema {} from {} because the endpoint does not have that schema any longer&quot;, info.version, endpoint);</span>
<span class="fc" id="L300">                continue;</span>
            }

<span class="pc bpc" id="L303" title="1 of 4 branches missed.">            if (shouldPullFromEndpoint(endpoint) &amp;&amp; info.outstandingRequests.add(endpoint))</span>
            {
<span class="fc" id="L305">                return scheduleSchemaPull(endpoint, info);</span>
            }
            else
            {
                // return to queue
<span class="fc" id="L310">                logger.trace(&quot;Could not pull schema {} from {} - the request will be added back to the queue&quot;, info.version, endpoint);</span>
<span class="fc" id="L311">                info.requestQueue.offer(endpoint);</span>
            }
        }

        // no suitable endpoints were found, check again in a minute, the periodic task will pick it up
<span class="fc" id="L316">        return FINISHED_FUTURE;</span>
    }

    synchronized Map&lt;UUID, Set&lt;InetAddressAndPort&gt;&gt; outstandingVersions()
    {
<span class="nc" id="L321">        HashMap&lt;UUID, Set&lt;InetAddressAndPort&gt;&gt; map = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">        for (VersionInfo info : versionInfo.values())</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">            if (!info.wasReceived())</span>
<span class="nc" id="L324">                map.put(info.version, ImmutableSet.copyOf(info.endpoints));</span>
<span class="nc" id="L325">        return map;</span>
    }

    @VisibleForTesting
    VersionInfo getVersionInfoUnsafe(UUID version)
    {
<span class="nc" id="L331">        return versionInfo.get(version);</span>
    }

    private boolean shouldPullSchema(UUID version)
    {
<span class="fc" id="L336">        UUID localSchemaVersion = schemaVersion.get();</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">        if (localSchemaVersion == null)</span>
        {
<span class="nc" id="L339">            logger.debug(&quot;Not pulling schema {} because the local schama version is not known yet&quot;, version);</span>
<span class="nc" id="L340">            return false;</span>
        }

<span class="fc bfc" id="L343" title="All 2 branches covered.">        if (localSchemaVersion.equals(version))</span>
        {
<span class="fc" id="L345">            logger.debug(&quot;Not pulling schema {} because it is the same as the local schema&quot;, version);</span>
<span class="fc" id="L346">            return false;</span>
        }

<span class="fc" id="L349">        return true;</span>
    }

    private boolean shouldPullFromEndpoint(InetAddressAndPort endpoint)
    {
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">        if (endpoint.equals(FBUtilities.getBroadcastAddressAndPort()))</span>
        {
<span class="nc" id="L356">            logger.trace(&quot;Not pulling schema from local endpoint&quot;);</span>
<span class="nc" id="L357">            return false;</span>
        }

<span class="fc" id="L360">        EndpointState state = gossiper.getEndpointStateForEndpoint(endpoint);</span>
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">        if (state == null)</span>
        {
<span class="nc" id="L363">            logger.trace(&quot;Not pulling schema from endpoint {} because its state is unknown&quot;, endpoint);</span>
<span class="nc" id="L364">            return false;</span>
        }

<span class="fc" id="L367">        VersionedValue releaseVersionValue = state.getApplicationState(ApplicationState.RELEASE_VERSION);</span>
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">        if (releaseVersionValue == null)</span>
<span class="nc" id="L369">            return false;</span>
<span class="fc" id="L370">        final String releaseVersion = releaseVersionValue.value;</span>
<span class="fc" id="L371">        final String ourMajorVersion = FBUtilities.getReleaseVersionMajor();</span>

<span class="fc bfc" id="L373" title="All 2 branches covered.">        if (!releaseVersion.startsWith(ourMajorVersion))</span>
        {
<span class="fc" id="L375">            logger.debug(&quot;Not pulling schema from {} because release version in Gossip is not major version {}, it is {}&quot;,</span>
                         endpoint, ourMajorVersion, releaseVersion);
<span class="fc" id="L377">            return false;</span>
        }

<span class="pc bpc" id="L380" title="1 of 2 branches missed.">        if (!messagingService.versions.knows(endpoint))</span>
        {
<span class="nc" id="L382">            logger.debug(&quot;Not pulling schema from {} because their messaging version is unknown&quot;, endpoint);</span>
<span class="nc" id="L383">            return false;</span>
        }

<span class="pc bpc" id="L386" title="1 of 2 branches missed.">        if (messagingService.versions.getRaw(endpoint) != MessagingService.current_version)</span>
        {
<span class="nc" id="L388">            logger.debug(&quot;Not pulling schema from {} because their schema format is incompatible&quot;, endpoint);</span>
<span class="nc" id="L389">            return false;</span>
        }

<span class="pc bpc" id="L392" title="1 of 2 branches missed.">        if (gossiper.isGossipOnlyMember(endpoint))</span>
        {
<span class="nc" id="L394">            logger.debug(&quot;Not pulling schema from {} because it's a gossip only member&quot;, endpoint);</span>
<span class="nc" id="L395">            return false;</span>
        }
<span class="fc" id="L397">        return true;</span>
    }

    private boolean shouldPullImmediately(InetAddressAndPort endpoint, UUID version)
    {
<span class="fc" id="L402">        UUID localSchemaVersion = schemaVersion.get();</span>
<span class="pc bpc" id="L403" title="2 of 4 branches missed.">        if (SchemaConstants.emptyVersion.equals(localSchemaVersion) || getUptimeFn.getAsLong() &lt; MIGRATION_DELAY_IN_MS)</span>
        {
            // If we think we may be bootstrapping or have recently started, submit MigrationTask immediately
<span class="fc" id="L406">            logger.debug(&quot;Immediately submitting migration task for {}, &quot; +</span>
                         &quot;schema versions: local={}, remote={}&quot;,
                         endpoint,
<span class="fc" id="L409">                         DistributedSchema.schemaVersionToString(localSchemaVersion),</span>
<span class="fc" id="L410">                         DistributedSchema.schemaVersionToString(version));</span>
<span class="fc" id="L411">            return true;</span>
        }
<span class="nc" id="L413">        return false;</span>
    }

    /**
     * If a previous schema update brought our version the same as the incoming schema, don't apply it
     */
    private synchronized boolean shouldApplySchemaFor(VersionInfo info)
    {
<span class="fc bfc" id="L421" title="All 2 branches covered.">        if (info.wasReceived())</span>
<span class="fc" id="L422">            return false;</span>
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">        return !Objects.equals(schemaVersion.get(), info.version);</span>
    }

    synchronized Future&lt;Void&gt; reportEndpointVersion(InetAddressAndPort endpoint, UUID version)
    {
<span class="fc" id="L428">        logger.debug(&quot;Reported schema {} at endpoint {}&quot;, version, endpoint);</span>
<span class="pc bpc" id="L429" title="2 of 4 branches missed.">        if (ignoredEndpoints.contains(endpoint) || IGNORED_VERSIONS.contains(version))</span>
        {
<span class="nc" id="L431">            endpointVersions.remove(endpoint);</span>
<span class="nc" id="L432">            removeEndpointFromVersion(endpoint, null);</span>
<span class="nc" id="L433">            logger.debug(&quot;Discarding endpoint {} or schema {} because either endpoint or schema version were marked as ignored&quot;, endpoint, version);</span>
<span class="nc" id="L434">            return FINISHED_FUTURE;</span>
        }

<span class="fc" id="L437">        UUID current = endpointVersions.put(endpoint, version);</span>
<span class="fc bfc" id="L438" title="All 4 branches covered.">        if (current != null &amp;&amp; current.equals(version))</span>
        {
<span class="fc" id="L440">            logger.trace(&quot;Skipping report of schema {} from {} because we already know that&quot;, version, endpoint);</span>
<span class="fc" id="L441">            return FINISHED_FUTURE;</span>
        }

<span class="fc" id="L444">        VersionInfo info = versionInfo.computeIfAbsent(version, VersionInfo::new);</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">        if (Objects.equals(schemaVersion.get(), version))</span>
        {
<span class="fc" id="L447">            info.markReceived();</span>
<span class="fc" id="L448">            logger.trace(&quot;Schema {} from {} has been marked as recevied because it is equal the local schema&quot;, version, endpoint);</span>
        }
        else
        {
<span class="fc" id="L452">            info.requestQueue.addFirst(endpoint);</span>
        }
<span class="fc" id="L454">        info.endpoints.add(endpoint);</span>
<span class="fc" id="L455">        logger.trace(&quot;Added endpoint {} to schema {}: {}&quot;, endpoint, info.version, info);</span>

        // disassociate this endpoint from its (now) previous schema version
<span class="fc" id="L458">        removeEndpointFromVersion(endpoint, current);</span>

<span class="fc" id="L460">        return maybePullSchema(info);</span>
    }

    private synchronized void removeEndpointFromVersion(InetAddressAndPort endpoint, UUID version)
    {
<span class="fc bfc" id="L465" title="All 2 branches covered.">        if (version == null)</span>
<span class="fc" id="L466">            return;</span>

<span class="fc" id="L468">        VersionInfo info = versionInfo.get(version);</span>

<span class="pc bpc" id="L470" title="1 of 2 branches missed.">        if (info == null)</span>
<span class="nc" id="L471">            return;</span>

<span class="fc" id="L473">        info.endpoints.remove(endpoint);</span>
<span class="fc" id="L474">        logger.trace(&quot;Removed endpoint {} from schema {}: {}&quot;, endpoint, version, info);</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">        if (info.endpoints.isEmpty())</span>
        {
<span class="fc" id="L477">            info.waitQueue.signalAll();</span>
<span class="fc" id="L478">            versionInfo.remove(version);</span>
<span class="fc" id="L479">            logger.trace(&quot;Removed schema info: {}&quot;, info);</span>
        }
<span class="fc" id="L481">    }</span>

    private void clearVersionsInfo()
    {
<span class="nc" id="L485">        Iterator&lt;Map.Entry&lt;UUID, VersionInfo&gt;&gt; it = versionInfo.entrySet().iterator();</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">        while (it.hasNext())</span>
        {
<span class="nc" id="L488">            Map.Entry&lt;UUID, VersionInfo&gt; entry = it.next();</span>
<span class="nc" id="L489">            it.remove();</span>
<span class="nc" id="L490">            entry.getValue().waitQueue.signal();</span>
<span class="nc" id="L491">        }</span>
<span class="nc" id="L492">    }</span>

    private void reportCurrentSchemaVersionOnEndpoint(InetAddressAndPort endpoint)
    {
<span class="nc bnc" id="L496" title="All 2 branches missed.">        if (FBUtilities.getBroadcastAddressAndPort().equals(endpoint))</span>
        {
<span class="nc" id="L498">            reportEndpointVersion(endpoint, schemaVersion.get());</span>
        }
        else
        {
<span class="nc" id="L502">            EndpointState state = gossiper.getEndpointStateForEndpoint(endpoint);</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">            if (state != null)</span>
            {
<span class="nc" id="L505">                UUID v = state.getSchemaVersion();</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">                if (v != null)</span>
                {
<span class="nc" id="L508">                    reportEndpointVersion(endpoint, v);</span>
                }
            }
        }
<span class="nc" id="L512">    }</span>

    /**
     * Resets the migration coordinator by notifying all waiting threads and removing all the existing version info.
     * Then, it is populated with the information about schema versions on different endpoints provided by Gossiper.
     * Each version is marked as unreceived so the migration coordinator will start pulling schemas from other nodes.
     */
    synchronized void reset()
    {
<span class="nc" id="L521">        logger.info(&quot;Resetting migration coordinator...&quot;);</span>

        // clear all the managed information
<span class="nc" id="L524">        this.endpointVersions.clear();</span>
<span class="nc" id="L525">        clearVersionsInfo();</span>

        // now report again the versions we are aware of
<span class="nc" id="L528">        gossiper.getLiveMembers().forEach(this::reportCurrentSchemaVersionOnEndpoint);</span>
<span class="nc" id="L529">    }</span>

    synchronized void removeAndIgnoreEndpoint(InetAddressAndPort endpoint)
    {
<span class="nc" id="L533">        logger.debug(&quot;Removing and ignoring endpoint {}&quot;, endpoint);</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">        Preconditions.checkArgument(endpoint != null);</span>
        // TODO The endpoint address is now ignored but when a node with the same address is added again later,
        //  there will be no way to include it in schema synchronization other than restarting each other node
        //  see https://issues.apache.org/jira/browse/CASSANDRA-17883 for details
<span class="nc" id="L538">        ignoredEndpoints.add(endpoint);</span>
<span class="nc" id="L539">        Set&lt;UUID&gt; versions = ImmutableSet.copyOf(versionInfo.keySet());</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">        for (UUID version : versions)</span>
        {
<span class="nc" id="L542">            removeEndpointFromVersion(endpoint, version);</span>
<span class="nc" id="L543">        }</span>
<span class="nc" id="L544">    }</span>

    private Future&lt;Void&gt; scheduleSchemaPull(InetAddressAndPort endpoint, VersionInfo info)
    {
<span class="fc" id="L548">        FutureTask&lt;Void&gt; task = new FutureTask&lt;&gt;(() -&gt; pullSchema(endpoint, new Callback(endpoint, info)));</span>

<span class="pc bpc" id="L550" title="1 of 2 branches missed.">        if (shouldPullImmediately(endpoint, info.version))</span>
        {
<span class="fc" id="L552">            logger.debug(&quot;Pulling {} immediately from {}&quot;, info, endpoint);</span>
<span class="fc" id="L553">            submitToMigrationIfNotShutdown(task);</span>
        }
        else
        {
<span class="nc" id="L557">            logger.debug(&quot;Postponing pull of {} from {} for {}ms&quot;, info, endpoint, MIGRATION_DELAY_IN_MS);</span>
<span class="nc" id="L558">            ScheduledExecutors.nonPeriodicTasks.schedule(() -&gt; submitToMigrationIfNotShutdown(task), MIGRATION_DELAY_IN_MS, TimeUnit.MILLISECONDS);</span>
        }

<span class="fc" id="L561">        return task;</span>
    }

    void announce(UUID schemaVersion)
    {
<span class="fc bfc" id="L566" title="All 2 branches covered.">        if (gossiper.isEnabled())</span>
<span class="fc" id="L567">            gossiper.addLocalApplicationState(ApplicationState.SCHEMA, StorageService.instance.valueFactory.schema(schemaVersion));</span>
<span class="fc" id="L568">        SchemaDiagnostics.versionAnnounced(Schema.instance);</span>
<span class="fc" id="L569">    }</span>

    private Future&lt;?&gt; submitToMigrationIfNotShutdown(Runnable task)
    {
<span class="fc" id="L573">        boolean skipped = false;</span>
        try
        {
<span class="pc bpc" id="L576" title="2 of 4 branches missed.">            if (executor.isShutdown() || executor.isTerminated())</span>
            {
<span class="nc" id="L578">                skipped = true;</span>
<span class="nc" id="L579">                return ImmediateFuture.success(null);</span>
            }
<span class="fc" id="L581">            return executor.submit(task);</span>
        }
<span class="nc" id="L583">        catch (RejectedExecutionException ex)</span>
        {
<span class="nc" id="L585">            skipped = true;</span>
<span class="nc" id="L586">            return ImmediateFuture.success(null);</span>
        }
        finally
        {
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">            if (skipped)</span>
            {
<span class="nc" id="L592">                logger.info(&quot;Skipped scheduled pulling schema from other nodes: the MIGRATION executor service has been shutdown.&quot;);</span>
            }
        }
    }

    private class Callback implements RequestCallback&lt;Collection&lt;Mutation&gt;&gt;
    {
        final InetAddressAndPort endpoint;
        final VersionInfo info;

        public Callback(InetAddressAndPort endpoint, VersionInfo info)
<span class="fc" id="L603">        {</span>
<span class="fc" id="L604">            this.endpoint = endpoint;</span>
<span class="fc" id="L605">            this.info = info;</span>
<span class="fc" id="L606">        }</span>

        public void onFailure(InetAddressAndPort from, RequestFailureReason failureReason)
        {
<span class="fc" id="L610">            fail();</span>
<span class="fc" id="L611">        }</span>

        Future&lt;Void&gt; fail()
        {
<span class="fc" id="L615">            return pullComplete(endpoint, info, false);</span>
        }

        public void onResponse(Message&lt;Collection&lt;Mutation&gt;&gt; message)
        {
<span class="fc" id="L620">            response(message.payload);</span>
<span class="fc" id="L621">        }</span>

        Future&lt;Void&gt; response(Collection&lt;Mutation&gt; mutations)
        {
<span class="fc" id="L625">            synchronized (info)</span>
            {
<span class="fc bfc" id="L627" title="All 2 branches covered.">                if (shouldApplySchemaFor(info))</span>
                {
                    try
                    {
<span class="fc" id="L631">                        schemaUpdateCallback.accept(endpoint, mutations);</span>
                    }
<span class="nc" id="L633">                    catch (Exception e)</span>
                    {
<span class="nc" id="L635">                        logger.error(String.format(&quot;Unable to merge schema from %s&quot;, endpoint), e);</span>
<span class="nc" id="L636">                        return fail();</span>
<span class="fc" id="L637">                    }</span>
                }
<span class="fc" id="L639">                return pullComplete(endpoint, info, true);</span>
            }
        }

        public boolean isLatencyForSnitch()
        {
<span class="nc" id="L645">            return false;</span>
        }
    }

    private void pullSchema(InetAddressAndPort endpoint, RequestCallback&lt;Collection&lt;Mutation&gt;&gt; callback)
    {
<span class="fc bfc" id="L651" title="All 2 branches covered.">        if (!gossiper.isAlive(endpoint))</span>
        {
<span class="fc" id="L653">            noSpamLogger.warn(&quot;Can't send schema pull request: node {} is down.&quot;, endpoint);</span>
<span class="fc" id="L654">            callback.onFailure(endpoint, RequestFailureReason.UNKNOWN);</span>
<span class="fc" id="L655">            return;</span>
        }

        // There is a chance that quite some time could have passed between now and the MM#maybeScheduleSchemaPull(),
        // potentially enough for the endpoint node to restart - which is an issue if it does restart upgraded, with
        // a higher major.
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">        if (!shouldPullFromEndpoint(endpoint))</span>
        {
<span class="nc" id="L663">            logger.info(&quot;Skipped sending a migration request: node {} has a higher major version now.&quot;, endpoint);</span>
<span class="nc" id="L664">            callback.onFailure(endpoint, RequestFailureReason.UNKNOWN);</span>
<span class="nc" id="L665">            return;</span>
        }

<span class="fc" id="L668">        logger.debug(&quot;Requesting schema from {}&quot;, endpoint);</span>
<span class="fc" id="L669">        sendMigrationMessage(endpoint, callback);</span>
<span class="fc" id="L670">    }</span>

    private void sendMigrationMessage(InetAddressAndPort endpoint, RequestCallback&lt;Collection&lt;Mutation&gt;&gt; callback)
    {
<span class="fc" id="L674">        Message&lt;NoPayload&gt; message = Message.out(Verb.SCHEMA_PULL_REQ, NoPayload.noPayload);</span>
<span class="fc" id="L675">        logger.info(&quot;Sending schema pull request to {}&quot;, endpoint);</span>
<span class="fc" id="L676">        messagingService.sendWithCallback(message, endpoint, callback);</span>
<span class="fc" id="L677">    }</span>

    private synchronized Future&lt;Void&gt; pullComplete(InetAddressAndPort endpoint, VersionInfo info, boolean wasSuccessful)
    {
<span class="fc bfc" id="L681" title="All 2 branches covered.">        if (wasSuccessful)</span>
<span class="fc" id="L682">            info.markReceived();</span>

<span class="fc" id="L684">        info.outstandingRequests.remove(endpoint);</span>
<span class="fc" id="L685">        info.requestQueue.add(endpoint);</span>
<span class="fc" id="L686">        return maybePullSchema(info);</span>
    }

    /**
     * Wait until we've received schema responses for all versions we're aware of
     * @param waitMillis
     * @return true if response for all schemas were received, false if we timed out waiting
     */
    boolean awaitSchemaRequests(long waitMillis)
    {
<span class="nc bnc" id="L696" title="All 2 branches missed.">        if (!FBUtilities.getBroadcastAddressAndPort().equals(InetAddressAndPort.getLoopbackAddress()))</span>
<span class="nc" id="L697">            Gossiper.waitToSettle();</span>

<span class="nc bnc" id="L699" title="All 2 branches missed.">        if (versionInfo.isEmpty())</span>
<span class="nc" id="L700">            logger.debug(&quot;Nothing in versionInfo - so no schemas to wait for&quot;);</span>

<span class="nc" id="L702">        List&lt;WaitQueue.Signal&gt; signalList = null;</span>
        try
        {
<span class="nc" id="L705">            synchronized (this)</span>
            {
<span class="nc" id="L707">                signalList = new ArrayList&lt;&gt;(versionInfo.size());</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">                for (VersionInfo version : versionInfo.values())</span>
                {
<span class="nc bnc" id="L710" title="All 2 branches missed.">                    if (version.wasReceived())</span>
<span class="nc" id="L711">                        continue;</span>

<span class="nc" id="L713">                    signalList.add(version.register());</span>
<span class="nc" id="L714">                }</span>

<span class="nc bnc" id="L716" title="All 2 branches missed.">                if (signalList.isEmpty())</span>
<span class="nc" id="L717">                    return true;</span>
<span class="nc" id="L718">            }</span>

<span class="nc" id="L720">            long deadline = nanoTime() + TimeUnit.MILLISECONDS.toNanos(waitMillis);</span>
<span class="nc" id="L721">            return signalList.stream().allMatch(signal -&gt; signal.awaitUntilUninterruptibly(deadline));</span>
        }
        finally
        {
<span class="nc bnc" id="L725" title="All 2 branches missed.">            if (signalList != null)</span>
<span class="nc" id="L726">                signalList.forEach(WaitQueue.Signal::cancel);</span>
        }
    }

    Pair&lt;Set&lt;InetAddressAndPort&gt;, Set&lt;InetAddressAndPort&gt;&gt; pushSchemaMutations(Collection&lt;Mutation&gt; schemaMutations)
    {
<span class="fc" id="L732">        logger.debug(&quot;Pushing schema mutations: {}&quot;, schemaMutations);</span>
<span class="fc" id="L733">        Set&lt;InetAddressAndPort&gt; schemaDestinationEndpoints = new HashSet&lt;&gt;();</span>
<span class="fc" id="L734">        Set&lt;InetAddressAndPort&gt; schemaEndpointsIgnored = new HashSet&lt;&gt;();</span>
<span class="fc" id="L735">        Message&lt;Collection&lt;Mutation&gt;&gt; message = Message.out(SCHEMA_PUSH_REQ, schemaMutations);</span>
<span class="fc bfc" id="L736" title="All 2 branches covered.">        for (InetAddressAndPort endpoint : gossiper.getLiveMembers())</span>
        {
<span class="fc bfc" id="L738" title="All 2 branches covered.">            if (shouldPushSchemaTo(endpoint))</span>
            {
<span class="fc" id="L740">                logger.debug(&quot;Pushing schema mutations to {}: {}&quot;, endpoint, schemaMutations);</span>
<span class="fc" id="L741">                messagingService.send(message, endpoint);</span>
<span class="fc" id="L742">                schemaDestinationEndpoints.add(endpoint);</span>
            }
            else
            {
<span class="fc" id="L746">                schemaEndpointsIgnored.add(endpoint);</span>
            }
<span class="fc" id="L748">        }</span>

<span class="fc" id="L750">        return Pair.create(schemaDestinationEndpoints, schemaEndpointsIgnored);</span>
    }

    private boolean shouldPushSchemaTo(InetAddressAndPort endpoint)
    {
        // only push schema to nodes with known and equal versions
<span class="fc bfc" id="L756" title="All 2 branches covered.">        return !endpoint.equals(FBUtilities.getBroadcastAddressAndPort())</span>
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">               &amp;&amp; messagingService.versions.knows(endpoint)</span>
<span class="pc bpc" id="L758" title="1 of 2 branches missed.">               &amp;&amp; messagingService.versions.getRaw(endpoint) == MessagingService.current_version;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>