<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RepairSession.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.repair</a> &gt; <span class="el_source">RepairSession.java</span></div><h1>RepairSession.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.repair;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.Executor;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.atomic.AtomicBoolean;

import javax.annotation.Nullable;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Lists;
import com.google.common.util.concurrent.*;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.concurrent.ExecutorPlus;
import org.apache.cassandra.concurrent.Stage;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.Keyspace;
import org.apache.cassandra.dht.Range;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.exceptions.RepairException;
import org.apache.cassandra.gms.*;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.net.Message;
import org.apache.cassandra.repair.consistent.ConsistentSession;
import org.apache.cassandra.repair.consistent.LocalSession;
import org.apache.cassandra.repair.consistent.LocalSessions;
import org.apache.cassandra.repair.messages.SyncResponse;
import org.apache.cassandra.repair.messages.ValidationResponse;
import org.apache.cassandra.repair.state.SessionState;
import org.apache.cassandra.schema.SystemDistributedKeyspace;
import org.apache.cassandra.schema.TableId;
import org.apache.cassandra.streaming.PreviewKind;
import org.apache.cassandra.tracing.Tracing;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.MerkleTrees;
import org.apache.cassandra.utils.Pair;
import org.apache.cassandra.utils.Throwables;
import org.apache.cassandra.utils.TimeUUID;
import org.apache.cassandra.utils.concurrent.AsyncFuture;

/**
 * Coordinates the (active) repair of a list of non overlapping token ranges.
 *
 * A given RepairSession repairs a set of replicas for a given set of ranges on a list
 * of column families. For each of the column family to repair, RepairSession
 * creates a {@link RepairJob} that handles the repair of that CF.
 *
 * A given RepairJob has the 3 main phases:
 * &lt;ol&gt;
 *   &lt;li&gt;
 *     Paxos repair: unfinished paxos operations in the range/keyspace/table are first completed
 *   &lt;/li&gt;
 *   &lt;li&gt;Validation phase: the job requests merkle trees from each of the replica involves
 *      ({@link org.apache.cassandra.repair.ValidationTask}) and waits until all trees are received (in
 *      validationComplete()).
 *   &lt;/li&gt;
 *   &lt;li&gt;Synchronization phase: once all trees are received, the job compares each tree with  all the others. If there is
 *       difference between 2 trees, the differences between the 2 endpoints will be streamed with a {@link SyncTask}.
 *   &lt;/li&gt;
 * &lt;/ol&gt;
 * The job is done once all its SyncTasks are done (i.e. have either computed no differences
 * or the streaming they started is done (syncComplete())).
 *
 * A given session will execute the first phase (validation phase) of each of it's job
 * sequentially. In other words, it will start the first job and only start the next one
 * once that first job validation phase is complete. This is done so that the replica only
 * create one merkle tree per range at a time, which is our way to ensure that such creation starts
 * roughly at the same time on every node (see CASSANDRA-2816). However the synchronization
 * phases are allowed to run concurrently (with each other and with validation phases).
 *
 * A given RepairJob has 2 modes: either sequential or not (RepairParallelism). If sequential,
 * it will requests merkle tree creation from each replica in sequence (though in that case
 * we still first send a message to each node to flush and snapshot data so each merkle tree
 * creation is still done on similar data, even if the actual creation is not
 * done simulatneously). If not sequential, all merkle tree are requested in parallel.
 * Similarly, if a job is sequential, it will handle one SymmetricSyncTask at a time, but will handle
 * all of them in parallel otherwise.
 */
public class RepairSession extends AsyncFuture&lt;RepairSessionResult&gt; implements IEndpointStateChangeSubscriber,
                                                                                  IFailureDetectionEventListener,
                                                                                  LocalSessions.Listener
{
<span class="fc" id="L113">    private static final Logger logger = LoggerFactory.getLogger(RepairSession.class);</span>

    public final SessionState state;
    public final RepairParallelism parallelismDegree;
    public final boolean pullRepair;

    /** Range to repair */
    public final boolean isIncremental;
    public final PreviewKind previewKind;
    public final boolean repairPaxos;
    public final boolean paxosOnly;

<span class="fc" id="L125">    private final AtomicBoolean isFailed = new AtomicBoolean(false);</span>

    // Each validation task waits response from replica in validating ConcurrentMap (keyed by CF name and endpoint address)
<span class="fc" id="L128">    private final ConcurrentMap&lt;Pair&lt;RepairJobDesc, InetAddressAndPort&gt;, ValidationTask&gt; validating = new ConcurrentHashMap&lt;&gt;();</span>
    // Remote syncing jobs wait response in syncingTasks map
<span class="fc" id="L130">    private final ConcurrentMap&lt;Pair&lt;RepairJobDesc, SyncNodePair&gt;, CompletableRemoteSyncTask&gt; syncingTasks = new ConcurrentHashMap&lt;&gt;();</span>

    // Tasks(snapshot, validate request, differencing, ...) are run on taskExecutor
    public final SafeExecutor taskExecutor;
    public final boolean optimiseStreams;
    public final SharedContext ctx;
<span class="fc" id="L136">    private volatile List&lt;RepairJob&gt; jobs = Collections.emptyList();</span>

<span class="fc" id="L138">    private volatile boolean terminated = false;</span>

    /**
     * Create new repair session.
     * @param parentRepairSession the parent sessions id
     * @param commonRange ranges to repair
     * @param keyspace name of keyspace
     * @param parallelismDegree specifies the degree of parallelism when calculating the merkle trees
     * @param pullRepair true if the repair should be one way (from remote host to this host and only applicable between two hosts--see RepairOption)
     * @param repairPaxos true if incomplete paxos operations should be completed as part of repair
     * @param paxosOnly true if we should only complete paxos operations, not run a normal repair
     * @param cfnames names of columnfamilies
     */
    public RepairSession(SharedContext ctx,
                         TimeUUID parentRepairSession,
                         CommonRange commonRange,
                         String keyspace,
                         RepairParallelism parallelismDegree,
                         boolean isIncremental,
                         boolean pullRepair,
                         PreviewKind previewKind,
                         boolean optimiseStreams,
                         boolean repairPaxos,
                         boolean paxosOnly,
                         String... cfnames)
<span class="fc" id="L163">    {</span>
<span class="fc" id="L164">        this.ctx = ctx;</span>
<span class="fc" id="L165">        this.repairPaxos = repairPaxos;</span>
<span class="fc" id="L166">        this.paxosOnly = paxosOnly;</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">        assert cfnames.length &gt; 0 : &quot;Repairing no column families seems pointless, doesn't it&quot;;</span>
<span class="fc" id="L168">        this.state = new SessionState(ctx.clock(), parentRepairSession, keyspace, cfnames, commonRange);</span>
<span class="fc" id="L169">        this.parallelismDegree = parallelismDegree;</span>
<span class="fc" id="L170">        this.isIncremental = isIncremental;</span>
<span class="fc" id="L171">        this.previewKind = previewKind;</span>
<span class="fc" id="L172">        this.pullRepair = pullRepair;</span>
<span class="fc" id="L173">        this.optimiseStreams = optimiseStreams;</span>
<span class="fc" id="L174">        this.taskExecutor = new SafeExecutor(createExecutor(ctx));</span>
<span class="fc" id="L175">    }</span>

    @VisibleForTesting
    protected ExecutorPlus createExecutor(SharedContext ctx)
    {
<span class="fc" id="L180">        return ctx.executorFactory().pooled(&quot;RepairJobTask&quot;, Integer.MAX_VALUE);</span>
    }

    public TimeUUID getId()
    {
<span class="fc" id="L185">        return state.id;</span>
    }

    public Collection&lt;Range&lt;Token&gt;&gt; ranges()
    {
<span class="fc" id="L190">        return state.commonRange.ranges;</span>
    }

    public Collection&lt;InetAddressAndPort&gt; endpoints()
    {
<span class="nc" id="L195">        return state.commonRange.endpoints;</span>
    }

    public synchronized void trackValidationCompletion(Pair&lt;RepairJobDesc, InetAddressAndPort&gt; key, ValidationTask task)
    {
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        if (terminated)</span>
        {
<span class="nc" id="L202">            task.abort(new RuntimeException(&quot;Session terminated&quot;));</span>
<span class="nc" id="L203">            return;</span>
        }
<span class="fc" id="L205">        validating.put(key, task);</span>
<span class="fc" id="L206">    }</span>

    public synchronized void trackSyncCompletion(Pair&lt;RepairJobDesc, SyncNodePair&gt; key, CompletableRemoteSyncTask task)
    {
<span class="nc bnc" id="L210" title="All 2 branches missed.">        if (terminated)</span>
<span class="nc" id="L211">            return;</span>
<span class="nc" id="L212">        syncingTasks.put(key, task);</span>
<span class="nc" id="L213">    }</span>

    /**
     * Receive merkle tree response or failed response from {@code endpoint} for current repair job.
     *
     * @param desc repair job description
     * @param message containing the merkle trees or an error
     */
    public void validationComplete(RepairJobDesc desc, Message&lt;ValidationResponse&gt; message)
    {
<span class="fc" id="L223">        InetAddressAndPort endpoint = message.from();</span>
<span class="fc" id="L224">        MerkleTrees trees = message.payload.trees;</span>
<span class="fc" id="L225">        ValidationTask task = validating.remove(Pair.create(desc, endpoint));</span>
        // replies without a callback get dropped, so if in mixed mode this should be ignored
<span class="fc" id="L227">        ctx.messaging().send(message.emptyResponse(), message.from());</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">        if (task == null)</span>
        {
            // The trees may be off-heap, and will therefore need to be released.
<span class="nc bnc" id="L231" title="All 2 branches missed.">            if (trees != null)</span>
<span class="nc" id="L232">                trees.release();</span>

            // either the session completed so the validation is no longer needed, or this is a retry; in both cases there is nothing to do
<span class="nc" id="L235">            return;</span>
        }

<span class="fc" id="L238">        String msg = String.format(&quot;Received merkle tree for %s from %s&quot;, desc.columnFamily, endpoint);</span>
<span class="fc" id="L239">        logger.info(&quot;{} {}&quot;, previewKind.logPrefix(getId()), msg);</span>
<span class="fc" id="L240">        Tracing.traceRepair(msg);</span>
<span class="fc" id="L241">        task.treesReceived(trees);</span>
<span class="fc" id="L242">    }</span>

    /**
     * Notify this session that sync completed/failed with given {@code SyncNodePair}.
     *
     * @param desc synced repair job
     * @param message nodes that completed sync and if they were successful
     */
    public void syncComplete(RepairJobDesc desc, Message&lt;SyncResponse&gt; message)
    {
<span class="nc" id="L252">        SyncNodePair nodes = message.payload.nodes;</span>
<span class="nc" id="L253">        CompletableRemoteSyncTask task = syncingTasks.remove(Pair.create(desc, nodes));</span>
        // replies without a callback get dropped, so if in mixed mode this should be ignored
<span class="nc" id="L255">        ctx.messaging().send(message.emptyResponse(), message.from());</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">        if (task == null)</span>
<span class="nc" id="L257">            return;</span>

<span class="nc bnc" id="L259" title="All 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="nc" id="L260">            logger.debug(&quot;{} Repair completed between {} and {} on {}&quot;, previewKind.logPrefix(getId()), nodes.coordinator, nodes.peer, desc.columnFamily);</span>
<span class="nc" id="L261">        task.syncComplete(message.payload.success, message.payload.summaries);</span>
<span class="nc" id="L262">    }</span>

    @VisibleForTesting
    Map&lt;Pair&lt;RepairJobDesc, SyncNodePair&gt;, CompletableRemoteSyncTask&gt; getSyncingTasks()
    {
<span class="nc" id="L267">        return Collections.unmodifiableMap(syncingTasks);</span>
    }

    private String repairedNodes()
    {
<span class="fc" id="L272">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L273">        sb.append(FBUtilities.getBroadcastAddressAndPort());</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">        for (InetAddressAndPort ep : state.commonRange.endpoints)</span>
<span class="fc" id="L275">            sb.append(&quot;, &quot;).append(ep);</span>
<span class="fc" id="L276">        return sb.toString();</span>
    }

    /**
     * Start RepairJob on given ColumnFamilies.
     *
     * This first validates if all replica are available, and if they are,
     * creates RepairJobs and submit to run on given executor.
     *
     * @param executor Executor to run validation
     */
    public void start(ExecutorPlus executor)
    {
<span class="fc" id="L289">        state.phase.start();</span>
        String message;
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">        if (terminated)</span>
<span class="nc" id="L292">            return;</span>

<span class="fc" id="L294">        logger.info(&quot;{} parentSessionId = {}: new session: will sync {} on range {} for {}.{}&quot;,</span>
<span class="fc" id="L295">                    previewKind.logPrefix(getId()), state.parentRepairSession, repairedNodes(), state.commonRange, state.keyspace, Arrays.toString(state.cfnames));</span>
<span class="fc" id="L296">        Tracing.traceRepair(&quot;Syncing range {}&quot;, state.commonRange);</span>
<span class="pc bpc" id="L297" title="2 of 4 branches missed.">        if (!previewKind.isPreview() &amp;&amp; !paxosOnly)</span>
        {
<span class="fc" id="L299">            SystemDistributedKeyspace.startRepairs(getId(), state.parentRepairSession, state.keyspace, state.cfnames, state.commonRange);</span>
        }

<span class="pc bpc" id="L302" title="1 of 2 branches missed.">        if (state.commonRange.endpoints.isEmpty())</span>
        {
<span class="nc" id="L304">            logger.info(&quot;{} {}&quot;, previewKind.logPrefix(getId()), message = String.format(&quot;No neighbors to repair with on range %s: session completed&quot;, state.commonRange));</span>
<span class="nc" id="L305">            state.phase.skip(message);</span>
<span class="nc" id="L306">            Tracing.traceRepair(message);</span>
<span class="nc" id="L307">            trySuccess(new RepairSessionResult(state.id, state.keyspace, state.commonRange.ranges, Lists.&lt;RepairResult&gt;newArrayList(), state.commonRange.hasSkippedReplicas));</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">            if (!previewKind.isPreview())</span>
            {
<span class="nc" id="L310">                SystemDistributedKeyspace.failRepairs(getId(), state.keyspace, state.cfnames, new RuntimeException(message));</span>
            }
<span class="nc" id="L312">            return;</span>
        }

        // Checking all nodes are live
<span class="fc bfc" id="L316" title="All 2 branches covered.">        for (InetAddressAndPort endpoint : state.commonRange.endpoints)</span>
        {
<span class="pc bpc" id="L318" title="3 of 4 branches missed.">            if (!ctx.failureDetector().isAlive(endpoint) &amp;&amp; !state.commonRange.hasSkippedReplicas)</span>
            {
<span class="nc" id="L320">                message = String.format(&quot;Cannot proceed on repair because a neighbor (%s) is dead: session failed&quot;, endpoint);</span>
<span class="nc" id="L321">                state.phase.fail(message);</span>
<span class="nc" id="L322">                logger.error(&quot;{} {}&quot;, previewKind.logPrefix(getId()), message);</span>
<span class="nc" id="L323">                Exception e = new IOException(message);</span>
<span class="nc" id="L324">                tryFailure(e);</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">                if (!previewKind.isPreview())</span>
                {
<span class="nc" id="L327">                    SystemDistributedKeyspace.failRepairs(getId(), state.keyspace, state.cfnames, e);</span>
                }
<span class="nc" id="L329">                return;</span>
            }
<span class="fc" id="L331">        }</span>

        // Create and submit RepairJob for each ColumnFamily
<span class="fc" id="L334">        state.phase.jobsSubmitted();</span>
<span class="fc" id="L335">        List&lt;RepairJob&gt; jobs = new ArrayList&lt;&gt;(state.cfnames.length);</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">        for (String cfname : state.cfnames)</span>
        {
<span class="fc" id="L338">            RepairJob job = new RepairJob(this, cfname);</span>
<span class="fc" id="L339">            state.register(job.state);</span>
<span class="fc" id="L340">            executor.execute(job);</span>
<span class="fc" id="L341">            jobs.add(job);</span>
        }
<span class="fc" id="L343">        this.jobs = jobs;</span>

        // When all RepairJobs are done without error, cleanup and set the final result
<span class="fc" id="L346">        FBUtilities.allOf(jobs).addCallback(new FutureCallback&lt;List&lt;RepairResult&gt;&gt;()</span>
<span class="fc" id="L347">        {</span>
            public void onSuccess(List&lt;RepairResult&gt; results)
            {
<span class="fc" id="L350">                state.phase.success();</span>
                // this repair session is completed
<span class="fc" id="L352">                logger.info(&quot;{} {}&quot;, previewKind.logPrefix(getId()), &quot;Session completed successfully&quot;);</span>
<span class="fc" id="L353">                Tracing.traceRepair(&quot;Completed sync of range {}&quot;, state.commonRange);</span>
<span class="fc" id="L354">                trySuccess(new RepairSessionResult(state.id, state.keyspace, state.commonRange.ranges, results, state.commonRange.hasSkippedReplicas));</span>

                // mark this session as terminated
<span class="fc" id="L357">                terminate(null);</span>
<span class="fc" id="L358">                taskExecutor.shutdown();</span>
<span class="fc" id="L359">            }</span>

            public void onFailure(Throwable t)
            {
<span class="nc" id="L363">                state.phase.fail(t);</span>
<span class="nc" id="L364">                String msg = &quot;{} Session completed with the following error&quot;;</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">                if (Throwables.anyCauseMatches(t, RepairException::shouldWarn))</span>
<span class="nc" id="L366">                    logger.warn(msg+ &quot;: {}&quot;, previewKind.logPrefix(getId()), t.getMessage());</span>
                else
<span class="nc" id="L368">                    logger.error(msg, previewKind.logPrefix(getId()), t);</span>
<span class="nc" id="L369">                Tracing.traceRepair(&quot;Session completed with the following error: {}&quot;, t);</span>
<span class="nc" id="L370">                forceShutdown(t);</span>
<span class="nc" id="L371">            }</span>
        }, taskExecutor);
<span class="fc" id="L373">    }</span>

    public synchronized void terminate(@Nullable Throwable reason)
    {
<span class="fc" id="L377">        terminated = true;</span>
<span class="fc" id="L378">        List&lt;RepairJob&gt; jobs = this.jobs;</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">        if (jobs != null)</span>
        {
<span class="fc bfc" id="L381" title="All 2 branches covered.">            for (RepairJob job : jobs)</span>
<span class="fc" id="L382">                job.abort(reason);</span>
        }
<span class="fc" id="L384">        this.jobs = null;</span>
<span class="fc" id="L385">        validating.clear();</span>
<span class="fc" id="L386">        syncingTasks.clear();</span>
<span class="fc" id="L387">    }</span>

    /**
     * clear all RepairJobs and terminate this session.
     *
     * @param reason Cause of error for shutdown
     */
    public void forceShutdown(Throwable reason)
    {
<span class="nc" id="L396">        tryFailure(reason);</span>
<span class="nc" id="L397">        terminate(reason);</span>
<span class="nc" id="L398">        taskExecutor.shutdown();</span>
<span class="nc" id="L399">    }</span>
    public void onRemove(InetAddressAndPort endpoint)
    {
<span class="nc" id="L402">        convict(endpoint, Double.MAX_VALUE);</span>
<span class="nc" id="L403">    }</span>

    public void onRestart(InetAddressAndPort endpoint, EndpointState epState)
    {
<span class="nc" id="L407">        convict(endpoint, Double.MAX_VALUE);</span>
<span class="nc" id="L408">    }</span>

    public void convict(InetAddressAndPort endpoint, double phi)
    {
<span class="nc bnc" id="L412" title="All 2 branches missed.">        if (!state.commonRange.endpoints.contains(endpoint))</span>
<span class="nc" id="L413">            return;</span>

        // We want a higher confidence in the failure detection than usual because failing a repair wrongly has a high cost.
<span class="nc bnc" id="L416" title="All 2 branches missed.">        if (phi &lt; 2 * DatabaseDescriptor.getPhiConvictThreshold())</span>
<span class="nc" id="L417">            return;</span>

        // Though unlikely, it is possible to arrive here multiple time and we
        // want to avoid print an error message twice
<span class="nc bnc" id="L421" title="All 2 branches missed.">        if (!isFailed.compareAndSet(false, true))</span>
<span class="nc" id="L422">            return;</span>

<span class="nc" id="L424">        Exception exception = new IOException(String.format(&quot;Endpoint %s died&quot;, endpoint));</span>
<span class="nc" id="L425">        logger.error(&quot;{} session completed with the following error&quot;, previewKind.logPrefix(getId()), exception);</span>
        // If a node failed, we stop everything (though there could still be some activity in the background)
<span class="nc" id="L427">        forceShutdown(exception);</span>
<span class="nc" id="L428">    }</span>

    public void onIRStateChange(LocalSession session)
    {
        // we should only be registered as listeners for PreviewKind.REPAIRED, but double check here
<span class="nc bnc" id="L433" title="All 2 branches missed.">        if (previewKind == PreviewKind.REPAIRED &amp;&amp;</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">            session.getState() == ConsistentSession.State.FINALIZED &amp;&amp;</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">            includesTables(session.tableIds))</span>
        {
<span class="nc bnc" id="L437" title="All 2 branches missed.">            for (Range&lt;Token&gt; range : session.ranges)</span>
            {
<span class="nc bnc" id="L439" title="All 2 branches missed.">                if (range.intersects(ranges()))</span>
                {
<span class="nc" id="L441">                    logger.warn(&quot;{} An intersecting incremental repair with session id = {} finished, preview repair might not be accurate&quot;, previewKind.logPrefix(getId()), session.sessionID);</span>
<span class="nc" id="L442">                    forceShutdown(RepairException.warn(&quot;An incremental repair with session id &quot;+session.sessionID+&quot; finished during this preview repair runtime&quot;));</span>
<span class="nc" id="L443">                    return;</span>
                }
<span class="nc" id="L445">            }</span>
        }
<span class="nc" id="L447">    }</span>

    private boolean includesTables(Set&lt;TableId&gt; tableIds)
    {
<span class="nc" id="L451">        Keyspace ks = Keyspace.open(state.keyspace);</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">        if (ks != null)</span>
        {
<span class="nc bnc" id="L454" title="All 2 branches missed.">            for (String table : state.cfnames)</span>
            {
<span class="nc" id="L456">                ColumnFamilyStore cfs = ks.getColumnFamilyStore(table);</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">                if (tableIds.contains(cfs.metadata.id))</span>
<span class="nc" id="L458">                    return true;</span>
            }
        }
<span class="nc" id="L461">        return false;</span>
    }

    private static class SafeExecutor implements Executor
    {
        private final ExecutorPlus delegate;

        private SafeExecutor(ExecutorPlus delegate)
<span class="fc" id="L469">        {</span>
<span class="fc" id="L470">            this.delegate = delegate;</span>
<span class="fc" id="L471">        }</span>

        @Override
        public void execute(Runnable command)
        {
            try
            {
<span class="fc" id="L478">                delegate.execute(command);</span>
            }
<span class="nc" id="L480">            catch (RejectedExecutionException e)</span>
            {
                // task executor was shutdown, so fall back to a known good executor to finish callbacks
<span class="nc" id="L483">                Stage.INTERNAL_RESPONSE.execute(command);</span>
<span class="fc" id="L484">            }</span>
<span class="fc" id="L485">        }</span>

        public void shutdown()
        {
<span class="fc" id="L489">            delegate.shutdown();</span>
<span class="fc" id="L490">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>