<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EndpointState.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.gms</a> &gt; <span class="el_source">EndpointState.java</span></div><h1>EndpointState.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.gms;

import java.io.*;
import java.util.*;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;

import javax.annotation.Nullable;

import com.google.common.annotations.VisibleForTesting;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.config.CassandraRelevantProperties;
import org.apache.cassandra.db.TypeSizes;
import org.apache.cassandra.io.IVersionedSerializer;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.utils.CassandraVersion;
import org.apache.cassandra.utils.NullableSerializer;

import static org.apache.cassandra.utils.Clock.Global.nanoTime;

/**
 * This abstraction represents both the HeartBeatState and the ApplicationState in an EndpointState
 * instance. Any state for a given endpoint can be retrieved from this instance.
 */
public class EndpointState
{
<span class="fc" id="L48">    protected static final Logger logger = LoggerFactory.getLogger(EndpointState.class);</span>

<span class="fc" id="L50">    static volatile boolean LOOSE_DEF_OF_EMPTY_ENABLED = CassandraRelevantProperties.LOOSE_DEF_OF_EMPTY_ENABLED.getBoolean();</span>

<span class="fc" id="L52">    public final static IVersionedSerializer&lt;EndpointState&gt; serializer = new EndpointStateSerializer();</span>
<span class="fc" id="L53">    public final static IVersionedSerializer&lt;EndpointState&gt; nullableSerializer = NullableSerializer.wrap(serializer);</span>

    private volatile HeartBeatState hbState;
    private final AtomicReference&lt;Map&lt;ApplicationState, VersionedValue&gt;&gt; applicationState;

    /* fields below do not get serialized */
    private volatile long updateTimestamp;
    private volatile boolean isAlive;

    public EndpointState(HeartBeatState initialHbState)
    {
<span class="fc" id="L64">        this(initialHbState, new EnumMap&lt;ApplicationState, VersionedValue&gt;(ApplicationState.class));</span>
<span class="fc" id="L65">    }</span>

    public EndpointState(EndpointState other)
    {
<span class="fc" id="L69">        this(new HeartBeatState(other.hbState), new EnumMap&lt;&gt;(other.applicationState.get()));</span>
<span class="fc" id="L70">    }</span>

    EndpointState(HeartBeatState initialHbState, Map&lt;ApplicationState, VersionedValue&gt; states)
<span class="fc" id="L73">    {</span>
<span class="fc" id="L74">        hbState = initialHbState;</span>
<span class="fc" id="L75">        applicationState = new AtomicReference&lt;Map&lt;ApplicationState, VersionedValue&gt;&gt;(new EnumMap&lt;&gt;(states));</span>
<span class="fc" id="L76">        updateTimestamp = nanoTime();</span>
<span class="fc" id="L77">        isAlive = true;</span>
<span class="fc" id="L78">    }</span>

    @VisibleForTesting
    public HeartBeatState getHeartBeatState()
    {
<span class="fc" id="L83">        return hbState;</span>
    }

    void setHeartBeatState(HeartBeatState newHbState)
    {
<span class="fc" id="L88">        updateTimestamp();</span>
<span class="fc" id="L89">        hbState = newHbState;</span>
<span class="fc" id="L90">    }</span>

    public VersionedValue getApplicationState(ApplicationState key)
    {
<span class="fc" id="L94">        return applicationState.get().get(key);</span>
    }

    public boolean containsApplicationState(ApplicationState key)
    {
<span class="fc" id="L99">        return applicationState.get().containsKey(key);</span>
    }

    public Set&lt;Map.Entry&lt;ApplicationState, VersionedValue&gt;&gt; states()
    {
<span class="fc" id="L104">        return applicationState.get().entrySet();</span>
    }

    public void addApplicationState(ApplicationState key, VersionedValue value)
    {
<span class="fc" id="L109">        addApplicationStates(Collections.singletonMap(key, value));</span>
<span class="fc" id="L110">    }</span>

    public void addApplicationStates(Map&lt;ApplicationState, VersionedValue&gt; values)
    {
<span class="fc" id="L114">        addApplicationStates(values.entrySet());</span>
<span class="fc" id="L115">    }</span>

    public void addApplicationStates(Set&lt;Map.Entry&lt;ApplicationState, VersionedValue&gt;&gt; values)
    {
        while (true)
        {
<span class="fc" id="L121">            Map&lt;ApplicationState, VersionedValue&gt; orig = applicationState.get();</span>
<span class="fc" id="L122">            Map&lt;ApplicationState, VersionedValue&gt; copy = new EnumMap&lt;&gt;(orig);</span>

<span class="fc bfc" id="L124" title="All 2 branches covered.">            for (Map.Entry&lt;ApplicationState, VersionedValue&gt; value : values)</span>
<span class="fc" id="L125">                copy.put(value.getKey(), value.getValue());</span>

<span class="pc bpc" id="L127" title="1 of 2 branches missed.">            if (applicationState.compareAndSet(orig, copy))</span>
<span class="fc" id="L128">                return;</span>
<span class="nc" id="L129">        }</span>
    }

    void removeMajorVersion3LegacyApplicationStates()
    {
<span class="fc bfc" id="L134" title="All 2 branches covered.">        while (hasLegacyFields())</span>
        {
<span class="fc" id="L136">            Map&lt;ApplicationState, VersionedValue&gt; orig = applicationState.get();</span>
<span class="fc" id="L137">            Map&lt;ApplicationState, VersionedValue&gt; updatedStates = filterMajorVersion3LegacyApplicationStates(orig);</span>
            // avoid updating if no state is removed
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">            if (orig.size() == updatedStates.size()</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">                || applicationState.compareAndSet(orig, updatedStates))</span>
<span class="fc" id="L141">                return;</span>
<span class="nc" id="L142">        }</span>
<span class="fc" id="L143">    }</span>

    private boolean hasLegacyFields()
    {
<span class="fc" id="L147">        Set&lt;ApplicationState&gt; statesPresent = applicationState.get().keySet();</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">        if (statesPresent.isEmpty())</span>
<span class="fc" id="L149">            return false;</span>
<span class="fc bfc" id="L150" title="All 4 branches covered.">        return (statesPresent.contains(ApplicationState.STATUS) &amp;&amp; statesPresent.contains(ApplicationState.STATUS_WITH_PORT))</span>
<span class="pc bpc" id="L151" title="1 of 4 branches missed.">               || (statesPresent.contains(ApplicationState.INTERNAL_IP) &amp;&amp; statesPresent.contains(ApplicationState.INTERNAL_ADDRESS_AND_PORT))</span>
<span class="pc bpc" id="L152" title="3 of 4 branches missed.">               || (statesPresent.contains(ApplicationState.RPC_ADDRESS) &amp;&amp; statesPresent.contains(ApplicationState.NATIVE_ADDRESS_AND_PORT));</span>
    }

    private static Map&lt;ApplicationState, VersionedValue&gt; filterMajorVersion3LegacyApplicationStates(Map&lt;ApplicationState, VersionedValue&gt; states)
    {
<span class="fc" id="L157">        return states.entrySet().stream().filter(entry -&gt; {</span>
                // Filter out pre-4.0 versions of data for more complete 4.0 versions
<span class="fc bfc" id="L159" title="All 4 branches covered.">                switch (entry.getKey())</span>
                {
                    case INTERNAL_IP:
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">                        return !states.containsKey(ApplicationState.INTERNAL_ADDRESS_AND_PORT);</span>
                    case STATUS:
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">                        return !states.containsKey(ApplicationState.STATUS_WITH_PORT);</span>
                    case RPC_ADDRESS:
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">                        return !states.containsKey(ApplicationState.NATIVE_ADDRESS_AND_PORT);</span>
                    default:
<span class="fc" id="L168">                        return true;</span>
                }
<span class="fc" id="L170">            }).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</span>
    }

    /* getters and setters */
    /**
     * @return System.nanoTime() when state was updated last time.
     */
    public long getUpdateTimestamp()
    {
<span class="nc" id="L179">        return updateTimestamp;</span>
    }

    void updateTimestamp()
    {
<span class="fc" id="L184">        updateTimestamp = nanoTime();</span>
<span class="fc" id="L185">    }</span>

    @VisibleForTesting
    public void unsafeSetUpdateTimestamp(long value)
    {
<span class="nc" id="L190">        updateTimestamp = value;</span>
<span class="nc" id="L191">    }</span>

    public boolean isAlive()
    {
<span class="fc" id="L195">        return isAlive;</span>
    }

    @VisibleForTesting
    public void markAlive()
    {
<span class="fc" id="L201">        isAlive = true;</span>
<span class="fc" id="L202">    }</span>

    @VisibleForTesting
    public void markDead()
    {
<span class="fc" id="L207">        isAlive = false;</span>
<span class="fc" id="L208">    }</span>

    /**
     * @return true if {@link HeartBeatState#isEmpty()} is true and no STATUS application state exists
     */
    public boolean isEmptyWithoutStatus()
    {
<span class="fc" id="L215">        Map&lt;ApplicationState, VersionedValue&gt; state = applicationState.get();</span>
<span class="pc bpc" id="L216" title="3 of 4 branches missed.">        boolean hasStatus = state.containsKey(ApplicationState.STATUS_WITH_PORT) || state.containsKey(ApplicationState.STATUS);</span>
<span class="pc bpc" id="L217" title="6 of 8 branches missed.">        return hbState.isEmpty() &amp;&amp; !hasStatus</span>
               // In the very specific case where hbState.isEmpty and STATUS is missing, this is known to be safe to &quot;fake&quot;
               // the data, as this happens when the gossip state isn't coming from the node but instead from a peer who
               // restarted and is missing the node's state.
               //
               // When hbState is not empty, then the node gossiped an empty STATUS; this happens during bootstrap and it's not
               // possible to tell if this is ok or not (we can't really tell if the node is dead or having networking issues).
               // For these cases allow an external actor to verify and inform Cassandra that it is safe - this is done by
               // updating the LOOSE_DEF_OF_EMPTY_ENABLED field.
               || (LOOSE_DEF_OF_EMPTY_ENABLED &amp;&amp; !hasStatus);
    }

    public boolean isRpcReady()
    {
<span class="fc" id="L231">        VersionedValue rpcState = getApplicationState(ApplicationState.RPC_READY);</span>
<span class="fc bfc" id="L232" title="All 4 branches covered.">        return rpcState != null &amp;&amp; Boolean.parseBoolean(rpcState.value);</span>
    }

    public boolean isNormalState()
    {
<span class="nc" id="L237">        return getStatus().equals(VersionedValue.STATUS_NORMAL);</span>
    }

    public String getStatus()
    {
<span class="fc" id="L242">        VersionedValue status = getApplicationState(ApplicationState.STATUS_WITH_PORT);</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">        if (status == null)</span>
        {
<span class="fc" id="L245">            status = getApplicationState(ApplicationState.STATUS);</span>
        }
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">        if (status == null)</span>
        {
<span class="nc" id="L249">            return &quot;&quot;;</span>
        }

<span class="fc" id="L252">        String[] pieces = status.value.split(VersionedValue.DELIMITER_STR, -1);</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">        assert (pieces.length &gt; 0);</span>
<span class="fc" id="L254">        return pieces[0];</span>
    }

    @Nullable
    public UUID getSchemaVersion()
    {
<span class="nc" id="L260">        VersionedValue applicationState = getApplicationState(ApplicationState.SCHEMA);</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">        return applicationState != null</span>
<span class="nc" id="L262">               ? UUID.fromString(applicationState.value)</span>
<span class="nc" id="L263">               : null;</span>
    }

    @Nullable
    public CassandraVersion getReleaseVersion()
    {
<span class="fc" id="L269">        VersionedValue applicationState = getApplicationState(ApplicationState.RELEASE_VERSION);</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">        return applicationState != null</span>
<span class="fc" id="L271">               ? new CassandraVersion(applicationState.value)</span>
<span class="fc" id="L272">               : null;</span>
    }

    public String toString()
    {
<span class="fc" id="L277">        return &quot;EndpointState: HeartBeatState = &quot; + hbState + &quot;, AppStateMap = &quot; + applicationState.get();</span>
    }

    public boolean isSupersededBy(EndpointState that)
    {
<span class="nc" id="L282">        int thisGeneration = this.getHeartBeatState().getGeneration();</span>
<span class="nc" id="L283">        int thatGeneration = that.getHeartBeatState().getGeneration();</span>

<span class="nc bnc" id="L285" title="All 2 branches missed.">        if (thatGeneration &gt; thisGeneration)</span>
<span class="nc" id="L286">            return true;</span>

<span class="nc bnc" id="L288" title="All 2 branches missed.">        if (thisGeneration &gt; thatGeneration)</span>
<span class="nc" id="L289">            return false;</span>

<span class="nc bnc" id="L291" title="All 2 branches missed.">        return Gossiper.getMaxEndpointStateVersion(that) &gt; Gossiper.getMaxEndpointStateVersion(this);</span>
    }
}

<span class="fc" id="L295">class EndpointStateSerializer implements IVersionedSerializer&lt;EndpointState&gt;</span>
{
    public void serialize(EndpointState epState, DataOutputPlus out, int version) throws IOException
    {
        /* serialize the HeartBeatState */
<span class="fc" id="L300">        HeartBeatState hbState = epState.getHeartBeatState();</span>
<span class="fc" id="L301">        HeartBeatState.serializer.serialize(hbState, out, version);</span>

        /* serialize the map of ApplicationState objects */
<span class="fc" id="L304">        Set&lt;Map.Entry&lt;ApplicationState, VersionedValue&gt;&gt; states = epState.states();</span>
<span class="fc" id="L305">        out.writeInt(states.size());</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">        for (Map.Entry&lt;ApplicationState, VersionedValue&gt; state : states)</span>
        {
<span class="fc" id="L308">            VersionedValue value = state.getValue();</span>
<span class="fc" id="L309">            out.writeInt(state.getKey().ordinal());</span>
<span class="fc" id="L310">            VersionedValue.serializer.serialize(value, out, version);</span>
<span class="fc" id="L311">        }</span>
<span class="fc" id="L312">    }</span>

    public EndpointState deserialize(DataInputPlus in, int version) throws IOException
    {
<span class="fc" id="L316">        HeartBeatState hbState = HeartBeatState.serializer.deserialize(in, version);</span>

<span class="fc" id="L318">        int appStateSize = in.readInt();</span>
<span class="fc" id="L319">        Map&lt;ApplicationState, VersionedValue&gt; states = new EnumMap&lt;&gt;(ApplicationState.class);</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">        for (int i = 0; i &lt; appStateSize; ++i)</span>
        {
<span class="fc" id="L322">            int key = in.readInt();</span>
<span class="fc" id="L323">            VersionedValue value = VersionedValue.serializer.deserialize(in, version);</span>
<span class="fc" id="L324">            states.put(Gossiper.STATES[key], value);</span>
        }

<span class="fc" id="L327">        return new EndpointState(hbState, states);</span>
    }

    public long serializedSize(EndpointState epState, int version)
    {
<span class="fc" id="L332">        long size = HeartBeatState.serializer.serializedSize(epState.getHeartBeatState(), version);</span>
<span class="fc" id="L333">        Set&lt;Map.Entry&lt;ApplicationState, VersionedValue&gt;&gt; states = epState.states();</span>
<span class="fc" id="L334">        size += TypeSizes.sizeof(states.size());</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">        for (Map.Entry&lt;ApplicationState, VersionedValue&gt; state : states)</span>
        {
<span class="fc" id="L337">            VersionedValue value = state.getValue();</span>
<span class="fc" id="L338">            size += TypeSizes.sizeof(state.getKey().ordinal());</span>
<span class="fc" id="L339">            size += VersionedValue.serializer.serializedSize(value, version);</span>
<span class="fc" id="L340">        }</span>
<span class="fc" id="L341">        return size;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>