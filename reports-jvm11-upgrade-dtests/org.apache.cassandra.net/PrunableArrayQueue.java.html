<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PrunableArrayQueue.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.net</a> &gt; <span class="el_source">PrunableArrayQueue.java</span></div><h1>PrunableArrayQueue.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.net;

import java.util.function.Predicate;

import org.apache.cassandra.utils.Throwables;

/**
 * A growing array-based queue that allows efficient bulk in-place removal.
 *
 * Can think of this queue as if it were an {@link java.util.ArrayDeque} with {@link #prune(Pruner)} method - an efficient
 * way to prune the queue in-place that is more expressive, and faster than {@link java.util.ArrayDeque#removeIf(Predicate)}.
 *
 * The latter has to perform O(n*n) shifts, whereas {@link #prune(Pruner)} only needs O(n) shifts at worst.
 */
<span class="fc" id="L32">final class PrunableArrayQueue&lt;E&gt;</span>
{
    public interface Pruner&lt;E&gt;
    {
        /**
         * @return whether the element should be pruned
         *  if {@code true},  the element will be removed from the queue, and {@link #onPruned(Object)} will be invoked,
         *  if {@code false}, the element will be kept, and {@link #onKept(Object)} will be invoked.
         */
        boolean shouldPrune(E e);

        void onPruned(E e);
        void onKept(E e);
    }

    private int capacity;
    private E[] buffer;

    /*
     * mask = capacity - 1;
     * since capacity is a power of 2, value % capacity == value &amp; (capacity - 1) == value &amp; mask
     */
    private int mask;

<span class="fc" id="L56">    private int head = 0;</span>
<span class="fc" id="L57">    private int tail = 0;</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    PrunableArrayQueue(int requestedCapacity)
<span class="fc" id="L61">    {</span>
<span class="fc" id="L62">        capacity = Math.max(8, findNextPositivePowerOfTwo(requestedCapacity));</span>
<span class="fc" id="L63">        mask = capacity - 1;</span>
<span class="fc" id="L64">        buffer = (E[]) new Object[capacity];</span>
<span class="fc" id="L65">    }</span>

    @SuppressWarnings(&quot;UnusedReturnValue&quot;)
    boolean offer(E e)
    {
<span class="fc" id="L70">        buffer[tail] = e;</span>
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">        if ((tail = (tail + 1) &amp; mask) == head)</span>
<span class="nc" id="L72">            doubleCapacity();</span>
<span class="fc" id="L73">        return true;</span>
    }

    E peek()
    {
<span class="fc" id="L78">        return buffer[head];</span>
    }

    E poll()
    {
<span class="fc" id="L83">        E result = buffer[head];</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">        if (null == result)</span>
<span class="fc" id="L85">            return null;</span>

<span class="fc" id="L87">        buffer[head] = null;</span>
<span class="fc" id="L88">        head = (head + 1) &amp; mask;</span>

<span class="fc" id="L90">        return result;</span>
    }

    int size()
    {
<span class="fc" id="L95">        return (tail - head) &amp; mask;</span>
    }

    boolean isEmpty()
    {
<span class="nc bnc" id="L100" title="All 2 branches missed.">        return head == tail;</span>
    }

    /**
     * Prunes the queue using the specified {@link Pruner}
     *
     * @return count of removed elements.
     */
    @SuppressWarnings(&quot;ThrowFromFinallyBlock&quot;)
    int prune(Pruner&lt;E&gt; pruner)
    {
        E e;
<span class="fc" id="L112">        int removed = 0;</span>
<span class="fc" id="L113">        Throwable error = null;</span>

        try
        {
<span class="fc" id="L117">            int size = size();</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++)</span>
            {
                /*
                 * We start at the tail and work backwards to minimise the number of copies
                 * as we expect to primarily prune from the front.
                 */
<span class="fc" id="L124">                int k = (tail - 1 - i) &amp; mask;</span>
<span class="fc" id="L125">                e = buffer[k];</span>

<span class="fc" id="L127">                boolean shouldPrune = false;</span>

                // If any error has been thrown from the Pruner callbacks, don't bother asking the
                // pruner. Just move any elements that need to be moved, correct the head, and rethrow.
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">                if (error == null)</span>
                {
                    try
                    {
<span class="fc" id="L135">                        shouldPrune = pruner.shouldPrune(e);</span>
                    }
<span class="nc" id="L137">                    catch (Throwable t)</span>
                    {
<span class="nc" id="L139">                        error = t;</span>
<span class="fc" id="L140">                    }</span>
                }

<span class="pc bpc" id="L143" title="1 of 2 branches missed.">                if (shouldPrune)</span>
                {
<span class="nc" id="L145">                    buffer[k] = null;</span>
<span class="nc" id="L146">                    removed++;</span>

                    try
                    {
<span class="nc" id="L150">                        pruner.onPruned(e);</span>
                    }
<span class="nc" id="L152">                    catch (Throwable t)</span>
                    {
<span class="nc" id="L154">                        error = t;</span>
<span class="nc" id="L155">                    }</span>
                }
                else
                {
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">                    if (removed &gt; 0)</span>
                    {
<span class="nc" id="L161">                        buffer[(k + removed) &amp; mask] = e;</span>
<span class="nc" id="L162">                        buffer[k] = null;</span>
                    }

                    try
                    {
<span class="fc" id="L167">                        pruner.onKept(e);</span>
                    }
<span class="nc" id="L169">                    catch (Throwable t)</span>
                    {
<span class="nc bnc" id="L171" title="All 2 branches missed.">                        if (error == null)</span>
                        {
<span class="nc" id="L173">                            error = t;</span>
                        }
<span class="fc" id="L175">                    }</span>
                }
            }
        }
        finally
        {
<span class="fc" id="L181">            head = (head + removed) &amp; mask;</span>

            // Rethrow any error(s) from the Pruner callbacks, but only after the queue state is valid.
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">            if (error != null)</span>
<span class="nc" id="L185">                throw Throwables.unchecked(error);</span>
        }

<span class="fc" id="L188">        return removed;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private void doubleCapacity()
    {
<span class="nc bnc" id="L194" title="All 2 branches missed.">        assert head == tail;</span>

<span class="nc" id="L196">        int newCapacity = capacity &lt;&lt; 1;</span>
<span class="nc" id="L197">        E[] newBuffer = (E[]) new Object[newCapacity];</span>

<span class="nc" id="L199">        int headPortionLen = capacity - head;</span>
<span class="nc" id="L200">        System.arraycopy(buffer, head, newBuffer, 0, headPortionLen);</span>
<span class="nc" id="L201">        System.arraycopy(buffer, 0, newBuffer, headPortionLen, tail);</span>

<span class="nc" id="L203">        head = 0;</span>
<span class="nc" id="L204">        tail = capacity;</span>

<span class="nc" id="L206">        capacity = newCapacity;</span>
<span class="nc" id="L207">        mask = newCapacity - 1;</span>
<span class="nc" id="L208">        buffer = newBuffer;</span>
<span class="nc" id="L209">    }</span>

    private static int findNextPositivePowerOfTwo(int value)
    {
<span class="fc" id="L213">        return 1 &lt;&lt; (32 - Integer.numberOfLeadingZeros(value - 1));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>