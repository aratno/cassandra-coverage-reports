<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FrameDecoderWith8bHeader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.net</a> &gt; <span class="el_source">FrameDecoderWith8bHeader.java</span></div><h1>FrameDecoderWith8bHeader.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.net;

import java.nio.ByteBuffer;
import java.util.Collection;

import net.nicoulaj.compilecommand.annotations.Inline;

/**
 * An abstract frame decoder for frames utilising a fixed length header of 8 bytes or smaller.
 * Implements a generic frame decode method, that is backed by the four abstract methods
 * (three of which simply decode and verify the header as a long).
 *
 * Implementors are expected to declare their implementation methods final, and an outer decode
 * method implemented to invoke this class' {@link #decode}, so that it may be inlined with the
 * abstract method implementations then inlined into it.
 */
abstract class FrameDecoderWith8bHeader extends FrameDecoder
{
    FrameDecoderWith8bHeader(BufferPoolAllocator allocator)
    {
<span class="fc" id="L38">        super(allocator);</span>
<span class="fc" id="L39">    }</span>

    /**
     * Read a header that is 8 bytes or shorter, without modifying the buffer position.
     * If your header is longer than this, you will need to implement your own {@link #decode}
     */
    abstract long readHeader(ByteBuffer in, int begin);
    /**
     * Verify the header, and return an unrecoverable CorruptFrame if it is corrupted
     * @return null or CorruptFrame.unrecoverable
     */
    abstract CorruptFrame verifyHeader(long header);

    /**
     * Calculate the full frame length from info provided by the header, including the length of the header and any triler
     */
    abstract int frameLength(long header);

    /**
     * Extract a frame known to cover the given range.
     * If {@code transferOwnership}, the method is responsible for ensuring bytes.release() is invoked at some future point.
     */
    abstract Frame unpackFrame(ShareableBytes bytes, int begin, int end, long header);

    /**
     * Decode a number of frames using the above abstract method implementations.
     * It is expected for this method to be invoked by the implementing class' {@link #decode(Collection, ShareableBytes)}
     * so that this implementation will be inlined, and all of the abstract method implementations will also be inlined.
     */
    @Inline
    protected void decode(Collection&lt;Frame&gt; into, ShareableBytes newBytes, int headerLength)
    {
<span class="fc" id="L71">        ByteBuffer in = newBytes.get();</span>

        try
        {
<span class="fc bfc" id="L75" title="All 2 branches covered.">            if (stash != null)</span>
            {
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">                if (!copyToSize(in, stash, headerLength))</span>
<span class="nc" id="L78">                    return;</span>

<span class="fc" id="L80">                long header = readHeader(stash, 0);</span>
<span class="fc" id="L81">                CorruptFrame c = verifyHeader(header);</span>
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">                if (c != null)</span>
                {
<span class="nc" id="L84">                    discard();</span>
<span class="nc" id="L85">                    into.add(c);</span>
<span class="nc" id="L86">                    return;</span>
                }

<span class="fc" id="L89">                int frameLength = frameLength(header);</span>
<span class="fc" id="L90">                stash = ensureCapacity(stash, frameLength);</span>

<span class="fc bfc" id="L92" title="All 2 branches covered.">                if (!copyToSize(in, stash, frameLength))</span>
<span class="fc" id="L93">                    return;</span>

<span class="fc" id="L95">                stash.flip();</span>
<span class="fc" id="L96">                ShareableBytes stashed = ShareableBytes.wrap(stash);</span>
<span class="fc" id="L97">                stash = null;</span>

                try
                {
<span class="fc" id="L101">                    into.add(unpackFrame(stashed, 0, frameLength, header));</span>
                }
                finally
                {
<span class="fc" id="L105">                    stashed.release();</span>
                }
            }

<span class="fc" id="L109">            int begin = in.position();</span>
<span class="fc" id="L110">            int limit = in.limit();</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">            while (begin &lt; limit)</span>
            {
<span class="fc" id="L113">                int remaining = limit - begin;</span>
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">                if (remaining &lt; headerLength)</span>
                {
<span class="nc" id="L116">                    stash(newBytes, headerLength, begin, remaining);</span>
<span class="nc" id="L117">                    return;</span>
                }

<span class="fc" id="L120">                long header = readHeader(in, begin);</span>
<span class="fc" id="L121">                CorruptFrame c = verifyHeader(header);</span>
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">                if (c != null)</span>
                {
<span class="nc" id="L124">                    into.add(c);</span>
<span class="nc" id="L125">                    return;</span>
                }

<span class="fc" id="L128">                int frameLength = frameLength(header);</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">                if (remaining &lt; frameLength)</span>
                {
<span class="fc" id="L131">                    stash(newBytes, frameLength, begin, remaining);</span>
<span class="fc" id="L132">                    return;</span>
                }

<span class="fc" id="L135">                into.add(unpackFrame(newBytes, begin, begin + frameLength, header));</span>
<span class="fc" id="L136">                begin += frameLength;</span>
<span class="fc" id="L137">            }</span>
        }
        finally
        {
<span class="fc" id="L141">            newBytes.release();</span>
        }
<span class="fc" id="L143">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>