<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LatencyMetrics.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.metrics</a> &gt; <span class="el_source">LatencyMetrics.java</span></div><h1>LatencyMetrics.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.metrics;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.TimeUnit;

import com.google.common.collect.Lists;

import com.codahale.metrics.Counter;
import com.codahale.metrics.Reservoir;
import com.codahale.metrics.Snapshot;
import com.codahale.metrics.Timer;

import static org.apache.cassandra.metrics.CassandraMetricsRegistry.Metrics;


/**
 * Metrics about latencies
 */
public class LatencyMetrics
{
    /** Latency */
    public final LatencyMetricsTimer latency;
    /** Total latency in micro sec */
    public final Counter totalLatency;

    /** parent metrics to replicate any updates to **/
<span class="fc" id="L45">    private List&lt;LatencyMetrics&gt; parents = Lists.newArrayList();</span>
<span class="fc" id="L46">    private final List&lt;LatencyMetrics&gt; children = Lists.newArrayList();</span>

    protected final MetricNameFactory factory;
    protected final MetricNameFactory aliasFactory;
    protected final String namePrefix;

    /**
     * Create LatencyMetrics with given group, type, and scope. Name prefix for each metric will be empty.
     *
     * @param type Type name
     * @param scope Scope
     */
    public LatencyMetrics(String type, String scope)
    {
<span class="fc" id="L60">        this(type, &quot;&quot;, scope);</span>
<span class="fc" id="L61">    }</span>

    /**
     * Create LatencyMetrics with given group, type, prefix to append to each metric name, and scope.
     *
     * @param type Type name
     * @param namePrefix Prefix to append to each metric name
     * @param scope Scope of metrics
     */
    public LatencyMetrics(String type, String namePrefix, String scope)
    {
<span class="fc" id="L72">        this(new DefaultNameFactory(type, scope), namePrefix);</span>
<span class="fc" id="L73">    }</span>

    /**
     * Create LatencyMetrics with given group, type, prefix to append to each metric name, and scope.
     *
     * @param factory MetricName factory to use
     * @param namePrefix Prefix to append to each metric name
     */
    public LatencyMetrics(MetricNameFactory factory, String namePrefix)
    {
<span class="fc" id="L83">        this(factory, null, namePrefix);</span>
<span class="fc" id="L84">    }</span>

    public LatencyMetrics(MetricNameFactory factory, MetricNameFactory aliasFactory, String namePrefix)
<span class="fc" id="L87">    {</span>
<span class="fc" id="L88">        this.factory = factory;</span>
<span class="fc" id="L89">        this.aliasFactory = aliasFactory;</span>
<span class="fc" id="L90">        this.namePrefix = namePrefix;</span>

<span class="fc" id="L92">        LatencyMetricsTimer timer = new LatencyMetrics.LatencyMetricsTimer(CassandraMetricsRegistry.createReservoir(TimeUnit.MICROSECONDS));</span>
<span class="fc" id="L93">        Counter counter = new LatencyMetricsCounter();</span>

<span class="fc bfc" id="L95" title="All 2 branches covered.">        if (aliasFactory == null)</span>
        {
<span class="fc" id="L97">            latency = Metrics.register(factory.createMetricName(namePrefix + &quot;Latency&quot;), timer);</span>
<span class="fc" id="L98">            totalLatency = Metrics.register(factory.createMetricName(namePrefix + &quot;TotalLatency&quot;), counter);</span>
        }
        else
        {
<span class="fc" id="L102">            latency = Metrics.register(factory.createMetricName(namePrefix + &quot;Latency&quot;), aliasFactory.createMetricName(namePrefix + &quot;Latency&quot;), timer);</span>
<span class="fc" id="L103">            totalLatency = Metrics.register(factory.createMetricName(namePrefix + &quot;TotalLatency&quot;), aliasFactory.createMetricName(namePrefix + &quot;TotalLatency&quot;), counter);</span>
        }
<span class="fc" id="L105">    }</span>
    
    /**
     * Create LatencyMetrics with given group, type, prefix to append to each metric name, and scope.  Any updates
     * to this will also run on parent
     *
     * @param factory MetricName factory to use
     * @param namePrefix Prefix to append to each metric name
     * @param parents any amount of parents to replicate updates to
     */
    public LatencyMetrics(MetricNameFactory factory, String namePrefix, LatencyMetrics ... parents)
    {
<span class="fc" id="L117">        this(factory, null, namePrefix);</span>
<span class="fc" id="L118">        this.parents = Arrays.asList(parents);</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">        for (LatencyMetrics parent : parents)</span>
        {
<span class="fc" id="L121">            parent.addChildren(this);</span>
        }
<span class="fc" id="L123">    }</span>

    private void addChildren(LatencyMetrics latencyMetric)
    {
<span class="fc" id="L127">        this.children.add(latencyMetric);</span>
<span class="fc" id="L128">    }</span>

    private synchronized void removeChildren(LatencyMetrics toRelease)
    {
        /*
        Merge details of removed children metrics and add them to our local copy to prevent metrics from going
        backwards. Synchronized since these methods are not thread safe to prevent multiple simultaneous removals.
        Will not protect against simultaneous updates, but since these methods are used by linked parent instances only,
        they should not receive any updates.
         */
<span class="fc" id="L138">        this.latency.releasedLatencyCount += toRelease.latency.getCount();</span>

<span class="fc" id="L140">        DecayingEstimatedHistogramReservoir.EstimatedHistogramReservoirSnapshot childSnapshot = (DecayingEstimatedHistogramReservoir.EstimatedHistogramReservoirSnapshot) toRelease.latency.getSnapshot();</span>
<span class="fc" id="L141">        DecayingEstimatedHistogramReservoir.EstimatedHistogramReservoirSnapshot snapshot = (DecayingEstimatedHistogramReservoir.EstimatedHistogramReservoirSnapshot) this.latency.getSnapshot();</span>

<span class="fc" id="L143">        snapshot.add(childSnapshot);</span>
<span class="fc" id="L144">        snapshot.rebaseReservoir();</span>

<span class="fc" id="L146">        this.totalLatency.inc(toRelease.totalLatency.getCount());</span>

        // Now we can remove the reference
<span class="fc" id="L149">        this.children.removeIf(latencyMetrics -&gt; latencyMetrics.equals(toRelease));</span>
<span class="fc" id="L150">    }</span>

    /** takes nanoseconds **/
    public void addNano(long nanos)
    {
        // convert to microseconds. 1 millionth
<span class="fc" id="L156">        latency.update(nanos, TimeUnit.NANOSECONDS);</span>
<span class="fc" id="L157">        totalLatency.inc(nanos / 1000);</span>
<span class="fc" id="L158">    }</span>

    public void release()
    {
        // Notify parent metrics that this metric is being released
<span class="fc bfc" id="L163" title="All 2 branches covered.">        for (LatencyMetrics parent : this.parents)</span>
        {
<span class="fc" id="L165">            parent.removeChildren(this);</span>
<span class="fc" id="L166">        }</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">        if (aliasFactory == null)</span>
        {
<span class="fc" id="L169">            Metrics.remove(factory.createMetricName(namePrefix + &quot;Latency&quot;));</span>
<span class="fc" id="L170">            Metrics.remove(factory.createMetricName(namePrefix + &quot;TotalLatency&quot;));</span>
        }
        else
        {
<span class="nc" id="L174">            Metrics.remove(factory.createMetricName(namePrefix + &quot;Latency&quot;), aliasFactory.createMetricName(namePrefix + &quot;Latency&quot;));</span>
<span class="nc" id="L175">            Metrics.remove(factory.createMetricName(namePrefix + &quot;TotalLatency&quot;), aliasFactory.createMetricName(namePrefix + &quot;TotalLatency&quot;));</span>
        }
<span class="fc" id="L177">    }</span>

    public class LatencyMetricsTimer extends Timer
    {

<span class="fc" id="L182">        long releasedLatencyCount = 0;</span>

        public LatencyMetricsTimer(Reservoir reservoir) 
<span class="fc" id="L185">        {</span>
<span class="fc" id="L186">            super(reservoir);</span>
<span class="fc" id="L187">        }</span>

        @Override
        public long getCount()
        {
<span class="fc" id="L192">            long count = super.getCount() + releasedLatencyCount;</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">            for (LatencyMetrics child : children)</span>
            {
<span class="fc" id="L195">                count += child.latency.getCount();</span>
<span class="fc" id="L196">            }</span>

<span class="fc" id="L198">            return count;</span>
        }

        @Override
        public double getFifteenMinuteRate()
        {
<span class="nc" id="L204">            double rate = super.getFifteenMinuteRate();</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">            for (LatencyMetrics child : children)</span>
            {
<span class="nc" id="L207">                rate += child.latency.getFifteenMinuteRate();</span>
<span class="nc" id="L208">            }</span>
<span class="nc" id="L209">            return rate;</span>
        }

        @Override
        public double getFiveMinuteRate()
        {
<span class="nc" id="L215">            double rate = super.getFiveMinuteRate();</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">            for (LatencyMetrics child : children)</span>
            {
<span class="nc" id="L218">                rate += child.latency.getFiveMinuteRate();</span>
<span class="nc" id="L219">            }</span>
<span class="nc" id="L220">            return rate;</span>
        }

        @Override
        public double getMeanRate()
        {
            // Not necessarily 100% accurate, but close enough
<span class="nc" id="L227">            double rate = super.getMeanRate();</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">            for (LatencyMetrics child : children)</span>
            {
<span class="nc" id="L230">                rate += child.latency.getMeanRate();</span>
<span class="nc" id="L231">            }</span>
<span class="nc" id="L232">            return rate;</span>
        }

        @Override
        public double getOneMinuteRate()
        {
<span class="fc" id="L238">            double rate = super.getOneMinuteRate();</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">            for (LatencyMetrics child : children)</span>
            {
<span class="nc" id="L241">                rate += child.latency.getOneMinuteRate();</span>
<span class="nc" id="L242">            }</span>
<span class="fc" id="L243">            return rate;</span>
        }

        @Override
        public Snapshot getSnapshot()
        {
<span class="fc" id="L249">            DecayingEstimatedHistogramReservoir.EstimatedHistogramReservoirSnapshot parent = (DecayingEstimatedHistogramReservoir.EstimatedHistogramReservoirSnapshot) super.getSnapshot();</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">            for (LatencyMetrics child : children)</span>
            {
<span class="fc" id="L252">                parent.add(child.latency.getSnapshot());</span>
<span class="fc" id="L253">            }</span>

<span class="fc" id="L255">            return parent;</span>
        }
    }

<span class="fc" id="L259">    class LatencyMetricsCounter extends Counter </span>
    {
        @Override
        public long getCount()
        {
<span class="fc" id="L264">            long count = super.getCount();</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">            for (LatencyMetrics child : children)</span>
            {
<span class="fc" id="L267">                count += child.totalLatency.getCount();</span>
<span class="fc" id="L268">            }</span>
<span class="fc" id="L269">            return count;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>