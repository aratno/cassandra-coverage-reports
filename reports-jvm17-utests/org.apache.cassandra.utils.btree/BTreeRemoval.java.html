<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BTreeRemoval.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.utils.btree</a> &gt; <span class="el_source">BTreeRemoval.java</span></div><h1>BTreeRemoval.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cassandra.utils.btree;

import java.util.Arrays;
import java.util.Comparator;

<span class="pc" id="L24">public class BTreeRemoval</span>
{
    /**
     * Remove |elem| from |btree|. If it's not present then return |btree| itself.
     */
    public static &lt;V&gt; Object[] remove(final Object[] btree, final Comparator&lt;? super V&gt; comparator, final V elem)
    {
<span class="fc bfc" id="L31" title="All 2 branches covered.">        if (BTree.isEmpty(btree))</span>
<span class="fc" id="L32">            return btree;</span>
<span class="fc" id="L33">        int index = -1;</span>
<span class="fc" id="L34">        V elemToSwap = null;</span>
<span class="fc" id="L35">        int lb = 0;</span>
<span class="fc" id="L36">        Object[] node = btree;</span>
        while (true)
        {
<span class="fc" id="L39">            int keyEnd = BTree.getKeyEnd(node);</span>
<span class="fc" id="L40">            int i = Arrays.binarySearch((V[]) node, 0, keyEnd, elem, comparator);</span>

<span class="fc bfc" id="L42" title="All 2 branches covered.">            if (i &gt;= 0)</span>
            {
<span class="fc bfc" id="L44" title="All 2 branches covered.">                if (BTree.isLeaf(node))</span>
<span class="fc" id="L45">                    index = lb + i;</span>
                else
                {
<span class="fc" id="L48">                    final int indexInNode = BTree.getSizeMap(node)[i];</span>
<span class="fc" id="L49">                    index = lb + indexInNode - 1;</span>
<span class="fc" id="L50">                    elemToSwap = BTree.findByIndex(node, indexInNode - 1);</span>
                }
<span class="fc" id="L52">                break;</span>
            }
<span class="fc bfc" id="L54" title="All 2 branches covered.">            if (BTree.isLeaf(node))</span>
<span class="fc" id="L55">                return btree;</span>

<span class="fc" id="L57">            i = -1 - i;</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">            if (i &gt; 0)</span>
<span class="fc" id="L59">                lb += BTree.getSizeMap(node)[i - 1] + 1;</span>

<span class="fc" id="L61">            node = (Object[]) node[keyEnd + i];</span>
<span class="fc" id="L62">        }</span>
<span class="fc bfc" id="L63" title="All 2 branches covered.">        if (BTree.size(btree) == 1)</span>
<span class="fc" id="L64">            return BTree.empty();</span>
<span class="fc" id="L65">        Object[] result = removeFromLeaf(btree, index);</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">        if (elemToSwap != null)</span>
<span class="fc" id="L67">            BTree.replaceInSitu(result, index, elemToSwap);</span>
<span class="fc" id="L68">        return result;</span>
    }

    /**
     * Remove |elem| from |btree|. It has to be present and it has to reside in a leaf node.
     */
    private static Object[] removeFromLeaf(Object[] node, int index)
    {
<span class="fc" id="L76">        Object[] result = null;</span>
<span class="fc" id="L77">        Object[] prevNode = null;</span>
<span class="fc" id="L78">        int prevI = -1;</span>
<span class="fc" id="L79">        boolean needsCopy = true;</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">        while (!BTree.isLeaf(node))</span>
        {
<span class="fc" id="L82">            final int keyEnd = BTree.getBranchKeyEnd(node);</span>
<span class="fc" id="L83">            int i = -1 - Arrays.binarySearch(BTree.getSizeMap(node), index);</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">            if (i &gt; 0)</span>
<span class="fc" id="L85">                index -= (1 + BTree.getSizeMap(node)[i - 1]);</span>
<span class="fc" id="L86">            Object[] nextNode = (Object[]) node[keyEnd + i];</span>
<span class="fc" id="L87">            boolean nextNodeNeedsCopy = true;</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">            if (BTree.getKeyEnd(nextNode) &gt; BTree.MIN_KEYS)</span>
<span class="fc" id="L89">                node = copyIfNeeded(node, needsCopy);</span>
<span class="fc bfc" id="L90" title="All 4 branches covered.">            else if (i &gt; 0 &amp;&amp; BTree.getKeyEnd((Object[]) node[keyEnd + i - 1]) &gt; BTree.MIN_KEYS)</span>
            {
<span class="fc" id="L92">                node = copyIfNeeded(node, needsCopy);</span>
<span class="fc" id="L93">                final Object[] leftNeighbour = (Object[]) node[keyEnd + i - 1];</span>
<span class="fc" id="L94">                index++;</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">                if (!BTree.isLeaf(leftNeighbour))</span>
<span class="fc" id="L96">                    index += BTree.size((Object[])leftNeighbour[BTree.getChildEnd(leftNeighbour) - 1]);</span>
<span class="fc" id="L97">                nextNode = rotateLeft(node, i);</span>
<span class="fc" id="L98">            }</span>
<span class="fc bfc" id="L99" title="All 4 branches covered.">            else if (i &lt; keyEnd &amp;&amp; BTree.getKeyEnd((Object[]) node[keyEnd + i + 1]) &gt; BTree.MIN_KEYS)</span>
            {
<span class="fc" id="L101">                node = copyIfNeeded(node, needsCopy);</span>
<span class="fc" id="L102">                nextNode = rotateRight(node, i);</span>
            }
            else
            {
<span class="fc" id="L106">                nextNodeNeedsCopy = false;</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">                if (i &gt; 0)</span>
                {
<span class="fc" id="L109">                    final Object[] leftNeighbour = (Object[]) node[keyEnd + i - 1];</span>
<span class="fc" id="L110">                    final Object nodeKey = node[i - 1];</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">                    node = keyEnd == 1 ? null : copyWithKeyAndChildRemoved(node, i - 1, i - 1, false);</span>
<span class="fc" id="L112">                    nextNode = merge(leftNeighbour, nextNode, nodeKey);</span>
<span class="fc" id="L113">                    i = i - 1;</span>
<span class="fc" id="L114">                    index += BTree.size(leftNeighbour) + 1;</span>
<span class="fc" id="L115">                }</span>
                else
                {
<span class="fc" id="L118">                    final Object[] rightNeighbour = (Object[]) node[keyEnd + i + 1];</span>
<span class="fc" id="L119">                    final Object nodeKey = node[i];</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">                    node = keyEnd == 1 ? null : copyWithKeyAndChildRemoved(node, i, i, false);</span>
<span class="fc" id="L121">                    nextNode = merge(nextNode, rightNeighbour, nodeKey);</span>
                }
            }

<span class="fc bfc" id="L125" title="All 2 branches covered.">            if (node != null)</span>
            {
<span class="fc" id="L127">                final int[] sizeMap = BTree.getSizeMap(node);</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">                for (int j = i; j &lt; sizeMap.length; ++j)</span>
<span class="fc" id="L129">                    sizeMap[j] -= 1;</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">                if (prevNode != null)</span>
<span class="fc" id="L131">                    prevNode[prevI] = node;</span>
                else
<span class="fc" id="L133">                    result = node;</span>
<span class="fc" id="L134">                prevNode = node;</span>
<span class="fc" id="L135">                prevI = BTree.getChildStart(node) + i;</span>
            }

<span class="fc" id="L138">            node = nextNode;</span>
<span class="fc" id="L139">            needsCopy = nextNodeNeedsCopy;</span>
<span class="fc" id="L140">        }</span>
<span class="fc" id="L141">        final int keyEnd = BTree.getLeafKeyEnd(node);</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">        final Object[] newLeaf = new Object[(keyEnd &amp; 1) == 1 ? keyEnd : keyEnd - 1];</span>
<span class="fc" id="L143">        copyKeys(node, newLeaf, 0, index);</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">        if (prevNode != null)</span>
<span class="fc" id="L145">            prevNode[prevI] = newLeaf;</span>
        else
<span class="fc" id="L147">            result = newLeaf;</span>
<span class="fc" id="L148">        return result;</span>
    }

    private static Object[] rotateRight(final Object[] node, final int i)
    {
<span class="fc" id="L153">        final int keyEnd = BTree.getBranchKeyEnd(node);</span>
<span class="fc" id="L154">        final Object[] nextNode = (Object[]) node[keyEnd + i];</span>
<span class="fc" id="L155">        final Object[] rightNeighbour = (Object[]) node[keyEnd + i + 1];</span>
<span class="fc" id="L156">        final boolean leaves = BTree.isLeaf(nextNode);</span>
<span class="fc" id="L157">        final int nextKeyEnd = BTree.getKeyEnd(nextNode);</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">        final Object[] newChild = leaves ? null : (Object[]) rightNeighbour[BTree.getChildStart(rightNeighbour)];</span>
<span class="fc" id="L159">        final Object[] newNextNode =</span>
<span class="fc" id="L160">                copyWithKeyAndChildInserted(nextNode, nextKeyEnd, node[i], BTree.getChildCount(nextNode), newChild);</span>
<span class="fc" id="L161">        node[i] = rightNeighbour[0];</span>
<span class="fc" id="L162">        node[keyEnd + i + 1] = copyWithKeyAndChildRemoved(rightNeighbour, 0, 0, true);</span>
<span class="fc" id="L163">        BTree.getSizeMap(node)[i] +=</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">                leaves ? 1 : 1 + BTree.size((Object[]) newNextNode[BTree.getChildEnd(newNextNode) - 1]);</span>
<span class="fc" id="L165">        return newNextNode;</span>
    }

    private static Object[] rotateLeft(final Object[] node, final int i)
    {
<span class="fc" id="L170">        final int keyEnd = BTree.getBranchKeyEnd(node);</span>
<span class="fc" id="L171">        final Object[] nextNode = (Object[]) node[keyEnd + i];</span>
<span class="fc" id="L172">        final Object[] leftNeighbour = (Object[]) node[keyEnd + i - 1];</span>
<span class="fc" id="L173">        final int leftNeighbourEndKey = BTree.getKeyEnd(leftNeighbour);</span>
<span class="fc" id="L174">        final boolean leaves = BTree.isLeaf(nextNode);</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">        final Object[] newChild = leaves ? null : (Object[]) leftNeighbour[BTree.getChildEnd(leftNeighbour) - 1];</span>
<span class="fc" id="L176">        final Object[] newNextNode = copyWithKeyAndChildInserted(nextNode, 0, node[i - 1], 0, newChild);</span>
<span class="fc" id="L177">        node[i - 1] = leftNeighbour[leftNeighbourEndKey - 1];</span>
<span class="fc" id="L178">        node[keyEnd + i - 1] = copyWithKeyAndChildRemoved(leftNeighbour, leftNeighbourEndKey - 1, leftNeighbourEndKey, true);</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        BTree.getSizeMap(node)[i - 1] -= leaves ? 1 : 1 + BTree.getSizeMap(newNextNode)[0];</span>
<span class="fc" id="L180">        return newNextNode;</span>
    }

    private static &lt;V&gt; Object[] copyWithKeyAndChildInserted(final Object[] node, final int keyIndex, final V key, final int childIndex, final Object[] child)
    {
<span class="fc" id="L185">        final boolean leaf = BTree.isLeaf(node);</span>
<span class="fc" id="L186">        final int keyEnd = BTree.getKeyEnd(node);</span>
        final Object[] copy;
<span class="fc bfc" id="L188" title="All 2 branches covered.">        if (leaf)</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">            copy = new Object[keyEnd + ((keyEnd &amp; 1) == 1 ? 2 : 1)];</span>
        else
<span class="fc" id="L191">            copy = new Object[node.length + 2];</span>

<span class="fc bfc" id="L193" title="All 2 branches covered.">        if (keyIndex &gt; 0)</span>
<span class="fc" id="L194">            System.arraycopy(node, 0, copy, 0, keyIndex);</span>
<span class="fc" id="L195">        copy[keyIndex] = key;</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">        if (keyIndex &lt; keyEnd)</span>
<span class="fc" id="L197">            System.arraycopy(node, keyIndex, copy, keyIndex + 1, keyEnd - keyIndex);</span>

<span class="fc bfc" id="L199" title="All 2 branches covered.">        if (!leaf)</span>
        {
<span class="fc bfc" id="L201" title="All 2 branches covered.">            if (childIndex &gt; 0)</span>
<span class="fc" id="L202">                System.arraycopy(node,</span>
<span class="fc" id="L203">                                 BTree.getChildStart(node),</span>
                                 copy,
                                 keyEnd + 1,
                                 childIndex);
<span class="fc" id="L207">            copy[keyEnd + 1 + childIndex] = child;</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">            if (childIndex &lt;= keyEnd)</span>
<span class="fc" id="L209">                System.arraycopy(node,</span>
<span class="fc" id="L210">                                 BTree.getChildStart(node) + childIndex,</span>
                                 copy,
                                 keyEnd + childIndex + 2,
                                 keyEnd - childIndex + 1);
<span class="fc" id="L214">            final int[] sizeMap = BTree.getSizeMap(node);</span>
<span class="fc" id="L215">            final int[] newSizeMap = new int[sizeMap.length + 1];</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">            if (childIndex &gt; 0)</span>
<span class="fc" id="L217">                System.arraycopy(sizeMap, 0, newSizeMap, 0, childIndex);</span>
<span class="fc" id="L218">            final int childSize = BTree.size(child);</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">            newSizeMap[childIndex] = childSize + ((childIndex == 0) ? 0 : newSizeMap[childIndex - 1] + 1);</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">            for (int i = childIndex + 1; i &lt; newSizeMap.length; ++i)</span>
<span class="fc" id="L221">                newSizeMap[i] = sizeMap[i - 1] + childSize + 1;</span>
<span class="fc" id="L222">            copy[copy.length - 1] = newSizeMap;</span>
        }
<span class="fc" id="L224">        return copy;</span>
    }

    private static Object[] copyWithKeyAndChildRemoved(final Object[] node, final int keyIndex, final int childIndex, final boolean substractSize)
    {
<span class="fc" id="L229">        final boolean leaf = BTree.isLeaf(node);</span>
        final Object[] newNode;
<span class="fc bfc" id="L231" title="All 2 branches covered.">        if (leaf)</span>
        {
<span class="fc" id="L233">            final int keyEnd = BTree.getKeyEnd(node);</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">            newNode = new Object[keyEnd - ((keyEnd &amp; 1) == 1 ? 0 : 1)];</span>
<span class="fc" id="L235">        }</span>
        else
        {
<span class="fc" id="L238">            newNode = new Object[node.length - 2];</span>
        }
<span class="fc" id="L240">        int offset = copyKeys(node, newNode, 0, keyIndex);</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">        if (!leaf)</span>
        {
<span class="fc" id="L243">            offset = copyChildren(node, newNode, offset, childIndex);</span>
<span class="fc" id="L244">            final int[] nodeSizeMap = BTree.getSizeMap(node);</span>
<span class="fc" id="L245">            final int[] newNodeSizeMap = new int[nodeSizeMap.length - 1];</span>
<span class="fc" id="L246">            int pos = 0;</span>
<span class="fc" id="L247">            final int sizeToRemove = BTree.size((Object[])node[BTree.getChildStart(node) + childIndex]) + 1;</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">            for (int i = 0; i &lt; nodeSizeMap.length; ++i)</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">                if (i != childIndex)</span>
<span class="fc" id="L250">                    newNodeSizeMap[pos++] = nodeSizeMap[i] -</span>
<span class="fc bfc" id="L251" title="All 4 branches covered.">                        ((substractSize &amp;&amp; i &gt; childIndex) ? sizeToRemove : 0);</span>
<span class="fc" id="L252">            newNode[offset] = newNodeSizeMap;</span>
        }
<span class="fc" id="L254">        return newNode;</span>
    }

    private static &lt;V&gt; Object[] merge(final Object[] left, final Object[] right, final V nodeKey)
    {
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">        assert BTree.getKeyEnd(left) == BTree.MIN_KEYS;</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">        assert BTree.getKeyEnd(right) == BTree.MIN_KEYS;</span>
<span class="fc" id="L261">        final boolean leaves = BTree.isLeaf(left);</span>
        final Object[] result;
<span class="fc bfc" id="L263" title="All 2 branches covered.">        if (leaves)</span>
<span class="fc" id="L264">            result = new Object[BTree.MIN_KEYS * 2 + 1];</span>
        else
<span class="fc" id="L266">            result = new Object[left.length + right.length];</span>
<span class="fc" id="L267">        int offset = 0;</span>
<span class="fc" id="L268">        offset = copyKeys(left, result, offset);</span>
<span class="fc" id="L269">        result[offset++] = nodeKey;</span>
<span class="fc" id="L270">        offset = copyKeys(right, result, offset);</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">        if (!leaves)</span>
        {
<span class="fc" id="L273">            offset = copyChildren(left, result, offset);</span>
<span class="fc" id="L274">            offset = copyChildren(right, result, offset);</span>
<span class="fc" id="L275">            final int[] leftSizeMap = BTree.getSizeMap(left);</span>
<span class="fc" id="L276">            final int[] rightSizeMap = BTree.getSizeMap(right);</span>
<span class="fc" id="L277">            final int[] newSizeMap = new int[leftSizeMap.length + rightSizeMap.length];</span>
<span class="fc" id="L278">            offset = 0;</span>
<span class="fc" id="L279">            offset = copySizeMap(leftSizeMap, newSizeMap, offset, 0);</span>
<span class="fc" id="L280">            offset = copySizeMap(rightSizeMap, newSizeMap, offset, leftSizeMap[leftSizeMap.length - 1] + 1);</span>
<span class="fc" id="L281">            result[result.length - 1] = newSizeMap;</span>
        }
<span class="fc" id="L283">        return result;</span>
    }

    private static int copyKeys(final Object[] from, final Object[] to, final int offset)
    {
<span class="fc" id="L288">        final int keysCount = BTree.getKeyEnd(from);</span>
<span class="fc" id="L289">        System.arraycopy(from, 0, to, offset, keysCount);</span>
<span class="fc" id="L290">        return offset + keysCount;</span>
    }

    private static int copyKeys(final Object[] from, final Object[] to, final int offset, final int skipIndex)
    {
<span class="fc" id="L295">        final int keysCount = BTree.getKeyEnd(from);</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">        if (skipIndex &gt; 0)</span>
<span class="fc" id="L297">            System.arraycopy(from, 0, to, offset, skipIndex);</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">        if (skipIndex + 1 &lt; keysCount)</span>
<span class="fc" id="L299">            System.arraycopy(from, skipIndex + 1, to, offset + skipIndex, keysCount - skipIndex - 1);</span>
<span class="fc" id="L300">        return offset + keysCount - 1;</span>
    }

    private static int copyChildren(final Object[] from, final Object[] to, final int offset)
    {
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">        assert !BTree.isLeaf(from);</span>
<span class="fc" id="L306">        final int start = BTree.getChildStart(from);</span>
<span class="fc" id="L307">        final int childCount = BTree.getChildCount(from);</span>
<span class="fc" id="L308">        System.arraycopy(from, start, to, offset, childCount);</span>
<span class="fc" id="L309">        return offset + childCount;</span>
    }

    private static int copyChildren(final Object[] from, final Object[] to, final int offset, final int skipIndex)
    {
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">        assert !BTree.isLeaf(from);</span>
<span class="fc" id="L315">        final int start = BTree.getChildStart(from);</span>
<span class="fc" id="L316">        final int childCount = BTree.getChildCount(from);</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">        if (skipIndex &gt; 0)</span>
<span class="fc" id="L318">            System.arraycopy(from, start, to, offset, skipIndex);</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">        if (skipIndex + 1 &lt;= childCount)</span>
<span class="fc" id="L320">            System.arraycopy(from, start + skipIndex + 1, to, offset + skipIndex, childCount - skipIndex - 1);</span>
<span class="fc" id="L321">        return offset + childCount - 1;</span>
    }

    private static int copySizeMap(final int[] from, final int[] to, final int offset, final int extra)
    {
<span class="fc bfc" id="L326" title="All 2 branches covered.">        for (int i = 0; i &lt; from.length; ++i)</span>
<span class="fc" id="L327">            to[offset + i] = from[i] + extra;</span>
<span class="fc" id="L328">        return offset + from.length;</span>
    }

    private static Object[] copyIfNeeded(final Object[] node, boolean needCopy)
    {
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (!needCopy) return node;</span>
<span class="fc" id="L334">        final Object[] copy = new Object[node.length];</span>
<span class="fc" id="L335">        System.arraycopy(node, 0, copy, 0, node.length);</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">        if (!BTree.isLeaf(node))</span>
        {
<span class="fc" id="L338">            final int[] sizeMap = BTree.getSizeMap(node);</span>
<span class="fc" id="L339">            final int[] copySizeMap = new int[sizeMap.length];</span>
<span class="fc" id="L340">            System.arraycopy(sizeMap, 0, copySizeMap, 0, sizeMap.length);</span>
<span class="fc" id="L341">            copy[copy.length - 1] = copySizeMap;</span>
        }
<span class="fc" id="L343">        return copy;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>