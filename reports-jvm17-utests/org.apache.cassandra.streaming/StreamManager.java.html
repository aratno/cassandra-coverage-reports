<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StreamManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.streaming</a> &gt; <span class="el_source">StreamManager.java</span></div><h1>StreamManager.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.streaming;

import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArrayList;
import javax.management.ListenerNotFoundException;
import javax.management.MBeanNotificationInfo;
import javax.management.NotificationFilter;
import javax.management.NotificationListener;
import javax.management.openmbean.CompositeData;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.Weigher;
import com.google.common.collect.Iterables;
import com.google.common.collect.Sets;
import com.google.common.util.concurrent.RateLimiter;
import org.cliffc.high_scale_lib.NonBlockingHashMap;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.config.DurationSpec;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.streaming.management.StreamEventJMXNotifier;
import org.apache.cassandra.streaming.management.StreamStateCompositeData;
import org.apache.cassandra.utils.TimeUUID;

/**
 * StreamManager manages currently running {@link StreamResultFuture}s and provides status of all operation invoked.
 *
 * All stream operations should be created through this class to track streaming status and progress.
 */
public class StreamManager implements StreamManagerMBean
{
<span class="fc" id="L57">    private static final Logger logger = LoggerFactory.getLogger(StreamManager.class);</span>

<span class="fc" id="L59">    public static final StreamManager instance = new StreamManager();</span>

    /**
     * Gets streaming rate limiter.
     * When stream_throughput_outbound is 0, this returns rate limiter
     * with the rate of Double.MAX_VALUE bytes per second.
     * Rate unit is bytes per sec.
     *
     * @return StreamRateLimiter with rate limit set based on peer location.
     */
    public static StreamRateLimiter getRateLimiter(InetAddressAndPort peer)
    {
<span class="fc" id="L71">        return new StreamRateLimiter(peer,</span>
                                     StreamRateLimiter.LIMITER,
                                     StreamRateLimiter.INTER_DC_LIMITER,
<span class="fc" id="L74">                                     DatabaseDescriptor.getStreamThroughputOutboundBytesPerSec(),</span>
<span class="fc" id="L75">                                     DatabaseDescriptor.getInterDCStreamThroughputOutboundBytesPerSec());</span>
    }

    /**
     * Get streaming rate limiter for entire SSTable operations.
     * When {@code entire_sstable_stream_throughput_outbound}
     * is less than or equal ot {@code 0}, this returns rate limiter with the
     * rate of {@link Double.MAX_VALUE} bytes per second.
     * Rate unit is bytes per sec.
     *
     * @param peer the peer location
     * @return {@link  StreamRateLimiter} with entire SSTable rate limit set based on peer location
     */
    public static StreamRateLimiter getEntireSSTableRateLimiter(InetAddressAndPort peer)
    {
<span class="fc" id="L90">        return new StreamRateLimiter(peer,</span>
                                     StreamRateLimiter.ENTIRE_SSTABLE_LIMITER,
                                     StreamRateLimiter.ENTIRE_SSTABLE_INTER_DC_LIMITER,
<span class="fc" id="L93">                                     DatabaseDescriptor.getEntireSSTableStreamThroughputOutboundBytesPerSec(),</span>
<span class="fc" id="L94">                                     DatabaseDescriptor.getEntireSSTableInterDCStreamThroughputOutboundBytesPerSec());</span>
    }

    public static class StreamRateLimiter implements StreamingDataOutputPlus.RateLimiter
    {
        public static final double BYTES_PER_MEBIBYTE = 1024.0 * 1024.0;
<span class="fc" id="L100">        private static final RateLimiter LIMITER = RateLimiter.create(calculateRateInBytes());</span>
<span class="fc" id="L101">        private static final RateLimiter INTER_DC_LIMITER = RateLimiter.create(calculateInterDCRateInBytes());</span>
<span class="fc" id="L102">        private static final RateLimiter ENTIRE_SSTABLE_LIMITER = RateLimiter.create(calculateEntireSSTableRateInBytes());</span>
<span class="fc" id="L103">        private static final RateLimiter ENTIRE_SSTABLE_INTER_DC_LIMITER = RateLimiter.create(calculateEntireSSTableInterDCRateInBytes());</span>

        private final RateLimiter limiter;
        private final RateLimiter interDCLimiter;
        private final boolean isLocalDC;
        private final double throughput;
        private final double interDCThroughput;

        private StreamRateLimiter(InetAddressAndPort peer, RateLimiter limiter, RateLimiter interDCLimiter, double throughput, double interDCThroughput)
<span class="fc" id="L112">        {</span>
<span class="fc" id="L113">            this.limiter = limiter;</span>
<span class="fc" id="L114">            this.interDCLimiter = interDCLimiter;</span>
<span class="fc" id="L115">            this.throughput = throughput;</span>
<span class="fc" id="L116">            this.interDCThroughput = interDCThroughput;</span>
<span class="pc bpc" id="L117" title="2 of 4 branches missed.">            if (DatabaseDescriptor.getLocalDataCenter() != null &amp;&amp; DatabaseDescriptor.getEndpointSnitch() != null)</span>
<span class="fc" id="L118">                isLocalDC = DatabaseDescriptor.getLocalDataCenter().equals(</span>
<span class="fc" id="L119">                DatabaseDescriptor.getEndpointSnitch().getDatacenter(peer));</span>
            else
<span class="nc" id="L121">                isLocalDC = true;</span>
<span class="fc" id="L122">        }</span>

        @Override
        public void acquire(int toTransfer)
        {
<span class="fc" id="L127">            limiter.acquire(toTransfer);</span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">            if (!isLocalDC)</span>
<span class="nc" id="L129">                interDCLimiter.acquire(toTransfer);</span>
<span class="fc" id="L130">        }</span>

        @Override
        public boolean isRateLimited()
        {
            // Rate limiting is enabled when throughput greater than 0.
            // If the peer is not local, also check whether inter-DC rate limiting is enabled.
<span class="fc bfc" id="L137" title="All 6 branches covered.">            return throughput &gt; 0 || (!isLocalDC &amp;&amp; interDCThroughput &gt; 0);</span>
        }

        public static void updateThroughput()
        {
<span class="fc" id="L142">            LIMITER.setRate(calculateRateInBytes());</span>
<span class="fc" id="L143">        }</span>

        public static void updateInterDCThroughput()
        {
<span class="fc" id="L147">            INTER_DC_LIMITER.setRate(calculateInterDCRateInBytes());</span>
<span class="fc" id="L148">        }</span>

        public static void updateEntireSSTableThroughput()
        {
<span class="fc" id="L152">            ENTIRE_SSTABLE_LIMITER.setRate(calculateEntireSSTableRateInBytes());</span>
<span class="fc" id="L153">        }</span>

        public static void updateEntireSSTableInterDCThroughput()
        {
<span class="fc" id="L157">            ENTIRE_SSTABLE_INTER_DC_LIMITER.setRate(calculateEntireSSTableInterDCRateInBytes());</span>
<span class="fc" id="L158">        }</span>

        private static double calculateRateInBytes()
        {
<span class="fc" id="L162">            double throughput = DatabaseDescriptor.getStreamThroughputOutboundBytesPerSec();</span>
<span class="fc" id="L163">            return calculateEffectiveRateInBytes(throughput);</span>
        }

        private static double calculateInterDCRateInBytes()
        {
<span class="fc" id="L168">            double throughput = DatabaseDescriptor.getInterDCStreamThroughputOutboundBytesPerSec();</span>
<span class="fc" id="L169">            return calculateEffectiveRateInBytes(throughput);</span>
        }

        private static double calculateEntireSSTableRateInBytes()
        {
<span class="fc" id="L174">            double throughput = DatabaseDescriptor.getEntireSSTableStreamThroughputOutboundBytesPerSec();</span>
<span class="fc" id="L175">            return calculateEffectiveRateInBytes(throughput);</span>
        }

        private static double calculateEntireSSTableInterDCRateInBytes()
        {
<span class="fc" id="L180">            double throughput = DatabaseDescriptor.getEntireSSTableInterDCStreamThroughputOutboundBytesPerSec();</span>
<span class="fc" id="L181">            return calculateEffectiveRateInBytes(throughput);</span>
        }

        @VisibleForTesting
        public static double getRateLimiterRateInBytes()
        {
<span class="fc" id="L187">            return LIMITER.getRate();</span>
        }

        @VisibleForTesting
        public static double getInterDCRateLimiterRateInBytes()
        {
<span class="fc" id="L193">            return INTER_DC_LIMITER.getRate();</span>
        }

        @VisibleForTesting
        public static double getEntireSSTableRateLimiterRateInBytes()
        {
<span class="fc" id="L199">            return ENTIRE_SSTABLE_LIMITER.getRate();</span>
        }

        @VisibleForTesting
        public static double getEntireSSTableInterDCRateLimiterRateInBytes()
        {
<span class="fc" id="L205">            return ENTIRE_SSTABLE_INTER_DC_LIMITER.getRate();</span>
        }

        private static double calculateEffectiveRateInBytes(double throughput)
        {
            // if throughput is set to 0, throttling is disabled
<span class="fc bfc" id="L211" title="All 2 branches covered.">            return throughput &gt; 0</span>
<span class="fc" id="L212">                   ? throughput</span>
<span class="fc" id="L213">                   : Double.MAX_VALUE;</span>
        }
    }

<span class="fc" id="L217">    private final StreamEventJMXNotifier notifier = new StreamEventJMXNotifier();</span>
<span class="fc" id="L218">    private final CopyOnWriteArrayList&lt;StreamListener&gt; listeners = new CopyOnWriteArrayList&lt;&gt;();</span>

    /*
     * Currently running streams. Removed after completion/failure.
     * We manage them in two different maps to distinguish plan from initiated ones to
     * receiving ones withing the same JVM.
     */
<span class="fc" id="L225">    private final Map&lt;TimeUUID, StreamResultFuture&gt; initiatorStreams = new NonBlockingHashMap&lt;&gt;();</span>
<span class="fc" id="L226">    private final Map&lt;TimeUUID, StreamResultFuture&gt; followerStreams = new NonBlockingHashMap&lt;&gt;();</span>

    private final Cache&lt;TimeUUID, StreamingState&gt; states;
<span class="fc" id="L229">    private final StreamListener listener = new StreamListener()</span>
<span class="fc" id="L230">    {</span>
        @Override
        public void onRegister(StreamResultFuture result)
        {
<span class="nc bnc" id="L234" title="All 2 branches missed.">            if (!DatabaseDescriptor.getStreamingStatsEnabled())</span>
<span class="nc" id="L235">                return;</span>
            // reason for synchronized rather than states.get is to detect duplicates
            // streaming shouldn't be producing duplicates as that would imply a planId collision
<span class="nc" id="L238">            synchronized (states)</span>
            {
<span class="nc" id="L240">                StreamingState previous = states.getIfPresent(result.planId);</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">                if (previous == null)</span>
                {
<span class="nc" id="L243">                    StreamingState state = new StreamingState(result);</span>
<span class="nc" id="L244">                    states.put(state.id(), state);</span>
<span class="nc" id="L245">                    state.phase.start();</span>
<span class="nc" id="L246">                    result.addEventListener(state);</span>
<span class="nc" id="L247">                }</span>
                else
                {
<span class="nc" id="L250">                    logger.warn(&quot;Duplicate streaming states detected for id {}&quot;, result.planId);</span>
                }
<span class="nc" id="L252">            }</span>
<span class="nc" id="L253">        }</span>
    };

    protected void addStreamingStateAgain(StreamingState state)
    {
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">        if (!DatabaseDescriptor.getStreamingStatsEnabled())</span>
<span class="nc" id="L259">            return;</span>
<span class="fc" id="L260">        states.put(state.id(), state);</span>
<span class="fc" id="L261">    }</span>

    public StreamManager()
<span class="fc" id="L264">    {</span>
<span class="fc" id="L265">        DurationSpec.LongNanosecondsBound duration = DatabaseDescriptor.getStreamingStateExpires();</span>
<span class="fc" id="L266">        long sizeBytes = DatabaseDescriptor.getStreamingStateSize().toBytes();</span>
<span class="fc" id="L267">        logger.info(&quot;Storing streaming state for {} or for size {}&quot;, duration, sizeBytes);</span>
<span class="fc" id="L268">        states = CacheBuilder.newBuilder()</span>
<span class="fc" id="L269">                             .expireAfterWrite(duration.quantity(), duration.unit())</span>
<span class="fc" id="L270">                             .maximumWeight(sizeBytes)</span>
<span class="fc" id="L271">                             .weigher(new StreamingStateWeigher())</span>
<span class="fc" id="L272">                             .build();</span>
<span class="fc" id="L273">    }</span>

    private static class StreamingStateWeigher implements Weigher&lt;TimeUUID,StreamingState&gt;
    {
        @Override
        public int weigh(TimeUUID key, StreamingState val)
        {
<span class="fc" id="L280">            long costOfStreamingState = val.unsharedHeapSize() + TimeUUID.TIMEUUID_SIZE;</span>
<span class="fc" id="L281">            return Math.toIntExact(costOfStreamingState);</span>
        }
    }

    public void start()
    {
<span class="fc" id="L287">        addListener(listener);</span>
<span class="fc" id="L288">    }</span>

    public void stop()
    {
<span class="nc" id="L292">        removeListener(listener);</span>
<span class="nc" id="L293">    }</span>

    public Collection&lt;StreamingState&gt; getStreamingStates()
    {
<span class="fc" id="L297">        return states.asMap().values();</span>
    }

    public StreamingState getStreamingState(TimeUUID id)
    {
<span class="nc" id="L302">        return states.getIfPresent(id);</span>
    }

    @VisibleForTesting
    public void putStreamingState(StreamingState state)
    {
<span class="fc" id="L308">        synchronized (states)</span>
        {
<span class="fc" id="L310">            StreamingState previous = states.getIfPresent(state.id());</span>
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">            if (previous != null)</span>
<span class="nc" id="L312">                throw new AssertionError(&quot;StreamPlan id &quot; + state.id() + &quot; already exists&quot;);</span>
<span class="fc" id="L313">            states.put(state.id(), state);</span>
<span class="fc" id="L314">        }</span>
<span class="fc" id="L315">    }</span>

    @VisibleForTesting
    public void clearStates()
    {
        // states.cleanUp() doesn't clear, it looks to only run gc on things that could be removed... this method should remove all state
<span class="fc" id="L321">        states.asMap().clear();</span>
<span class="fc" id="L322">    }</span>

    public Set&lt;CompositeData&gt; getCurrentStreams()
    {
<span class="fc" id="L326">        return Sets.newHashSet(Iterables.transform(Iterables.concat(initiatorStreams.values(), followerStreams.values()), new Function&lt;StreamResultFuture, CompositeData&gt;()</span>
<span class="fc" id="L327">        {</span>
            public CompositeData apply(StreamResultFuture input)
            {
<span class="nc" id="L330">                return StreamStateCompositeData.toCompositeData(input.getCurrentState());</span>
            }
        }));
    }

    @Override
    public boolean getStreamingStatsEnabled()
    {
<span class="nc" id="L338">        return DatabaseDescriptor.getStreamingStatsEnabled();</span>
    }

    @Override
    public void setStreamingStatsEnabled(boolean streamingStatsEnabled)
    {
<span class="nc" id="L344">        DatabaseDescriptor.setStreamingStatsEnabled(streamingStatsEnabled);</span>
<span class="nc" id="L345">    }</span>

    @Override
    public String getStreamingSlowEventsLogTimeout()
    {
<span class="nc" id="L350">        return DatabaseDescriptor.getStreamingSlowEventsLogTimeout().toString();</span>
    }

    @Override
    public void setStreamingSlowEventsLogTimeout(String value)
    {
<span class="nc" id="L356">        DatabaseDescriptor.setStreamingSlowEventsLogTimeout(value);</span>
<span class="nc" id="L357">    }</span>

    public void registerInitiator(final StreamResultFuture result)
    {
<span class="fc" id="L361">        result.addEventListener(notifier);</span>
        // Make sure we remove the stream on completion (whether successful or not)
<span class="fc" id="L363">        result.addListener(() -&gt; initiatorStreams.remove(result.planId));</span>

<span class="fc" id="L365">        initiatorStreams.put(result.planId, result);</span>
<span class="fc" id="L366">        notifySafeOnRegister(result);</span>
<span class="fc" id="L367">    }</span>

    public StreamResultFuture registerFollower(final StreamResultFuture result)
    {
<span class="fc" id="L371">        result.addEventListener(notifier);</span>
        // Make sure we remove the stream on completion (whether successful or not)
<span class="fc" id="L373">        result.addListener(() -&gt; followerStreams.remove(result.planId));</span>

<span class="fc" id="L375">        StreamResultFuture previous = followerStreams.putIfAbsent(result.planId, result);</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">        if (previous == null)</span>
        {
<span class="fc" id="L378">            notifySafeOnRegister(result);</span>
<span class="fc" id="L379">            return result;</span>
        }
<span class="fc" id="L381">        return previous;</span>
    }

    @VisibleForTesting
    public void putInitiatorStream(StreamResultFuture future)
    {
<span class="fc" id="L387">        StreamResultFuture current = initiatorStreams.putIfAbsent(future.planId, future);</span>
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">        assert current == null: &quot;Duplicat initiator stream for &quot; + future.planId;</span>
<span class="fc" id="L389">    }</span>

    @VisibleForTesting
    public void putFollowerStream(StreamResultFuture future)
    {
<span class="fc" id="L394">        StreamResultFuture current = followerStreams.putIfAbsent(future.planId, future);</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">        assert current == null: &quot;Duplicate follower stream for &quot; + future.planId;</span>
<span class="fc" id="L396">    }</span>

    public void addListener(StreamListener listener)
    {
<span class="fc" id="L400">        listeners.add(listener);</span>
<span class="fc" id="L401">    }</span>

    public void removeListener(StreamListener listener)
    {
<span class="nc" id="L405">        listeners.remove(listener);</span>
<span class="nc" id="L406">    }</span>

    private void notifySafeOnRegister(StreamResultFuture result)
    {
<span class="pc bpc" id="L410" title="1 of 2 branches missed.">        for (StreamListener l : listeners)</span>
        {
            try
            {
<span class="nc" id="L414">                l.onRegister(result);</span>
            }
<span class="nc" id="L416">            catch (Throwable t)</span>
            {
<span class="nc" id="L418">                logger.warn(&quot;Failed to notify stream listener of new Initiator/Follower&quot;, t);</span>
<span class="nc" id="L419">            }</span>
<span class="nc" id="L420">        }</span>
<span class="fc" id="L421">    }</span>

    public StreamResultFuture getReceivingStream(TimeUUID planId)
    {
<span class="fc" id="L425">        return followerStreams.get(planId);</span>
    }

    public StreamResultFuture getInitiatorStream(TimeUUID planId)
    {
<span class="fc" id="L430">        return initiatorStreams.get(planId);</span>
    }

    public void addNotificationListener(NotificationListener listener, NotificationFilter filter, Object handback)
    {
<span class="nc" id="L435">        notifier.addNotificationListener(listener, filter, handback);</span>
<span class="nc" id="L436">    }</span>

    public void removeNotificationListener(NotificationListener listener) throws ListenerNotFoundException
    {
<span class="nc" id="L440">        notifier.removeNotificationListener(listener);</span>
<span class="nc" id="L441">    }</span>

    public void removeNotificationListener(NotificationListener listener, NotificationFilter filter, Object handback) throws ListenerNotFoundException
    {
<span class="nc" id="L445">        notifier.removeNotificationListener(listener, filter, handback);</span>
<span class="nc" id="L446">    }</span>

    public MBeanNotificationInfo[] getNotificationInfo()
    {
<span class="fc" id="L450">        return notifier.getNotificationInfo();</span>
    }

    public StreamSession findSession(InetAddressAndPort peer, TimeUUID planId, int sessionIndex, boolean searchInitiatorSessions)
    {
<span class="fc bfc" id="L455" title="All 2 branches covered.">        Map&lt;TimeUUID, StreamResultFuture&gt; streams = searchInitiatorSessions ? initiatorStreams : followerStreams;</span>
<span class="fc" id="L456">        return findSession(streams, peer, planId, sessionIndex);</span>
    }

    private StreamSession findSession(Map&lt;TimeUUID, StreamResultFuture&gt; streams, InetAddressAndPort peer, TimeUUID planId, int sessionIndex)
    {
<span class="fc" id="L461">        StreamResultFuture streamResultFuture = streams.get(planId);</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">        if (streamResultFuture == null)</span>
<span class="fc" id="L463">            return null;</span>

<span class="fc" id="L465">        return streamResultFuture.getSession(peer, sessionIndex);</span>
    }

    public long getTotalRemainingOngoingBytes()
    {
<span class="fc" id="L470">        long total = 0;</span>
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">        for (StreamResultFuture fut : Iterables.concat(initiatorStreams.values(), followerStreams.values()))</span>
        {
<span class="nc bnc" id="L473" title="All 2 branches missed.">            for (SessionInfo sessionInfo : fut.getCurrentState().sessions)</span>
<span class="nc" id="L474">                total += sessionInfo.getTotalSizeToReceive() - sessionInfo.getTotalSizeReceived();</span>
<span class="nc" id="L475">        }</span>
<span class="fc" id="L476">        return total;</span>
    }

    public interface StreamListener
    {
<span class="nc" id="L481">        default void onRegister(StreamResultFuture result) {}</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>