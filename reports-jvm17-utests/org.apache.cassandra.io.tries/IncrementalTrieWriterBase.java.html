<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IncrementalTrieWriterBase.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.io.tries</a> &gt; <span class="el_source">IncrementalTrieWriterBase.java</span></div><h1>IncrementalTrieWriterBase.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.io.tries;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;

import org.apache.cassandra.utils.bytecomparable.ByteComparable;
import org.apache.cassandra.utils.bytecomparable.ByteSource;
import org.apache.cassandra.utils.concurrent.LightweightRecycler;
import org.apache.cassandra.utils.concurrent.ThreadLocals;

/**
 * Helper base class for incremental trie builders.
 */
<span class="fc" id="L34">public abstract class IncrementalTrieWriterBase&lt;VALUE, DEST, NODE extends IncrementalTrieWriterBase.BaseNode&lt;VALUE, NODE&gt;&gt;</span>
implements IncrementalTrieWriter&lt;VALUE&gt;
{
<span class="fc" id="L37">    protected final Deque&lt;NODE&gt; stack = new ArrayDeque&lt;&gt;();</span>
    protected final TrieSerializer&lt;VALUE, ? super DEST&gt; serializer;
    protected final DEST dest;
<span class="fc" id="L40">    protected ByteComparable prev = null;</span>
<span class="fc" id="L41">    long count = 0;</span>

    protected IncrementalTrieWriterBase(TrieSerializer&lt;VALUE, ? super DEST&gt; serializer, DEST dest, NODE root)
<span class="fc" id="L44">    {</span>
<span class="fc" id="L45">        this.serializer = serializer;</span>
<span class="fc" id="L46">        this.dest = dest;</span>
<span class="fc" id="L47">        this.stack.addLast(root);</span>
<span class="fc" id="L48">    }</span>

    protected void reset(NODE root)
    {
<span class="fc" id="L52">        this.prev = null;</span>
<span class="fc" id="L53">        this.count = 0;</span>
<span class="fc" id="L54">        this.stack.clear();</span>
<span class="fc" id="L55">        this.stack.addLast(root);</span>
<span class="fc" id="L56">    }</span>


    @Override
    public void close()
    {
<span class="fc" id="L62">        this.prev = null;</span>
<span class="fc" id="L63">        this.count = 0;</span>
<span class="fc" id="L64">        this.stack.clear();</span>
<span class="fc" id="L65">    }</span>

    @Override
    public void add(ByteComparable next, VALUE value) throws IOException
    {
<span class="fc" id="L70">        ++count;</span>
<span class="fc" id="L71">        int stackpos = 0;</span>
<span class="fc" id="L72">        ByteSource sn = next.asComparableBytes(Walker.BYTE_COMPARABLE_VERSION);</span>
<span class="fc" id="L73">        int n = sn.next();</span>

<span class="fc bfc" id="L75" title="All 2 branches covered.">        if (prev != null)</span>
        {
<span class="fc" id="L77">            ByteSource sp = prev.asComparableBytes(Walker.BYTE_COMPARABLE_VERSION);</span>
<span class="fc" id="L78">            int p = sp.next();</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">            while ( n == p )</span>
            {
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">                assert n != ByteSource.END_OF_STREAM : String.format(&quot;Incremental trie requires unique sorted keys, got equal %s(%s) after %s(%s).&quot;,</span>
                                                                     next,
<span class="nc" id="L83">                                                                     next.byteComparableAsString(Walker.BYTE_COMPARABLE_VERSION),</span>
                                                                     prev,
<span class="nc" id="L85">                                                                     prev.byteComparableAsString(Walker.BYTE_COMPARABLE_VERSION));</span>

<span class="fc" id="L87">                ++stackpos;</span>
<span class="fc" id="L88">                n = sn.next();</span>
<span class="fc" id="L89">                p = sp.next();</span>
            }
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">            assert p &lt; n : String.format(&quot;Incremental trie requires sorted keys, got %s(%s) after %s(%s).&quot;,</span>
                                         next,
<span class="nc" id="L93">                                         next.byteComparableAsString(Walker.BYTE_COMPARABLE_VERSION),</span>
                                         prev,
<span class="nc" id="L95">                                         prev.byteComparableAsString(Walker.BYTE_COMPARABLE_VERSION));</span>
        }
<span class="fc" id="L97">        prev = next;</span>

<span class="fc bfc" id="L99" title="All 2 branches covered.">        while (stack.size() &gt; stackpos + 1)</span>
<span class="fc" id="L100">            completeLast();</span>

<span class="fc" id="L102">        NODE node = stack.getLast();</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">        while (n != ByteSource.END_OF_STREAM)</span>
        {
<span class="fc" id="L105">            node = node.addChild((byte) n);</span>
<span class="fc" id="L106">            stack.addLast(node);</span>
<span class="fc" id="L107">            ++stackpos;</span>
<span class="fc" id="L108">            n = sn.next();</span>
        }

<span class="fc" id="L111">        VALUE existingPayload = node.setPayload(value);</span>
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">        assert existingPayload == null;</span>
<span class="fc" id="L113">    }</span>

    public long complete() throws IOException
    {
<span class="fc" id="L117">        NODE root = stack.getFirst();</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">        if (root.filePos != -1)</span>
<span class="nc" id="L119">            return root.filePos;</span>

<span class="fc" id="L121">        return performCompletion().filePos;</span>
    }

    NODE performCompletion() throws IOException
    {
<span class="fc" id="L126">        NODE root = null;</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">        while (!stack.isEmpty())</span>
<span class="fc" id="L128">            root = completeLast();</span>
<span class="fc" id="L129">        stack.addLast(root);</span>
<span class="fc" id="L130">        return root;</span>
    }

    public long count()
    {
<span class="fc" id="L135">        return count;</span>
    }

    protected NODE completeLast() throws IOException
    {
<span class="fc" id="L140">        NODE node = stack.removeLast();</span>
<span class="fc" id="L141">        complete(node);</span>
<span class="fc" id="L142">        return node;</span>
    }

    abstract void complete(NODE value) throws IOException;
    abstract public PartialTail makePartialRoot() throws IOException;

<span class="fc" id="L148">    static class PTail implements PartialTail</span>
    {
        long root;
        long cutoff;
        long count;
        ByteBuffer tail;

        @Override
        public long root()
        {
<span class="fc" id="L158">            return root;</span>
        }

        @Override
        public long cutoff()
        {
<span class="fc" id="L164">            return cutoff;</span>
        }

        @Override
        public ByteBuffer tail()
        {
<span class="fc" id="L170">            return tail;</span>
        }

        @Override
        public long count()
        {
<span class="fc" id="L176">            return count;</span>
        }
    }

    static abstract class BaseNode&lt;VALUE, NODE extends BaseNode&lt;VALUE, NODE&gt;&gt; implements SerializationNode&lt;VALUE&gt;
    {
        private static final int CHILDREN_LIST_RECYCLER_LIMIT = 1024;
        @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L184">        private static final LightweightRecycler&lt;ArrayList&gt; CHILDREN_LIST_RECYCLER = ThreadLocals.createLightweightRecycler(CHILDREN_LIST_RECYCLER_LIMIT);</span>
        @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L186">        private static final ArrayList EMPTY_LIST = new ArrayList&lt;&gt;(0);</span>

        @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
        private static &lt;NODE&gt; ArrayList&lt;NODE&gt; allocateChildrenList()
        {
<span class="fc" id="L191">            return CHILDREN_LIST_RECYCLER.reuseOrAllocate(() -&gt; new ArrayList(4));</span>
        }

        private static &lt;NODE&gt; void recycleChildrenList(ArrayList&lt;NODE&gt; children)
        {
<span class="fc" id="L196">            CHILDREN_LIST_RECYCLER.tryRecycle(children);</span>
<span class="fc" id="L197">        }</span>

        VALUE payload;
        ArrayList&lt;NODE&gt; children;
        final int transition;
<span class="fc" id="L202">        long filePos = -1;</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        BaseNode(int transition)
<span class="fc" id="L206">        {</span>
<span class="fc" id="L207">            children = EMPTY_LIST;</span>
<span class="fc" id="L208">            this.transition = transition;</span>
<span class="fc" id="L209">        }</span>

        public VALUE payload()
        {
<span class="fc" id="L213">            return payload;</span>
        }

        public VALUE setPayload(VALUE newPayload)
        {
<span class="fc" id="L218">            VALUE p = payload;</span>
<span class="fc" id="L219">            payload = newPayload;</span>
<span class="fc" id="L220">            return p;</span>
        }

        public NODE addChild(byte b)
        {
<span class="pc bpc" id="L225" title="1 of 4 branches missed.">            assert children.isEmpty() || (children.get(children.size() - 1).transition &amp; 0xFF) &lt; (b &amp; 0xFF);</span>
<span class="fc" id="L226">            NODE node = newNode(b);</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">            if (children == EMPTY_LIST)</span>
<span class="fc" id="L228">                children = allocateChildrenList();</span>

<span class="fc" id="L230">            children.add(node);</span>
<span class="fc" id="L231">            return node;</span>
        }

        public int childCount()
        {
<span class="fc" id="L236">            return children.size();</span>
        }

        void finalizeWithPosition(long position)
        {
<span class="fc" id="L241">            this.filePos = position;</span>

            // Make sure we are not holding on to pointers to data we no longer need
            // (otherwise we keep the whole trie in memory).
<span class="fc bfc" id="L245" title="All 2 branches covered.">            if (children != EMPTY_LIST)</span>
                // the recycler will also clear the collection before adding it to the pool
<span class="fc" id="L247">                recycleChildrenList(children);</span>

<span class="fc" id="L249">            children = null;</span>
<span class="fc" id="L250">            payload = null;</span>
<span class="fc" id="L251">        }</span>

        public int transition(int i)
        {
<span class="fc" id="L255">            return children.get(i).transition;</span>
        }

        @Override
        public String toString()
        {
<span class="fc" id="L261">            return String.format(&quot;%02x&quot;, transition);</span>
        }

        abstract NODE newNode(byte transition);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>