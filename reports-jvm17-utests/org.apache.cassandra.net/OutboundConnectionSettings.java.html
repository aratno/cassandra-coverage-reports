<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OutboundConnectionSettings.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.net</a> &gt; <span class="el_source">OutboundConnectionSettings.java</span></div><h1>OutboundConnectionSettings.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.net;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;

import io.netty.channel.WriteBufferWaterMark;
import org.apache.cassandra.auth.IInternodeAuthenticator;
import org.apache.cassandra.config.CassandraRelevantProperties;
import org.apache.cassandra.config.Config;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.config.EncryptionOptions.ServerEncryptionOptions;
import org.apache.cassandra.db.SystemKeyspace;
import org.apache.cassandra.locator.IEndpointSnitch;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.utils.FBUtilities;

import static org.apache.cassandra.config.DatabaseDescriptor.getEndpointSnitch;
import static org.apache.cassandra.net.MessagingService.instance;
import static org.apache.cassandra.utils.FBUtilities.getBroadcastAddressAndPort;

/**
 * A collection of settings to be passed around for outbound connections.
 */
@SuppressWarnings({ &quot;WeakerAccess&quot;, &quot;unused&quot; })
public class OutboundConnectionSettings
{
    /**
     * Enabled/disable TCP_NODELAY for intradc connections. Defaults to enabled.
     */
<span class="fc" id="L48">    private static final boolean INTRADC_TCP_NODELAY = CassandraRelevantProperties.OTC_INTRADC_TCP_NODELAY.getBoolean();</span>

<span class="fc" id="L50">    public enum Framing</span>
    {
        // uses simple unprotected frames with header crc but no payload protection
<span class="fc" id="L53">        UNPROTECTED(0),</span>
        // uses our framing format with header crc24
<span class="fc" id="L55">        LZ4(1),</span>
        // uses simple frames with separate header and payload crc
<span class="fc" id="L57">        CRC(2);</span>

        public static Framing forId(int id)
        {
<span class="pc bpc" id="L61" title="1 of 4 branches missed.">            switch (id)</span>
            {
<span class="fc" id="L63">                case 0: return UNPROTECTED;</span>
<span class="fc" id="L64">                case 1: return LZ4;</span>
<span class="fc" id="L65">                case 2: return CRC;</span>
            }
<span class="nc" id="L67">            throw new IllegalStateException();</span>
        }

        final int id;
        Framing(int id)
<span class="fc" id="L72">        {</span>
<span class="fc" id="L73">            this.id = id;</span>
<span class="fc" id="L74">        }</span>
    }

    public final IInternodeAuthenticator authenticator;
    public final InetAddressAndPort to;
    public final InetAddressAndPort connectTo; // may be represented by a different IP address on this node's local network
    public final ServerEncryptionOptions encryption;
    public final Framing framing;
    public final Integer socketSendBufferSizeInBytes;
    public final Integer applicationSendQueueCapacityInBytes;
    public final Integer applicationSendQueueReserveEndpointCapacityInBytes;
    public final ResourceLimits.Limit applicationSendQueueReserveGlobalCapacityInBytes;
    public final Boolean tcpNoDelay;
    public final int flushLowWaterMark, flushHighWaterMark;
    public final Integer tcpConnectTimeoutInMS;
    public final Integer tcpUserTimeoutInMS;
    public final AcceptVersions acceptVersions;
    public final InetAddressAndPort from;
    public final SocketFactory socketFactory;
    public final OutboundMessageCallbacks callbacks;
    public final OutboundDebugCallbacks debug;
    public final EndpointMessagingVersions endpointToVersion;

    public OutboundConnectionSettings(InetAddressAndPort to)
    {
<span class="fc" id="L99">        this(to, null);</span>
<span class="fc" id="L100">    }</span>

    public OutboundConnectionSettings(InetAddressAndPort to, InetAddressAndPort preferred)
    {
<span class="fc" id="L104">        this(null, to, preferred, null, null, null, null, null, null, null, 1 &lt;&lt; 15, 1 &lt;&lt; 16, null, null, null, null, null, null, null, null);</span>
<span class="fc" id="L105">    }</span>

    private OutboundConnectionSettings(IInternodeAuthenticator authenticator,
                                       InetAddressAndPort to,
                                       InetAddressAndPort connectTo,
                                       ServerEncryptionOptions encryption,
                                       Framing framing,
                                       Integer socketSendBufferSizeInBytes,
                                       Integer applicationSendQueueCapacityInBytes,
                                       Integer applicationSendQueueReserveEndpointCapacityInBytes,
                                       ResourceLimits.Limit applicationSendQueueReserveGlobalCapacityInBytes,
                                       Boolean tcpNoDelay,
                                       int flushLowWaterMark,
                                       int flushHighWaterMark,
                                       Integer tcpConnectTimeoutInMS,
                                       Integer tcpUserTimeoutInMS,
                                       AcceptVersions acceptVersions,
                                       InetAddressAndPort from,
                                       SocketFactory socketFactory,
                                       OutboundMessageCallbacks callbacks,
                                       OutboundDebugCallbacks debug,
                                       EndpointMessagingVersions endpointToVersion)
<span class="fc" id="L127">    {</span>
<span class="pc bpc" id="L128" title="1 of 6 branches missed.">        Preconditions.checkArgument(socketSendBufferSizeInBytes == null || socketSendBufferSizeInBytes == 0 || socketSendBufferSizeInBytes &gt;= 1 &lt;&lt; 10, &quot;illegal socket send buffer size: &quot; + socketSendBufferSizeInBytes);</span>
<span class="pc bpc" id="L129" title="1 of 4 branches missed.">        Preconditions.checkArgument(applicationSendQueueCapacityInBytes == null || applicationSendQueueCapacityInBytes &gt;= 1 &lt;&lt; 10, &quot;illegal application send queue capacity: &quot; + applicationSendQueueCapacityInBytes);</span>
<span class="fc bfc" id="L130" title="All 4 branches covered.">        Preconditions.checkArgument(tcpUserTimeoutInMS == null || tcpUserTimeoutInMS &gt;= 0, &quot;tcp user timeout must be non negative: &quot; + tcpUserTimeoutInMS);</span>
<span class="fc bfc" id="L131" title="All 4 branches covered.">        Preconditions.checkArgument(tcpConnectTimeoutInMS == null || tcpConnectTimeoutInMS &gt; 0, &quot;tcp connect timeout must be positive: &quot; + tcpConnectTimeoutInMS);</span>
<span class="pc bpc" id="L132" title="1 of 6 branches missed.">        Preconditions.checkArgument(acceptVersions == null || acceptVersions.min &gt;= MessagingService.minimum_version, &quot;acceptVersions.min must be minimum_version or higher: &quot; + (acceptVersions == null ? null : acceptVersions.min));</span>

<span class="fc" id="L134">        this.authenticator = authenticator;</span>
<span class="fc" id="L135">        this.to = to;</span>
<span class="fc" id="L136">        this.connectTo = connectTo;</span>
<span class="fc" id="L137">        this.encryption = encryption;</span>
<span class="fc" id="L138">        this.framing = framing;</span>
<span class="fc" id="L139">        this.socketSendBufferSizeInBytes = socketSendBufferSizeInBytes;</span>
<span class="fc" id="L140">        this.applicationSendQueueCapacityInBytes = applicationSendQueueCapacityInBytes;</span>
<span class="fc" id="L141">        this.applicationSendQueueReserveEndpointCapacityInBytes = applicationSendQueueReserveEndpointCapacityInBytes;</span>
<span class="fc" id="L142">        this.applicationSendQueueReserveGlobalCapacityInBytes = applicationSendQueueReserveGlobalCapacityInBytes;</span>
<span class="fc" id="L143">        this.tcpNoDelay = tcpNoDelay;</span>
<span class="fc" id="L144">        this.flushLowWaterMark = flushLowWaterMark;</span>
<span class="fc" id="L145">        this.flushHighWaterMark = flushHighWaterMark;</span>
<span class="fc" id="L146">        this.tcpConnectTimeoutInMS = tcpConnectTimeoutInMS;</span>
<span class="fc" id="L147">        this.tcpUserTimeoutInMS = tcpUserTimeoutInMS;</span>
<span class="fc" id="L148">        this.acceptVersions = acceptVersions;</span>
<span class="fc" id="L149">        this.from = from;</span>
<span class="fc" id="L150">        this.socketFactory = socketFactory;</span>
<span class="fc" id="L151">        this.callbacks = callbacks;</span>
<span class="fc" id="L152">        this.debug = debug;</span>
<span class="fc" id="L153">        this.endpointToVersion = endpointToVersion;</span>
<span class="fc" id="L154">    }</span>

    public boolean withEncryption()
    {
<span class="fc bfc" id="L158" title="All 2 branches covered.">        return encryption != null;</span>
    }

    public String toString()
    {
<span class="fc" id="L163">        return String.format(&quot;peer: (%s, %s), framing: %s, encryption: %s&quot;,</span>
<span class="fc" id="L164">                             to, connectTo, framing, SocketFactory.encryptionOptionsSummary(encryption));</span>
    }

    public OutboundConnectionSettings withAuthenticator(IInternodeAuthenticator authenticator)
    {
<span class="nc" id="L169">        return new OutboundConnectionSettings(authenticator, to, connectTo, encryption, framing,</span>
                                              socketSendBufferSizeInBytes, applicationSendQueueCapacityInBytes,
                                              applicationSendQueueReserveEndpointCapacityInBytes, applicationSendQueueReserveGlobalCapacityInBytes,
                                              tcpNoDelay, flushLowWaterMark, flushHighWaterMark, tcpConnectTimeoutInMS,
                                              tcpUserTimeoutInMS, acceptVersions, from, socketFactory, callbacks, debug, endpointToVersion);
    }

    @SuppressWarnings(&quot;unused&quot;)
    public OutboundConnectionSettings toEndpoint(InetAddressAndPort endpoint)
    {
<span class="nc" id="L179">        return new OutboundConnectionSettings(authenticator, endpoint, connectTo, encryption, framing,</span>
                                              socketSendBufferSizeInBytes, applicationSendQueueCapacityInBytes,
                                              applicationSendQueueReserveEndpointCapacityInBytes, applicationSendQueueReserveGlobalCapacityInBytes,
                                              tcpNoDelay, flushLowWaterMark, flushHighWaterMark, tcpConnectTimeoutInMS,
                                              tcpUserTimeoutInMS, acceptVersions, from, socketFactory, callbacks, debug, endpointToVersion);
    }

    public OutboundConnectionSettings withConnectTo(InetAddressAndPort connectTo)
    {
<span class="fc" id="L188">        return new OutboundConnectionSettings(authenticator, to, connectTo, encryption, framing,</span>
                                              socketSendBufferSizeInBytes, applicationSendQueueCapacityInBytes,
                                              applicationSendQueueReserveEndpointCapacityInBytes, applicationSendQueueReserveGlobalCapacityInBytes,
                                              tcpNoDelay, flushLowWaterMark, flushHighWaterMark, tcpConnectTimeoutInMS,
                                              tcpUserTimeoutInMS, acceptVersions, from, socketFactory, callbacks, debug, endpointToVersion);
    }

    public OutboundConnectionSettings withEncryption(ServerEncryptionOptions encryption)
    {
<span class="fc" id="L197">        return new OutboundConnectionSettings(authenticator, to, connectTo, encryption, framing,</span>
                                              socketSendBufferSizeInBytes, applicationSendQueueCapacityInBytes,
                                              applicationSendQueueReserveEndpointCapacityInBytes, applicationSendQueueReserveGlobalCapacityInBytes,
                                              tcpNoDelay, flushLowWaterMark, flushHighWaterMark, tcpConnectTimeoutInMS,
                                              tcpUserTimeoutInMS, acceptVersions, from, socketFactory, callbacks, debug, endpointToVersion);
    }

    @SuppressWarnings(&quot;unused&quot;)
    public OutboundConnectionSettings withFraming(Framing framing)
    {
<span class="fc" id="L207">        return new OutboundConnectionSettings(authenticator, to, connectTo, encryption, framing, socketSendBufferSizeInBytes, applicationSendQueueCapacityInBytes,</span>
                                              applicationSendQueueReserveEndpointCapacityInBytes, applicationSendQueueReserveGlobalCapacityInBytes,
                                              tcpNoDelay, flushLowWaterMark, flushHighWaterMark, tcpConnectTimeoutInMS,
                                              tcpUserTimeoutInMS, acceptVersions, from, socketFactory, callbacks, debug, endpointToVersion);
    }

    public OutboundConnectionSettings withSocketSendBufferSizeInBytes(int socketSendBufferSizeInBytes)
    {
<span class="pc" id="L215">        return new OutboundConnectionSettings(authenticator, to, connectTo, encryption, framing,</span>
<span class="nc" id="L216">                                              socketSendBufferSizeInBytes, applicationSendQueueCapacityInBytes,</span>
                                              applicationSendQueueReserveEndpointCapacityInBytes, applicationSendQueueReserveGlobalCapacityInBytes,
                                              tcpNoDelay, flushLowWaterMark, flushHighWaterMark, tcpConnectTimeoutInMS,
                                              tcpUserTimeoutInMS, acceptVersions, from, socketFactory, callbacks, debug, endpointToVersion);
    }

    @SuppressWarnings(&quot;unused&quot;)
    public OutboundConnectionSettings withApplicationSendQueueCapacityInBytes(int applicationSendQueueCapacityInBytes)
    {
<span class="fc" id="L225">        return new OutboundConnectionSettings(authenticator, to, connectTo, encryption, framing,</span>
<span class="fc" id="L226">                                              socketSendBufferSizeInBytes, applicationSendQueueCapacityInBytes,</span>
                                              applicationSendQueueReserveEndpointCapacityInBytes, applicationSendQueueReserveGlobalCapacityInBytes,
                                              tcpNoDelay, flushLowWaterMark, flushHighWaterMark, tcpConnectTimeoutInMS,
                                              tcpUserTimeoutInMS, acceptVersions, from, socketFactory, callbacks, debug, endpointToVersion);
    }

    public OutboundConnectionSettings withApplicationReserveSendQueueCapacityInBytes(Integer applicationReserveSendQueueEndpointCapacityInBytes, ResourceLimits.Limit applicationReserveSendQueueGlobalCapacityInBytes)
    {
<span class="fc" id="L234">        return new OutboundConnectionSettings(authenticator, to, connectTo, encryption, framing,</span>
                                              socketSendBufferSizeInBytes, applicationSendQueueCapacityInBytes,
                                              applicationReserveSendQueueEndpointCapacityInBytes, applicationReserveSendQueueGlobalCapacityInBytes,
                                              tcpNoDelay, flushLowWaterMark, flushHighWaterMark, tcpConnectTimeoutInMS,
                                              tcpUserTimeoutInMS, acceptVersions, from, socketFactory, callbacks, debug, endpointToVersion);
    }

    @SuppressWarnings(&quot;unused&quot;)
    public OutboundConnectionSettings withTcpNoDelay(boolean tcpNoDelay)
    {
<span class="nc" id="L244">        return new OutboundConnectionSettings(authenticator, to, connectTo, encryption, framing,</span>
                                              socketSendBufferSizeInBytes, applicationSendQueueCapacityInBytes,
                                              applicationSendQueueReserveEndpointCapacityInBytes, applicationSendQueueReserveGlobalCapacityInBytes,
<span class="nc" id="L247">                                              tcpNoDelay, flushLowWaterMark, flushHighWaterMark, tcpConnectTimeoutInMS,</span>
                                              tcpUserTimeoutInMS, acceptVersions, from, socketFactory, callbacks, debug, endpointToVersion);
    }

    @SuppressWarnings(&quot;unused&quot;)
    public OutboundConnectionSettings withNettyBufferBounds(WriteBufferWaterMark nettyBufferBounds)
    {
<span class="nc" id="L254">        return new OutboundConnectionSettings(authenticator, to, connectTo, encryption, framing,</span>
                                              socketSendBufferSizeInBytes, applicationSendQueueCapacityInBytes,
                                              applicationSendQueueReserveEndpointCapacityInBytes, applicationSendQueueReserveGlobalCapacityInBytes,
                                              tcpNoDelay, flushLowWaterMark, flushHighWaterMark, tcpConnectTimeoutInMS,
                                              tcpUserTimeoutInMS, acceptVersions, from, socketFactory, callbacks, debug, endpointToVersion);
    }

    public OutboundConnectionSettings withTcpConnectTimeoutInMS(int tcpConnectTimeoutInMS)
    {
<span class="pc" id="L263">        return new OutboundConnectionSettings(authenticator, to, connectTo, encryption, framing,</span>
                                              socketSendBufferSizeInBytes, applicationSendQueueCapacityInBytes,
                                              applicationSendQueueReserveEndpointCapacityInBytes, applicationSendQueueReserveGlobalCapacityInBytes,
<span class="nc" id="L266">                                              tcpNoDelay, flushLowWaterMark, flushHighWaterMark, tcpConnectTimeoutInMS,</span>
                                              tcpUserTimeoutInMS, acceptVersions, from, socketFactory, callbacks, debug, endpointToVersion);
    }

    public OutboundConnectionSettings withTcpUserTimeoutInMS(int tcpUserTimeoutInMS)
    {
<span class="fc" id="L272">        return new OutboundConnectionSettings(authenticator, to, connectTo, encryption, framing,</span>
                                              socketSendBufferSizeInBytes, applicationSendQueueCapacityInBytes,
                                              applicationSendQueueReserveEndpointCapacityInBytes, applicationSendQueueReserveGlobalCapacityInBytes,
                                              tcpNoDelay, flushLowWaterMark, flushHighWaterMark, tcpConnectTimeoutInMS,
<span class="fc" id="L276">                                              tcpUserTimeoutInMS, acceptVersions, from, socketFactory, callbacks, debug, endpointToVersion);</span>
    }

    public OutboundConnectionSettings withAcceptVersions(AcceptVersions acceptVersions)
    {
<span class="fc" id="L281">        return new OutboundConnectionSettings(authenticator, to, connectTo, encryption, framing,</span>
                                              socketSendBufferSizeInBytes, applicationSendQueueCapacityInBytes,
                                              applicationSendQueueReserveEndpointCapacityInBytes, applicationSendQueueReserveGlobalCapacityInBytes,
                                              tcpNoDelay, flushLowWaterMark, flushHighWaterMark, tcpConnectTimeoutInMS,
                                              tcpUserTimeoutInMS, acceptVersions, from, socketFactory, callbacks, debug, endpointToVersion);
    }

    public OutboundConnectionSettings withFrom(InetAddressAndPort from)
    {
<span class="fc" id="L290">        return new OutboundConnectionSettings(authenticator, to, connectTo, encryption, framing,</span>
                                              socketSendBufferSizeInBytes, applicationSendQueueCapacityInBytes,
                                              applicationSendQueueReserveEndpointCapacityInBytes, applicationSendQueueReserveGlobalCapacityInBytes,
                                              tcpNoDelay, flushLowWaterMark, flushHighWaterMark, tcpConnectTimeoutInMS,
                                              tcpUserTimeoutInMS, acceptVersions, from, socketFactory, callbacks, debug, endpointToVersion);
    }

    public OutboundConnectionSettings withSocketFactory(SocketFactory socketFactory)
    {
<span class="fc" id="L299">        return new OutboundConnectionSettings(authenticator, to, connectTo, encryption, framing,</span>
                                              socketSendBufferSizeInBytes, applicationSendQueueCapacityInBytes,
                                              applicationSendQueueReserveEndpointCapacityInBytes, applicationSendQueueReserveGlobalCapacityInBytes,
                                              tcpNoDelay, flushLowWaterMark, flushHighWaterMark, tcpConnectTimeoutInMS,
                                              tcpUserTimeoutInMS, acceptVersions, from, socketFactory, callbacks, debug, endpointToVersion);
    }

    public OutboundConnectionSettings withCallbacks(OutboundMessageCallbacks callbacks)
    {
<span class="nc" id="L308">        return new OutboundConnectionSettings(authenticator, to, connectTo, encryption, framing,</span>
                                              socketSendBufferSizeInBytes, applicationSendQueueCapacityInBytes,
                                              applicationSendQueueReserveEndpointCapacityInBytes, applicationSendQueueReserveGlobalCapacityInBytes,
                                              tcpNoDelay, flushLowWaterMark, flushHighWaterMark, tcpConnectTimeoutInMS,
                                              tcpUserTimeoutInMS, acceptVersions, from, socketFactory, callbacks, debug, endpointToVersion);
    }

    public OutboundConnectionSettings withDebugCallbacks(OutboundDebugCallbacks debug)
    {
<span class="fc" id="L317">        return new OutboundConnectionSettings(authenticator, to, connectTo, encryption, framing,</span>
                                              socketSendBufferSizeInBytes, applicationSendQueueCapacityInBytes,
                                              applicationSendQueueReserveEndpointCapacityInBytes, applicationSendQueueReserveGlobalCapacityInBytes,
                                              tcpNoDelay, flushLowWaterMark, flushHighWaterMark, tcpConnectTimeoutInMS,
                                              tcpUserTimeoutInMS, acceptVersions, from, socketFactory, callbacks, debug, endpointToVersion);
    }

    public OutboundConnectionSettings withDefaultReserveLimits()
    {
<span class="fc" id="L326">        Integer applicationReserveSendQueueEndpointCapacityInBytes = this.applicationSendQueueReserveEndpointCapacityInBytes;</span>
<span class="fc" id="L327">        ResourceLimits.Limit applicationReserveSendQueueGlobalCapacityInBytes = this.applicationSendQueueReserveGlobalCapacityInBytes;</span>

<span class="fc bfc" id="L329" title="All 2 branches covered.">        if (applicationReserveSendQueueEndpointCapacityInBytes == null)</span>
<span class="fc" id="L330">            applicationReserveSendQueueEndpointCapacityInBytes = DatabaseDescriptor.getInternodeApplicationSendQueueReserveEndpointCapacityInBytes();</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">        if (applicationReserveSendQueueGlobalCapacityInBytes == null)</span>
<span class="fc" id="L332">            applicationReserveSendQueueGlobalCapacityInBytes = MessagingService.instance().outboundGlobalReserveLimit;</span>

<span class="fc" id="L334">        return withApplicationReserveSendQueueCapacityInBytes(applicationReserveSendQueueEndpointCapacityInBytes, applicationReserveSendQueueGlobalCapacityInBytes);</span>
    }

    public IInternodeAuthenticator authenticator()
    {
<span class="fc bfc" id="L339" title="All 2 branches covered.">        return authenticator != null ? authenticator : DatabaseDescriptor.getInternodeAuthenticator();</span>
    }

    public EndpointMessagingVersions endpointToVersion()
    {
<span class="fc bfc" id="L344" title="All 2 branches covered.">        if (endpointToVersion == null)</span>
<span class="fc" id="L345">            return instance().versions;</span>
<span class="fc" id="L346">        return endpointToVersion;</span>
    }

    public InetAddressAndPort from()
    {
<span class="fc bfc" id="L351" title="All 2 branches covered.">        return from != null ? from : FBUtilities.getBroadcastAddressAndPort();</span>
    }

    public OutboundDebugCallbacks debug()
    {
<span class="fc bfc" id="L356" title="All 2 branches covered.">        return debug != null ? debug : OutboundDebugCallbacks.NONE;</span>
    }

    public ServerEncryptionOptions encryption()
    {
<span class="fc bfc" id="L361" title="All 2 branches covered.">        return encryption != null ? encryption : defaultEncryptionOptions(to);</span>
    }

    public SocketFactory socketFactory()
    {
<span class="fc bfc" id="L366" title="All 2 branches covered.">        return socketFactory != null ? socketFactory : instance().socketFactory;</span>
    }

    public OutboundMessageCallbacks callbacks()
    {
<span class="fc bfc" id="L371" title="All 2 branches covered.">        return callbacks != null ? callbacks : instance().callbacks;</span>
    }

    public int socketSendBufferSizeInBytes()
    {
<span class="fc bfc" id="L376" title="All 2 branches covered.">        return socketSendBufferSizeInBytes != null ? socketSendBufferSizeInBytes</span>
<span class="fc" id="L377">                                                   : DatabaseDescriptor.getInternodeSocketSendBufferSizeInBytes();</span>
    }

    public int applicationSendQueueCapacityInBytes()
    {
<span class="fc bfc" id="L382" title="All 2 branches covered.">        return applicationSendQueueCapacityInBytes != null ? applicationSendQueueCapacityInBytes</span>
<span class="fc" id="L383">                                                           : DatabaseDescriptor.getInternodeApplicationSendQueueCapacityInBytes();</span>
    }

    public ResourceLimits.Limit applicationSendQueueReserveGlobalCapacityInBytes()
    {
<span class="fc bfc" id="L388" title="All 2 branches covered.">        return applicationSendQueueReserveGlobalCapacityInBytes != null ? applicationSendQueueReserveGlobalCapacityInBytes</span>
<span class="fc" id="L389">                                                                        : instance().outboundGlobalReserveLimit;</span>
    }

    public int applicationSendQueueReserveEndpointCapacityInBytes()
    {
<span class="fc bfc" id="L394" title="All 2 branches covered.">        return applicationSendQueueReserveEndpointCapacityInBytes != null ? applicationSendQueueReserveEndpointCapacityInBytes</span>
<span class="fc" id="L395">                                                                          : DatabaseDescriptor.getInternodeApplicationReceiveQueueReserveEndpointCapacityInBytes();</span>
    }

    public int tcpConnectTimeoutInMS()
    {
<span class="fc bfc" id="L400" title="All 2 branches covered.">        return tcpConnectTimeoutInMS != null ? tcpConnectTimeoutInMS</span>
<span class="fc" id="L401">                                             : DatabaseDescriptor.getInternodeTcpConnectTimeoutInMS();</span>
    }

    public int tcpUserTimeoutInMS(ConnectionCategory category)
    {
        // Reusing tcpUserTimeoutInMS for both messaging and streaming, since the connection is created for either one of them.
<span class="fc bfc" id="L407" title="All 2 branches covered.">        if (tcpUserTimeoutInMS != null)</span>
<span class="fc" id="L408">            return tcpUserTimeoutInMS;</span>

<span class="pc bpc" id="L410" title="1 of 3 branches missed.">        switch (category)</span>
        {
<span class="fc" id="L412">            case MESSAGING: return DatabaseDescriptor.getInternodeTcpUserTimeoutInMS();</span>
<span class="fc" id="L413">            case STREAMING: return DatabaseDescriptor.getInternodeStreamingTcpUserTimeoutInMS();</span>
<span class="nc" id="L414">            default: throw new IllegalArgumentException(&quot;Unknown connection category: &quot; + category);</span>
        }
    }

    public boolean tcpNoDelay()
    {
<span class="fc bfc" id="L420" title="All 2 branches covered.">        if (tcpNoDelay != null)</span>
<span class="fc" id="L421">            return tcpNoDelay;</span>

<span class="fc bfc" id="L423" title="All 2 branches covered.">        if (isInLocalDC(getEndpointSnitch(), getBroadcastAddressAndPort(), to))</span>
<span class="fc" id="L424">            return INTRADC_TCP_NODELAY;</span>

<span class="fc" id="L426">        return DatabaseDescriptor.getInterDCTcpNoDelay();</span>
    }

    public AcceptVersions acceptVersions(ConnectionCategory category)
    {
<span class="fc bfc" id="L431" title="All 2 branches covered.">        return acceptVersions != null ? acceptVersions</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">                                      : category.isStreaming()</span>
<span class="fc" id="L433">                                        ? MessagingService.accept_streaming</span>
<span class="fc" id="L434">                                        : MessagingService.accept_messaging;</span>
    }

    public InetAddressAndPort connectTo()
    {
<span class="fc" id="L439">        InetAddressAndPort connectTo = this.connectTo;</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">        if (connectTo == null)</span>
<span class="fc" id="L441">            connectTo = SystemKeyspace.getPreferredIP(to);</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">        if (FBUtilities.getBroadcastAddressAndPort().equals(connectTo))</span>
<span class="fc" id="L443">            return FBUtilities.getLocalAddressAndPort();</span>
<span class="fc" id="L444">        return connectTo;</span>
    }

    public String connectToId()
    {
<span class="pc bpc" id="L449" title="1 of 2 branches missed.">        return !to.equals(connectTo())</span>
<span class="nc" id="L450">             ? to.toString()</span>
<span class="fc" id="L451">             : to.toString() + '(' + connectTo().toString() + ')';</span>
    }

    public Framing framing(ConnectionCategory category)
    {
<span class="fc bfc" id="L456" title="All 2 branches covered.">        if (framing != null)</span>
<span class="fc" id="L457">            return framing;</span>

<span class="fc bfc" id="L459" title="All 2 branches covered.">        if (category.isStreaming())</span>
<span class="fc" id="L460">            return Framing.UNPROTECTED;</span>

<span class="fc bfc" id="L462" title="All 2 branches covered.">        return shouldCompressConnection(getEndpointSnitch(), getBroadcastAddressAndPort(), to)</span>
<span class="fc" id="L463">               ? Framing.LZ4 : Framing.CRC;</span>
    }

    // note that connectTo is updated even if specified, in the case of pre40 messaging and using encryption (to update port)
    public OutboundConnectionSettings withDefaults(ConnectionCategory category)
    {
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">        if (to == null)</span>
<span class="nc" id="L470">            throw new IllegalArgumentException();</span>

<span class="fc" id="L472">        return new OutboundConnectionSettings(authenticator(), to, connectTo(),</span>
<span class="fc" id="L473">                                              encryption(), framing(category),</span>
<span class="fc" id="L474">                                              socketSendBufferSizeInBytes(), applicationSendQueueCapacityInBytes(),</span>
<span class="fc" id="L475">                                              applicationSendQueueReserveEndpointCapacityInBytes(),</span>
<span class="fc" id="L476">                                              applicationSendQueueReserveGlobalCapacityInBytes(),</span>
<span class="fc" id="L477">                                              tcpNoDelay(), flushLowWaterMark, flushHighWaterMark,</span>
<span class="fc" id="L478">                                              tcpConnectTimeoutInMS(), tcpUserTimeoutInMS(category), acceptVersions(category),</span>
<span class="fc" id="L479">                                              from(), socketFactory(), callbacks(), debug(), endpointToVersion());</span>
    }

    private static boolean isInLocalDC(IEndpointSnitch snitch, InetAddressAndPort localHost, InetAddressAndPort remoteHost)
    {
<span class="fc" id="L484">        String remoteDC = snitch.getDatacenter(remoteHost);</span>
<span class="fc" id="L485">        String localDC = snitch.getDatacenter(localHost);</span>
<span class="pc bpc" id="L486" title="1 of 4 branches missed.">        return remoteDC != null &amp;&amp; remoteDC.equals(localDC);</span>
    }

    @VisibleForTesting
    static ServerEncryptionOptions defaultEncryptionOptions(InetAddressAndPort endpoint)
    {
<span class="fc" id="L492">        ServerEncryptionOptions options = DatabaseDescriptor.getInternodeMessagingEncyptionOptions();</span>
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">        return options.shouldEncrypt(endpoint) ? options : null;</span>
    }

    @VisibleForTesting
    static boolean shouldCompressConnection(IEndpointSnitch snitch, InetAddressAndPort localHost, InetAddressAndPort remoteHost)
    {
<span class="fc bfc" id="L499" title="All 2 branches covered.">        return (DatabaseDescriptor.internodeCompression() == Config.InternodeCompression.all)</span>
<span class="fc bfc" id="L500" title="All 4 branches covered.">               || ((DatabaseDescriptor.internodeCompression() == Config.InternodeCompression.dc) &amp;&amp; !isInLocalDC(snitch, localHost, remoteHost));</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>