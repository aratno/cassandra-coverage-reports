<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ListenerList.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.utils.concurrent</a> &gt; <span class="el_source">ListenerList.java</span></div><h1>ListenerList.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.utils.concurrent;

import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import javax.annotation.Nullable;

import com.google.common.util.concurrent.FutureCallback;

import io.netty.util.concurrent.EventExecutor;
import io.netty.util.concurrent.GenericFutureListener;
import net.nicoulaj.compilecommand.annotations.Inline;
import org.apache.cassandra.concurrent.ExecutionFailure;
import org.apache.cassandra.concurrent.ExecutorPlus;
import org.apache.cassandra.concurrent.ImmediateExecutor;

import static org.apache.cassandra.utils.concurrent.ListenerList.Notifying.NOTIFYING;

/**
 * Encapsulate one or more items in a linked-list that is immutable whilst shared, forming a prepend-only list (or stack).
 * Once the list is ready to consume, exclusive ownership is taken by clearing the shared variable containing it, after
 * which the list may be invoked using {@link #notifyExclusive(ListenerList, Future)}, which reverses the list before invoking the work it contains.
 */
<span class="fc" id="L43">abstract class ListenerList&lt;V&gt; extends IntrusiveStack&lt;ListenerList&lt;V&gt;&gt;</span>
{
    abstract void notifySelf(Executor notifyExecutor, Future&lt;V&gt; future);

    static ListenerList pushHead(ListenerList prev, ListenerList next)
    {
<span class="fc bfc" id="L49" title="All 2 branches covered.">        if (prev instanceof Notifying&lt;?&gt;)</span>
        {
<span class="fc" id="L51">            Notifying result = new Notifying();</span>
<span class="fc" id="L52">            result.next = next;</span>
<span class="fc bfc" id="L53" title="All 2 branches covered.">            next.next = prev == NOTIFYING ? null : prev;</span>
<span class="fc" id="L54">            return result;</span>
        }
<span class="fc" id="L56">        next.next = prev;</span>
<span class="fc" id="L57">        return next;</span>
    }

    /**
     * Logically append {@code newListener} to {@link #listeners}
     * (at this stage it is a stack, so we actually prepend)
     *
     * @param newListener must be either a {@link ListenerList} or {@link GenericFutureListener}
     */
    @Inline
    static &lt;T&gt; void push(AtomicReferenceFieldUpdater&lt;? super T, ListenerList&gt; updater, T in, ListenerList newListener)
    {
<span class="fc" id="L69">        IntrusiveStack.push(updater, in, newListener, ListenerList::pushHead);</span>
<span class="fc" id="L70">    }</span>

    /**
     * Logically append {@code newListener} to {@link #listeners}
     * (at this stage it is a stack, so we actually prepend)
     *
     * @param newListener must be either a {@link ListenerList} or {@link GenericFutureListener}
     */
    @Inline
    static &lt;T&gt; void pushExclusive(AtomicReferenceFieldUpdater&lt;? super T, ListenerList&gt; updater, T in, ListenerList newListener)
    {
<span class="nc" id="L81">        IntrusiveStack.pushExclusive(updater, in, newListener, ListenerList::pushHead);</span>
<span class="nc" id="L82">    }</span>

    static &lt;V, T extends Future&lt;V&gt;&gt; void notify(AtomicReferenceFieldUpdater&lt;? super T, ListenerList&gt; updater, T in)
    {
        while (true)
        {
<span class="fc" id="L88">            ListenerList&lt;V&gt; listeners = updater.get(in);</span>
<span class="fc bfc" id="L89" title="All 4 branches covered.">            if (listeners == null || listeners instanceof Notifying)</span>
<span class="fc" id="L90">                return; // either no listeners, or we are already notifying listeners, so we'll get to the new one when ready</span>

<span class="fc bfc" id="L92" title="All 2 branches covered.">            if (updater.compareAndSet(in, listeners, NOTIFYING))</span>
            {
                while (true)
                {
<span class="fc" id="L96">                    notifyExclusive(listeners, in);</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">                    if (updater.compareAndSet(in, NOTIFYING, null))</span>
<span class="fc" id="L98">                        return;</span>

<span class="fc" id="L100">                    listeners = updater.getAndSet(in, NOTIFYING);</span>
                }
            }
<span class="fc" id="L103">        }</span>
    }

    /**
     * Requires exclusive ownership of {@code head}.
     *
     * Task submission occurs in the order the operations were submitted; if all of the executors
     * are immediate or unspecified this guarantees execution order.
     * Tasks are submitted to the executor individually, as this simplifies semantics and
     * we anticipate few listeners in practice, and even fewer with indirect executors.
     *
     * @param head must be either a {@link ListenerList} or {@link GenericFutureListener}
     */
    static &lt;T&gt; void notifyExclusive(ListenerList&lt;T&gt; head, Future&lt;T&gt; future)
    {
        Executor notifyExecutor; {
<span class="fc" id="L119">            Executor exec = future.notifyExecutor();</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">            notifyExecutor = inExecutor(exec) ? null : exec;</span>
        }

<span class="fc" id="L123">        head = reverse(head);</span>
<span class="fc" id="L124">        forEach(head, i -&gt; i.notifySelf(notifyExecutor, future));</span>
<span class="fc" id="L125">    }</span>

    /**
     * Notify {@code listener} on the invoking thread, handling any exceptions
     */
    static &lt;F extends io.netty.util.concurrent.Future&lt;?&gt;&gt; void notifyListener(GenericFutureListener&lt;F&gt; listener, F future)
    {
        try
        {
<span class="fc" id="L134">            listener.operationComplete(future);</span>
        }
<span class="nc" id="L136">        catch (Throwable t)</span>
        {
            // TODO: suboptimal package interdependency - move FutureTask etc here?
<span class="nc" id="L139">            ExecutionFailure.handle(t);</span>
<span class="fc" id="L140">        }</span>
<span class="fc" id="L141">    }</span>

    /**
     * Notify {@code listener} using {@code notifyExecutor} if set, and handling exceptions otherwise
     */
    static &lt;F extends io.netty.util.concurrent.Future&lt;?&gt;&gt; void notifyListener(Executor notifyExecutor, GenericFutureListener&lt;F&gt; listener, F future)
    {
<span class="fc bfc" id="L148" title="All 2 branches covered.">        if (notifyExecutor == null) notifyListener(listener, future);</span>
<span class="fc" id="L149">        else safeExecute(notifyExecutor, () -&gt; notifyListener(listener, future));</span>
<span class="fc" id="L150">    }</span>

    /**
     * Notify {@code listener} using {@code notifyExecutor} if set, and handling exceptions otherwise
     */
    static void notifyListener(@Nullable Executor notifyExecutor, Runnable listener)
    {
<span class="fc" id="L157">        safeExecute(notifyExecutor, listener);</span>
<span class="fc" id="L158">    }</span>

    private static void safeExecute(@Nullable Executor notifyExecutor, Runnable runnable)
    {
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (notifyExecutor == null)</span>
<span class="fc" id="L163">            notifyExecutor = ImmediateExecutor.INSTANCE;</span>
        try
        {
<span class="fc" id="L166">            notifyExecutor.execute(runnable);</span>
        }
<span class="fc" id="L168">        catch (Exception | Error e)</span>
        {
            // TODO: suboptimal package interdependency - move FutureTask etc here?
<span class="fc" id="L171">            ExecutionFailure.handle(e);</span>
<span class="fc" id="L172">        }</span>
<span class="fc" id="L173">    }</span>

    /**
     * Encapsulate a regular listener in a linked list
     */
    static class GenericFutureListenerList&lt;V&gt; extends ListenerList&lt;V&gt;
    {
        final GenericFutureListener listener;

        GenericFutureListenerList(GenericFutureListener listener)
<span class="fc" id="L183">        {</span>
<span class="fc" id="L184">            this.listener = listener;</span>
<span class="fc" id="L185">        }</span>

        @Override
        void notifySelf(Executor notifyExecutor, Future&lt;V&gt; future)
        {
<span class="fc" id="L190">            notifyListener(notifyExecutor, listener, future);</span>
<span class="fc" id="L191">        }</span>
    }

    /**
     * Encapsulates the invocation of a callback with everything needed to submit for execution
     * without incurring significant further overhead as a list
     */
    static class CallbackListener&lt;V&gt; extends ListenerList&lt;V&gt; implements Runnable
    {
        final Future&lt;V&gt; future;
        final FutureCallback&lt;? super V&gt; callback;

        CallbackListener(Future&lt;V&gt; future, FutureCallback&lt;? super V&gt; callback)
<span class="fc" id="L204">        {</span>
<span class="fc" id="L205">            this.future = future;</span>
<span class="fc" id="L206">            this.callback = callback;</span>
<span class="fc" id="L207">        }</span>

        @Override
        public void run()
        {
<span class="fc bfc" id="L212" title="All 2 branches covered.">            if (future.isSuccess()) callback.onSuccess(future.getNow());</span>
<span class="fc" id="L213">            else callback.onFailure(future.cause());</span>
<span class="fc" id="L214">        }</span>

        @Override
        void notifySelf(Executor notifyExecutor, Future&lt;V&gt; future)
        {
<span class="fc" id="L219">            notifyListener(notifyExecutor, this);</span>
<span class="fc" id="L220">        }</span>
    }

    /**
     * Encapsulates the invocation of a callback with everything needed to submit for execution
     * without incurring significant further overhead as a list
     */
    static class CallbackBiConsumerListener&lt;V&gt; extends ListenerList&lt;V&gt; implements Runnable
    {
        final Future&lt;V&gt; future;
        final BiConsumer&lt;? super V, Throwable&gt; callback;
        final Executor executor;

        CallbackBiConsumerListener(Future&lt;V&gt; future, BiConsumer&lt;? super V, Throwable&gt; callback, Executor executor)
<span class="fc" id="L234">        {</span>
<span class="fc" id="L235">            this.future = future;</span>
<span class="fc" id="L236">            this.callback = callback;</span>
<span class="fc" id="L237">            this.executor = executor;</span>
<span class="fc" id="L238">        }</span>

        @Override
        public void run()
        {
<span class="fc bfc" id="L243" title="All 2 branches covered.">            if (future.isSuccess()) callback.accept(future.getNow(), null);</span>
<span class="fc" id="L244">            else callback.accept(null, future.cause());</span>
<span class="fc" id="L245">        }</span>

        @Override
        void notifySelf(Executor notifyExecutor, Future&lt;V&gt; future)
        {
<span class="fc bfc" id="L250" title="All 2 branches covered.">            notifyListener(executor == null ? notifyExecutor : executor, this);</span>
<span class="fc" id="L251">        }</span>
    }

    /**
     * Encapsulates the invocation of a callback with everything needed to submit for execution
     * without incurring significant further overhead as a list
     */
    static class CallbackListenerWithExecutor&lt;V&gt; extends CallbackListener&lt;V&gt;
    {
        final Executor executor;
        CallbackListenerWithExecutor(Future&lt;V&gt; future, FutureCallback&lt;? super V&gt; callback, Executor executor)
        {
<span class="fc" id="L263">            super(future, callback);</span>
<span class="fc" id="L264">            this.executor = executor;</span>
<span class="fc" id="L265">        }</span>

        @Override
        void notifySelf(Executor notifyExecutor, Future&lt;V&gt; future)
        {
<span class="fc" id="L270">            notifyListener(executor, this);</span>
<span class="fc" id="L271">        }</span>
    }

    /**
     * Encapsulates the invocation of a callback with everything needed to submit for execution
     * without incurring significant further overhead as a list
     */
    static class CallbackLambdaListener&lt;V&gt; extends ListenerList&lt;V&gt; implements Runnable
    {
        final Future&lt;V&gt; future;
        final Consumer&lt;? super V&gt; onSuccess;
        final Consumer&lt;? super Throwable&gt; onFailure;
        final Executor executor;

        CallbackLambdaListener(Future&lt;V&gt; future, Consumer&lt;? super V&gt; onSuccess, Consumer&lt;? super Throwable&gt; onFailure, Executor executor)
<span class="fc" id="L286">        {</span>
<span class="fc" id="L287">            this.future = future;</span>
<span class="fc" id="L288">            this.onSuccess = onSuccess;</span>
<span class="fc" id="L289">            this.onFailure = onFailure;</span>
<span class="fc" id="L290">            this.executor = executor;</span>
<span class="fc" id="L291">        }</span>

        @Override
        public void run()
        {
<span class="fc bfc" id="L296" title="All 2 branches covered.">            if (future.isSuccess()) onSuccess.accept(future.getNow());</span>
<span class="fc" id="L297">            else onFailure.accept(future.cause());</span>
<span class="fc" id="L298">        }</span>

        @Override
        void notifySelf(Executor notifyExecutor, Future future)
        {
<span class="fc bfc" id="L303" title="All 2 branches covered.">            notifyListener(executor == null ? notifyExecutor : executor, this);</span>
<span class="fc" id="L304">        }</span>
    }

    /**
     * Encapsulate a task, executable on completion by {@link Future#notifyExecutor}, in a linked list for storing in
     * {@link #listeners}, either as a listener on its own (since we need to encapsulate it anyway), or alongside
     * other listeners in a list
     */
    static class RunnableWithNotifyExecutor&lt;V&gt; extends ListenerList&lt;V&gt;
    {
        final Runnable task;
        RunnableWithNotifyExecutor(Runnable task)
<span class="fc" id="L316">        {</span>
<span class="fc" id="L317">            this.task = task;</span>
<span class="fc" id="L318">        }</span>

        @Override
        void notifySelf(Executor notifyExecutor, Future&lt;V&gt; future)
        {
<span class="fc" id="L323">            notifyListener(notifyExecutor, task);</span>
<span class="fc" id="L324">        }</span>
    }

    /**
     * Encapsulate a task executable on completion in a linked list for storing in {@link #listeners},
     * either as a listener on its own (since we need to encapsulate it anyway), or alongside other listeners
     * in a list
     */
    static class RunnableWithExecutor&lt;V&gt; extends ListenerList&lt;V&gt;
    {
        final Runnable task;
        @Nullable final Executor executor;
        RunnableWithExecutor(Runnable task, @Nullable Executor executor)
<span class="fc" id="L337">        {</span>
<span class="fc" id="L338">            this.task = task;</span>
<span class="fc" id="L339">            this.executor = executor;</span>
<span class="fc" id="L340">        }</span>

        @Override
        void notifySelf(Executor notifyExecutor, Future&lt;V&gt; future)
        {
<span class="fc bfc" id="L345" title="All 2 branches covered.">            notifyListener(inExecutor(executor) ? null : executor, task);</span>
<span class="fc" id="L346">        }</span>
    }

    /**
     * Dummy that indicates listeners are already being notified after the future was completed,
     * so we cannot notify them ourselves whilst maintaining the guaranteed invocation order.
     * The invocation of the list can be left to the thread already notifying listeners.
     */
<span class="fc" id="L354">    static class Notifying&lt;V&gt; extends ListenerList&lt;V&gt;</span>
    {
<span class="fc" id="L356">        static final Notifying NOTIFYING = new Notifying();</span>

        @Override
        void notifySelf(Executor notifyExecutor, Future&lt;V&gt; future)
        {
<span class="fc" id="L361">        }</span>
    }

    /**
     * @return true iff the invoking thread is executing {@code executor}
     */
    static boolean inExecutor(Executor executor)
    {
<span class="fc bfc" id="L369" title="All 6 branches covered.">        return (executor instanceof EventExecutor &amp;&amp; ((EventExecutor) executor).inEventLoop())</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">               || (executor instanceof ExecutorPlus &amp;&amp; ((ExecutorPlus) executor).inExecutor());</span>
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>