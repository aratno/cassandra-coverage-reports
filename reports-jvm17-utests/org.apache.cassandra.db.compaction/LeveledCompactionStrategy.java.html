<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LeveledCompactionStrategy.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.compaction</a> &gt; <span class="el_source">LeveledCompactionStrategy.java</span></div><h1>LeveledCompactionStrategy.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.compaction;

import java.util.*;


import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.*;
import com.google.common.primitives.Doubles;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.JsonNodeFactory;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.apache.cassandra.io.sstable.metadata.StatsMetadata;
import org.apache.cassandra.schema.CompactionParams;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
import org.apache.cassandra.db.rows.UnfilteredRowIterator;
import org.apache.cassandra.dht.Range;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.io.sstable.ISSTableScanner;
import org.apache.cassandra.io.sstable.format.SSTableReader;

import static org.apache.cassandra.config.CassandraRelevantProperties.TOLERATE_SSTABLE_SIZE;

public class LeveledCompactionStrategy extends AbstractCompactionStrategy
{
<span class="fc" id="L49">    private static final Logger logger = LoggerFactory.getLogger(LeveledCompactionStrategy.class);</span>
    private static final String SSTABLE_SIZE_OPTION = &quot;sstable_size_in_mb&quot;;
<span class="fc" id="L51">    private static final boolean tolerateSstableSize = TOLERATE_SSTABLE_SIZE.getBoolean();</span>
    private static final String LEVEL_FANOUT_SIZE_OPTION = &quot;fanout_size&quot;;
    private static final String SINGLE_SSTABLE_UPLEVEL_OPTION = &quot;single_sstable_uplevel&quot;;
    public static final int DEFAULT_LEVEL_FANOUT_SIZE = 10;

    @VisibleForTesting
    final LeveledManifest manifest;
    private final int maxSSTableSizeInMiB;
    private final int levelFanoutSize;
    private final boolean singleSSTableUplevel;

    public LeveledCompactionStrategy(ColumnFamilyStore cfs, Map&lt;String, String&gt; options)
    {
<span class="fc" id="L64">        super(cfs, options);</span>
<span class="fc" id="L65">        int configuredMaxSSTableSize = 160;</span>
<span class="fc" id="L66">        int configuredLevelFanoutSize = DEFAULT_LEVEL_FANOUT_SIZE;</span>
<span class="fc" id="L67">        boolean configuredSingleSSTableUplevel = false;</span>
<span class="fc" id="L68">        SizeTieredCompactionStrategyOptions localOptions = new SizeTieredCompactionStrategyOptions(options);</span>
<span class="pc bpc" id="L69" title="1 of 2 branches missed.">        if (options != null)</span>
        {
<span class="fc bfc" id="L71" title="All 2 branches covered.">            if (options.containsKey(SSTABLE_SIZE_OPTION))</span>
            {
<span class="fc" id="L73">                configuredMaxSSTableSize = Integer.parseInt(options.get(SSTABLE_SIZE_OPTION));</span>
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">                if (!tolerateSstableSize)</span>
                {
<span class="nc bnc" id="L76" title="All 2 branches missed.">                    if (configuredMaxSSTableSize &gt;= 1000)</span>
<span class="nc" id="L77">                        logger.warn(&quot;Max sstable size of {}MB is configured for {}.{}; having a unit of compaction this large is probably a bad idea&quot;,</span>
<span class="nc" id="L78">                                configuredMaxSSTableSize, cfs.name, cfs.getTableName());</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">                    if (configuredMaxSSTableSize &lt; 50)</span>
<span class="nc" id="L80">                        logger.warn(&quot;Max sstable size of {}MB is configured for {}.{}.  Testing done for CASSANDRA-5727 indicates that performance improves up to 160MB&quot;,</span>
<span class="nc" id="L81">                                configuredMaxSSTableSize, cfs.name, cfs.getTableName());</span>
                }
            }

<span class="fc bfc" id="L85" title="All 2 branches covered.">            if (options.containsKey(LEVEL_FANOUT_SIZE_OPTION))</span>
            {
<span class="fc" id="L87">                configuredLevelFanoutSize = Integer.parseInt(options.get(LEVEL_FANOUT_SIZE_OPTION));</span>
            }

<span class="fc bfc" id="L90" title="All 2 branches covered.">            if (options.containsKey(SINGLE_SSTABLE_UPLEVEL_OPTION))</span>
            {
<span class="fc" id="L92">                configuredSingleSSTableUplevel = Boolean.parseBoolean(options.get(SINGLE_SSTABLE_UPLEVEL_OPTION));</span>
            }
        }
<span class="fc" id="L95">        maxSSTableSizeInMiB = configuredMaxSSTableSize;</span>
<span class="fc" id="L96">        levelFanoutSize = configuredLevelFanoutSize;</span>
<span class="fc" id="L97">        singleSSTableUplevel = configuredSingleSSTableUplevel;</span>

<span class="fc" id="L99">        manifest = new LeveledManifest(cfs, this.maxSSTableSizeInMiB, this.levelFanoutSize, localOptions);</span>
<span class="fc" id="L100">        logger.trace(&quot;Created {}&quot;, manifest);</span>
<span class="fc" id="L101">    }</span>

    public int getLevelSize(int i)
    {
<span class="fc" id="L105">        return manifest.getLevelSize(i);</span>
    }

    public int[] getAllLevelSize()
    {
<span class="fc" id="L110">        return manifest.getAllLevelSize();</span>
    }

    public long[] getAllLevelSizeBytes()
    {
<span class="fc" id="L115">        return manifest.getAllLevelSizeBytes();</span>
    }

    @Override
    public void startup()
    {
<span class="fc" id="L121">        manifest.calculateLastCompactedKeys();</span>
<span class="fc" id="L122">        super.startup();</span>
<span class="fc" id="L123">    }</span>

    /**
     * the only difference between background and maximal in LCS is that maximal is still allowed
     * (by explicit user request) even when compaction is disabled.
     */
    @SuppressWarnings(&quot;resource&quot;) // transaction is closed by AbstractCompactionTask::execute
    public AbstractCompactionTask getNextBackgroundTask(long gcBefore)
    {
<span class="fc" id="L132">        Collection&lt;SSTableReader&gt; previousCandidate = null;</span>
        while (true)
        {
            OperationType op;
<span class="fc" id="L136">            LeveledManifest.CompactionCandidate candidate = manifest.getCompactionCandidates();</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">            if (candidate == null)</span>
            {
                // if there is no sstable to compact in standard way, try compacting based on droppable tombstone ratio
<span class="fc" id="L140">                SSTableReader sstable = findDroppableSSTable(gcBefore);</span>
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">                if (sstable == null)</span>
                {
<span class="fc" id="L143">                    logger.trace(&quot;No compaction necessary for {}&quot;, this);</span>
<span class="fc" id="L144">                    return null;</span>
                }
<span class="nc" id="L146">                candidate = new LeveledManifest.CompactionCandidate(Collections.singleton(sstable),</span>
<span class="nc" id="L147">                                                                    sstable.getSSTableLevel(),</span>
<span class="nc" id="L148">                                                                    getMaxSSTableBytes());</span>
<span class="nc" id="L149">                op = OperationType.TOMBSTONE_COMPACTION;</span>
<span class="nc" id="L150">            }</span>
            else
            {
<span class="fc" id="L153">                op = OperationType.COMPACTION;</span>
            }

            // Already tried acquiring references without success. It means there is a race with
            // the tracker but candidate SSTables were not yet replaced in the compaction strategy manager
<span class="fc bfc" id="L158" title="All 2 branches covered.">            if (candidate.sstables.equals(previousCandidate))</span>
            {
<span class="fc" id="L160">                logger.warn(&quot;Could not acquire references for compacting SSTables {} which is not a problem per se,&quot; +</span>
                            &quot;unless it happens frequently, in which case it must be reported. Will retry later.&quot;,
                            candidate.sstables);
<span class="fc" id="L163">                return null;</span>
            }

<span class="fc" id="L166">            LifecycleTransaction txn = cfs.getTracker().tryModify(candidate.sstables, OperationType.COMPACTION);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">            if (txn != null)</span>
            {
                AbstractCompactionTask newTask;
<span class="pc bpc" id="L170" title="1 of 6 branches missed.">                if (!singleSSTableUplevel || op == OperationType.TOMBSTONE_COMPACTION || txn.originals().size() &gt; 1)</span>
<span class="fc" id="L171">                    newTask = new LeveledCompactionTask(cfs, txn, candidate.level, gcBefore, candidate.maxSSTableBytes, false);</span>
                else
<span class="fc" id="L173">                    newTask = new SingleSSTableLCSTask(cfs, txn, candidate.level);</span>

<span class="fc" id="L175">                newTask.setCompactionType(op);</span>
<span class="fc" id="L176">                return newTask;</span>
            }
<span class="fc" id="L178">            previousCandidate = candidate.sstables;</span>
<span class="fc" id="L179">        }</span>
    }

    @SuppressWarnings(&quot;resource&quot;) // transaction is closed by AbstractCompactionTask::execute
    public synchronized Collection&lt;AbstractCompactionTask&gt; getMaximalTask(long gcBefore, boolean splitOutput)
    {
<span class="fc" id="L185">        Iterable&lt;SSTableReader&gt; sstables = manifest.getSSTables();</span>

<span class="fc" id="L187">        Iterable&lt;SSTableReader&gt; filteredSSTables = filterSuspectSSTables(sstables);</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">        if (Iterables.isEmpty(sstables))</span>
<span class="fc" id="L189">            return null;</span>
<span class="fc" id="L190">        LifecycleTransaction txn = cfs.getTracker().tryModify(filteredSSTables, OperationType.COMPACTION);</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">        if (txn == null)</span>
<span class="nc" id="L192">            return null;</span>
<span class="fc" id="L193">        return Arrays.&lt;AbstractCompactionTask&gt;asList(new LeveledCompactionTask(cfs, txn, 0, gcBefore, getMaxSSTableBytes(), true));</span>

    }

    @Override
    @SuppressWarnings(&quot;resource&quot;) // transaction is closed by AbstractCompactionTask::execute
    public AbstractCompactionTask getUserDefinedTask(Collection&lt;SSTableReader&gt; sstables, long gcBefore)
    {

<span class="pc bpc" id="L202" title="1 of 2 branches missed.">        if (sstables.isEmpty())</span>
<span class="nc" id="L203">            return null;</span>

<span class="fc" id="L205">        LifecycleTransaction transaction = cfs.getTracker().tryModify(sstables, OperationType.COMPACTION);</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">        if (transaction == null)</span>
        {
<span class="nc" id="L208">            logger.trace(&quot;Unable to mark {} for compaction; probably a background compaction got to it first.  You can disable background compactions temporarily if this is a problem&quot;, sstables);</span>
<span class="nc" id="L209">            return null;</span>
        }
<span class="fc bfc" id="L211" title="All 2 branches covered.">        int level = sstables.size() &gt; 1 ? 0 : sstables.iterator().next().getSSTableLevel();</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">        return new LeveledCompactionTask(cfs, transaction, level, gcBefore, level == 0 ? Long.MAX_VALUE : getMaxSSTableBytes(), false);</span>
    }

    @Override
    public AbstractCompactionTask getCompactionTask(LifecycleTransaction txn, long gcBefore, long maxSSTableBytes)
    {
<span class="nc bnc" id="L218" title="All 2 branches missed.">        assert txn.originals().size() &gt; 0;</span>
<span class="nc" id="L219">        int level = -1;</span>
        // if all sstables are in the same level, we can set that level:
<span class="nc bnc" id="L221" title="All 2 branches missed.">        for (SSTableReader sstable : txn.originals())</span>
        {
<span class="nc bnc" id="L223" title="All 2 branches missed.">            if (level == -1)</span>
<span class="nc" id="L224">                level = sstable.getSSTableLevel();</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">            if (level != sstable.getSSTableLevel())</span>
<span class="nc" id="L226">                level = 0;</span>
<span class="nc" id="L227">        }</span>
<span class="nc" id="L228">        return new LeveledCompactionTask(cfs, txn, level, gcBefore, maxSSTableBytes, false);</span>
    }

    /**
     * Leveled compaction strategy has guarantees on the data contained within each level so we
     * have to make sure we only create groups of SSTables with members from the same level.
     * This way we won't end up creating invalid sstables during anti-compaction.
     * @param ssTablesToGroup
     * @return Groups of sstables from the same level
     */
    @Override
    public Collection&lt;Collection&lt;SSTableReader&gt;&gt; groupSSTablesForAntiCompaction(Collection&lt;SSTableReader&gt; ssTablesToGroup)
    {
<span class="fc" id="L241">        int groupSize = 2;</span>
<span class="fc" id="L242">        Map&lt;Integer, Collection&lt;SSTableReader&gt;&gt; sstablesByLevel = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">        for (SSTableReader sstable : ssTablesToGroup)</span>
        {
<span class="fc" id="L245">            Integer level = sstable.getSSTableLevel();</span>
<span class="fc" id="L246">            Collection&lt;SSTableReader&gt; sstablesForLevel = sstablesByLevel.get(level);</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">            if (sstablesForLevel == null)</span>
            {
<span class="fc" id="L249">                sstablesForLevel = new ArrayList&lt;SSTableReader&gt;();</span>
<span class="fc" id="L250">                sstablesByLevel.put(level, sstablesForLevel);</span>
            }
<span class="fc" id="L252">            sstablesForLevel.add(sstable);</span>
<span class="fc" id="L253">        }</span>

<span class="fc" id="L255">        Collection&lt;Collection&lt;SSTableReader&gt;&gt; groupedSSTables = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L257" title="All 2 branches covered.">        for (Collection&lt;SSTableReader&gt; levelOfSSTables : sstablesByLevel.values())</span>
        {
<span class="fc" id="L259">            Collection&lt;SSTableReader&gt; currGroup = new ArrayList&lt;&gt;(groupSize);</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">            for (SSTableReader sstable : levelOfSSTables)</span>
            {
<span class="fc" id="L262">                currGroup.add(sstable);</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">                if (currGroup.size() == groupSize)</span>
                {
<span class="fc" id="L265">                    groupedSSTables.add(currGroup);</span>
<span class="fc" id="L266">                    currGroup = new ArrayList&lt;&gt;(groupSize);</span>
                }
<span class="fc" id="L268">            }</span>

<span class="fc bfc" id="L270" title="All 2 branches covered.">            if (currGroup.size() != 0)</span>
<span class="fc" id="L271">                groupedSSTables.add(currGroup);</span>
<span class="fc" id="L272">        }</span>
<span class="fc" id="L273">        return groupedSSTables;</span>

    }

    public int getEstimatedRemainingTasks()
    {
<span class="fc" id="L279">        int n = manifest.getEstimatedTasks();</span>
<span class="fc" id="L280">        cfs.getCompactionStrategyManager().compactionLogger.pending(this, n);</span>
<span class="fc" id="L281">        return n;</span>
    }

    @Override
    int getEstimatedRemainingTasks(int additionalSSTables, long additionalBytes)
    {
<span class="nc" id="L287">        return manifest.getEstimatedTasks(additionalBytes);</span>
    }

    public long getMaxSSTableBytes()
    {
<span class="fc" id="L292">        return maxSSTableSizeInMiB * 1024L * 1024L;</span>
    }

    public int getLevelFanoutSize()
    {
<span class="fc" id="L297">        return levelFanoutSize;</span>
    }

    public ScannerList getScanners(Collection&lt;SSTableReader&gt; sstables, Collection&lt;Range&lt;Token&gt;&gt; ranges)
    {
<span class="fc" id="L302">        Set&lt;SSTableReader&gt;[] sstablesPerLevel = manifest.getSStablesPerLevelSnapshot();</span>

<span class="fc" id="L304">        Multimap&lt;Integer, SSTableReader&gt; byLevel = ArrayListMultimap.create();</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">        for (SSTableReader sstable : sstables)</span>
        {
<span class="fc" id="L307">            int level = sstable.getSSTableLevel();</span>
            // if an sstable is not on the manifest, it was recently added or removed
            // so we add it to level -1 and create exclusive scanners for it - see below (#9935)
<span class="pc bpc" id="L310" title="2 of 4 branches missed.">            if (level &gt;= sstablesPerLevel.length || !sstablesPerLevel[level].contains(sstable))</span>
            {
<span class="nc" id="L312">                logger.warn(&quot;Live sstable {} from level {} is not on corresponding level in the leveled manifest.&quot; +</span>
                            &quot; This is not a problem per se, but may indicate an orphaned sstable due to a failed&quot; +
                            &quot; compaction not cleaned up properly.&quot;,
<span class="nc" id="L315">                             sstable.getFilename(), level);</span>
<span class="nc" id="L316">                level = -1;</span>
            }
<span class="fc" id="L318">            byLevel.get(level).add(sstable);</span>
<span class="fc" id="L319">        }</span>

<span class="fc" id="L321">        List&lt;ISSTableScanner&gt; scanners = new ArrayList&lt;ISSTableScanner&gt;(sstables.size());</span>
        try
        {
<span class="fc bfc" id="L324" title="All 2 branches covered.">            for (Integer level : byLevel.keySet())</span>
            {
                // level can be -1 when sstables are added to Tracker but not to LeveledManifest
                // since we don't know which level those sstable belong yet, we simply do the same as L0 sstables.
<span class="fc bfc" id="L328" title="All 2 branches covered.">                if (level &lt;= 0)</span>
                {
                    // L0 makes no guarantees about overlapping-ness.  Just create a direct scanner for each
<span class="fc bfc" id="L331" title="All 2 branches covered.">                    for (SSTableReader sstable : byLevel.get(level))</span>
<span class="fc" id="L332">                        scanners.add(sstable.getScanner(ranges));</span>
                }
                else
                {
                    // Create a LeveledScanner that only opens one sstable at a time, in sorted order
<span class="fc" id="L337">                    Collection&lt;SSTableReader&gt; intersecting = LeveledScanner.intersecting(byLevel.get(level), ranges);</span>
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">                    if (!intersecting.isEmpty())</span>
                    {
                        @SuppressWarnings(&quot;resource&quot;) // The ScannerList will be in charge of closing (and we close properly on errors)
<span class="fc" id="L341">                        ISSTableScanner scanner = new LeveledScanner(cfs.metadata(), intersecting, ranges);</span>
<span class="fc" id="L342">                        scanners.add(scanner);</span>
                    }
                }
<span class="fc" id="L345">            }</span>
        }
<span class="nc" id="L347">        catch (Throwable t)</span>
        {
<span class="nc" id="L349">            ISSTableScanner.closeAllAndPropagate(scanners, t);</span>
<span class="fc" id="L350">        }</span>

<span class="fc" id="L352">        return new ScannerList(scanners);</span>
    }

    @Override
    public void replaceSSTables(Collection&lt;SSTableReader&gt; removed, Collection&lt;SSTableReader&gt; added)
    {
<span class="fc" id="L358">        manifest.replace(removed, added);</span>
<span class="fc" id="L359">    }</span>

    @Override
    public void metadataChanged(StatsMetadata oldMetadata, SSTableReader sstable)
    {
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">        if (sstable.getSSTableLevel() != oldMetadata.sstableLevel)</span>
<span class="fc" id="L365">            manifest.newLevel(sstable, oldMetadata.sstableLevel);</span>
<span class="fc" id="L366">    }</span>

    @Override
    public void addSSTables(Iterable&lt;SSTableReader&gt; sstables)
    {
<span class="fc" id="L371">        manifest.addSSTables(sstables);</span>
<span class="fc" id="L372">    }</span>

    @Override
    public void addSSTable(SSTableReader added)
    {
<span class="fc" id="L377">        manifest.addSSTables(Collections.singleton(added));</span>
<span class="fc" id="L378">    }</span>

    @Override
    public void removeSSTable(SSTableReader sstable)
    {
<span class="fc" id="L383">        manifest.remove(sstable);</span>
<span class="fc" id="L384">    }</span>

    @Override
    protected Set&lt;SSTableReader&gt; getSSTables()
    {
<span class="nc" id="L389">        return manifest.getSSTables();</span>
    }

    // Lazily creates SSTableBoundedScanner for sstable that are assumed to be from the
    // same level (e.g. non overlapping) - see #4142
<span class="fc" id="L394">    private static class LeveledScanner extends AbstractIterator&lt;UnfilteredRowIterator&gt; implements ISSTableScanner</span>
    {
        private final TableMetadata metadata;
        private final Collection&lt;Range&lt;Token&gt;&gt; ranges;
        private final List&lt;SSTableReader&gt; sstables;
        private final Iterator&lt;SSTableReader&gt; sstableIterator;
        private final long totalLength;
        private final long compressedLength;

        private ISSTableScanner currentScanner;
        private long positionOffset;
<span class="fc" id="L405">        private long totalBytesScanned = 0;</span>

        public LeveledScanner(TableMetadata metadata, Collection&lt;SSTableReader&gt; sstables, Collection&lt;Range&lt;Token&gt;&gt; ranges)
<span class="fc" id="L408">        {</span>
<span class="fc" id="L409">            this.metadata = metadata;</span>
<span class="fc" id="L410">            this.ranges = ranges;</span>

            // add only sstables that intersect our range, and estimate how much data that involves
<span class="fc" id="L413">            this.sstables = new ArrayList&lt;&gt;(sstables.size());</span>
<span class="fc" id="L414">            long length = 0;</span>
<span class="fc" id="L415">            long cLength = 0;</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">            for (SSTableReader sstable : sstables)</span>
            {
<span class="fc" id="L418">                this.sstables.add(sstable);</span>
<span class="fc" id="L419">                long estimatedKeys = sstable.estimatedKeys();</span>
<span class="fc" id="L420">                double estKeysInRangeRatio = 1.0;</span>

<span class="pc bpc" id="L422" title="1 of 4 branches missed.">                if (estimatedKeys &gt; 0 &amp;&amp; ranges != null)</span>
<span class="fc" id="L423">                    estKeysInRangeRatio = ((double) sstable.estimatedKeysForRanges(ranges)) / estimatedKeys;</span>

<span class="fc" id="L425">                length += sstable.uncompressedLength() * estKeysInRangeRatio;</span>
<span class="fc" id="L426">                cLength += sstable.onDiskLength() * estKeysInRangeRatio;</span>
<span class="fc" id="L427">            }</span>

<span class="fc" id="L429">            totalLength = length;</span>
<span class="fc" id="L430">            compressedLength = cLength;</span>
<span class="fc" id="L431">            Collections.sort(this.sstables, SSTableReader.firstKeyComparator);</span>
<span class="fc" id="L432">            sstableIterator = this.sstables.iterator();</span>
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">            assert sstableIterator.hasNext(); // caller should check intersecting first</span>
<span class="fc" id="L434">            SSTableReader currentSSTable = sstableIterator.next();</span>
<span class="fc" id="L435">            currentScanner = currentSSTable.getScanner(ranges);</span>

<span class="fc" id="L437">        }</span>

        public static Collection&lt;SSTableReader&gt; intersecting(Collection&lt;SSTableReader&gt; sstables, Collection&lt;Range&lt;Token&gt;&gt; ranges)
        {
<span class="fc bfc" id="L441" title="All 2 branches covered.">            if (ranges == null)</span>
<span class="fc" id="L442">                return Lists.newArrayList(sstables);</span>

<span class="fc" id="L444">            Set&lt;SSTableReader&gt; filtered = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">            for (Range&lt;Token&gt; range : ranges)</span>
            {
<span class="fc bfc" id="L447" title="All 2 branches covered.">                for (SSTableReader sstable : sstables)</span>
                {
<span class="fc" id="L449">                    Range&lt;Token&gt; sstableRange = new Range&lt;&gt;(sstable.getFirst().getToken(), sstable.getLast().getToken());</span>
<span class="pc bpc" id="L450" title="2 of 4 branches missed.">                    if (range == null || sstableRange.intersects(range))</span>
<span class="fc" id="L451">                        filtered.add(sstable);</span>
<span class="fc" id="L452">                }</span>
<span class="fc" id="L453">            }</span>
<span class="fc" id="L454">            return filtered;</span>
        }

        public TableMetadata metadata()
        {
<span class="fc" id="L459">            return metadata;</span>
        }

        protected UnfilteredRowIterator computeNext()
        {
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">            if (currentScanner == null)</span>
<span class="nc" id="L465">                return endOfData();</span>

            while (true)
            {
<span class="fc bfc" id="L469" title="All 2 branches covered.">                if (currentScanner.hasNext())</span>
<span class="fc" id="L470">                    return currentScanner.next();</span>

<span class="fc" id="L472">                positionOffset += currentScanner.getLengthInBytes();</span>
<span class="fc" id="L473">                totalBytesScanned += currentScanner.getBytesScanned();</span>

<span class="fc" id="L475">                currentScanner.close();</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">                if (!sstableIterator.hasNext())</span>
                {
                    // reset to null so getCurrentPosition does not return wrong value
<span class="fc" id="L479">                    currentScanner = null;</span>
<span class="fc" id="L480">                    return endOfData();</span>
                }
<span class="fc" id="L482">                SSTableReader currentSSTable = sstableIterator.next();</span>
<span class="fc" id="L483">                currentScanner = currentSSTable.getScanner(ranges);</span>
<span class="fc" id="L484">            }</span>
        }

        public void close()
        {
<span class="fc bfc" id="L489" title="All 2 branches covered.">            if (currentScanner != null)</span>
<span class="fc" id="L490">                currentScanner.close();</span>
<span class="fc" id="L491">        }</span>

        public long getLengthInBytes()
        {
<span class="fc" id="L495">            return totalLength;</span>
        }

        public long getCurrentPosition()
        {
<span class="fc bfc" id="L500" title="All 2 branches covered.">            return positionOffset + (currentScanner == null ? 0L : currentScanner.getCurrentPosition());</span>
        }

        public long getCompressedLengthInBytes()
        {
<span class="fc" id="L505">            return compressedLength;</span>
        }

        public long getBytesScanned()
        {
<span class="fc bfc" id="L510" title="All 2 branches covered.">            return currentScanner == null ? totalBytesScanned : totalBytesScanned + currentScanner.getBytesScanned();</span>
        }

        public Set&lt;SSTableReader&gt; getBackingSSTables()
        {
<span class="fc" id="L515">            return ImmutableSet.copyOf(sstables);</span>
        }
    }

    @Override
    public String toString()
    {
<span class="nc" id="L522">        return String.format(&quot;LCS@%d(%s)&quot;, hashCode(), cfs.name);</span>
    }

    private SSTableReader findDroppableSSTable(final long gcBefore)
    {
        level:
<span class="fc bfc" id="L528" title="All 2 branches covered.">        for (int i = manifest.getLevelCount(); i &gt;= 0; i--)</span>
        {
<span class="fc bfc" id="L530" title="All 2 branches covered.">            if (manifest.getLevelSize(i) == 0)</span>
<span class="fc" id="L531">                continue;</span>
            // sort sstables by droppable ratio in descending order
<span class="fc" id="L533">            List&lt;SSTableReader&gt; tombstoneSortedSSTables = manifest.getLevelSorted(i, (o1, o2) -&gt; {</span>
<span class="fc" id="L534">                double r1 = o1.getEstimatedDroppableTombstoneRatio(gcBefore);</span>
<span class="fc" id="L535">                double r2 = o2.getEstimatedDroppableTombstoneRatio(gcBefore);</span>
<span class="fc" id="L536">                return -1 * Doubles.compare(r1, r2);</span>
            });

<span class="fc" id="L539">            Set&lt;SSTableReader&gt; compacting = cfs.getTracker().getCompacting();</span>
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">            for (SSTableReader sstable : tombstoneSortedSSTables)</span>
            {
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">                if (sstable.getEstimatedDroppableTombstoneRatio(gcBefore) &lt;= tombstoneThreshold)</span>
<span class="fc" id="L543">                    continue level;</span>
<span class="nc bnc" id="L544" title="All 6 branches missed.">                else if (!compacting.contains(sstable) &amp;&amp; !sstable.isMarkedSuspect() &amp;&amp; worthDroppingTombstones(sstable, gcBefore))</span>
<span class="nc" id="L545">                    return sstable;</span>
<span class="nc" id="L546">            }</span>
        }
<span class="fc" id="L548">        return null;</span>
    }

    public CompactionLogger.Strategy strategyLogger()
    {
<span class="fc" id="L553">        return new CompactionLogger.Strategy()</span>
<span class="fc" id="L554">        {</span>
            public JsonNode sstable(SSTableReader sstable)
            {
<span class="fc" id="L557">                ObjectNode node = JsonNodeFactory.instance.objectNode();</span>
<span class="fc" id="L558">                node.put(&quot;level&quot;, sstable.getSSTableLevel());</span>
<span class="fc" id="L559">                node.put(&quot;min_token&quot;, sstable.getFirst().getToken().toString());</span>
<span class="fc" id="L560">                node.put(&quot;max_token&quot;, sstable.getLast().getToken().toString());</span>
<span class="fc" id="L561">                return node;</span>
            }

            public JsonNode options()
            {
<span class="fc" id="L566">                return null;</span>
            }
        };
    }

    public static Map&lt;String, String&gt; validateOptions(Map&lt;String, String&gt; options) throws ConfigurationException
    {
<span class="fc" id="L573">        Map&lt;String, String&gt; uncheckedOptions = AbstractCompactionStrategy.validateOptions(options);</span>

<span class="fc bfc" id="L575" title="All 2 branches covered.">        String size = options.containsKey(SSTABLE_SIZE_OPTION) ? options.get(SSTABLE_SIZE_OPTION) : &quot;1&quot;;</span>
        try
        {
<span class="fc" id="L578">            int ssSize = Integer.parseInt(size);</span>
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">            if (ssSize &lt; 1)</span>
            {
<span class="nc" id="L581">                throw new ConfigurationException(String.format(&quot;%s must be larger than 0, but was %s&quot;, SSTABLE_SIZE_OPTION, ssSize));</span>
            }
        }
<span class="nc" id="L584">        catch (NumberFormatException ex)</span>
        {
<span class="nc" id="L586">            throw new ConfigurationException(String.format(&quot;%s is not a parsable int (base10) for %s&quot;, size, SSTABLE_SIZE_OPTION), ex);</span>
<span class="fc" id="L587">        }</span>

<span class="fc" id="L589">        uncheckedOptions.remove(SSTABLE_SIZE_OPTION);</span>

        // Validate the fanout_size option
<span class="fc bfc" id="L592" title="All 2 branches covered.">        String levelFanoutSize = options.containsKey(LEVEL_FANOUT_SIZE_OPTION) ? options.get(LEVEL_FANOUT_SIZE_OPTION) : String.valueOf(DEFAULT_LEVEL_FANOUT_SIZE);</span>
        try
        {
<span class="fc" id="L595">            int fanoutSize = Integer.parseInt(levelFanoutSize);</span>
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">            if (fanoutSize &lt; 1)</span>
            {
<span class="nc" id="L598">                throw new ConfigurationException(String.format(&quot;%s must be larger than 0, but was %s&quot;, LEVEL_FANOUT_SIZE_OPTION, fanoutSize));</span>
            }
        }
<span class="nc" id="L601">        catch (NumberFormatException ex)</span>
        {
<span class="nc" id="L603">            throw new ConfigurationException(String.format(&quot;%s is not a parsable int (base10) for %s&quot;, size, LEVEL_FANOUT_SIZE_OPTION), ex);</span>
<span class="fc" id="L604">        }</span>

<span class="fc" id="L606">        uncheckedOptions.remove(LEVEL_FANOUT_SIZE_OPTION);</span>
<span class="fc" id="L607">        uncheckedOptions.remove(SINGLE_SSTABLE_UPLEVEL_OPTION);</span>

<span class="fc" id="L609">        uncheckedOptions.remove(CompactionParams.Option.MIN_THRESHOLD.toString());</span>
<span class="fc" id="L610">        uncheckedOptions.remove(CompactionParams.Option.MAX_THRESHOLD.toString());</span>

<span class="fc" id="L612">        uncheckedOptions = SizeTieredCompactionStrategyOptions.validateOptions(options, uncheckedOptions);</span>

<span class="fc" id="L614">        return uncheckedOptions;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>