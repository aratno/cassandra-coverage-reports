<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RepairMessage.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.repair.messages</a> &gt; <span class="el_source">RepairMessage.java</span></div><h1>RepairMessage.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.repair.messages;

import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.Map;
import java.util.Set;
import java.util.function.Supplier;

import javax.annotation.Nullable;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.config.RepairRetrySpec;
import org.apache.cassandra.config.RetrySpec;
import org.apache.cassandra.repair.SharedContext;
import org.apache.cassandra.exceptions.RepairException;
import org.apache.cassandra.exceptions.RequestFailureReason;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.net.Message;
import org.apache.cassandra.net.RequestCallback;
import org.apache.cassandra.net.Verb;
import org.apache.cassandra.repair.RepairJobDesc;
import org.apache.cassandra.streaming.PreviewKind;
import org.apache.cassandra.utils.Backoff;
import org.apache.cassandra.utils.CassandraVersion;
import org.apache.cassandra.utils.TimeUUID;
import org.apache.cassandra.utils.concurrent.Future;

import static org.apache.cassandra.net.MessageFlag.CALL_BACK_ON_FAILURE;

/**
 * Base class of all repair related request/response messages.
 *
 * @since 2.0
 */
public abstract class RepairMessage
{
<span class="fc" id="L58">    private enum ErrorHandling { NONE, TIMEOUT, RETRY }</span>
<span class="fc" id="L59">    private static final CassandraVersion SUPPORTS_RETRY = new CassandraVersion(&quot;5.0.0-alpha2.SNAPSHOT&quot;);</span>
    private static final Map&lt;Verb, CassandraVersion&gt; VERB_TIMEOUT_VERSIONS;

    static
    {
<span class="fc" id="L64">        CassandraVersion timeoutVersion = new CassandraVersion(&quot;4.0.7-SNAPSHOT&quot;);</span>
<span class="fc" id="L65">        EnumMap&lt;Verb, CassandraVersion&gt; map = new EnumMap&lt;&gt;(Verb.class);</span>
<span class="fc" id="L66">        map.put(Verb.VALIDATION_REQ, timeoutVersion);</span>
<span class="fc" id="L67">        map.put(Verb.SYNC_REQ, timeoutVersion);</span>
<span class="fc" id="L68">        map.put(Verb.VALIDATION_RSP, SUPPORTS_RETRY);</span>
<span class="fc" id="L69">        map.put(Verb.SYNC_RSP, SUPPORTS_RETRY);</span>
<span class="fc" id="L70">        VERB_TIMEOUT_VERSIONS = Collections.unmodifiableMap(map);</span>
    }
<span class="fc" id="L72">    private static final Set&lt;Verb&gt; SUPPORTS_RETRY_WITHOUT_VERSION_CHECK = Collections.unmodifiableSet(EnumSet.of(Verb.CLEANUP_MSG));</span>

<span class="fc" id="L74">    private static final Logger logger = LoggerFactory.getLogger(RepairMessage.class);</span>
    @Nullable
    public final RepairJobDesc desc;

    protected RepairMessage(@Nullable RepairJobDesc desc)
<span class="fc" id="L79">    {</span>
<span class="fc" id="L80">        this.desc = desc;</span>
<span class="fc" id="L81">    }</span>

    public TimeUUID parentRepairSession()
    {
<span class="fc" id="L85">        return desc.parentSessionId;</span>
    }

    public interface RepairFailureCallback
    {
        void onFailure(Exception e);
    }

    private static Backoff backoff(SharedContext ctx, Verb verb)
    {
<span class="fc" id="L95">        RepairRetrySpec retrySpec = DatabaseDescriptor.getRepairRetrySpec();</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">        RetrySpec spec = verb == Verb.VALIDATION_RSP ? retrySpec.getMerkleTreeResponseSpec() : retrySpec;</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">        if (!spec.isEnabled())</span>
<span class="fc" id="L98">            return Backoff.None.INSTANCE;</span>
<span class="fc" id="L99">        return new Backoff.ExponentialBackoff(spec.maxAttempts.value, spec.baseSleepTime.toMilliseconds(), spec.maxSleepTime.toMilliseconds(), ctx.random().get()::nextDouble);</span>
    }

    public static Supplier&lt;Boolean&gt; notDone(Future&lt;?&gt; f)
    {
<span class="fc bfc" id="L104" title="All 2 branches covered.">        return () -&gt; !f.isDone();</span>
    }

    private static Supplier&lt;Boolean&gt; always()
    {
<span class="fc" id="L109">        return () -&gt; true;</span>
    }

    public static &lt;T&gt; void sendMessageWithRetries(SharedContext ctx, Supplier&lt;Boolean&gt; allowRetry, RepairMessage request, Verb verb, InetAddressAndPort endpoint, RequestCallback&lt;T&gt; finalCallback)
    {
<span class="fc" id="L114">        sendMessageWithRetries(ctx, backoff(ctx, verb), allowRetry, request, verb, endpoint, finalCallback, 0);</span>
<span class="fc" id="L115">    }</span>

    public static &lt;T&gt; void sendMessageWithRetries(SharedContext ctx, RepairMessage request, Verb verb, InetAddressAndPort endpoint, RequestCallback&lt;T&gt; finalCallback)
    {
<span class="fc" id="L119">        sendMessageWithRetries(ctx, backoff(ctx, verb), always(), request, verb, endpoint, finalCallback, 0);</span>
<span class="fc" id="L120">    }</span>

    public static void sendMessageWithRetries(SharedContext ctx, RepairMessage request, Verb verb, InetAddressAndPort endpoint)
    {
<span class="fc" id="L124">        sendMessageWithRetries(ctx, backoff(ctx, verb), always(), request, verb, endpoint, new RequestCallback&lt;&gt;()</span>
<span class="fc" id="L125">        {</span>
            @Override
            public void onResponse(Message&lt;Object&gt; msg)
            {
<span class="fc" id="L129">            }</span>

            @Override
            public void onFailure(InetAddressAndPort from, RequestFailureReason failureReason)
            {
<span class="nc" id="L134">            }</span>
        }, 0);
<span class="fc" id="L136">    }</span>

    private static &lt;T&gt; void sendMessageWithRetries(SharedContext ctx, Backoff backoff, Supplier&lt;Boolean&gt; allowRetry, RepairMessage request, Verb verb, InetAddressAndPort endpoint, RequestCallback&lt;T&gt; finalCallback, int attempt)
    {
<span class="fc" id="L140">        RequestCallback&lt;T&gt; callback = new RequestCallback&lt;&gt;()</span>
<span class="fc" id="L141">        {</span>
            @Override
            public void onResponse(Message&lt;T&gt; msg)
            {
<span class="fc" id="L145">                finalCallback.onResponse(msg);</span>
<span class="fc" id="L146">            }</span>

            @Override
            public void onFailure(InetAddressAndPort from, RequestFailureReason failureReason)
            {
<span class="fc" id="L151">                ErrorHandling allowed = errorHandlingSupported(ctx, endpoint, verb, request.parentRepairSession());</span>
<span class="pc bpc" id="L152" title="3 of 4 branches missed.">                switch (allowed)</span>
                {
                    case NONE:
<span class="nc" id="L155">                        logger.error(&quot;[#{}] {} failed on {}: {}&quot;, request.parentRepairSession(), verb, from, failureReason);</span>
<span class="nc" id="L156">                        return;</span>
                    case TIMEOUT:
<span class="nc" id="L158">                        finalCallback.onFailure(from, failureReason);</span>
<span class="nc" id="L159">                        return;</span>
                    case RETRY:
<span class="fc" id="L161">                        int maxAttempts = backoff.maxAttempts();</span>
<span class="pc bpc" id="L162" title="1 of 6 branches missed.">                        if (failureReason == RequestFailureReason.TIMEOUT &amp;&amp; attempt &lt; maxAttempts &amp;&amp; allowRetry.get())</span>
                        {
<span class="fc" id="L164">                            ctx.optionalTasks().schedule(() -&gt; sendMessageWithRetries(ctx, backoff, allowRetry, request, verb, endpoint, finalCallback, attempt + 1),</span>
<span class="fc" id="L165">                                                         backoff.computeWaitTime(attempt), backoff.unit());</span>
<span class="fc" id="L166">                            return;</span>
                        }
<span class="fc" id="L168">                        finalCallback.onFailure(from, failureReason);</span>
<span class="fc" id="L169">                        return;</span>
                    default:
<span class="nc" id="L171">                        throw new AssertionError(&quot;Unknown error handler: &quot; + allowed);</span>
                }
            }

            @Override
            public boolean invokeOnFailure()
            {
<span class="fc" id="L178">                return true;</span>
            }
        };
<span class="fc" id="L181">        ctx.messaging().sendWithCallback(Message.outWithFlag(verb, request, CALL_BACK_ON_FAILURE),</span>
                                         endpoint,
                                         callback);
<span class="fc" id="L184">    }</span>

    public static void sendMessageWithFailureCB(SharedContext ctx, Supplier&lt;Boolean&gt; allowRetry, RepairMessage request, Verb verb, InetAddressAndPort endpoint, RepairFailureCallback failureCallback)
    {
<span class="fc" id="L188">        RequestCallback&lt;?&gt; callback = new RequestCallback&lt;&gt;()</span>
<span class="fc" id="L189">        {</span>
            @Override
            public void onResponse(Message&lt;Object&gt; msg)
            {
<span class="fc" id="L193">                logger.info(&quot;[#{}] {} received by {}&quot;, request.parentRepairSession(), verb, endpoint);</span>
                // todo: at some point we should make repair messages follow the normal path, actually using this
<span class="fc" id="L195">            }</span>

            @Override
            public void onFailure(InetAddressAndPort from, RequestFailureReason failureReason)
            {
<span class="fc" id="L200">                failureCallback.onFailure(RepairException.error(request.desc, PreviewKind.NONE, String.format(&quot;Got %s failure from %s: %s&quot;, verb, from, failureReason)));</span>
<span class="fc" id="L201">            }</span>

            @Override
            public boolean invokeOnFailure()
            {
<span class="nc" id="L206">                return true;</span>
            }
        };
<span class="fc" id="L209">        sendMessageWithRetries(ctx, allowRetry, request, verb, endpoint, callback);</span>
<span class="fc" id="L210">    }</span>

    private static ErrorHandling errorHandlingSupported(SharedContext ctx, InetAddressAndPort from, Verb verb, TimeUUID parentSessionId)
    {
<span class="fc bfc" id="L214" title="All 2 branches covered.">        if (SUPPORTS_RETRY_WITHOUT_VERSION_CHECK.contains(verb))</span>
<span class="fc" id="L215">            return ErrorHandling.RETRY;</span>
        // Repair in mixed mode isn't fully supported, but also not activally blocked... so in the common case all participants
        // will be on the same version as this instance, so can avoid the lookup from gossip
<span class="fc" id="L218">        CassandraVersion remoteVersion = ctx.gossiper().getReleaseVersion(from);</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">        if (remoteVersion == null)</span>
        {
<span class="nc bnc" id="L221" title="All 2 branches missed.">            if (VERB_TIMEOUT_VERSIONS.containsKey(verb))</span>
            {
<span class="nc" id="L223">                logger.warn(&quot;[#{}] Not failing repair due to remote host {} not supporting repair message timeouts (version is unknown)&quot;, parentSessionId, from);</span>
<span class="nc" id="L224">                return ErrorHandling.NONE;</span>
            }
<span class="nc" id="L226">            return ErrorHandling.TIMEOUT;</span>
        }
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">        if (remoteVersion.compareTo(SUPPORTS_RETRY) &gt;= 0)</span>
<span class="fc" id="L229">            return ErrorHandling.RETRY;</span>
<span class="nc" id="L230">        CassandraVersion timeoutVersion = VERB_TIMEOUT_VERSIONS.get(verb);</span>
<span class="nc bnc" id="L231" title="All 4 branches missed.">        if (timeoutVersion == null || remoteVersion.compareTo(timeoutVersion) &gt;= 0)</span>
<span class="nc" id="L232">            return ErrorHandling.TIMEOUT;</span>
<span class="nc" id="L233">        return ErrorHandling.NONE;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>