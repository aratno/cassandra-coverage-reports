<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RowIndexReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.io.sstable.format.bti</a> &gt; <span class="el_source">RowIndexReader.java</span></div><h1>RowIndexReader.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.io.sstable.format.bti;

import java.io.IOException;
import java.io.PrintStream;
import java.nio.ByteBuffer;
import javax.annotation.concurrent.NotThreadSafe;

import org.apache.cassandra.db.DeletionTime;
import org.apache.cassandra.io.sstable.format.Version;
import org.apache.cassandra.io.tries.SerializationNode;
import org.apache.cassandra.io.tries.TrieNode;
import org.apache.cassandra.io.tries.TrieSerializer;
import org.apache.cassandra.io.tries.Walker;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.io.util.FileHandle;
import org.apache.cassandra.io.util.SizedInts;
import org.apache.cassandra.utils.bytecomparable.ByteComparable;

/**
 * Reader class for row index files created by {@link RowIndexWriter}.
 * &lt;p&gt;
 * Row index &quot;tries&quot; do not need to store whole keys, as what we need from them is to be able to tell where in the data file
 * to start looking for a given key. Instead, we store some prefix that is greater than the greatest key of the previous
 * index section and smaller than or equal to the smallest key of the next. So for a given key the first index section
 * that could potentially contain it is given by the trie's floor for that key.
 * &lt;p&gt;
 * This builds upon the trie Walker class which provides basic trie walking functionality. The class is thread-unsafe
 * and must be re-instantiated for every thread that needs access to the trie (its overhead is below that of a
 * {@link org.apache.cassandra.io.util.RandomAccessReader}).
 */
@NotThreadSafe
public class RowIndexReader extends Walker&lt;RowIndexReader&gt;
{
    public final Version version;
    private static final int FLAG_OPEN_MARKER = 8;

    public static class IndexInfo
    {
        public final long offset;
        public final DeletionTime openDeletion;

        IndexInfo(long offset, DeletionTime openDeletion)
<span class="fc" id="L60">        {</span>
<span class="fc" id="L61">            this.offset = offset;</span>
<span class="fc" id="L62">            this.openDeletion = openDeletion;</span>
<span class="fc" id="L63">        }</span>
    }

    public RowIndexReader(FileHandle file, long root, Version version)
    {
<span class="fc" id="L68">        super(file.instantiateRebufferer(null), root);</span>
<span class="fc" id="L69">        this.version = version;</span>
<span class="fc" id="L70">    }</span>

    public RowIndexReader(FileHandle file, TrieIndexEntry entry, Version version)
    {
<span class="fc" id="L74">        this(file, entry.indexTrieRoot, version);</span>
<span class="fc" id="L75">    }</span>

    /**
     * Computes the floor for a given key.
     * @throws IOException 
     */
    public IndexInfo separatorFloor(ByteComparable key) throws IOException
    {
        // Check for a prefix and find closest smaller branch.
<span class="fc" id="L84">        IndexInfo res = prefixAndNeighbours(key, RowIndexReader::readPayload);</span>
        // If there's a prefix, in a separator trie it could be less than, equal, or greater than sought value.
        // Sought value is still greater than max of previous section.
        // On match the prefix must be used as a starting point.
<span class="fc bfc" id="L88" title="All 2 branches covered.">        if (res != null)</span>
<span class="fc" id="L89">            return res;</span>

        // Otherwise return the IndexInfo for the closest entry of the smaller branch (which is the max of lesserBranch).
        // Note (see prefixAndNeighbours): since we accept prefix matches above, at this point there cannot be another
        // prefix match that is closer than max(lesserBranch).
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">        if (lesserBranch == NONE)</span>
<span class="nc" id="L95">            return null;</span>
<span class="fc" id="L96">        goMax(lesserBranch);</span>
<span class="fc" id="L97">        return getCurrentIndexInfo();</span>
    }

    public IndexInfo min() throws IOException
    {
<span class="fc" id="L102">        goMin(root);</span>
<span class="fc" id="L103">        return getCurrentIndexInfo();</span>
    }

    protected IndexInfo getCurrentIndexInfo() throws IOException
    {
<span class="fc" id="L108">        return readPayload(payloadPosition(), payloadFlags());</span>
    }

    protected IndexInfo readPayload(int ppos, int bits) throws IOException
    {
<span class="fc" id="L113">        return readPayload(buf, ppos, bits, version);</span>
    }

    static IndexInfo readPayload(ByteBuffer buf, int ppos, int bits, Version version) throws IOException
    {
        long dataOffset;
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">        if (bits == 0)</span>
<span class="nc" id="L120">            return null;</span>
<span class="fc" id="L121">        int bytes = bits &amp; ~FLAG_OPEN_MARKER;</span>
<span class="fc" id="L122">        dataOffset = SizedInts.read(buf, ppos, bytes);</span>
<span class="fc" id="L123">        ppos += bytes;</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">        DeletionTime deletion = (bits &amp; FLAG_OPEN_MARKER) != 0</span>
<span class="fc" id="L125">                ? DeletionTime.getSerializer(version).deserialize(buf, ppos)</span>
<span class="fc" id="L126">                : null;</span>
<span class="fc" id="L127">        return new IndexInfo(dataOffset, deletion);</span>
    }

    // The trie serializer describes how the payloads are written. Placed here (instead of writer) so that reading and
    // writing the payload are close together should they need to be changed.
    static final TrieSerializer&lt;IndexInfo, DataOutputPlus&gt; getSerializer(Version version)
    {
<span class="fc" id="L134">        return new TrieSerializer&lt;IndexInfo, DataOutputPlus&gt;()</span>
<span class="fc" id="L135">        {</span>
            @Override
            public int sizeofNode(SerializationNode&lt;IndexInfo&gt; node, long nodePosition)
            {
<span class="fc" id="L139">                return TrieNode.typeFor(node, nodePosition).sizeofNode(node) + sizeof(node.payload());</span>
            }

            @Override
            public void write(DataOutputPlus dest, SerializationNode&lt;IndexInfo&gt; node, long nodePosition) throws IOException
            {
<span class="fc" id="L145">                write(dest, TrieNode.typeFor(node, nodePosition), node, nodePosition);</span>
<span class="fc" id="L146">            }</span>

            private int sizeof(IndexInfo payload)
            {
<span class="fc" id="L150">                int size = 0;</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">                if (payload != null)</span>
                {
<span class="fc" id="L153">                    size += SizedInts.nonZeroSize(payload.offset);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">                    if (!payload.openDeletion.isLive())</span>
<span class="fc" id="L155">                        size += DeletionTime.getSerializer(version).serializedSize(payload.openDeletion);</span>
                }
<span class="fc" id="L157">                return size;</span>
            }

            private void write(DataOutputPlus dest, TrieNode type, SerializationNode&lt;IndexInfo&gt; node, long nodePosition) throws IOException
            {
<span class="fc" id="L162">                IndexInfo payload = node.payload();</span>
<span class="fc" id="L163">                int bytes = 0;</span>
<span class="fc" id="L164">                int hasOpenMarker = 0;</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">                if (payload != null)</span>
                {
<span class="fc" id="L167">                    bytes = SizedInts.nonZeroSize(payload.offset);</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">                    assert bytes &lt; 8 : &quot;Row index does not support rows larger than 32 PiB&quot;;</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">                    if (!payload.openDeletion.isLive())</span>
<span class="fc" id="L170">                        hasOpenMarker = FLAG_OPEN_MARKER;</span>
                }
<span class="fc" id="L172">                type.serialize(dest, node, bytes | hasOpenMarker, nodePosition);</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">                if (payload != null)</span>
                {
<span class="fc" id="L175">                    SizedInts.write(dest, payload.offset, bytes);</span>

<span class="fc bfc" id="L177" title="All 2 branches covered.">                    if (hasOpenMarker == FLAG_OPEN_MARKER)</span>
<span class="fc" id="L178">                        DeletionTime.getSerializer(version).serialize(payload.openDeletion, dest);</span>
                }
<span class="fc" id="L180">            }</span>

        };
    }

    // debug/test code
    @SuppressWarnings(&quot;unused&quot;)
    public void dumpTrie(PrintStream out) throws IOException
    {
<span class="nc" id="L189">        dumpTrie(out, RowIndexReader::dumpRowIndexEntry, version);</span>
<span class="nc" id="L190">    }</span>

    static String dumpRowIndexEntry(ByteBuffer buf, int ppos, int bits, Version version) throws IOException
    {
<span class="nc" id="L194">        IndexInfo ii = readPayload(buf, ppos, bits, version);</span>

<span class="nc bnc" id="L196" title="All 2 branches missed.">        return ii != null</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">               ? String.format(&quot;pos %x %s&quot;, ii.offset, ii.openDeletion == null ? &quot;&quot; : ii.openDeletion)</span>
<span class="nc" id="L198">               : &quot;pos null&quot;;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>