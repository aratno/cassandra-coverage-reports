<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractMutableVirtualTable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.virtual</a> &gt; <span class="el_source">AbstractMutableVirtualTable.java</span></div><h1>AbstractMutableVirtualTable.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.virtual;

import java.nio.ByteBuffer;
import java.util.List;
import java.util.Optional;

import com.google.common.base.Preconditions;
import com.google.common.collect.BoundType;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Range;

import org.apache.commons.lang3.ArrayUtils;

import org.apache.cassandra.db.Clustering;
import org.apache.cassandra.db.ClusteringBound;
import org.apache.cassandra.db.ClusteringPrefix;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.Slice;
import org.apache.cassandra.db.marshal.CompositeType;
import org.apache.cassandra.db.partitions.PartitionUpdate;
import org.apache.cassandra.db.rows.Cell;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.TableMetadata;

import static org.apache.cassandra.cql3.statements.RequestValidations.checkFalse;
import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;

/**
 * An abstract virtual table implementation that builds the resultset on demand and allows fine-grained source
 * modification via INSERT/UPDATE, DELETE and TRUNCATE operations.
 * 
 * Virtual table implementation need to be thread-safe has they can be called from different threads.
 */
public abstract class AbstractMutableVirtualTable extends AbstractVirtualTable
{

    protected AbstractMutableVirtualTable(TableMetadata metadata)
    {
<span class="fc" id="L56">        super(metadata);</span>
<span class="fc" id="L57">    }</span>

    @Override
    public final void apply(PartitionUpdate update)
    {
<span class="fc" id="L62">        ColumnValues partitionKey = ColumnValues.from(metadata(), update.partitionKey());</span>

<span class="fc bfc" id="L64" title="All 2 branches covered.">        if (update.deletionInfo().isLive())</span>
<span class="fc" id="L65">            update.forEach(row -&gt;</span>
            {
<span class="fc" id="L67">                ColumnValues clusteringColumns = ColumnValues.from(metadata(), row.clustering());</span>

<span class="fc bfc" id="L69" title="All 2 branches covered.">                if (row.deletion().isLive())</span>
                {
<span class="fc bfc" id="L71" title="All 2 branches covered.">                    if (row.columnCount() == 0)</span>
                    {
<span class="fc" id="L73">                        applyColumnUpdate(partitionKey, clusteringColumns, Optional.empty());</span>
                    }
                    else
                    {
<span class="fc" id="L77">                        row.forEach(columnData -&gt;</span>
                        {
<span class="fc" id="L79">                            checkFalse(columnData.column().isComplex(), &quot;Complex type columns are not supported by table %s&quot;, metadata);</span>

<span class="fc" id="L81">                            Cell&lt;?&gt; cell = (Cell&lt;?&gt;) columnData;</span>

<span class="fc bfc" id="L83" title="All 2 branches covered.">                            if (cell.isTombstone())</span>
<span class="fc" id="L84">                                applyColumnDeletion(partitionKey, clusteringColumns, columnName(cell));</span>
                            else
<span class="fc" id="L86">                                applyColumnUpdate(partitionKey,</span>
                                        clusteringColumns,
<span class="fc" id="L88">                                        Optional.of(ColumnValue.from(cell)));</span>
<span class="fc" id="L89">                        });</span>
                    }
                }
                else
<span class="fc" id="L93">                    applyRowDeletion(partitionKey, clusteringColumns);</span>
<span class="fc" id="L94">            });</span>
        else
        {
            // MutableDeletionInfo may have partition delete or range tombstone list or both
<span class="fc bfc" id="L98" title="All 2 branches covered.">            if (update.deletionInfo().hasRanges())</span>
<span class="fc" id="L99">                update.deletionInfo()</span>
<span class="fc" id="L100">                        .rangeIterator(false)</span>
<span class="fc" id="L101">                        .forEachRemaining(rt -&gt; applyRangeTombstone(partitionKey, toRange(rt.deletedSlice())));</span>

<span class="fc bfc" id="L103" title="All 2 branches covered.">            if (!update.deletionInfo().getPartitionDeletion().isLive())</span>
<span class="fc" id="L104">                applyPartitionDeletion(partitionKey);</span>
        }
<span class="fc" id="L106">    }</span>

    protected void applyPartitionDeletion(ColumnValues partitionKey)
    {
<span class="nc" id="L110">        throw invalidRequest(&quot;Partition deletion is not supported by table %s&quot;, metadata);</span>
    }

    private Range&lt;ColumnValues&gt; toRange(Slice slice)
    {
<span class="fc" id="L115">        ClusteringBound&lt;?&gt; startBound = slice.start();</span>
<span class="fc" id="L116">        ClusteringBound&lt;?&gt; endBound = slice.end();</span>

<span class="fc bfc" id="L118" title="All 2 branches covered.">        if (startBound.isBottom())</span>
        {
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">            if (endBound.isTop())</span>
<span class="nc" id="L121">                return Range.all();</span>

<span class="fc" id="L123">            return Range.upTo(ColumnValues.from(metadata(), endBound), boundType(endBound));</span>
        }

<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (endBound.isTop())</span>
<span class="fc" id="L127">            return Range.downTo(ColumnValues.from(metadata(), startBound), boundType(startBound));</span>

<span class="fc" id="L129">        ColumnValues start = ColumnValues.from(metadata(), startBound);</span>
<span class="fc" id="L130">        BoundType startType = boundType(startBound);</span>

<span class="fc" id="L132">        ColumnValues end = ColumnValues.from(metadata(), endBound);</span>
<span class="fc" id="L133">        BoundType endType = boundType(endBound);</span>

<span class="fc" id="L135">        return Range.range(start, startType, end, endType);</span>
    }

    private static BoundType boundType(ClusteringBound&lt;?&gt; bound)
    {
<span class="fc bfc" id="L140" title="All 2 branches covered.">        return bound.isInclusive() ? BoundType.CLOSED : BoundType.OPEN;</span>
    }

    protected void applyRangeTombstone(ColumnValues partitionKey, Range&lt;ColumnValues&gt; range)
    {
<span class="nc" id="L145">        throw invalidRequest(&quot;Range deletion is not supported by table %s&quot;, metadata);</span>
    }

    protected void applyRowDeletion(ColumnValues partitionKey, ColumnValues clusteringColumns)
    {
<span class="nc" id="L150">        throw invalidRequest(&quot;Row deletion is not supported by table %s&quot;, metadata);</span>
    }

    protected void applyColumnDeletion(ColumnValues partitionKey, ColumnValues clusteringColumns, String columnName)
    {
<span class="nc" id="L155">        throw invalidRequest(&quot;Column deletion is not supported by table %s&quot;, metadata);</span>
    }

    protected void applyColumnUpdate(ColumnValues partitionKey,
                                     ColumnValues clusteringColumns,
                                     Optional&lt;ColumnValue&gt; columnValue)
    {
<span class="fc" id="L162">        throw invalidRequest(&quot;Column modification is not supported by table %s&quot;, metadata);</span>
    }

    private static String columnName(Cell&lt;?&gt; cell)
    {
<span class="fc" id="L167">        return cell.column().name.toCQLString();</span>
    }

    /**
     * A set of partition key or clustering column values.
     */
    public static final class ColumnValues implements Comparable&lt;ColumnValues&gt;
    {
        /**
         * An empty set of column values.
         */
<span class="fc" id="L178">        private static final ColumnValues EMPTY = new ColumnValues(ImmutableList.of(), ArrayUtils.EMPTY_OBJECT_ARRAY);</span>

        /**
         * The column metadata for the set of columns.
         */
        private final ImmutableList&lt;ColumnMetadata&gt; metadata;

        /**
         * The column values. The number of values can be smaller than the number of values if only
         * a sub-set of the column values is specified (e.g. clustering prefix).
         */
        private final Object[] values;

        /**
         * Returns the set of column values corresponding to the specified partition key.
         *
         * @param metadata the table metadata
         * @param partitionKey the partition key
         * @return the set of columns values corresponding to the specified partition key
         */
        public static ColumnValues from(TableMetadata metadata, DecoratedKey partitionKey)
        {
<span class="fc bfc" id="L200" title="All 2 branches covered.">            if (metadata.partitionKeyType instanceof CompositeType)</span>
            {
<span class="fc" id="L202">                ByteBuffer[] buffers = ((CompositeType) metadata.partitionKeyType).split(partitionKey.getKey());</span>
<span class="fc" id="L203">                return ColumnValues.from(metadata.partitionKeyColumns(), buffers);</span>
            }

<span class="fc" id="L206">            return ColumnValues.from(metadata.partitionKeyColumns(), partitionKey.getKey());</span>
        }

        /**
         * Returns the set of column values corresponding to the specified clustering prefix.
         *
         * @param metadata the table metadata
         * @param prefix the clustering prefix
         * @return the set of columns values corresponding to the specified clustering prefix
         */
        public static ColumnValues from(TableMetadata metadata, ClusteringPrefix&lt;?&gt; prefix)
        {
<span class="fc bfc" id="L218" title="All 2 branches covered.">            if (prefix == Clustering.EMPTY)</span>
<span class="fc" id="L219">                return EMPTY;</span>

<span class="fc" id="L221">            return ColumnValues.from(metadata.clusteringColumns(), prefix.getBufferArray());</span>
        }

        private static ColumnValues from(ImmutableList&lt;ColumnMetadata&gt; metadata, ByteBuffer... buffers)
        {
<span class="fc" id="L226">            return new ColumnValues(metadata, convert(metadata, buffers));</span>
        }

        /**
         * Create a {@code ColumnValues} for the specified set of columns.
         *
         * @param metadata the partition or clustering columns metadata
         * @param values the partition or clustering column values
         */
        public ColumnValues(List&lt;ColumnMetadata&gt; metadata, Object... values)
<span class="fc" id="L236">        {</span>
<span class="fc" id="L237">            this.metadata = ImmutableList.copyOf(metadata);</span>
<span class="fc" id="L238">            this.values = values;</span>
<span class="fc" id="L239">        }</span>

        /**
         * Deserializes the column values.
         *
         * @param metadata the column metadata
         * @param buffers the serialized column values
         * @return the deserialized column values
         */
        private static Object[] convert(ImmutableList&lt;ColumnMetadata&gt; metadata, ByteBuffer[] buffers)
        {
<span class="fc" id="L250">            Object[] values = new Object[buffers.length];</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">            for (int i = 0; i &lt; buffers.length; i++)</span>
            {
<span class="fc" id="L253">                values[i] = metadata.get(i).type.compose(buffers[i]);</span>
            }
<span class="fc" id="L255">            return values;</span>
        }

        /**
         * Returns the name of the specified column
         *
         * @param i the column index
         * @return the column name
         */
        public String name(int i)
        {
<span class="nc" id="L266">            Preconditions.checkPositionIndex(i, values.length);</span>
<span class="nc" id="L267">            return metadata.get(i).name.toCQLString();</span>
        }

        /**
         * Returns the value for the specified column
         *
         * @param i the column index
         * @return the column value
         */
        @SuppressWarnings(&quot;unchecked&quot;)
        public &lt;V&gt; V value(int i)
        {
<span class="fc" id="L279">            Preconditions.checkPositionIndex(i, values.length);</span>
<span class="fc" id="L280">            return (V) values[i];</span>
        }

        /**
         * Returns the number of column values.
         *
         * @return the number of column values.
         */
        public int size()
        {
<span class="fc" id="L290">            return values.length;</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L296">            StringBuilder builder = new StringBuilder();</span>
<span class="nc" id="L297">            builder.append('[');</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">            for (int i = 0, m = metadata.size(); i &lt;m; i++)</span>
            {
<span class="nc bnc" id="L300" title="All 2 branches missed.">                if (i != 0)</span>
<span class="nc" id="L301">                    builder.append(&quot;, &quot;);</span>

<span class="nc" id="L303">                builder.append(metadata.get(i).name.toCQLString())</span>
<span class="nc" id="L304">                       .append(&quot; : &quot;);</span>

<span class="nc bnc" id="L306" title="All 2 branches missed.">                if (i &lt; values.length)</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">                       builder.append(i &lt; values.length ? values[i].toString() : &quot;unspecified&quot;);</span>
            }
<span class="nc" id="L309">            return builder.append(']').toString();</span>
        }

        @Override
        public int compareTo(ColumnValues o)
        {
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">            assert metadata.equals(o.metadata);</span>

<span class="fc" id="L317">            int s1 = size();</span>
<span class="fc" id="L318">            int s2 = o.size();</span>
<span class="fc" id="L319">            int minSize = Math.min(s1, s2);</span>

<span class="fc bfc" id="L321" title="All 2 branches covered.">            for (int i = 0; i &lt; minSize; i++)</span>
            {
<span class="fc" id="L323">                int cmp = compare(values[i], o.values[i]);</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">                if (cmp != 0)</span>
<span class="fc" id="L325">                    return cmp;</span>
            }

<span class="fc" id="L328">            return 0;</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        private &lt;T extends Comparable&lt;T&gt;&gt; int compare(Object c1, Object c2)
        {
<span class="fc" id="L334">            return ((T) c1).compareTo((T) c2);</span>
        }
    }

    /**
     * A regular column value.
     */
    public static final class ColumnValue
    {
        /**
         * The column metadata
         */
        private final ColumnMetadata metadata;

        /**
         * The column value
         */
        private final Object value;

        /**
         * Returns the column value corresponding to the specified cell.
         *
         * @param cell the column cell metadata
         * @return the column value corresponding to the specified cell
         */
        public static ColumnValue from(Cell&lt;?&gt; cell)
        {
<span class="fc" id="L361">            ColumnMetadata metadata = cell.column();</span>
<span class="fc" id="L362">            return new ColumnValue(metadata, metadata.type.compose(cell.buffer()));</span>
        }

        private ColumnValue(ColumnMetadata metadata, Object value)
<span class="fc" id="L366">        {</span>
<span class="fc" id="L367">            this.metadata = metadata;</span>
<span class="fc" id="L368">            this.value = value;</span>
<span class="fc" id="L369">        }</span>

        /**
         * Returns the column name.
         *
         * @return the column name
         */
        public String name()
        {
<span class="fc" id="L378">            return metadata.name.toCQLString();</span>
        }

        /**
         * Returns the column value.
         *
         * @return the column value
         */
        @SuppressWarnings(&quot;unchecked&quot;)
        public &lt;V&gt; V value()
        {
<span class="fc" id="L389">            return (V) value;</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L395">            return String.format(&quot;%s : %s&quot;, name(), value());</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>