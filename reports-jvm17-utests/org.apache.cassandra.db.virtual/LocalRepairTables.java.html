<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LocalRepairTables.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.virtual</a> &gt; <span class="el_source">LocalRepairTables.java</span></div><h1>LocalRepairTables.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.virtual;

import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableSet;

import org.apache.cassandra.cql3.statements.schema.CreateTableStatement;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.marshal.TimeUUIDType;
import org.apache.cassandra.db.marshal.UUIDType;
import org.apache.cassandra.dht.LocalPartitioner;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.repair.CommonRange;
import org.apache.cassandra.repair.RepairJobDesc;
import org.apache.cassandra.repair.state.Completable;
import org.apache.cassandra.repair.state.CoordinatorState;
import org.apache.cassandra.repair.state.JobState;
import org.apache.cassandra.repair.state.ParticipateState;
import org.apache.cassandra.repair.state.SessionState;
import org.apache.cassandra.repair.state.State;
import org.apache.cassandra.repair.state.ValidationState;
import org.apache.cassandra.schema.Schema;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.service.ActiveRepairService;
import org.apache.cassandra.utils.TimeUUID;

public class LocalRepairTables
{
    private LocalRepairTables()
    {
    }

    public static Collection&lt;VirtualTable&gt; getAll(String keyspace)
    {
<span class="fc" id="L60">        return Arrays.asList(</span>
        new RepairTable(keyspace),
        new SessionTable(keyspace),
        new JobTable(keyspace),
        new ParticipateTable(keyspace),
        new ValidationTable(keyspace)
        );
    }

    private static final String JOB_DESC_COLUMNS = &quot;  repair_id timeuuid,\n&quot; +
                                                   &quot;  session_id timeuuid,\n&quot; +
                                                   &quot;  keyspace_name text,\n&quot; +
                                                   &quot;  table_name text,\n&quot; +
                                                   &quot;  ranges frozen&lt;list&lt;text&gt;&gt;,\n&quot;;

    static final class RepairTable extends AbstractVirtualTable
    {
        protected RepairTable(String keyspace)
        {
<span class="fc" id="L79">            super(parse(keyspace, &quot;Repair summary&quot;,</span>
                        &quot;CREATE TABLE repairs (\n&quot; +
<span class="fc" id="L81">                        stdColumnsWithStatus(true) +</span>
                        &quot;  command_id int,\n&quot; +
                        &quot;  keyspace_name text,\n&quot; +
                        // human readable definition of what the repair is doing
                        &quot;  type text,\n&quot; +
                        // list of all sessions; this is lazy so only once the session is created will it be present, so this dynamically changes within the life of a repair
                        &quot;  sessions frozen&lt;set&lt;timeuuid&gt;&gt;,\n&quot; +

                        // options_ maps to RepairOption
                        &quot;  options_parallelism text,\n&quot; +
                        &quot;  options_primary_range boolean,\n&quot; +
                        &quot;  options_incremental boolean,\n&quot; +
                        &quot;  options_trace boolean,\n&quot; +
                        &quot;  options_job_threads int,\n&quot; +
                        &quot;  options_subrange_repair boolean,\n&quot; +
                        &quot;  options_pull_repair boolean,\n&quot; +
                        &quot;  options_force_repair boolean,\n&quot; +
                        &quot;  options_preview_kind text,\n&quot; +
                        &quot;  options_optimise_streams boolean,\n&quot; +
                        &quot;  options_ignore_unreplicated_keyspaces boolean,\n&quot; +
                        &quot;  options_column_families frozen&lt;set&lt;text&gt;&gt;,\n&quot; +
                        &quot;  options_data_centers frozen&lt;set&lt;text&gt;&gt;,\n&quot; +
                        &quot;  options_hosts frozen&lt;set&lt;text&gt;&gt;,\n&quot; +
                        &quot;  options_ranges frozen&lt;set&lt;text&gt;&gt;,\n&quot; +

                        &quot;  table_names frozen&lt;list&lt;text&gt;&gt;,\n&quot; +
                        &quot;  ranges frozen&lt;list&lt;list&lt;text&gt;&gt;&gt;,\n&quot; +
                        &quot;  unfiltered_ranges frozen&lt;list&lt;list&lt;text&gt;&gt;&gt;,\n&quot; +
                        &quot;  participants frozen&lt;list&lt;text&gt;&gt;,\n&quot; +
<span class="fc" id="L110">                        stateColumns(CoordinatorState.State.class) +</span>
                        &quot;\n&quot; +
                        &quot;  PRIMARY KEY ( (id) )\n&quot; +
                        &quot;)&quot;));
<span class="fc" id="L114">        }</span>

        public DataSet data()
        {
<span class="fc" id="L118">            SimpleDataSet result = new SimpleDataSet(metadata());</span>
<span class="fc" id="L119">            ActiveRepairService.instance().coordinators().forEach(s -&gt; updateDataset(result, s));</span>
<span class="fc" id="L120">            return result;</span>
        }

        public DataSet data(DecoratedKey partitionKey)
        {
<span class="fc" id="L125">            TimeUUID id = TimeUUIDType.instance.compose(partitionKey.getKey());</span>
<span class="fc" id="L126">            SimpleDataSet result = new SimpleDataSet(metadata());</span>
<span class="fc" id="L127">            CoordinatorState state = ActiveRepairService.instance().coordinator(id);</span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">            if (state != null)</span>
<span class="fc" id="L129">                updateDataset(result, state);</span>
<span class="fc" id="L130">            return result;</span>
        }

        private void updateDataset(SimpleDataSet result, CoordinatorState state)
        {
<span class="fc" id="L135">            result.row(state.id);</span>
<span class="fc" id="L136">            addState(result, state);</span>
<span class="fc" id="L137">            result.column(&quot;type&quot;, getType(state));</span>
<span class="fc" id="L138">            result.column(&quot;keyspace_name&quot;, state.keyspace);</span>
<span class="fc" id="L139">            result.column(&quot;command_id&quot;, state.cmd);</span>

<span class="fc" id="L141">            result.column(&quot;options_parallelism&quot;, state.options.getParallelism().name());</span>
<span class="fc" id="L142">            result.column(&quot;options_primary_range&quot;, state.options.isPrimaryRange());</span>
<span class="fc" id="L143">            result.column(&quot;options_trace&quot;, state.options.isTraced());</span>
<span class="fc" id="L144">            result.column(&quot;options_job_threads&quot;, state.options.getJobThreads());</span>
<span class="fc" id="L145">            result.column(&quot;options_subrange_repair&quot;, state.options.isSubrangeRepair());</span>
<span class="fc" id="L146">            result.column(&quot;options_pull_repair&quot;, state.options.isPullRepair());</span>
<span class="fc" id="L147">            result.column(&quot;options_force_repair&quot;, state.options.isForcedRepair());</span>
<span class="fc" id="L148">            result.column(&quot;options_preview_kind&quot;, state.options.getPreviewKind().name());</span>
<span class="fc" id="L149">            result.column(&quot;options_optimise_streams&quot;, state.options.optimiseStreams());</span>
<span class="fc" id="L150">            result.column(&quot;options_ignore_unreplicated_keyspaces&quot;, state.options.ignoreUnreplicatedKeyspaces());</span>
<span class="fc" id="L151">            result.column(&quot;options_column_families&quot;, state.options.getColumnFamilies());</span>
<span class="fc" id="L152">            result.column(&quot;options_data_centers&quot;, state.options.getDataCenters());</span>
<span class="fc" id="L153">            result.column(&quot;options_hosts&quot;, state.options.getHosts());</span>
<span class="fc" id="L154">            result.column(&quot;options_ranges&quot;, toStringSet(state.options.getRanges()));</span>

<span class="fc" id="L156">            result.column(&quot;sessions&quot;, state.getSessionIds());</span>

<span class="fc" id="L158">            String[] columnFamilyNames = state.getColumnFamilyNames();</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">            result.column(&quot;table_names&quot;, columnFamilyNames == null ? null : Arrays.asList(columnFamilyNames));</span>

<span class="fc" id="L161">            Set&lt;InetAddressAndPort&gt; participants = state.getParticipants();</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">            result.column(&quot;participants&quot;, participants == null ? null : toStringList(participants));</span>

<span class="fc" id="L164">            List&lt;CommonRange&gt; ranges = state.getFilteredCommonRanges();</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">            result.column(&quot;ranges&quot;, ranges == null ? null : ranges.stream().map(c -&gt; c.ranges).map(LocalRepairTables::toStringList).collect(Collectors.toList()));</span>

<span class="fc" id="L167">            ranges = state.getCommonRanges();</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">            result.column(&quot;unfiltered_ranges&quot;, ranges == null ? null : ranges.stream().map(c -&gt; c.ranges).map(LocalRepairTables::toStringList).collect(Collectors.toList()));</span>
<span class="fc" id="L169">        }</span>

        private String getType(CoordinatorState state)
        {
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">            if (state.options.isPreview())</span>
            {
<span class="nc bnc" id="L175" title="All 5 branches missed.">                switch (state.options.getPreviewKind())</span>
                {
<span class="nc" id="L177">                    case ALL: return &quot;preview full&quot;;</span>
<span class="nc" id="L178">                    case REPAIRED: return &quot;preview repaired&quot;;</span>
<span class="nc" id="L179">                    case UNREPAIRED: return &quot;preview unrepaired&quot;;</span>
<span class="nc" id="L180">                    case NONE: throw new AssertionError(&quot;NONE preview kind not expected when preview repair is set&quot;);</span>
<span class="nc" id="L181">                    default: throw new AssertionError(&quot;Unknown preview kind: &quot; + state.options.getPreviewKind());</span>
                }
            }
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">            else if (state.options.isIncremental())</span>
            {
<span class="nc" id="L186">                return &quot;incremental&quot;;</span>
            }
<span class="fc" id="L188">            return &quot;full&quot;;</span>
        }
    }

    private static final class SessionTable extends AbstractVirtualTable
    {
        SessionTable(String keyspace)
        {
<span class="fc" id="L196">            super(parse(keyspace, &quot;Repair session&quot;,</span>
                        &quot;CREATE TABLE repair_sessions (\n&quot; +
<span class="fc" id="L198">                        stdColumnsWithStatus(true) +</span>
                        &quot;  repair_id timeuuid,\n&quot; +
                        &quot;  keyspace_name text,\n&quot; +
                        &quot;  table_names frozen&lt;list&lt;text&gt;&gt;,\n&quot; +
                        &quot;  ranges frozen&lt;list&lt;text&gt;&gt;,\n&quot; +
                        &quot;  participants frozen&lt;list&lt;text&gt;&gt;,\n&quot; +
                        &quot;  jobs frozen&lt;set&lt;uuid&gt;&gt;,\n&quot; +
                        &quot;\n&quot; +
<span class="fc" id="L206">                        stateColumns(SessionState.State.class) +</span>
                        &quot;\n&quot; +
                        &quot;  PRIMARY KEY ( (id) )\n&quot; +
                        &quot;)&quot;));
<span class="fc" id="L210">        }</span>

        @Override
        public DataSet data()
        {
<span class="fc" id="L215">            SimpleDataSet result = new SimpleDataSet(metadata());</span>
<span class="fc" id="L216">            ActiveRepairService.instance().coordinators().stream()</span>
<span class="fc" id="L217">                                                .flatMap(s -&gt; s.getSessions().stream())</span>
<span class="fc" id="L218">                                                .forEach(s -&gt; updateDataset(result, s));</span>
<span class="fc" id="L219">            return result;</span>
        }

        private void updateDataset(SimpleDataSet result, SessionState state)
        {
<span class="fc" id="L224">            result.row(state.id);</span>
<span class="fc" id="L225">            addState(result, state);</span>
<span class="fc" id="L226">            result.column(&quot;repair_id&quot;, state.parentRepairSession);</span>
<span class="fc" id="L227">            result.column(&quot;keyspace_name&quot;, state.keyspace);</span>
<span class="fc" id="L228">            result.column(&quot;table_names&quot;, Arrays.asList(state.cfnames));</span>
<span class="fc" id="L229">            result.column(&quot;ranges&quot;, toStringList(state.commonRange.ranges));</span>
<span class="fc" id="L230">            result.column(&quot;jobs&quot;, state.getJobIds());</span>
<span class="fc" id="L231">            result.column(&quot;participants&quot;, toStringList(state.getParticipants()));</span>
<span class="fc" id="L232">        }</span>
    }

    private static final class JobTable extends AbstractVirtualTable
    {
        JobTable(String keyspace)
        {
<span class="fc" id="L239">            super(parse(keyspace, &quot;Repair job&quot;,</span>
                        &quot;CREATE TABLE repair_jobs (\n&quot; +
<span class="fc" id="L241">                        stdColumnsWithStatus(false) +</span>
                        &quot;  participants frozen&lt;list&lt;text&gt;&gt;,\n&quot; +
                        JOB_DESC_COLUMNS +
                        &quot;\n&quot; +
<span class="fc" id="L245">                        stateColumns(JobState.State.class) +</span>
                        &quot;\n&quot; +
                        &quot;  PRIMARY KEY ( (id) )\n&quot; +
                        &quot;)&quot;));
<span class="fc" id="L249">        }</span>

        @Override
        public DataSet data()
        {
<span class="fc" id="L254">            SimpleDataSet result = new SimpleDataSet(metadata());</span>
<span class="fc" id="L255">            ActiveRepairService.instance().coordinators().stream()</span>
<span class="fc" id="L256">                                                .flatMap(s -&gt; s.getSessions().stream())</span>
<span class="fc" id="L257">                                                .flatMap(s -&gt; s.getJobs().stream())</span>
<span class="fc" id="L258">                                                .forEach(s -&gt; updateDataset(result, s));</span>
<span class="fc" id="L259">            return result;</span>
        }

        private void updateDataset(SimpleDataSet result, JobState state)
        {
<span class="fc" id="L264">            result.row(state.id);</span>
<span class="fc" id="L265">            addState(result, state);</span>
<span class="fc" id="L266">            addState(result, state.desc);</span>
<span class="fc" id="L267">            result.column(&quot;participants&quot;, toStringList(state.getParticipants()));</span>
<span class="fc" id="L268">        }</span>
    }

    static final class ParticipateTable extends AbstractVirtualTable
    {
        protected ParticipateTable(String keyspace)
        {
<span class="fc" id="L275">            super(parse(keyspace, &quot;Repair participate summary&quot;,</span>
                        &quot;CREATE TABLE repair_participates (&quot; +
<span class="fc" id="L277">                        stdColumns(true) +</span>
                        &quot;  initiator  text,\n&quot; +
                        &quot;  tables frozen&lt;set&lt;text&gt;&gt;, \n&quot; +
                        &quot;  ranges frozen&lt;list&lt;text&gt;&gt;,\n&quot; +
                        &quot;  incremental boolean,\n&quot; +
                        &quot;  global boolean,\n&quot; +
                        &quot;  preview_kind text,\n&quot; +
                        &quot;  repaired_at timestamp,\n&quot; +
                        &quot;  validations frozen&lt;set&lt;uuid&gt;&gt;,\n&quot; +
                        &quot;\n&quot; +
                        &quot;  PRIMARY KEY ( (id) )\n&quot; +
                        &quot;)&quot;));
<span class="fc" id="L289">        }</span>

        @Override
        public DataSet data()
        {
<span class="fc" id="L294">            SimpleDataSet result = new SimpleDataSet(metadata());</span>
<span class="fc" id="L295">            ActiveRepairService.instance().participates().stream()</span>
<span class="fc" id="L296">                                        .forEach(s -&gt; updateDataset(result, s));</span>
<span class="fc" id="L297">            return result;</span>
        }

        @Override
        public DataSet data(DecoratedKey partitionKey)
        {
<span class="fc" id="L303">            TimeUUID id = TimeUUIDType.instance.compose(partitionKey.getKey());</span>
<span class="fc" id="L304">            SimpleDataSet result = new SimpleDataSet(metadata());</span>
<span class="fc" id="L305">            ParticipateState state = ActiveRepairService.instance().participate(id);</span>
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">            if (state != null)</span>
<span class="fc" id="L307">                updateDataset(result, state);</span>
<span class="fc" id="L308">            return result;</span>
        }

        private void updateDataset(SimpleDataSet result, ParticipateState state)
        {
<span class="fc" id="L313">            result.row(state.id);</span>
<span class="fc" id="L314">            addCompletableState(result, state);</span>
<span class="fc" id="L315">            result.column(&quot;initiator&quot;, state.initiator.toString());</span>
<span class="fc" id="L316">            result.column(&quot;tables&quot;, state.tableIds.stream()</span>
<span class="fc" id="L317">                                                  .map(Schema.instance::getTableMetadata)</span>
<span class="pc bnc" id="L318" title="All 2 branches missed.">                                                  .filter(a -&gt; a != null) // getTableMetadata returns null if id isn't know, most likely dropped</span>
<span class="fc" id="L319">                                                  .map(Object::toString)</span>
<span class="fc" id="L320">                                                  .collect(Collectors.toSet()));</span>
<span class="fc" id="L321">            result.column(&quot;incremental&quot;, state.incremental);</span>
<span class="fc" id="L322">            result.column(&quot;global&quot;, state.global);</span>
<span class="fc" id="L323">            result.column(&quot;preview_kind&quot;, state.previewKind.name());</span>
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">            if (state.repairedAt != 0)</span>
<span class="fc" id="L325">                result.column(&quot;repaired_at&quot;, new Date(state.repairedAt));</span>
<span class="fc" id="L326">            result.column(&quot;validations&quot;, ImmutableSet.copyOf(state.validationIds()));</span>
<span class="fc" id="L327">            result.column(&quot;ranges&quot;, toStringList(state.ranges));</span>
<span class="fc" id="L328">        }</span>
    }

    private static final class ValidationTable extends AbstractVirtualTable
    {
        ValidationTable(String keyspace)
        {
<span class="fc" id="L335">            super(parse(keyspace, &quot;Repair validation&quot;,</span>
                        &quot;CREATE TABLE repair_validations (\n&quot; +
<span class="fc" id="L337">                        stdColumnsWithStatus(false) +</span>
                        JOB_DESC_COLUMNS +
                        &quot;  initiator  text,\n&quot; +
                        &quot;  estimated_partitions  bigint,\n&quot; +
                        &quot;  estimated_total_bytes  bigint,\n&quot; +
                        &quot;  partitions_processed  bigint,\n&quot; +
                        &quot;  bytes_read  bigint,\n&quot; +
                        &quot;  progress_percentage float,\n&quot; +
                        &quot;\n&quot; +
<span class="fc" id="L346">                        stateColumns(ValidationState.State.class) +</span>
                        &quot;\n&quot; +
                        &quot;  PRIMARY KEY ( (id) )\n&quot; +
                        &quot;)&quot;));
<span class="fc" id="L350">        }</span>

        @Override
        public DataSet data()
        {
<span class="fc" id="L355">            SimpleDataSet result = new SimpleDataSet(metadata());</span>
<span class="fc" id="L356">            ActiveRepairService.instance().validations().stream()</span>
<span class="fc" id="L357">                                                     .forEach(s -&gt; updateDataset(result, s));</span>
<span class="fc" id="L358">            return result;</span>
        }

        @Override
        public DataSet data(DecoratedKey partitionKey)
        {
<span class="fc" id="L364">            UUID id = UUIDType.instance.compose(partitionKey.getKey());</span>
<span class="fc" id="L365">            SimpleDataSet result = new SimpleDataSet(metadata());</span>
<span class="fc" id="L366">            ValidationState state = ActiveRepairService.instance().validation(id);</span>
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">            if (state != null)</span>
<span class="fc" id="L368">                updateDataset(result, state);</span>
<span class="fc" id="L369">            return result;</span>
        }

        private void updateDataset(SimpleDataSet result, ValidationState state)
        {
<span class="fc" id="L374">            result.row(state.id);</span>
<span class="fc" id="L375">            addState(result, state);</span>
<span class="fc" id="L376">            addState(result, state.desc);</span>
<span class="fc" id="L377">            result.column(&quot;initiator&quot;, state.initiator.toString());</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">            result.column(&quot;estimated_partitions&quot;, state.estimatedPartitions == 0 ? null : state.estimatedPartitions);</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">            result.column(&quot;estimated_total_bytes&quot;, state.estimatedTotalBytes == 0 ? null : state.estimatedTotalBytes);</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">            result.column(&quot;partitions_processed&quot;, state.partitionsProcessed == 0 ? null : state.partitionsProcessed);</span>
<span class="fc" id="L381">            result.column(&quot;progress_percentage&quot;, round(state.getProgress() * 100));</span>
<span class="fc" id="L382">            result.column(&quot;bytes_read&quot;, state.bytesRead);</span>
<span class="fc" id="L383">        }</span>
    }

    private static String timestampColumnName(Enum&lt;?&gt; e)
    {
<span class="fc" id="L388">        return timestampColumnName(e.name().toLowerCase());</span>
    }

    private static String timestampColumnName(String e)
    {
<span class="fc" id="L393">        return &quot;state_&quot; + e + &quot;_timestamp&quot;;</span>
    }

    private static String stateColumns(Class&lt;? extends Enum&lt;?&gt;&gt; klass)
    {
<span class="fc" id="L398">        StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">        for (Enum&lt;?&gt; e : klass.getEnumConstants())</span>
<span class="fc" id="L400">            sb.append(&quot;  &quot;).append(timestampColumnName(e)).append(&quot; timestamp, \n&quot;);</span>
<span class="fc" id="L401">        return sb.toString();</span>
    }

    private static String stdStateColumns()
    {
<span class="fc" id="L406">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L407">        sb.append(&quot;  &quot;).append(timestampColumnName(&quot;init&quot;)).append(&quot; timestamp, \n&quot;);</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">        for (State.Result.Kind kind : State.Result.Kind.values())</span>
<span class="fc" id="L409">            sb.append(&quot;  &quot;).append(timestampColumnName(kind)).append(&quot; timestamp, \n&quot;);</span>
<span class="fc" id="L410">        return sb.toString();</span>
    }

    private static void addCompletableState(SimpleDataSet ds, Completable&lt;?&gt; state)
    {
        // read timestamp early to see latest data
<span class="fc" id="L416">        ds.column(&quot;last_updated_at&quot;, new Date(state.getLastUpdatedAtMillis()));</span>
<span class="fc" id="L417">        ds.column(&quot;duration_millis&quot;, state.getDurationMillis());</span>
<span class="fc" id="L418">        State.Result result = state.getResult();</span>
<span class="fc" id="L419">        ds.column(&quot;failure_cause&quot;, state.getFailureCause());</span>
<span class="fc" id="L420">        ds.column(&quot;success_message&quot;, state.getSuccessMessage());</span>
<span class="fc" id="L421">        ds.column(timestampColumnName(&quot;init&quot;), new Date(state.getInitializedAtMillis()));</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">        ds.column(&quot;completed&quot;, result != null);</span>

<span class="fc bfc" id="L424" title="All 2 branches covered.">        if (result != null)</span>
<span class="fc" id="L425">            ds.column(timestampColumnName(result.kind), new Date(state.getLastUpdatedAtMillis()));</span>
<span class="fc" id="L426">    }</span>

    private static &lt;T extends Enum&lt;T&gt;&gt; void addState(SimpleDataSet ds, State&lt;T, ?&gt; state)
    {
<span class="fc" id="L430">        addCompletableState(ds, state);</span>

<span class="fc" id="L432">        T currentState = state.getStatus();</span>
<span class="fc" id="L433">        State.Result result = state.getResult();</span>
<span class="fc bfc" id="L434" title="All 4 branches covered.">        ds.column(&quot;status&quot;, result != null ? result.kind.name().toLowerCase() : currentState == null ? &quot;init&quot; : currentState.name().toLowerCase());</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">        for (Map.Entry&lt;T, Long&gt; e : state.getStateTimesMillis().entrySet())</span>
        {
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">            if (e.getValue().longValue() != 0)</span>
<span class="fc" id="L438">                ds.column(timestampColumnName(e.getKey()), new Date(e.getValue()));</span>
<span class="fc" id="L439">        }</span>
<span class="fc" id="L440">    }</span>

    @VisibleForTesting
    static float round(float value)
    {
<span class="fc" id="L445">        return Math.round(value * 100.0F) / 100.0F;</span>
    }

    private static void addState(SimpleDataSet result, RepairJobDesc desc)
    {
<span class="fc" id="L450">        result.column(&quot;repair_id&quot;, desc.parentSessionId);</span>
<span class="fc" id="L451">        result.column(&quot;session_id&quot;, desc.sessionId);</span>
<span class="fc" id="L452">        result.column(&quot;keyspace_name&quot;, desc.keyspace);</span>
<span class="fc" id="L453">        result.column(&quot;table_name&quot;, desc.columnFamily);</span>
<span class="fc" id="L454">        result.column(&quot;ranges&quot;, toStringList(desc.ranges));</span>
<span class="fc" id="L455">    }</span>

    private static &lt;T&gt; List&lt;String&gt; toStringList(Collection&lt;T&gt; list)
    {
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">        if (list == null)</span>
<span class="nc" id="L460">            return null;</span>
<span class="fc" id="L461">        return list.stream().map(Object::toString).collect(Collectors.toList());</span>
    }

    private static &lt;T&gt; Set&lt;String&gt; toStringSet(Collection&lt;T&gt; list)
    {
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">        if (list == null)</span>
<span class="nc" id="L467">            return null;</span>
<span class="fc" id="L468">        return list.stream().map(Object::toString).collect(Collectors.toSet());</span>
    }

    private static TableMetadata parse(String keyspace, String comment, String query)
    {
<span class="fc" id="L473">        return CreateTableStatement.parse(query, keyspace)</span>
<span class="fc" id="L474">                                   .comment(comment)</span>
<span class="fc" id="L475">                                   .kind(TableMetadata.Kind.VIRTUAL)</span>
<span class="fc" id="L476">                                   .partitioner(new LocalPartitioner(UUIDType.instance))</span>
<span class="fc" id="L477">                                   .build();</span>
    }

    private static String stdColumns(boolean time)
    {
<span class="fc" id="L482">        String str = &quot;  id timeuuid,\n&quot; +</span>
                     &quot;  last_updated_at timestamp,\n&quot; +
                     &quot;  completed boolean,\n&quot; +
                     &quot;  duration_millis bigint,\n&quot; +
                     &quot;  failure_cause text,\n&quot; +
                     &quot;  success_message text,\n&quot;;
<span class="fc bfc" id="L488" title="All 2 branches covered.">        if (!time)</span>
<span class="fc" id="L489">            str = str.replace(&quot;id timeuuid&quot;, &quot;id uuid&quot;);</span>
<span class="fc" id="L490">        return str + stdStateColumns();</span>
    }

    private static String stdColumnsWithStatus(boolean time)
    {
<span class="fc" id="L495">        return stdColumns(time) + &quot;  status text,\n&quot;;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>