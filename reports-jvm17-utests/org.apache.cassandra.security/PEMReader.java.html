<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PEMReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.security</a> &gt; <span class="el_source">PEMReader.java</span></div><h1>PEMReader.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.security;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.security.AlgorithmParameters;
import java.security.GeneralSecurityException;
import java.security.Key;
import java.security.KeyFactory;
import java.security.PrivateKey;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.EncryptedPrivateKeyInfo;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;

import com.google.common.collect.ImmutableSet;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static java.util.regex.Pattern.CASE_INSENSITIVE;

/**
 * This is a helper class to read private keys and X509 certifificates encoded based on &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc1421&quot;&gt;PEM (RFC 1421)&lt;/a&gt;
 * format. It can read Password Based Encrypted (PBE henceforth) private keys as well as non-encrypted private keys
 * along with the X509 certificates/cert-chain based on the textual encoding defined in the &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7468&quot;&gt;RFC 7468&lt;/a&gt;
 * &lt;p&gt;
 * The input private key must be in PKCS#8 format.
 * &lt;p&gt;
 * It returns PKCS#8 formatted private key and X509 certificates.
 */
<span class="nc" id="L60">public final class PEMReader</span>
{
    /**
     * The private key can be with any of these algorithms in order for this read to successfully parse it.
     * Currently, supported algorithms are,
     * &lt;pre&gt;
     *     RSA, DSA or EC
     * &lt;/pre&gt;
     * The first one to be evaluated is RSA, being the most common for private keys.
     */
<span class="fc" id="L70">    public static final Set&lt;String&gt; SUPPORTED_PRIVATE_KEY_ALGORITHMS = ImmutableSet.of(&quot;RSA&quot;, &quot;DSA&quot;, &quot;EC&quot;);</span>
<span class="fc" id="L71">    private static final Logger logger = LoggerFactory.getLogger(PEMReader.class);</span>
<span class="fc" id="L72">    private static final Pattern CERT_PATTERN = Pattern.compile(&quot;-+BEGIN\\s+.*CERTIFICATE[^-]*-+(?:\\s|\\r|\\n)+([a-z0-9+/=\\r\\n]+)-+END\\s+.*CERTIFICATE[^-]*-+&quot;, CASE_INSENSITIVE);</span>
<span class="fc" id="L73">    private static final Pattern KEY_PATTERN = Pattern.compile(&quot;-+BEGIN\\s+.*PRIVATE\\s+KEY[^-]*-+(?:\\s|\\r|\\n)+([a-z0-9+/=\\r\\n]+)-+END\\s+.*PRIVATE\\s+KEY[^-]*-+&quot;, CASE_INSENSITIVE);</span>

    /**
     * Extracts private key from the PEM content for the private key, assuming its not PBE.
     *
     * @param unencryptedPEMKey private key stored as PEM content
     * @return {@link PrivateKey} upon successful reading of the private key
     * @throws IOException              in case PEM reading fails
     * @throws GeneralSecurityException in case any issue encountered while reading the private key
     */
    public static PrivateKey extractPrivateKey(String unencryptedPEMKey) throws IOException, GeneralSecurityException
    {
<span class="fc" id="L85">        return extractPrivateKey(unencryptedPEMKey, null);</span>
    }

    /**
     * Extracts private key from the Password Based Encrypted PEM content for the private key.
     *
     * @param pemKey      PBE private key stored as PEM content
     * @param keyPassword password to be used for the private key decryption
     * @return {@link PrivateKey} upon successful reading of the private key
     * @throws IOException              in case PEM reading fails
     * @throws GeneralSecurityException in case any issue encountered while reading the private key
     */
    public static PrivateKey extractPrivateKey(String pemKey, String keyPassword) throws IOException,
                                                                                         GeneralSecurityException
    {
        PKCS8EncodedKeySpec keySpec;
<span class="fc" id="L101">        String base64EncodedKey = extractBase64EncodedKey(pemKey);</span>
<span class="fc" id="L102">        byte[] derKeyBytes = decodeBase64(base64EncodedKey);</span>

<span class="fc bfc" id="L104" title="All 2 branches covered.">        if (!StringUtils.isEmpty(keyPassword))</span>
        {
<span class="fc" id="L106">            logger.debug(&quot;Encrypted key's length: {}, key's password length: {}&quot;,</span>
<span class="fc" id="L107">                         derKeyBytes.length, keyPassword.length());</span>

<span class="fc" id="L109">            EncryptedPrivateKeyInfo epki = new EncryptedPrivateKeyInfo(derKeyBytes);</span>
<span class="fc" id="L110">            logger.debug(&quot;Encrypted private key info's algorithm name: {}&quot;, epki.getAlgName());</span>

<span class="fc" id="L112">            AlgorithmParameters params = epki.getAlgParameters();</span>
<span class="fc" id="L113">            PBEKeySpec pbeKeySpec = new PBEKeySpec(keyPassword.toCharArray());</span>
<span class="fc" id="L114">            Key encryptionKey = SecretKeyFactory.getInstance(epki.getAlgName()).generateSecret(pbeKeySpec);</span>
<span class="fc" id="L115">            pbeKeySpec.clearPassword();</span>
<span class="fc" id="L116">            logger.debug(&quot;Key algorithm: {}, key format: {}&quot;, encryptionKey.getAlgorithm(), encryptionKey.getFormat());</span>

<span class="fc" id="L118">            Cipher cipher = Cipher.getInstance(epki.getAlgName());</span>
<span class="fc" id="L119">            cipher.init(Cipher.DECRYPT_MODE, encryptionKey, params);</span>
            byte[] rawKeyBytes;
            try
            {
<span class="fc" id="L123">                rawKeyBytes = cipher.doFinal(epki.getEncryptedData());</span>
            }
<span class="fc" id="L125">            catch (BadPaddingException e)</span>
            {
<span class="fc" id="L127">                throw new GeneralSecurityException(&quot;Failed to decrypt the private key data. Either the password &quot; +</span>
                                                   &quot;provided for the key is wrong or the private key data is &quot; +
<span class="fc" id="L129">                                                   &quot;corrupted. msg=&quot; + e.getMessage(), e);</span>
<span class="fc" id="L130">            }</span>
<span class="fc" id="L131">            logger.debug(&quot;Decrypted private key's length: {}&quot;, rawKeyBytes.length);</span>

<span class="fc" id="L133">            keySpec = new PKCS8EncodedKeySpec(rawKeyBytes);</span>
<span class="fc" id="L134">        }</span>
        else
        {
<span class="fc" id="L137">            logger.debug(&quot;Key length: {}&quot;, derKeyBytes.length);</span>
<span class="fc" id="L138">            keySpec = new PKCS8EncodedKeySpec(derKeyBytes);</span>
        }

<span class="fc" id="L141">        PrivateKey privateKey = null;</span>

        /*
         * Ideally we can inspect the OID (Object Identifier) from the private key with ASN.1 parser and identify the
         * actual algorithm of the private key. For doing that, we have to use some special library like BouncyCastle.
         * However in the absence of that, below brute-force approach can work- that is to try out all the supported
         * private key algorithms given that there are only three major algorithms to verify against.
         */
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        for (String privateKeyAlgorithm : SUPPORTED_PRIVATE_KEY_ALGORITHMS)</span>
        {
            try
            {
<span class="fc" id="L153">                privateKey = KeyFactory.getInstance(privateKeyAlgorithm).generatePrivate(keySpec);</span>
<span class="fc" id="L154">                logger.info(&quot;Parsing for the private key finished with {} algorithm.&quot;, privateKeyAlgorithm);</span>
<span class="fc" id="L155">                return privateKey;</span>
            }
<span class="fc" id="L157">            catch (Exception e)</span>
            {
<span class="fc" id="L159">                logger.debug(&quot;Failed to parse the private key with {} algorithm. Will try the other supported &quot; +</span>
                             &quot;algorithms.&quot;, privateKeyAlgorithm);
            }
<span class="fc" id="L162">        }</span>
<span class="nc" id="L163">        throw new GeneralSecurityException(&quot;The given private key could not be parsed with any of the supported &quot; +</span>
                                           &quot;algorithms. Please see PEMReader#SUPPORTED_PRIVATE_KEY_ALGORITHMS.&quot;);
    }

    /**
     * Extracts the certificates/cert-chain from the PEM content.
     *
     * @param pemCerts certificates/cert-chain stored as PEM content
     * @return X509 certiificate list
     * @throws GeneralSecurityException in case any issue encountered while reading the certificates
     */
    public static Certificate[] extractCertificates(String pemCerts) throws GeneralSecurityException
    {
<span class="fc" id="L176">        List&lt;Certificate&gt; certificateList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L177">        List&lt;String&gt; base64EncodedCerts = extractBase64EncodedCerts(pemCerts);</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">        for (String base64EncodedCertificate : base64EncodedCerts)</span>
        {
<span class="fc" id="L180">            certificateList.add(generateCertificate(base64EncodedCertificate));</span>
<span class="fc" id="L181">        }</span>
<span class="fc" id="L182">        Certificate[] certificates = certificateList.toArray(new Certificate[0]);</span>
<span class="fc" id="L183">        return certificates;</span>
    }

    /**
     * Generates the X509 certificate object given the base64 encoded PEM content.
     *
     * @param base64Certificate base64 encoded PEM content for the certificate
     * @return X509 certificate
     * @throws GeneralSecurityException in case any issue encountered while reading the certificate
     */
    private static Certificate generateCertificate(String base64Certificate) throws GeneralSecurityException
    {
<span class="fc" id="L195">        byte[] decodedCertificateBytes = decodeBase64(base64Certificate);</span>
<span class="fc" id="L196">        CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;);</span>
<span class="fc" id="L197">        X509Certificate certificate =</span>
<span class="fc" id="L198">        (X509Certificate) certificateFactory.generateCertificate(new ByteArrayInputStream(decodedCertificateBytes));</span>
<span class="fc" id="L199">        logCertificateDetails(certificate);</span>
<span class="fc" id="L200">        return certificate;</span>
    }

    /**
     * Logs X509 certificate details for the debugging purpose with {@code INFO} level log.
     * Namely, it prints - Subject DN, Issuer DN, Certificate serial number and the certificate expiry date which
     * could be very valuable for debugging any certificate related issues.
     *
     * @param certificate certificate to log
     */
    private static void logCertificateDetails(X509Certificate certificate)
    {
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">        assert certificate != null;</span>
<span class="fc" id="L213">        logger.info(&quot;*********** Certificate Details *****************&quot;);</span>
<span class="fc" id="L214">        logger.info(&quot;Subject DN: {}&quot;, certificate.getSubjectDN());</span>
<span class="fc" id="L215">        logger.info(&quot;Issuer DN: {}&quot;, certificate.getIssuerDN());</span>
<span class="fc" id="L216">        logger.info(&quot;Serial Number: {}&quot;, certificate.getSerialNumber());</span>
<span class="fc" id="L217">        logger.info(&quot;Expiry: {}&quot;, certificate.getNotAfter());</span>
<span class="fc" id="L218">    }</span>

    /**
     * Parses the PEM formatted private key based on the standard pattern specified by the &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7468#section-11&quot;&gt;RFC 7468&lt;/a&gt;.
     *
     * @param pemKey private key stored as PEM content
     * @return base64 string contained within the defined encapsulation boundaries by the above RFC
     * @throws GeneralSecurityException in case any issue encountered while parsing the key
     */
    private static String extractBase64EncodedKey(String pemKey) throws GeneralSecurityException
    {
<span class="fc" id="L229">        Matcher matcher = KEY_PATTERN.matcher(pemKey);</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">        if (matcher.find())</span>
        {
<span class="fc" id="L232">            return matcher.group(1).replaceAll(&quot;\\s&quot;, &quot;&quot;);</span>
        }
        else
        {
<span class="fc" id="L236">            throw new GeneralSecurityException(&quot;Invalid private key format&quot;);</span>
        }
    }

    /**
     * Parses the PEM formatted certificate/public-key based on the standard pattern specified by the
     * &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7468#section-13&quot;&gt;RFC 7468&lt;/a&gt;.
     *
     * @param pemCerts certificate/public-key stored as PEM content
     * @return list of base64 encoded certificates within the defined encapsulation boundaries by the above RFC
     * @throws GeneralSecurityException in case any issue encountered parsing the certificate
     */
    private static List&lt;String&gt; extractBase64EncodedCerts(String pemCerts) throws GeneralSecurityException
    {
<span class="fc" id="L250">        List&lt;String&gt; certificateList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L251">        Matcher matcher = CERT_PATTERN.matcher(pemCerts);</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">        if (!matcher.find())</span>
        {
<span class="fc" id="L254">            throw new GeneralSecurityException(&quot;Invalid certificate format&quot;);</span>
        }

<span class="fc bfc" id="L257" title="All 2 branches covered.">        for (int start = 0; matcher.find(start); start = matcher.end())</span>
        {
<span class="fc" id="L259">            String certificate = matcher.group(1).replaceAll(&quot;\\s&quot;, &quot;&quot;);</span>
<span class="fc" id="L260">            certificateList.add(certificate);</span>
        }
<span class="fc" id="L262">        return certificateList;</span>
    }

    /**
     * Decodes given input in Base64 format.
     *
     * @param base64Input input to be decoded
     * @return byte[] containing decoded bytes
     * @throws GeneralSecurityException in case it fails to decode the given base64 input
     */
    private static byte[] decodeBase64(String base64Input) throws GeneralSecurityException
    {
        try
        {
<span class="fc" id="L276">            return Base64.getDecoder().decode(base64Input);</span>
        }
<span class="fc" id="L278">        catch (IllegalArgumentException e)</span>
        {
<span class="fc" id="L280">            throw new GeneralSecurityException(&quot;Failed to decode given base64 input. msg=&quot; + e.getMessage(), e);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>