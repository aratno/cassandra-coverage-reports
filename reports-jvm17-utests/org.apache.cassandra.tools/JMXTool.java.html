<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JMXTool.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.tools</a> &gt; <span class="el_source">JMXTool.java</span></div><h1>JMXTool.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.tools;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintStream;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.concurrent.Callable;
import java.util.function.BiConsumer;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.inject.Inject;
import javax.management.InstanceNotFoundException;
import javax.management.IntrospectionException;
import javax.management.MBeanAttributeInfo;
import javax.management.MBeanFeatureInfo;
import javax.management.MBeanInfo;
import javax.management.MBeanOperationInfo;
import javax.management.MBeanParameterInfo;
import javax.management.MBeanServerConnection;
import javax.management.MalformedObjectNameException;
import javax.management.ObjectName;
import javax.management.ReflectionException;
import javax.management.remote.JMXConnector;
import javax.management.remote.JMXConnectorFactory;
import javax.management.remote.JMXServiceURL;

import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.collect.Sets;
import com.google.common.collect.Sets.SetView;

import com.fasterxml.jackson.core.type.TypeReference;
import io.airlift.airline.Arguments;
import io.airlift.airline.Cli;
import io.airlift.airline.Command;
import io.airlift.airline.Help;
import io.airlift.airline.HelpOption;
import io.airlift.airline.Option;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.io.util.FileInputStreamPlus;
import org.apache.cassandra.utils.JsonUtils;
import org.yaml.snakeyaml.TypeDescription;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.constructor.Constructor;
import org.yaml.snakeyaml.nodes.MappingNode;
import org.yaml.snakeyaml.nodes.Node;
import org.yaml.snakeyaml.nodes.Tag;
import org.yaml.snakeyaml.representer.Representer;

<span class="nc" id="L82">public class JMXTool</span>
{
<span class="nc" id="L84">    private static final List&lt;String&gt; METRIC_PACKAGES = Arrays.asList(&quot;org.apache.cassandra.metrics&quot;,</span>
                                                                      &quot;org.apache.cassandra.db&quot;,
                                                                      &quot;org.apache.cassandra.hints&quot;,
                                                                      &quot;org.apache.cassandra.internal&quot;,
                                                                      &quot;org.apache.cassandra.net&quot;,
                                                                      &quot;org.apache.cassandra.request&quot;,
                                                                      &quot;org.apache.cassandra.service&quot;);

<span class="nc" id="L92">    private static final Comparator&lt;MBeanOperationInfo&gt; OPERATOR_COMPARATOR = (a, b) -&gt; {</span>
<span class="nc" id="L93">        int rc = a.getName().compareTo(b.getName());</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">        if (rc != 0)</span>
<span class="nc" id="L95">            return rc;</span>
<span class="nc" id="L96">        String[] aSig = Stream.of(a.getSignature()).map(MBeanParameterInfo::getName).toArray(String[]::new);</span>
<span class="nc" id="L97">        String[] bSig = Stream.of(b.getSignature()).map(MBeanParameterInfo::getName).toArray(String[]::new);</span>
<span class="nc" id="L98">        rc = Integer.compare(aSig.length, bSig.length);</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (rc != 0)</span>
<span class="nc" id="L100">            return rc;</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">        for (int i = 0; i &lt; aSig.length; i++)</span>
        {
<span class="nc" id="L103">            rc = aSig[i].compareTo(bSig[i]);</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">            if (rc != 0)</span>
<span class="nc" id="L105">                return rc;</span>
        }
<span class="nc" id="L107">        return rc;</span>
    };

    @Command(name = &quot;dump&quot;, description = &quot;Dump the Apache Cassandra JMX objects and metadata.&quot;)
    public static final class Dump implements Callable&lt;Void&gt;
    {
        @Inject
        private HelpOption helpOption;

        @Option(title = &quot;url&quot;, name = { &quot;-u&quot;, &quot;--url&quot; }, description = &quot;JMX url to target&quot;)
        private String targetUrl = &quot;service:jmx:rmi:///jndi/rmi://localhost:7199/jmxrmi&quot;;

        @Option(title = &quot;format&quot;, name = { &quot;-f&quot;, &quot;--format&quot; }, description = &quot;What format to dump content as; supported values are console (default), json, and yaml&quot;)
        private Format format = Format.console;

        public Void call() throws Exception
        {
            Map&lt;String, Info&gt; map = load(new JMXServiceURL(targetUrl));
            format.dump(System.out, map);
            return null;
        }

<span class="fc" id="L129">        public enum Format</span>
        {
<span class="fc" id="L131">            console</span>
            {
                void dump(OutputStream output, Map&lt;String, Info&gt; map)
                {
                    @SuppressWarnings(&quot;resource&quot;)
                    // output should be released by caller
<span class="nc" id="L137">                    PrintStream out = toPrintStream(output);</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">                    for (Map.Entry&lt;String, Info&gt; e : map.entrySet())</span>
                    {
<span class="nc" id="L140">                        String name = e.getKey();</span>
<span class="nc" id="L141">                        Info info = e.getValue();</span>

<span class="nc" id="L143">                        out.println(name);</span>
<span class="nc" id="L144">                        out.println(&quot;\tAttributes&quot;);</span>
<span class="nc" id="L145">                        Stream.of(info.attributes).forEach(a -&gt; printRow(out, a.name, a.type, a.access));</span>
<span class="nc" id="L146">                        out.println(&quot;\tOperations&quot;);</span>
<span class="nc" id="L147">                        Stream.of(info.operations).forEach(o -&gt; {</span>
<span class="nc" id="L148">                            String args = Stream.of(o.parameters)</span>
<span class="nc" id="L149">                                                .map(i -&gt; i.name + &quot;: &quot; + i.type)</span>
<span class="nc" id="L150">                                                .collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;));</span>
<span class="nc" id="L151">                            printRow(out, o.name, o.returnType, args);</span>
<span class="nc" id="L152">                        });</span>
<span class="nc" id="L153">                    }</span>
<span class="nc" id="L154">                }</span>
            },
<span class="fc" id="L156">            json</span>
            {
                void dump(OutputStream output, Map&lt;String, Info&gt; map) throws IOException
                {
<span class="fc" id="L160">                    JsonUtils.JSON_OBJECT_PRETTY_WRITER.writeValue(output, map);</span>
<span class="fc" id="L161">                }</span>
            },
<span class="fc" id="L163">            yaml</span>
            {
                void dump(OutputStream output, Map&lt;String, Info&gt; map) throws IOException
                {
<span class="fc" id="L167">                    Representer representer = new Representer();</span>
<span class="fc" id="L168">                    representer.addClassTag(Info.class, Tag.MAP); // avoid the auto added tag</span>
<span class="fc" id="L169">                    Yaml yaml = new Yaml(representer);</span>
<span class="fc" id="L170">                    yaml.dump(map, new OutputStreamWriter(output));</span>
<span class="fc" id="L171">                }</span>
            };

            private static PrintStream toPrintStream(OutputStream output)
            {
                try
                {
<span class="nc bnc" id="L178" title="All 2 branches missed.">                    return output instanceof PrintStream ? (PrintStream) output : new PrintStream(output, true, &quot;UTF-8&quot;);</span>
                }
<span class="nc" id="L180">                catch (UnsupportedEncodingException e)</span>
                {
<span class="nc" id="L182">                    throw new AssertionError(e); // utf-8 is a required charset for the JVM</span>
                }
            }

            abstract void dump(OutputStream output, Map&lt;String, Info&gt; map) throws IOException;
        }
    }

    @Command(name = &quot;diff&quot;, description = &quot;Diff two jmx dump files and report their differences&quot;)
    public static final class Diff implements Callable&lt;Void&gt;
    {
        @Inject
        private HelpOption helpOption;

        @Arguments(title = &quot;files&quot;, usage = &quot;&lt;left&gt; &lt;right&gt;&quot;, description = &quot;Files to diff&quot;)
        private List&lt;File&gt; files;

        @Option(title = &quot;format&quot;, name = { &quot;-f&quot;, &quot;--format&quot; }, description = &quot;What format the files are in; only support json and yaml as format&quot;)
        private Format format = Format.yaml;

        @Option(title = &quot;ignore left&quot;, name = { &quot;--ignore-missing-on-left&quot; }, description = &quot;Ignore results missing on the left&quot;)
        private boolean ignoreMissingLeft;

        @Option(title = &quot;ignore right&quot;, name = { &quot;--ignore-missing-on-right&quot; }, description = &quot;Ignore results missing on the right&quot;)
        private boolean ignoreMissingRight;

        @Option(title = &quot;exclude objects&quot;, name = &quot;--exclude-object&quot;, description
                                                                      = &quot;Ignores processing specific objects. &quot; +
                                                                        &quot;Each usage should take a single object, &quot; +
                                                                        &quot;but can use this flag multiple times.&quot;)
        private List&lt;CliPattern&gt; excludeObjects = new ArrayList&lt;&gt;();

        @Option(title = &quot;exclude attributes&quot;, name = &quot;--exclude-attribute&quot;, description
                                                                            = &quot;Ignores processing specific attributes. &quot; +
                                                                              &quot;Each usage should take a single attribute, &quot; +
                                                                              &quot;but can use this flag multiple times.&quot;)
        private List&lt;CliPattern&gt; excludeAttributes = new ArrayList&lt;&gt;();

        @Option(title = &quot;exclude operations&quot;, name = &quot;--exclude-operation&quot;, description
                                                                            = &quot;Ignores processing specific operations. &quot; +
                                                                              &quot;Each usage should take a single operation, &quot; +
                                                                              &quot;but can use this flag multiple times.&quot;)
        private List&lt;CliPattern&gt; excludeOperations = new ArrayList&lt;&gt;();

        public Void call() throws Exception
        {
            Preconditions.checkArgument(files.size() == 2, &quot;files requires 2 arguments but given %s&quot;, files);
            Map&lt;String, Info&gt; left;
            Map&lt;String, Info&gt; right;
            try (FileInputStreamPlus leftStream = new FileInputStreamPlus(files.get(0));
                 FileInputStreamPlus rightStream = new FileInputStreamPlus(files.get(1)))
            {
                left = format.load(leftStream);
                right = format.load(rightStream);
            }

            diff(left, right);
            return null;
        }

        private void diff(Map&lt;String, Info&gt; left, Map&lt;String, Info&gt; right)
        {
            DiffResult&lt;String&gt; objectNames = diff(left.keySet(), right.keySet(), name -&gt; {
                for (CliPattern p : excludeObjects)
                {
                    if (p.pattern.matcher(name).matches())
                        return false;
                }
                return true;
            });

            if (!ignoreMissingRight &amp;&amp; !objectNames.notInRight.isEmpty())
            {
                System.out.println(&quot;Objects not in right:&quot;);
                printSet(0, objectNames.notInRight);
            }
            if (!ignoreMissingLeft &amp;&amp; !objectNames.notInLeft.isEmpty())
            {
                System.out.println(&quot;Objects not in left: &quot;);
                printSet(0, objectNames.notInLeft);
            }
            Runnable printHeader = new Runnable()
            {
                boolean printedHeader = false;

                public void run()
                {
                    if (!printedHeader)
                    {
                        System.out.println(&quot;Difference found in attribute or operation&quot;);
                        printedHeader = true;
                    }
                }
            };

            for (String key : objectNames.shared)
            {
                Info leftInfo = left.get(key);
                Info rightInfo = right.get(key);
                DiffResult&lt;Attribute&gt; attributes = diff(leftInfo.attributeSet(), rightInfo.attributeSet(), attribute -&gt; {
                    for (CliPattern p : excludeAttributes)
                    {
                        if (p.pattern.matcher(attribute.name).matches())
                            return false;
                    }
                    return true;
                });
                if (!ignoreMissingRight &amp;&amp; !attributes.notInRight.isEmpty())
                {
                    printHeader.run();
                    System.out.println(key + &quot;\tattribute not in right:&quot;);
                    printSet(1, attributes.notInRight);
                }
                if (!ignoreMissingLeft &amp;&amp; !attributes.notInLeft.isEmpty())
                {
                    printHeader.run();
                    System.out.println(key + &quot;\tattribute not in left:&quot;);
                    printSet(1, attributes.notInLeft);
                }

                DiffResult&lt;Operation&gt; operations = diff(leftInfo.operationSet(), rightInfo.operationSet(), operation -&gt; {
                    for (CliPattern p : excludeOperations)
                    {
                        if (p.pattern.matcher(operation.name).matches())
                            return false;
                    }
                    return true;
                });
                if (!ignoreMissingRight &amp;&amp; !operations.notInRight.isEmpty())
                {
                    printHeader.run();
                    System.out.println(key + &quot;\toperation not in right:&quot;);
                    printSet(1, operations.notInRight, (sb, o) -&gt;
                                                       rightInfo.getOperation(o.name).ifPresent(match -&gt;
                                                                                                sb.append(&quot;\t&quot;).append(&quot;similar in right: &quot;).append(match)));
                }
                if (!ignoreMissingLeft &amp;&amp; !operations.notInLeft.isEmpty())
                {
                    printHeader.run();
                    System.out.println(key + &quot;\toperation not in left:&quot;);
                    printSet(1, operations.notInLeft, (sb, o) -&gt;
                                                      leftInfo.getOperation(o.name).ifPresent(match -&gt;
                                                                                              sb.append(&quot;\t&quot;).append(&quot;similar in left: &quot;).append(match)));
                }
            }
        }

        private static &lt;T extends Comparable&lt;T&gt;&gt; void printSet(int indent, Set&lt;T&gt; set)
        {
            printSet(indent, set, (i1, i2) -&gt; {});
        }

        private static &lt;T extends Comparable&lt;T&gt;&gt; void printSet(int indent, Set&lt;T&gt; set, BiConsumer&lt;StringBuilder, T&gt; fn)
        {
            StringBuilder sb = new StringBuilder();
            for (T t : new TreeSet&lt;&gt;(set))
            {
                sb.setLength(0);
                for (int i = 0; i &lt; indent; i++)
                    sb.append('\t');
                sb.append(t);
                fn.accept(sb, t);
                System.out.println(sb);
            }
        }

        private static &lt;T&gt; DiffResult&lt;T&gt; diff(Set&lt;T&gt; left, Set&lt;T&gt; right, Predicate&lt;T&gt; fn)
        {
            left = Sets.filter(left, fn);
            right = Sets.filter(right, fn);
            return new DiffResult&lt;&gt;(Sets.difference(left, right), Sets.difference(right, left), Sets.intersection(left, right));
        }

        private static final class DiffResult&lt;T&gt;
        {
            private final SetView&lt;T&gt; notInRight;
            private final SetView&lt;T&gt; notInLeft;
            private final SetView&lt;T&gt; shared;

            private DiffResult(SetView&lt;T&gt; notInRight, SetView&lt;T&gt; notInLeft, SetView&lt;T&gt; shared)
            {
                this.notInRight = notInRight;
                this.notInLeft = notInLeft;
                this.shared = shared;
            }
        }

<span class="fc" id="L369">        public enum Format</span>
        {
<span class="fc" id="L371">            json</span>
            {
                Map&lt;String, Info&gt; load(InputStream input) throws IOException
                {
<span class="fc" id="L375">                    return JsonUtils.JSON_OBJECT_MAPPER.readValue(input, new TypeReference&lt;Map&lt;String, Info&gt;&gt;() {});</span>
                }
            },
<span class="fc" id="L378">            yaml</span>
            {
                Map&lt;String, Info&gt; load(InputStream input) throws IOException
                {
<span class="fc" id="L382">                    Yaml yaml = new Yaml(new CustomConstructor());</span>
<span class="fc" id="L383">                    return (Map&lt;String, Info&gt;) yaml.load(input);</span>
                }
            };

            abstract Map&lt;String, Info&gt; load(InputStream input) throws IOException;
        }

        private static final class CustomConstructor extends Constructor
        {
            private static final String ROOT = &quot;__root__&quot;;
<span class="fc" id="L393">            private static final TypeDescription INFO_TYPE = new TypeDescription(Info.class);</span>

            public CustomConstructor()
<span class="fc" id="L396">            {</span>
<span class="fc" id="L397">                this.rootTag = new Tag(ROOT);</span>
<span class="fc" id="L398">                this.addTypeDescription(INFO_TYPE);</span>
<span class="fc" id="L399">            }</span>

            protected Object constructObject(Node node)
            {
<span class="pc bpc" id="L403" title="1 of 4 branches missed.">                if (ROOT.equals(node.getTag().getValue()) &amp;&amp; node instanceof MappingNode)</span>
                {
<span class="fc" id="L405">                    MappingNode mn = (MappingNode) node;</span>
<span class="fc" id="L406">                    return mn.getValue().stream()</span>
<span class="fc" id="L407">                                .collect(Collectors.toMap(t -&gt; super.constructObject(t.getKeyNode()),</span>
                                                          t -&gt; {
<span class="fc" id="L409">                                                              Node child = t.getValueNode();</span>
<span class="fc" id="L410">                                                              child.setType(INFO_TYPE.getType());</span>
<span class="fc" id="L411">                                                              return super.constructObject(child);</span>
                                                          }));
                }
                else
                {
<span class="fc" id="L416">                    return super.constructObject(node);</span>
                }
            }
        }
    }

    private static Map&lt;String, Info&gt; load(JMXServiceURL url) throws IOException, MalformedObjectNameException, IntrospectionException, InstanceNotFoundException, ReflectionException
    {
<span class="nc" id="L424">        try (JMXConnector jmxc = JMXConnectorFactory.connect(url, null))</span>
        {
<span class="nc" id="L426">            MBeanServerConnection mbsc = jmxc.getMBeanServerConnection();</span>

<span class="nc" id="L428">            Map&lt;String, Info&gt; map = new TreeMap&lt;&gt;();</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">            for (String pkg : new TreeSet&lt;&gt;(METRIC_PACKAGES))</span>
            {
<span class="nc" id="L431">                Set&lt;ObjectName&gt; metricNames = new TreeSet&lt;&gt;(mbsc.queryNames(new ObjectName(pkg + &quot;:*&quot;), null));</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">                for (ObjectName name : metricNames)</span>
                {
<span class="nc bnc" id="L434" title="All 2 branches missed.">                    if (mbsc.isRegistered(name))</span>
                    {
<span class="nc" id="L436">                        MBeanInfo info = mbsc.getMBeanInfo(name);</span>
<span class="nc" id="L437">                        map.put(name.toString(), Info.from(info));</span>
                    }
<span class="nc" id="L439">                }</span>
<span class="nc" id="L440">            }</span>
<span class="nc" id="L441">            return map;</span>
        }
    }

    private static String getAccess(MBeanAttributeInfo a)
    {
        String access;
<span class="nc bnc" id="L448" title="All 2 branches missed.">        if (a.isReadable())</span>
        {
<span class="nc bnc" id="L450" title="All 2 branches missed.">            if (a.isWritable())</span>
<span class="nc" id="L451">                access = &quot;read/write&quot;;</span>
            else
<span class="nc" id="L453">                access = &quot;read-only&quot;;</span>
        }
<span class="nc bnc" id="L455" title="All 2 branches missed.">        else if (a.isWritable())</span>
<span class="nc" id="L456">            access = &quot;write-only&quot;;</span>
        else
<span class="nc" id="L458">            access = &quot;no-access&quot;;</span>
<span class="nc" id="L459">        return access;</span>
    }

    private static String normalizeType(String type)
    {
<span class="nc bnc" id="L464" title="All 9 branches missed.">        switch (type)</span>
        {
            case &quot;[Z&quot;:
<span class="nc" id="L467">                return &quot;boolean[]&quot;;</span>
            case &quot;[B&quot;:
<span class="nc" id="L469">                return &quot;byte[]&quot;;</span>
            case &quot;[S&quot;:
<span class="nc" id="L471">                return &quot;short[]&quot;;</span>
            case &quot;[I&quot;:
<span class="nc" id="L473">                return &quot;int[]&quot;;</span>
            case &quot;[J&quot;:
<span class="nc" id="L475">                return &quot;long[]&quot;;</span>
            case &quot;[F&quot;:
<span class="nc" id="L477">                return &quot;float[]&quot;;</span>
            case &quot;[D&quot;:
<span class="nc" id="L479">                return &quot;double[]&quot;;</span>
            case &quot;[C&quot;:
<span class="nc" id="L481">                return &quot;char[]&quot;;</span>
        }
<span class="nc bnc" id="L483" title="All 2 branches missed.">        if (type.startsWith(&quot;[L&quot;))</span>
<span class="nc" id="L484">            return type.substring(2, type.length() - 1) + &quot;[]&quot;; // -1 will remove the ; at the end</span>
<span class="nc" id="L485">        return type;</span>
    }

<span class="nc" id="L488">    private static final StringBuilder ROW_BUFFER = new StringBuilder();</span>

    private static void printRow(PrintStream out, String... args)
    {
<span class="nc" id="L492">        ROW_BUFFER.setLength(0);</span>
<span class="nc" id="L493">        ROW_BUFFER.append(&quot;\t\t&quot;);</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">        for (String a : args)</span>
<span class="nc" id="L495">            ROW_BUFFER.append(a).append(&quot;\t&quot;);</span>
<span class="nc" id="L496">        out.println(ROW_BUFFER);</span>
<span class="nc" id="L497">    }</span>

    public static final class Info
    {
        private Attribute[] attributes;
        private Operation[] operations;

        public Info()
<span class="fc" id="L505">        {</span>
<span class="fc" id="L506">        }</span>

        public Info(Attribute[] attributes, Operation[] operations)
<span class="fc" id="L509">        {</span>
<span class="fc" id="L510">            this.attributes = attributes;</span>
<span class="fc" id="L511">            this.operations = operations;</span>
<span class="fc" id="L512">        }</span>

        private static Info from(MBeanInfo info)
        {
<span class="nc" id="L516">            Attribute[] attributes = Stream.of(info.getAttributes())</span>
<span class="nc" id="L517">                                           .sorted(Comparator.comparing(MBeanFeatureInfo::getName))</span>
<span class="nc" id="L518">                                           .map(Attribute::from)</span>
<span class="nc" id="L519">                                           .toArray(Attribute[]::new);</span>

<span class="nc" id="L521">            Operation[] operations = Stream.of(info.getOperations())</span>
<span class="nc" id="L522">                                           .sorted(OPERATOR_COMPARATOR)</span>
<span class="nc" id="L523">                                           .map(Operation::from)</span>
<span class="nc" id="L524">                                           .toArray(Operation[]::new);</span>
<span class="nc" id="L525">            return new Info(attributes, operations);</span>
        }

        public Attribute[] getAttributes()
        {
<span class="fc" id="L530">            return attributes;</span>
        }

        public void setAttributes(Attribute[] attributes)
        {
<span class="fc" id="L535">            this.attributes = attributes;</span>
<span class="fc" id="L536">        }</span>

        public Set&lt;String&gt; attributeNames()
        {
<span class="nc" id="L540">            return Stream.of(attributes).map(a -&gt; a.name).collect(Collectors.toSet());</span>
        }

        public Set&lt;Attribute&gt; attributeSet()
        {
<span class="nc" id="L545">            return new HashSet&lt;&gt;(Arrays.asList(attributes));</span>
        }

        public Operation[] getOperations()
        {
<span class="fc" id="L550">            return operations;</span>
        }

        public void setOperations(Operation[] operations)
        {
<span class="fc" id="L555">            this.operations = operations;</span>
<span class="fc" id="L556">        }</span>

        public Set&lt;String&gt; operationNames()
        {
<span class="nc" id="L560">            return Stream.of(operations).map(o -&gt; o.name).collect(Collectors.toSet());</span>
        }

        public Set&lt;Operation&gt; operationSet()
        {
<span class="nc" id="L565">            return new HashSet&lt;&gt;(Arrays.asList(operations));</span>
        }

        public Optional&lt;Attribute&gt; getAttribute(String name)
        {
<span class="nc" id="L570">            return Stream.of(attributes).filter(a -&gt; a.name.equals(name)).findFirst();</span>
        }

        public Attribute getAttributePresent(String name)
        {
<span class="nc" id="L575">            return getAttribute(name).orElseThrow(AssertionError::new);</span>
        }

        public Optional&lt;Operation&gt; getOperation(String name)
        {
<span class="nc" id="L580">            return Stream.of(operations).filter(o -&gt; o.name.equals(name)).findFirst();</span>
        }

        public Operation getOperationPresent(String name)
        {
<span class="nc" id="L585">            return getOperation(name).orElseThrow(AssertionError::new);</span>
        }

        @Override
        public boolean equals(Object o)
        {
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">            if (this == o) return true;</span>
<span class="pc bpc" id="L592" title="2 of 4 branches missed.">            if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L593">            Info info = (Info) o;</span>
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">            return Arrays.equals(attributes, info.attributes) &amp;&amp;</span>
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">                   Arrays.equals(operations, info.operations);</span>
        }

        @Override
        public int hashCode()
        {
<span class="nc" id="L601">            int result = Arrays.hashCode(attributes);</span>
<span class="nc" id="L602">            result = 31 * result + Arrays.hashCode(operations);</span>
<span class="nc" id="L603">            return result;</span>
        }
    }

    public static final class Attribute implements Comparable&lt;Attribute&gt;
    {
        private String name;
        private String type;
        private String access;

        public Attribute()
<span class="fc" id="L614">        {</span>
<span class="fc" id="L615">        }</span>

        public Attribute(String name, String type, String access)
<span class="fc" id="L618">        {</span>
<span class="fc" id="L619">            this.name = name;</span>
<span class="fc" id="L620">            this.type = type;</span>
<span class="fc" id="L621">            this.access = access;</span>
<span class="fc" id="L622">        }</span>

        private static Attribute from(MBeanAttributeInfo info)
        {
<span class="nc" id="L626">            return new Attribute(info.getName(), normalizeType(info.getType()), JMXTool.getAccess(info));</span>
        }

        public String getName()
        {
<span class="fc" id="L631">            return name;</span>
        }

        public void setName(String name)
        {
<span class="fc" id="L636">            this.name = name;</span>
<span class="fc" id="L637">        }</span>

        public String getType()
        {
<span class="fc" id="L641">            return type;</span>
        }

        public void setType(String type)
        {
<span class="fc" id="L646">            this.type = type;</span>
<span class="fc" id="L647">        }</span>

        public String getAccess()
        {
<span class="fc" id="L651">            return access;</span>
        }

        public void setAccess(String access)
        {
<span class="fc" id="L656">            this.access = access;</span>
<span class="fc" id="L657">        }</span>

        public boolean equals(Object o)
        {
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">            if (this == o) return true;</span>
<span class="pc bpc" id="L662" title="2 of 4 branches missed.">            if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L663">            Attribute attribute = (Attribute) o;</span>
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">            return Objects.equals(name, attribute.name) &amp;&amp;</span>
<span class="pc bpc" id="L665" title="1 of 2 branches missed.">                   Objects.equals(type, attribute.type);</span>
        }

        public int hashCode()
        {
<span class="nc" id="L670">            return Objects.hash(name, type);</span>
        }

        public String toString()
        {
<span class="nc" id="L675">            return name + &quot;: &quot; + type;</span>
        }

        public int compareTo(Attribute o)
        {
<span class="nc" id="L680">            int rc = name.compareTo(o.name);</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">            if (rc != 0)</span>
<span class="nc" id="L682">                return rc;</span>
<span class="nc" id="L683">            return type.compareTo(o.type);</span>
        }
    }

    public static final class Operation implements Comparable&lt;Operation&gt;
    {
        private String name;
        private Parameter[] parameters;
        private String returnType;

        public Operation()
<span class="fc" id="L694">        {</span>
<span class="fc" id="L695">        }</span>

        public Operation(String name, Parameter[] parameters, String returnType)
<span class="fc" id="L698">        {</span>
<span class="fc" id="L699">            this.name = name;</span>
<span class="fc" id="L700">            this.parameters = parameters;</span>
<span class="fc" id="L701">            this.returnType = returnType;</span>
<span class="fc" id="L702">        }</span>

        private static Operation from(MBeanOperationInfo info)
        {
<span class="nc" id="L706">            Parameter[] params = Stream.of(info.getSignature()).map(Parameter::from).toArray(Parameter[]::new);</span>
<span class="nc" id="L707">            return new Operation(info.getName(), params, normalizeType(info.getReturnType()));</span>
        }

        public String getName()
        {
<span class="fc" id="L712">            return name;</span>
        }

        public void setName(String name)
        {
<span class="fc" id="L717">            this.name = name;</span>
<span class="fc" id="L718">        }</span>

        public Parameter[] getParameters()
        {
<span class="fc" id="L722">            return parameters;</span>
        }

        public void setParameters(Parameter[] parameters)
        {
<span class="fc" id="L727">            this.parameters = parameters;</span>
<span class="fc" id="L728">        }</span>

        public List&lt;String&gt; parameterTypes()
        {
<span class="nc" id="L732">            return Stream.of(parameters).map(p -&gt; p.type).collect(Collectors.toList());</span>
        }

        public String getReturnType()
        {
<span class="fc" id="L737">            return returnType;</span>
        }

        public void setReturnType(String returnType)
        {
<span class="fc" id="L742">            this.returnType = returnType;</span>
<span class="fc" id="L743">        }</span>

        public boolean equals(Object o)
        {
<span class="pc bpc" id="L747" title="1 of 2 branches missed.">            if (this == o) return true;</span>
<span class="pc bpc" id="L748" title="2 of 4 branches missed.">            if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L749">            Operation operation = (Operation) o;</span>
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">            return Objects.equals(name, operation.name) &amp;&amp;</span>
<span class="pc bpc" id="L751" title="1 of 2 branches missed.">                   Arrays.equals(parameters, operation.parameters) &amp;&amp;</span>
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">                   Objects.equals(returnType, operation.returnType);</span>
        }

        public int hashCode()
        {
<span class="nc" id="L757">            int result = Objects.hash(name, returnType);</span>
<span class="nc" id="L758">            result = 31 * result + Arrays.hashCode(parameters);</span>
<span class="nc" id="L759">            return result;</span>
        }

        public String toString()
        {
<span class="nc" id="L764">            return name + Stream.of(parameters).map(Parameter::toString).collect(Collectors.joining(&quot;, &quot;, &quot;(&quot;, &quot;)&quot;)) + &quot;: &quot; + returnType;</span>
        }

        public int compareTo(Operation o)
        {
<span class="nc" id="L769">            int rc = name.compareTo(o.name);</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">            if (rc != 0)</span>
<span class="nc" id="L771">                return rc;</span>
<span class="nc" id="L772">            rc = Integer.compare(parameters.length, o.parameters.length);</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">            if (rc != 0)</span>
<span class="nc" id="L774">                return rc;</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">            for (int i = 0; i &lt; parameters.length; i++)</span>
            {
<span class="nc" id="L777">                rc = parameters[i].type.compareTo(o.parameters[i].type);</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">                if (rc != 0)</span>
<span class="nc" id="L779">                    return rc;</span>
            }
<span class="nc" id="L781">            return returnType.compareTo(o.returnType);</span>
        }
    }

    public static final class Parameter
    {
        private String name;
        private String type;

        public Parameter()
<span class="fc" id="L791">        {</span>
<span class="fc" id="L792">        }</span>

        public Parameter(String name, String type)
<span class="fc" id="L795">        {</span>
<span class="fc" id="L796">            this.name = name;</span>
<span class="fc" id="L797">            this.type = type;</span>
<span class="fc" id="L798">        }</span>

        private static Parameter from(MBeanParameterInfo info)
        {
<span class="nc" id="L802">            return new Parameter(info.getName(), normalizeType(info.getType()));</span>
        }

        public String getName()
        {
<span class="fc" id="L807">            return name;</span>
        }

        public void setName(String name)
        {
<span class="fc" id="L812">            this.name = name;</span>
<span class="fc" id="L813">        }</span>

        public String getType()
        {
<span class="fc" id="L817">            return type;</span>
        }

        public void setType(String type)
        {
<span class="fc" id="L822">            this.type = type;</span>
<span class="fc" id="L823">        }</span>

        public boolean equals(Object o)
        {
<span class="pc bpc" id="L827" title="1 of 2 branches missed.">            if (this == o) return true;</span>
<span class="pc bpc" id="L828" title="2 of 4 branches missed.">            if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L829">            Parameter parameter = (Parameter) o;</span>
<span class="fc" id="L830">            return Objects.equals(type, parameter.type);</span>
        }

        public int hashCode()
        {
<span class="nc" id="L835">            return Objects.hash(type);</span>
        }

        public String toString()
        {
<span class="nc" id="L840">            return name + &quot;: &quot; + type;</span>
        }
    }

    public static final class CliPattern
    {
        private final Pattern pattern;

        public CliPattern(String pattern)
        {
            this.pattern = Pattern.compile(pattern);
        }
    }

    public static void main(String[] args) throws Exception
    {
<span class="nc" id="L856">        Cli.CliBuilder&lt;Callable&lt;Void&gt;&gt; builder = Cli.builder(&quot;jmxtool&quot;);</span>
<span class="nc" id="L857">        builder.withDefaultCommand(Help.class);</span>
<span class="nc" id="L858">        builder.withCommands(Help.class, Dump.class, Diff.class);</span>

<span class="nc" id="L860">        Cli&lt;Callable&lt;Void&gt;&gt; parser = builder.build();</span>
<span class="nc" id="L861">        Callable&lt;Void&gt; command = parser.parse(args);</span>
<span class="nc" id="L862">        command.call();</span>
<span class="nc" id="L863">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>