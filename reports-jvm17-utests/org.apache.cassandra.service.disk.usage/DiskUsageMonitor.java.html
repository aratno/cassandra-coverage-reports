<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DiskUsageMonitor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.service.disk.usage</a> &gt; <span class="el_source">DiskUsageMonitor.java</span></div><h1>DiskUsageMonitor.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.service.disk.usage;

import java.io.IOException;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.nio.file.FileStore;
import java.nio.file.Files;
import java.util.Collection;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import java.util.function.Supplier;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimap;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.concurrent.ScheduledExecutors;
import org.apache.cassandra.config.CassandraRelevantProperties;
import org.apache.cassandra.config.DataStorageSpec;
import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.Directories;
import org.apache.cassandra.db.guardrails.Guardrails;
import org.apache.cassandra.db.guardrails.GuardrailsConfig;
import org.apache.cassandra.db.memtable.Memtable;
import org.apache.cassandra.io.util.FileUtils;

/**
 * Schedule periodic task to monitor local disk usage and notify {@link DiskUsageBroadcaster} if local state changed.
 */
public class DiskUsageMonitor
{
<span class="fc" id="L54">    private static final Logger logger = LoggerFactory.getLogger(DiskUsageMonitor.class);</span>

<span class="fc" id="L56">    public static DiskUsageMonitor instance = new DiskUsageMonitor();</span>

<span class="fc" id="L58">    private final Supplier&lt;GuardrailsConfig&gt; guardrailsConfigSupplier = () -&gt; Guardrails.CONFIG_PROVIDER.getOrCreate(null);</span>
    private final Supplier&lt;Multimap&lt;FileStore, Directories.DataDirectory&gt;&gt; dataDirectoriesSupplier;

<span class="fc" id="L61">    private volatile DiskUsageState localState = DiskUsageState.NOT_AVAILABLE;</span>

    @VisibleForTesting
    public DiskUsageMonitor()
<span class="fc" id="L65">    {</span>
<span class="fc" id="L66">        this.dataDirectoriesSupplier = DiskUsageMonitor::dataDirectoriesGroupedByFileStore;</span>
<span class="fc" id="L67">    }</span>

    @VisibleForTesting
    public DiskUsageMonitor(Supplier&lt;Multimap&lt;FileStore, Directories.DataDirectory&gt;&gt; dataDirectoriesSupplier)
<span class="fc" id="L71">    {</span>
<span class="fc" id="L72">        this.dataDirectoriesSupplier = dataDirectoriesSupplier;</span>
<span class="fc" id="L73">    }</span>

    /**
     * Start monitoring local disk usage and call notifier when local disk usage state changed.
     */
    public void start(Consumer&lt;DiskUsageState&gt; notifier)
    {
        // start the scheduler regardless guardrail is enabled, so we can enable it later without a restart
<span class="fc" id="L81">        ScheduledExecutors.scheduledTasks.scheduleAtFixedRate(() -&gt; {</span>

<span class="pc bpc" id="L83" title="1 of 2 branches missed.">            if (!Guardrails.localDataDiskUsage.enabled(null))</span>
<span class="fc" id="L84">                return;</span>

<span class="nc" id="L86">            updateLocalState(getDiskUsage(), notifier);</span>
<span class="pc" id="L87">        }, 0, CassandraRelevantProperties.DISK_USAGE_MONITOR_INTERVAL_MS.getLong(), TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L88">    }</span>

    @VisibleForTesting
    public void updateLocalState(double usageRatio, Consumer&lt;DiskUsageState&gt; notifier)
    {
<span class="fc" id="L93">        double percentage = usageRatio * 100;</span>
<span class="fc" id="L94">        long percentageCeiling = (long) Math.ceil(percentage);</span>

<span class="fc" id="L96">        DiskUsageState state = getState(percentageCeiling);</span>

<span class="fc" id="L98">        Guardrails.localDataDiskUsage.guard(percentageCeiling, state.toString(), false, null);</span>

        // if state remains unchanged, no need to notify peers
<span class="fc bfc" id="L101" title="All 2 branches covered.">        if (state == localState)</span>
<span class="fc" id="L102">            return;</span>

<span class="fc" id="L104">        localState = state;</span>
<span class="fc" id="L105">        notifier.accept(state);</span>
<span class="fc" id="L106">    }</span>

    /**
     * @return local node disk usage state
     */
    @VisibleForTesting
    public DiskUsageState state()
    {
<span class="fc" id="L114">        return localState;</span>
    }

    /**
     * @return The current disk usage (including all memtable sizes) ratio. This is the ratio between the space taken by
     * all the data directories and the addition of that same space and the free available space on disk. The space
     * taken by the data directories is the addition of the actual space on disk plus the size of the memtables.
     * Memtables are included in that calculation because they are expected to be eventually flushed to disk.
     */
    @VisibleForTesting
    public double getDiskUsage()
    {
        // using BigInteger to handle large file system
<span class="fc" id="L127">        BigInteger used = BigInteger.ZERO; // space used by data directories</span>
<span class="fc" id="L128">        BigInteger usable = BigInteger.ZERO; // free space on disks</span>

<span class="fc bfc" id="L130" title="All 2 branches covered.">        for (Map.Entry&lt;FileStore, Collection&lt;Directories.DataDirectory&gt;&gt; e : dataDirectoriesSupplier.get().asMap().entrySet())</span>
        {
<span class="fc" id="L132">            usable = usable.add(BigInteger.valueOf(usableSpace(e.getKey())));</span>

<span class="fc bfc" id="L134" title="All 2 branches covered.">            for (Directories.DataDirectory dir : e.getValue())</span>
<span class="fc" id="L135">                used = used.add(BigInteger.valueOf(dir.getRawSize()));</span>
<span class="fc" id="L136">        }</span>

        // The total disk size for data directories is the space that is actually used by those directories plus the
        // free space on disk that might be used for storing those directories in the future.
<span class="fc" id="L140">        BigInteger total = used.add(usable);</span>

        // That total space can be limited by the config property data_disk_usage_max_disk_size.
<span class="fc" id="L143">        DataStorageSpec.LongBytesBound diskUsageMaxSize = guardrailsConfigSupplier.get().getDataDiskUsageMaxDiskSize();</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">        if (diskUsageMaxSize != null)</span>
<span class="fc" id="L145">            total = total.min(BigInteger.valueOf(diskUsageMaxSize.toBytes()));</span>

        // Add memtables size to the amount of used space because those memtables will be flushed to data directories.
<span class="fc" id="L148">        used = used.add(BigInteger.valueOf(getAllMemtableSize()));</span>

<span class="pc bpc" id="L150" title="1 of 2 branches missed.">        if (logger.isTraceEnabled())</span>
<span class="nc" id="L151">            logger.trace(&quot;Disk Usage Guardrail: current disk usage = {}, total disk usage = {}.&quot;,</span>
<span class="nc" id="L152">                         FileUtils.stringifyFileSize(used.doubleValue()),</span>
<span class="nc" id="L153">                         FileUtils.stringifyFileSize(total.doubleValue()));</span>

<span class="fc" id="L155">        return new BigDecimal(used).divide(new BigDecimal(total), 5, RoundingMode.UP).doubleValue();</span>
    }

    @VisibleForTesting
    public long getAllMemtableSize()
    {
<span class="fc" id="L161">        long size = 0;</span>

<span class="fc bfc" id="L163" title="All 2 branches covered.">        for (ColumnFamilyStore cfs : ColumnFamilyStore.all())</span>
        {
<span class="fc bfc" id="L165" title="All 2 branches covered.">            for (Memtable memtable : cfs.getTracker().getView().getAllMemtables())</span>
            {
<span class="fc" id="L167">                size += memtable.getLiveDataSize();</span>
<span class="fc" id="L168">            }</span>
<span class="fc" id="L169">        }</span>

<span class="fc" id="L171">        return size;</span>
    }

    @VisibleForTesting
    public DiskUsageState getState(long usagePercentage)
    {
<span class="fc bfc" id="L177" title="All 2 branches covered.">        if (!Guardrails.localDataDiskUsage.enabled())</span>
<span class="fc" id="L178">            return DiskUsageState.NOT_AVAILABLE;</span>

<span class="fc bfc" id="L180" title="All 2 branches covered.">        if (Guardrails.localDataDiskUsage.failsOn(usagePercentage, null))</span>
<span class="fc" id="L181">            return DiskUsageState.FULL;</span>

<span class="fc bfc" id="L183" title="All 2 branches covered.">        if (Guardrails.localDataDiskUsage.warnsOn(usagePercentage, null))</span>
<span class="fc" id="L184">            return DiskUsageState.STUFFED;</span>

<span class="fc" id="L186">        return DiskUsageState.SPACIOUS;</span>
    }

    private static Multimap&lt;FileStore, Directories.DataDirectory&gt; dataDirectoriesGroupedByFileStore()
    {
<span class="nc" id="L191">        Multimap&lt;FileStore, Directories.DataDirectory&gt; directories = HashMultimap.create();</span>
        try
        {
<span class="nc bnc" id="L194" title="All 2 branches missed.">            for (Directories.DataDirectory dir : Directories.dataDirectories.getAllDirectories())</span>
            {
<span class="nc" id="L196">                FileStore store = Files.getFileStore(dir.location.toPath());</span>
<span class="nc" id="L197">                directories.put(store, dir);</span>
<span class="nc" id="L198">            }</span>
        }
<span class="nc" id="L200">        catch (IOException e)</span>
        {
<span class="nc" id="L202">            throw new RuntimeException(&quot;Cannot get data directories grouped by file store&quot;, e);</span>
<span class="nc" id="L203">        }</span>
<span class="nc" id="L204">        return directories;</span>
    }

    public static long totalDiskSpace()
    {
<span class="nc" id="L209">        BigInteger size = dataDirectoriesGroupedByFileStore().keys()</span>
<span class="nc" id="L210">                                                             .stream()</span>
<span class="nc" id="L211">                                                             .map(DiskUsageMonitor::totalSpace)</span>
<span class="nc" id="L212">                                                             .map(BigInteger::valueOf)</span>
<span class="nc" id="L213">                                                             .reduce(BigInteger.ZERO, BigInteger::add);</span>

<span class="nc bnc" id="L215" title="All 2 branches missed.">        return size.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) &gt;= 0</span>
<span class="nc" id="L216">               ? Long.MAX_VALUE</span>
<span class="nc" id="L217">               : size.longValue();</span>
    }

    public static long totalSpace(FileStore store)
    {
        try
        {
<span class="nc" id="L224">            long size = store.getTotalSpace();</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">            return size &lt; 0 ? Long.MAX_VALUE : size;</span>
        }
<span class="nc" id="L227">        catch (IOException e)</span>
        {
<span class="nc" id="L229">            throw new RuntimeException(&quot;Cannot get total space of file store&quot;, e);</span>
        }
    }

    public static long usableSpace(FileStore store)
    {
        try
        {
<span class="fc" id="L237">            long size = store.getUsableSpace();</span>
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">            return size &lt; 0 ? Long.MAX_VALUE : size;</span>
        }
<span class="nc" id="L240">        catch (IOException e)</span>
        {
<span class="nc" id="L242">            throw new RuntimeException(&quot;Cannot get usable size of file store&quot;, e);</span>
        }
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>