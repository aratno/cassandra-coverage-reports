<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IntegerType.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.marshal</a> &gt; <span class="el_source">IntegerType.java</span></div><h1>IntegerType.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.marshal;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.util.Objects;

import org.apache.cassandra.cql3.CQL3Type;
import org.apache.cassandra.cql3.Constants;
import org.apache.cassandra.cql3.Term;
import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
import org.apache.cassandra.serializers.TypeSerializer;
import org.apache.cassandra.serializers.IntegerSerializer;
import org.apache.cassandra.serializers.MarshalException;
import org.apache.cassandra.transport.ProtocolVersion;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.bytecomparable.ByteComparable;
import org.apache.cassandra.utils.bytecomparable.ByteSource;
import org.apache.cassandra.utils.bytecomparable.ByteSourceInverse;

public final class IntegerType extends NumberType&lt;BigInteger&gt;
{
<span class="fc" id="L40">    public static final IntegerType instance = new IntegerType();</span>

<span class="fc" id="L42">    private static final ArgumentDeserializer ARGUMENT_DESERIALIZER = new DefaultArgumentDeserializer(instance);</span>

<span class="fc" id="L44">    private static final ByteBuffer MASKED_VALUE = instance.decompose(BigInteger.ZERO);</span>

    // Constants or escaping values needed to encode/decode variable-length integers in our custom byte-ordered
    // encoding scheme.
    private static final int POSITIVE_VARINT_HEADER = 0x80;
    private static final int NEGATIVE_VARINT_LENGTH_HEADER = 0x00;
    private static final int POSITIVE_VARINT_LENGTH_HEADER = 0xFF;
    private static final byte BIG_INTEGER_NEGATIVE_LEADING_ZERO = (byte) 0xFF;
    private static final byte BIG_INTEGER_POSITIVE_LEADING_ZERO = (byte) 0x00;
    public static final int FULL_FORM_THRESHOLD = 7;

    private static &lt;V&gt; int findMostSignificantByte(V value, ValueAccessor&lt;V&gt; accessor)
    {
<span class="fc" id="L57">        int len = accessor.size(value) - 1;</span>
<span class="fc" id="L58">        int i = 0;</span>
<span class="fc bfc" id="L59" title="All 2 branches covered.">        for (; i &lt; len; i++)</span>
        {
<span class="fc" id="L61">            byte b0 = accessor.getByte(value, i);</span>
<span class="fc bfc" id="L62" title="All 4 branches covered.">            if (b0 != 0 &amp;&amp; b0 != -1)</span>
<span class="fc" id="L63">                break;</span>
<span class="fc" id="L64">            byte b1 = accessor.getByte(value, i + 1);</span>
<span class="fc bfc" id="L65" title="All 4 branches covered.">            if (b0 == 0 &amp;&amp; b1 != 0)</span>
            {
<span class="fc bfc" id="L67" title="All 2 branches covered.">                if (b1 &gt; 0)</span>
<span class="fc" id="L68">                    i++;</span>
                break;
            }
<span class="fc bfc" id="L71" title="All 4 branches covered.">            if (b0 == -1 &amp;&amp; b1 != -1)</span>
            {
<span class="fc bfc" id="L73" title="All 2 branches covered.">                if (b1 &lt; 0)</span>
<span class="fc" id="L74">                    i++;</span>
                break;
            }
        }
<span class="fc" id="L78">        return i;</span>
    }

<span class="fc" id="L81">    IntegerType() {super(ComparisonType.CUSTOM);}/* singleton */</span>

    public boolean isEmptyValueMeaningless()
    {
<span class="nc" id="L85">        return true;</span>
    }

    public &lt;VL, VR&gt; int compareCustom(VL left, ValueAccessor&lt;VL&gt; accessorL, VR right, ValueAccessor&lt;VR&gt; accessorR)
    {
<span class="fc" id="L90">        return IntegerType.compareIntegers(left, accessorL, right, accessorR);</span>
    }

    public static &lt;VL, VR&gt; int compareIntegers(VL lhs, ValueAccessor&lt;VL&gt; accessorL, VR rhs, ValueAccessor&lt;VR&gt; accessorR)
    {
<span class="fc" id="L95">        int lhsLen = accessorL.size(lhs);</span>
<span class="fc" id="L96">        int rhsLen = accessorR.size(rhs);</span>

<span class="fc bfc" id="L98" title="All 2 branches covered.">        if (lhsLen == 0)</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">            return rhsLen == 0 ? 0 : -1;</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">        if (rhsLen == 0)</span>
<span class="fc" id="L101">            return 1;</span>

<span class="fc" id="L103">        int lhsMsbIdx = findMostSignificantByte(lhs, accessorL);</span>
<span class="fc" id="L104">        int rhsMsbIdx = findMostSignificantByte(rhs, accessorR);</span>

        //diffs contain number of &quot;meaningful&quot; bytes (i.e. ignore padding)
<span class="fc" id="L107">        int lhsLenDiff = lhsLen - lhsMsbIdx;</span>
<span class="fc" id="L108">        int rhsLenDiff = rhsLen - rhsMsbIdx;</span>

<span class="fc" id="L110">        byte lhsMsb = accessorL.getByte(lhs, lhsMsbIdx);</span>
<span class="fc" id="L111">        byte rhsMsb = accessorR.getByte(rhs, rhsMsbIdx);</span>

        /*         +    -
         *      -----------
         *    + | -d |  1 |
         * LHS  -----------
         *    - | -1 |  d |
         *      -----------
         *          RHS
         *
         * d = difference of length in significant bytes
         */
<span class="fc bfc" id="L123" title="All 2 branches covered.">        if (lhsLenDiff != rhsLenDiff)</span>
        {
<span class="fc bfc" id="L125" title="All 2 branches covered.">            if (lhsMsb &lt; 0)</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">                return rhsMsb &lt; 0 ? rhsLenDiff - lhsLenDiff : -1;</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">            if (rhsMsb &lt; 0)</span>
<span class="fc" id="L128">                return 1;</span>
<span class="fc" id="L129">            return lhsLenDiff - rhsLenDiff;</span>
        }

        // msb uses signed comparison
<span class="fc bfc" id="L133" title="All 2 branches covered.">        if (lhsMsb != rhsMsb)</span>
<span class="fc" id="L134">            return lhsMsb - rhsMsb;</span>
<span class="fc" id="L135">        lhsMsbIdx++;</span>
<span class="fc" id="L136">        rhsMsbIdx++;</span>

        // remaining bytes are compared unsigned
<span class="fc bfc" id="L139" title="All 2 branches covered.">        while (lhsMsbIdx &lt; lhsLen)</span>
        {
<span class="fc" id="L141">            lhsMsb = accessorL.getByte(lhs, lhsMsbIdx++);</span>
<span class="fc" id="L142">            rhsMsb = accessorR.getByte(rhs, rhsMsbIdx++);</span>

<span class="fc bfc" id="L144" title="All 2 branches covered.">            if (lhsMsb != rhsMsb)</span>
<span class="fc" id="L145">                return (lhsMsb &amp; 0xFF) - (rhsMsb &amp; 0xFF);</span>
        }

<span class="fc" id="L148">        return 0;</span>
    }

    /**
     * Constructs a byte-comparable representation of the number.
     *
     * In the current format we represent it:
     *    directly as varint, if the length is 6 or smaller (the encoding has non-00/FF first byte)
     *    &lt;signbyte&gt;&lt;length as unsigned integer - 7&gt;&lt;7 or more bytes&gt;, otherwise
     * where &lt;signbyte&gt; is 00 for negative numbers and FF for positive ones, and the length's bytes are inverted if
     * the number is negative (so that longer length sorts smaller).
     *
     * Because we present the sign separately, we don't need to include 0x00 prefix for positive integers whose first
     * byte is &gt;= 0x80 or 0xFF prefix for negative integers whose first byte is &lt; 0x80. Note that we do this before
     * taking the length for the purposes of choosing between varint and full-form encoding.
     *
     * The representations are prefix-free, because the choice between varint and full-form encoding is determined by
     * the first byte where varints are properly ordered between full-form negative and full-form positive, varint
     * encoding is prefix-free, and full-form representations of different length always have length bytes that differ.
     *
     * Examples:
     *    -1            as 7F
     *    0             as 80
     *    1             as 81
     *    127           as C07F
     *    255           as C0FF
     *    2^32-1        as F8FFFFFFFF
     *    2^32          as F900000000
     *    2^56-1        as FEFFFFFFFFFFFFFF
     *    2^56          as FF000100000000000000
     *
     * See {@link #asComparableBytesLegacy} for description of the legacy format.
     */
    @Override
    public &lt;V&gt; ByteSource asComparableBytes(ValueAccessor&lt;V&gt; accessor, V data, ByteComparable.Version version)
    {
<span class="fc" id="L184">        final int limit = accessor.size(data);</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        if (limit == 0)</span>
<span class="fc" id="L186">            return null;</span>

        // skip any leading sign-only byte(s)
<span class="fc" id="L189">        int p = 0;</span>
<span class="fc" id="L190">        final byte signbyte = accessor.getByte(data, p);</span>
<span class="fc bfc" id="L191" title="All 4 branches covered.">        if (signbyte == BIG_INTEGER_NEGATIVE_LEADING_ZERO || signbyte == BIG_INTEGER_POSITIVE_LEADING_ZERO)</span>
        {
<span class="fc bfc" id="L193" title="All 2 branches covered.">            while (p + 1 &lt; limit)</span>
            {
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">                if (accessor.getByte(data, ++p) != signbyte)</span>
<span class="fc" id="L196">                    break;</span>
            }
        }

<span class="fc bfc" id="L200" title="All 2 branches covered.">        if (version != ByteComparable.Version.LEGACY)</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">            return (limit - p &lt; FULL_FORM_THRESHOLD)</span>
<span class="fc" id="L202">                   ? encodeAsVarInt(accessor, data, limit)</span>
<span class="fc" id="L203">                   : asComparableBytesCurrent(accessor, data, p, limit, (signbyte &gt;&gt; 7) &amp; 0xFF);</span>
        else
<span class="fc" id="L205">            return asComparableBytesLegacy(accessor, data, p, limit, signbyte);</span>
    }

    /**
     * Encode the BigInteger stored in the given buffer as a variable-length signed integer.
     * The length of the number is given in the limit argument, and must be &lt;= 8.
     */
    private &lt;V&gt; ByteSource encodeAsVarInt(ValueAccessor&lt;V&gt; accessor, V data, int limit)
    {
        long v;
<span class="pc bpc" id="L215" title="2 of 9 branches missed.">        switch (limit)</span>
        {
            case 1:
<span class="fc" id="L218">                v = accessor.getByte(data, 0);</span>
<span class="fc" id="L219">                break;</span>
            case 2:
<span class="fc" id="L221">                v = accessor.getShort(data, 0);</span>
<span class="fc" id="L222">                break;</span>
            case 3:
<span class="fc" id="L224">                v = (accessor.getShort(data, 0) &lt;&lt; 8) | (accessor.getByte(data, 2) &amp; 0xFF);</span>
<span class="fc" id="L225">                break;</span>
            case 4:
<span class="fc" id="L227">                v = accessor.getInt(data, 0);</span>
<span class="fc" id="L228">                break;</span>
            case 5:
<span class="fc" id="L230">                v = ((long) accessor.getInt(data, 0) &lt;&lt; 8) | (accessor.getByte(data, 4) &amp; 0xFF);</span>
<span class="fc" id="L231">                break;</span>
            case 6:
<span class="fc" id="L233">                v = ((long) accessor.getInt(data, 0) &lt;&lt; 16) | (accessor.getShort(data, 4) &amp; 0xFFFF);</span>
<span class="fc" id="L234">                break;</span>
            case 7:
<span class="fc" id="L236">                v = ((long) accessor.getInt(data, 0) &lt;&lt; 24) | ((accessor.getShort(data, 4) &amp; 0xFFFF) &lt;&lt; 8) | (accessor.getByte(data, 6) &amp; 0xFF);</span>
<span class="fc" id="L237">                break;</span>
            case 8:
                // This is not reachable within the encoding; added for completeness.
<span class="nc" id="L240">                v = accessor.getLong(data, 0);</span>
<span class="nc" id="L241">                break;</span>
            default:
<span class="nc" id="L243">                throw new AssertionError();</span>
        }
<span class="fc" id="L245">        return ByteSource.variableLengthInteger(v);</span>
    }

    /**
     * Constructs a full-form byte-comparable representation of the number in the current format.
     *
     * This contains:
     *    &lt;signbyte&gt;&lt;length as unsigned integer - 7&gt;&lt;7 or more bytes&gt;, otherwise
     * where &lt;signbyte&gt; is 00 for negative numbers and FF for positive ones, and the length's bytes are inverted if
     * the number is negative (so that longer length sorts smaller).
     *
     * Because we present the sign separately, we don't need to include 0x00 prefix for positive integers whose first
     * byte is &gt;= 0x80 or 0xFF prefix for negative integers whose first byte is &lt; 0x80.
     *
     * The representations are prefix-free, because representations of different length always have length bytes that
     * differ.
     */
    private &lt;V&gt; ByteSource asComparableBytesCurrent(ValueAccessor&lt;V&gt; accessor, V data, int startpos, int limit, int signbyte)
    {
        // start with sign as a byte, then variable-length-encoded length, then bytes (stripped leading sign)
<span class="fc" id="L265">        return new ByteSource()</span>
<span class="fc" id="L266">        {</span>
<span class="fc" id="L267">            int pos = -2;</span>
<span class="fc" id="L268">            ByteSource lengthEncoding = new VariableLengthUnsignedInteger(limit - startpos - FULL_FORM_THRESHOLD);</span>

            @Override
            public int next()
            {
<span class="fc bfc" id="L273" title="All 2 branches covered.">                if (pos == -2)</span>
                {
<span class="fc" id="L275">                    ++pos;</span>
<span class="fc" id="L276">                    return signbyte ^ 0xFF; // 00 for negative/FF for positive (01-FE for direct varint encoding)</span>
                }
<span class="fc bfc" id="L278" title="All 2 branches covered.">                else if (pos == -1)</span>
                {
<span class="fc" id="L280">                    int nextByte = lengthEncoding.next();</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">                    if (nextByte != END_OF_STREAM)</span>
<span class="fc" id="L282">                        return nextByte ^ signbyte;</span>
<span class="fc" id="L283">                    pos = startpos;</span>
                }

<span class="fc bfc" id="L286" title="All 2 branches covered.">                if (pos == limit)</span>
<span class="fc" id="L287">                    return END_OF_STREAM;</span>

<span class="fc" id="L289">                return accessor.getByte(data, pos++) &amp; 0xFF;</span>
            }
        };
    }

    /**
     * Constructs a byte-comparable representation of the number in the legacy format.
     * We represent it as
     *    &lt;zero or more length_bytes where length = 128&gt; &lt;length_byte&gt; &lt;first_significant_byte&gt; &lt;zero or more bytes&gt;
     * where a length_byte is:
     *    - 0x80 + (length - 1) for positive numbers (so that longer length sorts bigger)
     *    - 0x7F - (length - 1) for negative numbers (so that longer length sorts smaller)
     *
     * Because we include the sign in the length byte:
     * - unlike fixed-length ints, we don't need to sign-invert the first significant byte,
     * - unlike BigInteger, we don't need to include 0x00 prefix for positive integers whose first byte is &gt;= 0x80
     *   or 0xFF prefix for negative integers whose first byte is &lt; 0x80.
     *
     * The representations are prefix-free, because representations of different length always have length bytes that
     * differ.
     *
     * Examples:
     *    0             as 8000
     *    1             as 8001
     *    127           as 807F
     *    255           as 80FF
     *    2^31-1        as 837FFFFFFF
     *    2^31          as 8380000000
     *    2^32          as 840100000000
     */
    private &lt;V&gt; ByteSource asComparableBytesLegacy(ValueAccessor&lt;V&gt; accessor, V data, int startpos, int limit, int signbyte)
    {
<span class="fc" id="L321">        return new ByteSource()</span>
<span class="fc" id="L322">        {</span>
<span class="fc" id="L323">            int pos = startpos;</span>
<span class="fc" id="L324">            int sizeToReport = limit - startpos;</span>
<span class="fc" id="L325">            boolean sizeReported = false;</span>

            public int next()
            {
<span class="fc bfc" id="L329" title="All 2 branches covered.">                if (!sizeReported)</span>
                {
<span class="fc bfc" id="L331" title="All 2 branches covered.">                    if (sizeToReport &gt;= 128)</span>
                    {
<span class="fc" id="L333">                        sizeToReport -= 128;</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">                        return signbyte &gt;= 0</span>
<span class="fc" id="L335">                               ? POSITIVE_VARINT_LENGTH_HEADER</span>
<span class="fc" id="L336">                               : NEGATIVE_VARINT_LENGTH_HEADER;</span>
                    }
                    else
                    {
<span class="fc" id="L340">                        sizeReported = true;</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">                        return signbyte &gt;= 0</span>
<span class="fc" id="L342">                               ? POSITIVE_VARINT_HEADER + (sizeToReport - 1)</span>
<span class="fc" id="L343">                               : POSITIVE_VARINT_HEADER - sizeToReport;</span>
                    }
                }

<span class="fc bfc" id="L347" title="All 2 branches covered.">                if (pos == limit)</span>
<span class="fc" id="L348">                    return END_OF_STREAM;</span>

<span class="fc" id="L350">                return accessor.getByte(data, pos++) &amp; 0xFF;</span>
            }
        };
    }

    @Override
    public &lt;V&gt; V fromComparableBytes(ValueAccessor&lt;V&gt; accessor, ByteSource.Peekable comparableBytes, ByteComparable.Version version)
    {
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">        assert version != ByteComparable.Version.LEGACY;</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">        if (comparableBytes == null)</span>
<span class="fc" id="L360">            return accessor.empty();</span>

        // Consume the first byte to determine whether the encoded number is positive and
        // start iterating through the length header bytes and collecting the number of value bytes.
<span class="fc" id="L364">        int sign = comparableBytes.peek() ^ 0xFF;   // FF if negative, 00 if positive</span>
<span class="fc bfc" id="L365" title="All 4 branches covered.">        if (sign != 0xFF &amp;&amp; sign != 0x00)</span>
<span class="fc" id="L366">            return extractVarIntBytes(accessor, ByteSourceInverse.getVariableLengthInteger(comparableBytes));</span>

        // consume the sign byte
<span class="fc" id="L369">        comparableBytes.next();</span>

        // Read the length (inverted if the number is negative)
<span class="fc" id="L372">        int valueBytes = Math.toIntExact(ByteSourceInverse.getVariableLengthUnsignedIntegerXoring(comparableBytes, sign) + FULL_FORM_THRESHOLD);</span>
        // Get the bytes.
<span class="fc" id="L374">        return extractBytes(accessor, comparableBytes, sign, valueBytes);</span>
    }

    private &lt;V&gt; V extractVarIntBytes(ValueAccessor&lt;V&gt; accessor, long value)
    {
<span class="fc" id="L379">        int length = (64 - Long.numberOfLeadingZeros(value ^ (value &gt;&gt; 63)) + 8) / 8;   // number of bytes needed: 7 bits -&gt; one byte, 8 bits -&gt; 2 bytes</span>
<span class="fc" id="L380">        V buf = accessor.allocate(length);</span>
<span class="pc bpc" id="L381" title="2 of 9 branches missed.">        switch (length)</span>
        {
            case 1:
<span class="fc" id="L384">                accessor.putByte(buf, 0, (byte) value);</span>
<span class="fc" id="L385">                break;</span>
            case 2:
<span class="fc" id="L387">                accessor.putShort(buf, 0, (short) value);</span>
<span class="fc" id="L388">                break;</span>
            case 3:
<span class="fc" id="L390">                accessor.putShort(buf, 0, (short) (value &gt;&gt; 8));</span>
<span class="fc" id="L391">                accessor.putByte(buf, 2, (byte) value);</span>
<span class="fc" id="L392">                break;</span>
            case 4:
<span class="fc" id="L394">                accessor.putInt(buf, 0, (int) value);</span>
<span class="fc" id="L395">                break;</span>
            case 5:
<span class="fc" id="L397">                accessor.putInt(buf, 0, (int) (value &gt;&gt; 8));</span>
<span class="fc" id="L398">                accessor.putByte(buf, 4, (byte) value);</span>
<span class="fc" id="L399">                break;</span>
            case 6:
<span class="fc" id="L401">                accessor.putInt(buf, 0, (int) (value &gt;&gt; 16));</span>
<span class="fc" id="L402">                accessor.putShort(buf, 4, (short) value);</span>
<span class="fc" id="L403">                break;</span>
            case 7:
<span class="fc" id="L405">                accessor.putInt(buf, 0, (int) (value &gt;&gt; 24));</span>
<span class="fc" id="L406">                accessor.putShort(buf, 4, (short) (value &gt;&gt; 8));</span>
<span class="fc" id="L407">                accessor.putByte(buf, 6, (byte) value);</span>
<span class="fc" id="L408">                break;</span>
            case 8:
                // This is not reachable within the encoding; added for completeness.
<span class="nc" id="L411">                accessor.putLong(buf, 0, value);</span>
<span class="nc" id="L412">                break;</span>
            default:
<span class="nc" id="L414">                throw new AssertionError();</span>
        }
<span class="fc" id="L416">        return buf;</span>
    }

    private &lt;V&gt; V extractBytes(ValueAccessor&lt;V&gt; accessor, ByteSource.Peekable comparableBytes, int sign, int valueBytes)
    {
<span class="fc" id="L421">        int writtenBytes = 0;</span>
        V buf;
        // Add &quot;leading zero&quot; if needed (i.e. in case the leading byte of a positive number corresponds to a negative
        // value, or in case the leading byte of a negative number corresponds to a non-negative value).
        // Size the array containing all the value bytes accordingly.
<span class="fc" id="L426">        int curr = comparableBytes.next();</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">        if ((curr &amp; 0x80) != (sign &amp; 0x80))</span>
        {
<span class="fc" id="L429">            ++valueBytes;</span>
<span class="fc" id="L430">            buf = accessor.allocate(valueBytes);</span>
<span class="fc" id="L431">            accessor.putByte(buf, writtenBytes++, (byte) sign);</span>
        }
        else
<span class="fc" id="L434">            buf = accessor.allocate(valueBytes);</span>
        // Don't forget to add the first consumed value byte after determining whether leading zero should be added
        // and sizing the value bytes array.
<span class="fc" id="L437">        accessor.putByte(buf, writtenBytes++, (byte) curr);</span>

        // Consume exactly the number of expected value bytes.
<span class="fc bfc" id="L440" title="All 2 branches covered.">        while (writtenBytes &lt; valueBytes)</span>
<span class="fc" id="L441">            accessor.putByte(buf, writtenBytes++, (byte) comparableBytes.next());</span>

<span class="fc" id="L443">        return buf;</span>
    }

    public ByteBuffer fromString(String source) throws MarshalException
    {
        // Return an empty ByteBuffer for an empty string.
<span class="pc bpc" id="L449" title="1 of 2 branches missed.">        if (source.isEmpty())</span>
<span class="nc" id="L450">            return ByteBufferUtil.EMPTY_BYTE_BUFFER;</span>

        BigInteger integerType;

        try
        {
<span class="fc" id="L456">            integerType = new BigInteger(source);</span>
        }
<span class="nc" id="L458">        catch (Exception e)</span>
        {
<span class="nc" id="L460">            throw new MarshalException(String.format(&quot;unable to make int from '%s'&quot;, source), e);</span>
<span class="fc" id="L461">        }</span>

<span class="fc" id="L463">        return decompose(integerType);</span>
    }

    @Override
    public Term fromJSONObject(Object parsed) throws MarshalException
    {
        try
        {
<span class="fc" id="L471">            return new Constants.Value(getSerializer().serialize(new BigInteger(parsed.toString())));</span>
        }
<span class="fc" id="L473">        catch (NumberFormatException exc)</span>
        {
<span class="fc" id="L475">            throw new MarshalException(String.format(</span>
                    &quot;Value '%s' is not a valid representation of a varint value&quot;, parsed));
        }
    }

    @Override
    public String toJSONString(ByteBuffer buffer, ProtocolVersion protocolVersion)
    {
<span class="fc" id="L483">        return Objects.toString(getSerializer().deserialize(buffer), &quot;\&quot;\&quot;&quot;);</span>
    }

    @Override
    public boolean isValueCompatibleWithInternal(AbstractType&lt;?&gt; otherType)
    {
<span class="fc bfc" id="L489" title="All 6 branches covered.">        return this == otherType || Int32Type.instance.isValueCompatibleWith(otherType) || LongType.instance.isValueCompatibleWith(otherType);</span>
    }

    public CQL3Type asCQL3Type()
    {
<span class="fc" id="L494">        return CQL3Type.Native.VARINT;</span>
    }

    public TypeSerializer&lt;BigInteger&gt; getSerializer()
    {
<span class="fc" id="L499">        return IntegerSerializer.instance;</span>
    }

    @Override
    public ArgumentDeserializer getArgumentDeserializer()
    {
<span class="fc" id="L505">        return ARGUMENT_DESERIALIZER;</span>
    }

    private BigInteger toBigInteger(Number number)
    {
<span class="fc bfc" id="L510" title="All 2 branches covered.">        if (number instanceof BigInteger)</span>
<span class="fc" id="L511">            return (BigInteger) number;</span>

<span class="fc" id="L513">        return BigInteger.valueOf(number.longValue());</span>
    }

    public ByteBuffer add(Number left, Number right)
    {
<span class="fc" id="L518">        return decompose(toBigInteger(left).add(toBigInteger(right)));</span>
    }

    public ByteBuffer substract(Number left, Number right)
    {
<span class="fc" id="L523">        return decompose(toBigInteger(left).subtract(toBigInteger(right)));</span>
    }

    public ByteBuffer multiply(Number left, Number right)
    {
<span class="fc" id="L528">        return decompose(toBigInteger(left).multiply(toBigInteger(right)));</span>
    }

    public ByteBuffer divide(Number left, Number right)
    {
<span class="fc" id="L533">        return decompose(toBigInteger(left).divide(toBigInteger(right)));</span>
    }

    public ByteBuffer mod(Number left, Number right)
    {
<span class="fc" id="L538">        return decompose(toBigInteger(left).remainder(toBigInteger(right)));</span>
    }

    public ByteBuffer negate(Number input)
    {
<span class="fc" id="L543">        return decompose(toBigInteger(input).negate());</span>
    }

    @Override
    public ByteBuffer abs(Number input)
    {
<span class="fc" id="L549">        return decompose(toBigInteger(input).abs());</span>
    }

    @Override
    public ByteBuffer exp(Number input)
    {
<span class="fc" id="L555">        BigInteger bi = toBigInteger(input);</span>
<span class="fc" id="L556">        BigDecimal bd = new BigDecimal(bi);</span>
<span class="fc" id="L557">        BigDecimal result = DecimalType.instance.exp(bd);</span>
<span class="fc" id="L558">        BigInteger out = result.toBigInteger();</span>
<span class="fc" id="L559">        return IntegerType.instance.decompose(out);</span>
    }

    @Override
    public ByteBuffer log(Number input)
    {
<span class="fc" id="L565">        BigInteger bi = toBigInteger(input);</span>
<span class="pc bpc" id="L566" title="1 of 2 branches missed.">        if (bi.compareTo(BigInteger.ZERO) &lt;= 0) throw new ArithmeticException(&quot;Natural log of number zero or less&quot;);</span>
<span class="fc" id="L567">        BigDecimal bd = new BigDecimal(bi);</span>
<span class="fc" id="L568">        BigDecimal result = DecimalType.instance.log(bd);</span>
<span class="fc" id="L569">        BigInteger out = result.toBigInteger();</span>
<span class="fc" id="L570">        return IntegerType.instance.decompose(out);</span>
    }

    @Override
    public ByteBuffer log10(Number input)
    {
<span class="fc" id="L576">        BigInteger bi = toBigInteger(input);</span>
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">        if (bi.compareTo(BigInteger.ZERO) &lt;= 0) throw new ArithmeticException(&quot;Log10 of number zero or less&quot;);</span>
<span class="fc" id="L578">        BigDecimal bd = new BigDecimal(bi);</span>
<span class="fc" id="L579">        BigDecimal result = DecimalType.instance.log10(bd);</span>
<span class="fc" id="L580">        BigInteger out = result.toBigInteger();</span>
<span class="fc" id="L581">        return IntegerType.instance.decompose(out);</span>
    }

    @Override
    public ByteBuffer round(Number input)
    {
<span class="fc" id="L587">        return decompose(toBigInteger(input));</span>
    }

    @Override
    public ByteBuffer getMaskedValue()
    {
<span class="fc" id="L593">        return MASKED_VALUE;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>