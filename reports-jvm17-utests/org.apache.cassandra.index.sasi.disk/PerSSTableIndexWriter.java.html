<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PerSSTableIndexWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.index.sasi.disk</a> &gt; <span class="el_source">PerSSTableIndexWriter.java</span></div><h1>PerSSTableIndexWriter.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.index.sasi.disk;

import java.nio.ByteBuffer;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Maps;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.concurrent.ExecutorPlus;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.compaction.OperationType;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.rows.Row;
import org.apache.cassandra.db.rows.Unfiltered;
import org.apache.cassandra.index.sasi.analyzer.AbstractAnalyzer;
import org.apache.cassandra.index.sasi.conf.ColumnIndex;
import org.apache.cassandra.index.sasi.utils.CombinedTermIterator;
import org.apache.cassandra.index.sasi.utils.TypeUtil;
import org.apache.cassandra.io.FSError;
import org.apache.cassandra.io.sstable.Descriptor;
import org.apache.cassandra.io.sstable.SSTableFlushObserver;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.Pair;
import org.apache.cassandra.utils.concurrent.CountDownLatch;
import org.apache.cassandra.utils.concurrent.ImmediateFuture;

import static org.apache.cassandra.concurrent.ExecutorFactory.Global.executorFactory;
import static org.apache.cassandra.utils.Clock.Global.nanoTime;
import static org.apache.cassandra.utils.concurrent.CountDownLatch.newCountDownLatch;

public class PerSSTableIndexWriter implements SSTableFlushObserver
{
<span class="fc" id="L61">    private static final Logger logger = LoggerFactory.getLogger(PerSSTableIndexWriter.class);</span>

    private static final int POOL_SIZE = 8;
    private static final ExecutorPlus INDEX_FLUSHER_MEMTABLE;
    private static final ExecutorPlus INDEX_FLUSHER_GENERAL;

    static
    {
<span class="fc" id="L69">        INDEX_FLUSHER_GENERAL = executorFactory().withJmxInternal()</span>
<span class="fc" id="L70">                                                 .pooled(&quot;SASI-General&quot;, POOL_SIZE);</span>

<span class="fc" id="L72">        INDEX_FLUSHER_MEMTABLE = executorFactory().withJmxInternal()</span>
<span class="fc" id="L73">                                                  .pooled(&quot;SASI-Memtable&quot;, POOL_SIZE);</span>
<span class="fc" id="L74">    }</span>

<span class="fc" id="L76">    private final long nowInSec = FBUtilities.nowInSeconds();</span>

    private final Descriptor descriptor;
    private final OperationType source;

    private final AbstractType&lt;?&gt; keyValidator;

    @VisibleForTesting
    protected final Map&lt;ColumnMetadata, Index&gt; indexes;

    private DecoratedKey currentKey;
    private long currentKeyPosition;
    private boolean isComplete;

    public PerSSTableIndexWriter(AbstractType&lt;?&gt; keyValidator,
                                 Descriptor descriptor,
                                 OperationType source,
                                 Map&lt;ColumnMetadata, ColumnIndex&gt; supportedIndexes)
<span class="fc" id="L94">    {</span>
<span class="fc" id="L95">        this.keyValidator = keyValidator;</span>
<span class="fc" id="L96">        this.descriptor = descriptor;</span>
<span class="fc" id="L97">        this.source = source;</span>
<span class="fc" id="L98">        this.indexes = Maps.newHashMapWithExpectedSize(supportedIndexes.size());</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">        for (Map.Entry&lt;ColumnMetadata, ColumnIndex&gt; entry : supportedIndexes.entrySet())</span>
<span class="fc" id="L100">            indexes.put(entry.getKey(), newIndex(entry.getValue()));</span>
<span class="fc" id="L101">    }</span>

    @Override
    public void begin()
<span class="fc" id="L105">    {}</span>

    @Override
    public void startPartition(DecoratedKey key, long keyPosition, long KeyPositionForSASI)
    {
<span class="fc" id="L110">        currentKey = key;</span>
<span class="fc" id="L111">        currentKeyPosition = KeyPositionForSASI;</span>
<span class="fc" id="L112">    }</span>

    @Override
    public void staticRow(Row staticRow)
    {
<span class="fc" id="L117">        nextUnfilteredCluster(staticRow);</span>
<span class="fc" id="L118">    }</span>

    @Override
    public void nextUnfilteredCluster(Unfiltered unfiltered)
    {
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">        if (!unfiltered.isRow())</span>
<span class="nc" id="L124">            return;</span>

<span class="fc" id="L126">        Row row = (Row) unfiltered;</span>

<span class="fc" id="L128">        indexes.forEach((column, index) -&gt; {</span>
<span class="fc" id="L129">            ByteBuffer value = ColumnIndex.getValueOf(column, row, nowInSec);</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">            if (value == null)</span>
<span class="fc" id="L131">                return;</span>

<span class="pc bpc" id="L133" title="1 of 2 branches missed.">            if (index == null)</span>
<span class="nc" id="L134">                throw new IllegalArgumentException(&quot;No index exists for column &quot; + column.name.toString());</span>

<span class="fc" id="L136">            index.add(value.duplicate(), currentKey, currentKeyPosition);</span>
<span class="fc" id="L137">        });</span>
<span class="fc" id="L138">    }</span>

    @Override
    public void complete()
    {
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">        if (isComplete)</span>
<span class="nc" id="L144">            return;</span>

<span class="fc" id="L146">        currentKey = null;</span>

        try
        {
<span class="fc" id="L150">            CountDownLatch latch = newCountDownLatch(indexes.size());</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">            for (Index index : indexes.values())</span>
<span class="fc" id="L152">                index.complete(latch);</span>

<span class="fc" id="L154">            latch.awaitUninterruptibly();</span>
        }
        finally
        {
<span class="fc" id="L158">            indexes.clear();</span>
<span class="fc" id="L159">            isComplete = true;</span>
        }
<span class="fc" id="L161">    }</span>

    public Index getIndex(ColumnMetadata columnDef)
    {
<span class="fc" id="L165">        return indexes.get(columnDef);</span>
    }

    public Descriptor getDescriptor()
    {
<span class="fc" id="L170">        return descriptor;</span>
    }

    @VisibleForTesting
    protected Index newIndex(ColumnIndex columnIndex)
    {
<span class="fc" id="L176">        return new Index(columnIndex);</span>
    }

    @VisibleForTesting
    protected class Index
    {
        @VisibleForTesting
        protected final File outputFile;

        private final ColumnIndex columnIndex;
        private final AbstractAnalyzer analyzer;
        private final long maxMemorySize;

        @VisibleForTesting
        protected final Set&lt;Future&lt;OnDiskIndex&gt;&gt; segments;
<span class="fc" id="L191">        private int segmentNumber = 0;</span>

        private OnDiskIndexBuilder currentBuilder;

        public Index(ColumnIndex columnIndex)
<span class="fc" id="L196">        {</span>
<span class="fc" id="L197">            this.columnIndex = columnIndex;</span>
<span class="fc" id="L198">            this.outputFile = descriptor.fileFor(columnIndex.getComponent());</span>
<span class="fc" id="L199">            this.analyzer = columnIndex.getAnalyzer();</span>
<span class="fc" id="L200">            this.segments = new HashSet&lt;&gt;();</span>
<span class="fc" id="L201">            this.maxMemorySize = maxMemorySize(columnIndex);</span>
<span class="fc" id="L202">            this.currentBuilder = newIndexBuilder();</span>
<span class="fc" id="L203">        }</span>

        public void add(ByteBuffer term, DecoratedKey key, long keyPosition)
        {
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">            if (term.remaining() == 0)</span>
<span class="nc" id="L208">                return;</span>

<span class="fc" id="L210">            boolean isAdded = false;</span>

<span class="fc" id="L212">            analyzer.reset(term);</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">            while (analyzer.hasNext())</span>
            {
<span class="fc" id="L215">                ByteBuffer token = analyzer.next();</span>
<span class="fc" id="L216">                int size = token.remaining();</span>

<span class="fc bfc" id="L218" title="All 2 branches covered.">                if (token.remaining() &gt;= OnDiskIndexBuilder.MAX_TERM_SIZE)</span>
                {
<span class="fc" id="L220">                    logger.info(&quot;Rejecting value (size {}, maximum {}) for column {} (analyzed {}) at {} SSTable.&quot;,</span>
<span class="fc" id="L221">                            FBUtilities.prettyPrintMemory(term.remaining()),</span>
<span class="fc" id="L222">                            FBUtilities.prettyPrintMemory(OnDiskIndexBuilder.MAX_TERM_SIZE),</span>
<span class="fc" id="L223">                            columnIndex.getColumnName(),</span>
<span class="fc" id="L224">                            columnIndex.getMode().isAnalyzed,</span>
                            descriptor);
<span class="fc" id="L226">                    continue;</span>
                }

<span class="pc bpc" id="L229" title="1 of 2 branches missed.">                if (!TypeUtil.isValid(token, columnIndex.getValidator()))</span>
                {
<span class="nc bnc" id="L231" title="All 2 branches missed.">                    if ((token = TypeUtil.tryUpcast(token, columnIndex.getValidator())) == null)</span>
                    {
<span class="nc" id="L233">                        logger.info(&quot;({}) Failed to add {} to index for key: {}, value size was {}, validator is {}.&quot;,</span>
                                    outputFile,
<span class="nc" id="L235">                                    columnIndex.getColumnName(),</span>
<span class="nc" id="L236">                                    keyValidator.getString(key.getKey()),</span>
<span class="nc" id="L237">                                    FBUtilities.prettyPrintMemory(size),</span>
<span class="nc" id="L238">                                    columnIndex.getValidator());</span>
<span class="nc" id="L239">                        continue;</span>
                    }
                }

<span class="fc" id="L243">                currentBuilder.add(token, key, keyPosition);</span>
<span class="fc" id="L244">                isAdded = true;</span>
<span class="fc" id="L245">            }</span>

<span class="pc bpc" id="L247" title="1 of 4 branches missed.">            if (!isAdded || currentBuilder.estimatedMemoryUse() &lt; maxMemorySize)</span>
<span class="fc" id="L248">                return; // non of the generated tokens were added to the index or memory size wasn't reached</span>

<span class="nc" id="L250">            segments.add(getExecutor().submit(scheduleSegmentFlush(false)));</span>
<span class="nc" id="L251">        }</span>

        @VisibleForTesting
        protected Callable&lt;OnDiskIndex&gt; scheduleSegmentFlush(final boolean isFinal)
        {
<span class="fc" id="L256">            final OnDiskIndexBuilder builder = currentBuilder;</span>
<span class="fc" id="L257">            currentBuilder = newIndexBuilder();</span>

<span class="fc" id="L259">            final File segmentFile = file(isFinal);</span>

<span class="fc" id="L261">            return () -&gt; {</span>
<span class="fc" id="L262">                long start = nanoTime();</span>

                try
                {
<span class="fc bfc" id="L266" title="All 2 branches covered.">                    return builder.finish(segmentFile) ? new OnDiskIndex(segmentFile, columnIndex.getValidator(), null) : null;</span>
                }
<span class="fc" id="L268">                catch (Exception | FSError e)</span>
                {
<span class="fc" id="L270">                    logger.error(&quot;Failed to build index segment {}&quot;, segmentFile, e);</span>
<span class="fc" id="L271">                    return null;</span>
                }
                finally
                {
<span class="fc bfc" id="L275" title="All 2 branches covered.">                    if (!isFinal)</span>
<span class="fc" id="L276">                        logger.info(&quot;Flushed index segment {}, took {} ms.&quot;, segmentFile, TimeUnit.NANOSECONDS.toMillis(nanoTime() - start));</span>
                }
            };
        }

        public void complete(final CountDownLatch latch)
        {
<span class="fc" id="L283">            logger.info(&quot;Scheduling index flush to {}&quot;, outputFile);</span>

<span class="fc" id="L285">            getExecutor().submit(() -&gt; {</span>
<span class="fc" id="L286">                long start1 = nanoTime();</span>

<span class="fc" id="L288">                OnDiskIndex[] parts = new OnDiskIndex[segments.size() + 1];</span>

                try
                {
                    // no parts present, build entire index from memory
<span class="fc bfc" id="L293" title="All 2 branches covered.">                    if (segments.isEmpty())</span>
                    {
<span class="fc" id="L295">                        scheduleSegmentFlush(true).call();</span>
<span class="fc" id="L296">                        return;</span>
                    }

                    // parts are present but there is something still in memory, let's flush that inline
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">                    if (!currentBuilder.isEmpty())</span>
                    {
                        @SuppressWarnings({ &quot;resource&quot;, &quot;RedundantSuppression&quot; })
<span class="nc" id="L303">                        OnDiskIndex last = scheduleSegmentFlush(false).call();</span>
<span class="nc" id="L304">                        segments.add(ImmediateFuture.success(last));</span>
                    }

<span class="fc" id="L307">                    int index = 0;</span>
<span class="fc" id="L308">                    ByteBuffer combinedMin = null, combinedMax = null;</span>

<span class="fc bfc" id="L310" title="All 2 branches covered.">                    for (Future&lt;OnDiskIndex&gt; f : segments)</span>
                    {
                        @SuppressWarnings({ &quot;resource&quot;, &quot;RedundantSuppression&quot; })
<span class="fc" id="L313">                        OnDiskIndex part = f.get();</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">                        if (part == null)</span>
<span class="nc" id="L315">                            continue;</span>

<span class="fc" id="L317">                        parts[index++] = part;</span>
<span class="fc bfc" id="L318" title="All 4 branches covered.">                        combinedMin = (combinedMin == null || keyValidator.compare(combinedMin, part.minKey()) &gt; 0) ? part.minKey() : combinedMin;</span>
<span class="fc bfc" id="L319" title="All 4 branches covered.">                        combinedMax = (combinedMax == null || keyValidator.compare(combinedMax, part.maxKey()) &lt; 0) ? part.maxKey() : combinedMax;</span>
<span class="fc" id="L320">                    }</span>

<span class="fc" id="L322">                    OnDiskIndexBuilder builder = newIndexBuilder();</span>
<span class="fc" id="L323">                    builder.finish(Pair.create(combinedMin, combinedMax),</span>
                                   outputFile,
                                   new CombinedTermIterator(parts));
                }
<span class="fc" id="L327">                catch (Exception | FSError e)</span>
                {
<span class="fc" id="L329">                    logger.error(&quot;Failed to flush index {}.&quot;, outputFile, e);</span>
<span class="fc" id="L330">                    outputFile.tryDelete();</span>
                }
                finally
                {
<span class="fc" id="L334">                    logger.info(&quot;Index flush to {} took {} ms.&quot;, outputFile, TimeUnit.NANOSECONDS.toMillis(nanoTime() - start1));</span>

<span class="fc bfc" id="L336" title="All 2 branches covered.">                    for (int segment = 0; segment &lt; segmentNumber; segment++)</span>
                    {
                        @SuppressWarnings({ &quot;resource&quot;, &quot;RedundantSuppression&quot; })
<span class="fc" id="L339">                        OnDiskIndex part = parts[segment];</span>

<span class="fc bfc" id="L341" title="All 2 branches covered.">                        if (part != null)</span>
<span class="fc" id="L342">                            FileUtils.closeQuietly(part);</span>

<span class="fc" id="L344">                        outputFile.withSuffix(&quot;_&quot; + segment).tryDelete();</span>
                    }

<span class="fc" id="L347">                    latch.decrement();</span>
                }
<span class="fc" id="L349">            });</span>
<span class="fc" id="L350">        }</span>

        private ExecutorService getExecutor()
        {
<span class="fc bfc" id="L354" title="All 2 branches covered.">            return source == OperationType.FLUSH ? INDEX_FLUSHER_MEMTABLE : INDEX_FLUSHER_GENERAL;</span>
        }

        private OnDiskIndexBuilder newIndexBuilder()
        {
<span class="fc" id="L359">            return new OnDiskIndexBuilder(keyValidator, columnIndex.getValidator(), columnIndex.getMode().mode);</span>
        }

        public File file(boolean isFinal)
        {
<span class="fc bfc" id="L364" title="All 2 branches covered.">            return isFinal ? outputFile : outputFile.withSuffix(&quot;_&quot; + segmentNumber++);</span>
        }
    }

    protected long maxMemorySize(ColumnIndex columnIndex)
    {
        // 1G for memtable and configuration for compaction
<span class="fc bfc" id="L371" title="All 2 branches covered.">        return source == OperationType.FLUSH ? 1073741824L : columnIndex.getMode().maxCompactionFlushMemoryInBytes;</span>
    }

    public int hashCode()
    {
<span class="nc" id="L376">        return descriptor.hashCode();</span>
    }

    public boolean equals(Object o)
    {
<span class="nc bnc" id="L381" title="All 4 branches missed.">        return o instanceof PerSSTableIndexWriter &amp;&amp; descriptor.equals(((PerSSTableIndexWriter) o).descriptor);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>