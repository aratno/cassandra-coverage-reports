<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OnDiskIndex.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.index.sasi.disk</a> &gt; <span class="el_source">OnDiskIndex.java</span></div><h1>OnDiskIndex.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.index.sasi.disk;

import java.io.Closeable;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NavigableMap;
import java.util.TreeMap;
import java.util.stream.Collectors;

import com.google.common.base.Function;
import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import com.google.common.collect.PeekingIterator;

import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.index.sasi.Term;
import org.apache.cassandra.index.sasi.plan.Expression;
import org.apache.cassandra.index.sasi.plan.Expression.Op;
import org.apache.cassandra.index.sasi.utils.MappedBuffer;
import org.apache.cassandra.index.sasi.utils.RangeUnionIterator;
import org.apache.cassandra.index.sasi.utils.RangeIterator;
import org.apache.cassandra.io.FSReadError;
import org.apache.cassandra.io.util.ChannelProxy;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.io.util.FileInputStreamPlus;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.utils.AbstractGuavaIterator;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.FBUtilities;

import static org.apache.cassandra.index.sasi.disk.OnDiskBlock.SearchResult;

<span class="fc" id="L57">public class OnDiskIndex implements Iterable&lt;OnDiskIndex.DataTerm&gt;, Closeable</span>
{
<span class="fc" id="L59">    public enum IteratorOrder</span>
    {
<span class="fc" id="L61">        DESC(1), ASC(-1);</span>

        public final int step;

        IteratorOrder(int step)
<span class="fc" id="L66">        {</span>
<span class="fc" id="L67">            this.step = step;</span>
<span class="fc" id="L68">        }</span>

        public int startAt(OnDiskBlock&lt;DataTerm&gt; block, Expression e)
        {
<span class="pc bpc" id="L72" title="1 of 3 branches missed.">            switch (this)</span>
            {
                case DESC:
<span class="fc bfc" id="L75" title="All 2 branches covered.">                    return e.lower == null</span>
<span class="fc" id="L76">                            ? 0</span>
<span class="fc" id="L77">                            : startAt(block.search(e.validator, e.lower.value), e.lower.inclusive);</span>

                case ASC:
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">                    return e.upper == null</span>
<span class="nc" id="L81">                            ? block.termCount() - 1</span>
<span class="fc" id="L82">                            : startAt(block.search(e.validator, e.upper.value), e.upper.inclusive);</span>

                default:
<span class="nc" id="L85">                    throw new IllegalArgumentException(&quot;Unknown order: &quot; + this);</span>
            }
        }

        public int startAt(SearchResult&lt;DataTerm&gt; found, boolean inclusive)
        {
<span class="pc bpc" id="L91" title="1 of 3 branches missed.">            switch (this)</span>
            {
                case DESC:
<span class="fc bfc" id="L94" title="All 2 branches covered.">                    if (found.cmp &lt; 0)</span>
<span class="fc" id="L95">                        return found.index + 1;</span>

<span class="fc bfc" id="L97" title="All 4 branches covered.">                    return inclusive || found.cmp != 0 ? found.index : found.index + 1;</span>

                case ASC:
<span class="fc bfc" id="L100" title="All 2 branches covered.">                    if (found.cmp &lt; 0) // search term was bigger then whole data set</span>
<span class="fc" id="L101">                        return found.index;</span>
<span class="pc bpc" id="L102" title="1 of 6 branches missed.">                    return inclusive &amp;&amp; (found.cmp == 0 || found.cmp &lt; 0) ? found.index : found.index - 1;</span>

                default:
<span class="nc" id="L105">                    throw new IllegalArgumentException(&quot;Unknown order: &quot; + this);</span>
            }
        }
    }

    public final Descriptor descriptor;
    protected final OnDiskIndexBuilder.Mode mode;
    protected final OnDiskIndexBuilder.TermSize termSize;

    protected final AbstractType&lt;?&gt; comparator;
    protected final MappedBuffer indexFile;
    protected final long indexSize;
    protected final boolean hasMarkedPartials;

    protected final Function&lt;Long, DecoratedKey&gt; keyFetcher;

    protected final String indexPath;

    protected final PointerLevel[] levels;
    protected final DataLevel dataLevel;

    protected final ByteBuffer minTerm, maxTerm, minKey, maxKey;

    @SuppressWarnings(&quot;resource&quot;)
    public OnDiskIndex(File index, AbstractType&lt;?&gt; cmp, Function&lt;Long, DecoratedKey&gt; keyReader)
<span class="fc" id="L130">    {</span>
<span class="fc" id="L131">        keyFetcher = keyReader;</span>

<span class="fc" id="L133">        comparator = cmp;</span>
<span class="fc" id="L134">        indexPath = index.absolutePath();</span>


<span class="fc" id="L137">        try (FileInputStreamPlus backingFile = new FileInputStreamPlus(index))</span>
        {
<span class="fc" id="L139">            descriptor = new Descriptor(backingFile.readUTF());</span>

<span class="fc" id="L141">            termSize = OnDiskIndexBuilder.TermSize.of(backingFile.readShort());</span>

<span class="fc" id="L143">            minTerm = ByteBufferUtil.readWithShortLength(backingFile);</span>
<span class="fc" id="L144">            maxTerm = ByteBufferUtil.readWithShortLength(backingFile);</span>

<span class="fc" id="L146">            minKey = ByteBufferUtil.readWithShortLength(backingFile);</span>
<span class="fc" id="L147">            maxKey = ByteBufferUtil.readWithShortLength(backingFile);</span>

<span class="fc" id="L149">            mode = OnDiskIndexBuilder.Mode.mode(backingFile.readUTF());</span>
<span class="fc" id="L150">            hasMarkedPartials = backingFile.readBoolean();</span>

<span class="fc" id="L152">            FileChannel channel = index.newReadChannel();</span>
<span class="fc" id="L153">            indexSize = channel.size();</span>
<span class="fc" id="L154">            indexFile = new MappedBuffer(new ChannelProxy(index, channel));</span>
        }
<span class="nc" id="L156">        catch (IOException e)</span>
        {
<span class="nc" id="L158">            throw new FSReadError(e, index);</span>
<span class="fc" id="L159">        }</span>

        // start of the levels
<span class="fc" id="L162">        indexFile.position(indexFile.getLong(indexSize - 8));</span>

<span class="fc" id="L164">        int numLevels = indexFile.getInt();</span>
<span class="fc" id="L165">        levels = new PointerLevel[numLevels];</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">        for (int i = 0; i &lt; levels.length; i++)</span>
        {
<span class="fc" id="L168">            int blockCount = indexFile.getInt();</span>
<span class="fc" id="L169">            levels[i] = new PointerLevel(indexFile.position(), blockCount);</span>
<span class="fc" id="L170">            indexFile.position(indexFile.position() + blockCount * 8);</span>
        }

<span class="fc" id="L173">        int blockCount = indexFile.getInt();</span>
<span class="fc" id="L174">        dataLevel = new DataLevel(indexFile.position(), blockCount);</span>
<span class="fc" id="L175">    }</span>

    public boolean hasMarkedPartials()
    {
<span class="fc" id="L179">        return hasMarkedPartials;</span>
    }

    public OnDiskIndexBuilder.Mode mode()
    {
<span class="fc" id="L184">        return mode;</span>
    }

    public ByteBuffer minTerm()
    {
<span class="fc" id="L189">        return minTerm;</span>
    }

    public ByteBuffer maxTerm()
    {
<span class="fc" id="L194">        return maxTerm;</span>
    }

    public ByteBuffer minKey()
    {
<span class="fc" id="L199">        return minKey;</span>
    }

    public ByteBuffer maxKey()
    {
<span class="fc" id="L204">        return maxKey;</span>
    }

    public DataTerm min()
    {
<span class="fc" id="L209">        return dataLevel.getBlock(0).getTerm(0);</span>
    }

    public DataTerm max()
    {
<span class="fc" id="L214">        DataBlock block = dataLevel.getBlock(dataLevel.blockCount - 1);</span>
<span class="fc" id="L215">        return block.getTerm(block.termCount() - 1);</span>
    }

    /**
     * Search for rows which match all of the terms inside the given expression in the index file.
     *
     * @param exp The expression to use for the query.
     *
     * @return Iterator which contains rows for all of the terms from the given range.
     */
    public RangeIterator&lt;Long, Token&gt; search(Expression exp)
    {
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">        assert mode.supports(exp.getOp());</span>

<span class="pc bpc" id="L229" title="1 of 6 branches missed.">        if (exp.getOp() == Expression.Op.PREFIX &amp;&amp; mode == OnDiskIndexBuilder.Mode.CONTAINS &amp;&amp; !hasMarkedPartials)</span>
<span class="nc" id="L230">            throw new UnsupportedOperationException(&quot;prefix queries in CONTAINS mode are not supported by this index&quot;);</span>

        // optimization in case single term is requested from index
        // we don't really need to build additional union iterator
<span class="fc bfc" id="L234" title="All 2 branches covered.">        if (exp.getOp() == Op.EQ)</span>
        {
<span class="fc" id="L236">            DataTerm term = getTerm(exp.lower.value);</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">            return term == null ? null : term.getTokens();</span>
        }

        // convert single NOT_EQ to range with exclusion
<span class="fc bfc" id="L241" title="All 2 branches covered.">        final Expression expression = (exp.getOp() != Op.NOT_EQ)</span>
<span class="fc" id="L242">                                        ? exp</span>
<span class="fc" id="L243">                                        : new Expression(exp).setOp(Op.RANGE)</span>
<span class="fc" id="L244">                                                .setLower(new Expression.Bound(minTerm, true))</span>
<span class="fc" id="L245">                                                .setUpper(new Expression.Bound(maxTerm, true))</span>
<span class="fc" id="L246">                                                .addExclusion(exp.lower.value);</span>

<span class="fc" id="L248">        List&lt;ByteBuffer&gt; exclusions = new ArrayList&lt;&gt;(expression.exclusions.size());</span>

<span class="fc" id="L250">        Iterables.addAll(exclusions, expression.exclusions.stream().filter(exclusion -&gt; {</span>
            // accept only exclusions which are in the bounds of lower/upper
<span class="fc bfc" id="L252" title="All 6 branches covered.">            return !(expression.lower != null &amp;&amp; comparator.compare(exclusion, expression.lower.value) &lt; 0)</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">                &amp;&amp; !(expression.upper != null &amp;&amp; comparator.compare(exclusion, expression.upper.value) &gt; 0);</span>
<span class="fc" id="L254">        }).collect(Collectors.toList()));</span>

<span class="fc" id="L256">        Collections.sort(exclusions, comparator);</span>

<span class="fc bfc" id="L258" title="All 2 branches covered.">        if (exclusions.size() == 0)</span>
<span class="fc" id="L259">            return searchRange(expression);</span>

<span class="fc" id="L261">        List&lt;Expression&gt; ranges = new ArrayList&lt;&gt;(exclusions.size());</span>

        // calculate range splits based on the sorted exclusions
<span class="fc" id="L264">        Iterator&lt;ByteBuffer&gt; exclusionsIterator = exclusions.iterator();</span>

<span class="fc" id="L266">        Expression.Bound min = expression.lower, max = null;</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">        while (exclusionsIterator.hasNext())</span>
        {
<span class="fc" id="L269">            max = new Expression.Bound(exclusionsIterator.next(), false);</span>
<span class="fc" id="L270">            ranges.add(new Expression(expression).setOp(Op.RANGE).setLower(min).setUpper(max));</span>
<span class="fc" id="L271">            min = max;</span>
        }

<span class="pc bpc" id="L274" title="1 of 2 branches missed.">        assert max != null;</span>
<span class="fc" id="L275">        ranges.add(new Expression(expression).setOp(Op.RANGE).setLower(max).setUpper(expression.upper));</span>

<span class="fc" id="L277">        RangeUnionIterator.Builder&lt;Long, Token&gt; builder = RangeUnionIterator.builder();</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">        for (Expression e : ranges)</span>
        {
            @SuppressWarnings(&quot;resource&quot;)
<span class="fc" id="L281">            RangeIterator&lt;Long, Token&gt; range = searchRange(e);</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">            if (range != null)</span>
<span class="fc" id="L283">                builder.add(range);</span>
<span class="fc" id="L284">        }</span>

<span class="fc" id="L286">        return builder.build();</span>
    }

    private RangeIterator&lt;Long, Token&gt; searchRange(Expression range)
    {
<span class="fc" id="L291">        Expression.Bound lower = range.lower;</span>
<span class="fc" id="L292">        Expression.Bound upper = range.upper;</span>

<span class="fc bfc" id="L294" title="All 2 branches covered.">        int lowerBlock = lower == null ? 0 : getDataBlock(lower.value);</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">        int upperBlock = upper == null</span>
<span class="fc" id="L296">                ? dataLevel.blockCount - 1</span>
                // optimization so we don't have to fetch upperBlock when query has lower == upper
<span class="fc bfc" id="L298" title="All 4 branches covered.">                : (lower != null &amp;&amp; comparator.compare(lower.value, upper.value) == 0) ? lowerBlock : getDataBlock(upper.value);</span>

<span class="fc bfc" id="L300" title="All 6 branches covered.">        return (mode != OnDiskIndexBuilder.Mode.SPARSE || lowerBlock == upperBlock || upperBlock - lowerBlock &lt;= 1)</span>
<span class="fc" id="L301">                ? searchPoint(lowerBlock, range)</span>
<span class="fc" id="L302">                : searchRange(lowerBlock, lower, upperBlock, upper);</span>
    }

    private RangeIterator&lt;Long, Token&gt; searchRange(int lowerBlock, Expression.Bound lower, int upperBlock, Expression.Bound upper)
    {
        // if lower is at the beginning of the block that means we can just do a single iterator per block
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">        SearchResult&lt;DataTerm&gt; lowerPosition = (lower == null) ? null : searchIndex(lower.value, lowerBlock);</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">        SearchResult&lt;DataTerm&gt; upperPosition = (upper == null) ? null : searchIndex(upper.value, upperBlock);</span>

<span class="fc" id="L311">        RangeUnionIterator.Builder&lt;Long, Token&gt; builder = RangeUnionIterator.builder();</span>

        // optimistically assume that first and last blocks are full block reads, saves at least 3 'else' conditions
<span class="fc" id="L314">        int firstFullBlockIdx = lowerBlock, lastFullBlockIdx = upperBlock;</span>

        // 'lower' doesn't cover the whole block so we need to do a partial iteration
        // Two reasons why that can happen:
        //   - 'lower' is not the first element of the block
        //   - 'lower' is first element but it's not inclusive in the query
<span class="pc bpc" id="L320" title="1 of 6 branches missed.">        if (lowerPosition != null &amp;&amp; (lowerPosition.index &gt; 0 || !lower.inclusive))</span>
        {
<span class="fc" id="L322">            DataBlock block = dataLevel.getBlock(lowerBlock);</span>
<span class="pc bpc" id="L323" title="1 of 4 branches missed.">            int start = (lower.inclusive || lowerPosition.cmp != 0) ? lowerPosition.index : lowerPosition.index + 1;</span>

<span class="fc" id="L325">            builder.add(block.getRange(start, block.termCount()));</span>
<span class="fc" id="L326">            firstFullBlockIdx = lowerBlock + 1;</span>
        }

<span class="fc bfc" id="L329" title="All 2 branches covered.">        if (upperPosition != null)</span>
        {
<span class="fc" id="L331">            DataBlock block = dataLevel.getBlock(upperBlock);</span>
<span class="fc" id="L332">            int lastIndex = block.termCount() - 1;</span>

            // The save as with 'lower' but here we need to check if the upper is the last element of the block,
            // which means that we only have to get individual results if:
            //  - if it *is not* the last element, or
            //  - it *is* but shouldn't be included (dictated by upperInclusive)
<span class="fc bfc" id="L338" title="All 4 branches covered.">            if (upperPosition.index != lastIndex || !upper.inclusive)</span>
            {
<span class="pc bpc" id="L340" title="2 of 6 branches missed.">                int end = (upperPosition.cmp &lt; 0 || (upperPosition.cmp == 0 &amp;&amp; upper.inclusive))</span>
<span class="fc" id="L341">                                ? upperPosition.index + 1 : upperPosition.index;</span>

<span class="fc" id="L343">                builder.add(block.getRange(0, end));</span>
<span class="fc" id="L344">                lastFullBlockIdx = upperBlock - 1;</span>
            }
        }

<span class="fc" id="L348">        int totalSuperBlocks = (lastFullBlockIdx - firstFullBlockIdx) / OnDiskIndexBuilder.SUPER_BLOCK_SIZE;</span>

        // if there are no super-blocks, we can simply read all of the block iterators in sequence
<span class="fc bfc" id="L351" title="All 2 branches covered.">        if (totalSuperBlocks == 0)</span>
        {
<span class="fc bfc" id="L353" title="All 2 branches covered.">            for (int i = firstFullBlockIdx; i &lt;= lastFullBlockIdx; i++)</span>
<span class="fc" id="L354">                builder.add(dataLevel.getBlock(i).getBlockIndex().iterator(keyFetcher));</span>

<span class="fc" id="L356">            return builder.build();</span>
        }

        // first get all of the blocks which are aligned before the first super-block in the sequence,
        // e.g. if the block range was (1, 9) and super-block-size = 4, we need to read 1, 2, 3, 4 - 7 is covered by
        // super-block, 8, 9 is a remainder.

<span class="fc bfc" id="L363" title="All 2 branches covered.">        int superBlockAlignedStart = firstFullBlockIdx == 0 ? 0 : (int) FBUtilities.align(firstFullBlockIdx, OnDiskIndexBuilder.SUPER_BLOCK_SIZE);</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">        for (int blockIdx = firstFullBlockIdx; blockIdx &lt; Math.min(superBlockAlignedStart, lastFullBlockIdx); blockIdx++)</span>
<span class="fc" id="L365">            builder.add(getBlockIterator(blockIdx));</span>

        // now read all of the super-blocks matched by the request, from the previous comment
        // it's a block with index 1 (which covers everything from 4 to 7)

<span class="fc" id="L370">        int superBlockIdx = superBlockAlignedStart / OnDiskIndexBuilder.SUPER_BLOCK_SIZE;</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">        for (int offset = 0; offset &lt; totalSuperBlocks - 1; offset++)</span>
<span class="fc" id="L372">            builder.add(dataLevel.getSuperBlock(superBlockIdx++).iterator());</span>

        // now it's time for a remainder read, again from the previous example it's 8, 9 because
        // we have over-shot previous block but didn't request enough to cover next super-block.

<span class="fc" id="L377">        int lastCoveredBlock = superBlockIdx * OnDiskIndexBuilder.SUPER_BLOCK_SIZE;</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">        for (int offset = 0; offset &lt;= (lastFullBlockIdx - lastCoveredBlock); offset++)</span>
<span class="fc" id="L379">            builder.add(getBlockIterator(lastCoveredBlock + offset));</span>

<span class="fc" id="L381">        return builder.build();</span>
    }

    private RangeIterator&lt;Long, Token&gt; searchPoint(int lowerBlock, Expression expression)
    {
<span class="fc" id="L386">        Iterator&lt;DataTerm&gt; terms = new TermIterator(lowerBlock, expression, IteratorOrder.DESC);</span>
<span class="fc" id="L387">        RangeUnionIterator.Builder&lt;Long, Token&gt; builder = RangeUnionIterator.builder();</span>

<span class="fc bfc" id="L389" title="All 2 branches covered.">        while (terms.hasNext())</span>
        {
            try
            {
<span class="fc" id="L393">                builder.add(terms.next().getTokens());</span>
            }
            finally
            {
<span class="fc" id="L397">                expression.checkpoint();</span>
<span class="fc" id="L398">            }</span>
        }

<span class="fc" id="L401">        return builder.build();</span>
    }

    private RangeIterator&lt;Long, Token&gt; getBlockIterator(int blockIdx)
    {
<span class="fc" id="L406">        DataBlock block = dataLevel.getBlock(blockIdx);</span>
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">        return (block.hasCombinedIndex)</span>
<span class="fc" id="L408">                ? block.getBlockIndex().iterator(keyFetcher)</span>
<span class="nc" id="L409">                : block.getRange(0, block.termCount());</span>
    }

    public Iterator&lt;DataTerm&gt; iteratorAt(ByteBuffer query, IteratorOrder order, boolean inclusive)
    {
<span class="fc" id="L414">        Expression e = new Expression(&quot;&quot;, comparator);</span>
<span class="fc" id="L415">        Expression.Bound bound = new Expression.Bound(query, inclusive);</span>

<span class="pc bpc" id="L417" title="1 of 3 branches missed.">        switch (order)</span>
        {
            case DESC:
<span class="fc" id="L420">                e.setLower(bound);</span>
<span class="fc" id="L421">                break;</span>

            case ASC:
<span class="fc" id="L424">                e.setUpper(bound);</span>
<span class="fc" id="L425">                break;</span>

            default:
<span class="nc" id="L428">                throw new IllegalArgumentException(&quot;Unknown order: &quot; + order);</span>
        }

<span class="pc bpc" id="L431" title="1 of 2 branches missed.">        return new TermIterator(levels.length == 0 ? 0 : getBlockIdx(findPointer(query), query), e, order);</span>
    }

    private int getDataBlock(ByteBuffer query)
    {
<span class="fc bfc" id="L436" title="All 2 branches covered.">        return levels.length == 0 ? 0 : getBlockIdx(findPointer(query), query);</span>
    }

    public Iterator&lt;DataTerm&gt; iterator()
    {
<span class="fc" id="L441">        return new TermIterator(0, new Expression(&quot;&quot;, comparator), IteratorOrder.DESC);</span>
    }

    public void close() throws IOException
    {
<span class="fc" id="L446">        FileUtils.closeQuietly(indexFile);</span>
<span class="fc" id="L447">    }</span>

    private PointerTerm findPointer(ByteBuffer query)
    {
<span class="fc" id="L451">        PointerTerm ptr = null;</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">        for (PointerLevel level : levels)</span>
        {
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">            if ((ptr = level.getPointer(ptr, query)) == null)</span>
<span class="nc" id="L455">                return null;</span>
        }

<span class="fc" id="L458">        return ptr;</span>
    }

    private DataTerm getTerm(ByteBuffer query)
    {
<span class="fc" id="L463">        SearchResult&lt;DataTerm&gt; term = searchIndex(query, getDataBlock(query));</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">        return term.cmp == 0 ? term.result : null;</span>
    }

    private SearchResult&lt;DataTerm&gt; searchIndex(ByteBuffer query, int blockIdx)
    {
<span class="fc" id="L469">        return dataLevel.getBlock(blockIdx).search(comparator, query);</span>
    }

    private int getBlockIdx(PointerTerm ptr, ByteBuffer query)
    {
<span class="fc" id="L474">        int blockIdx = 0;</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">        if (ptr != null)</span>
        {
<span class="fc" id="L477">            int cmp = ptr.compareTo(comparator, query);</span>
<span class="fc bfc" id="L478" title="All 4 branches covered.">            blockIdx = (cmp == 0 || cmp &gt; 0) ? ptr.getBlock() : ptr.getBlock() + 1;</span>
        }

<span class="fc" id="L481">        return blockIdx;</span>
    }

    protected class PointerLevel extends Level&lt;PointerBlock&gt;
    {
        public PointerLevel(long offset, int count)
<span class="fc" id="L487">        {</span>
<span class="fc" id="L488">            super(offset, count);</span>
<span class="fc" id="L489">        }</span>

        public PointerTerm getPointer(PointerTerm parent, ByteBuffer query)
        {
<span class="fc" id="L493">            return getBlock(getBlockIdx(parent, query)).search(comparator, query).result;</span>
        }

        protected PointerBlock cast(MappedBuffer block)
        {
<span class="fc" id="L498">            return new PointerBlock(block);</span>
        }
    }

<span class="fc" id="L502">    protected class DataLevel extends Level&lt;DataBlock&gt;</span>
    {
        protected final int superBlockCnt;
        protected final long superBlocksOffset;

        public DataLevel(long offset, int count)
<span class="fc" id="L508">        {</span>
<span class="fc" id="L509">            super(offset, count);</span>
<span class="fc" id="L510">            long baseOffset = blockOffsets + blockCount * 8;</span>
<span class="fc" id="L511">            superBlockCnt = indexFile.getInt(baseOffset);</span>
<span class="fc" id="L512">            superBlocksOffset = baseOffset + 4;</span>
<span class="fc" id="L513">        }</span>

        protected DataBlock cast(MappedBuffer block)
        {
<span class="fc" id="L517">            return new DataBlock(block);</span>
        }

        public OnDiskSuperBlock getSuperBlock(int idx)
        {
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">            assert idx &lt; superBlockCnt : String.format(&quot;requested index %d is greater than super block count %d&quot;, idx, superBlockCnt);</span>
<span class="fc" id="L523">            long blockOffset = indexFile.getLong(superBlocksOffset + idx * 8);</span>
<span class="fc" id="L524">            return new OnDiskSuperBlock(indexFile.duplicate().position(blockOffset));</span>
        }
    }

    protected class OnDiskSuperBlock
    {
        private final TokenTree tokenTree;

        public OnDiskSuperBlock(MappedBuffer buffer)
<span class="fc" id="L533">        {</span>
<span class="fc" id="L534">            tokenTree = new TokenTree(descriptor, buffer);</span>
<span class="fc" id="L535">        }</span>

        public RangeIterator&lt;Long, Token&gt; iterator()
        {
<span class="fc" id="L539">            return tokenTree.iterator(keyFetcher);</span>
        }
    }

<span class="fc" id="L543">    protected abstract class Level&lt;T extends OnDiskBlock&gt;</span>
    {
        protected final long blockOffsets;
        protected final int blockCount;

        public Level(long offsets, int count)
<span class="fc" id="L549">        {</span>
<span class="fc" id="L550">            this.blockOffsets = offsets;</span>
<span class="fc" id="L551">            this.blockCount = count;</span>
<span class="fc" id="L552">        }</span>

        public T getBlock(int idx) throws FSReadError
        {
<span class="pc bpc" id="L556" title="2 of 4 branches missed.">            assert idx &gt;= 0 &amp;&amp; idx &lt; blockCount;</span>

            // calculate block offset and move there
            // (long is intentional, we'll just need mmap implementation which supports long positions)
<span class="fc" id="L560">            long blockOffset = indexFile.getLong(blockOffsets + idx * 8);</span>
<span class="fc" id="L561">            return cast(indexFile.duplicate().position(blockOffset));</span>
        }

        protected abstract T cast(MappedBuffer block);
    }

    protected class DataBlock extends OnDiskBlock&lt;DataTerm&gt;
    {
        public DataBlock(MappedBuffer data)
<span class="fc" id="L570">        {</span>
<span class="fc" id="L571">            super(descriptor, data, BlockType.DATA);</span>
<span class="fc" id="L572">        }</span>

        protected DataTerm cast(MappedBuffer data)
        {
<span class="fc" id="L576">            return new DataTerm(data, termSize, getBlockIndex());</span>
        }

        public RangeIterator&lt;Long, Token&gt; getRange(int start, int end)
        {
<span class="fc" id="L581">            RangeUnionIterator.Builder&lt;Long, Token&gt; builder = RangeUnionIterator.builder();</span>
<span class="fc" id="L582">            NavigableMap&lt;Long, Token&gt; sparse = new TreeMap&lt;&gt;();</span>

<span class="fc bfc" id="L584" title="All 2 branches covered.">            for (int i = start; i &lt; end; i++)</span>
            {
<span class="fc" id="L586">                DataTerm term = getTerm(i);</span>

<span class="pc bpc" id="L588" title="1 of 2 branches missed.">                if (term.isSparse())</span>
                {
<span class="fc" id="L590">                    NavigableMap&lt;Long, Token&gt; tokens = term.getSparseTokens();</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">                    for (Map.Entry&lt;Long, Token&gt; t : tokens.entrySet())</span>
                    {
<span class="fc" id="L593">                        Token token = sparse.get(t.getKey());</span>
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">                        if (token == null)</span>
<span class="fc" id="L595">                            sparse.put(t.getKey(), t.getValue());</span>
                        else
<span class="nc" id="L597">                            token.merge(t.getValue());</span>
<span class="fc" id="L598">                    }</span>
<span class="fc" id="L599">                }</span>
                else
                {
<span class="nc" id="L602">                    builder.add(term.getTokens());</span>
                }
            }

<span class="fc bfc" id="L606" title="All 2 branches covered.">            PrefetchedTokensIterator prefetched = sparse.isEmpty() ? null : new PrefetchedTokensIterator(sparse);</span>

<span class="pc bpc" id="L608" title="1 of 2 branches missed.">            if (builder.rangeCount() == 0)</span>
<span class="fc" id="L609">                return prefetched;</span>

<span class="nc" id="L611">            builder.add(prefetched);</span>
<span class="nc" id="L612">            return builder.build();</span>
        }
    }

    protected class PointerBlock extends OnDiskBlock&lt;PointerTerm&gt;
    {
        public PointerBlock(MappedBuffer block)
<span class="fc" id="L619">        {</span>
<span class="fc" id="L620">            super(descriptor, block, BlockType.POINTER);</span>
<span class="fc" id="L621">        }</span>

        protected PointerTerm cast(MappedBuffer data)
        {
<span class="fc" id="L625">            return new PointerTerm(data, termSize, hasMarkedPartials);</span>
        }
    }

<span class="fc" id="L629">    public class DataTerm extends Term implements Comparable&lt;DataTerm&gt;</span>
    {
        private final TokenTree perBlockIndex;

        protected DataTerm(MappedBuffer content, OnDiskIndexBuilder.TermSize size, TokenTree perBlockIndex)
<span class="fc" id="L634">        {</span>
<span class="fc" id="L635">            super(content, size, hasMarkedPartials);</span>
<span class="fc" id="L636">            this.perBlockIndex = perBlockIndex;</span>
<span class="fc" id="L637">        }</span>

        public RangeIterator&lt;Long, Token&gt; getTokens()
        {
<span class="fc" id="L641">            final long blockEnd = FBUtilities.align(content.position(), OnDiskIndexBuilder.BLOCK_SIZE);</span>

<span class="fc bfc" id="L643" title="All 2 branches covered.">            if (isSparse())</span>
<span class="fc" id="L644">                return new PrefetchedTokensIterator(getSparseTokens());</span>

<span class="fc" id="L646">            long offset = blockEnd + 4 + content.getInt(getDataOffset() + 1);</span>
<span class="fc" id="L647">            return new TokenTree(descriptor, indexFile.duplicate().position(offset)).iterator(keyFetcher);</span>
        }

        public boolean isSparse()
        {
<span class="fc bfc" id="L652" title="All 2 branches covered.">            return content.get(getDataOffset()) &gt; 0;</span>
        }

        public NavigableMap&lt;Long, Token&gt; getSparseTokens()
        {
<span class="fc" id="L657">            long ptrOffset = getDataOffset();</span>

<span class="fc" id="L659">            byte size = content.get(ptrOffset);</span>

<span class="pc bpc" id="L661" title="1 of 2 branches missed.">            assert size &gt; 0;</span>

<span class="fc" id="L663">            NavigableMap&lt;Long, Token&gt; individualTokens = new TreeMap&lt;&gt;();</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++)</span>
            {
<span class="fc" id="L666">                Token token = perBlockIndex.get(content.getLong(ptrOffset + 1 + (8 * i)), keyFetcher);</span>

<span class="pc bpc" id="L668" title="1 of 2 branches missed.">                assert token != null;</span>
<span class="fc" id="L669">                individualTokens.put(token.get(), token);</span>
            }

<span class="fc" id="L672">            return individualTokens;</span>
        }

        public int compareTo(DataTerm other)
        {
<span class="pc bpc" id="L677" title="1 of 2 branches missed.">            return other == null ? 1 : compareTo(comparator, other.getTerm());</span>
        }
    }

    protected static class PointerTerm extends Term
    {
        public PointerTerm(MappedBuffer content, OnDiskIndexBuilder.TermSize size, boolean hasMarkedPartials)
        {
<span class="fc" id="L685">            super(content, size, hasMarkedPartials);</span>
<span class="fc" id="L686">        }</span>

        public int getBlock()
        {
<span class="fc" id="L690">            return content.getInt(getDataOffset());</span>
        }
    }

    private static class PrefetchedTokensIterator extends RangeIterator&lt;Long, Token&gt;
    {
        private final NavigableMap&lt;Long, Token&gt; tokens;
        private PeekingIterator&lt;Token&gt; currentIterator;

        public PrefetchedTokensIterator(NavigableMap&lt;Long, Token&gt; tokens)
        {
<span class="fc" id="L701">            super(tokens.firstKey(), tokens.lastKey(), tokens.size());</span>
<span class="fc" id="L702">            this.tokens = tokens;</span>
<span class="fc" id="L703">            this.currentIterator = Iterators.peekingIterator(tokens.values().iterator());</span>
<span class="fc" id="L704">        }</span>

        protected Token computeNext()
        {
<span class="pc bpc" id="L708" title="1 of 4 branches missed.">            return currentIterator != null &amp;&amp; currentIterator.hasNext()</span>
<span class="fc" id="L709">                    ? currentIterator.next()</span>
<span class="fc" id="L710">                    : endOfData();</span>
        }

        protected void performSkipTo(Long nextToken)
        {
<span class="nc" id="L715">            currentIterator = Iterators.peekingIterator(tokens.tailMap(nextToken, true).values().iterator());</span>
<span class="nc" id="L716">        }</span>

        public void close() throws IOException
        {
<span class="fc" id="L720">            endOfData();</span>
<span class="fc" id="L721">        }</span>
    }

    public AbstractType&lt;?&gt; getComparator()
    {
<span class="fc" id="L726">        return comparator;</span>
    }

    public String getIndexPath()
    {
<span class="fc" id="L731">        return indexPath;</span>
    }

    private class TermIterator extends AbstractGuavaIterator&lt;DataTerm&gt;
    {
        private final Expression e;
        private final IteratorOrder order;

        protected OnDiskBlock&lt;DataTerm&gt; currentBlock;
        protected int blockIndex, offset;

<span class="fc" id="L742">        private boolean checkLower = true, checkUpper = true;</span>

        public TermIterator(int startBlock, Expression expression, IteratorOrder order)
<span class="fc" id="L745">        {</span>
<span class="fc" id="L746">            this.e = expression;</span>
<span class="fc" id="L747">            this.order = order;</span>
<span class="fc" id="L748">            this.blockIndex = startBlock;</span>

<span class="fc" id="L750">            nextBlock();</span>
<span class="fc" id="L751">        }</span>

        protected DataTerm computeNext()
        {
            for (;;)
            {
<span class="fc bfc" id="L757" title="All 2 branches covered.">                if (currentBlock == null)</span>
<span class="fc" id="L758">                    return endOfData();</span>

<span class="fc bfc" id="L760" title="All 4 branches covered.">                if (offset &gt;= 0 &amp;&amp; offset &lt; currentBlock.termCount())</span>
                {
<span class="fc" id="L762">                    DataTerm currentTerm = currentBlock.getTerm(nextOffset());</span>

                    // we need to step over all of the partial terms, in PREFIX mode,
                    // encountered by the query until upper-bound tells us to stop
<span class="fc bfc" id="L766" title="All 4 branches covered.">                    if (e.getOp() == Op.PREFIX &amp;&amp; currentTerm.isPartial())</span>
<span class="fc" id="L767">                        continue;</span>

                    // haven't reached the start of the query range yet, let's
                    // keep skip the current term until lower bound is satisfied
<span class="fc bfc" id="L771" title="All 4 branches covered.">                    if (checkLower &amp;&amp; !e.isLowerSatisfiedBy(currentTerm))</span>
<span class="fc" id="L772">                        continue;</span>

                    // flip the flag right on the first bounds match
                    // to avoid expensive comparisons
<span class="fc" id="L776">                    checkLower = false;</span>

<span class="fc bfc" id="L778" title="All 4 branches covered.">                    if (checkUpper &amp;&amp; !e.isUpperSatisfiedBy(currentTerm))</span>
<span class="fc" id="L779">                        return endOfData();</span>

<span class="fc" id="L781">                    return currentTerm;</span>
                }

<span class="fc" id="L784">                nextBlock();</span>
            }
        }

        protected void nextBlock()
        {
<span class="fc" id="L790">            currentBlock = null;</span>

<span class="fc bfc" id="L792" title="All 4 branches covered.">            if (blockIndex &lt; 0 || blockIndex &gt;= dataLevel.blockCount)</span>
<span class="fc" id="L793">                return;</span>

<span class="fc" id="L795">            currentBlock = dataLevel.getBlock(nextBlockIndex());</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">            offset = checkLower ? order.startAt(currentBlock, e) : currentBlock.minOffset(order);</span>

            // let's check the last term of the new block right away
            // if expression's upper bound is satisfied by it such means that we can avoid
            // doing any expensive upper bound checks for that block.
<span class="fc bfc" id="L801" title="All 4 branches covered.">            checkUpper = e.hasUpper() &amp;&amp; !e.isUpperSatisfiedBy(currentBlock.getTerm(currentBlock.maxOffset(order)));</span>
<span class="fc" id="L802">        }</span>

        protected int nextBlockIndex()
        {
<span class="fc" id="L806">            int current = blockIndex;</span>
<span class="fc" id="L807">            blockIndex += order.step;</span>
<span class="fc" id="L808">            return current;</span>
        }

        protected int nextOffset()
        {
<span class="fc" id="L813">            int current = offset;</span>
<span class="fc" id="L814">            offset += order.step;</span>
<span class="fc" id="L815">            return current;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>