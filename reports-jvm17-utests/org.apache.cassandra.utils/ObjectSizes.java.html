<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ObjectSizes.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.utils</a> &gt; <span class="el_source">ObjectSizes.java</span></div><h1>ObjectSizes.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.cassandra.utils;

import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;

import org.github.jamm.MemoryMeter;
import org.github.jamm.MemoryMeter.ByteBufferMode;
import org.github.jamm.MemoryMeter.Guess;

import static org.github.jamm.MemoryMeterStrategy.MEMORY_LAYOUT;
import static org.github.jamm.utils.ArrayMeasurementUtils.computeArraySize;

/**
 * A convenience class for wrapping access to MemoryMeter. Should be used instead of using a {@code MemoryMeter} directly.
 * {@code MemoryMeter} can be used directly for testing as it allow a more fine tuned configuration for comparison.
 */
<span class="nc" id="L38">public class ObjectSizes</span>
{
<span class="fc" id="L40">    private static final MemoryMeter meter = MemoryMeter.builder().withGuessing(Guess.INSTRUMENTATION_AND_SPECIFICATION,</span>
                                                                                Guess.UNSAFE)
<span class="fc" id="L42">                                                                  .build();</span>

<span class="fc" id="L44">    private static final long HEAP_BUFFER_SHALLOW_SIZE = measure(ByteBufferUtil.EMPTY_BYTE_BUFFER);</span>
<span class="fc" id="L45">    private static final long DIRECT_BUFFER_SHALLOW_SIZE = measure(ByteBuffer.allocateDirect(0));</span>
<span class="fc" id="L46">    private static final long DIRECT_BUFFER_DEEP_SIZE = measureDeep(ByteBuffer.allocateDirect(0));</span>

<span class="fc" id="L48">    public static final long IPV6_SOCKET_ADDRESS_SIZE = ObjectSizes.measureDeep(new InetSocketAddress(getIpvAddress(16), 42));</span>

    /**
     * Memory a byte array consumes
     *
     * @param bytes byte array to get memory size
     * @return heap-size of the array
     */
    public static long sizeOfArray(byte[] bytes)
    {
<span class="fc" id="L58">        return meter.measureArray(bytes);</span>
    }

    /**
     * Memory a long array consumes
     *
     * @param longs byte array to get memory size
     * @return heap-size of the array
     */
    public static long sizeOfArray(long[] longs)
    {
<span class="fc" id="L69">        return meter.measureArray(longs);</span>
    }

    /**
     * Memory an int array consumes
     *
     * @param ints byte array to get memory size
     * @return heap-size of the array
     */
    public static long sizeOfArray(int[] ints)
    {
<span class="fc" id="L80">        return meter.measureArray(ints);</span>
    }

    /**
     * Memory a reference array consumes
     *
     * @param length the length of the reference array
     * @return heap-size of the array
     */
    public static long sizeOfReferenceArray(int length)
    {
<span class="fc" id="L91">        return sizeOfArray(length, MEMORY_LAYOUT.getReferenceSize());</span>
    }

    /**
     * Memory a reference array consumes itself only
     *
     * @param objects the array to size
     * @return heap-size of the array (excluding memory retained by referenced objects)
     */
    public static long sizeOfArray(Object[] objects)
    {
<span class="fc" id="L102">        return meter.measureArray(objects);</span>
    }

    private static long sizeOfArray(int length, int elementSize)
    {
<span class="fc" id="L107">        return computeArraySize(MEMORY_LAYOUT.getArrayHeaderSize(), length, elementSize, MEMORY_LAYOUT.getObjectAlignment());</span>
    }

    /**
     * Amount of heap memory consumed by the array of byte buffers. It sums memory consumed by the array itself
     * and for each included byte buffer using {@link #sizeOnHeapOf(ByteBuffer)}.
     */
    public static long sizeOnHeapOf(ByteBuffer[] array)
    {
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        if (array == null)</span>
<span class="nc" id="L117">            return 0;</span>

<span class="fc" id="L119">        long sum = sizeOfArray(array);</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">        for (ByteBuffer buffer : array)</span>
<span class="fc" id="L121">            sum += sizeOnHeapOf(buffer);</span>

<span class="fc" id="L123">        return sum;</span>
    }

    /**
     * Amount of non-data heap memory consumed by the array of byte buffers. It sums memory consumed
     * by the array itself and for each included byte buffer using {@link #sizeOnHeapExcludingDataOf(ByteBuffer)}.
     */
    public static long sizeOnHeapExcludingDataOf(ByteBuffer[] array)
    {
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if (array == null)</span>
<span class="nc" id="L133">            return 0;</span>

<span class="fc" id="L135">        long sum = sizeOfArray(array);</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">        for (ByteBuffer b : array)</span>
<span class="fc" id="L137">            sum += sizeOnHeapExcludingDataOf(b);</span>

<span class="fc" id="L139">        return sum;</span>
    }

    /**
     * Measures the heap memory used by the specified byte buffer. If the buffer is a slab only the data size will be
     * counted but not the internal overhead. A SLAB is assumed to be created by: {@code buffer.duplicate().position(start).limit(end)} without the use of {@code slice()}.
     * &lt;p&gt;This method makes a certain amount of assumptions:
     *   &lt;ul&gt;
     *       &lt;li&gt;That slabs are always created using: {@code buffer.duplicate().position(start).limit(end)} and not through slice&lt;/li&gt;
     *       &lt;li&gt;That the input buffers are not read-only buffers&lt;/li&gt;
     *       &lt;li&gt;That the direct buffers that are not slab are not duplicates&lt;/li&gt;  
     *   &lt;/ul&gt;
     *  Non-respect of those assumptions can lead to an invalid value being returned.
     * @param buffer the buffer to measure
     * @return the heap memory used by the specified byte buffer.
     */
    public static long sizeOnHeapOf(ByteBuffer buffer)
    {
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">        if (buffer == null)</span>
<span class="nc" id="L158">            return 0;</span>

<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        assert !buffer.isReadOnly();</span>

        // We assume here that slabs are always created using: buffer.duplicate().position(start).limit(end) and not through slice
<span class="fc bfc" id="L163" title="All 2 branches covered.">        if (ByteBufferMode.SLAB_ALLOCATION_NO_SLICE.isSlab(buffer))</span>
        {
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">            if (buffer.isDirect())</span>
<span class="nc" id="L166">                return DIRECT_BUFFER_SHALLOW_SIZE; // We ignore the underlying buffer</span>

<span class="fc" id="L168">            return HEAP_BUFFER_SHALLOW_SIZE + buffer.remaining(); // We ignore the array overhead</span>
        }

<span class="fc bfc" id="L171" title="All 2 branches covered.">        if (buffer.isDirect())</span>
<span class="fc" id="L172">            return DIRECT_BUFFER_DEEP_SIZE; // That might not be true if the buffer is a view of another buffer so we could undercount</span>

<span class="fc" id="L174">        return HEAP_BUFFER_SHALLOW_SIZE + meter.measureArray(buffer.array());</span>
    }

    /**
     * Measures the heap memory used by the specified byte buffer excluding the data. If the buffer shallow size will be counted.
     * A SLAB is assumed to be created by: {@code buffer.duplicate().position(start).limit(end)} without the use of {@code slice()}.
     * &lt;p&gt;This method makes a certain amount of assumptions:
     *   &lt;ul&gt;
     *       &lt;li&gt;That slabs are always created using: {@code buffer.duplicate().position(start).limit(end)} and not through slice&lt;/li&gt;
     *       &lt;li&gt;That the input buffers are not read-only buffers&lt;/li&gt;
     *       &lt;li&gt;That the direct buffers that are not slab are not duplicates&lt;/li&gt;  
     *   &lt;/ul&gt;
     *  Non-respect of those assumptions can lead to an invalid value being returned. T 
     * @param buffer the buffer to measure
     * @return the heap memory used by the specified byte buffer excluding the data..
     */
    public static long sizeOnHeapExcludingDataOf(ByteBuffer buffer)
    {
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        if (buffer == null)</span>
<span class="nc" id="L193">            return 0;</span>

<span class="pc bpc" id="L195" title="1 of 2 branches missed.">        assert !buffer.isReadOnly();</span>

        // We assume here that slabs are always created using: buffer.duplicate().position(start).limit(end) and not through slice
<span class="fc bfc" id="L198" title="All 2 branches covered.">        if (ByteBufferMode.SLAB_ALLOCATION_NO_SLICE.isSlab(buffer))</span>
        {
<span class="fc bfc" id="L200" title="All 2 branches covered.">            if (buffer.isDirect())</span>
<span class="fc" id="L201">                return DIRECT_BUFFER_SHALLOW_SIZE; // We ignore the underlying buffer</span>

<span class="fc" id="L203">            return HEAP_BUFFER_SHALLOW_SIZE; // We ignore the array overhead</span>
        }

<span class="fc bfc" id="L206" title="All 2 branches covered.">        if (buffer.isDirect())</span>
<span class="fc" id="L207">            return DIRECT_BUFFER_DEEP_SIZE; // That might not be true if the buffer is a view of another buffer so we could undercount</span>

<span class="fc" id="L209">        byte[] bytes = buffer.array();</span>
<span class="fc" id="L210">        return HEAP_BUFFER_SHALLOW_SIZE + meter.measureArray(bytes) - bytes.length;</span>
    }

    /**
     * Memory a String consumes
     *
     * @param str String to calculate memory size of
     * @return Total in-memory size of the String
     */
    public static long sizeOf(String str)
    {
<span class="fc" id="L221">        return meter.measureStringDeep(str);</span>
    }

    /**
     * @param pojo the object to measure
     * @return the size on the heap of the instance and all retained heap referenced by it, excluding portions of
     * ByteBuffer that are not directly referenced by it but including any other referenced that may also be retained
     * by other objects.
     */
    public static long measureDeep(Object pojo)
    {
<span class="fc" id="L232">        return meter.measureDeep(pojo);</span>
    }

    /**
     * @param pojo the object to measure
     * @return The size on the heap of the instance and all retained heap referenced by it, excluding portions of
     * ByteBuffer that are not directly referenced by it but including any other referenced that may also be retained
     * by other objects. This also includes bytes referenced in direct byte buffers, and may double-count memory if
     * it is referenced by multiple ByteBuffer copies.
     */
    public static long measureDeepOmitShared(Object pojo)
    {
<span class="fc" id="L244">        return meter.measureDeep(pojo, ByteBufferMode.SLAB_ALLOCATION_NO_SLICE);</span>
    }

    /**
     * @param pojo the object to measure
     * @return the size on the heap of the instance only, excluding any referenced objects
     */
    public static long measure(Object pojo)
    {
<span class="fc" id="L253">        return meter.measure(pojo);</span>
    }

    private static InetAddress getIpvAddress(int size)
    {
<span class="pc bpc" id="L258" title="3 of 4 branches missed.">        if (size == 16 || size ==4)</span>
        {
            try
            {
<span class="fc" id="L262">                return InetAddress.getByAddress(new byte[size]);</span>
            }
<span class="nc" id="L264">            catch (UnknownHostException e)</span>
            {
<span class="nc" id="L266">                throw new IllegalArgumentException(&quot;Invalid size of a byte array when getting and ipv address: &quot; + size);</span>
            }
        }
<span class="nc" id="L269">        else throw new IllegalArgumentException(&quot;Excpected a byte array size of 4 or 16 for an ipv address but got: &quot; + size);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>