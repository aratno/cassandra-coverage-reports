<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FastByteOperations.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.utils</a> &gt; <span class="el_source">FastByteOperations.java</span></div><h1>FastByteOperations.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.utils;

import java.lang.reflect.Field;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.security.AccessController;
import java.security.PrivilegedAction;

import com.google.common.primitives.*;

import net.nicoulaj.compilecommand.annotations.Inline;
import sun.misc.Unsafe;

/**
 * Utility code to do optimized byte-array comparison.
 * This is borrowed and slightly modified from Guava's {@link UnsignedBytes}
 * class to be able to compare arrays that start at non-zero offsets.
 */
<span class="nc" id="L37">public class FastByteOperations</span>
{

    /**
     * Lexicographically compare two byte arrays.
     */
    public static int compareUnsigned(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2)
    {
<span class="fc" id="L45">        return BestHolder.BEST.compare(b1, s1, l1, b2, s2, l2);</span>
    }

    public static int compareUnsigned(ByteBuffer b1, byte[] b2, int s2, int l2)
    {
<span class="fc" id="L50">        return BestHolder.BEST.compare(b1, b2, s2, l2);</span>
    }

    public static int compareUnsigned(byte[] b1, int s1, int l1, ByteBuffer b2)
    {
<span class="fc" id="L55">        return -BestHolder.BEST.compare(b2, b1, s1, l1);</span>
    }

    public static int compareUnsigned(ByteBuffer b1, int s1, int l1, byte[] b2, int s2, int l2)
    {
<span class="fc" id="L60">        return BestHolder.BEST.compare(b1, s1, l1, b2, s2, l2);</span>
    }

    public static int compareUnsigned(byte[] b1, int s1, int l1, ByteBuffer b2, int s2, int l2)
    {
<span class="fc" id="L65">        return -BestHolder.BEST.compare(b2, s2, l2, b1, s1, l1);</span>
    }

    public static int compareUnsigned(ByteBuffer b1, ByteBuffer b2)
    {
<span class="fc" id="L70">        return BestHolder.BEST.compare(b1, b2);</span>
    }

    public static int compareUnsigned(byte[] b1, byte[] b2)
    {
<span class="fc" id="L75">        return compareUnsigned(b1, 0, b1.length, b2, 0, b2.length);</span>
    }

    public static void copy(byte[] src, int srcPosition, byte[] trg, int trgPosition, int length)
    {
<span class="fc" id="L80">        BestHolder.BEST.copy(src, srcPosition, trg, trgPosition, length);</span>
<span class="fc" id="L81">    }</span>

    public static void copy(ByteBuffer src, int srcPosition, byte[] trg, int trgPosition, int length)
    {
<span class="fc" id="L85">        BestHolder.BEST.copy(src, srcPosition, trg, trgPosition, length);</span>
<span class="fc" id="L86">    }</span>

    public static void copy(byte[] src, int srcPosition, ByteBuffer trg, int trgPosition, int length)
    {
<span class="fc" id="L90">        BestHolder.BEST.copy(src, srcPosition, trg, trgPosition, length);</span>
<span class="fc" id="L91">    }</span>

    public static void copy(ByteBuffer src, int srcPosition, ByteBuffer trg, int trgPosition, int length)
    {
<span class="fc" id="L95">        BestHolder.BEST.copy(src, srcPosition, trg, trgPosition, length);</span>
<span class="fc" id="L96">    }</span>

    public interface ByteOperations
    {
        abstract public int compare(byte[] buffer1, int offset1, int length1,
                                    byte[] buffer2, int offset2, int length2);

        abstract public int compare(ByteBuffer buffer1, byte[] buffer2, int offset2, int length2);

        abstract public int compare(ByteBuffer buffer1, int offset1, int length1, byte[] buffer2, int offset2, int length2);

        abstract public int compare(ByteBuffer buffer1, ByteBuffer buffer2);

        abstract public void copy(byte[] src, int srcPosition, byte[] trg, int trgPosition, int length);

        abstract public void copy(ByteBuffer src, int srcPosition, byte[] trg, int trgPosition, int length);

        abstract public void copy(byte[] src, int srcPosition, ByteBuffer trg, int trgPosition, int length);

        abstract public void copy(ByteBuffer src, int srcPosition, ByteBuffer trg, int trgPosition, int length);
    }

    /**
     * Provides a lexicographical comparer implementation; either a Java
     * implementation or a faster implementation based on {@link Unsafe}.
     * &lt;p/&gt;
     * &lt;p&gt;Uses reflection to gracefully fall back to the Java implementation if
     * {@code Unsafe} isn't available.
     */
    private static class BestHolder
    {
<span class="fc" id="L127">        static final String UNSAFE_COMPARER_NAME = FastByteOperations.class.getName() + &quot;$UnsafeOperations&quot;;</span>
<span class="fc" id="L128">        static final ByteOperations BEST = getBest();</span>

        /**
         * Returns the Unsafe-using Comparer, or falls back to the pure-Java
         * implementation if unable to do so.
         */
        static ByteOperations getBest()
        {
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">            if (!Architecture.IS_UNALIGNED)</span>
<span class="nc" id="L137">                return new PureJavaOperations();</span>
            try
            {
<span class="fc" id="L140">                Class&lt;?&gt; theClass = Class.forName(UNSAFE_COMPARER_NAME);</span>

                // yes, UnsafeComparer does implement Comparer&lt;byte[]&gt;
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L144">                ByteOperations comparer = (ByteOperations) theClass.getConstructor().newInstance();</span>
<span class="fc" id="L145">                return comparer;</span>
            }
<span class="nc" id="L147">            catch (Throwable t)</span>
            {
<span class="nc" id="L149">                JVMStabilityInspector.inspectThrowable(t);</span>
                // ensure we really catch *everything*
<span class="nc" id="L151">                return new PureJavaOperations();</span>
            }
        }

    }

    @SuppressWarnings(&quot;unused&quot;) // used via reflection
<span class="fc" id="L158">    public static final class UnsafeOperations implements ByteOperations</span>
    {
        static final Unsafe theUnsafe;
        /**
         * The offset to the first element in a byte array.
         */
        static final long BYTE_ARRAY_BASE_OFFSET;
        static final long DIRECT_BUFFER_ADDRESS_OFFSET;

        static
        {
<span class="fc" id="L169">            theUnsafe = (Unsafe) AccessController.doPrivileged(</span>
                      new PrivilegedAction&lt;Object&gt;()
<span class="fc" id="L171">                      {</span>
                          @Override
                          public Object run()
                          {
                              try
                              {
<span class="fc" id="L177">                                  Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span>
<span class="fc" id="L178">                                  f.setAccessible(true);</span>
<span class="fc" id="L179">                                  return f.get(null);</span>
                              }
<span class="nc" id="L181">                              catch (NoSuchFieldException e)</span>
                              {
                                  // It doesn't matter what we throw;
                                  // it's swallowed in getBest().
<span class="nc" id="L185">                                  throw new Error();</span>
                              }
<span class="nc" id="L187">                              catch (IllegalAccessException e)</span>
                              {
<span class="nc" id="L189">                                  throw new Error();</span>
                              }
                          }
                      });

            try
            {
<span class="fc" id="L196">                BYTE_ARRAY_BASE_OFFSET = theUnsafe.arrayBaseOffset(byte[].class);</span>
<span class="fc" id="L197">                DIRECT_BUFFER_ADDRESS_OFFSET = theUnsafe.objectFieldOffset(Buffer.class.getDeclaredField(&quot;address&quot;));</span>
            }
<span class="nc" id="L199">            catch (Exception e)</span>
            {
<span class="nc" id="L201">                throw new AssertionError(e);</span>
<span class="fc" id="L202">            }</span>

            // sanity check - this should never fail
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">            if (theUnsafe.arrayIndexScale(byte[].class) != 1)</span>
            {
<span class="nc" id="L207">                throw new AssertionError();</span>
            }
        }

<span class="fc" id="L211">        static final boolean BIG_ENDIAN = ByteOrder.nativeOrder().equals(ByteOrder.BIG_ENDIAN);</span>

        public int compare(byte[] buffer1, int offset1, int length1, byte[] buffer2, int offset2, int length2)
        {
<span class="fc" id="L215">            return compareTo(buffer1, BYTE_ARRAY_BASE_OFFSET + offset1, length1,</span>
                             buffer2, BYTE_ARRAY_BASE_OFFSET + offset2, length2);
        }

        public int compare(ByteBuffer buffer1, byte[] buffer2, int offset2, int length2)
        {
<span class="fc" id="L221">            return compare(buffer1, buffer1.position(), buffer1.remaining(), buffer2, offset2, length2);</span>
        }

        public int compare(ByteBuffer buffer1, int position1, int length1, byte[] buffer2, int offset2, int length2)
        {
            Object obj1;
            long offset1;
<span class="fc bfc" id="L228" title="All 2 branches covered.">            if (buffer1.hasArray())</span>
            {
<span class="fc" id="L230">                obj1 = buffer1.array();</span>
<span class="fc" id="L231">                offset1 = BYTE_ARRAY_BASE_OFFSET + buffer1.arrayOffset() + position1;</span>
            }
            else
            {
<span class="fc" id="L235">                obj1 = null;</span>
<span class="fc" id="L236">                offset1 = theUnsafe.getLong(buffer1, DIRECT_BUFFER_ADDRESS_OFFSET) + position1;</span>
            }

<span class="fc" id="L239">            return compareTo(obj1, offset1, length1, buffer2, BYTE_ARRAY_BASE_OFFSET + offset2, length2);</span>
        }

        public int compare(ByteBuffer buffer1, ByteBuffer buffer2)
        {
<span class="fc" id="L244">            return compareTo(buffer1, buffer2);</span>
        }

        public void copy(byte[] src, int srcPosition, byte[] trg, int trgPosition, int length)
        {
<span class="fc" id="L249">            System.arraycopy(src, srcPosition, trg, trgPosition, length);</span>
<span class="fc" id="L250">        }</span>

        public void copy(ByteBuffer src, int srcPosition, byte[] trg, int trgPosition, int length)
        {
<span class="fc bfc" id="L254" title="All 2 branches covered.">            if (src.hasArray())</span>
<span class="fc" id="L255">                System.arraycopy(src.array(), src.arrayOffset() + srcPosition, trg, trgPosition, length);</span>
            else
<span class="fc" id="L257">                copy(null, srcPosition + theUnsafe.getLong(src, DIRECT_BUFFER_ADDRESS_OFFSET), trg, trgPosition, length);</span>
<span class="fc" id="L258">        }</span>

        public void copy(byte[] src, int srcPosition, ByteBuffer trg, int trgPosition, int length)
        {
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">            if (trg.hasArray())</span>
<span class="fc" id="L263">                System.arraycopy(src, srcPosition, trg.array(), trg.arrayOffset() + trgPosition, length);</span>
            else
<span class="nc" id="L265">                copy(null, srcPosition + theUnsafe.getLong(src, Unsafe.ARRAY_BYTE_BASE_OFFSET), trg, trgPosition, length);</span>
<span class="fc" id="L266">        }</span>

        public void copy(ByteBuffer srcBuf, int srcPosition, ByteBuffer trgBuf, int trgPosition, int length)
        {
            Object src;
            long srcOffset;
<span class="fc bfc" id="L272" title="All 2 branches covered.">            if (srcBuf.hasArray())</span>
            {
<span class="fc" id="L274">                src = srcBuf.array();</span>
<span class="fc" id="L275">                srcOffset = BYTE_ARRAY_BASE_OFFSET + srcBuf.arrayOffset();</span>
            }
            else
            {
<span class="fc" id="L279">                src = null;</span>
<span class="fc" id="L280">                srcOffset = theUnsafe.getLong(srcBuf, DIRECT_BUFFER_ADDRESS_OFFSET);</span>
            }
<span class="fc" id="L282">            copy(src, srcOffset + srcPosition, trgBuf, trgPosition, length);</span>
<span class="fc" id="L283">        }</span>

        public static void copy(Object src, long srcOffset, ByteBuffer trgBuf, int trgPosition, int length)
        {
<span class="fc bfc" id="L287" title="All 2 branches covered.">            if (trgBuf.hasArray())</span>
<span class="fc" id="L288">                copy(src, srcOffset, trgBuf.array(), trgBuf.arrayOffset() + trgPosition, length);</span>
            else
<span class="fc" id="L290">                copy(src, srcOffset, null, trgPosition + theUnsafe.getLong(trgBuf, DIRECT_BUFFER_ADDRESS_OFFSET), length);</span>
<span class="fc" id="L291">        }</span>

        public static void copy(Object src, long srcOffset, byte[] trg, int trgPosition, int length)
        {
<span class="fc bfc" id="L295" title="All 2 branches covered.">            if (length &lt;= MIN_COPY_THRESHOLD)</span>
            {
<span class="fc bfc" id="L297" title="All 2 branches covered.">                for (int i = 0 ; i &lt; length ; i++)</span>
<span class="fc" id="L298">                    trg[trgPosition + i] = theUnsafe.getByte(src, srcOffset + i);</span>
            }
            else
            {
<span class="fc" id="L302">                copy(src, srcOffset, trg, BYTE_ARRAY_BASE_OFFSET + trgPosition, length);</span>
            }
<span class="fc" id="L304">        }</span>

        // 1M, copied from java.nio.Bits (unfortunately a package-private class)
        private static final long UNSAFE_COPY_THRESHOLD = 1 &lt;&lt; 20;
        private static final long MIN_COPY_THRESHOLD = 6;

        public static void copy(Object src, long srcOffset, Object dst, long dstOffset, long length)
        {
<span class="fc bfc" id="L312" title="All 2 branches covered.">            while (length &gt; 0)</span>
            {
<span class="fc bfc" id="L314" title="All 2 branches covered.">                long size = (length &gt; UNSAFE_COPY_THRESHOLD) ? UNSAFE_COPY_THRESHOLD : length;</span>
                // if src or dst are null, the offsets are absolute base addresses:
<span class="fc" id="L316">                theUnsafe.copyMemory(src, srcOffset, dst, dstOffset, size);</span>
<span class="fc" id="L317">                length -= size;</span>
<span class="fc" id="L318">                srcOffset += size;</span>
<span class="fc" id="L319">                dstOffset += size;</span>
<span class="fc" id="L320">            }</span>
<span class="fc" id="L321">        }</span>

        @Inline
        public static int compareTo(ByteBuffer buffer1, ByteBuffer buffer2)
        {
            Object obj1;
            long offset1;
            int length1;
<span class="fc bfc" id="L329" title="All 2 branches covered.">            if (buffer1.hasArray())</span>
            {
<span class="fc" id="L331">                obj1 = buffer1.array();</span>
<span class="fc" id="L332">                offset1 = BYTE_ARRAY_BASE_OFFSET + buffer1.arrayOffset();</span>
            }
            else
            {
<span class="fc" id="L336">                obj1 = null;</span>
<span class="fc" id="L337">                offset1 = theUnsafe.getLong(buffer1, DIRECT_BUFFER_ADDRESS_OFFSET);</span>
            }
<span class="fc" id="L339">            offset1 += buffer1.position();</span>
<span class="fc" id="L340">            length1 = buffer1.remaining();</span>
<span class="fc" id="L341">            return compareTo(obj1, offset1, length1, buffer2);</span>
        }

        @Inline
        public static int compareTo(Object buffer1, long offset1, int length1, ByteBuffer buffer)
        {
            Object obj2;
            long offset2;

<span class="fc" id="L350">            int position = buffer.position();</span>
<span class="fc" id="L351">            int limit = buffer.limit();</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">            if (buffer.hasArray())</span>
            {
<span class="fc" id="L354">                obj2 = buffer.array();</span>
<span class="fc" id="L355">                offset2 = BYTE_ARRAY_BASE_OFFSET + buffer.arrayOffset();</span>
            }
            else
            {
<span class="fc" id="L359">                obj2 = null;</span>
<span class="fc" id="L360">                offset2 = theUnsafe.getLong(buffer, DIRECT_BUFFER_ADDRESS_OFFSET);</span>
            }
<span class="fc" id="L362">            int length2 = limit - position;</span>
<span class="fc" id="L363">            offset2 += position;</span>

<span class="fc" id="L365">            return compareTo(buffer1, offset1, length1, obj2, offset2, length2);</span>
        }

        /**
         * Lexicographically compare two arrays.
         *
         * @param buffer1 left operand: a byte[] or null
         * @param buffer2 right operand: a byte[] or null
         * @param memoryOffset1 Where to start comparing in the left buffer (pure memory address if buffer1 is null, or relative otherwise)
         * @param memoryOffset2 Where to start comparing in the right buffer (pure memory address if buffer1 is null, or relative otherwise)
         * @param length1 How much to compare from the left buffer
         * @param length2 How much to compare from the right buffer
         * @return 0 if equal, {@code &lt; 0} if left is less than right, etc.
         */
        @Inline
        public static int compareTo(Object buffer1, long memoryOffset1, int length1,
                             Object buffer2, long memoryOffset2, int length2)
        {
<span class="fc" id="L383">            int minLength = Math.min(length1, length2);</span>

            /*
             * Compare 8 bytes at a time. Benchmarking shows comparing 8 bytes at a
             * time is no slower than comparing 4 bytes at a time even on 32-bit.
             * On the other hand, it is substantially faster on 64-bit.
             */
<span class="fc" id="L390">            int wordComparisons = minLength &amp; ~7;</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">            for (int i = 0; i &lt; wordComparisons ; i += Longs.BYTES)</span>
            {
<span class="fc" id="L393">                long lw = theUnsafe.getLong(buffer1, memoryOffset1 + i);</span>
<span class="fc" id="L394">                long rw = theUnsafe.getLong(buffer2, memoryOffset2 + i);</span>

<span class="fc bfc" id="L396" title="All 2 branches covered.">                if (lw != rw)</span>
                {
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">                    if (BIG_ENDIAN)</span>
<span class="nc" id="L399">                        return UnsignedLongs.compare(lw, rw);</span>

<span class="fc" id="L401">                    return UnsignedLongs.compare(Long.reverseBytes(lw), Long.reverseBytes(rw));</span>
                }
            }

<span class="fc bfc" id="L405" title="All 2 branches covered.">            for (int i = wordComparisons ; i &lt; minLength ; i++)</span>
            {
<span class="fc" id="L407">                int b1 = theUnsafe.getByte(buffer1, memoryOffset1 + i) &amp; 0xFF;</span>
<span class="fc" id="L408">                int b2 = theUnsafe.getByte(buffer2, memoryOffset2 + i) &amp; 0xFF;</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">                if (b1 != b2)</span>
<span class="fc" id="L410">                    return b1 - b2;</span>
            }

<span class="fc" id="L413">            return length1 - length2;</span>
        }

    }

    @SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L419">    public static final class PureJavaOperations implements ByteOperations</span>
    {
        @Override
        public int compare(byte[] buffer1, int offset1, int length1,
                           byte[] buffer2, int offset2, int length2)
        {
            // Short circuit equal case
<span class="pc bpc" id="L426" title="5 of 6 branches missed.">            if (buffer1 == buffer2 &amp;&amp; offset1 == offset2 &amp;&amp; length1 == length2)</span>
<span class="nc" id="L427">                return 0;</span>

<span class="fc" id="L429">            int end1 = offset1 + length1;</span>
<span class="fc" id="L430">            int end2 = offset2 + length2;</span>
<span class="fc bfc" id="L431" title="All 4 branches covered.">            for (int i = offset1, j = offset2; i &lt; end1 &amp;&amp; j &lt; end2; i++, j++)</span>
            {
<span class="fc" id="L433">                int a = (buffer1[i] &amp; 0xff);</span>
<span class="fc" id="L434">                int b = (buffer2[j] &amp; 0xff);</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">                if (a != b)</span>
                {
<span class="fc" id="L437">                    return a - b;</span>
                }
            }
<span class="fc" id="L440">            return length1 - length2;</span>
        }

        public int compare(ByteBuffer buffer1, int position1, int length1, byte[] buffer2, int offset2, int length2)
        {
<span class="nc bnc" id="L445" title="All 2 branches missed.">            if (buffer1.hasArray())</span>
<span class="nc" id="L446">                return compare(buffer1.array(), buffer1.arrayOffset() + position1, length1, buffer2, offset2, length2);</span>

<span class="nc bnc" id="L448" title="All 2 branches missed.">            if (position1 != buffer1.position())</span>
            {
<span class="nc" id="L450">                buffer1 = buffer1.duplicate();</span>
<span class="nc" id="L451">                buffer1.position(position1);</span>
            }

<span class="nc" id="L454">            return compare(buffer1, ByteBuffer.wrap(buffer2, offset2, length2));</span>
        }

        public int compare(ByteBuffer buffer1, byte[] buffer2, int offset2, int length2)
        {
<span class="fc bfc" id="L459" title="All 2 branches covered.">            if (buffer1.hasArray())</span>
            {
<span class="fc" id="L461">                return compare(buffer1.array(), buffer1.arrayOffset() + buffer1.position(), buffer1.remaining(),</span>
                               buffer2, offset2, length2);
            }

<span class="fc" id="L465">            return compare(buffer1, ByteBuffer.wrap(buffer2, offset2, length2));</span>
        }

        public int compare(ByteBuffer buffer1, ByteBuffer buffer2)
        {
<span class="fc" id="L470">            int end1 = buffer1.limit();</span>
<span class="fc" id="L471">            int end2 = buffer2.limit();</span>
<span class="pc bpc" id="L472" title="2 of 4 branches missed.">            for (int i = buffer1.position(), j = buffer2.position(); i &lt; end1 &amp;&amp; j &lt; end2; i++, j++)</span>
            {
<span class="fc" id="L474">                int a = (buffer1.get(i) &amp; 0xff);</span>
<span class="fc" id="L475">                int b = (buffer2.get(j) &amp; 0xff);</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">                if (a != b)</span>
                {
<span class="fc" id="L478">                    return a - b;</span>
                }
            }
<span class="nc" id="L481">            return buffer1.remaining() - buffer2.remaining();</span>
        }

        public void copy(byte[] src, int srcPosition, byte[] trg, int trgPosition, int length)
        {
<span class="nc" id="L486">            System.arraycopy(src, srcPosition, trg, trgPosition, length);</span>
<span class="nc" id="L487">        }</span>

        public void copy(ByteBuffer src, int srcPosition, byte[] trg, int trgPosition, int length)
        {
<span class="fc bfc" id="L491" title="All 2 branches covered.">            if (src.hasArray())</span>
            {
<span class="fc" id="L493">                System.arraycopy(src.array(), src.arrayOffset() + srcPosition, trg, trgPosition, length);</span>
<span class="fc" id="L494">                return;</span>
            }
<span class="fc" id="L496">            src = src.duplicate();</span>
<span class="fc" id="L497">            src.position(srcPosition);</span>
<span class="fc" id="L498">            src.get(trg, trgPosition, length);</span>
<span class="fc" id="L499">        }</span>

        public void copy(byte[] src, int srcPosition, ByteBuffer trg, int trgPosition, int length)
        {
<span class="nc bnc" id="L503" title="All 2 branches missed.">            if (trg.hasArray())</span>
            {
<span class="nc" id="L505">                System.arraycopy(src, srcPosition, trg.array(), trg.arrayOffset() + trgPosition, length);</span>
<span class="nc" id="L506">                return;</span>
            }
<span class="nc" id="L508">            trg.duplicate().put(src, srcPosition, length);</span>
<span class="nc" id="L509">        }</span>

        public void copy(ByteBuffer src, int srcPosition, ByteBuffer trg, int trgPosition, int length)
        {
<span class="fc bfc" id="L513" title="All 4 branches covered.">            if (src.hasArray() &amp;&amp; trg.hasArray())</span>
            {
<span class="fc" id="L515">                System.arraycopy(src.array(), src.arrayOffset() + srcPosition, trg.array(), trg.arrayOffset() + trgPosition, length);</span>
<span class="fc" id="L516">                return;</span>
            }
<span class="fc" id="L518">            src = src.duplicate();</span>
<span class="fc" id="L519">            src.position(srcPosition).limit(srcPosition + length);</span>
<span class="fc" id="L520">            trg = trg.duplicate();</span>
<span class="fc" id="L521">            trg.position(trgPosition);</span>
<span class="fc" id="L522">            trg.put(src);</span>
<span class="fc" id="L523">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>