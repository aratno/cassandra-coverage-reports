<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LongTimSort.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.utils</a> &gt; <span class="el_source">LongTimSort.java</span></div><h1>LongTimSort.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * This file originates from https://android.googlesource.com/platform/libcore/+/gingerbread/luni/src/main/java/java/util/TimSort.java
 * and has been modified to sort primitive long arrays instead of object arrays.
 */
//package java.util;

package org.apache.cassandra.utils;

import java.util.Arrays;

/**
 * A stable, adaptive, iterative mergesort that requires far fewer than
 * n lg(n) comparisons when running on partially sorted arrays, while
 * offering performance comparable to a traditional mergesort when run
 * on random arrays.  Like all proper mergesorts, this sort is stable and
 * runs O(n log n) time (worst case).  In the worst case, this sort requires
 * temporary storage space for n/2 object references; in the best case,
 * it requires only a small constant amount of space.
 *
 * This implementation was adapted from Tim Peters's list sort for
 * Python, which is described in detail here:
 *
 *   http://svn.python.org/projects/python/trunk/Objects/listsort.txt
 *
 * Tim's C code may be found here:
 *
 *   http://svn.python.org/projects/python/trunk/Objects/listobject.c
 *
 * The underlying techniques are described in this paper (and may have
 * even earlier origins):
 *
 *  &quot;Optimistic Sorting and Information Theoretic Complexity&quot;
 *  Peter McIlroy
 *  SODA (Fourth Annual ACM-SIAM Symposium on Discrete Algorithms),
 *  pp 467-474, Austin, Texas, 25-27 January 1993.
 *
 * While the API to this class consists solely of static methods, it is
 * (privately) instantiable; a TimSort instance holds the state of an ongoing
 * sort, assuming the input array is large enough to warrant the full-blown
 * TimSort. Small arrays are sorted in place, using a binary insertion sort.
 */
public final class LongTimSort {
    /**
     * This is the minimum sized sequence that will be merged.  Shorter
     * sequences will be lengthened by calling binarySort.  If the entire
     * array is less than this length, no merges will be performed.
     *
     * This constant should be a power of two.  It was 64 in Tim Peter's C
     * implementation, but 32 was empirically determined to work better in
     * this implementation.  In the unlikely event that you set this constant
     * to be a number that's not a power of two, you'll need to change the
     * {@link #minRunLength} computation.
     *
     * If you decrease this constant, you must change the stackLen
     * computation in the TimSort constructor, or you risk an
     * ArrayOutOfBounds exception.  See listsort.txt for a discussion
     * of the minimum stack length required as a function of the length
     * of the array being sorted and the minimum merge sequence length.
     */
    private static final int MIN_MERGE = 32;
    /**
     * The array being sorted.
     */
    private final long[] a;
    /**
     * The comparator for this sort.
     */
    private final LongComparator c;
    /**
     * When we get into galloping mode, we stay there until both runs win less
     * often than MIN_GALLOP consecutive times.
     */
    private static final int  MIN_GALLOP = 7;
    /**
     * This controls when we get *into* galloping mode.  It is initialized
     * to MIN_GALLOP.  The mergeLo and mergeHi methods nudge it higher for
     * random data, and lower for highly structured data.
     */
<span class="fc" id="L94">    private int minGallop = MIN_GALLOP;</span>
    /**
     * Maximum initial size of tmp array, which is used for merging.  The array
     * can grow to accommodate demand.
     *
     * Unlike Tim's original C version, we do not allocate this much storage
     * when sorting smaller arrays.  This change was required for performance.
     */
    private static final int INITIAL_TMP_STORAGE_LENGTH = 256;
    /**
     * Temp storage for merges.
     */
    private long[] tmp;
    /**
     * A stack of pending runs yet to be merged.  Run i starts at
     * address base[i] and extends for len[i] elements.  It's always
     * true (so long as the indices are in bounds) that:
     *
     *     runBase[i] + runLen[i] == runBase[i + 1]
     *
     * so we could cut the storage for this, but it's a minor amount,
     * and keeping all the info explicit simplifies the code.
     */
<span class="fc" id="L117">    private int stackSize = 0;  // Number of pending runs on stack</span>
    private final int[] runBase;
    private final int[] runLen;
    /**
     * Asserts have been placed in if-statements for performace. To enable them,
     * set this field to true and enable them in VM with a command line flag.
     * If you modify this class, please do test the asserts!
     */
    private static final boolean DEBUG = false;
    /**
     * Creates a TimSort instance to maintain the state of an ongoing sort.
     *
     * @param a the array to be sorted
     * @param c the comparator to determine the order of the sort
     */
<span class="fc" id="L132">    private LongTimSort(long[] a, LongComparator c) {</span>
<span class="fc" id="L133">        this.a = a;</span>
<span class="fc" id="L134">        this.c = c;</span>
        // Allocate temp storage (which may be increased later if necessary)
<span class="fc" id="L136">        int len = a.length;</span>
        @SuppressWarnings({&quot;unchecked&quot;, &quot;UnnecessaryLocalVariable&quot;})
<span class="fc bfc" id="L138" title="All 2 branches covered.">        long[] newArray = new long[len &lt; 2 * INITIAL_TMP_STORAGE_LENGTH ?</span>
<span class="fc" id="L139">                                   len &gt;&gt;&gt; 1 : INITIAL_TMP_STORAGE_LENGTH];</span>
<span class="fc" id="L140">        tmp = newArray;</span>
        /*
         * Allocate runs-to-be-merged stack (which cannot be expanded).  The
         * stack length requirements are described in listsort.txt.  The C
         * version always uses the same stack length (85), but this was
         * measured to be too expensive when sorting &quot;mid-sized&quot; arrays (e.g.,
         * 100 elements) in Java.  Therefore, we use smaller (but sufficiently
         * large) stack lengths for smaller arrays.  The &quot;magic numbers&quot; in the
         * computation below must be changed if MIN_MERGE is decreased.  See
         * the MIN_MERGE declaration above for more information.
         */
<span class="fc bfc" id="L151" title="All 2 branches covered.">        int stackLen = (len &lt;    120  ?  5 :</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">                        len &lt;   1542  ? 10 :</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">                        len &lt; 119151  ? 19 : 40);</span>
<span class="fc" id="L154">        runBase = new int[stackLen];</span>
<span class="fc" id="L155">        runLen = new int[stackLen];</span>
<span class="fc" id="L156">    }</span>
    /*
     * The next two methods (which are package private and static) constitute
     * the entire API of this class.  Each of these methods obeys the contract
     * of the public method with the same signature in java.util.Arrays.
     */
    public static void sort(long[] a, LongComparator c) {
<span class="fc" id="L163">        sort(a, 0, a.length, c);</span>
<span class="fc" id="L164">    }</span>
    public static void sort(long[] a, int lo, int hi, LongComparator c) {
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L167">            Arrays.sort(a, lo, hi);</span>
<span class="nc" id="L168">            return;</span>
        }
<span class="fc" id="L170">        rangeCheck(a.length, lo, hi);</span>
<span class="fc" id="L171">        int nRemaining  = hi - lo;</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">        if (nRemaining &lt; 2)</span>
<span class="fc" id="L173">            return;  // Arrays of size 0 and 1 are always sorted</span>
        // If array is small, do a &quot;mini-TimSort&quot; with no merges
<span class="fc bfc" id="L175" title="All 2 branches covered.">        if (nRemaining &lt; MIN_MERGE) {</span>
<span class="fc" id="L176">            int initRunLen = countRunAndMakeAscending(a, lo, hi, c);</span>
<span class="fc" id="L177">            binarySort(a, lo, hi, lo + initRunLen, c);</span>
<span class="fc" id="L178">            return;</span>
        }
        /**
         * March over the array once, left to right, finding natural runs,
         * extending short natural runs to minRun elements, and merging runs
         * to maintain stack invariant.
         */
<span class="fc" id="L185">        LongTimSort ts = new LongTimSort(a, c);</span>
<span class="fc" id="L186">        int minRun = minRunLength(nRemaining);</span>
        do {
            // Identify next run
<span class="fc" id="L189">            int runLen = countRunAndMakeAscending(a, lo, hi, c);</span>
            // If run is short, extend to min(minRun, nRemaining)
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">            if (runLen &lt; minRun) {</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">                int force = nRemaining &lt;= minRun ? nRemaining : minRun;</span>
<span class="fc" id="L193">                binarySort(a, lo, lo + force, lo + runLen, c);</span>
<span class="fc" id="L194">                runLen = force;</span>
            }
            // Push run onto pending-run stack, and maybe merge
<span class="fc" id="L197">            ts.pushRun(lo, runLen);</span>
<span class="fc" id="L198">            ts.mergeCollapse();</span>
            // Advance to find next run
<span class="fc" id="L200">            lo += runLen;</span>
<span class="fc" id="L201">            nRemaining -= runLen;</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">        } while (nRemaining != 0);</span>
        // Merge all remaining runs to complete sort
        if (DEBUG) assert lo == hi;
<span class="fc" id="L205">        ts.mergeForceCollapse();</span>
        if (DEBUG) assert ts.stackSize == 1;
<span class="fc" id="L207">    }</span>
    /**
     * Sorts the specified portion of the specified array using a binary
     * insertion sort.  This is the best method for sorting small numbers
     * of elements.  It requires O(n log n) compares, but O(n^2) data
     * movement (worst case).
     *
     * If the initial part of the specified range is already sorted,
     * this method can take advantage of it: the method assumes that the
     * elements from index {@code lo}, inclusive, to {@code start},
     * exclusive are already sorted.
     *
     * @param a the array in which a range is to be sorted
     * @param lo the index of the first element in the range to be sorted
     * @param hi the index after the last element in the range to be sorted
     * @param start the index of the first element in the range that is
     *        not already known to be sorted (@code lo &lt;= start &lt;= hi}
     * @param c comparator to used for the sort
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    private static void binarySort(long[] a, int lo, int hi, int start,
                                       LongComparator c) {
        if (DEBUG) assert lo &lt;= start &amp;&amp; start &lt;= hi;
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">        if (start == lo)</span>
<span class="nc" id="L231">            start++;</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">        for ( ; start &lt; hi; start++) {</span>
<span class="fc" id="L233">            long pivot = a[start];</span>
            // Set left (and right) to the index where a[start] (pivot) belongs
<span class="fc" id="L235">            int left = lo;</span>
<span class="fc" id="L236">            int right = start;</span>
            if (DEBUG) assert left &lt;= right;
            /*
             * Invariants:
             *   pivot &gt;= all in [lo, left).
             *   pivot &lt;  all in [right, start).
             */
<span class="fc bfc" id="L243" title="All 2 branches covered.">            while (left &lt; right) {</span>
<span class="fc" id="L244">                int mid = (left + right) &gt;&gt;&gt; 1;</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">                if (c.compare(pivot, a[mid]) &lt; 0)</span>
<span class="fc" id="L246">                    right = mid;</span>
                else
<span class="fc" id="L248">                    left = mid + 1;</span>
<span class="fc" id="L249">            }</span>
            if (DEBUG) assert left == right;
            /*
             * The invariants still hold: pivot &gt;= all in [lo, left) and
             * pivot &lt; all in [left, start), so pivot belongs at left.  Note
             * that if there are elements equal to pivot, left points to the
             * first slot after them -- that's why this sort is stable.
             * Slide elements over to make room to make room for pivot.
             */
<span class="fc" id="L258">            int n = start - left;  // The number of elements to move</span>
            // Switch is just an optimization for arraycopy in default case
<span class="fc bfc" id="L260" title="All 3 branches covered.">            switch(n) {</span>
<span class="fc" id="L261">                case 2:  a[left + 2] = a[left + 1];</span>
<span class="fc" id="L262">                case 1:  a[left + 1] = a[left];</span>
<span class="fc" id="L263">                    break;</span>
<span class="fc" id="L264">                default: System.arraycopy(a, left, a, left + 1, n);</span>
            }
<span class="fc" id="L266">            a[left] = pivot;</span>
        }
<span class="fc" id="L268">    }</span>
    /**
     * Returns the length of the run beginning at the specified position in
     * the specified array and reverses the run if it is descending (ensuring
     * that the run will always be ascending when the method returns).
     *
     * A run is the longest ascending sequence with:
     *
     *    a[lo] &lt;= a[lo + 1] &lt;= a[lo + 2] &lt;= ...
     *
     * or the longest descending sequence with:
     *
     *    a[lo] &gt;  a[lo + 1] &gt;  a[lo + 2] &gt;  ...
     *
     * For its intended use in a stable mergesort, the strictness of the
     * definition of &quot;descending&quot; is needed so that the call can safely
     * reverse a descending sequence without violating stability.
     *
     * @param a the array in which a run is to be counted and possibly reversed
     * @param lo index of the first element in the run
     * @param hi index after the last element that may be contained in the run.
    It is required that @code{lo &lt; hi}.
     * @param c the comparator to used for the sort
     * @return  the length of the run beginning at the specified position in
     *          the specified array
     */
    private static int countRunAndMakeAscending(long[] a, int lo, int hi,
                                                LongComparator c) {
        if (DEBUG) assert lo &lt; hi;
<span class="fc" id="L297">        int runHi = lo + 1;</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        if (runHi == hi)</span>
<span class="nc" id="L299">            return 1;</span>
        // Find end of run, and reverse range if descending
<span class="fc bfc" id="L301" title="All 2 branches covered.">        if (c.compare(a[runHi++], a[lo]) &lt; 0) { // Descending</span>
<span class="fc bfc" id="L302" title="All 4 branches covered.">            while(runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - 1]) &lt; 0)</span>
<span class="fc" id="L303">                runHi++;</span>
<span class="fc" id="L304">            reverseRange(a, lo, runHi);</span>
        } else {                              // Ascending
<span class="pc bpc" id="L306" title="1 of 4 branches missed.">            while (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - 1]) &gt;= 0)</span>
<span class="fc" id="L307">                runHi++;</span>
        }
<span class="fc" id="L309">        return runHi - lo;</span>
    }
    /**
     * Reverse the specified range of the specified array.
     *
     * @param a the array in which a range is to be reversed
     * @param lo the index of the first element in the range to be reversed
     * @param hi the index after the last element in the range to be reversed
     */
    private static void reverseRange(long[] a, int lo, int hi) {
<span class="fc" id="L319">        hi--;</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">        while (lo &lt; hi) {</span>
<span class="fc" id="L321">            long t = a[lo];</span>
<span class="fc" id="L322">            a[lo++] = a[hi];</span>
<span class="fc" id="L323">            a[hi--] = t;</span>
<span class="fc" id="L324">        }</span>
<span class="fc" id="L325">    }</span>
    /**
     * Returns the minimum acceptable run length for an array of the specified
     * length. Natural runs shorter than this will be extended with
     * {@link #binarySort}.
     *
     * Roughly speaking, the computation is:
     *
     *  If n &lt; MIN_MERGE, return n (it's too small to bother with fancy stuff).
     *  Else if n is an exact power of 2, return MIN_MERGE/2.
     *  Else return an int k, MIN_MERGE/2 &lt;= k &lt;= MIN_MERGE, such that n/k
     *   is close to, but strictly less than, an exact power of 2.
     *
     * For the rationale, see listsort.txt.
     *
     * @param n the length of the array to be sorted
     * @return the length of the minimum run to be merged
     */
    private static int minRunLength(int n) {
        if (DEBUG) assert n &gt;= 0;
<span class="fc" id="L345">        int r = 0;      // Becomes 1 if any 1 bits are shifted off</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">        while (n &gt;= MIN_MERGE) {</span>
<span class="fc" id="L347">            r |= (n &amp; 1);</span>
<span class="fc" id="L348">            n &gt;&gt;= 1;</span>
        }
<span class="fc" id="L350">        return n + r;</span>
    }
    /**
     * Pushes the specified run onto the pending-run stack.
     *
     * @param runBase index of the first element in the run
     * @param runLen  the number of elements in the run
     */
    private void pushRun(int runBase, int runLen) {
<span class="fc" id="L359">        this.runBase[stackSize] = runBase;</span>
<span class="fc" id="L360">        this.runLen[stackSize] = runLen;</span>
<span class="fc" id="L361">        stackSize++;</span>
<span class="fc" id="L362">    }</span>
    /**
     * Examines the stack of runs waiting to be merged and merges adjacent runs
     * until the stack invariants are reestablished:
     *
     *     1. runLen[i - 3] &gt; runLen[i - 2] + runLen[i - 1]
     *     2. runLen[i - 2] &gt; runLen[i - 1]
     *
     * This method is called each time a new run is pushed onto the stack,
     * so the invariants are guaranteed to hold for i &lt; stackSize upon
     * entry to the method.
     */
    private void mergeCollapse() {
<span class="fc bfc" id="L375" title="All 2 branches covered.">        while (stackSize &gt; 1) {</span>
<span class="fc" id="L376">            int n = stackSize - 2;</span>
<span class="fc bfc" id="L377" title="All 4 branches covered.">            if (n &gt; 0 &amp;&amp; runLen[n-1] &lt;= runLen[n] + runLen[n+1]) {</span>
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">                if (runLen[n - 1] &lt; runLen[n + 1])</span>
<span class="nc" id="L379">                    n--;</span>
<span class="fc" id="L380">                mergeAt(n);</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">            } else if (runLen[n] &lt;= runLen[n + 1]) {</span>
<span class="fc" id="L382">                mergeAt(n);</span>
            } else {
                break; // Invariant is established
            }
<span class="fc" id="L386">        }</span>
<span class="fc" id="L387">    }</span>
    /**
     * Merges all runs on the stack until only one remains.  This method is
     * called once, to complete the sort.
     */
    private void mergeForceCollapse() {
<span class="fc bfc" id="L393" title="All 2 branches covered.">        while (stackSize &gt; 1) {</span>
<span class="fc" id="L394">            int n = stackSize - 2;</span>
<span class="pc bpc" id="L395" title="1 of 4 branches missed.">            if (n &gt; 0 &amp;&amp; runLen[n - 1] &lt; runLen[n + 1])</span>
<span class="nc" id="L396">                n--;</span>
<span class="fc" id="L397">            mergeAt(n);</span>
<span class="fc" id="L398">        }</span>
<span class="fc" id="L399">    }</span>
    /**
     * Merges the two runs at stack indices i and i+1.  Run i must be
     * the penultimate or antepenultimate run on the stack.  In other words,
     * i must be equal to stackSize-2 or stackSize-3.
     *
     * @param i stack index of the first of the two runs to merge
     */
    private void mergeAt(int i) {
        if (DEBUG) assert stackSize &gt;= 2;
        if (DEBUG) assert i &gt;= 0;
        if (DEBUG) assert i == stackSize - 2 || i == stackSize - 3;
<span class="fc" id="L411">        int base1 = runBase[i];</span>
<span class="fc" id="L412">        int len1 = runLen[i];</span>
<span class="fc" id="L413">        int base2 = runBase[i + 1];</span>
<span class="fc" id="L414">        int len2 = runLen[i + 1];</span>
        if (DEBUG) assert len1 &gt; 0 &amp;&amp; len2 &gt; 0;
        if (DEBUG) assert base1 + len1 == base2;
        /*
         * Record the length of the combined runs; if i is the 3rd-last
         * run now, also slide over the last run (which isn't involved
         * in this merge).  The current run (i+1) goes away in any case.
         */
<span class="fc" id="L422">        runLen[i] = len1 + len2;</span>
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">        if (i == stackSize - 3) {</span>
<span class="nc" id="L424">            runBase[i + 1] = runBase[i + 2];</span>
<span class="nc" id="L425">            runLen[i + 1] = runLen[i + 2];</span>
        }
<span class="fc" id="L427">        stackSize--;</span>
        /*
         * Find where the first element of run2 goes in run1. Prior elements
         * in run1 can be ignored (because they're already in place).
         */
<span class="fc" id="L432">        int k = gallopRight(a[base2], a, base1, len1, 0, c);</span>
        if (DEBUG) assert k &gt;= 0;
<span class="fc" id="L434">        base1 += k;</span>
<span class="fc" id="L435">        len1 -= k;</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">        if (len1 == 0)</span>
<span class="nc" id="L437">            return;</span>
        /*
         * Find where the last element of run1 goes in run2. Subsequent elements
         * in run2 can be ignored (because they're already in place).
         */
<span class="fc" id="L442">        len2 = gallopLeft(a[base1 + len1 - 1], a, base2, len2, len2 - 1, c);</span>
        if (DEBUG) assert len2 &gt;= 0;
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">        if (len2 == 0)</span>
<span class="nc" id="L445">            return;</span>
        // Merge remaining runs, using tmp array with min(len1, len2) elements
<span class="fc bfc" id="L447" title="All 2 branches covered.">        if (len1 &lt;= len2)</span>
<span class="fc" id="L448">            mergeLo(base1, len1, base2, len2);</span>
        else
<span class="fc" id="L450">            mergeHi(base1, len1, base2, len2);</span>
<span class="fc" id="L451">    }</span>
    /**
     * Locates the position at which to insert the specified key into the
     * specified sorted range; if the range contains an element equal to key,
     * returns the index of the leftmost equal element.
     *
     * @param key the key whose insertion point to search for
     * @param a the array in which to search
     * @param base the index of the first element in the range
     * @param len the length of the range; must be &gt; 0
     * @param hint the index at which to begin the search, 0 &lt;= hint &lt; n.
     *     The closer hint is to the result, the faster this method will run.
     * @param c the comparator used to order the range, and to search
     * @return the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k],
     *    pretending that a[b - 1] is minus infinity and a[b + n] is infinity.
     *    In other words, key belongs at index b + k; or in other words,
     *    the first k elements of a should precede key, and the last n - k
     *    should follow it.
     */
    private static int gallopLeft(long key, long[] a, int base, int len, int hint,
                                  LongComparator c) {
        if (DEBUG) assert len &gt; 0 &amp;&amp; hint &gt;= 0 &amp;&amp; hint &lt; len;
<span class="fc" id="L473">        int lastOfs = 0;</span>
<span class="fc" id="L474">        int ofs = 1;</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">        if (c.compare(key, a[base + hint]) &gt; 0) {</span>
            // Gallop right until a[base+hint+lastOfs] &lt; key &lt;= a[base+hint+ofs]
<span class="fc" id="L477">            int maxOfs = len - hint;</span>
<span class="fc bfc" id="L478" title="All 4 branches covered.">            while (ofs &lt; maxOfs &amp;&amp; c.compare(key, a[base + hint + ofs]) &gt; 0) {</span>
<span class="fc" id="L479">                lastOfs = ofs;</span>
<span class="fc" id="L480">                ofs = (ofs &lt;&lt; 1) + 1;</span>
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">                if (ofs &lt;= 0)   // int overflow</span>
<span class="nc" id="L482">                    ofs = maxOfs;</span>
            }
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">            if (ofs &gt; maxOfs)</span>
<span class="nc" id="L485">                ofs = maxOfs;</span>
            // Make offsets relative to base
<span class="fc" id="L487">            lastOfs += hint;</span>
<span class="fc" id="L488">            ofs += hint;</span>
<span class="fc" id="L489">        } else { // key &lt;= a[base + hint]</span>
            // Gallop left until a[base+hint-ofs] &lt; key &lt;= a[base+hint-lastOfs]
<span class="fc" id="L491">            final int maxOfs = hint + 1;</span>
<span class="fc bfc" id="L492" title="All 4 branches covered.">            while (ofs &lt; maxOfs &amp;&amp; c.compare(key, a[base + hint - ofs]) &lt;= 0) {</span>
<span class="fc" id="L493">                lastOfs = ofs;</span>
<span class="fc" id="L494">                ofs = (ofs &lt;&lt; 1) + 1;</span>
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">                if (ofs &lt;= 0)   // int overflow</span>
<span class="nc" id="L496">                    ofs = maxOfs;</span>
            }
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">            if (ofs &gt; maxOfs)</span>
<span class="nc" id="L499">                ofs = maxOfs;</span>
            // Make offsets relative to base
<span class="fc" id="L501">            int tmp = lastOfs;</span>
<span class="fc" id="L502">            lastOfs = hint - ofs;</span>
<span class="fc" id="L503">            ofs = hint - tmp;</span>
        }
        if (DEBUG) assert -1 &lt;= lastOfs &amp;&amp; lastOfs &lt; ofs &amp;&amp; ofs &lt;= len;
        /*
         * Now a[base+lastOfs] &lt; key &lt;= a[base+ofs], so key belongs somewhere
         * to the right of lastOfs but no farther right than ofs.  Do a binary
         * search, with invariant a[base + lastOfs - 1] &lt; key &lt;= a[base + ofs].
         */
<span class="fc" id="L511">        lastOfs++;</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">        while (lastOfs &lt; ofs) {</span>
<span class="fc" id="L513">            int m = lastOfs + ((ofs - lastOfs) &gt;&gt;&gt; 1);</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">            if (c.compare(key, a[base + m]) &gt; 0)</span>
<span class="fc" id="L515">                lastOfs = m + 1;  // a[base + m] &lt; key</span>
            else
<span class="fc" id="L517">                ofs = m;          // key &lt;= a[base + m]</span>
<span class="fc" id="L518">        }</span>
        if (DEBUG) assert lastOfs == ofs;    // so a[base + ofs - 1] &lt; key &lt;= a[base + ofs]
<span class="fc" id="L520">        return ofs;</span>
    }
    /**
     * Like gallopLeft, except that if the range contains an element equal to
     * key, gallopRight returns the index after the rightmost equal element.
     *
     * @param key the key whose insertion point to search for
     * @param a the array in which to search
     * @param base the index of the first element in the range
     * @param len the length of the range; must be &gt; 0
     * @param hint the index at which to begin the search, 0 &lt;= hint &lt; n.
     *     The closer hint is to the result, the faster this method will run.
     * @param c the comparator used to order the range, and to search
     * @return the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]
     */
    private static int gallopRight(long key, long[] a, int base, int len,
                                       int hint, LongComparator c) {
        if (DEBUG) assert len &gt; 0 &amp;&amp; hint &gt;= 0 &amp;&amp; hint &lt; len;
<span class="fc" id="L538">        int ofs = 1;</span>
<span class="fc" id="L539">        int lastOfs = 0;</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">        if (c.compare(key, a[base + hint]) &lt; 0) {</span>
            // Gallop left until a[b+hint - ofs] &lt;= key &lt; a[b+hint - lastOfs]
<span class="fc" id="L542">            int maxOfs = hint + 1;</span>
<span class="fc bfc" id="L543" title="All 4 branches covered.">            while (ofs &lt; maxOfs &amp;&amp; c.compare(key, a[base + hint - ofs]) &lt; 0) {</span>
<span class="fc" id="L544">                lastOfs = ofs;</span>
<span class="fc" id="L545">                ofs = (ofs &lt;&lt; 1) + 1;</span>
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">                if (ofs &lt;= 0)   // int overflow</span>
<span class="nc" id="L547">                    ofs = maxOfs;</span>
            }
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">            if (ofs &gt; maxOfs)</span>
<span class="nc" id="L550">                ofs = maxOfs;</span>
            // Make offsets relative to b
<span class="fc" id="L552">            int tmp = lastOfs;</span>
<span class="fc" id="L553">            lastOfs = hint - ofs;</span>
<span class="fc" id="L554">            ofs = hint - tmp;</span>
<span class="fc" id="L555">        } else { // a[b + hint] &lt;= key</span>
            // Gallop right until a[b+hint + lastOfs] &lt;= key &lt; a[b+hint + ofs]
<span class="fc" id="L557">            int maxOfs = len - hint;</span>
<span class="fc bfc" id="L558" title="All 4 branches covered.">            while (ofs &lt; maxOfs &amp;&amp; c.compare(key, a[base + hint + ofs]) &gt;= 0) {</span>
<span class="fc" id="L559">                lastOfs = ofs;</span>
<span class="fc" id="L560">                ofs = (ofs &lt;&lt; 1) + 1;</span>
<span class="pc bpc" id="L561" title="1 of 2 branches missed.">                if (ofs &lt;= 0)   // int overflow</span>
<span class="nc" id="L562">                    ofs = maxOfs;</span>
            }
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">            if (ofs &gt; maxOfs)</span>
<span class="nc" id="L565">                ofs = maxOfs;</span>
            // Make offsets relative to b
<span class="fc" id="L567">            lastOfs += hint;</span>
<span class="fc" id="L568">            ofs += hint;</span>
        }
        if (DEBUG) assert -1 &lt;= lastOfs &amp;&amp; lastOfs &lt; ofs &amp;&amp; ofs &lt;= len;
        /*
         * Now a[b + lastOfs] &lt;= key &lt; a[b + ofs], so key belongs somewhere to
         * the right of lastOfs but no farther right than ofs.  Do a binary
         * search, with invariant a[b + lastOfs - 1] &lt;= key &lt; a[b + ofs].
         */
<span class="fc" id="L576">        lastOfs++;</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">        while (lastOfs &lt; ofs) {</span>
<span class="fc" id="L578">            int m = lastOfs + ((ofs - lastOfs) &gt;&gt;&gt; 1);</span>
<span class="fc bfc" id="L579" title="All 2 branches covered.">            if (c.compare(key, a[base + m]) &lt; 0)</span>
<span class="fc" id="L580">                ofs = m;          // key &lt; a[b + m]</span>
            else
<span class="fc" id="L582">                lastOfs = m + 1;  // a[b + m] &lt;= key</span>
<span class="fc" id="L583">        }</span>
        if (DEBUG) assert lastOfs == ofs;    // so a[b + ofs - 1] &lt;= key &lt; a[b + ofs]
<span class="fc" id="L585">        return ofs;</span>
    }
    /**
     * Merges two adjacent runs in place, in a stable fashion.  The first
     * element of the first run must be greater than the first element of the
     * second run (a[base1] &gt; a[base2]), and the last element of the first run
     * (a[base1 + len1-1]) must be greater than all elements of the second run.
     *
     * For performance, this method should be called only when len1 &lt;= len2;
     * its twin, mergeHi should be called if len1 &gt;= len2.  (Either method
     * may be called if len1 == len2.)
     *
     * @param base1 index of first element in first run to be merged
     * @param len1  length of first run to be merged (must be &gt; 0)
     * @param base2 index of first element in second run to be merged
     *        (must be aBase + aLen)
     * @param len2  length of second run to be merged (must be &gt; 0)
     */
    private void mergeLo(int base1, int len1, int base2, int len2) {
        if (DEBUG) assert len1 &gt; 0 &amp;&amp; len2 &gt; 0 &amp;&amp; base1 + len1 == base2;
        // Copy first run into temp array
<span class="fc" id="L606">        long[] a = this.a; // For performance</span>
<span class="fc" id="L607">        long[] tmp = ensureCapacity(len1);</span>
<span class="fc" id="L608">        System.arraycopy(a, base1, tmp, 0, len1);</span>
<span class="fc" id="L609">        int cursor1 = 0;       // Indexes into tmp array</span>
<span class="fc" id="L610">        int cursor2 = base2;   // Indexes int a</span>
<span class="fc" id="L611">        int dest = base1;      // Indexes int a</span>
        // Move first element of second run and deal with degenerate cases
<span class="fc" id="L613">        a[dest++] = a[cursor2++];</span>
<span class="pc bpc" id="L614" title="1 of 2 branches missed.">        if (--len2 == 0) {</span>
<span class="nc" id="L615">            System.arraycopy(tmp, cursor1, a, dest, len1);</span>
<span class="nc" id="L616">            return;</span>
        }
<span class="pc bpc" id="L618" title="1 of 2 branches missed.">        if (len1 == 1) {</span>
<span class="nc" id="L619">            System.arraycopy(a, cursor2, a, dest, len2);</span>
<span class="nc" id="L620">            a[dest + len2] = tmp[cursor1]; // Last elt of run 1 to end of merge</span>
<span class="nc" id="L621">            return;</span>
        }
<span class="fc" id="L623">        LongComparator c = this.c;  // Use local variable for performance</span>
<span class="fc" id="L624">        int minGallop = this.minGallop;    //  &quot;    &quot;       &quot;     &quot;      &quot;</span>
        outer:
        while (true) {
<span class="fc" id="L627">            int count1 = 0; // Number of times in a row that first run won</span>
<span class="fc" id="L628">            int count2 = 0; // Number of times in a row that second run won</span>
            /*
             * Do the straightforward thing until (if ever) one run starts
             * winning consistently.
             */
            do {
                if (DEBUG) assert len1 &gt; 1 &amp;&amp; len2 &gt; 0;
<span class="fc bfc" id="L635" title="All 2 branches covered.">                if (c.compare(a[cursor2], tmp[cursor1]) &lt; 0) {</span>
<span class="fc" id="L636">                    a[dest++] = a[cursor2++];</span>
<span class="fc" id="L637">                    count2++;</span>
<span class="fc" id="L638">                    count1 = 0;</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">                    if (--len2 == 0)</span>
<span class="fc" id="L640">                        break outer;</span>
                } else {
<span class="fc" id="L642">                    a[dest++] = tmp[cursor1++];</span>
<span class="fc" id="L643">                    count1++;</span>
<span class="fc" id="L644">                    count2 = 0;</span>
<span class="fc bfc" id="L645" title="All 2 branches covered.">                    if (--len1 == 1)</span>
<span class="fc" id="L646">                        break outer;</span>
                }
<span class="fc bfc" id="L648" title="All 2 branches covered.">            } while ((count1 | count2) &lt; minGallop);</span>
            /*
             * One run is winning so consistently that galloping may be a
             * huge win. So try that, and continue galloping until (if ever)
             * neither run appears to be winning consistently anymore.
             */
            do {
                if (DEBUG) assert len1 &gt; 1 &amp;&amp; len2 &gt; 0;
<span class="fc" id="L656">                count1 = gallopRight(a[cursor2], tmp, cursor1, len1, 0, c);</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">                if (count1 != 0) {</span>
<span class="fc" id="L658">                    System.arraycopy(tmp, cursor1, a, dest, count1);</span>
<span class="fc" id="L659">                    dest += count1;</span>
<span class="fc" id="L660">                    cursor1 += count1;</span>
<span class="fc" id="L661">                    len1 -= count1;</span>
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">                    if (len1 &lt;= 1) // len1 == 1 || len1 == 0</span>
<span class="nc" id="L663">                        break outer;</span>
                }
<span class="fc" id="L665">                a[dest++] = a[cursor2++];</span>
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">                if (--len2 == 0)</span>
<span class="nc" id="L667">                    break outer;</span>
<span class="fc" id="L668">                count2 = gallopLeft(tmp[cursor1], a, cursor2, len2, 0, c);</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">                if (count2 != 0) {</span>
<span class="fc" id="L670">                    System.arraycopy(a, cursor2, a, dest, count2);</span>
<span class="fc" id="L671">                    dest += count2;</span>
<span class="fc" id="L672">                    cursor2 += count2;</span>
<span class="fc" id="L673">                    len2 -= count2;</span>
<span class="pc bpc" id="L674" title="1 of 2 branches missed.">                    if (len2 == 0)</span>
<span class="nc" id="L675">                        break outer;</span>
                }
<span class="fc" id="L677">                a[dest++] = tmp[cursor1++];</span>
<span class="pc bpc" id="L678" title="1 of 2 branches missed.">                if (--len1 == 1)</span>
<span class="nc" id="L679">                    break outer;</span>
<span class="fc" id="L680">                minGallop--;</span>
<span class="fc bfc" id="L681" title="All 6 branches covered.">            } while (count1 &gt;= MIN_GALLOP | count2 &gt;= MIN_GALLOP);</span>
<span class="pc bpc" id="L682" title="1 of 2 branches missed.">            if (minGallop &lt; 0)</span>
<span class="nc" id="L683">                minGallop = 0;</span>
<span class="fc" id="L684">            minGallop += 2;  // Penalize for leaving gallop mode</span>
<span class="fc" id="L685">        }  // End of &quot;outer&quot; loop</span>
<span class="pc bpc" id="L686" title="1 of 2 branches missed.">        this.minGallop = minGallop &lt; 1 ? 1 : minGallop;  // Write back to field</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">        if (len1 == 1) {</span>
            if (DEBUG) assert len2 &gt; 0;
<span class="fc" id="L689">            System.arraycopy(a, cursor2, a, dest, len2);</span>
<span class="fc" id="L690">            a[dest + len2] = tmp[cursor1]; //  Last elt of run 1 to end of merge</span>
<span class="pc bpc" id="L691" title="1 of 2 branches missed.">        } else if (len1 == 0) {</span>
<span class="nc" id="L692">            throw new IllegalArgumentException(</span>
                                              &quot;Comparison method violates its general contract!&quot;);
        } else {
            if (DEBUG) assert len2 == 0;
            if (DEBUG) assert len1 &gt; 1;
<span class="fc" id="L697">            System.arraycopy(tmp, cursor1, a, dest, len1);</span>
        }
<span class="fc" id="L699">    }</span>
    /**
     * Like mergeLo, except that this method should be called only if
     * len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2.  (Either method
     * may be called if len1 == len2.)
     *
     * @param base1 index of first element in first run to be merged
     * @param len1  length of first run to be merged (must be &gt; 0)
     * @param base2 index of first element in second run to be merged
     *        (must be aBase + aLen)
     * @param len2  length of second run to be merged (must be &gt; 0)
     */
    private void mergeHi(int base1, int len1, int base2, int len2) {
        if (DEBUG) assert len1 &gt; 0 &amp;&amp; len2 &gt; 0 &amp;&amp; base1 + len1 == base2;
        // Copy second run into temp array
<span class="fc" id="L714">        long[] a = this.a; // For performance</span>
<span class="fc" id="L715">        long[] tmp = ensureCapacity(len2);</span>
<span class="fc" id="L716">        System.arraycopy(a, base2, tmp, 0, len2);</span>
<span class="fc" id="L717">        int cursor1 = base1 + len1 - 1;  // Indexes into a</span>
<span class="fc" id="L718">        int cursor2 = len2 - 1;          // Indexes into tmp array</span>
<span class="fc" id="L719">        int dest = base2 + len2 - 1;     // Indexes into a</span>
        // Move last element of first run and deal with degenerate cases
<span class="fc" id="L721">        a[dest--] = a[cursor1--];</span>
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">        if (--len1 == 0) {</span>
<span class="nc" id="L723">            System.arraycopy(tmp, 0, a, dest - (len2 - 1), len2);</span>
<span class="nc" id="L724">            return;</span>
        }
<span class="pc bpc" id="L726" title="1 of 2 branches missed.">        if (len2 == 1) {</span>
<span class="nc" id="L727">            dest -= len1;</span>
<span class="nc" id="L728">            cursor1 -= len1;</span>
<span class="nc" id="L729">            System.arraycopy(a, cursor1 + 1, a, dest + 1, len1);</span>
<span class="nc" id="L730">            a[dest] = tmp[cursor2];</span>
<span class="nc" id="L731">            return;</span>
        }
<span class="fc" id="L733">        LongComparator c = this.c;  // Use local variable for performance</span>
<span class="fc" id="L734">        int minGallop = this.minGallop;    //  &quot;    &quot;       &quot;     &quot;      &quot;</span>
        outer:
        while (true) {
<span class="fc" id="L737">            int count1 = 0; // Number of times in a row that first run won</span>
<span class="fc" id="L738">            int count2 = 0; // Number of times in a row that second run won</span>
            /*
             * Do the straightforward thing until (if ever) one run
             * appears to win consistently.
             */
            do {
                if (DEBUG) assert len1 &gt; 0 &amp;&amp; len2 &gt; 1;
<span class="fc bfc" id="L745" title="All 2 branches covered.">                if (c.compare(tmp[cursor2], a[cursor1]) &lt; 0) {</span>
<span class="fc" id="L746">                    a[dest--] = a[cursor1--];</span>
<span class="fc" id="L747">                    count1++;</span>
<span class="fc" id="L748">                    count2 = 0;</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">                    if (--len1 == 0)</span>
<span class="fc" id="L750">                        break outer;</span>
                } else {
<span class="fc" id="L752">                    a[dest--] = tmp[cursor2--];</span>
<span class="fc" id="L753">                    count2++;</span>
<span class="fc" id="L754">                    count1 = 0;</span>
<span class="fc bfc" id="L755" title="All 2 branches covered.">                    if (--len2 == 1)</span>
<span class="fc" id="L756">                        break outer;</span>
                }
<span class="fc bfc" id="L758" title="All 2 branches covered.">            } while ((count1 | count2) &lt; minGallop);</span>
            /*
             * One run is winning so consistently that galloping may be a
             * huge win. So try that, and continue galloping until (if ever)
             * neither run appears to be winning consistently anymore.
             */
            do {
                if (DEBUG) assert len1 &gt; 0 &amp;&amp; len2 &gt; 1;
<span class="fc" id="L766">                count1 = len1 - gallopRight(tmp[cursor2], a, base1, len1, len1 - 1, c);</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">                if (count1 != 0) {</span>
<span class="fc" id="L768">                    dest -= count1;</span>
<span class="fc" id="L769">                    cursor1 -= count1;</span>
<span class="fc" id="L770">                    len1 -= count1;</span>
<span class="fc" id="L771">                    System.arraycopy(a, cursor1 + 1, a, dest + 1, count1);</span>
<span class="pc bpc" id="L772" title="1 of 2 branches missed.">                    if (len1 == 0)</span>
<span class="nc" id="L773">                        break outer;</span>
                }
<span class="fc" id="L775">                a[dest--] = tmp[cursor2--];</span>
<span class="pc bpc" id="L776" title="1 of 2 branches missed.">                if (--len2 == 1)</span>
<span class="nc" id="L777">                    break outer;</span>
<span class="fc" id="L778">                count2 = len2 - gallopLeft(a[cursor1], tmp, 0, len2, len2 - 1, c);</span>
<span class="fc bfc" id="L779" title="All 2 branches covered.">                if (count2 != 0) {</span>
<span class="fc" id="L780">                    dest -= count2;</span>
<span class="fc" id="L781">                    cursor2 -= count2;</span>
<span class="fc" id="L782">                    len2 -= count2;</span>
<span class="fc" id="L783">                    System.arraycopy(tmp, cursor2 + 1, a, dest + 1, count2);</span>
<span class="pc bpc" id="L784" title="1 of 2 branches missed.">                    if (len2 &lt;= 1)  // len2 == 1 || len2 == 0</span>
<span class="nc" id="L785">                        break outer;</span>
                }
<span class="fc" id="L787">                a[dest--] = a[cursor1--];</span>
<span class="pc bpc" id="L788" title="1 of 2 branches missed.">                if (--len1 == 0)</span>
<span class="nc" id="L789">                    break outer;</span>
<span class="fc" id="L790">                minGallop--;</span>
<span class="fc bfc" id="L791" title="All 6 branches covered.">            } while (count1 &gt;= MIN_GALLOP | count2 &gt;= MIN_GALLOP);</span>
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">            if (minGallop &lt; 0)</span>
<span class="nc" id="L793">                minGallop = 0;</span>
<span class="fc" id="L794">            minGallop += 2;  // Penalize for leaving gallop mode</span>
<span class="fc" id="L795">        }  // End of &quot;outer&quot; loop</span>
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">        this.minGallop = minGallop &lt; 1 ? 1 : minGallop;  // Write back to field</span>
<span class="fc bfc" id="L797" title="All 2 branches covered.">        if (len2 == 1) {</span>
            if (DEBUG) assert len1 &gt; 0;
<span class="fc" id="L799">            dest -= len1;</span>
<span class="fc" id="L800">            cursor1 -= len1;</span>
<span class="fc" id="L801">            System.arraycopy(a, cursor1 + 1, a, dest + 1, len1);</span>
<span class="fc" id="L802">            a[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge</span>
<span class="pc bpc" id="L803" title="1 of 2 branches missed.">        } else if (len2 == 0) {</span>
<span class="nc" id="L804">            throw new IllegalArgumentException(</span>
                                              &quot;Comparison method violates its general contract!&quot;);
        } else {
            if (DEBUG) assert len1 == 0;
            if (DEBUG) assert len2 &gt; 0;
<span class="fc" id="L809">            System.arraycopy(tmp, 0, a, dest - (len2 - 1), len2);</span>
        }
<span class="fc" id="L811">    }</span>
    /**
     * Ensures that the external array tmp has at least the specified
     * number of elements, increasing its size if necessary.  The size
     * increases exponentially to ensure amortized linear time complexity.
     *
     * @param minCapacity the minimum required capacity of the tmp array
     * @return tmp, whether or not it grew
     */
    private long[] ensureCapacity(int minCapacity) {
<span class="fc bfc" id="L821" title="All 2 branches covered.">        if (tmp.length &lt; minCapacity) {</span>
            // Compute smallest power of 2 &gt; minCapacity
<span class="fc" id="L823">            int newSize = minCapacity;</span>
<span class="fc" id="L824">            newSize |= newSize &gt;&gt; 1;</span>
<span class="fc" id="L825">            newSize |= newSize &gt;&gt; 2;</span>
<span class="fc" id="L826">            newSize |= newSize &gt;&gt; 4;</span>
<span class="fc" id="L827">            newSize |= newSize &gt;&gt; 8;</span>
<span class="fc" id="L828">            newSize |= newSize &gt;&gt; 16;</span>
<span class="fc" id="L829">            newSize++;</span>
<span class="pc bpc" id="L830" title="1 of 2 branches missed.">            if (newSize &lt; 0) // Not bloody likely!</span>
<span class="nc" id="L831">                newSize = minCapacity;</span>
            else
<span class="fc" id="L833">                newSize = Math.min(newSize, a.length &gt;&gt;&gt; 1);</span>
            @SuppressWarnings({&quot;unchecked&quot;, &quot;UnnecessaryLocalVariable&quot;})
<span class="fc" id="L835">            long[] newArray = new long[newSize];</span>
<span class="fc" id="L836">            tmp = newArray;</span>
        }
<span class="fc" id="L838">        return tmp;</span>
    }
    /**
     * Checks that fromIndex and toIndex are in range, and throws an
     * appropriate exception if they aren't.
     *
     * @param arrayLen the length of the array
     * @param fromIndex the index of the first element of the range
     * @param toIndex the index after the last element of the range
     * @throws IllegalArgumentException if fromIndex &gt; toIndex
     * @throws ArrayIndexOutOfBoundsException if fromIndex &lt; 0
     *         or toIndex &gt; arrayLen
     */
    private static void rangeCheck(int arrayLen, int fromIndex, int toIndex) {
<span class="pc bpc" id="L852" title="1 of 2 branches missed.">        if (fromIndex &gt; toIndex)</span>
<span class="nc" id="L853">            throw new IllegalArgumentException(&quot;fromIndex(&quot; + fromIndex +</span>
                                               &quot;) &gt; toIndex(&quot; + toIndex+&quot;)&quot;);
<span class="pc bpc" id="L855" title="1 of 2 branches missed.">        if (fromIndex &lt; 0)</span>
<span class="nc" id="L856">            throw new ArrayIndexOutOfBoundsException(fromIndex);</span>
<span class="pc bpc" id="L857" title="1 of 2 branches missed.">        if (toIndex &gt; arrayLen)</span>
<span class="nc" id="L858">            throw new ArrayIndexOutOfBoundsException(toIndex);</span>
<span class="fc" id="L859">    }</span>
    
    // addition to original file
    
    @FunctionalInterface
    public static interface LongComparator
    {
        int compare(long o1, long o2);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>