<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Memory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.io.util</a> &gt; <span class="el_source">Memory.java</span></div><h1>Memory.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.io.util;

import java.lang.reflect.Field;
import java.nio.ByteBuffer;

import net.nicoulaj.compilecommand.annotations.Inline;

import org.apache.cassandra.utils.Architecture;
import org.apache.cassandra.utils.FastByteOperations;
import org.apache.cassandra.utils.concurrent.Ref;
import org.apache.cassandra.utils.memory.MemoryUtil;
import sun.misc.Unsafe;

/**
 * An off-heap region of memory that must be manually free'd when no longer needed.
 */
public class Memory implements AutoCloseable, ReadableMemory
{
    private static final Unsafe unsafe;
    static
    {
        try
        {
<span class="fc" id="L41">            Field field = sun.misc.Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span>
<span class="fc" id="L42">            field.setAccessible(true);</span>
<span class="fc" id="L43">            unsafe = (sun.misc.Unsafe) field.get(null);</span>
        }
<span class="nc" id="L45">        catch (Exception e)</span>
        {
<span class="nc" id="L47">            throw new AssertionError(e);</span>
<span class="fc" id="L48">        }</span>
    }

<span class="fc" id="L51">    private static final long BYTE_ARRAY_BASE_OFFSET = unsafe.arrayBaseOffset(byte[].class);</span>

<span class="fc" id="L53">    public static final ByteBuffer[] NO_BYTE_BUFFERS = new ByteBuffer[0];</span>

    protected long peer;
    // size of the memory region
    protected final long size;

    protected Memory(long bytes)
<span class="fc" id="L60">    {</span>
<span class="pc bpc" id="L61" title="1 of 2 branches missed.">        if (bytes &lt;= 0)</span>
<span class="nc" id="L62">            throw new AssertionError();</span>
<span class="fc" id="L63">        size = bytes;</span>
<span class="fc" id="L64">        peer = MemoryUtil.allocate(size);</span>
        // we permit a 0 peer iff size is zero, since such an allocation makes no sense, and an allocator would be
        // justified in returning a null pointer (and permitted to do so: http://www.cplusplus.com/reference/cstdlib/malloc)
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">        if (peer == 0)</span>
<span class="nc" id="L68">            throw new OutOfMemoryError(); // checkstyle: permit this instantiation</span>
<span class="fc" id="L69">    }</span>

    // create a memory object that references the exacy same memory location as the one provided.
    // this should ONLY be used by SafeMemory
    protected Memory(Memory copyOf)
<span class="fc" id="L74">    {</span>
<span class="fc" id="L75">        size = copyOf.size;</span>
<span class="fc" id="L76">        peer = copyOf.peer;</span>
<span class="fc" id="L77">    }</span>

    public static Memory allocate(long bytes)
    {
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">        if (bytes &lt; 0)</span>
<span class="nc" id="L82">            throw new IllegalArgumentException();</span>

<span class="pc bpc" id="L84" title="1 of 2 branches missed.">        if (Ref.DEBUG_ENABLED)</span>
<span class="fc" id="L85">            return new SafeMemory(bytes);</span>

<span class="nc" id="L87">        return new Memory(bytes);</span>
    }

    public void setByte(long offset, byte b)
    {
<span class="fc" id="L92">        checkBounds(offset, offset + 1);</span>
<span class="fc" id="L93">        unsafe.putByte(peer + offset, b);</span>
<span class="fc" id="L94">    }</span>

    public void setMemory(long offset, long bytes, byte b)
    {
<span class="fc" id="L98">        checkBounds(offset, offset + bytes);</span>
        // check if the last element will fit into the memory
<span class="fc" id="L100">        unsafe.setMemory(peer + offset, bytes, b);</span>
<span class="fc" id="L101">    }</span>

    public void setLong(long offset, long l)
    {
<span class="fc" id="L105">        checkBounds(offset, offset + 8);</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">        if (Architecture.IS_UNALIGNED)</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">            unsafe.putLong(peer + offset, Architecture.BIG_ENDIAN ? Long.reverseBytes(l) : l);</span>
        else
<span class="nc" id="L109">            putLongByByte(peer + offset, l);</span>
<span class="fc" id="L110">    }</span>

    private void putLongByByte(long address, long value)
    {
<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (Architecture.BIG_ENDIAN)</span>
        {
<span class="nc" id="L116">            unsafe.putByte(address, (byte) (value &gt;&gt; 56));</span>
<span class="nc" id="L117">            unsafe.putByte(address + 1, (byte) (value &gt;&gt; 48));</span>
<span class="nc" id="L118">            unsafe.putByte(address + 2, (byte) (value &gt;&gt; 40));</span>
<span class="nc" id="L119">            unsafe.putByte(address + 3, (byte) (value &gt;&gt; 32));</span>
<span class="nc" id="L120">            unsafe.putByte(address + 4, (byte) (value &gt;&gt; 24));</span>
<span class="nc" id="L121">            unsafe.putByte(address + 5, (byte) (value &gt;&gt; 16));</span>
<span class="nc" id="L122">            unsafe.putByte(address + 6, (byte) (value &gt;&gt; 8));</span>
<span class="nc" id="L123">            unsafe.putByte(address + 7, (byte) (value));</span>
        }
        else
        {
<span class="nc" id="L127">            unsafe.putByte(address + 7, (byte) (value &gt;&gt; 56));</span>
<span class="nc" id="L128">            unsafe.putByte(address + 6, (byte) (value &gt;&gt; 48));</span>
<span class="nc" id="L129">            unsafe.putByte(address + 5, (byte) (value &gt;&gt; 40));</span>
<span class="nc" id="L130">            unsafe.putByte(address + 4, (byte) (value &gt;&gt; 32));</span>
<span class="nc" id="L131">            unsafe.putByte(address + 3, (byte) (value &gt;&gt; 24));</span>
<span class="nc" id="L132">            unsafe.putByte(address + 2, (byte) (value &gt;&gt; 16));</span>
<span class="nc" id="L133">            unsafe.putByte(address + 1, (byte) (value &gt;&gt; 8));</span>
<span class="nc" id="L134">            unsafe.putByte(address, (byte) (value));</span>
        }
<span class="nc" id="L136">    }</span>

    public void setInt(long offset, int l)
    {
<span class="fc" id="L140">        checkBounds(offset, offset + 4);</span>
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">        if (Architecture.IS_UNALIGNED)</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">            unsafe.putInt(peer + offset, Architecture.BIG_ENDIAN ? Integer.reverseBytes(l) : l);</span>
        else
<span class="nc" id="L144">            putIntByByte(peer + offset, l);</span>
<span class="fc" id="L145">    }</span>

    private void putIntByByte(long address, int value)
    {
<span class="nc bnc" id="L149" title="All 2 branches missed.">        if (Architecture.BIG_ENDIAN)</span>
        {
<span class="nc" id="L151">            unsafe.putByte(address, (byte) (value &gt;&gt; 24));</span>
<span class="nc" id="L152">            unsafe.putByte(address + 1, (byte) (value &gt;&gt; 16));</span>
<span class="nc" id="L153">            unsafe.putByte(address + 2, (byte) (value &gt;&gt; 8));</span>
<span class="nc" id="L154">            unsafe.putByte(address + 3, (byte) (value));</span>
        }
        else
        {
<span class="nc" id="L158">            unsafe.putByte(address + 3, (byte) (value &gt;&gt; 24));</span>
<span class="nc" id="L159">            unsafe.putByte(address + 2, (byte) (value &gt;&gt; 16));</span>
<span class="nc" id="L160">            unsafe.putByte(address + 1, (byte) (value &gt;&gt; 8));</span>
<span class="nc" id="L161">            unsafe.putByte(address, (byte) (value));</span>
        }
<span class="nc" id="L163">    }</span>

    public void setShort(long offset, short l)
    {
<span class="nc" id="L167">        checkBounds(offset, offset + 2);</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">        if (Architecture.IS_UNALIGNED)</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">            unsafe.putShort(peer + offset, Architecture.BIG_ENDIAN ? Short.reverseBytes(l) : l);</span>
        else
<span class="nc" id="L171">            putShortByByte(peer + offset, l);</span>
<span class="nc" id="L172">    }</span>

    private void putShortByByte(long address, short value)
    {
<span class="nc bnc" id="L176" title="All 2 branches missed.">        if (Architecture.BIG_ENDIAN)</span>
        {
<span class="nc" id="L178">            unsafe.putByte(address, (byte) (value &gt;&gt; 8));</span>
<span class="nc" id="L179">            unsafe.putByte(address + 1, (byte) (value));</span>
        }
        else
        {
<span class="nc" id="L183">            unsafe.putByte(address + 1, (byte) (value &gt;&gt; 8));</span>
<span class="nc" id="L184">            unsafe.putByte(address, (byte) (value));</span>
        }
<span class="nc" id="L186">    }</span>

    public void setBytes(long memoryOffset, ByteBuffer buffer)
    {
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">        if (buffer == null)</span>
<span class="nc" id="L191">            throw new NullPointerException();</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        else if (buffer.remaining() == 0)</span>
<span class="nc" id="L193">            return;</span>

<span class="fc" id="L195">        checkBounds(memoryOffset, memoryOffset + buffer.remaining());</span>
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">        if (buffer.hasArray())</span>
        {
<span class="fc" id="L198">            setBytes(memoryOffset, buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.remaining());</span>
        }
<span class="nc bnc" id="L200" title="All 2 branches missed.">        else if (buffer.isDirect())</span>
        {
<span class="nc" id="L202">            unsafe.copyMemory(MemoryUtil.getAddress(buffer) + buffer.position(), peer + memoryOffset, buffer.remaining());</span>
        }
        else
<span class="nc" id="L205">            throw new IllegalStateException();</span>
<span class="fc" id="L206">    }</span>
    /**
     * Transfers count bytes from buffer to Memory
     *
     * @param memoryOffset start offset in the memory
     * @param buffer the data buffer
     * @param bufferOffset start offset of the buffer
     * @param count number of bytes to transfer
     */
    public void setBytes(long memoryOffset, byte[] buffer, int bufferOffset, int count)
    {
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">        if (buffer == null)</span>
<span class="nc" id="L218">            throw new NullPointerException();</span>
<span class="pc bpc" id="L219" title="3 of 6 branches missed.">        else if (bufferOffset &lt; 0</span>
                 || count &lt; 0
                 || bufferOffset + count &gt; buffer.length)
<span class="nc" id="L222">            throw new IndexOutOfBoundsException();</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">        else if (count == 0)</span>
<span class="nc" id="L224">            return;</span>

<span class="fc" id="L226">        checkBounds(memoryOffset, memoryOffset + count);</span>
<span class="fc" id="L227">        unsafe.copyMemory(buffer, BYTE_ARRAY_BASE_OFFSET + bufferOffset, null, peer + memoryOffset, count);</span>
<span class="fc" id="L228">    }</span>

    public byte getByte(long offset)
    {
<span class="fc" id="L232">        checkBounds(offset, offset + 1);</span>
<span class="fc" id="L233">        return unsafe.getByte(peer + offset);</span>
    }

    public long getLong(long offset)
    {
<span class="fc" id="L238">        checkBounds(offset, offset + 8);</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">        if (Architecture.IS_UNALIGNED)</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">            return Architecture.BIG_ENDIAN ? Long.reverseBytes(unsafe.getLong(peer+offset)) : unsafe.getLong(peer+offset);</span>
        else
<span class="nc" id="L242">            return getLongByByte(peer + offset);</span>
    }

    private long getLongByByte(long address)
    {
<span class="nc bnc" id="L247" title="All 2 branches missed.">        if (Architecture.BIG_ENDIAN)</span>
        {
<span class="nc" id="L249">            return  (((long) unsafe.getByte(address    )       ) &lt;&lt; 56) |</span>
<span class="nc" id="L250">                    (((long) unsafe.getByte(address + 1) &amp; 0xff) &lt;&lt; 48) |</span>
<span class="nc" id="L251">                    (((long) unsafe.getByte(address + 2) &amp; 0xff) &lt;&lt; 40) |</span>
<span class="nc" id="L252">                    (((long) unsafe.getByte(address + 3) &amp; 0xff) &lt;&lt; 32) |</span>
<span class="nc" id="L253">                    (((long) unsafe.getByte(address + 4) &amp; 0xff) &lt;&lt; 24) |</span>
<span class="nc" id="L254">                    (((long) unsafe.getByte(address + 5) &amp; 0xff) &lt;&lt; 16) |</span>
<span class="nc" id="L255">                    (((long) unsafe.getByte(address + 6) &amp; 0xff) &lt;&lt;  8) |</span>
<span class="nc" id="L256">                    (((long) unsafe.getByte(address + 7) &amp; 0xff)      );</span>
        }
        else
        {
<span class="nc" id="L260">            return  (((long) unsafe.getByte(address + 7)       ) &lt;&lt; 56) |</span>
<span class="nc" id="L261">                    (((long) unsafe.getByte(address + 6) &amp; 0xff) &lt;&lt; 48) |</span>
<span class="nc" id="L262">                    (((long) unsafe.getByte(address + 5) &amp; 0xff) &lt;&lt; 40) |</span>
<span class="nc" id="L263">                    (((long) unsafe.getByte(address + 4) &amp; 0xff) &lt;&lt; 32) |</span>
<span class="nc" id="L264">                    (((long) unsafe.getByte(address + 3) &amp; 0xff) &lt;&lt; 24) |</span>
<span class="nc" id="L265">                    (((long) unsafe.getByte(address + 2) &amp; 0xff) &lt;&lt; 16) |</span>
<span class="nc" id="L266">                    (((long) unsafe.getByte(address + 1) &amp; 0xff) &lt;&lt;  8) |</span>
<span class="nc" id="L267">                    (((long) unsafe.getByte(address    ) &amp; 0xff)      );</span>
        }
    }

    public int getInt(long offset)
    {
<span class="fc" id="L273">        checkBounds(offset, offset + 4);</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">        if (Architecture.IS_UNALIGNED)</span>
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">            return Architecture.BIG_ENDIAN ? Integer.reverseBytes(unsafe.getInt(peer+offset)) : unsafe.getInt(peer+offset);</span>
        else
<span class="nc" id="L277">            return getIntByByte(peer + offset);</span>
    }

    private int getIntByByte(long address)
    {
<span class="nc bnc" id="L282" title="All 2 branches missed.">        if (Architecture.BIG_ENDIAN)</span>
        {
<span class="nc" id="L284">            return  ((unsafe.getByte(address    )       ) &lt;&lt; 24) |</span>
<span class="nc" id="L285">                    ((unsafe.getByte(address + 1) &amp; 0xff) &lt;&lt; 16) |</span>
<span class="nc" id="L286">                    ((unsafe.getByte(address + 2) &amp; 0xff) &lt;&lt; 8 ) |</span>
<span class="nc" id="L287">                    ((unsafe.getByte(address + 3) &amp; 0xff)      );</span>
        }
        else
        {
<span class="nc" id="L291">            return  ((unsafe.getByte(address + 3)       ) &lt;&lt; 24) |</span>
<span class="nc" id="L292">                    ((unsafe.getByte(address + 2) &amp; 0xff) &lt;&lt; 16) |</span>
<span class="nc" id="L293">                    ((unsafe.getByte(address + 1) &amp; 0xff) &lt;&lt;  8) |</span>
<span class="nc" id="L294">                    ((unsafe.getByte(address    ) &amp; 0xff)      );</span>
        }
    }

    /**
     * Transfers count bytes from Memory starting at memoryOffset to buffer starting at bufferOffset
     *
     * @param memoryOffset start offset in the memory
     * @param buffer the data buffer
     * @param bufferOffset start offset of the buffer
     * @param count number of bytes to transfer
     */
    public void getBytes(long memoryOffset, byte[] buffer, int bufferOffset, int count)
    {
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">        if (buffer == null)</span>
<span class="nc" id="L309">            throw new NullPointerException();</span>
<span class="pc bpc" id="L310" title="3 of 6 branches missed.">        else if (bufferOffset &lt; 0 || count &lt; 0 || count &gt; buffer.length - bufferOffset)</span>
<span class="nc" id="L311">            throw new IndexOutOfBoundsException();</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">        else if (count == 0)</span>
<span class="fc" id="L313">            return;</span>

<span class="fc" id="L315">        checkBounds(memoryOffset, memoryOffset + count);</span>
<span class="fc" id="L316">        FastByteOperations.UnsafeOperations.copy(null, peer + memoryOffset, buffer, bufferOffset, count);</span>
<span class="fc" id="L317">    }</span>

    @Inline
    protected void checkBounds(long start, long end)
    {
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">        assert peer != 0 : &quot;Memory was freed&quot;;</span>
<span class="pc bpc" id="L323" title="1 of 6 branches missed.">        assert start &gt;= 0 &amp;&amp; end &lt;= size &amp;&amp; start &lt;= end : &quot;Illegal bounds [&quot; + start + &quot;..&quot; + end + &quot;); size: &quot; + size;</span>
<span class="fc" id="L324">    }</span>

    public void put(long trgOffset, Memory memory, long srcOffset, long size)
    {
<span class="fc" id="L328">        checkBounds(trgOffset, trgOffset + size);</span>
<span class="fc" id="L329">        memory.checkBounds(srcOffset, srcOffset + size);</span>
<span class="fc" id="L330">        unsafe.copyMemory(memory.peer + srcOffset, peer + trgOffset, size);</span>
<span class="fc" id="L331">    }</span>

    public Memory copy(long newSize)
    {
<span class="nc" id="L335">        Memory copy = Memory.allocate(newSize);</span>
<span class="nc" id="L336">        copy.put(0, this, 0, Math.min(size(), newSize));</span>
<span class="nc" id="L337">        return copy;</span>
    }

    public void free()
    {
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">        if (peer != 0) MemoryUtil.free(peer);</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">        else assert size == 0;</span>
<span class="fc" id="L344">        peer = 0;</span>
<span class="fc" id="L345">    }</span>

    public void close()
    {
<span class="nc" id="L349">        free();</span>
<span class="nc" id="L350">    }</span>

    public long size()
    {
<span class="fc bfc" id="L354" title="All 2 branches covered.">        assert peer != 0;</span>
<span class="fc" id="L355">        return size;</span>
    }

    @Override
    public boolean equals(Object o)
    {
<span class="nc bnc" id="L361" title="All 2 branches missed.">        if (this == o)</span>
<span class="nc" id="L362">            return true;</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (!(o instanceof Memory))</span>
<span class="nc" id="L364">            return false;</span>
<span class="nc" id="L365">        Memory b = (Memory) o;</span>
<span class="nc bnc" id="L366" title="All 4 branches missed.">        if (peer == b.peer &amp;&amp; size == b.size)</span>
<span class="nc" id="L367">            return true;</span>
<span class="nc" id="L368">        return false;</span>
    }

    public ByteBuffer[] asByteBuffers(long offset, long length)
    {
<span class="fc" id="L373">        checkBounds(offset, offset + length);</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">        if (size() == 0)</span>
<span class="nc" id="L375">            return NO_BYTE_BUFFERS;</span>

<span class="fc" id="L377">        ByteBuffer[] result = new ByteBuffer[(int) (length / Integer.MAX_VALUE) + 1];</span>
<span class="fc" id="L378">        int size = (int) (size() / result.length);</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">        for (int i = 0 ; i &lt; result.length - 1 ; i++)</span>
        {
<span class="nc" id="L381">            result[i] = MemoryUtil.getByteBuffer(peer + offset, size);</span>
<span class="nc" id="L382">            offset += size;</span>
<span class="nc" id="L383">            length -= size;</span>
        }
<span class="fc" id="L385">        result[result.length - 1] = MemoryUtil.getByteBuffer(peer + offset, (int) length);</span>
<span class="fc" id="L386">        return result;</span>
    }

    public ByteBuffer asByteBuffer(long offset, int length)
    {
<span class="fc" id="L391">        checkBounds(offset, offset + length);</span>
<span class="fc" id="L392">        return MemoryUtil.getByteBuffer(peer + offset, length);</span>
    }

    // MUST provide a buffer created via MemoryUtil.getHollowDirectByteBuffer()
    public void setByteBuffer(ByteBuffer buffer, long offset, int length)
    {
<span class="fc" id="L398">        checkBounds(offset, offset + length);</span>
<span class="fc" id="L399">        MemoryUtil.setDirectByteBuffer(buffer, peer + offset, length);</span>
<span class="fc" id="L400">    }</span>

    public String toString()
    {
<span class="fc" id="L404">        return toString(peer, size);</span>
    }

    protected static String toString(long peer, long size)
    {
<span class="fc" id="L409">        return String.format(&quot;Memory@[%x..%x)&quot;, peer, peer + size);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>