<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Message.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.transport</a> &gt; <span class="el_source">Message.java</span></div><h1>Message.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.transport;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.nio.ByteBuffer;
import java.util.EnumSet;
import java.util.List;
import java.util.Map;

import com.google.common.annotations.VisibleForTesting;

import io.netty.buffer.ByteBuf;
import io.netty.channel.*;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.service.StorageService;
import org.apache.cassandra.tracing.Tracing;
import org.apache.cassandra.transport.messages.*;
import org.apache.cassandra.service.QueryState;
import org.apache.cassandra.utils.ReflectionUtils;
import org.apache.cassandra.utils.TimeUUID;

import static org.apache.cassandra.utils.TimeUUID.Generator.nextTimeUUID;

/**
 * A message from the CQL binary protocol.
 */
public abstract class Message
{
<span class="fc" id="L49">    protected static final Logger logger = LoggerFactory.getLogger(Message.class);</span>

    public interface Codec&lt;M extends Message&gt; extends CBCodec&lt;M&gt; {}

<span class="fc" id="L53">    public enum Direction</span>
    {
<span class="fc" id="L55">        REQUEST, RESPONSE;</span>

        public static Direction extractFromVersion(int versionWithDirection)
        {
<span class="fc bfc" id="L59" title="All 2 branches covered.">            return (versionWithDirection &amp; 0x80) == 0 ? REQUEST : RESPONSE;</span>
        }

        public int addToVersion(int rawVersion)
        {
<span class="fc bfc" id="L64" title="All 2 branches covered.">            return this == REQUEST ? (rawVersion &amp; 0x7F) : (rawVersion | 0x80);</span>
        }
    }

<span class="fc" id="L68">    public enum Type</span>
    {
<span class="fc" id="L70">        ERROR          (0,  Direction.RESPONSE, ErrorMessage.codec),</span>
<span class="fc" id="L71">        STARTUP        (1,  Direction.REQUEST,  StartupMessage.codec),</span>
<span class="fc" id="L72">        READY          (2,  Direction.RESPONSE, ReadyMessage.codec),</span>
<span class="fc" id="L73">        AUTHENTICATE   (3,  Direction.RESPONSE, AuthenticateMessage.codec),</span>
<span class="fc" id="L74">        CREDENTIALS    (4,  Direction.REQUEST,  UnsupportedMessageCodec.instance),</span>
<span class="fc" id="L75">        OPTIONS        (5,  Direction.REQUEST,  OptionsMessage.codec),</span>
<span class="fc" id="L76">        SUPPORTED      (6,  Direction.RESPONSE, SupportedMessage.codec),</span>
<span class="fc" id="L77">        QUERY          (7,  Direction.REQUEST,  QueryMessage.codec),</span>
<span class="fc" id="L78">        RESULT         (8,  Direction.RESPONSE, ResultMessage.codec),</span>
<span class="fc" id="L79">        PREPARE        (9,  Direction.REQUEST,  PrepareMessage.codec),</span>
<span class="fc" id="L80">        EXECUTE        (10, Direction.REQUEST,  ExecuteMessage.codec),</span>
<span class="fc" id="L81">        REGISTER       (11, Direction.REQUEST,  RegisterMessage.codec),</span>
<span class="fc" id="L82">        EVENT          (12, Direction.RESPONSE, EventMessage.codec),</span>
<span class="fc" id="L83">        BATCH          (13, Direction.REQUEST,  BatchMessage.codec),</span>
<span class="fc" id="L84">        AUTH_CHALLENGE (14, Direction.RESPONSE, AuthChallenge.codec),</span>
<span class="fc" id="L85">        AUTH_RESPONSE  (15, Direction.REQUEST,  AuthResponse.codec),</span>
<span class="fc" id="L86">        AUTH_SUCCESS   (16, Direction.RESPONSE, AuthSuccess.codec);</span>

        public final int opcode;
        public final Direction direction;
        public final Codec&lt;?&gt; codec;

        private static final Type[] opcodeIdx;
        static
        {
<span class="fc" id="L95">            int maxOpcode = -1;</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">            for (Type type : Type.values())</span>
<span class="fc" id="L97">                maxOpcode = Math.max(maxOpcode, type.opcode);</span>
<span class="fc" id="L98">            opcodeIdx = new Type[maxOpcode + 1];</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">            for (Type type : Type.values())</span>
            {
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">                if (opcodeIdx[type.opcode] != null)</span>
<span class="nc" id="L102">                    throw new IllegalStateException(&quot;Duplicate opcode&quot;);</span>
<span class="fc" id="L103">                opcodeIdx[type.opcode] = type;</span>
            }
<span class="fc" id="L105">        }</span>

        Type(int opcode, Direction direction, Codec&lt;?&gt; codec)
<span class="fc" id="L108">        {</span>
<span class="fc" id="L109">            this.opcode = opcode;</span>
<span class="fc" id="L110">            this.direction = direction;</span>
<span class="fc" id="L111">            this.codec = codec;</span>
<span class="fc" id="L112">        }</span>

        public static Type fromOpcode(int opcode, Direction direction)
        {
<span class="fc bfc" id="L116" title="All 2 branches covered.">            if (opcode &gt;= opcodeIdx.length)</span>
<span class="fc" id="L117">                throw new ProtocolException(String.format(&quot;Unknown opcode %d&quot;, opcode));</span>
<span class="fc" id="L118">            Type t = opcodeIdx[opcode];</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">            if (t == null)</span>
<span class="nc" id="L120">                throw new ProtocolException(String.format(&quot;Unknown opcode %d&quot;, opcode));</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">            if (t.direction != direction)</span>
<span class="fc" id="L122">                throw new ProtocolException(String.format(&quot;Wrong protocol direction (expected %s, got %s) for opcode %d (%s)&quot;,</span>
                                                          t.direction,
                                                          direction,
<span class="fc" id="L125">                                                          opcode,</span>
                                                          t));
<span class="fc" id="L127">            return t;</span>
        }

        @VisibleForTesting
        public Codec&lt;?&gt; unsafeSetCodec(Codec&lt;?&gt; codec) throws NoSuchFieldException, IllegalAccessException
        {
<span class="nc" id="L133">            Codec&lt;?&gt; original = this.codec;</span>
<span class="nc" id="L134">            Field field = Type.class.getDeclaredField(&quot;codec&quot;);</span>
<span class="nc" id="L135">            field.setAccessible(true);</span>
<span class="nc" id="L136">            Field modifiers = ReflectionUtils.getModifiersField();</span>
<span class="nc" id="L137">            modifiers.setAccessible(true);</span>
<span class="nc" id="L138">            modifiers.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL);</span>
<span class="nc" id="L139">            field.set(this, codec);</span>
<span class="nc" id="L140">            return original;</span>
        }
    }

    public final Type type;
    protected Connection connection;
    private int streamId;
    private Envelope source;
    private Map&lt;String, ByteBuffer&gt; customPayload;
<span class="fc" id="L149">    protected ProtocolVersion forcedProtocolVersion = null;</span>

    protected Message(Type type)
<span class="fc" id="L152">    {</span>
<span class="fc" id="L153">        this.type = type;</span>
<span class="fc" id="L154">    }</span>

    public void attach(Connection connection)
    {
<span class="fc" id="L158">        this.connection = connection;</span>
<span class="fc" id="L159">    }</span>

    public Connection connection()
    {
<span class="fc" id="L163">        return connection;</span>
    }

    public Message setStreamId(int streamId)
    {
<span class="fc" id="L168">        this.streamId = streamId;</span>
<span class="fc" id="L169">        return this;</span>
    }

    public int getStreamId()
    {
<span class="fc" id="L174">        return streamId;</span>
    }

    public void setSource(Envelope source)
    {
<span class="fc" id="L179">        this.source = source;</span>
<span class="fc" id="L180">    }</span>

    public Envelope getSource()
    {
<span class="fc" id="L184">        return source;</span>
    }

    public Map&lt;String, ByteBuffer&gt; getCustomPayload()
    {
<span class="fc" id="L189">        return customPayload;</span>
    }

    public void setCustomPayload(Map&lt;String, ByteBuffer&gt; customPayload)
    {
<span class="fc" id="L194">        this.customPayload = customPayload;</span>
<span class="fc" id="L195">    }</span>

    @Override
    public String toString()
    {
<span class="nc bnc" id="L200" title="All 2 branches missed.">        return String.format(&quot;(%s:%s:%s)&quot;, type, streamId, connection == null ? &quot;null&quot; :  connection.getVersion().asInt());</span>
    }

    public static abstract class Request extends Message
    {
        private boolean tracingRequested;

        protected Request(Type type)
        {
<span class="fc" id="L209">            super(type);</span>

<span class="pc bpc" id="L211" title="1 of 2 branches missed.">            if (type.direction != Direction.REQUEST)</span>
<span class="nc" id="L212">                throw new IllegalArgumentException();</span>
<span class="fc" id="L213">        }</span>

        /**
         * @return true if the execution of this {@link Request} should be recorded in a tracing session
         */
        protected boolean isTraceable()
        {
<span class="fc" id="L220">            return false;</span>
        }

        /**
         * @return true if warnings should be tracked and aborts enforced for resource limits on this {@link Request}
         */
        protected boolean isTrackable()
        {
<span class="fc" id="L228">            return false;</span>
        }

        protected abstract Response execute(QueryState queryState, long queryStartNanoTime, boolean traceRequest);

        public final Response execute(QueryState queryState, long queryStartNanoTime)
        {
<span class="fc" id="L235">            boolean shouldTrace = false;</span>
<span class="fc" id="L236">            TimeUUID tracingSessionId = null;</span>

<span class="fc bfc" id="L238" title="All 2 branches covered.">            if (isTraceable())</span>
            {
<span class="fc bfc" id="L240" title="All 2 branches covered.">                if (isTracingRequested())</span>
                {
<span class="fc" id="L242">                    shouldTrace = true;</span>
<span class="fc" id="L243">                    tracingSessionId = nextTimeUUID();</span>
<span class="fc" id="L244">                    Tracing.instance.newSession(tracingSessionId, getCustomPayload());</span>
                }
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">                else if (StorageService.instance.shouldTraceProbablistically())</span>
                {
<span class="nc" id="L248">                    shouldTrace = true;</span>
<span class="nc" id="L249">                    Tracing.instance.newSession(getCustomPayload());</span>
                }
            }

            Response response;
            try
            {
<span class="fc" id="L256">                response = execute(queryState, queryStartNanoTime, shouldTrace);</span>
            }
            finally
            {
<span class="fc bfc" id="L260" title="All 2 branches covered.">                if (shouldTrace)</span>
<span class="fc" id="L261">                    Tracing.instance.stopSession();</span>
            }

<span class="fc bfc" id="L264" title="All 4 branches covered.">            if (isTraceable() &amp;&amp; isTracingRequested())</span>
<span class="fc" id="L265">                response.setTracingId(tracingSessionId);</span>

<span class="fc" id="L267">            return response;</span>
        }

        void setTracingRequested()
        {
<span class="fc" id="L272">            tracingRequested = true;</span>
<span class="fc" id="L273">        }</span>

        boolean isTracingRequested()
        {
<span class="fc" id="L277">            return tracingRequested;</span>
        }
    }

    public static abstract class Response extends Message
    {
        protected TimeUUID tracingId;
        protected List&lt;String&gt; warnings;

        protected Response(Type type)
        {
<span class="fc" id="L288">            super(type);</span>

<span class="pc bpc" id="L290" title="1 of 2 branches missed.">            if (type.direction != Direction.RESPONSE)</span>
<span class="nc" id="L291">                throw new IllegalArgumentException();</span>
<span class="fc" id="L292">        }</span>

        Message setTracingId(TimeUUID tracingId)
        {
<span class="fc" id="L296">            this.tracingId = tracingId;</span>
<span class="fc" id="L297">            return this;</span>
        }

        TimeUUID getTracingId()
        {
<span class="fc" id="L302">            return tracingId;</span>
        }

        public Message setWarnings(List&lt;String&gt; warnings)
        {
<span class="fc" id="L307">            this.warnings = warnings;</span>
<span class="fc" id="L308">            return this;</span>
        }

        public List&lt;String&gt; getWarnings()
        {
<span class="fc" id="L313">            return warnings;</span>
        }
    }

    public Envelope encode(ProtocolVersion version)
    {
<span class="fc" id="L319">        EnumSet&lt;Envelope.Header.Flag&gt; flags = EnumSet.noneOf(Envelope.Header.Flag.class);</span>
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L321">        Codec&lt;Message&gt; codec = (Codec&lt;Message&gt;)this.type.codec;</span>
        try
        {
<span class="fc" id="L324">            int messageSize = codec.encodedSize(this, version);</span>
            ByteBuf body;
<span class="fc bfc" id="L326" title="All 2 branches covered.">            if (this instanceof Response)</span>
            {
<span class="fc" id="L328">                Response message = (Response)this;</span>
<span class="fc" id="L329">                TimeUUID tracingId = message.getTracingId();</span>
<span class="fc" id="L330">                Map&lt;String, ByteBuffer&gt; customPayload = message.getCustomPayload();</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">                if (tracingId != null)</span>
<span class="fc" id="L332">                    messageSize += TimeUUID.sizeInBytes();</span>
<span class="fc" id="L333">                List&lt;String&gt; warnings = message.getWarnings();</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">                if (warnings != null)</span>
                {
                    // if cassandra populates warnings for &lt;= v3 protocol, this is a bug
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">                    if (version.isSmallerThan(ProtocolVersion.V4))</span>
                    {
<span class="nc" id="L339">                        logger.warn(&quot;Warnings present in message with version less than v4 (it is {}); warnings={}&quot;, version, warnings);</span>
<span class="nc" id="L340">                        warnings = null;</span>
                    }
                    else
                    {
<span class="fc" id="L344">                        messageSize += CBUtil.sizeOfStringList(warnings);</span>
                    }
                }
<span class="fc bfc" id="L347" title="All 2 branches covered.">                if (customPayload != null)</span>
                {
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">                    if (version.isSmallerThan(ProtocolVersion.V4))</span>
<span class="nc" id="L350">                        throw new ProtocolException(&quot;Must not send frame with CUSTOM_PAYLOAD flag for native protocol version &lt; 4&quot;);</span>
<span class="fc" id="L351">                    messageSize += CBUtil.sizeOfBytesMap(customPayload);</span>
                }
<span class="fc" id="L353">                body = CBUtil.allocator.buffer(messageSize);</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">                if (tracingId != null)</span>
                {
<span class="fc" id="L356">                    CBUtil.writeUUID(tracingId, body);</span>
<span class="fc" id="L357">                    flags.add(Envelope.Header.Flag.TRACING);</span>
                }
<span class="fc bfc" id="L359" title="All 2 branches covered.">                if (warnings != null)</span>
                {
<span class="fc" id="L361">                    CBUtil.writeStringList(warnings, body);</span>
<span class="fc" id="L362">                    flags.add(Envelope.Header.Flag.WARNING);</span>
                }
<span class="fc bfc" id="L364" title="All 2 branches covered.">                if (customPayload != null)</span>
                {
<span class="fc" id="L366">                    CBUtil.writeBytesMap(customPayload, body);</span>
<span class="fc" id="L367">                    flags.add(Envelope.Header.Flag.CUSTOM_PAYLOAD);</span>
                }
<span class="fc" id="L369">            }</span>
            else
            {
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">                assert this instanceof Request;</span>
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">                if (((Request)this).isTracingRequested())</span>
<span class="nc" id="L374">                    flags.add(Envelope.Header.Flag.TRACING);</span>
<span class="fc" id="L375">                Map&lt;String, ByteBuffer&gt; payload = getCustomPayload();</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">                if (payload != null)</span>
<span class="fc" id="L377">                    messageSize += CBUtil.sizeOfBytesMap(payload);</span>
<span class="fc" id="L378">                body = CBUtil.allocator.buffer(messageSize);</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">                if (payload != null)</span>
                {
<span class="fc" id="L381">                    CBUtil.writeBytesMap(payload, body);</span>
<span class="fc" id="L382">                    flags.add(Envelope.Header.Flag.CUSTOM_PAYLOAD);</span>
                }
            }

            try
            {
<span class="fc" id="L388">                codec.encode(this, body, version);</span>
            }
<span class="nc" id="L390">            catch (Throwable e)</span>
            {
<span class="nc" id="L392">                body.release();</span>
<span class="nc" id="L393">                throw e;</span>
<span class="fc" id="L394">            }</span>

            // if the driver attempted to connect with a protocol version lower than the minimum supported
            // version, respond with a protocol error message with the correct message header for that version
<span class="fc bfc" id="L398" title="All 2 branches covered.">            ProtocolVersion responseVersion = forcedProtocolVersion == null</span>
<span class="fc" id="L399">                                              ? version</span>
<span class="fc" id="L400">                                              : forcedProtocolVersion;</span>

<span class="fc bfc" id="L402" title="All 2 branches covered.">            if (responseVersion.isBeta())</span>
<span class="fc" id="L403">                flags.add(Envelope.Header.Flag.USE_BETA);</span>

<span class="fc" id="L405">            return Envelope.create(type, getStreamId(), responseVersion, flags, body);</span>
        }
<span class="nc" id="L407">        catch (Throwable e)</span>
        {
<span class="nc" id="L409">            throw ErrorMessage.wrap(e, getStreamId());</span>
        }
    }

<span class="fc" id="L413">    abstract static class Decoder&lt;M extends Message&gt;</span>
    {
        static Message decodeMessage(Channel channel, Envelope inbound)
        {
<span class="fc bfc" id="L417" title="All 2 branches covered.">            boolean isRequest = inbound.header.type.direction == Direction.REQUEST;</span>
<span class="fc" id="L418">            boolean isTracing = inbound.header.flags.contains(Envelope.Header.Flag.TRACING);</span>
<span class="fc" id="L419">            boolean isCustomPayload = inbound.header.flags.contains(Envelope.Header.Flag.CUSTOM_PAYLOAD);</span>
<span class="fc" id="L420">            boolean hasWarning = inbound.header.flags.contains(Envelope.Header.Flag.WARNING);</span>

<span class="pc bpc" id="L422" title="1 of 4 branches missed.">            TimeUUID tracingId = isRequest || !isTracing ? null : CBUtil.readTimeUUID(inbound.body);</span>
<span class="fc bfc" id="L423" title="All 4 branches covered.">            List&lt;String&gt; warnings = isRequest || !hasWarning ? null : CBUtil.readStringList(inbound.body);</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">            Map&lt;String, ByteBuffer&gt; customPayload = !isCustomPayload ? null : CBUtil.readBytesMap(inbound.body);</span>

<span class="fc bfc" id="L426" title="All 4 branches covered.">            if (isCustomPayload &amp;&amp; inbound.header.version.isSmallerThan(ProtocolVersion.V4))</span>
<span class="fc" id="L427">                throw new ProtocolException(&quot;Received frame with CUSTOM_PAYLOAD flag for native protocol version &lt; 4&quot;);</span>

<span class="fc" id="L429">            Message message = inbound.header.type.codec.decode(inbound.body, inbound.header.version);</span>
<span class="fc" id="L430">            message.setStreamId(inbound.header.streamId);</span>
<span class="fc" id="L431">            message.setSource(inbound);</span>
<span class="fc" id="L432">            message.setCustomPayload(customPayload);</span>

<span class="fc bfc" id="L434" title="All 2 branches covered.">            if (isRequest)</span>
            {
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">                assert message instanceof Request;</span>
<span class="fc" id="L437">                Request req = (Request) message;</span>
<span class="fc" id="L438">                Connection connection = channel.attr(Connection.attributeKey).get();</span>
<span class="fc" id="L439">                req.attach(connection);</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">                if (isTracing)</span>
<span class="fc" id="L441">                    req.setTracingRequested();</span>
<span class="fc" id="L442">            }</span>
            else
            {
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">                assert message instanceof Response;</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">                if (isTracing)</span>
<span class="nc" id="L447">                    ((Response) message).setTracingId(tracingId);</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">                if (hasWarning)</span>
<span class="fc" id="L449">                    ((Response) message).setWarnings(warnings);</span>
            }
<span class="fc" id="L451">            return message;</span>
        }

        abstract M decode(Channel channel, Envelope inbound);

        private static class RequestDecoder extends Decoder&lt;Request&gt;
        {
            Request decode(Channel channel, Envelope request)
            {
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">                if (request.header.type.direction != Direction.REQUEST)</span>
<span class="nc" id="L461">                    throw new ProtocolException(String.format(&quot;Unexpected RESPONSE message %s, expecting REQUEST&quot;,</span>
                                                              request.header.type));

<span class="fc" id="L464">                return (Request) decodeMessage(channel, request);</span>
            }
        }

        private static class ResponseDecoder extends Decoder&lt;Response&gt;
        {
            Response decode(Channel channel, Envelope response)
            {
<span class="pc bpc" id="L472" title="1 of 2 branches missed.">                if (response.header.type.direction != Direction.RESPONSE)</span>
<span class="nc" id="L473">                    throw new ProtocolException(String.format(&quot;Unexpected REQUEST message %s, expecting RESPONSE&quot;,</span>
                                                              response.header.type));

<span class="fc" id="L476">                return (Response) decodeMessage(channel, response);</span>
            }
        }
    }

<span class="fc" id="L481">    private static final Decoder.RequestDecoder REQUEST_DECODER = new Decoder.RequestDecoder();</span>
<span class="fc" id="L482">    private static final Decoder.ResponseDecoder RESPONSE_DECODER = new Decoder.ResponseDecoder();</span>

    static Decoder&lt;Message.Request&gt; requestDecoder()
    {
<span class="fc" id="L486">        return REQUEST_DECODER;</span>
    }

    static Decoder&lt;Message.Response&gt; responseDecoder()
    {
<span class="fc" id="L491">        return RESPONSE_DECODER;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>