<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ColumnMetadata.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.schema</a> &gt; <span class="el_source">ColumnMetadata.java</span></div><h1>ColumnMetadata.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.schema;

import java.nio.ByteBuffer;
import java.util.*;
import java.util.function.Predicate;

import javax.annotation.Nullable;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.MoreObjects;
import com.google.common.collect.Collections2;

import org.apache.cassandra.cql3.*;
import org.apache.cassandra.cql3.functions.masking.ColumnMask;
import org.apache.cassandra.cql3.selection.Selectable;
import org.apache.cassandra.cql3.selection.Selector;
import org.apache.cassandra.cql3.selection.SimpleSelector;
import org.apache.cassandra.db.rows.*;
import org.apache.cassandra.db.marshal.*;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.serializers.MarshalException;
import org.github.jamm.Unmetered;

@Unmetered
public final class ColumnMetadata extends ColumnSpecification implements Selectable, Comparable&lt;ColumnMetadata&gt;
{
<span class="fc" id="L44">    public static final Comparator&lt;Object&gt; asymmetricColumnDataComparator =</span>
<span class="fc" id="L45">        (a, b) -&gt; ((ColumnData) a).column().compareTo((ColumnMetadata) b);</span>

    public static final int NO_POSITION = -1;

<span class="fc" id="L49">    public enum ClusteringOrder</span>
    {
<span class="fc" id="L51">        ASC, DESC, NONE</span>
    }

    /**
     * The type of CQL3 column this definition represents.
     * There is 4 main type of CQL3 columns: those parts of the partition key,
     * those parts of the clustering columns and amongst the others, regular and
     * static ones.
     *
     * IMPORTANT: this enum is serialized as toString() and deserialized by calling
     * Kind.valueOf(), so do not override toString() or rename existing values.
     */
<span class="fc" id="L63">    public enum Kind</span>
    {
        // NOTE: if adding a new type, must modify comparisonOrder
<span class="fc" id="L66">        PARTITION_KEY,</span>
<span class="fc" id="L67">        CLUSTERING,</span>
<span class="fc" id="L68">        REGULAR,</span>
<span class="fc" id="L69">        STATIC;</span>

        public boolean isPrimaryKeyKind()
        {
<span class="fc bfc" id="L73" title="All 4 branches covered.">            return this == PARTITION_KEY || this == CLUSTERING;</span>
        }

    }

    public final Kind kind;

    /*
     * If the column is a partition key or clustering column, its position relative to
     * other columns of the same kind. Otherwise,  NO_POSITION (-1).
     *
     * Note that partition key and clustering columns are numbered separately so
     * the first clustering column is 0.
     */
    private final int position;

    private final Comparator&lt;CellPath&gt; cellPathComparator;
    private final Comparator&lt;Object&gt; asymmetricCellPathComparator;
    private final Comparator&lt;? super Cell&lt;?&gt;&gt; cellComparator;

    private int hash;

    /**
     * These objects are compared frequently, so we encode several of their comparison components
     * into a single long value so that this can be done efficiently
     */
    private final long comparisonOrder;

    /**
     * Masking function used to dynamically mask the contents of this column.
     */
    @Nullable
    private final ColumnMask mask;

    private static long comparisonOrder(Kind kind, boolean isComplex, long position, ColumnIdentifier name)
    {
<span class="pc bpc" id="L109" title="2 of 4 branches missed.">        assert position &gt;= 0 &amp;&amp; position &lt; 1 &lt;&lt; 12;</span>
<span class="fc" id="L110">        return   (((long) kind.ordinal()) &lt;&lt; 61)</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">               | (isComplex ? 1L &lt;&lt; 60 : 0)</span>
               | (position &lt;&lt; 48)
               | (name.prefixComparison &gt;&gt;&gt; 16);
    }

    public static ColumnMetadata partitionKeyColumn(TableMetadata table, ByteBuffer name, AbstractType&lt;?&gt; type, int position)
    {
<span class="nc" id="L118">        return new ColumnMetadata(table, name, type, position, Kind.PARTITION_KEY, null);</span>
    }

    public static ColumnMetadata partitionKeyColumn(String keyspace, String table, String name, AbstractType&lt;?&gt; type, int position)
    {
<span class="nc" id="L123">        return new ColumnMetadata(keyspace, table, ColumnIdentifier.getInterned(name, true), type, position, Kind.PARTITION_KEY, null);</span>
    }

    public static ColumnMetadata clusteringColumn(TableMetadata table, ByteBuffer name, AbstractType&lt;?&gt; type, int position)
    {
<span class="nc" id="L128">        return new ColumnMetadata(table, name, type, position, Kind.CLUSTERING, null);</span>
    }

    public static ColumnMetadata clusteringColumn(String keyspace, String table, String name, AbstractType&lt;?&gt; type, int position)
    {
<span class="nc" id="L133">        return new ColumnMetadata(keyspace, table, ColumnIdentifier.getInterned(name, true), type, position, Kind.CLUSTERING, null);</span>
    }

    public static ColumnMetadata regularColumn(TableMetadata table, ByteBuffer name, AbstractType&lt;?&gt; type)
    {
<span class="nc" id="L138">        return new ColumnMetadata(table, name, type, NO_POSITION, Kind.REGULAR, null);</span>
    }

    public static ColumnMetadata regularColumn(String keyspace, String table, String name, AbstractType&lt;?&gt; type)
    {
<span class="fc" id="L143">        return new ColumnMetadata(keyspace, table, ColumnIdentifier.getInterned(name, true), type, NO_POSITION, Kind.REGULAR, null);</span>
    }

    public static ColumnMetadata staticColumn(TableMetadata table, ByteBuffer name, AbstractType&lt;?&gt; type)
    {
<span class="nc" id="L148">        return new ColumnMetadata(table, name, type, NO_POSITION, Kind.STATIC, null);</span>
    }

    public static ColumnMetadata staticColumn(String keyspace, String table, String name, AbstractType&lt;?&gt; type)
    {
<span class="nc" id="L153">        return new ColumnMetadata(keyspace, table, ColumnIdentifier.getInterned(name, true), type, NO_POSITION, Kind.STATIC, null);</span>
    }

    public ColumnMetadata(TableMetadata table,
                          ByteBuffer name,
                          AbstractType&lt;?&gt; type,
                          int position,
                          Kind kind,
                          @Nullable ColumnMask mask)
    {
<span class="nc" id="L163">        this(table.keyspace,</span>
             table.name,
<span class="nc" id="L165">             ColumnIdentifier.getInterned(name, UTF8Type.instance),</span>
             type,
             position,
             kind,
             mask);
<span class="nc" id="L170">    }</span>

    @VisibleForTesting
    public ColumnMetadata(String ksName,
                          String cfName,
                          ColumnIdentifier name,
                          AbstractType&lt;?&gt; type,
                          int position,
                          Kind kind,
                          @Nullable ColumnMask mask)
    {
<span class="fc" id="L181">        super(ksName, cfName, name, type);</span>
<span class="pc bpc" id="L182" title="3 of 6 branches missed.">        assert name != null &amp;&amp; type != null &amp;&amp; kind != null;</span>
<span class="pc bpc" id="L183" title="1 of 6 branches missed.">        assert (position == NO_POSITION) == !kind.isPrimaryKeyKind(); // The position really only make sense for partition and clustering columns (and those must have one),</span>
                                                                      // so make sure we don't sneak it for something else since it'd breaks equals()

        // The propagation of system distributed keyspaces at startup can be problematic for old nodes without DDM,
        // since those won't know what to do with the mask mutations. Thus, we don't support DDM on those keyspaces.
<span class="pc bpc" id="L188" title="3 of 4 branches missed.">        if (mask != null &amp;&amp; SchemaConstants.isReplicatedSystemKeyspace(ksName))</span>
<span class="nc" id="L189">            throw new AssertionError(&quot;DDM is not supported on system distributed keyspaces&quot;);</span>

<span class="fc" id="L191">        this.kind = kind;</span>
<span class="fc" id="L192">        this.position = position;</span>
<span class="fc" id="L193">        this.cellPathComparator = makeCellPathComparator(kind, type);</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">        this.cellComparator = cellPathComparator == null ? ColumnData.comparator : (a, b) -&gt; cellPathComparator.compare(a.path(), b.path());</span>
<span class="pc bfc" id="L195" title="All 2 branches covered.">        this.asymmetricCellPathComparator = cellPathComparator == null ? null : (a, b) -&gt; cellPathComparator.compare(((Cell&lt;?&gt;)a).path(), (CellPath) b);</span>
<span class="fc" id="L196">        this.comparisonOrder = comparisonOrder(kind, isComplex(), Math.max(0, position), name);</span>
<span class="fc" id="L197">        this.mask = mask;</span>
<span class="fc" id="L198">    }</span>

    private static Comparator&lt;CellPath&gt; makeCellPathComparator(Kind kind, AbstractType&lt;?&gt; type)
    {
<span class="fc bfc" id="L202" title="All 4 branches covered.">        if (kind.isPrimaryKeyKind() || !type.isMultiCell())</span>
<span class="fc" id="L203">            return null;</span>

<span class="pc bpc" id="L205" title="1 of 2 branches missed.">        AbstractType&lt;?&gt; nameComparator = type.isCollection()</span>
<span class="fc" id="L206">                                       ? ((CollectionType) type).nameComparator()</span>
<span class="pc" id="L207">                                       : ((UserType) type).nameComparator();</span>


<span class="fc" id="L210">        return (path1, path2) -&gt;</span>
        {
<span class="pc bpc" id="L212" title="1 of 4 branches missed.">            if (path1.size() == 0 || path2.size() == 0)</span>
            {
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">                if (path1 == CellPath.BOTTOM)</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">                    return path2 == CellPath.BOTTOM ? 0 : -1;</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">                if (path1 == CellPath.TOP)</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">                    return path2 == CellPath.TOP ? 0 : 1;</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">                return path2 == CellPath.BOTTOM ? 1 : -1;</span>
            }

            // This will get more complicated once we have non-frozen UDT and nested collections
<span class="pc bpc" id="L222" title="2 of 4 branches missed.">            assert path1.size() == 1 &amp;&amp; path2.size() == 1;</span>
<span class="fc" id="L223">            return nameComparator.compare(path1.get(0), path2.get(0));</span>
        };
    }

    public ColumnMetadata copy()
    {
<span class="nc" id="L229">        return new ColumnMetadata(ksName, cfName, name, type, position, kind, mask);</span>
    }

    public ColumnMetadata withNewName(ColumnIdentifier newName)
    {
<span class="nc" id="L234">        return new ColumnMetadata(ksName, cfName, newName, type, position, kind, mask);</span>
    }

    public ColumnMetadata withNewType(AbstractType&lt;?&gt; newType)
    {
<span class="fc" id="L239">        return new ColumnMetadata(ksName, cfName, name, newType, position, kind, mask);</span>
    }

    public ColumnMetadata withNewMask(@Nullable ColumnMask newMask)
    {
<span class="nc" id="L244">        return new ColumnMetadata(ksName, cfName, name, type, position, kind, newMask);</span>
    }

    public boolean isPartitionKey()
    {
<span class="fc bfc" id="L249" title="All 2 branches covered.">        return kind == Kind.PARTITION_KEY;</span>
    }

    public boolean isClusteringColumn()
    {
<span class="fc bfc" id="L254" title="All 2 branches covered.">        return kind == Kind.CLUSTERING;</span>
    }

    public boolean isStatic()
    {
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">        return kind == Kind.STATIC;</span>
    }

    public boolean isMasked()
    {
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">        return mask != null;</span>
    }

    public boolean isRegular()
    {
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">        return kind == Kind.REGULAR;</span>
    }

    public ClusteringOrder clusteringOrder()
    {
<span class="fc bfc" id="L274" title="All 2 branches covered.">        if (!isClusteringColumn())</span>
<span class="fc" id="L275">            return ClusteringOrder.NONE;</span>

<span class="pc bpc" id="L277" title="1 of 2 branches missed.">        return type.isReversed() ? ClusteringOrder.DESC : ClusteringOrder.ASC;</span>
    }

    public int position()
    {
<span class="fc" id="L282">        return position;</span>
    }

    @Nullable
    public ColumnMask getMask()
    {
<span class="fc" id="L288">        return mask;</span>
    }

    @Override
    public boolean equals(Object o)
    {
<span class="fc bfc" id="L294" title="All 2 branches covered.">        if (this == o)</span>
<span class="fc" id="L295">            return true;</span>

<span class="pc bpc" id="L297" title="1 of 2 branches missed.">        if (!(o instanceof ColumnMetadata))</span>
<span class="nc" id="L298">            return false;</span>

<span class="fc" id="L300">        ColumnMetadata cd = (ColumnMetadata) o;</span>

<span class="pc bpc" id="L302" title="1 of 4 branches missed.">        return equalsWithoutType(cd) &amp;&amp; type.equals(cd.type);</span>
    }

    private boolean equalsWithoutType(ColumnMetadata other)
    {
<span class="pc bpc" id="L307" title="2 of 6 branches missed.">        return name.equals(other.name)</span>
            &amp;&amp; kind == other.kind
            &amp;&amp; position == other.position
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">            &amp;&amp; ksName.equals(other.ksName)</span>
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">            &amp;&amp; cfName.equals(other.cfName)</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">            &amp;&amp; Objects.equals(mask, other.mask);</span>
    }

    Optional&lt;Difference&gt; compare(ColumnMetadata other)
    {
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">        if (!equalsWithoutType(other))</span>
<span class="nc" id="L318">            return Optional.of(Difference.SHALLOW);</span>

<span class="pc bpc" id="L320" title="1 of 2 branches missed.">        if (type.equals(other.type))</span>
<span class="fc" id="L321">            return Optional.empty();</span>

<span class="nc bnc" id="L323" title="All 2 branches missed.">        return type.asCQL3Type().toString().equals(other.type.asCQL3Type().toString())</span>
<span class="nc" id="L324">             ? Optional.of(Difference.DEEP)</span>
<span class="nc" id="L325">             : Optional.of(Difference.SHALLOW);</span>
    }

    @Override
    public int hashCode()
    {
        // This achieves the same as Objects.hashcode, but avoids the object array allocation
        // which features significantly in the allocation profile and caches the result.
<span class="fc" id="L333">        int result = hash;</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">        if (result == 0)</span>
        {
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">            result = 31 + (ksName == null ? 0 : ksName.hashCode());</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">            result = 31 * result + (cfName == null ? 0 : cfName.hashCode());</span>
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">            result = 31 * result + (name == null ? 0 : name.hashCode());</span>
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">            result = 31 * result + (type == null ? 0 : type.hashCode());</span>
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">            result = 31 * result + (kind == null ? 0 : kind.hashCode());</span>
<span class="fc" id="L341">            result = 31 * result + position;</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">            result = 31 * result + (mask == null ? 0 : mask.hashCode());</span>
<span class="fc" id="L343">            hash = result;</span>
        }
<span class="fc" id="L345">        return result;</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L351">        return name.toString();</span>
    }

    public String debugString()
    {
<span class="nc" id="L356">        return MoreObjects.toStringHelper(this)</span>
<span class="nc" id="L357">                          .add(&quot;name&quot;, name)</span>
<span class="nc" id="L358">                          .add(&quot;type&quot;, type)</span>
<span class="nc" id="L359">                          .add(&quot;kind&quot;, kind)</span>
<span class="nc" id="L360">                          .add(&quot;position&quot;, position)</span>
<span class="nc" id="L361">                          .toString();</span>
    }

    public boolean isPrimaryKeyColumn()
    {
<span class="fc" id="L366">        return kind.isPrimaryKeyKind();</span>
    }

    @Override
    public boolean selectColumns(Predicate&lt;ColumnMetadata&gt; predicate)
    {
<span class="nc" id="L372">        return predicate.test(this);</span>
    }

    @Override
    public boolean processesSelection()
    {
<span class="fc" id="L378">        return isMasked();</span>
    }

    /**
     * Converts the specified column definitions into column identifiers.
     *
     * @param definitions the column definitions to convert.
     * @return the column identifiers corresponding to the specified definitions
     */
    public static Collection&lt;ColumnIdentifier&gt; toIdentifiers(Collection&lt;ColumnMetadata&gt; definitions)
    {
<span class="nc" id="L389">        return Collections2.transform(definitions, columnDef -&gt; columnDef.name);</span>
    }

    public int compareTo(ColumnMetadata other)
    {
<span class="fc bfc" id="L394" title="All 2 branches covered.">        if (this == other)</span>
<span class="fc" id="L395">            return 0;</span>

<span class="fc bfc" id="L397" title="All 2 branches covered.">        if (comparisonOrder != other.comparisonOrder)</span>
<span class="fc" id="L398">            return Long.compare(comparisonOrder, other.comparisonOrder);</span>

<span class="fc" id="L400">        return this.name.compareTo(other.name);</span>
    }

    public Comparator&lt;CellPath&gt; cellPathComparator()
    {
<span class="fc" id="L405">        return cellPathComparator;</span>
    }

    public Comparator&lt;Object&gt; asymmetricCellPathComparator()
    {
<span class="nc" id="L410">        return asymmetricCellPathComparator;</span>
    }

    public Comparator&lt;? super Cell&lt;?&gt;&gt; cellComparator()
    {
<span class="fc" id="L415">        return cellComparator;</span>
    }

    public boolean isComplex()
    {
<span class="fc bfc" id="L420" title="All 2 branches covered.">        return cellPathComparator != null;</span>
    }

    public boolean isSimple()
    {
<span class="fc bfc" id="L425" title="All 2 branches covered.">        return !isComplex();</span>
    }

    public CellPath.Serializer cellPathSerializer()
    {
        // Collections are our only complex so far, so keep it simple
<span class="fc" id="L431">        return CollectionType.cellPathSerializer;</span>
    }

    public &lt;V&gt; void validateCell(Cell&lt;V&gt; cell)
    {
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">        if (cell.isTombstone())</span>
        {
<span class="nc bnc" id="L438" title="All 2 branches missed.">            if (cell.valueSize() &gt; 0)</span>
<span class="nc" id="L439">                throw new MarshalException(&quot;A tombstone should not have a value&quot;);</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">            if (cell.path() != null)</span>
<span class="nc" id="L441">                validateCellPath(cell.path());</span>
        }
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">        else if(type.isUDT())</span>
        {
            // To validate a non-frozen UDT field, both the path and the value
            // are needed, the path being an index into an array of value types.
<span class="nc" id="L447">            ((UserType)type).validateCell(cell);</span>
        }
        else
        {
<span class="fc" id="L451">            type.validateCellValue(cell.value(), cell.accessor());</span>
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">            if (cell.path() != null)</span>
<span class="nc" id="L453">                validateCellPath(cell.path());</span>
        }
<span class="fc" id="L455">    }</span>

    private void validateCellPath(CellPath path)
    {
<span class="nc bnc" id="L459" title="All 2 branches missed.">        if (!isComplex())</span>
<span class="nc" id="L460">            throw new MarshalException(&quot;Only complex cells should have a cell path&quot;);</span>

<span class="nc bnc" id="L462" title="All 2 branches missed.">        assert type.isMultiCell();</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">        if (type.isCollection())</span>
<span class="nc" id="L464">            ((CollectionType)type).nameComparator().validate(path.get(0));</span>
        else
<span class="nc" id="L466">            ((UserType)type).nameComparator().validate(path.get(0));</span>
<span class="nc" id="L467">    }</span>

    public void appendCqlTo(CqlBuilder builder)
    {
<span class="nc" id="L471">        builder.append(name)</span>
<span class="nc" id="L472">               .append(' ')</span>
<span class="nc" id="L473">               .append(type);</span>

<span class="nc bnc" id="L475" title="All 2 branches missed.">        if (isStatic())</span>
<span class="nc" id="L476">            builder.append(&quot; static&quot;);</span>

<span class="nc bnc" id="L478" title="All 2 branches missed.">        if (isMasked())</span>
<span class="nc" id="L479">            mask.appendCqlTo(builder);</span>
<span class="nc" id="L480">    }</span>

    public static String toCQLString(Iterable&lt;ColumnMetadata&gt; defs)
    {
<span class="nc" id="L484">        return toCQLString(defs.iterator());</span>
    }

    public static String toCQLString(Iterator&lt;ColumnMetadata&gt; defs)
    {
<span class="nc bnc" id="L489" title="All 2 branches missed.">        if (!defs.hasNext())</span>
<span class="nc" id="L490">            return &quot;&quot;;</span>

<span class="nc" id="L492">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L493">        sb.append(defs.next().name.toCQLString());</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">        while (defs.hasNext())</span>
<span class="nc" id="L495">            sb.append(&quot;, &quot;).append(defs.next().name.toCQLString());</span>
<span class="nc" id="L496">        return sb.toString();</span>
    }


    public void appendNameAndOrderTo(CqlBuilder builder)
    {
<span class="nc" id="L502">        builder.append(name.toCQLString())</span>
<span class="nc" id="L503">               .append(' ')</span>
<span class="nc" id="L504">               .append(clusteringOrder().toString());</span>
<span class="nc" id="L505">    }</span>

    /**
     * The type of the cell values for cell belonging to this column.
     *
     * This is the same than the column type, except for non-frozen collections where it's the 'valueComparator'
     * of the collection.
     * 
     * This method should not be used to get value type of non-frozon UDT.
     */
    public AbstractType&lt;?&gt; cellValueType()
    {
<span class="nc bnc" id="L517" title="All 4 branches missed.">        assert !(type instanceof UserType &amp;&amp; type.isMultiCell());</span>
<span class="nc bnc" id="L518" title="All 4 branches missed.">        return type instanceof CollectionType &amp;&amp; type.isMultiCell()</span>
<span class="nc" id="L519">                ? ((CollectionType)type).valueComparator()</span>
<span class="nc" id="L520">                : type;</span>
    }

    /**
     * Check if column is counter type.
     */
    public boolean isCounterColumn()
    {
<span class="fc bfc" id="L528" title="All 2 branches covered.">        if (type instanceof CollectionType) // Possible with, for example, supercolumns</span>
<span class="fc" id="L529">            return ((CollectionType) type).valueComparator().isCounter();</span>
<span class="fc" id="L530">        return type.isCounter();</span>
    }

    public Selector.Factory newSelectorFactory(TableMetadata table, AbstractType&lt;?&gt; expectedType, List&lt;ColumnMetadata&gt; defs, VariableSpecifications boundNames) throws InvalidRequestException
    {
<span class="fc" id="L535">        return SimpleSelector.newFactory(this, addAndGetIndex(this, defs), false);</span>
    }

    public AbstractType&lt;?&gt; getExactTypeIfKnown(String keyspace)
    {
<span class="nc" id="L540">        return type;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>