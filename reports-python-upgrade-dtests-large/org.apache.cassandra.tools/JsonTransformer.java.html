<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JsonTransformer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.tools</a> &gt; <span class="el_source">JsonTransformer.java</span></div><h1>JsonTransformer.java</h1><pre class="source lang-java linenums">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.cassandra.tools;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.stream.Stream;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;
import com.fasterxml.jackson.core.util.DefaultPrettyPrinter.Indenter;
import com.fasterxml.jackson.core.util.MinimalPrettyPrinter;
import org.apache.cassandra.db.ClusteringBound;
import org.apache.cassandra.db.ClusteringPrefix;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.DeletionTime;
import org.apache.cassandra.db.LivenessInfo;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.marshal.CollectionType;
import org.apache.cassandra.db.marshal.CompositeType;
import org.apache.cassandra.db.marshal.UserType;
import org.apache.cassandra.db.rows.Cell;
import org.apache.cassandra.db.rows.ColumnData;
import org.apache.cassandra.db.rows.ComplexColumnData;
import org.apache.cassandra.db.rows.RangeTombstoneBoundMarker;
import org.apache.cassandra.db.rows.RangeTombstoneBoundaryMarker;
import org.apache.cassandra.db.rows.RangeTombstoneMarker;
import org.apache.cassandra.db.rows.Row;
import org.apache.cassandra.db.rows.Unfiltered;
import org.apache.cassandra.db.rows.UnfilteredRowIterator;
import org.apache.cassandra.io.sstable.ISSTableScanner;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.transport.ProtocolVersion;
import org.apache.cassandra.utils.ByteBufferUtil;

import static org.apache.cassandra.utils.Clock.Global.currentTimeMillis;

public final class JsonTransformer
{

<span class="nc" id="L70">    private static final Logger logger = LoggerFactory.getLogger(JsonTransformer.class);</span>

<span class="nc" id="L72">    private static final JsonFactory jsonFactory = new JsonFactory();</span>

    private final JsonGenerator json;

<span class="nc" id="L76">    private final CompactIndenter objectIndenter = new CompactIndenter();</span>

<span class="nc" id="L78">    private final CompactIndenter arrayIndenter = new CompactIndenter();</span>

    private final TableMetadata metadata;

    private final ISSTableScanner currentScanner;

<span class="nc" id="L84">    private boolean rawTime = false;</span>

<span class="nc" id="L86">    private long currentPosition = 0;</span>

    private JsonTransformer(JsonGenerator json, ISSTableScanner currentScanner, boolean rawTime, TableMetadata metadata, boolean isJsonLines)
<span class="nc" id="L89">    {</span>
<span class="nc" id="L90">        this.json = json;</span>
<span class="nc" id="L91">        this.metadata = metadata;</span>
<span class="nc" id="L92">        this.currentScanner = currentScanner;</span>
<span class="nc" id="L93">        this.rawTime = rawTime;</span>

<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (isJsonLines)</span>
        {
<span class="nc" id="L97">            MinimalPrettyPrinter minimalPrettyPrinter = new MinimalPrettyPrinter();</span>
<span class="nc" id="L98">            minimalPrettyPrinter.setRootValueSeparator(&quot;\n&quot;);</span>
<span class="nc" id="L99">            json.setPrettyPrinter(minimalPrettyPrinter);</span>
<span class="nc" id="L100">        }</span>
        else
        {
<span class="nc" id="L103">            DefaultPrettyPrinter prettyPrinter = new DefaultPrettyPrinter();</span>
<span class="nc" id="L104">            prettyPrinter.indentObjectsWith(objectIndenter);</span>
<span class="nc" id="L105">            prettyPrinter.indentArraysWith(arrayIndenter);</span>
<span class="nc" id="L106">            json.setPrettyPrinter(prettyPrinter);</span>
        }
<span class="nc" id="L108">    }</span>

    public static void toJson(ISSTableScanner currentScanner, Stream&lt;UnfilteredRowIterator&gt; partitions, boolean rawTime, TableMetadata metadata, OutputStream out)
            throws IOException
    {
<span class="nc" id="L113">        try (JsonGenerator json = jsonFactory.createGenerator(new OutputStreamWriter(out, StandardCharsets.UTF_8)))</span>
        {
<span class="nc" id="L115">            JsonTransformer transformer = new JsonTransformer(json, currentScanner, rawTime, metadata, false);</span>
<span class="nc" id="L116">            json.writeStartArray();</span>
<span class="nc" id="L117">            partitions.forEach(transformer::serializePartition);</span>
<span class="nc" id="L118">            json.writeEndArray();</span>
        }
<span class="nc" id="L120">    }</span>

    public static void toJsonLines(ISSTableScanner currentScanner, Stream&lt;UnfilteredRowIterator&gt; partitions, boolean rawTime, TableMetadata metadata, OutputStream out)
            throws IOException
    {
<span class="nc" id="L125">        try (JsonGenerator json = jsonFactory.createGenerator(new OutputStreamWriter(out, StandardCharsets.UTF_8)))</span>
        {
<span class="nc" id="L127">            JsonTransformer transformer = new JsonTransformer(json, currentScanner, rawTime, metadata, true);</span>
<span class="nc" id="L128">            partitions.forEach(transformer::serializePartition);</span>
        }
<span class="nc" id="L130">    }</span>

    public static void keysToJson(ISSTableScanner currentScanner, Stream&lt;DecoratedKey&gt; keys, boolean rawTime, TableMetadata metadata, OutputStream out) throws IOException
    {
<span class="nc" id="L134">        try (JsonGenerator json = jsonFactory.createGenerator(new OutputStreamWriter(out, StandardCharsets.UTF_8)))</span>
        {
<span class="nc" id="L136">            JsonTransformer transformer = new JsonTransformer(json, currentScanner, rawTime, metadata, false);</span>
<span class="nc" id="L137">            json.writeStartArray();</span>
<span class="nc" id="L138">            keys.forEach(transformer::serializePartitionKey);</span>
<span class="nc" id="L139">            json.writeEndArray();</span>
        }
<span class="nc" id="L141">    }</span>

    private void updatePosition()
    {
<span class="nc" id="L145">        this.currentPosition = currentScanner.getCurrentPosition();</span>
<span class="nc" id="L146">    }</span>

    private void serializePartitionKey(DecoratedKey key)
    {
<span class="nc" id="L150">        AbstractType&lt;?&gt; keyValidator = metadata.partitionKeyType;</span>
<span class="nc" id="L151">        objectIndenter.setCompact(true);</span>
        try
        {
<span class="nc" id="L154">            arrayIndenter.setCompact(true);</span>
<span class="nc" id="L155">            json.writeStartArray();</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">            if (keyValidator instanceof CompositeType)</span>
            {
                // if a composite type, the partition has multiple keys.
<span class="nc" id="L159">                CompositeType compositeType = (CompositeType) keyValidator;</span>
<span class="nc" id="L160">                ByteBuffer keyBytes = key.getKey().duplicate();</span>
                // Skip static data if it exists.
<span class="nc bnc" id="L162" title="All 2 branches missed.">                if (keyBytes.remaining() &gt;= 2)</span>
                {
<span class="nc" id="L164">                    int header = ByteBufferUtil.getShortLength(keyBytes, keyBytes.position());</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">                    if ((header &amp; 0xFFFF) == 0xFFFF)</span>
                    {
<span class="nc" id="L167">                        ByteBufferUtil.readShortLength(keyBytes);</span>
                    }
                }

<span class="nc" id="L171">                int i = 0;</span>
<span class="nc bnc" id="L172" title="All 4 branches missed.">                while (keyBytes.remaining() &gt; 0 &amp;&amp; i &lt; compositeType.getComponents().size())</span>
                {
<span class="nc" id="L174">                    AbstractType&lt;?&gt; colType = compositeType.getComponents().get(i);</span>

<span class="nc" id="L176">                    ByteBuffer value = ByteBufferUtil.readBytesWithShortLength(keyBytes);</span>
<span class="nc" id="L177">                    String colValue = colType.getString(value);</span>

<span class="nc" id="L179">                    json.writeString(colValue);</span>

<span class="nc" id="L181">                    byte b = keyBytes.get();</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">                    if (b != 0)</span>
                    {
<span class="nc" id="L184">                        break;</span>
                    }
<span class="nc" id="L186">                    ++i;</span>
<span class="nc" id="L187">                }</span>
<span class="nc" id="L188">            }</span>
            else
            {
                // if not a composite type, assume a single column partition key.
<span class="nc bnc" id="L192" title="All 2 branches missed.">                assert metadata.partitionKeyColumns().size() == 1;</span>
<span class="nc" id="L193">                json.writeString(keyValidator.getString(key.getKey()));</span>
            }
<span class="nc" id="L195">            json.writeEndArray();</span>
<span class="nc" id="L196">            objectIndenter.setCompact(false);</span>
<span class="nc" id="L197">            arrayIndenter.setCompact(false);</span>
        }
<span class="nc" id="L199">        catch (IOException e)</span>
        {
<span class="nc" id="L201">            logger.error(&quot;Failure serializing partition key.&quot;, e);</span>
<span class="nc" id="L202">        }</span>
<span class="nc" id="L203">    }</span>

    private void serializePartition(UnfilteredRowIterator partition)
    {
        try
        {
<span class="nc" id="L209">            json.writeStartObject();</span>
<span class="nc" id="L210">            json.writeObjectField(&quot;table kind&quot;, metadata.kind.name());</span>
            
<span class="nc" id="L212">            json.writeFieldName(&quot;partition&quot;);</span>
<span class="nc" id="L213">            json.writeStartObject();</span>
<span class="nc" id="L214">            json.writeFieldName(&quot;key&quot;);</span>
<span class="nc" id="L215">            serializePartitionKey(partition.partitionKey());</span>
<span class="nc" id="L216">            json.writeNumberField(&quot;position&quot;, this.currentScanner.getCurrentPosition());</span>

<span class="nc bnc" id="L218" title="All 2 branches missed.">            if (!partition.partitionLevelDeletion().isLive())</span>
<span class="nc" id="L219">                serializeDeletion(partition.partitionLevelDeletion());</span>

<span class="nc" id="L221">            json.writeEndObject();</span>

<span class="nc" id="L223">            json.writeFieldName(&quot;rows&quot;);</span>
<span class="nc" id="L224">            json.writeStartArray();</span>
<span class="nc" id="L225">            updatePosition();</span>

<span class="nc bnc" id="L227" title="All 2 branches missed.">            if (partition.staticRow() != null)</span>
            {
<span class="nc bnc" id="L229" title="All 2 branches missed.">                if (!partition.staticRow().isEmpty())</span>
<span class="nc" id="L230">                    serializeRow(partition.staticRow());</span>
<span class="nc" id="L231">                updatePosition();</span>
            }

            Unfiltered unfiltered;
<span class="nc bnc" id="L235" title="All 2 branches missed.">            while (partition.hasNext())</span>
            {
<span class="nc" id="L237">                unfiltered = partition.next();</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">                if (unfiltered instanceof Row)</span>
                {
<span class="nc" id="L240">                    serializeRow((Row) unfiltered);</span>
                }
<span class="nc bnc" id="L242" title="All 2 branches missed.">                else if (unfiltered instanceof RangeTombstoneMarker)</span>
                {
<span class="nc" id="L244">                    serializeTombstone((RangeTombstoneMarker) unfiltered);</span>
                }
<span class="nc" id="L246">                updatePosition();</span>
            }

<span class="nc" id="L249">            json.writeEndArray();</span>

<span class="nc" id="L251">            json.writeEndObject();</span>
        }

<span class="nc" id="L254">        catch (IOException e)</span>
        {
<span class="nc" id="L256">            String key = metadata.partitionKeyType.getString(partition.partitionKey().getKey());</span>
<span class="nc" id="L257">            logger.error(&quot;Fatal error parsing partition: {}&quot;, key, e);</span>
<span class="nc" id="L258">        }</span>
<span class="nc" id="L259">    }</span>

    private void serializeRow(Row row)
    {
        try
        {
<span class="nc" id="L265">            json.writeStartObject();</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">            String rowType = row.isStatic() ? &quot;static_block&quot; : &quot;row&quot;;</span>
<span class="nc" id="L267">            json.writeFieldName(&quot;type&quot;);</span>
<span class="nc" id="L268">            json.writeString(rowType);</span>
<span class="nc" id="L269">            json.writeNumberField(&quot;position&quot;, this.currentPosition);</span>

            // Only print clustering information for non-static rows.
<span class="nc bnc" id="L272" title="All 2 branches missed.">            if (!row.isStatic())</span>
            {
<span class="nc" id="L274">                serializeClustering(row.clustering());</span>
            }

<span class="nc" id="L277">            LivenessInfo liveInfo = row.primaryKeyLivenessInfo();</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">            if (!liveInfo.isEmpty())</span>
            {
<span class="nc" id="L280">                objectIndenter.setCompact(false);</span>
<span class="nc" id="L281">                json.writeFieldName(&quot;liveness_info&quot;);</span>
<span class="nc" id="L282">                objectIndenter.setCompact(true);</span>
<span class="nc" id="L283">                json.writeStartObject();</span>
<span class="nc" id="L284">                json.writeFieldName(&quot;tstamp&quot;);</span>
<span class="nc" id="L285">                json.writeString(dateString(TimeUnit.MICROSECONDS, liveInfo.timestamp()));</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">                if (liveInfo.isExpiring())</span>
                {
<span class="nc" id="L288">                    json.writeNumberField(&quot;ttl&quot;, liveInfo.ttl());</span>
<span class="nc" id="L289">                    json.writeFieldName(&quot;expires_at&quot;);</span>
<span class="nc" id="L290">                    json.writeString(dateString(TimeUnit.SECONDS, liveInfo.localExpirationTime()));</span>
<span class="nc" id="L291">                    json.writeFieldName(&quot;expired&quot;);</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">                    json.writeBoolean(liveInfo.localExpirationTime() &lt; (currentTimeMillis() / 1000));</span>
                }
<span class="nc" id="L294">                json.writeEndObject();</span>
<span class="nc" id="L295">                objectIndenter.setCompact(false);</span>
            }

            // If this is a deletion, indicate that, otherwise write cells.
<span class="nc bnc" id="L299" title="All 2 branches missed.">            if (!row.deletion().isLive())</span>
            {
<span class="nc" id="L301">                serializeDeletion(row.deletion().time());</span>
            }
<span class="nc" id="L303">            json.writeFieldName(&quot;cells&quot;);</span>
<span class="nc" id="L304">            json.writeStartArray();</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">            for (ColumnData cd : row)</span>
            {
<span class="nc" id="L307">                serializeColumnData(cd, liveInfo);</span>
<span class="nc" id="L308">            }</span>
<span class="nc" id="L309">            json.writeEndArray();</span>
<span class="nc" id="L310">            json.writeEndObject();</span>
        }
<span class="nc" id="L312">        catch (IOException e)</span>
        {
<span class="nc" id="L314">            logger.error(&quot;Fatal error parsing row.&quot;, e);</span>
<span class="nc" id="L315">        }</span>
<span class="nc" id="L316">    }</span>

    private void serializeTombstone(RangeTombstoneMarker tombstone)
    {
        try
        {
<span class="nc" id="L322">            json.writeStartObject();</span>
<span class="nc" id="L323">            json.writeFieldName(&quot;type&quot;);</span>

<span class="nc bnc" id="L325" title="All 2 branches missed.">            if (tombstone instanceof RangeTombstoneBoundMarker)</span>
            {
<span class="nc" id="L327">                json.writeString(&quot;range_tombstone_bound&quot;);</span>
<span class="nc" id="L328">                RangeTombstoneBoundMarker bm = (RangeTombstoneBoundMarker) tombstone;</span>
<span class="nc" id="L329">                serializeBound(bm.clustering(), bm.deletionTime());</span>
<span class="nc" id="L330">            }</span>
            else
            {
<span class="nc bnc" id="L333" title="All 2 branches missed.">                assert tombstone instanceof RangeTombstoneBoundaryMarker;</span>
<span class="nc" id="L334">                json.writeString(&quot;range_tombstone_boundary&quot;);</span>
<span class="nc" id="L335">                RangeTombstoneBoundaryMarker bm = (RangeTombstoneBoundaryMarker) tombstone;</span>
<span class="nc" id="L336">                serializeBound(bm.openBound(false), bm.openDeletionTime(false));</span>
<span class="nc" id="L337">                serializeBound(bm.closeBound(false), bm.closeDeletionTime(false));</span>
            }
<span class="nc" id="L339">            json.writeEndObject();</span>
<span class="nc" id="L340">            objectIndenter.setCompact(false);</span>
        }
<span class="nc" id="L342">        catch (IOException e)</span>
        {
<span class="nc" id="L344">            logger.error(&quot;Failure parsing tombstone.&quot;, e);</span>
<span class="nc" id="L345">        }</span>
<span class="nc" id="L346">    }</span>

    private void serializeBound(ClusteringBound&lt;?&gt; bound, DeletionTime deletionTime) throws IOException
    {
<span class="nc bnc" id="L350" title="All 2 branches missed.">        json.writeFieldName(bound.isStart() ? &quot;start&quot; : &quot;end&quot;);</span>
<span class="nc" id="L351">        json.writeStartObject();</span>
<span class="nc" id="L352">        json.writeFieldName(&quot;type&quot;);</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">        json.writeString(bound.isInclusive() ? &quot;inclusive&quot; : &quot;exclusive&quot;);</span>
<span class="nc" id="L354">        serializeClustering(bound.clustering());</span>
<span class="nc" id="L355">        serializeDeletion(deletionTime);</span>
<span class="nc" id="L356">        json.writeEndObject();</span>
<span class="nc" id="L357">    }</span>

    private &lt;T&gt; void serializeClustering(ClusteringPrefix&lt;T&gt; clustering) throws IOException
    {
<span class="nc bnc" id="L361" title="All 2 branches missed.">        if (clustering.size() &gt; 0)</span>
        {
<span class="nc" id="L363">            json.writeFieldName(&quot;clustering&quot;);</span>
<span class="nc" id="L364">            objectIndenter.setCompact(true);</span>
<span class="nc" id="L365">            json.writeStartArray();</span>
<span class="nc" id="L366">            arrayIndenter.setCompact(true);</span>
<span class="nc" id="L367">            List&lt;ColumnMetadata&gt; clusteringColumns = metadata.clusteringColumns();</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">            for (int i = 0; i &lt; clusteringColumns.size(); i++)</span>
            {
<span class="nc" id="L370">                ColumnMetadata column = clusteringColumns.get(i);</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">                if (i &gt;= clustering.size())</span>
                {
<span class="nc" id="L373">                    json.writeString(&quot;*&quot;);</span>
                }
                else
                {
<span class="nc" id="L377">                    AbstractType&lt;?&gt; type = column.cellValueType();</span>
<span class="nc" id="L378">                    json.writeRawValue(type.toJSONString(clustering.get(i), clustering.accessor(), ProtocolVersion.CURRENT));</span>
                }
            }
<span class="nc" id="L381">            json.writeEndArray();</span>
<span class="nc" id="L382">            objectIndenter.setCompact(false);</span>
<span class="nc" id="L383">            arrayIndenter.setCompact(false);</span>
        }
<span class="nc" id="L385">    }</span>

    private void serializeDeletion(DeletionTime deletion) throws IOException
    {
<span class="nc" id="L389">        json.writeFieldName(&quot;deletion_info&quot;);</span>
<span class="nc" id="L390">        objectIndenter.setCompact(true);</span>
<span class="nc" id="L391">        json.writeStartObject();</span>
<span class="nc" id="L392">        json.writeFieldName(&quot;marked_deleted&quot;);</span>
<span class="nc" id="L393">        json.writeString(dateString(TimeUnit.MICROSECONDS, deletion.markedForDeleteAt()));</span>
<span class="nc" id="L394">        json.writeFieldName(&quot;local_delete_time&quot;);</span>
<span class="nc" id="L395">        json.writeString(dateString(TimeUnit.SECONDS, deletion.localDeletionTime()));</span>
<span class="nc" id="L396">        json.writeEndObject();</span>
<span class="nc" id="L397">        objectIndenter.setCompact(false);</span>
<span class="nc" id="L398">    }</span>

    private void serializeColumnData(ColumnData cd, LivenessInfo liveInfo)
    {
<span class="nc bnc" id="L402" title="All 2 branches missed.">        if (cd.column().isSimple())</span>
        {
<span class="nc" id="L404">            serializeCell((Cell&lt;?&gt;) cd, liveInfo);</span>
        }
        else
        {
<span class="nc" id="L408">            ComplexColumnData complexData = (ComplexColumnData) cd;</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">            if (!complexData.complexDeletion().isLive())</span>
            {
                try
                {
<span class="nc" id="L413">                    objectIndenter.setCompact(true);</span>
<span class="nc" id="L414">                    json.writeStartObject();</span>
<span class="nc" id="L415">                    json.writeFieldName(&quot;name&quot;);</span>
<span class="nc" id="L416">                    json.writeString(cd.column().name.toCQLString());</span>
<span class="nc" id="L417">                    serializeDeletion(complexData.complexDeletion());</span>
<span class="nc" id="L418">                    objectIndenter.setCompact(true);</span>
<span class="nc" id="L419">                    json.writeEndObject();</span>
<span class="nc" id="L420">                    objectIndenter.setCompact(false);</span>
                }
<span class="nc" id="L422">                catch (IOException e)</span>
                {
<span class="nc" id="L424">                    logger.error(&quot;Failure parsing ColumnData.&quot;, e);</span>
<span class="nc" id="L425">                }</span>
            }
<span class="nc bnc" id="L427" title="All 2 branches missed.">            for (Cell&lt;?&gt; cell : complexData){</span>
<span class="nc" id="L428">                serializeCell(cell, liveInfo);</span>
<span class="nc" id="L429">            }</span>
        }
<span class="nc" id="L431">    }</span>

    private &lt;V&gt; void serializeCell(Cell&lt;V&gt; cell, LivenessInfo liveInfo)
    {
        try
        {
<span class="nc" id="L437">            json.writeStartObject();</span>
<span class="nc" id="L438">            objectIndenter.setCompact(true);</span>
<span class="nc" id="L439">            json.writeFieldName(&quot;name&quot;);</span>
<span class="nc" id="L440">            AbstractType&lt;?&gt; type = cell.column().type;</span>
<span class="nc" id="L441">            AbstractType&lt;?&gt; cellType = null;</span>
<span class="nc" id="L442">            json.writeString(cell.column().name.toCQLString());</span>

<span class="nc bnc" id="L444" title="All 4 branches missed.">            if (type.isCollection() &amp;&amp; type.isMultiCell()) // non-frozen collection</span>
            {
<span class="nc" id="L446">                CollectionType ct = (CollectionType) type;</span>
<span class="nc" id="L447">                json.writeFieldName(&quot;path&quot;);</span>
<span class="nc" id="L448">                arrayIndenter.setCompact(true);</span>
<span class="nc" id="L449">                json.writeStartArray();</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">                for (int i = 0; i &lt; cell.path().size(); i++)</span>
                {
<span class="nc" id="L452">                    json.writeString(ct.nameComparator().getString(cell.path().get(i)));</span>
                }
<span class="nc" id="L454">                json.writeEndArray();</span>
<span class="nc" id="L455">                arrayIndenter.setCompact(false);</span>

<span class="nc" id="L457">                cellType = cell.column().cellValueType();</span>
<span class="nc" id="L458">            }</span>
<span class="nc bnc" id="L459" title="All 4 branches missed.">            else if (type.isUDT() &amp;&amp; type.isMultiCell()) // non-frozen udt</span>
            {
<span class="nc" id="L461">                UserType ut = (UserType) type;</span>
<span class="nc" id="L462">                json.writeFieldName(&quot;path&quot;);</span>
<span class="nc" id="L463">                arrayIndenter.setCompact(true);</span>
<span class="nc" id="L464">                json.writeStartArray();</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">                for (int i = 0; i &lt; cell.path().size(); i++)</span>
                {
<span class="nc" id="L467">                    Short fieldPosition = ut.nameComparator().compose(cell.path().get(i));</span>
<span class="nc" id="L468">                    json.writeString(ut.fieldNameAsString(fieldPosition));</span>
                }
<span class="nc" id="L470">                json.writeEndArray();</span>
<span class="nc" id="L471">                arrayIndenter.setCompact(false);</span>

                // cellType of udt
<span class="nc" id="L474">                Short fieldPosition = ((UserType) type).nameComparator().compose(cell.path().get(0));</span>
<span class="nc" id="L475">                cellType = ((UserType) type).fieldType(fieldPosition);</span>
<span class="nc" id="L476">            }</span>
            else
            {
<span class="nc" id="L479">                cellType = cell.column().cellValueType();</span>
            }
<span class="nc bnc" id="L481" title="All 2 branches missed.">            if (cell.isTombstone())</span>
            {
<span class="nc" id="L483">                json.writeFieldName(&quot;deletion_info&quot;);</span>
<span class="nc" id="L484">                objectIndenter.setCompact(true);</span>
<span class="nc" id="L485">                json.writeStartObject();</span>
<span class="nc" id="L486">                json.writeFieldName(&quot;local_delete_time&quot;);</span>
<span class="nc" id="L487">                json.writeString(dateString(TimeUnit.SECONDS, cell.localDeletionTime()));</span>
<span class="nc" id="L488">                json.writeEndObject();</span>
<span class="nc" id="L489">                objectIndenter.setCompact(false);</span>
            }
            else
            {
<span class="nc" id="L493">                json.writeFieldName(&quot;value&quot;);</span>
<span class="nc" id="L494">                json.writeRawValue(cellType.toJSONString(cell.value(), cell.accessor(), ProtocolVersion.CURRENT));</span>
            }
<span class="nc bnc" id="L496" title="All 4 branches missed.">            if (liveInfo.isEmpty() || cell.timestamp() != liveInfo.timestamp())</span>
            {
<span class="nc" id="L498">                json.writeFieldName(&quot;tstamp&quot;);</span>
<span class="nc" id="L499">                json.writeString(dateString(TimeUnit.MICROSECONDS, cell.timestamp()));</span>
            }
<span class="nc bnc" id="L501" title="All 6 branches missed.">            if (cell.isExpiring() &amp;&amp; (liveInfo.isEmpty() || cell.ttl() != liveInfo.ttl()))</span>
            {
<span class="nc" id="L503">                json.writeFieldName(&quot;ttl&quot;);</span>
<span class="nc" id="L504">                json.writeNumber(cell.ttl());</span>
<span class="nc" id="L505">                json.writeFieldName(&quot;expires_at&quot;);</span>
<span class="nc" id="L506">                json.writeString(dateString(TimeUnit.SECONDS, cell.localDeletionTime()));</span>
<span class="nc" id="L507">                json.writeFieldName(&quot;expired&quot;);</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">                json.writeBoolean(!cell.isLive((int) (currentTimeMillis() / 1000)));</span>
            }
<span class="nc" id="L510">            json.writeEndObject();</span>
<span class="nc" id="L511">            objectIndenter.setCompact(false);</span>
        }
<span class="nc" id="L513">        catch (IOException e)</span>
        {
<span class="nc" id="L515">            logger.error(&quot;Failure parsing cell.&quot;, e);</span>
<span class="nc" id="L516">        }</span>
<span class="nc" id="L517">    }</span>

    private String dateString(TimeUnit from, long time)
    {
<span class="nc bnc" id="L521" title="All 2 branches missed.">        if (rawTime)</span>
        {
<span class="nc" id="L523">            return Long.toString(time);</span>
        }
        
<span class="nc" id="L526">        long secs = from.toSeconds(time);</span>
<span class="nc" id="L527">        long offset = Math.floorMod(from.toNanos(time), 1000_000_000L); // nanos per sec</span>
<span class="nc" id="L528">        return Instant.ofEpochSecond(secs, offset).toString();</span>
    }

    /**
     * A specialized {@link Indenter} that enables a 'compact' mode which puts all subsequent json values on the same
     * line. This is manipulated via {@link CompactIndenter#setCompact(boolean)}
     */
    private static final class CompactIndenter extends DefaultPrettyPrinter.NopIndenter
    {

        private static final int INDENT_LEVELS = 16;
        private final char[] indents;
        private final int charsPerLevel;
        private final String eol;
        private static final String space = &quot; &quot;;

<span class="nc" id="L544">        private boolean compact = false;</span>

        CompactIndenter()
        {
<span class="nc" id="L548">            this(&quot;  &quot;, System.lineSeparator());</span>
<span class="nc" id="L549">        }</span>

        CompactIndenter(String indent, String eol)
<span class="nc" id="L552">        {</span>
<span class="nc" id="L553">            this.eol = eol;</span>

<span class="nc" id="L555">            charsPerLevel = indent.length();</span>

<span class="nc" id="L557">            indents = new char[indent.length() * INDENT_LEVELS];</span>
<span class="nc" id="L558">            int offset = 0;</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">            for (int i = 0; i &lt; INDENT_LEVELS; i++)</span>
            {
<span class="nc" id="L561">                indent.getChars(0, indent.length(), indents, offset);</span>
<span class="nc" id="L562">                offset += indent.length();</span>
            }
<span class="nc" id="L564">        }</span>

        @Override
        public boolean isInline()
        {
<span class="nc" id="L569">            return false;</span>
        }

        /**
         * Configures whether or not subsequent json values should be on the same line delimited by string or not.
         *
         * @param compact
         *            Whether or not to compact.
         */
        public void setCompact(boolean compact)
        {
<span class="nc" id="L580">            this.compact = compact;</span>
<span class="nc" id="L581">        }</span>

        @Override
        public void writeIndentation(JsonGenerator jg, int level)
        {
            try
            {
<span class="nc bnc" id="L588" title="All 2 branches missed.">                if (!compact)</span>
                {
<span class="nc" id="L590">                    jg.writeRaw(eol);</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">                    if (level &gt; 0)</span>
                    { // should we err on negative values (as there's some flaw?)
<span class="nc" id="L593">                        level *= charsPerLevel;</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">                        while (level &gt; indents.length)</span>
                        { // unlike to happen but just in case
<span class="nc" id="L596">                            jg.writeRaw(indents, 0, indents.length);</span>
<span class="nc" id="L597">                            level -= indents.length;</span>
                        }
<span class="nc" id="L599">                        jg.writeRaw(indents, 0, level);</span>
                    }
                }
                else
                {
<span class="nc" id="L604">                    jg.writeRaw(space);</span>
                }
            }
<span class="nc" id="L607">            catch (IOException e)</span>
            {
<span class="nc" id="L609">                e.printStackTrace();</span>
<span class="nc" id="L610">                System.exit(1);</span>
<span class="nc" id="L611">            }</span>
<span class="nc" id="L612">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>