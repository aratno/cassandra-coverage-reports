<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StartupChecks.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.service</a> &gt; <span class="el_source">StartupChecks.java</span></div><h1>StartupChecks.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.service;

import java.io.BufferedReader;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;
import java.nio.file.FileStore;
import java.nio.file.FileVisitResult;
import java.nio.file.FileVisitor;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Joiner;
import com.google.common.base.Throwables;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import net.jpountz.lz4.LZ4Factory;
import org.apache.cassandra.config.CassandraRelevantProperties;
import org.apache.cassandra.config.Config;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.config.StartupChecksOptions;
import org.apache.cassandra.cql3.QueryProcessor;
import org.apache.cassandra.cql3.UntypedResultSet;
import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.Directories;
import org.apache.cassandra.db.SystemKeyspace;
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.exceptions.StartupException;
import org.apache.cassandra.io.sstable.Descriptor;
import org.apache.cassandra.io.sstable.UUIDBasedSSTableId;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.io.util.PathUtils;
import org.apache.cassandra.schema.Schema;
import org.apache.cassandra.schema.SchemaConstants;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.JavaUtils;
import org.apache.cassandra.utils.NativeLibrary;
import org.apache.cassandra.utils.SigarLibrary;

import static org.apache.cassandra.config.CassandraRelevantProperties.CASSANDRA_JMX_LOCAL_PORT;
import static org.apache.cassandra.config.CassandraRelevantProperties.COM_SUN_MANAGEMENT_JMXREMOTE_PORT;
import static org.apache.cassandra.config.CassandraRelevantProperties.JAVA_VERSION;
import static org.apache.cassandra.config.CassandraRelevantProperties.JAVA_VM_NAME;
import static org.apache.cassandra.utils.Clock.Global.currentTimeMillis;

/**
 * Verifies that the system and environment is in a fit state to be started.
 * Used in CassandraDaemon#setup() to check various settings and invariants.
 *
 * Each individual test is modelled as an implementation of StartupCheck, these are run
 * at the start of CassandraDaemon#setup() before any local state is mutated. The default
 * checks are a mix of informational tests (inspectJvmOptions), initialization
 * (initSigarLibrary, checkCacheServiceInitialization) and invariant checking
 * (checkValidLaunchDate, checkSystemKeyspaceState, checkSSTablesFormat).
 *
 * In addition, if checkSystemKeyspaceState determines that the release version has
 * changed since last startup (i.e. the node has been upgraded) it snapshots the system
 * keyspace to make it easier to back out if necessary.
 *
 * If any check reports a failure, then the setup method exits with an error (after
 * logging any output from the tests). If all tests report success, setup can continue.
 * We should be careful in future to ensure anything which mutates local state (such as
 * writing new sstables etc) only happens after we've verified the initial setup.
 */
<span class="fc" id="L101">public class StartupChecks</span>
{
<span class="fc" id="L103">    public enum StartupCheckType</span>
    {
        // non-configurable check is always enabled for execution
<span class="fc" id="L106">        non_configurable_check,</span>
<span class="fc" id="L107">        check_filesystem_ownership(true),</span>
<span class="fc" id="L108">        check_dc,</span>
<span class="fc" id="L109">        check_rack,</span>
<span class="fc" id="L110">        check_data_resurrection(true);</span>

        public final boolean disabledByDefault;

        StartupCheckType()
        {
<span class="fc" id="L116">            this(false);</span>
<span class="fc" id="L117">        }</span>

        StartupCheckType(boolean disabledByDefault)
<span class="fc" id="L120">        {</span>
<span class="fc" id="L121">            this.disabledByDefault = disabledByDefault;</span>
<span class="fc" id="L122">        }</span>
    }

<span class="fc" id="L125">    private static final Logger logger = LoggerFactory.getLogger(StartupChecks.class);</span>
    // List of checks to run before starting up. If any test reports failure, startup will be halted.
<span class="fc" id="L127">    private final List&lt;StartupCheck&gt; preFlightChecks = new ArrayList&lt;&gt;();</span>

    // The default set of pre-flight checks to run. Order is somewhat significant in that we probably
    // always want the system keyspace check run last, as this actually loads the schema for that
    // keyspace. All other checks should not require any schema initialization.
<span class="fc" id="L132">    private final List&lt;StartupCheck&gt; DEFAULT_TESTS = ImmutableList.of(checkJemalloc,</span>
                                                                      checkLz4Native,
                                                                      checkValidLaunchDate,
                                                                      checkJMXPorts,
                                                                      checkJMXProperties,
                                                                      inspectJvmOptions,
                                                                      checkNativeLibraryInitialization,
                                                                      initSigarLibrary,
                                                                      checkMaxMapCount,
                                                                      checkReadAheadKbSetting,
                                                                      checkDataDirs,
                                                                      checkSSTablesFormat,
                                                                      checkSystemKeyspaceState,
                                                                      checkDatacenter,
                                                                      checkRack,
                                                                      checkLegacyAuthTables,
                                                                      new DataResurrectionCheck());

    public StartupChecks withDefaultTests()
    {
<span class="fc" id="L152">        preFlightChecks.addAll(DEFAULT_TESTS);</span>
<span class="fc" id="L153">        return this;</span>
    }

    /**
     * Add system test to be run before schema is loaded during startup
     * @param test the system test to include
     */
    public StartupChecks withTest(StartupCheck test)
    {
<span class="fc" id="L162">        preFlightChecks.add(test);</span>
<span class="fc" id="L163">        return this;</span>
    }

    /**
     * Run the configured tests and return a report detailing the results.
     * @throws StartupException if any test determines that the
     * system is not in an valid state to startup
     * @param options options to pass to respective checks for their configration
     */
    public void verify(StartupChecksOptions options) throws StartupException
    {
<span class="fc bfc" id="L174" title="All 2 branches covered.">        for (StartupCheck test : preFlightChecks)</span>
<span class="fc" id="L175">            test.execute(options);</span>

<span class="fc bfc" id="L177" title="All 2 branches covered.">        for (StartupCheck test : preFlightChecks)</span>
        {
            try
            {
<span class="fc" id="L181">                test.postAction(options);</span>
            }
<span class="nc" id="L183">            catch (Throwable t)</span>
            {
<span class="nc" id="L185">                logger.warn(&quot;Failed to run startup check post-action on &quot; + test.getStartupCheckType());</span>
<span class="fc" id="L186">            }</span>
<span class="fc" id="L187">        }</span>
<span class="fc" id="L188">    }</span>

<span class="fc" id="L190">    public static final StartupCheck checkJemalloc = new StartupCheck()</span>
<span class="fc" id="L191">    {</span>
        @Override
        public void execute(StartupChecksOptions options)
        {
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">            if (options.isDisabled(getStartupCheckType()))</span>
<span class="nc" id="L196">                return;</span>

<span class="fc" id="L198">            String jemalloc = CassandraRelevantProperties.LIBJEMALLOC.getString();</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">            if (jemalloc == null)</span>
<span class="nc" id="L200">                logger.warn(&quot;jemalloc shared library could not be preloaded to speed up memory allocations&quot;);</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">            else if (&quot;-&quot;.equals(jemalloc))</span>
<span class="fc" id="L202">                logger.info(&quot;jemalloc preload explicitly disabled&quot;);</span>
            else
<span class="nc" id="L204">                logger.info(&quot;jemalloc seems to be preloaded from {}&quot;, jemalloc);</span>
<span class="fc" id="L205">        }</span>
    };

<span class="fc" id="L208">    public static final StartupCheck checkLz4Native = new StartupCheck()</span>
<span class="fc" id="L209">    {</span>
        @Override
        public void execute(StartupChecksOptions options)
        {
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">            if (options.isDisabled(getStartupCheckType()))</span>
<span class="nc" id="L214">                return;</span>
            try
            {
<span class="fc" id="L217">                LZ4Factory.nativeInstance(); // make sure native loads</span>
            }
<span class="nc" id="L219">            catch (AssertionError | LinkageError e)</span>
            {
<span class="nc" id="L221">                logger.warn(&quot;lz4-java was unable to load native libraries; this will lower the performance of lz4 (network/sstables/etc.): {}&quot;, Throwables.getRootCause(e).getMessage());</span>
<span class="fc" id="L222">            }</span>
<span class="fc" id="L223">        }</span>
    };

<span class="fc" id="L226">    public static final StartupCheck checkValidLaunchDate = new StartupCheck()</span>
<span class="fc" id="L227">    {</span>
        /**
         * The earliest legit timestamp a casandra instance could have ever launched.
         * Date roughly taken from http://perspectives.mvdirona.com/2008/07/12/FacebookReleasesCassandraAsOpenSource.aspx
         * We use this to ensure the system clock is at least somewhat correct at startup.
         */
        private static final long EARLIEST_LAUNCH_DATE = 1215820800000L;

        @Override
        public void execute(StartupChecksOptions options) throws StartupException
        {
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">            if (options.isDisabled(getStartupCheckType()))</span>
<span class="nc" id="L239">                return;</span>
<span class="fc" id="L240">            long now = currentTimeMillis();</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">            if (now &lt; EARLIEST_LAUNCH_DATE)</span>
<span class="nc" id="L242">                throw new StartupException(StartupException.ERR_WRONG_MACHINE_STATE,</span>
<span class="nc" id="L243">                                           String.format(&quot;current machine time is %s, but that is seemingly incorrect. exiting now.&quot;,</span>
<span class="nc" id="L244">                                                         new Date(now).toString()));</span>
<span class="fc" id="L245">        }</span>
    };

<span class="fc" id="L248">    public static final StartupCheck checkJMXPorts = new StartupCheck()</span>
<span class="fc" id="L249">    {</span>
        @Override
        public void execute(StartupChecksOptions options)
        {
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">            if (options.isDisabled(getStartupCheckType()))</span>
<span class="nc" id="L254">                return;</span>
<span class="fc" id="L255">            String jmxPort = CassandraRelevantProperties.CASSANDRA_JMX_REMOTE_PORT.getString();</span>
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">            if (jmxPort == null)</span>
            {
<span class="fc" id="L258">                logger.warn(&quot;JMX is not enabled to receive remote connections. Please see cassandra-env.sh for more info.&quot;);</span>
<span class="fc" id="L259">                jmxPort = CassandraRelevantProperties.CASSANDRA_JMX_LOCAL_PORT.toString();</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">                if (jmxPort == null)</span>
<span class="nc" id="L261">                    logger.error(CASSANDRA_JMX_LOCAL_PORT.getKey() + &quot; missing from cassandra-env.sh, unable to start local JMX service.&quot;);</span>
            }
            else
            {
<span class="nc" id="L265">                logger.info(&quot;JMX is enabled to receive remote connections on port: {}&quot;, jmxPort);</span>
            }
<span class="fc" id="L267">        }</span>
    };

<span class="fc" id="L270">    public static final StartupCheck checkJMXProperties = new StartupCheck()</span>
<span class="fc" id="L271">    {</span>
        @Override
        public void execute(StartupChecksOptions options)
        {
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">            if (options.isDisabled(getStartupCheckType()))</span>
<span class="nc" id="L276">                return;</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">            if (COM_SUN_MANAGEMENT_JMXREMOTE_PORT.isPresent())</span>
            {
<span class="nc" id="L279">                logger.warn(&quot;Use of com.sun.management.jmxremote.port at startup is deprecated. &quot; +</span>
                            &quot;Please use cassandra.jmx.remote.port instead.&quot;);
            }
<span class="fc" id="L282">        }</span>
    };

<span class="fc" id="L285">    public static final StartupCheck inspectJvmOptions = new StartupCheck()</span>
<span class="fc" id="L286">    {</span>
        @Override
        public void execute(StartupChecksOptions options)
        {
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">            if (options.isDisabled(getStartupCheckType()))</span>
<span class="nc" id="L291">                return;</span>
            // log warnings for different kinds of sub-optimal JVMs.  tldr use 64-bit Oracle &gt;= 1.6u32
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">            if (!DatabaseDescriptor.hasLargeAddressSpace())</span>
<span class="nc" id="L294">                logger.warn(&quot;32bit JVM detected.  It is recommended to run Cassandra on a 64bit JVM for better performance.&quot;);</span>

<span class="fc" id="L296">            String javaVmName = JAVA_VM_NAME.getString();</span>
<span class="pc bpc" id="L297" title="2 of 4 branches missed.">            if (!(javaVmName.contains(&quot;HotSpot&quot;) || javaVmName.contains(&quot;OpenJDK&quot;)))</span>
            {
<span class="nc" id="L299">                logger.warn(&quot;Non-Oracle JVM detected.  Some features, such as immediate unmap of compacted SSTables, may not work as intended&quot;);</span>
            }
            else
            {
<span class="fc" id="L303">                checkOutOfMemoryHandling();</span>
            }
<span class="fc" id="L305">        }</span>

        /**
         * Checks that the JVM is configured to handle OutOfMemoryError
         */
        private void checkOutOfMemoryHandling()
        {
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">            if (JavaUtils.supportExitOnOutOfMemory(JAVA_VERSION.getString()))</span>
            {
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">                if (!jvmOptionsContainsOneOf(&quot;-XX:OnOutOfMemoryError=&quot;, &quot;-XX:+ExitOnOutOfMemoryError&quot;, &quot;-XX:+CrashOnOutOfMemoryError&quot;))</span>
<span class="nc" id="L315">                    logger.warn(&quot;The JVM is not configured to stop on OutOfMemoryError which can cause data corruption.&quot;</span>
                                + &quot; Use one of the following JVM options to configure the behavior on OutOfMemoryError: &quot;
                                + &quot; -XX:+ExitOnOutOfMemoryError, -XX:+CrashOnOutOfMemoryError, or -XX:OnOutOfMemoryError=\&quot;&lt;cmd args&gt;;&lt;cmd args&gt;\&quot;&quot;);
            }
            else
            {
<span class="nc bnc" id="L321" title="All 2 branches missed.">                if (!jvmOptionsContainsOneOf(&quot;-XX:OnOutOfMemoryError=&quot;))</span>
<span class="nc" id="L322">                    logger.warn(&quot;The JVM is not configured to stop on OutOfMemoryError which can cause data corruption.&quot;</span>
                            + &quot; Either upgrade your JRE to a version greater or equal to 8u92 and use -XX:+ExitOnOutOfMemoryError/-XX:+CrashOnOutOfMemoryError&quot;
                            + &quot; or use -XX:OnOutOfMemoryError=\&quot;&lt;cmd args&gt;;&lt;cmd args&gt;\&quot; on your current JRE.&quot;);
            }
<span class="fc" id="L326">        }</span>

        /**
         * Checks if one of the specified options is being used.
         * @param optionNames The name of the options to check
         * @return {@code true} if one of the specified options is being used, {@code false} otherwise.
         */
        private boolean jvmOptionsContainsOneOf(String... optionNames)
        {
<span class="fc" id="L335">            RuntimeMXBean runtimeMxBean = ManagementFactory.getRuntimeMXBean();</span>
<span class="fc" id="L336">            List&lt;String&gt; inputArguments = runtimeMxBean.getInputArguments();</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">            for (String argument : inputArguments)</span>
            {
<span class="fc bfc" id="L339" title="All 2 branches covered.">                for (String optionName : optionNames)</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">                    if (argument.startsWith(optionName))</span>
<span class="fc" id="L341">                        return true;</span>
<span class="fc" id="L342">            }</span>
<span class="nc" id="L343">            return false;</span>
        }
    };

<span class="fc" id="L347">    public static final StartupCheck checkNativeLibraryInitialization = new StartupCheck()</span>
<span class="fc" id="L348">    {</span>
        @Override
        public void execute(StartupChecksOptions options) throws StartupException
        {
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">            if (options.isDisabled(getStartupCheckType()))</span>
<span class="nc" id="L353">                return;</span>
            // Fail-fast if the native library could not be linked.
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">            if (!NativeLibrary.isAvailable())</span>
<span class="nc" id="L356">                throw new StartupException(StartupException.ERR_WRONG_MACHINE_STATE, &quot;The native library could not be initialized properly. &quot;);</span>
<span class="fc" id="L357">        }</span>
    };

<span class="fc" id="L360">    public static final StartupCheck initSigarLibrary = new StartupCheck()</span>
<span class="fc" id="L361">    {</span>
        @Override
        public void execute(StartupChecksOptions options)
        {
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">            if (options.isDisabled(getStartupCheckType()))</span>
<span class="nc" id="L366">                return;</span>
<span class="fc" id="L367">            SigarLibrary.instance.warnIfRunningInDegradedMode();</span>
<span class="fc" id="L368">        }</span>
    };

<span class="fc" id="L371">    public static final StartupCheck checkReadAheadKbSetting = new StartupCheck()</span>
<span class="fc" id="L372">    {</span>
        // This value is in KB.
        private static final long MAX_RECOMMENDED_READ_AHEAD_KB_SETTING = 128;

        /**
         * Function to get the block device system path(Example: /dev/sda) from the
         * data directories defined in cassandra config.(cassandra.yaml)
         * @param dataDirectories list of data directories from cassandra.yaml
         * @return Map of block device path and data directory
         */
        private Map&lt;String, String&gt; getBlockDevices(String[] dataDirectories) {
<span class="fc" id="L383">            Map&lt;String, String&gt; blockDevices = new HashMap&lt;String, String&gt;();</span>

<span class="fc bfc" id="L385" title="All 2 branches covered.">            for (String dataDirectory : dataDirectories)</span>
            {
                try
                {
<span class="fc" id="L389">                    Path p = File.getPath(dataDirectory);</span>
<span class="fc" id="L390">                    FileStore fs = Files.getFileStore(p);</span>

<span class="fc" id="L392">                    String blockDirectory = fs.name();</span>
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">                    if(StringUtils.isNotEmpty(blockDirectory))</span>
                    {
<span class="fc" id="L395">                        blockDevices.put(blockDirectory, dataDirectory);</span>
                    }
                }
<span class="nc" id="L398">                catch (IOException e)</span>
                {
<span class="nc" id="L400">                    logger.warn(&quot;IO exception while reading file {}.&quot;, dataDirectory, e);</span>
<span class="fc" id="L401">                }</span>
            }
<span class="fc" id="L403">            return blockDevices;</span>
        }

        @Override
        public void execute(StartupChecksOptions options)
        {
<span class="pc bpc" id="L409" title="2 of 4 branches missed.">            if (options.isDisabled(getStartupCheckType()) || !FBUtilities.isLinux)</span>
<span class="nc" id="L410">                return;</span>

<span class="fc" id="L412">            String[] dataDirectories = DatabaseDescriptor.getRawConfig().data_file_directories;</span>
<span class="fc" id="L413">            Map&lt;String, String&gt; blockDevices = getBlockDevices(dataDirectories);</span>

<span class="fc bfc" id="L415" title="All 2 branches covered.">            for (Map.Entry&lt;String, String&gt; entry: blockDevices.entrySet())</span>
            {
<span class="fc" id="L417">                String blockDeviceDirectory = entry.getKey();</span>
<span class="fc" id="L418">                String dataDirectory = entry.getValue();</span>
                try
                {
<span class="fc" id="L421">                    Path readAheadKBPath = StartupChecks.getReadAheadKBPath(blockDeviceDirectory);</span>

<span class="pc bpc" id="L423" title="3 of 4 branches missed.">                    if (readAheadKBPath == null || Files.notExists(readAheadKBPath))</span>
                    {
<span class="fc" id="L425">                        logger.debug(&quot;No 'read_ahead_kb' setting found for device {} of data directory {}.&quot;, blockDeviceDirectory, dataDirectory);</span>
<span class="fc" id="L426">                        continue;</span>
                    }

<span class="nc" id="L429">                    final List&lt;String&gt; data = Files.readAllLines(readAheadKBPath);</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">                    if (data.isEmpty())</span>
<span class="nc" id="L431">                        continue;</span>

<span class="nc" id="L433">                    int readAheadKbSetting = Integer.parseInt(data.get(0));</span>

<span class="nc bnc" id="L435" title="All 2 branches missed.">                    if (readAheadKbSetting &gt; MAX_RECOMMENDED_READ_AHEAD_KB_SETTING)</span>
                    {
<span class="nc" id="L437">                        logger.warn(&quot;Detected high '{}' setting of {} for device '{}' of data directory '{}'. It is &quot; +</span>
                                    &quot;recommended to set this value to 8KB (or lower) on SSDs or 64KB (or lower) on HDDs &quot; +
                                    &quot;to prevent excessive IO usage and page cache churn on read-intensive workloads.&quot;,
<span class="nc" id="L440">                                    readAheadKBPath, readAheadKbSetting, blockDeviceDirectory, dataDirectory);</span>
                    }
                }
<span class="nc" id="L443">                catch (final IOException e)</span>
                {
<span class="nc" id="L445">                    logger.warn(&quot;IO exception while reading file {}.&quot;, blockDeviceDirectory, e);</span>
<span class="nc" id="L446">                }</span>
<span class="nc" id="L447">            }</span>
<span class="fc" id="L448">        }</span>
    };

<span class="fc" id="L451">    public static final StartupCheck checkMaxMapCount = new StartupCheck()</span>
<span class="fc" id="L452">    {</span>
<span class="fc" id="L453">        private final long EXPECTED_MAX_MAP_COUNT = 1048575;</span>
<span class="fc" id="L454">        private final String MAX_MAP_COUNT_PATH = &quot;/proc/sys/vm/max_map_count&quot;;</span>

        private long getMaxMapCount()
        {
<span class="fc" id="L458">            final Path path = File.getPath(MAX_MAP_COUNT_PATH);</span>
<span class="fc" id="L459">            try (final BufferedReader bufferedReader = Files.newBufferedReader(path))</span>
            {
<span class="fc" id="L461">                final String data = bufferedReader.readLine();</span>
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">                if (data != null)</span>
                {
                    try
                    {
<span class="fc" id="L466">                        return Long.parseLong(data);</span>
                    }
<span class="nc" id="L468">                    catch (final NumberFormatException e)</span>
                    {
<span class="nc" id="L470">                        logger.warn(&quot;Unable to parse {}.&quot;, path, e);</span>
                    }
                }
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">            }</span>
<span class="nc" id="L474">            catch (final IOException e)</span>
            {
<span class="nc" id="L476">                logger.warn(&quot;IO exception while reading file {}.&quot;, path, e);</span>
<span class="nc" id="L477">            }</span>
<span class="nc" id="L478">            return -1;</span>
        }

        @Override
        public void execute(StartupChecksOptions options)
        {
<span class="pc bpc" id="L484" title="2 of 4 branches missed.">            if (options.isDisabled(getStartupCheckType()) || !FBUtilities.isLinux)</span>
<span class="nc" id="L485">                return;</span>

<span class="fc bfc" id="L487" title="All 2 branches covered.">            if (DatabaseDescriptor.getDiskAccessMode() == Config.DiskAccessMode.standard &amp;&amp;</span>
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">                DatabaseDescriptor.getIndexAccessMode() == Config.DiskAccessMode.standard)</span>
<span class="nc" id="L489">                return; // no need to check if disk access mode is only standard and not mmap</span>

<span class="fc" id="L491">            long maxMapCount = getMaxMapCount();</span>
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">            if (maxMapCount &lt; EXPECTED_MAX_MAP_COUNT)</span>
<span class="fc" id="L493">                logger.warn(&quot;Maximum number of memory map areas per process (vm.max_map_count) {} &quot; +</span>
                            &quot;is too low, recommended value: {}, you can change it with sysctl.&quot;,
<span class="fc" id="L495">                            maxMapCount, EXPECTED_MAX_MAP_COUNT);</span>
<span class="fc" id="L496">        }</span>
    };

<span class="fc" id="L499">    public static final StartupCheck checkDataDirs = new StartupCheck()</span>
<span class="fc" id="L500">    {</span>
        @Override
        public void execute(StartupChecksOptions options) throws StartupException
        {
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">            if (options.isDisabled(getStartupCheckType()))</span>
<span class="nc" id="L505">                return;</span>
            // check all directories(data, commitlog, saved cache) for existence and permission
<span class="fc" id="L507">            Iterable&lt;String&gt; dirs = Iterables.concat(Arrays.asList(DatabaseDescriptor.getAllDataFileLocations()),</span>
<span class="fc" id="L508">                                                     Arrays.asList(DatabaseDescriptor.getCommitLogLocation(),</span>
<span class="fc" id="L509">                                                                   DatabaseDescriptor.getSavedCachesLocation(),</span>
<span class="fc" id="L510">                                                                   DatabaseDescriptor.getHintsDirectory().absolutePath()));</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">            for (String dataDir : dirs)</span>
            {
<span class="fc" id="L513">                logger.debug(&quot;Checking directory {}&quot;, dataDir);</span>
<span class="fc" id="L514">                File dir = new File(dataDir);</span>

                // check that directories exist.
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">                if (!dir.exists())</span>
                {
<span class="nc" id="L519">                    logger.warn(&quot;Directory {} doesn't exist&quot;, dataDir);</span>
                    // if they don't, failing their creation, stop cassandra.
<span class="nc bnc" id="L521" title="All 2 branches missed.">                    if (!dir.tryCreateDirectories())</span>
<span class="nc" id="L522">                        throw new StartupException(StartupException.ERR_WRONG_DISK_STATE,</span>
                                                   &quot;Has no permission to create directory &quot;+ dataDir);
                }

                // if directories exist verify their permissions
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">                if (!Directories.verifyFullPermissions(dir, dataDir))</span>
<span class="nc" id="L528">                    throw new StartupException(StartupException.ERR_WRONG_DISK_STATE,</span>
                                               &quot;Insufficient permissions on directory &quot; + dataDir);
<span class="fc" id="L530">            }</span>
<span class="fc" id="L531">        }</span>
    };

<span class="fc" id="L534">    public static final StartupCheck checkSSTablesFormat = new StartupCheck()</span>
<span class="fc" id="L535">    {</span>
        @Override
        public void execute(StartupChecksOptions options) throws StartupException
        {
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">            if (options.isDisabled(getStartupCheckType()))</span>
<span class="nc" id="L540">                return;</span>
<span class="fc" id="L541">            final Set&lt;String&gt; invalid = new HashSet&lt;&gt;();</span>
<span class="fc" id="L542">            final Set&lt;String&gt; nonSSTablePaths = new HashSet&lt;&gt;();</span>
<span class="fc" id="L543">            final List&lt;String&gt; withIllegalGenId = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L544">            nonSSTablePaths.add(FileUtils.getCanonicalPath(DatabaseDescriptor.getCommitLogLocation()));</span>
<span class="fc" id="L545">            nonSSTablePaths.add(FileUtils.getCanonicalPath(DatabaseDescriptor.getSavedCachesLocation()));</span>
<span class="fc" id="L546">            nonSSTablePaths.add(FileUtils.getCanonicalPath(DatabaseDescriptor.getHintsDirectory()));</span>

<span class="fc" id="L548">            FileVisitor&lt;Path&gt; sstableVisitor = new SimpleFileVisitor&lt;Path&gt;()</span>
<span class="fc" id="L549">            {</span>
                public FileVisitResult visitFile(Path path, BasicFileAttributes attrs)
                {
<span class="fc" id="L552">                    File file = new File(path);</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">                    if (!Descriptor.isValidFile(file))</span>
<span class="fc" id="L554">                        return FileVisitResult.CONTINUE;</span>

                    try
                    {
<span class="fc" id="L558">                        Descriptor desc = Descriptor.fromFileWithComponent(file, false).left;</span>
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">                        if (!desc.isCompatible())</span>
<span class="nc" id="L560">                            invalid.add(file.toString());</span>

<span class="pc bpc" id="L562" title="2 of 4 branches missed.">                        if (!DatabaseDescriptor.isUUIDSSTableIdentifiersEnabled() &amp;&amp; desc.id instanceof UUIDBasedSSTableId)</span>
<span class="nc" id="L563">                            withIllegalGenId.add(file.toString());</span>
                    }
<span class="nc" id="L565">                    catch (Exception e)</span>
                    {
<span class="nc" id="L567">                        invalid.add(file.toString());</span>
<span class="fc" id="L568">                    }</span>
<span class="fc" id="L569">                    return FileVisitResult.CONTINUE;</span>
                }

                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException
                {
<span class="fc" id="L574">                    String[] nameParts = FileUtils.getCanonicalPath(new File(dir)).split(java.io.File.separator);</span>
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">                    if (nameParts.length &gt;= 2)</span>
                    {
<span class="fc" id="L577">                        String tablePart = nameParts[nameParts.length - 1];</span>
<span class="fc" id="L578">                        String ksPart = nameParts[nameParts.length - 2];</span>

<span class="fc bfc" id="L580" title="All 2 branches covered.">                        if (tablePart.contains(&quot;-&quot;))</span>
<span class="fc" id="L581">                            tablePart = tablePart.split(&quot;-&quot;)[0];</span>

                        // In very old versions of Cassandra, we wouldn't necessarily delete sstables from dropped system tables
                        // which were removed in various major version upgrades (e.g system.Versions in 1.2)
<span class="pc bpc" id="L585" title="1 of 4 branches missed.">                        if (ksPart.equals(SchemaConstants.SYSTEM_KEYSPACE_NAME) &amp;&amp; !SystemKeyspace.ALL_TABLE_NAMES.contains(tablePart))</span>
                        {
<span class="nc" id="L587">                            String canonicalPath = FileUtils.getCanonicalPath(new File(dir));</span>

                            // We can have snapshots of our system tables or snapshots created with a -t tag of &quot;system&quot; that would trigger
                            // this potential warning, so we warn more softly in the case that it's probably a snapshot.
<span class="nc bnc" id="L591" title="All 2 branches missed.">                            if (canonicalPath.contains(&quot;snapshot&quot;))</span>
                            {
<span class="nc" id="L593">                                logger.info(&quot;Found unknown system directory {}.{} at {} that contains the word snapshot. &quot; +</span>
                                            &quot;This may be left over from a previous version of Cassandra or may be normal. &quot; +
                                            &quot; Consider removing after inspection if determined to be unnecessary.&quot;,
                                            ksPart, tablePart, canonicalPath);
                            }
                            else
                            {
<span class="nc" id="L600">                                logger.warn(&quot;Found unknown system directory {}.{} at {} - this is likely left over from a previous &quot; +</span>
                                            &quot;version of Cassandra and should be removed after inspection.&quot;,
                                            ksPart, tablePart, canonicalPath);
                            }
<span class="nc" id="L604">                            return FileVisitResult.SKIP_SUBTREE;</span>
                        }
                    }

<span class="fc" id="L608">                    String name = dir.getFileName().toString();</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">                    return (name.equals(Directories.SNAPSHOT_SUBDIR)</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">                            || name.equals(Directories.BACKUPS_SUBDIR)</span>
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">                            || nonSSTablePaths.contains(PathUtils.toCanonicalPath(dir).toString()))</span>
<span class="fc" id="L612">                           ? FileVisitResult.SKIP_SUBTREE</span>
<span class="fc" id="L613">                           : FileVisitResult.CONTINUE;</span>
                }
            };

<span class="fc bfc" id="L617" title="All 2 branches covered.">            for (String dataDir : DatabaseDescriptor.getAllDataFileLocations())</span>
            {
                try
                {
<span class="fc" id="L621">                    Files.walkFileTree(new File(dataDir).toPath(), sstableVisitor);</span>
                }
<span class="nc" id="L623">                catch (IOException e)</span>
                {
<span class="nc" id="L625">                    throw new StartupException(3, &quot;Unable to verify sstable files on disk&quot;, e);</span>
<span class="fc" id="L626">                }</span>
            }

<span class="pc bpc" id="L629" title="1 of 2 branches missed.">            if (!invalid.isEmpty())</span>
<span class="nc" id="L630">                throw new StartupException(StartupException.ERR_WRONG_DISK_STATE,</span>
<span class="nc" id="L631">                                           String.format(&quot;Detected unreadable sstables %s, please check &quot; +</span>
                                                         &quot;NEWS.txt and ensure that you have upgraded through &quot; +
                                                         &quot;all required intermediate versions, running &quot; +
                                                         &quot;upgradesstables&quot;,
<span class="nc" id="L635">                                                         Joiner.on(&quot;,&quot;).join(invalid)));</span>

<span class="pc bpc" id="L637" title="1 of 2 branches missed.">            if (!withIllegalGenId.isEmpty())</span>
<span class="nc" id="L638">                throw new StartupException(StartupException.ERR_WRONG_CONFIG,</span>
                                           &quot;UUID sstable identifiers are disabled but some sstables have been &quot; +
                                           &quot;created with UUID identifiers. You have to either delete those &quot; +
                                           &quot;sstables or enable UUID based sstable identifers in cassandra.yaml &quot; +
                                           &quot;(uuid_sstable_identifiers_enabled). The list of affected sstables is: &quot; +
<span class="nc" id="L643">                                           Joiner.on(&quot;, &quot;).join(withIllegalGenId) + &quot;. If you decide to delete sstables, &quot; +</span>
                                           &quot;and have that data replicated over other healthy nodes, those will be brought&quot; +
                                           &quot;back during repair&quot;);
<span class="fc" id="L646">        }</span>
    };

<span class="fc" id="L649">    public static final StartupCheck checkSystemKeyspaceState = new StartupCheck()</span>
<span class="fc" id="L650">    {</span>
        @Override
        public void execute(StartupChecksOptions options) throws StartupException
        {
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">            if (options.isDisabled(getStartupCheckType()))</span>
<span class="nc" id="L655">                return;</span>
            // check the system keyspace to keep user from shooting self in foot by changing partitioner, cluster name, etc.
            // we do a one-off scrub of the system keyspace first; we can't load the list of the rest of the keyspaces,
            // until system keyspace is opened.

<span class="fc bfc" id="L660" title="All 2 branches covered.">            for (TableMetadata cfm : Schema.instance.getTablesAndViews(SchemaConstants.SYSTEM_KEYSPACE_NAME))</span>
<span class="fc" id="L661">                ColumnFamilyStore.scrubDataDirectories(cfm);</span>

            try
            {
<span class="fc" id="L665">                SystemKeyspace.checkHealth();</span>
            }
<span class="nc" id="L667">            catch (ConfigurationException e)</span>
            {
<span class="nc" id="L669">                throw new StartupException(StartupException.ERR_WRONG_CONFIG, &quot;Fatal exception during initialization&quot;, e);</span>
<span class="fc" id="L670">            }</span>
<span class="fc" id="L671">        }</span>
    };

<span class="fc" id="L674">    public static final StartupCheck checkDatacenter = new StartupCheck()</span>
<span class="fc" id="L675">    {</span>
        @Override
        public void execute(StartupChecksOptions options) throws StartupException
        {
<span class="fc" id="L679">            boolean enabled = options.isEnabled(getStartupCheckType());</span>
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">            if (CassandraRelevantProperties.IGNORE_DC.isPresent())</span>
            {
<span class="nc" id="L682">                logger.warn(String.format(&quot;Cassandra system property flag %s is deprecated and you should &quot; +</span>
                                          &quot;use startup check configuration in cassandra.yaml&quot;,
<span class="nc" id="L684">                                          CassandraRelevantProperties.IGNORE_DC.getKey()));</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">                enabled = !CassandraRelevantProperties.IGNORE_DC.getBoolean();</span>
            }
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">            if (enabled)</span>
            {
<span class="fc" id="L689">                String storedDc = SystemKeyspace.getDatacenter();</span>
<span class="fc bfc" id="L690" title="All 2 branches covered.">                if (storedDc != null)</span>
                {
<span class="fc" id="L692">                    String currentDc = DatabaseDescriptor.getEndpointSnitch().getLocalDatacenter();</span>
<span class="pc bpc" id="L693" title="1 of 2 branches missed.">                    if (!storedDc.equals(currentDc))</span>
                    {
<span class="nc" id="L695">                        String formatMessage = &quot;Cannot start node if snitch's data center (%s) differs from previous data center (%s). &quot; +</span>
                                               &quot;Please fix the snitch configuration, decommission and rebootstrap this node or use the flag -Dcassandra.ignore_dc=true.&quot;;

<span class="nc" id="L698">                        throw new StartupException(StartupException.ERR_WRONG_CONFIG, String.format(formatMessage, currentDc, storedDc));</span>
                    }
                }
            }
<span class="fc" id="L702">        }</span>

        @Override
        public StartupCheckType getStartupCheckType()
        {
<span class="fc" id="L707">            return StartupCheckType.check_dc;</span>
        }
    };

<span class="fc" id="L711">    public static final StartupCheck checkRack = new StartupCheck()</span>
<span class="fc" id="L712">    {</span>
        @Override
        public void execute(StartupChecksOptions options) throws StartupException
        {
<span class="fc" id="L716">            boolean enabled = options.isEnabled(getStartupCheckType());</span>
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">            if (CassandraRelevantProperties.IGNORE_RACK.isPresent())</span>
            {
<span class="nc" id="L719">                logger.warn(String.format(&quot;Cassandra system property flag %s is deprecated and you should &quot; +</span>
                                          &quot;use startup check configuration in cassandra.yaml&quot;,
<span class="nc" id="L721">                                          CassandraRelevantProperties.IGNORE_RACK.getKey()));</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">                enabled = !CassandraRelevantProperties.IGNORE_RACK.getBoolean();</span>
            }
<span class="pc bpc" id="L724" title="1 of 2 branches missed.">            if (enabled)</span>
            {
<span class="fc" id="L726">                String storedRack = SystemKeyspace.getRack();</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">                if (storedRack != null)</span>
                {
<span class="fc" id="L729">                    String currentRack = DatabaseDescriptor.getEndpointSnitch().getLocalRack();</span>
<span class="pc bpc" id="L730" title="1 of 2 branches missed.">                    if (!storedRack.equals(currentRack))</span>
                    {
<span class="nc" id="L732">                        String formatMessage = &quot;Cannot start node if snitch's rack (%s) differs from previous rack (%s). &quot; +</span>
                                               &quot;Please fix the snitch configuration, decommission and rebootstrap this node or use the flag -Dcassandra.ignore_rack=true.&quot;;

<span class="nc" id="L735">                        throw new StartupException(StartupException.ERR_WRONG_CONFIG, String.format(formatMessage, currentRack, storedRack));</span>
                    }
                }
            }
<span class="fc" id="L739">        }</span>

        @Override
        public StartupCheckType getStartupCheckType()
        {
<span class="fc" id="L744">            return StartupCheckType.check_rack;</span>
        }
    };

<span class="fc" id="L748">    public static final StartupCheck checkLegacyAuthTables = new StartupCheck()</span>
<span class="fc" id="L749">    {</span>
        @Override
        public void execute(StartupChecksOptions options) throws StartupException
        {
<span class="pc bpc" id="L753" title="1 of 2 branches missed.">            if (options.isDisabled(getStartupCheckType()))</span>
<span class="nc" id="L754">                return;</span>
<span class="fc" id="L755">            Optional&lt;String&gt; errMsg = checkLegacyAuthTablesMessage();</span>
<span class="pc bpc" id="L756" title="1 of 2 branches missed.">            if (errMsg.isPresent())</span>
<span class="nc" id="L757">                throw new StartupException(StartupException.ERR_WRONG_CONFIG, errMsg.get());</span>
<span class="fc" id="L758">        }</span>
    };

    @VisibleForTesting
    public static Path getReadAheadKBPath(String blockDirectoryPath)
    {
<span class="fc" id="L764">        Path readAheadKBPath = null;</span>

<span class="fc" id="L766">        final String READ_AHEAD_KB_SETTING_PATH = &quot;/sys/block/%s/queue/read_ahead_kb&quot;;</span>
        try
        {
<span class="fc" id="L769">            String[] blockDirComponents = blockDirectoryPath.split(&quot;/&quot;);</span>
<span class="pc bpc" id="L770" title="3 of 4 branches missed.">            if (blockDirComponents.length &gt;= 2 &amp;&amp; blockDirComponents[1].equals(&quot;dev&quot;))</span>
            {
<span class="nc" id="L772">                String deviceName = blockDirComponents[2].replaceAll(&quot;[0-9]*$&quot;, &quot;&quot;);</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">                if (StringUtils.isNotEmpty(deviceName))</span>
                {
<span class="nc" id="L775">                    readAheadKBPath = File.getPath(String.format(READ_AHEAD_KB_SETTING_PATH, deviceName));</span>
                }
            }
        }
<span class="nc" id="L779">        catch (Exception e)</span>
        {
<span class="nc" id="L781">            logger.error(&quot;Error retrieving device path for {}.&quot;, blockDirectoryPath);</span>
<span class="fc" id="L782">        }</span>

<span class="fc" id="L784">        return readAheadKBPath;</span>
    }

    @VisibleForTesting
    static Optional&lt;String&gt; checkLegacyAuthTablesMessage()
    {
<span class="fc" id="L790">        List&lt;String&gt; existing = new ArrayList&lt;&gt;(SchemaConstants.LEGACY_AUTH_TABLES).stream().filter((legacyAuthTable) -&gt;</span>
            {
<span class="fc" id="L792">                UntypedResultSet result = QueryProcessor.executeOnceInternal(String.format(&quot;SELECT table_name FROM %s.%s WHERE keyspace_name='%s' AND table_name='%s'&quot;,</span>
                                                                                           SchemaConstants.SCHEMA_KEYSPACE_NAME,
                                                                                           &quot;tables&quot;,
                                                                                           SchemaConstants.AUTH_KEYSPACE_NAME,
                                                                                           legacyAuthTable));
<span class="pc bpc" id="L797" title="2 of 4 branches missed.">                return result != null &amp;&amp; !result.isEmpty();</span>
<span class="fc" id="L798">            }).collect(Collectors.toList());</span>

<span class="pc bpc" id="L800" title="1 of 2 branches missed.">        if (!existing.isEmpty())</span>
<span class="nc" id="L801">            return Optional.of(String.format(&quot;Legacy auth tables %s in keyspace %s still exist and have not been properly migrated.&quot;,</span>
<span class="nc" id="L802">                        Joiner.on(&quot;, &quot;).join(existing), SchemaConstants.AUTH_KEYSPACE_NAME));</span>
        else
<span class="fc" id="L804">            return Optional.empty();</span>
    };
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>