<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractSslContextFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.security</a> &gt; <span class="el_source">AbstractSslContextFactory.java</span></div><h1>AbstractSslContextFactory.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.security;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLException;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;

import com.google.common.collect.ImmutableList;

import io.netty.handler.ssl.CipherSuiteFilter;
import io.netty.handler.ssl.ClientAuth;
import io.netty.handler.ssl.OpenSsl;
import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.SslProvider;

import static org.apache.cassandra.config.CassandraRelevantProperties.DISABLE_TCACTIVE_OPENSSL;

/**
 * Abstract class implementing {@code ISslContextFacotry} to provide most of the functionality that any
 * implementation might need. This does not assume any file-based credentials for keys/certs hence provide a good base
 * for any implementation that only need to customize the loading of keys/certs in a custom way.
 * &lt;p&gt;
 * {@code CAUTION:} While this is extremely useful abstraction, please be careful if you need to modify this class
 * given possible custom implementations out there!
 *
 * @see DefaultSslContextFactory
 */
abstract public class AbstractSslContextFactory implements ISslContextFactory
{
    /*
    This list is substituted in configurations that have explicitly specified the original &quot;TLS&quot; default,
    by extracting it from the default &quot;TLS&quot; SSL Context instance
     */
<span class="fc" id="L57">    static protected final List&lt;String&gt; TLS_PROTOCOL_SUBSTITUTION = SSLFactory.tlsInstanceProtocolSubstitution();</span>

    protected boolean openSslIsAvailable;

    protected final Map&lt;String, Object&gt; parameters;
    protected final List&lt;String&gt; cipher_suites;
    protected final String protocol;
    protected final List&lt;String&gt; accepted_protocols;
    protected final String algorithm;
    protected final String store_type;
    protected final boolean require_client_auth;
    protected final boolean require_endpoint_verification;
    /*
    ServerEncryptionOptions does not use the enabled flag at all instead using the existing
    internode_encryption option. So we force this protected and expose through isEnabled
    so users of ServerEncryptionOptions can't accidentally use this when they should use isEnabled
    Long term we need to refactor ClientEncryptionOptions and ServerEncryptionOptions to be separate
    classes so we can choose appropriate configuration for each.
    See CASSANDRA-15262 and CASSANDRA-15146
     */
    protected Boolean enabled;
    protected Boolean optional;

    /* For test only */
    protected AbstractSslContextFactory()
<span class="nc" id="L82">    {</span>
<span class="nc" id="L83">        parameters = new HashMap&lt;&gt;();</span>
<span class="nc" id="L84">        cipher_suites = null;</span>
<span class="nc" id="L85">        protocol = null;</span>
<span class="nc" id="L86">        accepted_protocols = null;</span>
<span class="nc" id="L87">        algorithm = null;</span>
<span class="nc" id="L88">        store_type = &quot;JKS&quot;;</span>
<span class="nc" id="L89">        require_client_auth = false;</span>
<span class="nc" id="L90">        require_endpoint_verification = false;</span>
<span class="nc" id="L91">        enabled = null;</span>
<span class="nc" id="L92">        optional = null;</span>
<span class="nc" id="L93">        deriveIfOpenSslAvailable();</span>
<span class="nc" id="L94">    }</span>

    protected AbstractSslContextFactory(Map&lt;String, Object&gt; parameters)
<span class="fc" id="L97">    {</span>
<span class="fc" id="L98">        this.parameters = parameters;</span>
<span class="fc" id="L99">        cipher_suites = getStringList(&quot;cipher_suites&quot;);</span>
<span class="fc" id="L100">        protocol = getString(&quot;protocol&quot;);</span>
<span class="fc" id="L101">        accepted_protocols = getStringList(&quot;accepted_protocols&quot;);</span>
<span class="fc" id="L102">        algorithm = getString(&quot;algorithm&quot;);</span>
<span class="fc" id="L103">        store_type = getString(&quot;store_type&quot;, &quot;JKS&quot;);</span>
<span class="fc" id="L104">        require_client_auth = getBoolean(&quot;require_client_auth&quot;, false);</span>
<span class="fc" id="L105">        require_endpoint_verification = getBoolean(&quot;require_endpoint_verification&quot;, false);</span>
<span class="fc" id="L106">        enabled = getBoolean(&quot;enabled&quot;);</span>
<span class="fc" id="L107">        optional = getBoolean(&quot;optional&quot;);</span>
<span class="fc" id="L108">        deriveIfOpenSslAvailable();</span>
<span class="fc" id="L109">    }</span>

    /**
     * Dervies if {@code OpenSSL} is available. It allows in-jvm dtests to disable tcnative openssl support by
     * setting {@link  org.apache.cassandra.config.CassandraRelevantProperties#DISABLE_TCACTIVE_OPENSSL}
     * system property as {@code true}. Otherwise, it creates a circular reference that prevents the instance
     * class loader from being garbage collected.
     */
    protected void deriveIfOpenSslAvailable()
    {
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">        if (DISABLE_TCACTIVE_OPENSSL.getBoolean())</span>
<span class="nc" id="L120">            openSslIsAvailable = false;</span>
        else
<span class="fc" id="L122">            openSslIsAvailable = OpenSsl.isAvailable();</span>
<span class="fc" id="L123">    }</span>

    protected String getString(String key, String defaultValue)
    {
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        return parameters.get(key) == null ? defaultValue : (String) parameters.get(key);</span>
    }

    protected String getString(String key)
    {
<span class="fc" id="L132">        return (String) parameters.get(key);</span>
    }

    protected List&lt;String&gt; getStringList(String key)
    {
<span class="fc" id="L137">        return (List&lt;String&gt;) parameters.get(key);</span>
    }

    protected Boolean getBoolean(String key, boolean defaultValue)
    {
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">        return parameters.get(key) == null ? defaultValue : (Boolean) parameters.get(key);</span>
    }

    protected Boolean getBoolean(String key)
    {
<span class="fc" id="L147">        return (Boolean) this.parameters.get(key);</span>
    }

    @Override
    public SSLContext createJSSESslContext(boolean verifyPeerCertificate) throws SSLException
    {
<span class="nc" id="L153">        TrustManager[] trustManagers = null;</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">        if (verifyPeerCertificate)</span>
<span class="nc" id="L155">            trustManagers = buildTrustManagerFactory().getTrustManagers();</span>

<span class="nc" id="L157">        KeyManagerFactory kmf = buildKeyManagerFactory();</span>

        try
        {
<span class="nc" id="L161">            SSLContext ctx = SSLContext.getInstance(&quot;TLS&quot;);</span>
<span class="nc" id="L162">            ctx.init(kmf.getKeyManagers(), trustManagers, null);</span>
<span class="nc" id="L163">            return ctx;</span>
        }
<span class="nc" id="L165">        catch (Exception e)</span>
        {
<span class="nc" id="L167">            throw new SSLException(&quot;Error creating/initializing the SSL Context&quot;, e);</span>
        }
    }

    @Override
    public SslContext createNettySslContext(boolean verifyPeerCertificate, SocketType socketType,
                                            CipherSuiteFilter cipherFilter) throws SSLException
    {
        /*
            There is a case where the netty/openssl combo might not support using KeyManagerFactory. Specifically,
            I've seen this with the netty-tcnative dynamic openssl implementation. Using the netty-tcnative
            static-boringssl works fine with KeyManagerFactory. If we want to support all of the netty-tcnative
            options, we would need to fall back to passing in a file reference for both a x509 and PKCS#8 private
            key file in PEM format (see {@link SslContextBuilder#forServer(File, File, String)}). However, we are
            not supporting that now to keep the config/yaml API simple.
         */
        SslContextBuilder builder;
<span class="fc bfc" id="L184" title="All 2 branches covered.">        if (socketType == SocketType.SERVER)</span>
        {
<span class="fc" id="L186">            KeyManagerFactory kmf = buildKeyManagerFactory();</span>
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">            builder = SslContextBuilder.forServer(kmf).clientAuth(this.require_client_auth ? ClientAuth.REQUIRE :</span>
<span class="fc" id="L188">                                                                  ClientAuth.NONE);</span>
<span class="fc" id="L189">        }</span>
        else
        {
<span class="fc" id="L192">            KeyManagerFactory kmf = buildOutboundKeyManagerFactory();</span>
<span class="fc" id="L193">            builder = SslContextBuilder.forClient().keyManager(kmf);</span>
        }

<span class="fc" id="L196">        builder.sslProvider(getSslProvider()).protocols(getAcceptedProtocols());</span>

        // only set the cipher suites if the operator has explicity configured values for it; else, use the default
        // for each ssl implemention (jdk or openssl)
<span class="pc bpc" id="L200" title="3 of 4 branches missed.">        if (cipher_suites != null &amp;&amp; !cipher_suites.isEmpty())</span>
<span class="nc" id="L201">            builder.ciphers(cipher_suites, cipherFilter);</span>

<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        if (verifyPeerCertificate)</span>
<span class="fc" id="L204">            builder.trustManager(buildTrustManagerFactory());</span>

<span class="fc" id="L206">        return builder.build();</span>
    }

    /**
     * Combine the pre-4.0 protocol field with the accepted_protocols list, substituting a list of
     * explicit protocols for the previous catchall default of &quot;TLS&quot;
     *
     * @return array of protocol names suitable for passing to SslContextBuilder.protocols, or null if the default
     */
    @Override
    public List&lt;String&gt; getAcceptedProtocols()
    {
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">        if (accepted_protocols == null)</span>
        {
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">            if (protocol == null)</span>
            {
<span class="fc" id="L222">                return null;</span>
            }
            // TLS is accepted by SSLContext.getInstance as a shorthand for give me an engine that
            // can speak some TLS protocols.  It is not supported by SSLEngine.setAcceptedProtocols
            // so substitute if the user hasn't provided an accepted protocol configuration
<span class="nc bnc" id="L227" title="All 2 branches missed.">            else if (protocol.equalsIgnoreCase(&quot;TLS&quot;))</span>
            {
<span class="nc" id="L229">                return TLS_PROTOCOL_SUBSTITUTION;</span>
            }
            else // the user was trying to limit to a single specific protocol, so try that
            {
<span class="nc" id="L233">                return ImmutableList.of(protocol);</span>
            }
        }

<span class="nc bnc" id="L237" title="All 4 branches missed.">        if (protocol != null &amp;&amp; !protocol.equalsIgnoreCase(&quot;TLS&quot;) &amp;&amp;</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">            accepted_protocols.stream().noneMatch(ap -&gt; ap.equalsIgnoreCase(protocol)))</span>
        {
            // If the user provided a non-generic default protocol, append it to accepted_protocols - they wanted
            // it after all.
<span class="nc" id="L242">            return ImmutableList.&lt;String&gt;builder().addAll(accepted_protocols).add(protocol).build();</span>
        }
        else
        {
<span class="nc" id="L246">            return accepted_protocols;</span>
        }
    }

    @Override
    public List&lt;String&gt; getCipherSuites()
    {
<span class="nc" id="L253">        return cipher_suites;</span>
    }

    /**
     * Returns {@link SslProvider} to be used to build Netty's SslContext.
     *
     * @return appropriate SslProvider
     */
    protected SslProvider getSslProvider()
    {
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        return openSslIsAvailable ? SslProvider.OPENSSL : SslProvider.JDK;</span>
    }

    abstract protected KeyManagerFactory buildKeyManagerFactory() throws SSLException;

    abstract protected TrustManagerFactory buildTrustManagerFactory() throws SSLException;

    /**
     * Create a {@code KeyManagerFactory} for outbound connections.
     * It provides a seperate keystore for internode mTLS outbound connections.
     * @return {@code KeyManagerFactory}
     * @throws SSLException
     */
    abstract protected KeyManagerFactory buildOutboundKeyManagerFactory() throws SSLException;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>