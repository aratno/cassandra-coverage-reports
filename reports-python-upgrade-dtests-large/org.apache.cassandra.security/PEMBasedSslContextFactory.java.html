<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PEMBasedSslContextFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.security</a> &gt; <span class="el_source">PEMBasedSslContextFactory.java</span></div><h1>PEMBasedSslContextFactory.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.security;

import java.io.IOException;
import java.nio.file.Files;
import java.security.GeneralSecurityException;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.cert.Certificate;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLException;
import javax.net.ssl.TrustManagerFactory;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.io.util.File;


/**
 * SslContextFactory for the &lt;a href=&quot;&quot;&gt;PEM standard&lt;/a&gt; encoded PKCS#8 private keys and X509 certificates/public-keys.
 * It parses the key material based on the standard defined in the &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7468&quot;&gt;RFC 7468&lt;/a&gt;.
 * It creates &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc5208&quot;&gt;PKCS# 8&lt;/a&gt; based private key and X509 certificate(s)
 * for the public key to build the required keystore and the truststore managers that are used for the SSL context creation.
 * Internally it builds Java {@link KeyStore} with &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7292&quot;&gt;PKCS# 12&lt;/a&gt; &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#keystore-types&quot;&gt;store type&lt;/a&gt;
 * to be used for keystore and the truststore managers.
 * &lt;p&gt;
 * This factory also supports 'hot reloading' of the key material, the same way as defined by {@link FileBasedSslContextFactory},
 * &lt;b&gt;if it is file based&lt;/b&gt;. This factory ignores the existing 'store_type' configuration used for other file based store
 * types like JKS.
 * &lt;p&gt;
 * You can configure this factory with either inline PEM data or with the files having the required PEM data as shown
 * below,
 *
 * &lt;b&gt;Configuration: PEM keys/certs defined inline (mind the spaces in the YAML!)&lt;/b&gt;
 * &lt;pre&gt;
 *     client/server_encryption_options:
 *      ssl_context_factory:
 *         class_name: org.apache.cassandra.security.PEMBasedSslContextFactory
 *         parameters:
 *             private_key: |
 *              -----BEGIN ENCRYPTED PRIVATE KEY----- OR -----BEGIN PRIVATE KEY-----
 *              &lt;your base64 encoded private key&gt;
 *              -----END ENCRYPTED PRIVATE KEY----- OR -----END PRIVATE KEY-----
 *              -----BEGIN CERTIFICATE-----
 *              &lt;your base64 encoded certificate chain&gt;
 *              -----END CERTIFICATE-----
 *
 *             private_key_password: &quot;&lt;your password if the private key is encrypted with a password&gt;&quot;
 *
 *             trusted_certificates: |
 *               -----BEGIN CERTIFICATE-----
 *               &lt;your base64 encoded certificate&gt;
 *               -----END CERTIFICATE-----
 * &lt;/pre&gt;
 *
 * &lt;b&gt;Configuration: PEM keys/certs defined in files&lt;/b&gt;
 * &lt;pre&gt;
 *     client/server_encryption_options:
 *      ssl_context_factory:
 *         class_name: org.apache.cassandra.security.PEMBasedSslContextFactory
 *      keystore: &lt;file path to the keystore file in the PEM format with the private key and the certificate chain&gt;
 *      keystore_password: &quot;&lt;your password if the private key is encrypted with a password&gt;&quot;
 *      truststore: &lt;file path to the truststore file in the PEM format&gt;
 * &lt;/pre&gt;
 */
public final class PEMBasedSslContextFactory extends FileBasedSslContextFactory
{
    public static final String DEFAULT_TARGET_STORETYPE = &quot;PKCS12&quot;;
<span class="nc" id="L91">    private static final Logger logger = LoggerFactory.getLogger(PEMBasedSslContextFactory.class);</span>
    private PEMBasedKeyStoreContext pemEncodedTrustCertificates;
    private PEMBasedKeyStoreContext pemEncodedKeyContext;
    private PEMBasedKeyStoreContext pemEncodedOutboundKeyContext;

    public PEMBasedSslContextFactory()
<span class="nc" id="L97">    {</span>
<span class="nc" id="L98">    }</span>

    private void validatePasswords()
    {
<span class="nc bnc" id="L102" title="All 2 branches missed.">        boolean shouldThrow = !keystoreContext.passwordMatchesIfPresent(pemEncodedKeyContext.password)</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">                              || !outboundKeystoreContext.passwordMatchesIfPresent(pemEncodedOutboundKeyContext.password);</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">        boolean outboundPasswordMismatch = !outboundKeystoreContext.passwordMatchesIfPresent(pemEncodedOutboundKeyContext.password);</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">        String keyName = outboundPasswordMismatch ? &quot;outbound_&quot; : &quot;&quot;;</span>

<span class="nc bnc" id="L107" title="All 2 branches missed.">        if (shouldThrow)</span>
        {
<span class="nc" id="L109">            final String msg = String.format(&quot;'%skeystore_password' and '%skey_password' both configurations are given and the values do not match&quot;, keyName, keyName);</span>
<span class="nc" id="L110">            throw new IllegalArgumentException(msg);</span>
        }
<span class="nc" id="L112">    }</span>

    public PEMBasedSslContextFactory(Map&lt;String, Object&gt; parameters)
    {
<span class="nc" id="L116">        super(parameters);</span>
<span class="nc" id="L117">        final String pemEncodedKey = getString(ConfigKey.ENCODED_KEY.getKeyName());</span>
<span class="nc" id="L118">        final String pemEncodedKeyPassword = StringUtils.defaultString(getString(ConfigKey.KEY_PASSWORD.getKeyName()), keystoreContext.password);</span>
<span class="nc" id="L119">        pemEncodedKeyContext = new PEMBasedKeyStoreContext(pemEncodedKey, pemEncodedKeyPassword, StringUtils.isEmpty(pemEncodedKey), keystoreContext);</span>

<span class="nc" id="L121">        final String pemEncodedOutboundKey = StringUtils.defaultString(getString(ConfigKey.OUTBOUND_ENCODED_KEY.getKeyName()), pemEncodedKey);</span>
<span class="nc" id="L122">        final String outboundKeyPassword = StringUtils.defaultString(StringUtils.defaultString(getString(ConfigKey.OUTBOUND_ENCODED_KEY_PASSWORD.getKeyName()),</span>
                                                                                               outboundKeystoreContext.password), pemEncodedKeyPassword);
<span class="nc" id="L124">        pemEncodedOutboundKeyContext = new PEMBasedKeyStoreContext(pemEncodedKey, outboundKeyPassword, StringUtils.isEmpty(pemEncodedOutboundKey), outboundKeystoreContext);</span>

<span class="nc" id="L126">        validatePasswords();</span>

<span class="nc bnc" id="L128" title="All 2 branches missed.">        if (!StringUtils.isEmpty(trustStoreContext.password))</span>
        {
<span class="nc" id="L130">            logger.warn(&quot;PEM based truststore should not be using password. Ignoring the given value in &quot; +</span>
                        &quot;'truststore_password' configuration.&quot;);
        }

<span class="nc" id="L134">        final String pemEncodedCerts = getString(ConfigKey.ENCODED_CERTIFICATES.getKeyName());</span>
<span class="nc" id="L135">        pemEncodedTrustCertificates = new PEMBasedKeyStoreContext(pemEncodedCerts, null, StringUtils.isEmpty(pemEncodedCerts), trustStoreContext);</span>
<span class="nc" id="L136">        enforceSinglePrivateKeySource();</span>
<span class="nc" id="L137">        enforceSingleTurstedCertificatesSource();</span>
<span class="nc" id="L138">    }</span>

    /**
     * Decides if this factory has a keystore defined - key material specified in files or inline to the configuration.
     *
     * @return {@code true} if there is a keystore defined; {@code false} otherwise
     */
    @Override
    public boolean hasKeystore()
    {
<span class="nc bnc" id="L148" title="All 2 branches missed.">        return pemEncodedKeyContext.maybeFilebasedKey</span>
<span class="nc" id="L149">               ? keystoreContext.hasKeystore()</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">               : !StringUtils.isEmpty(pemEncodedKeyContext.key);</span>
    }

    /**
     * Decides if this factory has an outbound keystore defined - key material specified in files or inline to the configuration.
     *
     * @return {@code true} if there is an outbound keystore defined; {@code false} otherwise
     */
    @Override
    public boolean hasOutboundKeystore()
    {
<span class="nc bnc" id="L161" title="All 2 branches missed.">        return pemEncodedOutboundKeyContext.maybeFilebasedKey</span>
<span class="nc" id="L162">               ? outboundKeystoreContext.hasKeystore()</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">               : !StringUtils.isEmpty(pemEncodedOutboundKeyContext.key);</span>
    }

    /**
     * Decides if this factory has a truststore defined - key material specified in files or inline to the
     * configuration.
     *
     * @return {@code true} if there is a truststore defined; {@code false} otherwise
     */
    private boolean hasTruststore()
    {
<span class="nc bnc" id="L174" title="All 2 branches missed.">        return pemEncodedTrustCertificates.maybeFilebasedKey ? truststoreFileExists() :</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">               !StringUtils.isEmpty(pemEncodedTrustCertificates.key);</span>
    }

    /**
     * Checks if the truststore file exists.
     *
     * @return {@code true} if truststore file exists; {@code false} otherwise
     */
    private boolean truststoreFileExists()
    {
<span class="nc bnc" id="L185" title="All 4 branches missed.">        return trustStoreContext.filePath != null &amp;&amp; new File(trustStoreContext.filePath).exists();</span>
    }

    /**
     * This enables 'hot' reloading of the key/trust stores based on the last updated timestamps if they are file based.
     */
    @Override
    public synchronized void initHotReloading()
    {
<span class="nc" id="L194">        List&lt;HotReloadableFile&gt; fileList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L195" title="All 4 branches missed.">        if (pemEncodedKeyContext.maybeFilebasedKey &amp;&amp; hasKeystore())</span>
        {
<span class="nc" id="L197">            fileList.add(new HotReloadableFile(keystoreContext.filePath));</span>
        }
<span class="nc bnc" id="L199" title="All 4 branches missed.">        if (pemEncodedOutboundKeyContext.maybeFilebasedKey &amp;&amp; hasOutboundKeystore())</span>
        {
<span class="nc" id="L201">            fileList.add(new HotReloadableFile(outboundKeystoreContext.filePath));</span>
        }
<span class="nc bnc" id="L203" title="All 4 branches missed.">        if (pemEncodedTrustCertificates.maybeFilebasedKey &amp;&amp; hasTruststore())</span>
        {
<span class="nc" id="L205">            fileList.add(new HotReloadableFile(trustStoreContext.filePath));</span>
        }
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (!fileList.isEmpty())</span>
        {
<span class="nc" id="L209">            hotReloadableFiles = fileList;</span>
        }
<span class="nc" id="L211">    }</span>

    /**
     * Builds required KeyManagerFactory from the PEM based keystore. It also checks for the PrivateKey's certificate's
     * expiry and logs {@code warning} for each expired PrivateKey's certitificate.
     *
     * @return KeyManagerFactory built from the PEM based keystore.
     * @throws SSLException if any issues encountered during the build process
     */
    @Override
    protected KeyManagerFactory buildKeyManagerFactory() throws SSLException
    {
<span class="nc" id="L223">        return buildKeyManagerFactory(pemEncodedKeyContext, keystoreContext);</span>
    }

    @Override
    protected KeyManagerFactory buildOutboundKeyManagerFactory() throws SSLException
    {
<span class="nc" id="L229">        return buildKeyManagerFactory(pemEncodedOutboundKeyContext, outboundKeystoreContext);</span>
    }

    private KeyManagerFactory buildKeyManagerFactory(PEMBasedKeyStoreContext pemBasedKeyStoreContext, FileBasedStoreContext keyStoreContext) throws SSLException
    {
        try
        {
<span class="nc bnc" id="L236" title="All 2 branches missed.">            if (pemBasedKeyStoreContext.hasKey())</span>
            {
<span class="nc bnc" id="L238" title="All 2 branches missed.">                if (pemBasedKeyStoreContext.maybeFilebasedKey)</span>
                {
<span class="nc" id="L240">                    pemBasedKeyStoreContext.key = readPEMFile(keyStoreContext.filePath); // read PEM from the file</span>
                }

<span class="nc" id="L243">                KeyManagerFactory kmf = KeyManagerFactory.getInstance(</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">                algorithm == null ? KeyManagerFactory.getDefaultAlgorithm() : algorithm);</span>
<span class="nc" id="L245">                KeyStore ks = buildKeyStore(pemBasedKeyStoreContext.key, pemBasedKeyStoreContext.password);</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">                if (!keyStoreContext.checkedExpiry)</span>
                {
<span class="nc" id="L248">                    checkExpiredCerts(ks);</span>
<span class="nc" id="L249">                    keyStoreContext.checkedExpiry = true;</span>
                }
<span class="nc bnc" id="L251" title="All 2 branches missed.">                kmf.init(ks, pemBasedKeyStoreContext.password != null ? pemBasedKeyStoreContext.password.toCharArray() : null);</span>
<span class="nc" id="L252">                return kmf;</span>
            }
            else
            {
<span class="nc" id="L256">                throw new SSLException(&quot;Must provide outbound_keystore or outbound_private_key in configuration for PEMBasedSSlContextFactory&quot;);</span>
            }
        }
<span class="nc" id="L259">        catch (Exception e)</span>
        {
<span class="nc" id="L261">            throw new SSLException(&quot;Failed to build key manager store for secure connections&quot;, e);</span>
        }
    }

    /**
     * Builds TrustManagerFactory from the PEM based truststore.
     *
     * @return TrustManagerFactory from the PEM based truststore
     * @throws SSLException if any issues encountered during the build process
     */
    @Override
    protected TrustManagerFactory buildTrustManagerFactory() throws SSLException
    {
        try
        {
<span class="nc bnc" id="L276" title="All 2 branches missed.">            if (hasTruststore())</span>
            {
<span class="nc bnc" id="L278" title="All 2 branches missed.">                if (pemEncodedTrustCertificates.maybeFilebasedKey)</span>
                {
<span class="nc" id="L280">                    pemEncodedTrustCertificates.key = readPEMFile(trustStoreContext.filePath); // read PEM from the file</span>
                }

<span class="nc" id="L283">                TrustManagerFactory tmf = TrustManagerFactory.getInstance(</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">                algorithm == null ? TrustManagerFactory.getDefaultAlgorithm() : algorithm);</span>
<span class="nc" id="L285">                KeyStore ts = buildTrustStore();</span>
<span class="nc" id="L286">                tmf.init(ts);</span>
<span class="nc" id="L287">                return tmf;</span>
            }
            else
            {
<span class="nc" id="L291">                throw new SSLException(&quot;Must provide truststore or trusted_certificates in configuration for &quot; +</span>
                                       &quot;PEMBasedSSlContextFactory&quot;);
            }
        }
<span class="nc" id="L295">        catch (Exception e)</span>
        {
<span class="nc" id="L297">            throw new SSLException(&quot;Failed to build trust manager store for secure connections&quot;, e);</span>
        }
    }

    private String readPEMFile(String file) throws IOException
    {
<span class="nc" id="L303">        return new String(Files.readAllBytes(File.getPath(file)));</span>
    }

    /**
     * Builds KeyStore object given the {@link #DEFAULT_TARGET_STORETYPE} out of the PEM formatted private key material.
     * It uses {@code cassandra-ssl-keystore} as the alias for the created key-entry.
     */
    private static KeyStore buildKeyStore(final String pemEncodedKey, final String keyPassword) throws GeneralSecurityException, IOException
    {
<span class="nc bnc" id="L312" title="All 2 branches missed.">        char[] keyPasswordArray = keyPassword != null ? keyPassword.toCharArray() : null;</span>
<span class="nc" id="L313">        PrivateKey privateKey = PEMReader.extractPrivateKey(pemEncodedKey, keyPassword);</span>
<span class="nc" id="L314">        Certificate[] certChainArray = PEMReader.extractCertificates(pemEncodedKey);</span>
<span class="nc bnc" id="L315" title="All 4 branches missed.">        if (certChainArray == null || certChainArray.length == 0)</span>
        {
<span class="nc" id="L317">            throw new SSLException(&quot;Could not read any certificates for the certChain for the private key&quot;);</span>
        }

<span class="nc" id="L320">        KeyStore keyStore = KeyStore.getInstance(DEFAULT_TARGET_STORETYPE);</span>
<span class="nc" id="L321">        keyStore.load(null, null);</span>
<span class="nc" id="L322">        keyStore.setKeyEntry(&quot;cassandra-ssl-keystore&quot;, privateKey, keyPasswordArray, certChainArray);</span>
<span class="nc" id="L323">        return keyStore;</span>
    }

    /**
     * Builds KeyStore object given the {@link #DEFAULT_TARGET_STORETYPE} out of the PEM formatted certificates/public-key
     * material.
     * &lt;p&gt;
     * It uses {@code cassandra-ssl-trusted-cert-&lt;numeric-id&gt;} as the alias for the created certificate-entry.
     */
    private KeyStore buildTrustStore() throws GeneralSecurityException, IOException
    {
<span class="nc" id="L334">        Certificate[] certChainArray = PEMReader.extractCertificates(pemEncodedTrustCertificates.key);</span>
<span class="nc bnc" id="L335" title="All 4 branches missed.">        if (certChainArray == null || certChainArray.length == 0)</span>
        {
<span class="nc" id="L337">            throw new SSLException(&quot;Could not read any certificates from the given PEM&quot;);</span>
        }

<span class="nc" id="L340">        KeyStore keyStore = KeyStore.getInstance(DEFAULT_TARGET_STORETYPE);</span>
<span class="nc" id="L341">        keyStore.load(null, null);</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">        for (int i = 0; i &lt; certChainArray.length; i++)</span>
        {
<span class="nc" id="L344">            keyStore.setCertificateEntry(&quot;cassandra-ssl-trusted-cert-&quot; + (i + 1), certChainArray[i]);</span>
        }
<span class="nc" id="L346">        return keyStore;</span>
    }

    /**
     * Enforces that the configuration specified a sole source of loading private keys - either {@code keystore} (the
     * actual file must exist) or {@code private_key}, not both.
     */
    private void enforceSinglePrivateKeySource()
    {
<span class="nc bnc" id="L355" title="All 4 branches missed.">        if (keystoreContext.hasKeystore() &amp;&amp; !StringUtils.isEmpty(pemEncodedKeyContext.key))</span>
        {
<span class="nc" id="L357">            throw new IllegalArgumentException(&quot;Configuration must specify value for either keystore or private_key, &quot; +</span>
                                               &quot;not both for PEMBasedSSlContextFactory&quot;);
        }
<span class="nc bnc" id="L360" title="All 4 branches missed.">        if (outboundKeystoreContext.hasKeystore() &amp;&amp; !StringUtils.isEmpty(pemEncodedOutboundKeyContext.key))</span>
        {
<span class="nc" id="L362">            throw new IllegalArgumentException(&quot;Configuration must specify value for either outbound_keystore or outbound_private_key, &quot; +</span>
                                               &quot;not both for PEMBasedSSlContextFactory&quot;);
        }
<span class="nc" id="L365">    }</span>

    /**
     * Enforces that the configuration specified a sole source of loading trusted certificates - either {@code
     * truststore} (actual file must exist) or {@code trusted_certificates}, not both.
     */
    private void enforceSingleTurstedCertificatesSource()
    {
<span class="nc bnc" id="L373" title="All 4 branches missed.">        if (truststoreFileExists() &amp;&amp; !StringUtils.isEmpty(pemEncodedTrustCertificates.key))</span>
        {
<span class="nc" id="L375">            throw new IllegalArgumentException(&quot;Configuration must specify value for either truststore or &quot; +</span>
                                               &quot;trusted_certificates, not both for PEMBasedSSlContextFactory&quot;);
        }
<span class="nc" id="L378">    }</span>

    public static class PEMBasedKeyStoreContext
    {
        public String key;
        public final String password;
        public final boolean maybeFilebasedKey;
        public final FileBasedStoreContext filebasedKeystoreContext;

        public PEMBasedKeyStoreContext(final String encodedKey, final String getEncodedKeyPassword,
                                       final boolean maybeFilebasedKey, final FileBasedStoreContext filebasedKeystoreContext)
<span class="nc" id="L389">        {</span>
<span class="nc" id="L390">            this.key = encodedKey;</span>
<span class="nc" id="L391">            this.password = getEncodedKeyPassword;</span>
<span class="nc" id="L392">            this.maybeFilebasedKey = maybeFilebasedKey;</span>
<span class="nc" id="L393">            this.filebasedKeystoreContext = filebasedKeystoreContext;</span>
<span class="nc" id="L394">        }</span>

        public boolean hasKey()
        {
<span class="nc bnc" id="L398" title="All 2 branches missed.">            return maybeFilebasedKey</span>
<span class="nc" id="L399">                   ? filebasedKeystoreContext.hasKeystore()</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">                   : !StringUtils.isEmpty(key);</span>
        }
    }

<span class="nc" id="L404">    public enum ConfigKey</span>
    {
<span class="nc" id="L406">        ENCODED_KEY(&quot;private_key&quot;),</span>
<span class="nc" id="L407">        KEY_PASSWORD(&quot;private_key_password&quot;),</span>
<span class="nc" id="L408">        OUTBOUND_ENCODED_KEY(&quot;outbound_private_key&quot;),</span>
<span class="nc" id="L409">        OUTBOUND_ENCODED_KEY_PASSWORD(&quot;outbound_private_key_password&quot;),</span>
<span class="nc" id="L410">        ENCODED_CERTIFICATES(&quot;trusted_certificates&quot;);</span>

        final String keyName;

        ConfigKey(String keyName)
<span class="nc" id="L415">        {</span>
<span class="nc" id="L416">            this.keyName = keyName;</span>
<span class="nc" id="L417">        }</span>

        String getKeyName()
        {
<span class="nc" id="L421">            return keyName;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>