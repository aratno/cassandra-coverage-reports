<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MergeIterator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.utils</a> &gt; <span class="el_source">MergeIterator.java</span></div><h1>MergeIterator.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.utils;

import java.util.*;

/** Merges sorted input iterators which individually contain unique items. */
public abstract class MergeIterator&lt;In,Out&gt; extends AbstractIterator&lt;Out&gt; implements IMergeIterator&lt;In, Out&gt;
{
    protected final Reducer&lt;In,Out&gt; reducer;
    protected final List&lt;? extends Iterator&lt;In&gt;&gt; iterators;

    protected MergeIterator(List&lt;? extends Iterator&lt;In&gt;&gt; iters, Reducer&lt;In, Out&gt; reducer)
<span class="fc" id="L29">    {</span>
<span class="fc" id="L30">        this.iterators = iters;</span>
<span class="fc" id="L31">        this.reducer = reducer;</span>
<span class="fc" id="L32">    }</span>

    @SuppressWarnings(&quot;resource&quot;)
    public static &lt;In, Out&gt; MergeIterator&lt;In, Out&gt; get(List&lt;? extends Iterator&lt;In&gt;&gt; sources,
                                                       Comparator&lt;? super In&gt; comparator,
                                                       Reducer&lt;In, Out&gt; reducer)
    {
<span class="fc bfc" id="L39" title="All 2 branches covered.">        if (sources.size() == 1)</span>
        {
<span class="fc bfc" id="L41" title="All 2 branches covered.">            return reducer.trivialReduceIsTrivial()</span>
<span class="fc" id="L42">                 ? new TrivialOneToOne&lt;&gt;(sources, reducer)</span>
<span class="fc" id="L43">                 : new OneToOne&lt;&gt;(sources, reducer);</span>
        }
<span class="fc" id="L45">        return new ManyToOne&lt;&gt;(sources, comparator, reducer);</span>
    }

    public Iterable&lt;? extends Iterator&lt;In&gt;&gt; iterators()
    {
<span class="nc" id="L50">        return iterators;</span>
    }

    public void close()
    {
<span class="fc bfc" id="L55" title="All 2 branches covered.">        for (int i=0, isize=iterators.size(); i&lt;isize; i++)</span>
        {
<span class="fc" id="L57">            Iterator&lt;In&gt; iterator = iterators.get(i);</span>
            try
            {
<span class="pc bpc" id="L60" title="1 of 2 branches missed.">                if (iterator instanceof AutoCloseable)</span>
<span class="fc" id="L61">                    ((AutoCloseable)iterator).close();</span>
            }
<span class="nc" id="L63">            catch (Exception e)</span>
            {
<span class="nc" id="L65">                throw new RuntimeException(e);</span>
<span class="fc" id="L66">            }</span>
        }

<span class="fc" id="L69">        reducer.close();</span>
<span class="fc" id="L70">    }</span>

    /**
     * A MergeIterator that consumes multiple input values per output value.
     *
     * The most straightforward way to implement this is to use a {@code PriorityQueue} of iterators, {@code poll} it to
     * find the next item to consume, then {@code add} the iterator back after advancing. This is not very efficient as
     * {@code poll} and {@code add} in all cases require at least {@code log(size)} comparisons (usually more than
     * {@code 2*log(size)}) per consumed item, even if the input is suitable for fast iteration.
     *
     * The implementation below makes use of the fact that replacing the top element in a binary heap can be done much
     * more efficiently than separately removing it and placing it back, especially in the cases where the top iterator
     * is to be used again very soon (e.g. when there are large sections of the output where only a limited number of
     * input iterators overlap, which is normally the case in many practically useful situations, e.g. levelled
     * compaction). To further improve this particular scenario, we also use a short sorted section at the start of the
     * queue.
     *
     * The heap is laid out as this (for {@code SORTED_SECTION_SIZE == 2}):
     *                 0
     *                 |
     *                 1
     *                 |
     *                 2
     *               /   \
     *              3     4
     *             / \   / \
     *             5 6   7 8
     *            .. .. .. ..
     * Where each line is a &lt;= relationship.
     *
     * In the sorted section we can advance with a single comparison per level, while advancing a level within the heap
     * requires two (so that we can find the lighter element to pop up).
     * The sorted section adds a constant overhead when data is uniformly distributed among the iterators, but may up
     * to halve the iteration time when one iterator is dominant over sections of the merged data (as is the case with
     * non-overlapping iterators).
     *
     * The iterator is further complicated by the need to avoid advancing the input iterators until an output is
     * actually requested. To achieve this {@code consume} walks the heap to find equal items without advancing the
     * iterators, and {@code advance} moves them and restores the heap structure before any items can be consumed.
     * 
     * To avoid having to do additional comparisons in consume to identify the equal items, we keep track of equality
     * between children and their parents in the heap. More precisely, the lines in the diagram above define the
     * following relationship:
     *   parent &lt;= child &amp;&amp; (parent == child) == child.equalParent
     * We can track, make use of and update the equalParent field without any additional comparisons.
     *
     * For more formal definitions and proof of correctness, see CASSANDRA-8915.
     */
<span class="fc" id="L118">    static final class ManyToOne&lt;In,Out&gt; extends MergeIterator&lt;In,Out&gt;</span>
    {
        protected final Candidate&lt;In&gt;[] heap;

        /** Number of non-exhausted iterators. */
        int size;

        /**
         * Position of the deepest, right-most child that needs advancing before we can start consuming.
         * Because advancing changes the values of the items of each iterator, the parent-chain from any position
         * in this range that needs advancing is not in correct order. The trees rooted at any position that does
         * not need advancing, however, retain their prior-held binary heap property.
         */
        int needingAdvance;

        /**
         * The number of elements to keep in order before the binary heap starts, exclusive of the top heap element.
         */
        static final int SORTED_SECTION_SIZE = 4;

        public ManyToOne(List&lt;? extends Iterator&lt;In&gt;&gt; iters, Comparator&lt;? super In&gt; comp, Reducer&lt;In, Out&gt; reducer)
        {
<span class="fc" id="L140">            super(iters, reducer);</span>

            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L143">            Candidate&lt;In&gt;[] heap = new Candidate[iters.size()];</span>
<span class="fc" id="L144">            this.heap = heap;</span>
<span class="fc" id="L145">            size = 0;</span>

<span class="fc bfc" id="L147" title="All 2 branches covered.">            for (int i = 0; i &lt; iters.size(); i++)</span>
            {
<span class="fc" id="L149">                Candidate&lt;In&gt; candidate = new Candidate&lt;&gt;(i, iters.get(i), comp);</span>
<span class="fc" id="L150">                heap[size++] = candidate;</span>
            }
<span class="fc" id="L152">            needingAdvance = size;</span>
<span class="fc" id="L153">        }</span>

        protected final Out computeNext()
        {
<span class="fc" id="L157">            advance();</span>
<span class="fc" id="L158">            return consume();</span>
        }

        /**
         * Advance all iterators that need to be advanced and place them into suitable positions in the heap.
         *
         * By walking the iterators backwards we know that everything after the point being processed already forms
         * correctly ordered subheaps, thus we can build a subheap rooted at the current position by only sinking down
         * the newly advanced iterator. Because all parents of a consumed iterator are also consumed there is no way
         * that we can process one consumed iterator but skip over its parent.
         *
         * The procedure is the same as the one used for the initial building of a heap in the heapsort algorithm and
         * has a maximum number of comparisons {@code (2 * log(size) + SORTED_SECTION_SIZE / 2)} multiplied by the
         * number of iterators whose items were consumed at the previous step, but is also at most linear in the size of
         * the heap if the number of consumed elements is high (as it is in the initial heap construction). With non- or
         * lightly-overlapping iterators the procedure finishes after just one (resp. a couple of) comparisons.
         */
        private void advance()
        {
            // Turn the set of candidates into a heap.
<span class="fc bfc" id="L178" title="All 2 branches covered.">            for (int i = needingAdvance - 1; i &gt;= 0; --i)</span>
            {
<span class="fc" id="L180">                Candidate&lt;In&gt; candidate = heap[i];</span>
                /**
                 *  needingAdvance runs to the maximum index (and deepest-right node) that may need advancing;
                 *  since the equal items that were consumed at-once may occur in sub-heap &quot;veins&quot; of equality,
                 *  not all items above this deepest-right position may have been consumed; these already form
                 *  valid sub-heaps and can be skipped-over entirely
                 */
<span class="fc bfc" id="L187" title="All 2 branches covered.">                if (candidate.needsAdvance())</span>
<span class="fc" id="L188">                    replaceAndSink(candidate.advance(), i);</span>
            }
<span class="fc" id="L190">        }</span>

        /**
         * Consume all items that sort like the current top of the heap. As we cannot advance the iterators to let
         * equivalent items pop up, we walk the heap to find them and mark them as needing advance.
         *
         * This relies on the equalParent flag to avoid doing any comparisons.
         */
        private Out consume()
        {
<span class="fc bfc" id="L200" title="All 2 branches covered.">            if (size == 0)</span>
<span class="fc" id="L201">                return endOfData();</span>

<span class="fc" id="L203">            reducer.onKeyChange();</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">            assert !heap[0].equalParent;</span>
<span class="fc" id="L205">            heap[0].consume(reducer);</span>
<span class="fc" id="L206">            final int size = this.size;</span>
<span class="fc" id="L207">            final int sortedSectionSize = Math.min(size, SORTED_SECTION_SIZE);</span>
            int i;
            consume: {
<span class="fc bfc" id="L210" title="All 2 branches covered.">                for (i = 1; i &lt; sortedSectionSize; ++i)</span>
                {
<span class="fc bfc" id="L212" title="All 2 branches covered.">                    if (!heap[i].equalParent)</span>
<span class="fc" id="L213">                        break consume;</span>
<span class="fc" id="L214">                    heap[i].consume(reducer);</span>
                }
<span class="fc" id="L216">                i = Math.max(i, consumeHeap(i) + 1);</span>
            }
<span class="fc" id="L218">            needingAdvance = i;</span>
<span class="fc" id="L219">            return reducer.getReduced();</span>
        }

        /**
         * Recursively consume all items equal to equalItem in the binary subheap rooted at position idx.
         *
         * @return the largest equal index found in this search.
         */
        private int consumeHeap(int idx)
        {
<span class="fc bfc" id="L229" title="All 4 branches covered.">            if (idx &gt;= size || !heap[idx].equalParent)</span>
<span class="fc" id="L230">                return -1;</span>

<span class="fc" id="L232">            heap[idx].consume(reducer);</span>
<span class="fc" id="L233">            int nextIdx = (idx &lt;&lt; 1) - (SORTED_SECTION_SIZE - 1);</span>
<span class="fc" id="L234">            return Math.max(idx, Math.max(consumeHeap(nextIdx), consumeHeap(nextIdx + 1)));</span>
        }

        /**
         * Replace an iterator in the heap with the given position and move it down the heap until it finds its proper
         * position, pulling lighter elements up the heap.
         *
         * Whenever an equality is found between two elements that form a new parent-child relationship, the child's
         * equalParent flag is set to true if the elements are equal.
         */
        private void replaceAndSink(Candidate&lt;In&gt; candidate, int currIdx)
        {
<span class="fc bfc" id="L246" title="All 2 branches covered.">            if (candidate == null)</span>
            {
                // Drop iterator by replacing it with the last one in the heap.
<span class="fc" id="L249">                candidate = heap[--size];</span>
<span class="fc" id="L250">                heap[size] = null; // not necessary but helpful for debugging</span>
            }
            // The new element will be top of its heap, at this point there is no parent to be equal to.
<span class="fc" id="L253">            candidate.equalParent = false;</span>

<span class="fc" id="L255">            final int size = this.size;</span>
<span class="fc" id="L256">            final int sortedSectionSize = Math.min(size - 1, SORTED_SECTION_SIZE);</span>

            int nextIdx;

            // Advance within the sorted section, pulling up items lighter than candidate.
<span class="fc bfc" id="L261" title="All 2 branches covered.">            while ((nextIdx = currIdx + 1) &lt;= sortedSectionSize)</span>
            {
<span class="fc bfc" id="L263" title="All 2 branches covered.">                if (!heap[nextIdx].equalParent) // if we were greater then an (or were the) equal parent, we are &gt;= the child</span>
                {
<span class="fc" id="L265">                    int cmp = candidate.compareTo(heap[nextIdx]);</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">                    if (cmp &lt;= 0)</span>
                    {
<span class="fc bfc" id="L268" title="All 2 branches covered.">                        heap[nextIdx].equalParent = cmp == 0;</span>
<span class="fc" id="L269">                        heap[currIdx] = candidate;</span>
<span class="fc" id="L270">                        return;</span>
                    }
                }

<span class="fc" id="L274">                heap[currIdx] = heap[nextIdx];</span>
<span class="fc" id="L275">                currIdx = nextIdx;</span>
            }
            // If size &lt;= SORTED_SECTION_SIZE, nextIdx below will be no less than size,
            // because currIdx == sortedSectionSize == size - 1 and nextIdx becomes
            // (size - 1) * 2) - (size - 1 - 1) == size.

            // Advance in the binary heap, pulling up the lighter element from the two at each level.
<span class="fc bfc" id="L282" title="All 2 branches covered.">            while ((nextIdx = (currIdx * 2) - (sortedSectionSize - 1)) + 1 &lt; size)</span>
            {
<span class="fc bfc" id="L284" title="All 2 branches covered.">                if (!heap[nextIdx].equalParent)</span>
                {
<span class="fc bfc" id="L286" title="All 2 branches covered.">                    if (!heap[nextIdx + 1].equalParent)</span>
                    {
                        // pick the smallest of the two children
<span class="fc" id="L289">                        int siblingCmp = heap[nextIdx + 1].compareTo(heap[nextIdx]);</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">                        if (siblingCmp &lt; 0)</span>
<span class="fc" id="L291">                            ++nextIdx;</span>

                        // if we're smaller than this, we are done, and must only restore the heap and equalParent properties
<span class="fc" id="L294">                        int cmp = candidate.compareTo(heap[nextIdx]);</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">                        if (cmp &lt;= 0)</span>
                        {
<span class="fc bfc" id="L297" title="All 2 branches covered.">                            if (cmp == 0)</span>
                            {
<span class="fc" id="L299">                                heap[nextIdx].equalParent = true;</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">                                if (siblingCmp == 0) // siblingCmp == 0 =&gt; nextIdx is the left child</span>
<span class="fc" id="L301">                                    heap[nextIdx + 1].equalParent = true;</span>
                            }

<span class="fc" id="L304">                            heap[currIdx] = candidate;</span>
<span class="fc" id="L305">                            return;</span>
                        }

<span class="fc bfc" id="L308" title="All 2 branches covered.">                        if (siblingCmp == 0)</span>
                        {
                            // siblingCmp == 0 =&gt; nextIdx is still the left child
                            // if the two siblings were equal, and we are inserting something greater, we will
                            // pull up the left one; this means the right gets an equalParent
<span class="fc" id="L313">                            heap[nextIdx + 1].equalParent = true;</span>
                        }
<span class="fc" id="L315">                    }</span>
                    else
<span class="fc" id="L317">                        ++nextIdx;  // descend down the path where we found the equal child</span>
                }

<span class="fc" id="L320">                heap[currIdx] = heap[nextIdx];</span>
<span class="fc" id="L321">                currIdx = nextIdx;</span>
            }

            // our loop guard ensures there are always two siblings to process; typically when we exit the loop we will
            // be well past the end of the heap and this next condition will match...
<span class="fc bfc" id="L326" title="All 2 branches covered.">            if (nextIdx &gt;= size)</span>
            {
<span class="fc" id="L328">                heap[currIdx] = candidate;</span>
<span class="fc" id="L329">                return;</span>
            }

            // ... but sometimes we will have one last child to compare against, that has no siblings
<span class="fc bfc" id="L333" title="All 2 branches covered.">            if (!heap[nextIdx].equalParent)</span>
            {
<span class="fc" id="L335">                int cmp = candidate.compareTo(heap[nextIdx]);</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">                if (cmp &lt;= 0)</span>
                {
<span class="fc bfc" id="L338" title="All 2 branches covered.">                    heap[nextIdx].equalParent = cmp == 0;</span>
<span class="fc" id="L339">                    heap[currIdx] = candidate;</span>
<span class="fc" id="L340">                    return;</span>
                }
            }

<span class="fc" id="L344">            heap[currIdx] = heap[nextIdx];</span>
<span class="fc" id="L345">            heap[nextIdx] = candidate;</span>
<span class="fc" id="L346">        }</span>
    }

    // Holds and is comparable by the head item of an iterator it owns
<span class="fc" id="L350">    protected static final class Candidate&lt;In&gt; implements Comparable&lt;Candidate&lt;In&gt;&gt;</span>
    {
        private final Iterator&lt;? extends In&gt; iter;
        private final Comparator&lt;? super In&gt; comp;
        private final int idx;
        private In item;
        private In lowerBound;
        boolean equalParent;

        public Candidate(int idx, Iterator&lt;? extends In&gt; iter, Comparator&lt;? super In&gt; comp)
<span class="fc" id="L360">        {</span>
<span class="fc" id="L361">            this.iter = iter;</span>
<span class="fc" id="L362">            this.comp = comp;</span>
<span class="fc" id="L363">            this.idx = idx;</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">            this.lowerBound = iter instanceof IteratorWithLowerBound ? ((IteratorWithLowerBound&lt;In&gt;)iter).lowerBound() : null;</span>
<span class="fc" id="L365">        }</span>

        /** @return this if our iterator had an item, and it is now available, otherwise null */
        protected Candidate&lt;In&gt; advance()
        {
<span class="fc bfc" id="L370" title="All 2 branches covered.">            if (lowerBound != null)</span>
            {
<span class="fc" id="L372">                item = lowerBound;</span>
<span class="fc" id="L373">                return this;</span>
            }

<span class="fc bfc" id="L376" title="All 2 branches covered.">            if (!iter.hasNext())</span>
<span class="fc" id="L377">                return null;</span>

<span class="fc" id="L379">            item = iter.next();</span>
<span class="fc" id="L380">            return this;</span>
        }

        public int compareTo(Candidate&lt;In&gt; that)
        {
<span class="pc bpc" id="L385" title="2 of 4 branches missed.">            assert this.item != null &amp;&amp; that.item != null;</span>
<span class="fc" id="L386">            int ret = comp.compare(this.item, that.item);</span>
<span class="pc bpc" id="L387" title="1 of 4 branches missed.">            if (ret == 0 &amp;&amp; (this.isLowerBound() ^ that.isLowerBound()))</span>
            {   // if the items are equal and one of them is a lower bound (but not the other one)
                // then ensure the lower bound is less than the real item so we can safely
                // skip lower bounds when consuming
<span class="nc bnc" id="L391" title="All 2 branches missed.">                return this.isLowerBound() ? -1 : 1;</span>
            }
<span class="fc" id="L393">            return ret;</span>
        }

        private boolean isLowerBound()
        {
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">            assert item != null;</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">            return item == lowerBound;</span>
        }

        public &lt;Out&gt; void consume(Reducer&lt;In, Out&gt; reducer)
        {
<span class="fc bfc" id="L404" title="All 2 branches covered.">            if (isLowerBound())</span>
            {
<span class="fc" id="L406">                item = null;</span>
<span class="fc" id="L407">                lowerBound = null;</span>
            }
            else
            {
<span class="fc" id="L411">                reducer.reduce(idx, item);</span>
<span class="fc" id="L412">                item = null;</span>
            }
<span class="fc" id="L414">        }</span>

        public boolean needsAdvance()
        {
<span class="fc bfc" id="L418" title="All 2 branches covered.">            return item == null;</span>
        }
    }

    /** Accumulator that collects values of type A, and outputs a value of type B. */
<span class="fc" id="L423">    public static abstract class Reducer&lt;In,Out&gt;</span>
    {
        /**
         * @return true if Out is the same as In for the case of a single source iterator
         */
        public boolean trivialReduceIsTrivial()
        {
<span class="fc" id="L430">            return false;</span>
        }

        /**
         * combine this object with the previous ones.
         * intermediate state is up to your implementation.
         */
        public abstract void reduce(int idx, In current);

        /** @return The last object computed by reduce */
        protected abstract Out getReduced();

        /**
         * Called at the beginning of each new key, before any reduce is called.
         * To be overridden by implementing classes.
         */
<span class="nc" id="L446">        protected void onKeyChange() {}</span>

        /**
         * May be overridden by implementations that require cleaning up after use
         */
<span class="fc" id="L451">        public void close() {}</span>
    }

    private static class OneToOne&lt;In, Out&gt; extends MergeIterator&lt;In, Out&gt;
    {
        private final Iterator&lt;In&gt; source;

        public OneToOne(List&lt;? extends Iterator&lt;In&gt;&gt; sources, Reducer&lt;In, Out&gt; reducer)
        {
<span class="fc" id="L460">            super(sources, reducer);</span>
<span class="fc" id="L461">            source = sources.get(0);</span>
<span class="fc" id="L462">        }</span>

        protected Out computeNext()
        {
<span class="fc bfc" id="L466" title="All 2 branches covered.">            if (!source.hasNext())</span>
<span class="fc" id="L467">                return endOfData();</span>
<span class="fc" id="L468">            reducer.onKeyChange();</span>
<span class="fc" id="L469">            reducer.reduce(0, source.next());</span>
<span class="fc" id="L470">            return reducer.getReduced();</span>
        }
    }

    private static class TrivialOneToOne&lt;In, Out&gt; extends MergeIterator&lt;In, Out&gt;
    {
        private final Iterator&lt;In&gt; source;

        public TrivialOneToOne(List&lt;? extends Iterator&lt;In&gt;&gt; sources, Reducer&lt;In, Out&gt; reducer)
        {
<span class="fc" id="L480">            super(sources, reducer);</span>
<span class="fc" id="L481">            source = sources.get(0);</span>
<span class="fc" id="L482">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        protected Out computeNext()
        {
<span class="fc bfc" id="L487" title="All 2 branches covered.">            if (!source.hasNext())</span>
<span class="fc" id="L488">                return endOfData();</span>
<span class="fc" id="L489">            return (Out) source.next();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>