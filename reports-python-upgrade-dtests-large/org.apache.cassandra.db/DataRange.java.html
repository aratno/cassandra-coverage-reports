<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataRange.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db</a> &gt; <span class="el_source">DataRange.java</span></div><h1>DataRange.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db;

import java.io.IOException;
import java.nio.ByteBuffer;

import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.db.filter.*;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.marshal.CompositeType;
import org.apache.cassandra.dht.*;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.utils.bytecomparable.ByteComparable;

/**
 * Groups both the range of partitions to query, and the clustering index filter to
 * apply for each partition (for a (partition) range query).
 * &lt;p&gt;
 * The main &quot;trick&quot; is that the clustering index filter can only be obtained by
 * providing the partition key on which the filter will be applied. This is
 * necessary when paging range queries, as we might need a different filter
 * for the starting key than for other keys (because the previous page we had
 * queried may have ended in the middle of a partition).
 */
public class DataRange
{
<span class="fc" id="L44">    public static final Serializer serializer = new Serializer();</span>

    protected final AbstractBounds&lt;PartitionPosition&gt; keyRange;
    protected final ClusteringIndexFilter clusteringIndexFilter;

    /**
     * Creates a {@code DataRange} given a range of partition keys and a clustering index filter. The
     * return {@code DataRange} will return the same filter for all keys.
     *
     * @param range the range over partition keys to use.
     * @param clusteringIndexFilter the clustering index filter to use.
     */
    public DataRange(AbstractBounds&lt;PartitionPosition&gt; range, ClusteringIndexFilter clusteringIndexFilter)
<span class="fc" id="L57">    {</span>
<span class="fc" id="L58">        this.keyRange = range;</span>
<span class="fc" id="L59">        this.clusteringIndexFilter = clusteringIndexFilter;</span>
<span class="fc" id="L60">    }</span>

    /**
     * Creates a {@code DataRange} to query all data (over the whole ring).
     *
     * @param partitioner the partitioner in use for the table.
     *
     * @return the newly create {@code DataRange}.
     */
    public static DataRange allData(IPartitioner partitioner)
    {
<span class="fc" id="L71">        return forTokenRange(new Range&lt;&gt;(partitioner.getMinimumToken(), partitioner.getMinimumToken()));</span>
    }

    /**
     * Creates a {@code DataRange} to query all rows over the provided token range.
     *
     * @param tokenRange the (partition key) token range to query.
     *
     * @return the newly create {@code DataRange}.
     */
    public static DataRange forTokenRange(Range&lt;Token&gt; tokenRange)
    {
<span class="fc" id="L83">        return forKeyRange(Range.makeRowRange(tokenRange));</span>
    }

    /**
     * Creates a {@code DataRange} to query all rows over the provided key range.
     *
     * @param keyRange the (partition key) range to query.
     *
     * @return the newly create {@code DataRange}.
     */
    public static DataRange forKeyRange(Range&lt;PartitionPosition&gt; keyRange)
    {
<span class="fc" id="L95">        return new DataRange(keyRange, new ClusteringIndexSliceFilter(Slices.ALL, false));</span>
    }

    /**
     * Creates a {@code DataRange} to query all partitions of the ring using the provided
     * clustering index filter.
     *
     * @param partitioner the partitioner in use for the table queried.
     * @param filter the clustering index filter to use.
     *
     * @return the newly create {@code DataRange}.
     */
    public static DataRange allData(IPartitioner partitioner, ClusteringIndexFilter filter)
    {
<span class="nc" id="L109">        return new DataRange(Range.makeRowRange(new Range&lt;&gt;(partitioner.getMinimumToken(), partitioner.getMinimumToken())), filter);</span>
    }

    /**
     * The range of partition key queried by this {@code DataRange}.
     *
     * @return the range of partition key queried by this {@code DataRange}.
     */
    public AbstractBounds&lt;PartitionPosition&gt; keyRange()
    {
<span class="fc" id="L119">        return keyRange;</span>
    }

    /**
     * The start of the partition key range queried by this {@code DataRange}.
     *
     * @return the start of the partition key range queried by this {@code DataRange}.
     */
    public PartitionPosition startKey()
    {
<span class="nc" id="L129">        return keyRange.left;</span>
    }

    /**
     * The end of the partition key range queried by this {@code DataRange}.
     *
     * @return the end of the partition key range queried by this {@code DataRange}.
     */
    public PartitionPosition stopKey()
    {
<span class="nc" id="L139">        return keyRange.right;</span>
    }

    /**
     * The start of the partition key range queried by this {@code DataRange}.
     *
     * @return the start of the partition key range expressed as a ByteComparable.
     */
    public ByteComparable startAsByteComparable()
    {
<span class="nc" id="L149">        PartitionPosition bound = keyRange.left;</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        if (bound.isMinimum())</span>
<span class="nc" id="L151">            return null;</span>

<span class="nc" id="L153">        return bound.asComparableBound(keyRange.inclusiveLeft());</span>
    }

    /**
     * The end of the partition key range queried by this {@code DataRange}.
     *
     * @return the end of the partition key range expressed as a ByteComparable.
     */
    public ByteComparable stopAsByteComparable()
    {
<span class="nc" id="L163">        PartitionPosition bound = keyRange.right;</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (bound.isMinimum())</span>
<span class="nc" id="L165">            return null;</span>

<span class="nc bnc" id="L167" title="All 2 branches missed.">        return bound.asComparableBound(!keyRange.inclusiveRight());</span>
    }

    /**
     * Whether the underlying clustering index filter is a names filter or not.
     *
     * @return Whether the underlying clustering index filter is a names filter or not.
     */
    public boolean isNamesQuery()
    {
<span class="nc" id="L177">        return clusteringIndexFilter instanceof ClusteringIndexNamesFilter;</span>
    }

    /**
     * Whether the data range is for a paged request or not.
     *
     * @return true if for paging, false otherwise
     */
    public boolean isPaging()
    {
<span class="nc" id="L187">        return false;</span>
    }

    /**
     * Whether the range queried by this {@code DataRange} actually wraps around.
     *
     * @return whether the range queried by this {@code DataRange} actually wraps around.
     */
    public boolean isWrapAround()
    {
        // Only range can ever wrap
<span class="nc bnc" id="L198" title="All 4 branches missed.">        return keyRange instanceof Range &amp;&amp; ((Range&lt;?&gt;)keyRange).isWrapAround();</span>
    }

    /**
     * Whether the provided ring position is covered by this {@code DataRange}.
     *
     * @return whether the provided ring position is covered by this {@code DataRange}.
     */
    public boolean contains(PartitionPosition pos)
    {
<span class="nc" id="L208">        return keyRange.contains(pos);</span>
    }

    /**
     * Whether this {@code DataRange} queries everything (has no restriction neither on the
     * partition queried, nor within the queried partition).
     *
     * @return Whether this {@code DataRange} queries everything.
     */
    public boolean isUnrestricted(TableMetadata metadata)
    {
<span class="nc bnc" id="L219" title="All 4 branches missed.">        return startKey().isMinimum() &amp;&amp; stopKey().isMinimum() &amp;&amp;</span>
<span class="nc bnc" id="L220" title="All 4 branches missed.">               (clusteringIndexFilter.selectsAllPartition() || metadata.clusteringColumns().isEmpty());</span>
    }

    public boolean selectsAllPartition()
    {
<span class="fc" id="L225">        return clusteringIndexFilter.selectsAllPartition();</span>
    }

    /**
     * Whether the underlying {@code ClusteringIndexFilter} is reversed or not.
     *
     * @return whether the underlying {@code ClusteringIndexFilter} is reversed or not.
     */
    public boolean isReversed()
    {
<span class="nc" id="L235">        return clusteringIndexFilter.isReversed();</span>
    }

    /**
     * The clustering index filter to use for the provided key.
     * &lt;p&gt;
     * This may or may not be the same filter for all keys (that is, paging range
     * use a different filter for their start key).
     *
     * @param key the partition key for which we want the clustering index filter.
     *
     * @return the clustering filter to use for {@code key}.
     */
    public ClusteringIndexFilter clusteringIndexFilter(DecoratedKey key)
    {
<span class="fc" id="L250">        return clusteringIndexFilter;</span>
    }

    /**
     * Returns a new {@code DataRange} for use when paging {@code this} range.
     *
     * @param range the range of partition keys to query.
     * @param comparator the comparator for the table queried.
     * @param lastReturned the clustering for the last result returned by the previous page, i.e. the result we want to start our new page
     * from. This last returned &lt;b&gt;must&lt;/b&gt; correspond to left bound of {@code range} (in other words, {@code range.left} must be the
     * partition key for that {@code lastReturned} result).
     * @param inclusive whether or not we want to include the {@code lastReturned} in the newly returned page of results.
     *
     * @return a new {@code DataRange} suitable for paging {@code this} range given the {@code lastRetuned} result of the previous page.
     */
    public DataRange forPaging(AbstractBounds&lt;PartitionPosition&gt; range, ClusteringComparator comparator, Clustering&lt;?&gt; lastReturned, boolean inclusive)
    {
<span class="nc" id="L267">        return new Paging(range, clusteringIndexFilter, comparator, lastReturned, inclusive);</span>
    }

    /**
     * Returns a new {@code DataRange} equivalent to {@code this} one but restricted to the provided sub-range.
     *
     * @param range the sub-range to use for the newly returned data range. Note that assumes that {@code range} is a proper
     * sub-range of the initial range but doesn't validate it. You should make sure to only provided sub-ranges however or this
     * might throw off the paging case (see Paging.forSubRange()).
     *
     * @return a new {@code DataRange} using {@code range} as partition key range and the clustering index filter filter from {@code this}.
     */
    public DataRange forSubRange(AbstractBounds&lt;PartitionPosition&gt; range)
    {
<span class="fc" id="L281">        return new DataRange(range, clusteringIndexFilter);</span>
    }

    public String toString(TableMetadata metadata)
    {
<span class="nc" id="L286">        return String.format(&quot;range=%s pfilter=%s&quot;, keyRange.getString(metadata.partitionKeyType), clusteringIndexFilter.toString(metadata));</span>
    }

    public String toCQLString(TableMetadata metadata, RowFilter rowFilter)
    {
<span class="nc bnc" id="L291" title="All 2 branches missed.">        if (isUnrestricted(metadata))</span>
<span class="nc" id="L292">            return rowFilter.toCQLString();</span>

<span class="nc" id="L294">        StringBuilder sb = new StringBuilder();</span>

<span class="nc" id="L296">        boolean needAnd = false;</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">        if (!startKey().isMinimum())</span>
        {
<span class="nc" id="L299">            appendClause(startKey(), sb, metadata, true, keyRange.isStartInclusive());</span>
<span class="nc" id="L300">            needAnd = true;</span>
        }
<span class="nc bnc" id="L302" title="All 2 branches missed.">        if (!stopKey().isMinimum())</span>
        {
<span class="nc bnc" id="L304" title="All 2 branches missed.">            if (needAnd)</span>
<span class="nc" id="L305">                sb.append(&quot; AND &quot;);</span>
<span class="nc" id="L306">            appendClause(stopKey(), sb, metadata, false, keyRange.isEndInclusive());</span>
<span class="nc" id="L307">            needAnd = true;</span>
        }

<span class="nc" id="L310">        String filterString = clusteringIndexFilter.toCQLString(metadata, rowFilter);</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">        if (!filterString.isEmpty())</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">            sb.append(needAnd ? &quot; AND &quot; : &quot;&quot;).append(filterString);</span>

<span class="nc" id="L314">        return sb.toString();</span>
    }

    private void appendClause(PartitionPosition pos, StringBuilder sb, TableMetadata metadata, boolean isStart, boolean isInclusive)
    {
<span class="nc" id="L319">        sb.append(&quot;token(&quot;);</span>
<span class="nc" id="L320">        sb.append(ColumnMetadata.toCQLString(metadata.partitionKeyColumns()));</span>
<span class="nc" id="L321">        sb.append(&quot;) &quot;);</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (pos instanceof DecoratedKey)</span>
        {
<span class="nc" id="L324">            sb.append(getOperator(isStart, isInclusive)).append(&quot; &quot;);</span>
<span class="nc" id="L325">            sb.append(&quot;token(&quot;);</span>
<span class="nc" id="L326">            appendKeyString(sb, metadata.partitionKeyType, ((DecoratedKey)pos).getKey());</span>
<span class="nc" id="L327">            sb.append(&quot;)&quot;);</span>
        }
        else
        {
<span class="nc" id="L331">            Token.KeyBound keyBound = (Token.KeyBound) pos;</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">            sb.append(getOperator(isStart, isStart == keyBound.isMinimumBound)).append(&quot; &quot;);</span>
<span class="nc" id="L333">            sb.append(keyBound.getToken());</span>
        }
<span class="nc" id="L335">    }</span>

    private static String getOperator(boolean isStart, boolean isInclusive)
    {
<span class="nc bnc" id="L339" title="All 2 branches missed.">        return isStart</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">             ? (isInclusive ? &quot;&gt;=&quot; : &quot;&gt;&quot;)</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">             : (isInclusive ? &quot;&lt;=&quot; : &quot;&lt;&quot;);</span>
    }

    public static void appendKeyString(StringBuilder sb, AbstractType&lt;?&gt; type, ByteBuffer key)
    {
<span class="nc bnc" id="L346" title="All 2 branches missed.">        if (type instanceof CompositeType)</span>
        {
<span class="nc" id="L348">            CompositeType ct = (CompositeType)type;</span>
<span class="nc" id="L349">            ByteBuffer[] values = ct.split(key);</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">            for (int i = 0; i &lt; ct.types.size(); i++)</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                sb.append(i == 0 ? &quot;&quot; : &quot;, &quot;).append(ct.types.get(i).toCQLString(values[i]));</span>
<span class="nc" id="L352">        }</span>
        else
        {
<span class="nc" id="L355">            sb.append(type.toCQLString(key));</span>
        }
<span class="nc" id="L357">    }</span>

    /**
     * Specialized {@code DataRange} used for the paging case.
     * &lt;p&gt;
     * It uses the clustering of the last result of the previous page to restrict the filter on the
     * first queried partition (the one for that last result) so it only fetch results that follow that
     * last result. In other words, this makes sure this resume paging where we left off.
     */
<span class="nc" id="L366">    public static class Paging extends DataRange</span>
    {
        private final ClusteringComparator comparator;
        private final Clustering&lt;?&gt; lastReturned;
        private final boolean inclusive;

        private Paging(AbstractBounds&lt;PartitionPosition&gt; range,
                       ClusteringIndexFilter filter,
                       ClusteringComparator comparator,
                       Clustering&lt;?&gt; lastReturned,
                       boolean inclusive)
        {
<span class="nc" id="L378">            super(range, filter);</span>

            // When using a paging range, we don't allow wrapped ranges, as it's unclear how to handle them properly.
            // This is ok for now since we only need this in range queries, and the range are &quot;unwrapped&quot; in that case.
<span class="nc bnc" id="L382" title="All 6 branches missed.">            assert !(range instanceof Range) || !((Range&lt;?&gt;)range).isWrapAround() || range.right.isMinimum() : range;</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">            assert lastReturned != null;</span>

<span class="nc" id="L385">            this.comparator = comparator;</span>
<span class="nc" id="L386">            this.lastReturned = lastReturned;</span>
<span class="nc" id="L387">            this.inclusive = inclusive;</span>
<span class="nc" id="L388">        }</span>

        @Override
        public ClusteringIndexFilter clusteringIndexFilter(DecoratedKey key)
        {
<span class="nc bnc" id="L393" title="All 2 branches missed.">            return key.equals(startKey())</span>
<span class="nc" id="L394">                 ? clusteringIndexFilter.forPaging(comparator, lastReturned, inclusive)</span>
<span class="nc" id="L395">                 : clusteringIndexFilter;</span>
        }

        @Override
        public DataRange forSubRange(AbstractBounds&lt;PartitionPosition&gt; range)
        {
            // This is called for subrange of the initial range. So either it's the beginning of the initial range,
            // and we need to preserver lastReturned, or it's not, and we don't care about it anymore.
<span class="nc bnc" id="L403" title="All 2 branches missed.">            return range.left.equals(keyRange().left)</span>
<span class="nc" id="L404">                 ? new Paging(range, clusteringIndexFilter, comparator, lastReturned, inclusive)</span>
<span class="nc" id="L405">                 : new DataRange(range, clusteringIndexFilter);</span>
        }

        /**
         * @return the last Clustering that was returned (in the previous page)
         */
        public Clustering&lt;?&gt; getLastReturned()
        {
<span class="nc" id="L413">            return lastReturned;</span>
        }

        @Override
        public boolean isPaging()
        {
<span class="nc" id="L419">            return true;</span>
        }

        @Override
        public boolean isUnrestricted(TableMetadata metadata)
        {
<span class="nc" id="L425">            return false;</span>
        }

        @Override
        public String toString(TableMetadata metadata)
        {
<span class="nc" id="L431">            return String.format(&quot;range=%s (paging) pfilter=%s lastReturned=%s (%s)&quot;,</span>
<span class="nc" id="L432">                                 keyRange.getString(metadata.partitionKeyType),</span>
<span class="nc" id="L433">                                 clusteringIndexFilter.toString(metadata),</span>
<span class="nc" id="L434">                                 lastReturned.toString(metadata),</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">                                 inclusive ? &quot;included&quot; : &quot;excluded&quot;);</span>
        }
    }

<span class="fc" id="L439">    public static class Serializer</span>
    {
        public void serialize(DataRange range, DataOutputPlus out, int version, TableMetadata metadata) throws IOException
        {
<span class="fc" id="L443">            AbstractBounds.rowPositionSerializer.serialize(range.keyRange, out, version);</span>
<span class="fc" id="L444">            ClusteringIndexFilter.serializer.serialize(range.clusteringIndexFilter, out, version);</span>
<span class="fc" id="L445">            boolean isPaging = range instanceof Paging;</span>
<span class="fc" id="L446">            out.writeBoolean(isPaging);</span>
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">            if (isPaging)</span>
            {
<span class="nc" id="L449">                Clustering.serializer.serialize(((Paging)range).lastReturned, out, version, metadata.comparator.subtypes());</span>
<span class="nc" id="L450">                out.writeBoolean(((Paging)range).inclusive);</span>
            }
<span class="fc" id="L452">        }</span>

        public DataRange deserialize(DataInputPlus in, int version, TableMetadata metadata) throws IOException
        {
<span class="fc" id="L456">            AbstractBounds&lt;PartitionPosition&gt; range = AbstractBounds.rowPositionSerializer.deserialize(in, metadata.partitioner, version);</span>
<span class="fc" id="L457">            ClusteringIndexFilter filter = ClusteringIndexFilter.serializer.deserialize(in, version, metadata);</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">            if (in.readBoolean())</span>
            {
<span class="nc" id="L460">                ClusteringComparator comparator = metadata.comparator;</span>
<span class="nc" id="L461">                Clustering&lt;byte[]&gt; lastReturned = Clustering.serializer.deserialize(in, version, comparator.subtypes());</span>
<span class="nc" id="L462">                boolean inclusive = in.readBoolean();</span>
<span class="nc" id="L463">                return new Paging(range, filter, comparator, lastReturned, inclusive);</span>
            }
            else
            {
<span class="fc" id="L467">                return new DataRange(range, filter);</span>
            }
        }

        public long serializedSize(DataRange range, int version, TableMetadata metadata)
        {
<span class="fc" id="L473">            long size = AbstractBounds.rowPositionSerializer.serializedSize(range.keyRange, version)</span>
<span class="fc" id="L474">                      + ClusteringIndexFilter.serializer.serializedSize(range.clusteringIndexFilter, version)</span>
                      + 1; // isPaging boolean

<span class="pc bpc" id="L477" title="1 of 2 branches missed.">            if (range instanceof Paging)</span>
            {
<span class="nc" id="L479">                size += Clustering.serializer.serializedSize(((Paging)range).lastReturned, version, metadata.comparator.subtypes());</span>
<span class="nc" id="L480">                size += 1; // inclusive boolean</span>
            }
<span class="fc" id="L482">            return size;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>