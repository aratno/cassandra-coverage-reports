<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RepairCoordinator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.repair</a> &gt; <span class="el_source">RepairCoordinator.java</span></div><h1>RepairCoordinator.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.repair;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Supplier;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;

import org.apache.cassandra.locator.RangesAtEndpoint;
import org.apache.cassandra.utils.*;
import org.apache.cassandra.utils.concurrent.Future;
import org.apache.commons.lang3.time.DurationFormatUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.codahale.metrics.Timer;
import org.apache.cassandra.concurrent.ExecutorPlus;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.cql3.QueryOptions;
import org.apache.cassandra.cql3.QueryProcessor;
import org.apache.cassandra.cql3.UntypedResultSet;
import org.apache.cassandra.cql3.statements.SelectStatement;
import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.ConsistencyLevel;
import org.apache.cassandra.db.Keyspace;
import org.apache.cassandra.dht.Range;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.exceptions.RepairException;
import org.apache.cassandra.locator.EndpointsForRange;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.locator.Replica;
import org.apache.cassandra.metrics.StorageMetrics;
import org.apache.cassandra.repair.messages.RepairOption;
import org.apache.cassandra.repair.state.CoordinatorState;
import org.apache.cassandra.schema.SchemaConstants;
import org.apache.cassandra.schema.SystemDistributedKeyspace;
import org.apache.cassandra.service.ActiveRepairService;
import org.apache.cassandra.service.ActiveRepairService.ParentRepairStatus;
import org.apache.cassandra.service.ClientState;
import org.apache.cassandra.service.StorageService;
import org.apache.cassandra.tracing.TraceKeyspace;
import org.apache.cassandra.tracing.TraceState;
import org.apache.cassandra.tracing.Tracing;
import org.apache.cassandra.transport.messages.ResultMessage;
import org.apache.cassandra.utils.progress.ProgressEvent;
import org.apache.cassandra.utils.progress.ProgressEventNotifier;
import org.apache.cassandra.utils.progress.ProgressEventType;
import org.apache.cassandra.utils.progress.ProgressListener;

import static org.apache.cassandra.repair.state.AbstractState.COMPLETE;
import static org.apache.cassandra.repair.state.AbstractState.INIT;
import static org.apache.cassandra.service.QueryState.forInternalCalls;

public class RepairCoordinator implements Runnable, ProgressEventNotifier, RepairNotifier
{
<span class="nc" id="L90">    private static final Logger logger = LoggerFactory.getLogger(RepairCoordinator.class);</span>

<span class="nc" id="L92">    private static final AtomicInteger THREAD_COUNTER = new AtomicInteger(1);</span>

    public final CoordinatorState state;
    private final String tag;
    private final BiFunction&lt;String, String[], Iterable&lt;ColumnFamilyStore&gt;&gt; validColumnFamilies;
    private final Function&lt;String, RangesAtEndpoint&gt; getLocalReplicas;

<span class="nc" id="L99">    private final List&lt;ProgressListener&gt; listeners = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L100">    private final AtomicReference&lt;Throwable&gt; firstError = new AtomicReference&lt;&gt;(null);</span>
    final SharedContext ctx;

    private TraceState traceState;

    public RepairCoordinator(StorageService storageService, int cmd, RepairOption options, String keyspace)
    {
<span class="nc" id="L107">        this(SharedContext.Global.instance,</span>
<span class="nc" id="L108">                (ks, tables) -&gt; storageService.getValidColumnFamilies(false, false, ks, tables),</span>
<span class="nc" id="L109">                storageService::getLocalReplicas,</span>
                cmd, options, keyspace);
<span class="nc" id="L111">    }</span>

    RepairCoordinator(SharedContext ctx,
                      BiFunction&lt;String, String[], Iterable&lt;ColumnFamilyStore&gt;&gt; validColumnFamilies,
                      Function&lt;String, RangesAtEndpoint&gt; getLocalReplicas,
                      int cmd, RepairOption options, String keyspace)
<span class="nc" id="L117">    {</span>
<span class="nc" id="L118">        this.ctx = ctx;</span>
<span class="nc" id="L119">        this.state = new CoordinatorState(ctx.clock(), cmd, keyspace, options);</span>
<span class="nc" id="L120">        this.tag = &quot;repair:&quot; + cmd;</span>
<span class="nc" id="L121">        this.validColumnFamilies = validColumnFamilies;</span>
<span class="nc" id="L122">        this.getLocalReplicas = getLocalReplicas;</span>
<span class="nc" id="L123">        ctx.repair().register(state);</span>
<span class="nc" id="L124">    }</span>

    @Override
    public void addProgressListener(ProgressListener listener)
    {
<span class="nc" id="L129">        listeners.add(listener);</span>
<span class="nc" id="L130">    }</span>

    @Override
    public void removeProgressListener(ProgressListener listener)
    {
<span class="nc" id="L135">        listeners.remove(listener);</span>
<span class="nc" id="L136">    }</span>


    protected void fireProgressEvent(ProgressEvent event)
    {
<span class="nc bnc" id="L141" title="All 2 branches missed.">        for (ProgressListener listener : listeners)</span>
        {
<span class="nc" id="L143">            listener.progress(tag, event);</span>
<span class="nc" id="L144">        }</span>
<span class="nc" id="L145">    }</span>

    @Override
    public void notification(String msg)
    {
<span class="nc" id="L150">        logger.info(msg);</span>
<span class="nc" id="L151">        fireProgressEvent(jmxEvent(ProgressEventType.NOTIFICATION, msg));</span>
<span class="nc" id="L152">    }</span>

    @Override
    public void notifyError(Throwable error)
    {
        // exception should be ignored
<span class="nc bnc" id="L158" title="All 2 branches missed.">        if (error instanceof SomeRepairFailedException)</span>
<span class="nc" id="L159">            return;</span>

<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (Throwables.anyCauseMatches(error, RepairException::shouldWarn))</span>
        {
<span class="nc" id="L163">            logger.warn(&quot;Repair {} aborted: {}&quot;, state.id, error.getMessage());</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">            if (logger.isDebugEnabled())</span>
<span class="nc" id="L165">                logger.debug(&quot;Repair {} aborted: &quot;, state.id, error);</span>
        }
        else
        {
<span class="nc" id="L169">            logger.error(&quot;Repair {} failed:&quot;, state.id, error);</span>
        }

<span class="nc" id="L172">        StorageMetrics.repairExceptions.inc();</span>
<span class="nc" id="L173">        String errorMessage = String.format(&quot;Repair command #%d failed with error %s&quot;, state.cmd, error.getMessage());</span>
<span class="nc" id="L174">        fireProgressEvent(jmxEvent(ProgressEventType.ERROR, errorMessage));</span>
<span class="nc" id="L175">        firstError.compareAndSet(null, error);</span>

        // since this can fail, update table only after updating in-memory and notification state
<span class="nc" id="L178">        maybeStoreParentRepairFailure(error);</span>
<span class="nc" id="L179">    }</span>

    @Override
    public void notifyProgress(String message)
    {
<span class="nc" id="L184">        logger.info(message);</span>
<span class="nc" id="L185">        fireProgressEvent(jmxEvent(ProgressEventType.PROGRESS, message));</span>
<span class="nc" id="L186">    }</span>

    private void skip(String msg)
    {
<span class="nc" id="L190">        state.phase.skip(msg);</span>
<span class="nc" id="L191">        notification(&quot;Repair &quot; + state.id + &quot; skipped: &quot; + msg);</span>
<span class="nc" id="L192">        success(msg);</span>
<span class="nc" id="L193">    }</span>

    private void success(String msg)
    {
<span class="nc" id="L197">        state.phase.success(msg);</span>
<span class="nc" id="L198">        fireProgressEvent(jmxEvent(ProgressEventType.SUCCESS, msg));</span>
<span class="nc" id="L199">        ctx.repair().recordRepairStatus(state.cmd, ActiveRepairService.ParentRepairStatus.COMPLETED,</span>
<span class="nc" id="L200">                                                        ImmutableList.of(msg));</span>
<span class="nc" id="L201">        complete(null);</span>
<span class="nc" id="L202">    }</span>

    private void fail(String reason)
    {
<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (reason == null)</span>
        {
<span class="nc" id="L208">            Throwable error = firstError.get();</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">            reason = error != null ? error.toString() : &quot;Some repair failed&quot;;</span>
        }
<span class="nc" id="L211">        state.phase.fail(reason);</span>
<span class="nc" id="L212">        String completionMessage = String.format(&quot;Repair command #%d finished with error&quot;, state.cmd);</span>

        // Note we rely on the first message being the reason for the failure
        // when inspecting this state from RepairRunner.queryForCompletedRepair
<span class="nc" id="L216">        ctx.repair().recordRepairStatus(state.cmd, ParentRepairStatus.FAILED,</span>
<span class="nc" id="L217">                                                        ImmutableList.of(reason, completionMessage));</span>

<span class="nc" id="L219">        complete(completionMessage);</span>
<span class="nc" id="L220">    }</span>

    private void complete(String msg)
    {
<span class="nc" id="L224">        long durationMillis = state.getDurationMillis();</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">        if (msg == null)</span>
        {
<span class="nc" id="L227">            String duration = DurationFormatUtils.formatDurationWords(durationMillis, true, true);</span>
<span class="nc" id="L228">            msg = String.format(&quot;Repair command #%d finished in %s&quot;, state.cmd, duration);</span>
        }

<span class="nc" id="L231">        fireProgressEvent(jmxEvent(ProgressEventType.COMPLETE, msg));</span>
<span class="nc" id="L232">        logger.info(state.options.getPreviewKind().logPrefix(state.id) + msg);</span>

<span class="nc" id="L234">        ctx.repair().removeParentRepairSession(state.id);</span>
<span class="nc" id="L235">        TraceState localState = traceState;</span>
<span class="nc bnc" id="L236" title="All 4 branches missed.">        if (state.options.isTraced() &amp;&amp; localState != null)</span>
        {
<span class="nc bnc" id="L238" title="All 2 branches missed.">            for (ProgressListener listener : listeners)</span>
<span class="nc" id="L239">                localState.removeProgressListener(listener);</span>
            // Because ExecutorPlus#afterExecute and this callback
            // run in a nondeterministic order (within the same thread), the
            // TraceState may have been nulled out at this point. The TraceState
            // should be traceState, so just set it without bothering to check if it
            // actually was nulled out.
<span class="nc" id="L245">            Tracing.instance.set(localState);</span>
<span class="nc" id="L246">            Tracing.traceRepair(msg);</span>
<span class="nc" id="L247">            Tracing.instance.stopSession();</span>
        }

<span class="nc" id="L250">        Keyspace.open(state.keyspace).metric.repairTime.update(durationMillis, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L251">    }</span>

    public void run()
    {
        try
        {
<span class="nc" id="L257">            runMayThrow();</span>
        }
<span class="nc" id="L259">        catch (SkipRepairException e)</span>
        {
<span class="nc" id="L261">            skip(e.getMessage());</span>
        }
<span class="nc" id="L263">        catch (Throwable e)</span>
        {
<span class="nc" id="L265">            notifyError(e);</span>
<span class="nc" id="L266">            fail(e.getMessage());</span>
<span class="nc" id="L267">        }</span>
<span class="nc" id="L268">    }</span>

    private void runMayThrow() throws Throwable
    {
<span class="nc" id="L272">        state.phase.setup();</span>
<span class="nc" id="L273">        ctx.repair().recordRepairStatus(state.cmd, ParentRepairStatus.IN_PROGRESS, ImmutableList.of());</span>

<span class="nc" id="L275">        List&lt;ColumnFamilyStore&gt; columnFamilies = getColumnFamilies();</span>
<span class="nc" id="L276">        String[] cfnames = columnFamilies.stream().map(cfs -&gt; cfs.name).toArray(String[]::new);</span>

<span class="nc" id="L278">        this.traceState = maybeCreateTraceState(columnFamilies);</span>
<span class="nc" id="L279">        notifyStarting();</span>
<span class="nc" id="L280">        NeighborsAndRanges neighborsAndRanges = getNeighborsAndRanges();</span>
        // We test to validate the start JMX notification is seen before we compute neighbors and ranges
        // but in state (vtable) tracking, we rely on getNeighborsAndRanges to know where we are running repair...
        // JMX start != state start, its possible we fail in getNeighborsAndRanges and state start is never reached
<span class="nc" id="L284">        state.phase.start(columnFamilies, neighborsAndRanges);</span>

<span class="nc" id="L286">        maybeStoreParentRepairStart(cfnames);</span>

<span class="nc" id="L288">        prepare(columnFamilies, neighborsAndRanges.participants, neighborsAndRanges.shouldExcludeDeadParticipants)</span>
<span class="nc" id="L289">        .flatMap(ignore -&gt; repair(cfnames, neighborsAndRanges))</span>
<span class="nc" id="L290">        .addCallback((pair, failure) -&gt; {</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">            if (failure != null)</span>
            {
<span class="nc" id="L293">                notifyError(failure);</span>
<span class="nc" id="L294">                fail(failure.getMessage());</span>
            }
            else
            {
<span class="nc" id="L298">                state.phase.repairCompleted();</span>
<span class="nc" id="L299">                CoordinatedRepairResult result = pair.left;</span>
<span class="nc" id="L300">                maybeStoreParentRepairSuccess(result.successfulRanges);</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">                if (result.hasFailed())</span>
                {
<span class="nc" id="L303">                    fail(null);</span>
                }
                else
                {
<span class="nc" id="L307">                    success(pair.right.get());</span>
<span class="nc" id="L308">                    ctx.repair().cleanUp(state.id, neighborsAndRanges.participants);</span>
                }
            }
<span class="nc" id="L311">        });</span>
<span class="nc" id="L312">    }</span>

    private List&lt;ColumnFamilyStore&gt; getColumnFamilies()
    {
<span class="nc" id="L316">        String[] columnFamilies = state.options.getColumnFamilies().toArray(new String[state.options.getColumnFamilies().size()]);</span>
<span class="nc" id="L317">        Iterable&lt;ColumnFamilyStore&gt; validColumnFamilies = this.validColumnFamilies.apply(state.keyspace, columnFamilies);</span>

<span class="nc bnc" id="L319" title="All 2 branches missed.">        if (Iterables.isEmpty(validColumnFamilies))</span>
<span class="nc" id="L320">            throw new SkipRepairException(String.format(&quot;%s Empty keyspace, skipping repair: %s&quot;, state.id, state.keyspace));</span>
<span class="nc" id="L321">        return Lists.newArrayList(validColumnFamilies);</span>
    }

    private TraceState maybeCreateTraceState(Iterable&lt;ColumnFamilyStore&gt; columnFamilyStores)
    {
<span class="nc bnc" id="L326" title="All 2 branches missed.">        if (!state.options.isTraced())</span>
<span class="nc" id="L327">            return null;</span>

<span class="nc" id="L329">        StringBuilder cfsb = new StringBuilder();</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">        for (ColumnFamilyStore cfs : columnFamilyStores)</span>
<span class="nc" id="L331">            cfsb.append(&quot;, &quot;).append(cfs.getKeyspaceName()).append(&quot;.&quot;).append(cfs.name);</span>

<span class="nc" id="L333">        TimeUUID sessionId = Tracing.instance.newSession(Tracing.TraceType.REPAIR);</span>
<span class="nc" id="L334">        TraceState traceState = Tracing.instance.begin(&quot;repair&quot;, ImmutableMap.of(&quot;keyspace&quot;, state.keyspace, &quot;columnFamilies&quot;,</span>
<span class="nc" id="L335">                                                                                 cfsb.substring(2)));</span>
<span class="nc" id="L336">        traceState.enableActivityNotification(tag);</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">        for (ProgressListener listener : listeners)</span>
<span class="nc" id="L338">            traceState.addProgressListener(listener);</span>
<span class="nc" id="L339">        Thread queryThread = createQueryThread(sessionId);</span>
<span class="nc" id="L340">        queryThread.setName(&quot;RepairTracePolling&quot;);</span>
<span class="nc" id="L341">        return traceState;</span>
    }

    private void notifyStarting()
    {
<span class="nc" id="L346">        String message = String.format(&quot;Starting repair command #%d (%s), repairing keyspace %s with %s&quot;, state.cmd, state.id, state.keyspace,</span>
                                       state.options);
<span class="nc" id="L348">        logger.info(message);</span>
<span class="nc" id="L349">        Tracing.traceRepair(message);</span>
<span class="nc" id="L350">        fireProgressEvent(jmxEvent(ProgressEventType.START, message));</span>
<span class="nc" id="L351">    }</span>

    private NeighborsAndRanges getNeighborsAndRanges() throws RepairException
    {
<span class="nc" id="L355">        Set&lt;InetAddressAndPort&gt; allNeighbors = new HashSet&lt;&gt;();</span>
<span class="nc" id="L356">        List&lt;CommonRange&gt; commonRanges = new ArrayList&lt;&gt;();</span>

        //pre-calculate output of getLocalReplicas and pass it to getNeighbors to increase performance and prevent
        //calculation multiple times
<span class="nc" id="L360">        Iterable&lt;Range&lt;Token&gt;&gt; keyspaceLocalRanges = getLocalReplicas.apply(state.keyspace).ranges();</span>

<span class="nc bnc" id="L362" title="All 2 branches missed.">        for (Range&lt;Token&gt; range : state.options.getRanges())</span>
        {
<span class="nc" id="L364">            EndpointsForRange neighbors = ctx.repair().getNeighbors(state.keyspace, keyspaceLocalRanges, range,</span>
<span class="nc" id="L365">                                                                           state.options.getDataCenters(),</span>
<span class="nc" id="L366">                                                                           state.options.getHosts());</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">            if (neighbors.isEmpty())</span>
            {
<span class="nc bnc" id="L369" title="All 2 branches missed.">                if (state.options.ignoreUnreplicatedKeyspaces())</span>
                {
<span class="nc" id="L371">                    logger.info(&quot;{} Found no neighbors for range {} for {} - ignoring since repairing with --ignore-unreplicated-keyspaces&quot;, state.id, range, state.keyspace);</span>
<span class="nc" id="L372">                    continue;</span>
                }
                else
                {
<span class="nc" id="L376">                    throw RepairException.warn(String.format(&quot;Nothing to repair for %s in %s - aborting&quot;, range, state.keyspace));</span>
                }
            }
<span class="nc" id="L379">            addRangeToNeighbors(commonRanges, range, neighbors);</span>
<span class="nc" id="L380">            allNeighbors.addAll(neighbors.endpoints());</span>
<span class="nc" id="L381">        }</span>

<span class="nc bnc" id="L383" title="All 4 branches missed.">        if (state.options.ignoreUnreplicatedKeyspaces() &amp;&amp; allNeighbors.isEmpty())</span>
        {
<span class="nc" id="L385">            throw new SkipRepairException(String.format(&quot;Nothing to repair for %s in %s - unreplicated keyspace is ignored since repair was called with --ignore-unreplicated-keyspaces&quot;,</span>
<span class="nc" id="L386">                                                        state.options.getRanges(),</span>
                                                        state.keyspace));
        }

<span class="nc" id="L390">        boolean shouldExcludeDeadParticipants = state.options.isForcedRepair();</span>

<span class="nc bnc" id="L392" title="All 2 branches missed.">        if (shouldExcludeDeadParticipants)</span>
        {
<span class="nc" id="L394">            Set&lt;InetAddressAndPort&gt; actualNeighbors = Sets.newHashSet(Iterables.filter(allNeighbors, ctx.failureDetector()::isAlive));</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">            shouldExcludeDeadParticipants = !allNeighbors.equals(actualNeighbors);</span>
<span class="nc" id="L396">            allNeighbors = actualNeighbors;</span>
        }
<span class="nc" id="L398">        return new NeighborsAndRanges(shouldExcludeDeadParticipants, allNeighbors, commonRanges);</span>
    }

    private void maybeStoreParentRepairStart(String[] cfnames)
    {
<span class="nc bnc" id="L403" title="All 2 branches missed.">        if (!state.options.isPreview())</span>
        {
<span class="nc" id="L405">            SystemDistributedKeyspace.startParentRepair(state.id, state.keyspace, cfnames, state.options);</span>
        }
<span class="nc" id="L407">    }</span>

    private void maybeStoreParentRepairSuccess(Collection&lt;Range&lt;Token&gt;&gt; successfulRanges)
    {
<span class="nc bnc" id="L411" title="All 2 branches missed.">        if (!state.options.isPreview())</span>
        {
<span class="nc" id="L413">            SystemDistributedKeyspace.successfulParentRepair(state.id, successfulRanges);</span>
        }
<span class="nc" id="L415">    }</span>

    private void maybeStoreParentRepairFailure(Throwable error)
    {
<span class="nc bnc" id="L419" title="All 2 branches missed.">        if (!state.options.isPreview())</span>
        {
<span class="nc" id="L421">            SystemDistributedKeyspace.failParentRepair(state.id, error);</span>
        }
<span class="nc" id="L423">    }</span>

    private Future&lt;?&gt; prepare(List&lt;ColumnFamilyStore&gt; columnFamilies, Set&lt;InetAddressAndPort&gt; allNeighbors, boolean force)
    {
<span class="nc" id="L427">        state.phase.prepareStart();</span>
<span class="nc" id="L428">        Timer timer = Keyspace.open(state.keyspace).metric.repairPrepareTime;</span>
<span class="nc" id="L429">        long startNanos = ctx.clock().nanoTime();</span>
<span class="nc" id="L430">        return ctx.repair().prepareForRepair(state.id, ctx.broadcastAddressAndPort(), allNeighbors, state.options, force, columnFamilies)</span>
<span class="nc" id="L431">                  .map(ignore -&gt; {</span>
<span class="nc" id="L432">                      timer.update(ctx.clock().nanoTime() - startNanos, TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L433">                      state.phase.prepareComplete();</span>
<span class="nc" id="L434">                      return null;</span>
                  });
    }

    private Future&lt;Pair&lt;CoordinatedRepairResult, Supplier&lt;String&gt;&gt;&gt; repair(String[] cfnames, NeighborsAndRanges neighborsAndRanges)
    {
        RepairTask task;
<span class="nc bnc" id="L441" title="All 2 branches missed.">        if (state.options.isPreview())</span>
        {
<span class="nc" id="L443">            task = new PreviewRepairTask(this, state.id, neighborsAndRanges.filterCommonRanges(state.keyspace, cfnames), cfnames);</span>
        }
<span class="nc bnc" id="L445" title="All 2 branches missed.">        else if (state.options.isIncremental())</span>
        {
<span class="nc" id="L447">            task = new IncrementalRepairTask(this, state.id, neighborsAndRanges, cfnames);</span>
        }
        else
        {
<span class="nc" id="L451">            task = new NormalRepairTask(this, state.id, neighborsAndRanges.filterCommonRanges(state.keyspace, cfnames), cfnames);</span>
        }

<span class="nc" id="L454">        ExecutorPlus executor = createExecutor();</span>
<span class="nc" id="L455">        state.phase.repairSubmitted();</span>
<span class="nc" id="L456">        return task.perform(executor)</span>
                   // after adding the callback java could no longer infer the type...
<span class="nc" id="L458">                   .&lt;Pair&lt;CoordinatedRepairResult, Supplier&lt;String&gt;&gt;&gt;map(r -&gt; Pair.create(r, task::successMessage))</span>
<span class="nc" id="L459">                   .addCallback((s, f) -&gt; executor.shutdown());</span>
    }

    private ExecutorPlus createExecutor()
    {
<span class="nc" id="L464">        return ctx.executorFactory()</span>
<span class="nc" id="L465">                .localAware()</span>
<span class="nc" id="L466">                .withJmxInternal()</span>
<span class="nc" id="L467">                .pooled(&quot;Repair#&quot; + state.cmd, state.options.getJobThreads());</span>
    }

    private static void addRangeToNeighbors(List&lt;CommonRange&gt; neighborRangeList, Range&lt;Token&gt; range, EndpointsForRange neighbors)
    {
<span class="nc" id="L472">        Set&lt;InetAddressAndPort&gt; endpoints = neighbors.endpoints();</span>
<span class="nc" id="L473">        Set&lt;InetAddressAndPort&gt; transEndpoints = neighbors.filter(Replica::isTransient).endpoints();</span>

<span class="nc bnc" id="L475" title="All 2 branches missed.">        for (CommonRange commonRange : neighborRangeList)</span>
        {
<span class="nc bnc" id="L477" title="All 2 branches missed.">            if (commonRange.matchesEndpoints(endpoints, transEndpoints))</span>
            {
<span class="nc" id="L479">                commonRange.ranges.add(range);</span>
<span class="nc" id="L480">                return;</span>
            }
<span class="nc" id="L482">        }</span>

<span class="nc" id="L484">        List&lt;Range&lt;Token&gt;&gt; ranges = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L485">        ranges.add(range);</span>
<span class="nc" id="L486">        neighborRangeList.add(new CommonRange(endpoints, transEndpoints, ranges));</span>
<span class="nc" id="L487">    }</span>

    private Thread createQueryThread(final TimeUUID sessionId)
    {
<span class="nc" id="L491">        return ctx.executorFactory().startThread(&quot;Repair-Runnable-&quot; + THREAD_COUNTER.incrementAndGet(), new WrappedRunnable()</span>
<span class="nc" id="L492">        {</span>
            // Query events within a time interval that overlaps the last by one second. Ignore duplicates. Ignore local traces.
            // Wake up upon local trace activity. Query when notified of trace activity with a timeout that doubles every two timeouts.
            public void runMayThrow() throws Exception
            {
<span class="nc" id="L497">                TraceState state = Tracing.instance.get(sessionId);</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">                if (state == null)</span>
<span class="nc" id="L499">                    throw new Exception(&quot;no tracestate&quot;);</span>

<span class="nc" id="L501">                String format = &quot;select event_id, source, source_port, activity from %s.%s where session_id = ? and event_id &gt; ? and event_id &lt; ?;&quot;;</span>
<span class="nc" id="L502">                String query = String.format(format, SchemaConstants.TRACE_KEYSPACE_NAME, TraceKeyspace.EVENTS);</span>
<span class="nc" id="L503">                SelectStatement statement = (SelectStatement) QueryProcessor.parseStatement(query).prepare(ClientState.forInternalCalls());</span>

<span class="nc" id="L505">                ByteBuffer sessionIdBytes = sessionId.toBytes();</span>
<span class="nc" id="L506">                InetAddressAndPort source = ctx.broadcastAddressAndPort();</span>

<span class="nc" id="L508">                HashSet&lt;UUID&gt;[] seen = new HashSet[]{ new HashSet&lt;&gt;(), new HashSet&lt;&gt;() };</span>
<span class="nc" id="L509">                int si = 0;</span>
                UUID uuid;

<span class="nc" id="L512">                long tlast = ctx.clock().currentTimeMillis(), tcur;</span>

                TraceState.Status status;
<span class="nc" id="L515">                long minWaitMillis = 125;</span>
<span class="nc" id="L516">                long maxWaitMillis = 1000 * 1024L;</span>
<span class="nc" id="L517">                long timeout = minWaitMillis;</span>
<span class="nc" id="L518">                boolean shouldDouble = false;</span>

<span class="nc bnc" id="L520" title="All 2 branches missed.">                while ((status = state.waitActivity(timeout)) != TraceState.Status.STOPPED)</span>
                {
<span class="nc bnc" id="L522" title="All 2 branches missed.">                    if (status == TraceState.Status.IDLE)</span>
                    {
<span class="nc bnc" id="L524" title="All 2 branches missed.">                        timeout = shouldDouble ? Math.min(timeout * 2, maxWaitMillis) : timeout;</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">                        shouldDouble = !shouldDouble;</span>
                    }
                    else
                    {
<span class="nc" id="L529">                        timeout = minWaitMillis;</span>
<span class="nc" id="L530">                        shouldDouble = false;</span>
                    }
<span class="nc" id="L532">                    ByteBuffer tminBytes = TimeUUID.minAtUnixMillis(tlast - 1000).toBytes();</span>
<span class="nc" id="L533">                    ByteBuffer tmaxBytes = TimeUUID.maxAtUnixMillis(tcur = ctx.clock().currentTimeMillis()).toBytes();</span>
<span class="nc" id="L534">                    QueryOptions options = QueryOptions.forInternalCalls(ConsistencyLevel.ONE, Lists.newArrayList(sessionIdBytes,</span>
                                                                                                                  tminBytes,
                                                                                                                  tmaxBytes));
<span class="nc" id="L537">                    ResultMessage.Rows rows = statement.execute(forInternalCalls(), options, ctx.clock().nanoTime());</span>
<span class="nc" id="L538">                    UntypedResultSet result = UntypedResultSet.create(rows.result);</span>

<span class="nc bnc" id="L540" title="All 2 branches missed.">                    for (UntypedResultSet.Row r : result)</span>
                    {
<span class="nc" id="L542">                        int port = DatabaseDescriptor.getStoragePort();</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">                        if (r.has(&quot;source_port&quot;))</span>
<span class="nc" id="L544">                            port = r.getInt(&quot;source_port&quot;);</span>
<span class="nc" id="L545">                        InetAddressAndPort eventNode = InetAddressAndPort.getByAddressOverrideDefaults(r.getInetAddress(&quot;source&quot;), port);</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">                        if (source.equals(eventNode))</span>
<span class="nc" id="L547">                            continue;</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">                        if ((uuid = r.getUUID(&quot;event_id&quot;)).timestamp() &gt; (tcur - 1000) * 10000)</span>
<span class="nc" id="L549">                            seen[si].add(uuid);</span>
<span class="nc bnc" id="L550" title="All 4 branches missed.">                        if (seen[si == 0 ? 1 : 0].contains(uuid))</span>
<span class="nc" id="L551">                            continue;</span>
<span class="nc" id="L552">                        String message = String.format(&quot;%s: %s&quot;, r.getInetAddress(&quot;source&quot;), r.getString(&quot;activity&quot;));</span>
<span class="nc" id="L553">                        notification(message);</span>
<span class="nc" id="L554">                    }</span>
<span class="nc" id="L555">                    tlast = tcur;</span>

<span class="nc bnc" id="L557" title="All 2 branches missed.">                    si = si == 0 ? 1 : 0;</span>
<span class="nc" id="L558">                    seen[si].clear();</span>
<span class="nc" id="L559">                }</span>
<span class="nc" id="L560">            }</span>
        });
    }

    private ProgressEvent jmxEvent(ProgressEventType type, String msg)
    {
<span class="nc" id="L566">        int length = CoordinatorState.State.values().length + 1; // +1 to include completed state</span>
<span class="nc" id="L567">        int currentState = state.getCurrentState();</span>
<span class="nc bnc" id="L568" title="All 4 branches missed.">        return new ProgressEvent(type, currentState == INIT ? 0 : currentState == COMPLETE ? length : currentState, length, msg);</span>
    }

    private static final class SkipRepairException extends RuntimeException
    {
        SkipRepairException(String message)
        {
<span class="nc" id="L575">            super(message);</span>
<span class="nc" id="L576">        }</span>
    }

    public static final class NeighborsAndRanges
    {
        final boolean shouldExcludeDeadParticipants;
        public final Set&lt;InetAddressAndPort&gt; participants;
        public final List&lt;CommonRange&gt; commonRanges;

        public NeighborsAndRanges(boolean shouldExcludeDeadParticipants, Set&lt;InetAddressAndPort&gt; participants, List&lt;CommonRange&gt; commonRanges)
<span class="nc" id="L586">        {</span>
<span class="nc" id="L587">            this.shouldExcludeDeadParticipants = shouldExcludeDeadParticipants;</span>
<span class="nc" id="L588">            this.participants = participants;</span>
<span class="nc" id="L589">            this.commonRanges = commonRanges;</span>
<span class="nc" id="L590">        }</span>

        /**
         * When in the force mode, removes dead nodes from common ranges (not contained within `allNeighbors`),
         * and exludes ranges left without any participants
         * When not in the force mode, no-op.
         */
        public List&lt;CommonRange&gt; filterCommonRanges(String keyspace, String[] tableNames)
        {
<span class="nc bnc" id="L599" title="All 2 branches missed.">            if (!shouldExcludeDeadParticipants)</span>
            {
<span class="nc" id="L601">                return commonRanges;</span>
            }
            else
            {
<span class="nc" id="L605">                logger.debug(&quot;force flag set, removing dead endpoints if possible&quot;);</span>

<span class="nc" id="L607">                List&lt;CommonRange&gt; filtered = new ArrayList&lt;&gt;(commonRanges.size());</span>

<span class="nc bnc" id="L609" title="All 2 branches missed.">                for (CommonRange commonRange : commonRanges)</span>
                {
<span class="nc" id="L611">                    Set&lt;InetAddressAndPort&gt; endpoints = ImmutableSet.copyOf(Iterables.filter(commonRange.endpoints, participants::contains));</span>
<span class="nc" id="L612">                    Set&lt;InetAddressAndPort&gt; transEndpoints = ImmutableSet.copyOf(Iterables.filter(commonRange.transEndpoints, participants::contains));</span>
<span class="nc" id="L613">                    Preconditions.checkState(endpoints.containsAll(transEndpoints), &quot;transEndpoints must be a subset of endpoints&quot;);</span>

                    // this node is implicitly a participant in this repair, so a single endpoint is ok here
<span class="nc bnc" id="L616" title="All 2 branches missed.">                    if (!endpoints.isEmpty())</span>
                    {
<span class="nc" id="L618">                        Set&lt;InetAddressAndPort&gt; skippedReplicas = Sets.difference(commonRange.endpoints, endpoints);</span>
<span class="nc" id="L619">                        skippedReplicas.forEach(endpoint -&gt; logger.info(&quot;Removing a dead node {} from repair for ranges {} due to -force&quot;, endpoint, commonRange.ranges));</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">                        filtered.add(new CommonRange(endpoints, transEndpoints, commonRange.ranges, !skippedReplicas.isEmpty()));</span>
<span class="nc" id="L621">                    }</span>
                    else
                    {
<span class="nc" id="L624">                        logger.warn(&quot;Skipping forced repair for ranges {} of tables {} in keyspace {}, as no neighbor nodes are live.&quot;,</span>
<span class="nc" id="L625">                                    commonRange.ranges, Arrays.asList(tableNames), keyspace);</span>
                    }
<span class="nc" id="L627">                }</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">                Preconditions.checkState(!filtered.isEmpty(), &quot;Not enough live endpoints for a repair&quot;);</span>
<span class="nc" id="L629">                return filtered;</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>