<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BtiTableReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.io.sstable.format.bti</a> &gt; <span class="el_source">BtiTableReader.java</span></div><h1>BtiTableReader.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.io.sstable.format.bti;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;

import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.DataRange;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.DeletionTime;
import org.apache.cassandra.db.PartitionPosition;
import org.apache.cassandra.db.Slices;
import org.apache.cassandra.db.filter.ColumnFilter;
import org.apache.cassandra.db.partitions.UnfilteredPartitionIterator;
import org.apache.cassandra.db.rows.Rows;
import org.apache.cassandra.db.rows.UnfilteredRowIterator;
import org.apache.cassandra.db.rows.UnfilteredRowIterators;
import org.apache.cassandra.dht.AbstractBounds;
import org.apache.cassandra.dht.Range;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.io.sstable.CorruptSSTableException;
import org.apache.cassandra.io.sstable.Descriptor;
import org.apache.cassandra.io.sstable.ISSTableScanner;
import org.apache.cassandra.io.sstable.IVerifier;
import org.apache.cassandra.io.sstable.SSTable;
import org.apache.cassandra.io.sstable.SSTableReadsListener;
import org.apache.cassandra.io.sstable.SSTableReadsListener.SelectionReason;
import org.apache.cassandra.io.sstable.SSTableReadsListener.SkippingReason;
import org.apache.cassandra.io.sstable.format.SSTableReaderWithFilter;
import org.apache.cassandra.io.util.FileDataInput;
import org.apache.cassandra.io.util.FileHandle;
import org.apache.cassandra.io.util.RandomAccessReader;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.IFilter;
import org.apache.cassandra.utils.OutputHandler;

import static org.apache.cassandra.io.sstable.format.SSTableReader.Operator.EQ;
import static org.apache.cassandra.io.sstable.format.SSTableReader.Operator.GE;
import static org.apache.cassandra.io.sstable.format.SSTableReader.Operator.GT;
import static org.apache.cassandra.utils.concurrent.SharedCloseable.sharedCopyOrNull;

/**
 * Reader of SSTable files in BTI format (see {@link BtiFormat}), written by {@link BtiTableWriter}.
 * &lt;p&gt;
 * SSTableReaders are open()ed by Keyspace.onStart; after that they are created by SSTableWriter.renameAndOpen.
 * Do not re-call open() on existing SSTable files; use the references kept by ColumnFamilyStore post-start instead.
 */
<span class="nc" id="L73">public class BtiTableReader extends SSTableReaderWithFilter</span>
{
    private final FileHandle rowIndexFile;
    private final PartitionIndex partitionIndex;

    public BtiTableReader(Builder builder, SSTable.Owner owner)
    {
<span class="nc" id="L80">        super(builder, owner);</span>
<span class="nc" id="L81">        this.rowIndexFile = builder.getRowIndexFile();</span>
<span class="nc" id="L82">        this.partitionIndex = builder.getPartitionIndex();</span>
<span class="nc" id="L83">    }</span>

    protected final Builder unbuildTo(Builder builder, boolean sharedCopy)
    {
<span class="nc" id="L87">        Builder b = super.unbuildTo(builder, sharedCopy);</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">        if (builder.getPartitionIndex() == null)</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">            b.setPartitionIndex(sharedCopy ? sharedCopyOrNull(partitionIndex) : partitionIndex);</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">        if (builder.getRowIndexFile() == null)</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">            b.setRowIndexFile(sharedCopy ? sharedCopyOrNull(rowIndexFile) : rowIndexFile);</span>

<span class="nc" id="L93">        return b;</span>
    }

    @Override
    protected List&lt;AutoCloseable&gt; setupInstance(boolean trackHotness)
    {
<span class="nc" id="L99">        ArrayList&lt;AutoCloseable&gt; closeables = Lists.newArrayList(rowIndexFile, partitionIndex);</span>
<span class="nc" id="L100">        closeables.addAll(super.setupInstance(trackHotness));</span>
<span class="nc" id="L101">        return closeables;</span>
    }

    /**
     * Whether to filter out data before {@link #first}. Needed for sources of data in a compaction, where the relevant
     * output is opened early -- in this case the sstable's start is changed, but the data can still be found in the
     * file. Range and point queries must filter it out.
     */
    protected boolean filterFirst()
    {
<span class="nc bnc" id="L111" title="All 2 branches missed.">        return openReason == OpenReason.MOVED_START;</span>
    }

    /**
     * Whether to filter out data after {@link #last}. Early-open sstables may contain data beyond the switch point
     * (because an early-opened sstable is not ready until buffers have been flushed), and leaving that data visible
     * will give a redundant copy with all associated overheads.
     */
    protected boolean filterLast()
    {
<span class="nc bnc" id="L121" title="All 4 branches missed.">        return openReason == OpenReason.EARLY &amp;&amp; partitionIndex instanceof PartitionIndexEarly;</span>
    }

    public long estimatedKeys()
    {
<span class="nc bnc" id="L126" title="All 2 branches missed.">        return partitionIndex == null ? 0 : partitionIndex.size();</span>
    }

    @Override
    protected TrieIndexEntry getRowIndexEntry(PartitionPosition key,
                                              Operator operator,
                                              boolean updateStats,
                                              SSTableReadsListener listener)
    {
        PartitionPosition searchKey;
        Operator searchOp;

<span class="nc bnc" id="L138" title="All 2 branches missed.">        if (operator == EQ)</span>
<span class="nc" id="L139">            return getExactPosition((DecoratedKey) key, listener, updateStats);</span>

<span class="nc bnc" id="L141" title="All 4 branches missed.">        if (operator == GT || operator == GE)</span>
        {
<span class="nc bnc" id="L143" title="All 4 branches missed.">            if (filterLast() &amp;&amp; getLast().compareTo(key) &lt; 0)</span>
            {
<span class="nc" id="L145">                notifySkipped(SkippingReason.MIN_MAX_KEYS, listener, operator, updateStats);</span>
<span class="nc" id="L146">                return null;</span>
            }
<span class="nc bnc" id="L148" title="All 4 branches missed.">            boolean filteredLeft = (filterFirst() &amp;&amp; getFirst().compareTo(key) &gt; 0);</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">            searchKey = filteredLeft ? getFirst() : key;</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">            searchOp = filteredLeft ? GE : operator;</span>

<span class="nc" id="L152">            try (PartitionIndex.Reader reader = partitionIndex.openReader())</span>
            {
<span class="nc" id="L154">                TrieIndexEntry rie = reader.ceiling(searchKey, (pos, assumeNoMatch, compareKey) -&gt; retrieveEntryIfAcceptable(searchOp, compareKey, pos, assumeNoMatch));</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">                if (rie != null)</span>
<span class="nc" id="L156">                    notifySelected(SelectionReason.INDEX_ENTRY_FOUND, listener, operator, updateStats, rie);</span>
                else
<span class="nc" id="L158">                    notifySkipped(SkippingReason.INDEX_ENTRY_NOT_FOUND, listener, operator, updateStats);</span>
<span class="nc" id="L159">                return rie;</span>
            }
<span class="nc" id="L161">            catch (IOException e)</span>
            {
<span class="nc" id="L163">                markSuspect();</span>
<span class="nc" id="L164">                throw new CorruptSSTableException(e, rowIndexFile.path());</span>
            }
        }

<span class="nc" id="L168">        throw new IllegalArgumentException(&quot;Invalid op: &quot; + operator);</span>
    }

    /**
     * Called by {@link #getRowIndexEntry} above (via Reader.ceiling/floor) to check if the position satisfies the full
     * key constraint. This is called once if there is a prefix match (which can be in any relationship with the sought
     * key, thus assumeNoMatch: false), and if it returns null it is called again for the closest greater position
     * (with assumeNoMatch: true).
     * Returns the index entry at this position, or null if the search op rejects it.
     */
    private TrieIndexEntry retrieveEntryIfAcceptable(Operator searchOp, PartitionPosition searchKey, long pos, boolean assumeNoMatch) throws IOException
    {
<span class="nc bnc" id="L180" title="All 2 branches missed.">        if (pos &gt;= 0)</span>
        {
<span class="nc" id="L182">            try (FileDataInput in = rowIndexFile.createReader(pos))</span>
            {
<span class="nc bnc" id="L184" title="All 2 branches missed.">                if (assumeNoMatch)</span>
<span class="nc" id="L185">                    ByteBufferUtil.skipShortLength(in);</span>
                else
                {
<span class="nc" id="L188">                    ByteBuffer indexKey = ByteBufferUtil.readWithShortLength(in);</span>
<span class="nc" id="L189">                    DecoratedKey decorated = decorateKey(indexKey);</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">                    if (searchOp.apply(decorated.compareTo(searchKey)) != 0)</span>
<span class="nc" id="L191">                        return null;</span>
                }
<span class="nc" id="L193">                return TrieIndexEntry.deserialize(in, in.getFilePointer(), descriptor.version);</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">            }</span>
        }
        else
        {
<span class="nc" id="L198">            pos = ~pos;</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">            if (!assumeNoMatch)</span>
            {
<span class="nc" id="L201">                try (FileDataInput in = dfile.createReader(pos))</span>
                {
<span class="nc" id="L203">                    ByteBuffer indexKey = ByteBufferUtil.readWithShortLength(in);</span>
<span class="nc" id="L204">                    DecoratedKey decorated = decorateKey(indexKey);</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">                    if (searchOp.apply(decorated.compareTo(searchKey)) != 0)</span>
<span class="nc" id="L206">                        return null;</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">                }</span>
            }
<span class="nc" id="L209">            return new TrieIndexEntry(pos);</span>
        }
    }

    @Override
    public DecoratedKey keyAtPositionFromSecondaryIndex(long keyPositionFromSecondaryIndex) throws IOException
    {
<span class="nc" id="L216">        try (RandomAccessReader reader = openDataReader())</span>
        {
<span class="nc" id="L218">            reader.seek(keyPositionFromSecondaryIndex);</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">            if (reader.isEOF())</span>
<span class="nc" id="L220">                return null;</span>
<span class="nc" id="L221">            return decorateKey(ByteBufferUtil.readWithShortLength(reader));</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">        }</span>
    }

    TrieIndexEntry getExactPosition(DecoratedKey dk,
                                    SSTableReadsListener listener,
                                    boolean updateStats)
    {
<span class="nc bnc" id="L229" title="All 8 branches missed.">        if ((filterFirst() &amp;&amp; getFirst().compareTo(dk) &gt; 0) || (filterLast() &amp;&amp; getLast().compareTo(dk) &lt; 0))</span>
        {
<span class="nc" id="L231">            notifySkipped(SkippingReason.MIN_MAX_KEYS, listener, EQ, updateStats);</span>
<span class="nc" id="L232">            return null;</span>
        }

<span class="nc bnc" id="L235" title="All 2 branches missed.">        if (!isPresentInFilter(dk))</span>
        {
<span class="nc" id="L237">            notifySkipped(SkippingReason.BLOOM_FILTER, listener, EQ, updateStats);</span>
<span class="nc" id="L238">            return null;</span>
        }

<span class="nc" id="L241">        try (PartitionIndex.Reader reader = partitionIndex.openReader())</span>
        {
<span class="nc" id="L243">            long indexPos = reader.exactCandidate(dk);</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">            if (indexPos == PartitionIndex.NOT_FOUND)</span>
            {
<span class="nc" id="L246">                notifySkipped(SkippingReason.PARTITION_INDEX_LOOKUP, listener, EQ, updateStats);</span>
<span class="nc" id="L247">                return null;</span>
            }

            FileHandle fh;
            long seekPosition;
<span class="nc bnc" id="L252" title="All 2 branches missed.">            if (indexPos &gt;= 0)</span>
            {
<span class="nc" id="L254">                fh = rowIndexFile;</span>
<span class="nc" id="L255">                seekPosition = indexPos;</span>
            }
            else
            {
<span class="nc" id="L259">                fh = dfile;</span>
<span class="nc" id="L260">                seekPosition = ~indexPos;</span>
            }

<span class="nc" id="L263">            try (FileDataInput in = fh.createReader(seekPosition))</span>
            {
<span class="nc bnc" id="L265" title="All 2 branches missed.">                if (ByteBufferUtil.equalsWithShortLength(in, dk.getKey()))</span>
                {
<span class="nc bnc" id="L267" title="All 2 branches missed.">                    TrieIndexEntry rie = indexPos &gt;= 0 ? TrieIndexEntry.deserialize(in, in.getFilePointer(), descriptor.version)</span>
<span class="nc" id="L268">                                                       : new TrieIndexEntry(~indexPos);</span>
<span class="nc" id="L269">                    notifySelected(SelectionReason.INDEX_ENTRY_FOUND, listener, EQ, updateStats, rie);</span>
<span class="nc" id="L270">                    return rie;</span>
                }
                else
                {
<span class="nc" id="L274">                    notifySkipped(SkippingReason.INDEX_ENTRY_NOT_FOUND, listener, EQ, updateStats);</span>
<span class="nc" id="L275">                    return null;</span>
                }
<span class="nc bnc" id="L277" title="All 2 branches missed.">            }</span>
<span class="nc bnc" id="L278" title="All 4 branches missed.">        }</span>
<span class="nc" id="L279">        catch (IOException | IllegalArgumentException | ArrayIndexOutOfBoundsException | AssertionError e)</span>
        {
<span class="nc" id="L281">            markSuspect();</span>
<span class="nc" id="L282">            throw new CorruptSSTableException(e, rowIndexFile.path());</span>
        }
    }

    /**
     * Create a PartitionIterator listing all partitions within the given bounds.
     * This method relies on its caller to prepare the bounds correctly.
     *
     * @param bounds A range of keys. Must not be a wraparound range, and will not be checked against
     *               the sstable's bounds (i.e. this will return data before a moved start or after an early-open limit)
     */
    PartitionIterator coveredKeysIterator(AbstractBounds&lt;PartitionPosition&gt; bounds) throws IOException
    {
<span class="nc" id="L295">        return PartitionIterator.create(partitionIndex,</span>
<span class="nc" id="L296">                                        metadata().partitioner,</span>
                                        rowIndexFile,
                                        dfile,
<span class="nc bnc" id="L299" title="All 2 branches missed.">                                        bounds.left, bounds.inclusiveLeft() ? -1 : 0,</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">                                        bounds.right, bounds.inclusiveRight() ? 0 : -1,</span>
                                        descriptor.version);
    }

    public ScrubPartitionIterator scrubPartitionsIterator() throws IOException
    {
<span class="nc" id="L306">        return new ScrubIterator(partitionIndex, rowIndexFile, descriptor.version);</span>
    }

    @Override
    public PartitionIterator keyReader() throws IOException
    {
<span class="nc" id="L312">        return PartitionIterator.create(partitionIndex, metadata().partitioner, rowIndexFile, dfile, descriptor.version);</span>
    }

    @Override
    public Iterable&lt;DecoratedKey&gt; getKeySamples(final Range&lt;Token&gt; range)
    {
        // BTI does not support key sampling as it would involve walking the index or data file.
        // Validator has an alternate solution for empty key sample lists.
<span class="nc" id="L320">        return Collections.emptyList();</span>
    }

    @Override
    public long estimatedKeysForRanges(Collection&lt;Range&lt;Token&gt;&gt; ranges)
    {
        // Estimate the number of partitions by calculating the bytes of the sstable that are covered by the specified
        // ranges and using the mean partition size to obtain a number of partitions from that.
<span class="nc" id="L328">        long selectedDataSize = 0;</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">        for (Range&lt;Token&gt; range : Range.normalize(ranges))</span>
        {
<span class="nc" id="L331">            PartitionPosition left = range.left.minKeyBound();</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">            if (left.compareTo(getFirst()) &lt;= 0)</span>
<span class="nc" id="L333">                left = null;</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">            else if (left.compareTo(getLast()) &gt; 0)</span>
<span class="nc" id="L335">                continue;   // no intersection</span>

<span class="nc" id="L337">            PartitionPosition right = range.right.minKeyBound();</span>
<span class="nc bnc" id="L338" title="All 4 branches missed.">            if (range.right.isMinimum() || right.compareTo(getLast()) &gt;= 0)</span>
<span class="nc" id="L339">                right = null;</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">            else if (right.compareTo(getFirst()) &lt; 0)</span>
<span class="nc" id="L341">                continue;   // no intersection</span>

<span class="nc bnc" id="L343" title="All 4 branches missed.">            if (left == null &amp;&amp; right == null)</span>
<span class="nc" id="L344">                return partitionIndex.size();   // sstable is fully covered, return full partition count to avoid rounding errors</span>

<span class="nc bnc" id="L346" title="All 4 branches missed.">            if (left == null &amp;&amp; filterFirst())</span>
<span class="nc" id="L347">                left = getFirst();</span>
<span class="nc bnc" id="L348" title="All 4 branches missed.">            if (right == null &amp;&amp; filterLast())</span>
<span class="nc" id="L349">                right = getLast();</span>

<span class="nc bnc" id="L351" title="All 2 branches missed.">            long startPos = left != null ? getPosition(left, GE) : 0;</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">            long endPos = right != null ? getPosition(right, GE) : uncompressedLength();</span>
<span class="nc" id="L353">            selectedDataSize += endPos - startPos;</span>
<span class="nc" id="L354">        }</span>
<span class="nc" id="L355">        return Math.round(selectedDataSize / sstableMetadata.estimatedPartitionSize.rawMean());</span>
    }


    @Override
    public UnfilteredRowIterator rowIterator(DecoratedKey key,
                                             Slices slices,
                                             ColumnFilter selectedColumns,
                                             boolean reversed,
                                             SSTableReadsListener listener)
    {
<span class="nc" id="L366">        return rowIterator(null, key, getExactPosition(key, listener, true), slices, selectedColumns, reversed);</span>
    }

    public UnfilteredRowIterator rowIterator(FileDataInput dataFileInput,
                                             DecoratedKey key,
                                             TrieIndexEntry indexEntry,
                                             Slices slices,
                                             ColumnFilter selectedColumns,
                                             boolean reversed)
    {
<span class="nc bnc" id="L376" title="All 2 branches missed.">        if (indexEntry == null)</span>
<span class="nc" id="L377">            return UnfilteredRowIterators.noRowsIterator(metadata(), key, Rows.EMPTY_STATIC_ROW, DeletionTime.LIVE, reversed);</span>

<span class="nc bnc" id="L379" title="All 2 branches missed.">        if (reversed)</span>
<span class="nc" id="L380">            return new SSTableReversedIterator(this, dataFileInput, key, indexEntry, slices, selectedColumns, rowIndexFile);</span>
        else
<span class="nc" id="L382">            return new SSTableIterator(this, dataFileInput, key, indexEntry, slices, selectedColumns, rowIndexFile);</span>
    }

    @Override
    public ISSTableScanner getScanner()
    {
<span class="nc" id="L388">        return BtiTableScanner.getScanner(this);</span>
    }

    @Override
    public ISSTableScanner getScanner(Collection&lt;Range&lt;Token&gt;&gt; ranges)
    {
<span class="nc bnc" id="L394" title="All 2 branches missed.">        if (ranges != null)</span>
<span class="nc" id="L395">            return BtiTableScanner.getScanner(this, ranges);</span>
        else
<span class="nc" id="L397">            return getScanner();</span>
    }

    @Override
    public ISSTableScanner getScanner(Iterator&lt;AbstractBounds&lt;PartitionPosition&gt;&gt; rangeIterator)
    {
<span class="nc" id="L403">        return BtiTableScanner.getScanner(this, rangeIterator);</span>
    }

    @VisibleForTesting
    @Override
    public BtiTableReader cloneAndReplace(IFilter filter)
    {
<span class="nc" id="L410">        return unbuildTo(new Builder(descriptor).setFilter(filter), true).build(owner().orElse(null), true, true);</span>
    }

    @Override
    public BtiTableReader cloneWithRestoredStart(DecoratedKey restoredStart)
    {
<span class="nc" id="L416">        return runWithLock(ignored -&gt; cloneAndReplace(restoredStart, OpenReason.NORMAL));</span>
    }

    @Override
    public BtiTableReader cloneWithNewStart(DecoratedKey newStart)
    {
<span class="nc" id="L422">        return runWithLock(d -&gt; {</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">            assert openReason != OpenReason.EARLY : &quot;Cannot open early an early-open SSTable&quot;;</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">            if (newStart.compareTo(getFirst()) &gt; 0)</span>
            {
<span class="nc" id="L426">                final long dataStart = getPosition(newStart, Operator.EQ);</span>
<span class="nc" id="L427">                runOnClose(() -&gt; dfile.dropPageCache(dataStart));</span>
            }

<span class="nc" id="L430">            return cloneAndReplace(newStart, OpenReason.MOVED_START);</span>
        });
    }

    /**
     * Clone this reader with the provided start and open reason, and set the clone as replacement.
     *
     * @param newFirst the first key for the replacement (which can be different from the original due to the pre-emptive
     *                 opening of compaction results).
     * @param reason   the {@code OpenReason} for the replacement.
     * @return the cloned reader. That reader is set as a replacement by the method.
     */
    private BtiTableReader cloneAndReplace(DecoratedKey newFirst, OpenReason reason)
    {
<span class="nc" id="L444">        return unbuildTo(new Builder(descriptor), true)</span>
<span class="nc" id="L445">               .setFirst(newFirst)</span>
<span class="nc" id="L446">               .setOpenReason(reason)</span>
<span class="nc" id="L447">               .build(owner().orElse(null), true, true);</span>
    }

    @Override
    public DecoratedKey firstKeyBeyond(PartitionPosition token)
    {
        try
        {
<span class="nc" id="L455">            TrieIndexEntry pos = getRowIndexEntry(token, Operator.GT, true, SSTableReadsListener.NOOP_LISTENER);</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">            if (pos == null)</span>
<span class="nc" id="L457">                return null;</span>

<span class="nc" id="L459">            try (FileDataInput in = dfile.createReader(pos.position))</span>
            {
<span class="nc" id="L461">                ByteBuffer indexKey = ByteBufferUtil.readWithShortLength(in);</span>
<span class="nc" id="L462">                return decorateKey(indexKey);</span>
            }
        }
<span class="nc" id="L465">        catch (IOException e)</span>
        {
<span class="nc" id="L467">            markSuspect();</span>
<span class="nc" id="L468">            throw new CorruptSSTableException(e, dfile.path());</span>
        }
    }

    @Override
    public void releaseInMemoryComponents()
    {
<span class="nc" id="L475">        closeInternalComponent(partitionIndex);</span>
<span class="nc" id="L476">    }</span>

    @Override
    public boolean isEstimationInformative()
    {
<span class="nc" id="L481">        return true;</span>
    }

    @Override
    public UnfilteredPartitionIterator partitionIterator(ColumnFilter columnFilter, DataRange dataRange, SSTableReadsListener listener)
    {
<span class="nc" id="L487">        return BtiTableScanner.getScanner(this, columnFilter, dataRange, listener);</span>
    }

    @Override
    public IVerifier getVerifier(ColumnFamilyStore cfs, OutputHandler outputHandler, boolean isOffline, IVerifier.Options options)
    {
<span class="nc" id="L493">        Preconditions.checkArgument(cfs.metadata().equals(metadata()));</span>
<span class="nc" id="L494">        return new BtiTableVerifier(cfs, this, outputHandler, isOffline, options);</span>
    }

    public static class Builder extends SSTableReaderWithFilter.Builder&lt;BtiTableReader, Builder&gt;
    {
        private PartitionIndex partitionIndex;
        private FileHandle rowIndexFile;

        public Builder(Descriptor descriptor)
        {
<span class="nc" id="L504">            super(descriptor);</span>
<span class="nc" id="L505">        }</span>

        public Builder setRowIndexFile(FileHandle rowIndexFile)
        {
<span class="nc" id="L509">            this.rowIndexFile = rowIndexFile;</span>
<span class="nc" id="L510">            return this;</span>
        }

        public Builder setPartitionIndex(PartitionIndex partitionIndex)
        {
<span class="nc" id="L515">            this.partitionIndex = partitionIndex;</span>
<span class="nc" id="L516">            return this;</span>
        }

        public PartitionIndex getPartitionIndex()
        {
<span class="nc" id="L521">            return partitionIndex;</span>
        }

        public FileHandle getRowIndexFile()
        {
<span class="nc" id="L526">            return rowIndexFile;</span>
        }

        @Override
        protected BtiTableReader buildInternal(Owner owner)
        {
<span class="nc" id="L532">            return new BtiTableReader(this, owner);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>