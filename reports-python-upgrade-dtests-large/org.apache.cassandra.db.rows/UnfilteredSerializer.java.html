<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UnfilteredSerializer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.rows</a> &gt; <span class="el_source">UnfilteredSerializer.java</span></div><h1>UnfilteredSerializer.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.rows;

import java.io.IOException;

import net.nicoulaj.compilecommand.annotations.Inline;
import org.apache.cassandra.db.*;
import org.apache.cassandra.db.marshal.ByteArrayAccessor;
import org.apache.cassandra.db.rows.Row.Deletion;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputBuffer;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.io.util.FileDataInput;
import org.apache.cassandra.io.util.TrackedDataInputPlus;
import org.apache.cassandra.net.MessagingService;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.utils.SearchIterator;
import org.apache.cassandra.utils.WrappedException;

/**
 * Serialize/deserialize a single Unfiltered (both on-wire and on-disk).
 * &lt;p&gt;
 *
 * The encoded format for an unfiltered is {@code &lt;flags&gt;(&lt;row&gt;|&lt;marker&gt;)} where:
 * &lt;ul&gt;
 *   &lt;li&gt;
 *     {@code &lt;flags&gt;} is a byte (or two) whose bits are flags used by the rest
 *     of the serialization. Each flag is defined/explained below as the
 *     &quot;Unfiltered flags&quot; constants. One of those flags is an extension flag,
 *     and if present, indicates the presence of a 2ndbyte that contains more
 *     flags. If the extension is not set, defaults are assumed for the flags
 *     of that 2nd byte.
 *   &lt;/li&gt;
 *   &lt;li&gt;
 *     {@code &lt;row&gt;} is
 *        {@code &lt;clustering&gt;&lt;sizes&gt;[&lt;pkliveness&gt;][&lt;deletion&gt;][&lt;columns&gt;]&lt;columns_data&gt;}
 *     where:
 *     &lt;ul&gt;
 *       &lt;li&gt;{@code &lt;clustering&gt;} is the row clustering as serialized by
 *           {@link org.apache.cassandra.db.Clustering.Serializer} (note that static row are an
 *           exception and don't have this). &lt;/li&gt;
 *       &lt;li&gt;{@code &lt;sizes&gt;} are the sizes of the whole unfiltered on disk and
 *           of the previous unfiltered. This is only present for sstables and
 *           is used to efficiently skip rows (both forward and backward).&lt;/li&gt;
 *       &lt;li&gt;{@code &lt;pkliveness&gt;} is the row primary key liveness infos, and it
 *           contains the timestamp, ttl and local deletion time of that info,
 *           though some/all of those can be absent based on the flags. &lt;/li&gt;
 *       &lt;li&gt;{@code deletion} is the row deletion. It's presence is determined
 *           by the flags and if present, it conists of both the deletion
 *           timestamp and local deletion time.&lt;/li&gt;
 *       &lt;li&gt;{@code &lt;columns&gt;} are the columns present in the row  encoded by
 *           {@link org.apache.cassandra.db.Columns.Serializer#serializeSubset}. It is absent if the row
 *           contains all the columns of the {@code SerializationHeader} (which
 *           is then indicated by a flag). &lt;/li&gt;
 *       &lt;li&gt;{@code &lt;columns_data&gt;} is the data for each of the column present
 *           in the row. The encoding of each data depends on whether the data
 *           is for a simple or complex column:
 *           &lt;ul&gt;
 *              &lt;li&gt;Simple columns are simply encoded as one {@code &lt;cell&gt;}&lt;/li&gt;
 *              &lt;li&gt;Complex columns are encoded as {@code [&lt;delTime&gt;]&lt;n&gt;&lt;cell1&gt;...&lt;celln&gt;}
 *                  where {@code &lt;delTime&gt;} is the deletion for this complex
 *                  column (if flags indicates its presence), {@code &lt;n&gt;} is the
 *                  vint encoded value of n, i.e. {@code &lt;celln&gt;}'s 1-based
 *                  inde and {@code &lt;celli&gt;} are the {@code &lt;cell&gt;} for this
 *                  complex column&lt;/li&gt;
 *           &lt;/ul&gt;
 *       &lt;/li&gt;
 *     &lt;/ul&gt;
 *   &lt;/li&gt;
 *   &lt;li&gt;
 *     {@code &lt;marker&gt;} is {@code &lt;bound&gt;&lt;deletion&gt;} where {@code &lt;bound&gt;} is
 *     the marker bound as serialized by {@link org.apache.cassandra.db.ClusteringBoundOrBoundary.Serializer}
 *     and {@code &lt;deletion&gt;} is the marker deletion time.
 *   &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * The serialization of a {@code &lt;cell&gt;} is defined by {@link Cell.Serializer}.
 */
<span class="fc" id="L95">public class UnfilteredSerializer</span>
{
<span class="fc" id="L97">    public static final UnfilteredSerializer serializer = new UnfilteredSerializer();</span>

    /*
     * Unfiltered flags constants.
     */
    private final static int END_OF_PARTITION     = 0x01; // Signal the end of the partition. Nothing follows a &lt;flags&gt; field with that flag.
    private final static int IS_MARKER            = 0x02; // Whether the encoded unfiltered is a marker or a row. All following markers applies only to rows.
    private final static int HAS_TIMESTAMP        = 0x04; // Whether the encoded row has a timestamp (i.e. if row.partitionKeyLivenessInfo().hasTimestamp() == true).
    private final static int HAS_TTL              = 0x08; // Whether the encoded row has some expiration info (i.e. if row.partitionKeyLivenessInfo().hasTTL() == true).
    private final static int HAS_DELETION         = 0x10; // Whether the encoded row has some deletion info.
    private final static int HAS_ALL_COLUMNS      = 0x20; // Whether the encoded row has all of the columns from the header present.
    private final static int HAS_COMPLEX_DELETION = 0x40; // Whether the encoded row has some complex deletion for at least one of its columns.
    private final static int EXTENSION_FLAG       = 0x80; // If present, another byte is read containing the &quot;extended flags&quot; above.

    /*
     * Extended flags
     */
    private final static int IS_STATIC               = 0x01; // Whether the encoded row is a static. If there is no extended flag, the row is assumed not static.
    /**
     * A shadowable tombstone cannot replace a previous row deletion otherwise it could resurrect a
     * previously deleted cell not updated by a subsequent update, SEE CASSANDRA-11500
     */
    @Deprecated
    private final static int HAS_SHADOWABLE_DELETION = 0x02; // Whether the row deletion is shadowable. If there is no extended flag (or no row deletion), the deletion is assumed not shadowable.

    public void serialize(Unfiltered unfiltered, SerializationHelper helper, DataOutputPlus out, int version)
    throws IOException
    {
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        assert !helper.header.isForSSTable();</span>
<span class="fc" id="L126">        serialize(unfiltered, helper, out, 0, version);</span>
<span class="fc" id="L127">    }</span>

    public void serialize(Unfiltered unfiltered, SerializationHelper helper, DataOutputPlus out, long previousUnfilteredSize, int version)
    throws IOException
    {
<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (unfiltered.kind() == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)</span>
        {
<span class="fc" id="L134">            serialize((RangeTombstoneMarker) unfiltered, helper, out, previousUnfilteredSize, version);</span>
        }
        else
        {
<span class="fc" id="L138">            serialize((Row) unfiltered, helper, out, previousUnfilteredSize, version);</span>
        }
<span class="fc" id="L140">    }</span>

    public void serializeStaticRow(Row row, SerializationHelper helper, DataOutputPlus out, int version)
    throws IOException
    {
<span class="nc bnc" id="L145" title="All 2 branches missed.">        assert row.isStatic();</span>
<span class="nc" id="L146">        serialize(row, helper, out, 0, version);</span>
<span class="nc" id="L147">    }</span>

    private void serialize(Row row, SerializationHelper helper, DataOutputPlus out, long previousUnfilteredSize, int version)
    throws IOException
    {
<span class="fc" id="L152">        int flags = 0;</span>
<span class="fc" id="L153">        int extendedFlags = 0;</span>

<span class="fc" id="L155">        boolean isStatic = row.isStatic();</span>
<span class="fc" id="L156">        SerializationHeader header = helper.header;</span>
<span class="fc" id="L157">        LivenessInfo pkLiveness = row.primaryKeyLivenessInfo();</span>
<span class="fc" id="L158">        Row.Deletion deletion = row.deletion();</span>
<span class="fc" id="L159">        boolean hasComplexDeletion = row.hasComplexDeletion();</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">        boolean hasAllColumns = row.columnCount() == header.columns(isStatic).size();</span>
<span class="fc" id="L161">        boolean hasExtendedFlags = hasExtendedFlags(row);</span>

<span class="pc bpc" id="L163" title="1 of 2 branches missed.">        if (isStatic)</span>
<span class="nc" id="L164">            extendedFlags |= IS_STATIC;</span>

<span class="fc bfc" id="L166" title="All 2 branches covered.">        if (!pkLiveness.isEmpty())</span>
<span class="fc" id="L167">            flags |= HAS_TIMESTAMP;</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">        if (pkLiveness.isExpiring())</span>
<span class="fc" id="L169">            flags |= HAS_TTL;</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">        if (!deletion.isLive())</span>
        {
<span class="fc" id="L172">            flags |= HAS_DELETION;</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">            if (deletion.isShadowable())</span>
<span class="nc" id="L174">                extendedFlags |= HAS_SHADOWABLE_DELETION;</span>
        }
<span class="fc bfc" id="L176" title="All 2 branches covered.">        if (hasComplexDeletion)</span>
<span class="fc" id="L177">            flags |= HAS_COMPLEX_DELETION;</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">        if (hasAllColumns)</span>
<span class="fc" id="L179">            flags |= HAS_ALL_COLUMNS;</span>

<span class="pc bpc" id="L181" title="1 of 2 branches missed.">        if (hasExtendedFlags)</span>
<span class="nc" id="L182">            flags |= EXTENSION_FLAG;</span>

<span class="fc" id="L184">        out.writeByte((byte)flags);</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">        if (hasExtendedFlags)</span>
<span class="nc" id="L186">            out.writeByte((byte)extendedFlags);</span>

<span class="pc bpc" id="L188" title="1 of 2 branches missed.">        if (!isStatic)</span>
<span class="fc" id="L189">            Clustering.serializer.serialize(row.clustering(), out, version, header.clusteringTypes());</span>

<span class="fc bfc" id="L191" title="All 2 branches covered.">        if (header.isForSSTable())</span>
        {
<span class="fc" id="L193">            try (DataOutputBuffer dob = DataOutputBuffer.scratchBuffer.get())</span>
            {
<span class="fc" id="L195">                serializeRowBody(row, flags, helper, dob);</span>

<span class="fc" id="L197">                out.writeUnsignedVInt(dob.position() + TypeSizes.sizeofUnsignedVInt(previousUnfilteredSize));</span>
                // We write the size of the previous unfiltered to make reverse queries more efficient (and simpler).
                // This is currently not used however and using it is tbd.
<span class="fc" id="L200">                out.writeUnsignedVInt(previousUnfilteredSize);</span>
<span class="fc" id="L201">                out.write(dob.unsafeGetBufferAndFlip());</span>
            }
        }
        else
        {
<span class="fc" id="L206">            serializeRowBody(row, flags, helper, out);</span>
        }
<span class="fc" id="L208">    }</span>

    @Inline
    private void serializeRowBody(Row row, int flags, SerializationHelper helper, DataOutputPlus out)
    throws IOException
    {
<span class="fc" id="L214">        boolean isStatic = row.isStatic();</span>

<span class="fc" id="L216">        SerializationHeader header = helper.header;</span>
<span class="fc" id="L217">        Columns headerColumns = header.columns(isStatic);</span>
<span class="fc" id="L218">        LivenessInfo pkLiveness = row.primaryKeyLivenessInfo();</span>
<span class="fc" id="L219">        Row.Deletion deletion = row.deletion();</span>

<span class="fc bfc" id="L221" title="All 2 branches covered.">        if ((flags &amp; HAS_TIMESTAMP) != 0)</span>
<span class="fc" id="L222">            header.writeTimestamp(pkLiveness.timestamp(), out);</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">        if ((flags &amp; HAS_TTL) != 0)</span>
        {
<span class="fc" id="L225">            header.writeTTL(pkLiveness.ttl(), out);</span>
<span class="fc" id="L226">            header.writeLocalDeletionTime(pkLiveness.localExpirationTime(), out);</span>
        }
<span class="fc bfc" id="L228" title="All 2 branches covered.">        if ((flags &amp; HAS_DELETION) != 0)</span>
<span class="fc" id="L229">            header.writeDeletionTime(deletion.time(), out);</span>

<span class="fc bfc" id="L231" title="All 2 branches covered.">        if ((flags &amp; HAS_ALL_COLUMNS) == 0)</span>
<span class="fc" id="L232">            Columns.serializer.serializeSubset(row.columns(), headerColumns, out);</span>

<span class="fc" id="L234">        SearchIterator&lt;ColumnMetadata, ColumnMetadata&gt; si = helper.iterator(isStatic);</span>

        try
        {
<span class="fc" id="L238">            row.apply(cd -&gt; {</span>
                // We can obtain the column for data directly from data.column(). However, if the cell/complex data
                // originates from a sstable, the column we'll get will have the type used when the sstable was serialized,
                // and if that type have been recently altered, that may not be the type we want to serialize the column
                // with. So we use the ColumnMetadata from the &quot;header&quot; which is &quot;current&quot;. Also see #11810 for what
                // happens if we don't do that.
<span class="fc" id="L244">                ColumnMetadata column = si.next(cd.column());</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">                assert column != null : cd.column.toString();</span>

                try
                {
<span class="fc bfc" id="L249" title="All 2 branches covered.">                    if (cd.column.isSimple())</span>
<span class="fc" id="L250">                        Cell.serializer.serialize((Cell&lt;?&gt;) cd, column, out, pkLiveness, header);</span>
                    else
<span class="fc bfc" id="L252" title="All 2 branches covered.">                        writeComplexColumn((ComplexColumnData) cd, column, (flags &amp; HAS_COMPLEX_DELETION) != 0, pkLiveness, header, out);</span>
                }
<span class="nc" id="L254">                catch (IOException e)</span>
                {
<span class="nc" id="L256">                    throw new WrappedException(e);</span>
<span class="fc" id="L257">                }</span>
<span class="fc" id="L258">            });</span>
        }
<span class="nc" id="L260">        catch (WrappedException e)</span>
        {
<span class="nc bnc" id="L262" title="All 2 branches missed.">            if (e.getCause() instanceof IOException)</span>
<span class="nc" id="L263">                throw (IOException) e.getCause();</span>

<span class="nc" id="L265">            throw e;</span>
<span class="fc" id="L266">        }</span>
<span class="fc" id="L267">    }</span>

    private void writeComplexColumn(ComplexColumnData data, ColumnMetadata column, boolean hasComplexDeletion, LivenessInfo rowLiveness, SerializationHeader header, DataOutputPlus out)
    throws IOException
    {
<span class="fc bfc" id="L272" title="All 2 branches covered.">        if (hasComplexDeletion)</span>
<span class="fc" id="L273">            header.writeDeletionTime(data.complexDeletion(), out);</span>

<span class="fc" id="L275">        out.writeUnsignedVInt32(data.cellsCount());</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">        for (Cell&lt;?&gt; cell : data)</span>
<span class="fc" id="L277">            Cell.serializer.serialize(cell, column, out, rowLiveness, header);</span>
<span class="fc" id="L278">    }</span>

    private void serialize(RangeTombstoneMarker marker, SerializationHelper helper, DataOutputPlus out, long previousUnfilteredSize, int version)
    throws IOException
    {
<span class="fc" id="L283">        SerializationHeader header = helper.header;</span>
<span class="fc" id="L284">        out.writeByte((byte)IS_MARKER);</span>
<span class="fc" id="L285">        ClusteringBoundOrBoundary.serializer.serialize(marker.clustering(), out, version, header.clusteringTypes());</span>

<span class="pc bpc" id="L287" title="1 of 2 branches missed.">        if (header.isForSSTable())</span>
        {
<span class="nc" id="L289">            out.writeUnsignedVInt(serializedMarkerBodySize(marker, header, previousUnfilteredSize, version));</span>
<span class="nc" id="L290">            out.writeUnsignedVInt(previousUnfilteredSize);</span>
        }

<span class="pc bpc" id="L293" title="1 of 2 branches missed.">        if (marker.isBoundary())</span>
        {
<span class="nc" id="L295">            RangeTombstoneBoundaryMarker bm = (RangeTombstoneBoundaryMarker)marker;</span>
<span class="nc" id="L296">            header.writeDeletionTime(bm.endDeletionTime(), out);</span>
<span class="nc" id="L297">            header.writeDeletionTime(bm.startDeletionTime(), out);</span>
<span class="nc" id="L298">        }</span>
        else
        {
<span class="fc" id="L301">            header.writeDeletionTime(((RangeTombstoneBoundMarker)marker).deletionTime(), out);</span>
        }
<span class="fc" id="L303">    }</span>

    public long serializedSize(Unfiltered unfiltered, SerializationHelper helper, int version)
    {
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">        assert !helper.header.isForSSTable();</span>
<span class="fc" id="L308">        return serializedSize(unfiltered, helper, 0, version);</span>
    }

    public long serializedSize(Unfiltered unfiltered, SerializationHelper helper, long previousUnfilteredSize,int version)
    {
<span class="fc bfc" id="L313" title="All 2 branches covered.">        return unfiltered.kind() == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER</span>
<span class="fc" id="L314">             ? serializedSize((RangeTombstoneMarker) unfiltered, helper, previousUnfilteredSize, version)</span>
<span class="fc" id="L315">             : serializedSize((Row) unfiltered, helper, previousUnfilteredSize, version);</span>
    }

    private long serializedSize(Row row, SerializationHelper helper, long previousUnfilteredSize, int version)
    {
<span class="fc" id="L320">        long size = 1; // flags</span>

<span class="pc bpc" id="L322" title="1 of 2 branches missed.">        if (hasExtendedFlags(row))</span>
<span class="nc" id="L323">            size += 1; // extended flags</span>

<span class="pc bpc" id="L325" title="1 of 2 branches missed.">        if (!row.isStatic())</span>
<span class="fc" id="L326">            size += Clustering.serializer.serializedSize(row.clustering(), version, helper.header.clusteringTypes());</span>

<span class="fc" id="L328">        return size + serializedRowBodySize(row, helper, previousUnfilteredSize, version);</span>
    }

    private long serializedRowBodySize(Row row, SerializationHelper helper, long previousUnfilteredSize, int version)
    {
<span class="fc" id="L333">        long size = 0;</span>

<span class="fc" id="L335">        SerializationHeader header = helper.header;</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">        if (header.isForSSTable())</span>
<span class="nc" id="L337">            size += TypeSizes.sizeofUnsignedVInt(previousUnfilteredSize);</span>

<span class="fc" id="L339">        boolean isStatic = row.isStatic();</span>
<span class="fc" id="L340">        LivenessInfo pkLiveness = row.primaryKeyLivenessInfo();</span>
<span class="fc" id="L341">        Row.Deletion deletion = row.deletion();</span>
<span class="fc" id="L342">        boolean hasComplexDeletion = row.hasComplexDeletion();</span>
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">        boolean hasAllColumns = row.columnCount() == header.columns(isStatic).size();</span>

<span class="fc bfc" id="L345" title="All 2 branches covered.">        if (!pkLiveness.isEmpty())</span>
<span class="fc" id="L346">            size += header.timestampSerializedSize(pkLiveness.timestamp());</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">        if (pkLiveness.isExpiring())</span>
        {
<span class="fc" id="L349">            size += header.ttlSerializedSize(pkLiveness.ttl());</span>
<span class="fc" id="L350">            size += header.localDeletionTimeSerializedSize(pkLiveness.localExpirationTime());</span>
        }
<span class="fc bfc" id="L352" title="All 2 branches covered.">        if (!deletion.isLive())</span>
<span class="fc" id="L353">            size += header.deletionTimeSerializedSize(deletion.time());</span>

<span class="pc bpc" id="L355" title="1 of 2 branches missed.">        if (!hasAllColumns)</span>
<span class="nc" id="L356">            size += Columns.serializer.serializedSubsetSize(row.columns(), header.columns(isStatic));</span>

<span class="fc" id="L358">        SearchIterator&lt;ColumnMetadata, ColumnMetadata&gt; si = helper.iterator(isStatic);</span>
<span class="fc" id="L359">        return row.accumulate((data, v) -&gt; {</span>
<span class="fc" id="L360">            ColumnMetadata column = si.next(data.column());</span>
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">            assert column != null;</span>

<span class="fc bfc" id="L363" title="All 2 branches covered.">            if (data.column.isSimple())</span>
<span class="fc" id="L364">                return v + Cell.serializer.serializedSize((Cell&lt;?&gt;) data, column, pkLiveness, header);</span>
            else
<span class="fc" id="L366">                return v + sizeOfComplexColumn((ComplexColumnData) data, column, hasComplexDeletion, pkLiveness, header);</span>
        }, size);
    }

    private long sizeOfComplexColumn(ComplexColumnData data, ColumnMetadata column, boolean hasComplexDeletion, LivenessInfo rowLiveness, SerializationHeader header)
    {
<span class="fc" id="L372">        long size = 0;</span>

<span class="fc bfc" id="L374" title="All 2 branches covered.">        if (hasComplexDeletion)</span>
<span class="fc" id="L375">            size += header.deletionTimeSerializedSize(data.complexDeletion());</span>

<span class="fc" id="L377">        size += TypeSizes.sizeofUnsignedVInt(data.cellsCount());</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">        for (Cell&lt;?&gt; cell : data)</span>
<span class="fc" id="L379">            size += Cell.serializer.serializedSize(cell, column, rowLiveness, header);</span>

<span class="fc" id="L381">        return size;</span>
    }

    private long serializedSize(RangeTombstoneMarker marker, SerializationHelper helper, long previousUnfilteredSize, int version)
    {
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">        assert !helper.header.isForSSTable();</span>
<span class="fc" id="L387">        return 1 // flags</span>
<span class="fc" id="L388">             + ClusteringBoundOrBoundary.serializer.serializedSize(marker.clustering(), version, helper.header.clusteringTypes())</span>
<span class="fc" id="L389">             + serializedMarkerBodySize(marker, helper.header, previousUnfilteredSize, version);</span>
    }

    private long serializedMarkerBodySize(RangeTombstoneMarker marker, SerializationHeader header, long previousUnfilteredSize, int version)
    {
<span class="fc" id="L394">        long size = 0;</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">        if (header.isForSSTable())</span>
<span class="nc" id="L396">            size += TypeSizes.sizeofUnsignedVInt(previousUnfilteredSize);</span>

<span class="pc bpc" id="L398" title="1 of 2 branches missed.">        if (marker.isBoundary())</span>
        {
<span class="nc" id="L400">            RangeTombstoneBoundaryMarker bm = (RangeTombstoneBoundaryMarker)marker;</span>
<span class="nc" id="L401">            size += header.deletionTimeSerializedSize(bm.endDeletionTime());</span>
<span class="nc" id="L402">            size += header.deletionTimeSerializedSize(bm.startDeletionTime());</span>
<span class="nc" id="L403">        }</span>
        else
        {
<span class="fc" id="L406">           size += header.deletionTimeSerializedSize(((RangeTombstoneBoundMarker)marker).deletionTime());</span>
        }
<span class="fc" id="L408">        return size;</span>
    }

    public void writeEndOfPartition(DataOutputPlus out) throws IOException
    {
<span class="fc" id="L413">        out.writeByte((byte)1);</span>
<span class="fc" id="L414">    }</span>

    public long serializedSizeEndOfPartition()
    {
<span class="fc" id="L418">        return 1;</span>
    }

    /**
     * Deserialize an {@link Unfiltered} from the provided input.
     *
     * @param in the input from which to deserialize.
     * @param header serialization header corresponding to the serialized data.
     * @param helper the helper to use for deserialization.
     * @param builder a row builder, passed here so we don't allocate a new one for every new row.
     * @return the deserialized {@link Unfiltered} or {@code null} if we've read the end of a partition. This method is
     * guaranteed to never return empty rows.
     */
    public Unfiltered deserialize(DataInputPlus in, SerializationHeader header, DeserializationHelper helper, Row.Builder builder)
    throws IOException
    {
        while (true)
        {
<span class="fc" id="L436">            Unfiltered unfiltered = deserializeOne(in, header, helper, builder);</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">            if (unfiltered == null)</span>
<span class="fc" id="L438">                return null;</span>

            // Skip empty rows, see deserializeOne javadoc
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">            if (!unfiltered.isEmpty())</span>
<span class="fc" id="L442">                return unfiltered;</span>
<span class="nc" id="L443">        }</span>
    }

    /**
     * Deserialize a single {@link Unfiltered} from the provided input.
     * &lt;p&gt;
     * &lt;b&gt;WARNING:&lt;/b&gt; this can return an empty row because it's possible there is a row serialized, but that row only
     * contains data for dropped columns, see CASSANDRA-13337. But as most code expect rows to not be empty, this isn't
     * meant to be exposed publicly.
     *
     * But as {@link UnfilteredRowIterator} should not return empty
     * rows, this mean consumer of this method should make sure to skip said empty rows.
     */
    private Unfiltered deserializeOne(DataInputPlus in, SerializationHeader header, DeserializationHelper helper, Row.Builder builder)
    throws IOException
    {
        // It wouldn't be wrong per-se to use an unsorted builder, but it would be inefficient so make sure we don't do it by mistake
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">        assert builder.isSorted();</span>

<span class="fc" id="L462">        int flags = in.readUnsignedByte();</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">        if (isEndOfPartition(flags))</span>
<span class="fc" id="L464">            return null;</span>

<span class="fc" id="L466">        int extendedFlags = readExtendedFlags(in, flags);</span>

<span class="pc bpc" id="L468" title="1 of 2 branches missed.">        if (kind(flags) == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)</span>
        {
<span class="nc" id="L470">            ClusteringBoundOrBoundary&lt;byte[]&gt; bound = ClusteringBoundOrBoundary.serializer.deserialize(in, helper.version, header.clusteringTypes());</span>
<span class="nc" id="L471">            return deserializeMarkerBody(in, header, bound);</span>
        }
        else
        {
            // deserializeStaticRow should be used for that.
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">            if (isStatic(extendedFlags))</span>
<span class="nc" id="L477">                throw new IOException(&quot;Corrupt flags value for unfiltered partition (isStatic flag set): &quot; + flags);</span>

<span class="fc" id="L479">            builder.newRow(Clustering.serializer.deserialize(in, helper.version, header.clusteringTypes()));</span>
<span class="fc" id="L480">            return deserializeRowBody(in, header, helper, flags, extendedFlags, builder);</span>
        }
    }

    public Unfiltered deserializeTombstonesOnly(FileDataInput in, SerializationHeader header, DeserializationHelper helper)
    throws IOException
    {
        while (true)
        {
<span class="nc" id="L489">            int flags = in.readUnsignedByte();</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">            if (isEndOfPartition(flags))</span>
<span class="nc" id="L491">                return null;</span>

<span class="nc" id="L493">            int extendedFlags = readExtendedFlags(in, flags);</span>

<span class="nc bnc" id="L495" title="All 2 branches missed.">            if (kind(flags) == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)</span>
            {
<span class="nc" id="L497">                ClusteringBoundOrBoundary&lt;byte[]&gt; bound = ClusteringBoundOrBoundary.serializer.deserialize(in, helper.version, header.clusteringTypes());</span>
<span class="nc" id="L498">                return deserializeMarkerBody(in, header, bound);</span>
            }
            else
            {
<span class="nc bnc" id="L502" title="All 2 branches missed.">                assert !isStatic(extendedFlags); // deserializeStaticRow should be used for that.</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">                if ((flags &amp; HAS_DELETION) != 0)</span>
                {
<span class="nc bnc" id="L505" title="All 2 branches missed.">                    assert header.isForSSTable();</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">                    boolean hasTimestamp = (flags &amp; HAS_TIMESTAMP) != 0;</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">                    boolean hasTTL = (flags &amp; HAS_TTL) != 0;</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">                    boolean deletionIsShadowable = (extendedFlags &amp; HAS_SHADOWABLE_DELETION) != 0;</span>
<span class="nc" id="L509">                    Clustering&lt;byte[]&gt; clustering = Clustering.serializer.deserialize(in, helper.version, header.clusteringTypes());</span>
<span class="nc" id="L510">                    long nextPosition = in.readUnsignedVInt() + in.getFilePointer();</span>
<span class="nc" id="L511">                    in.readUnsignedVInt(); // skip previous unfiltered size</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">                    if (hasTimestamp)</span>
                    {
<span class="nc" id="L514">                        header.readTimestamp(in);</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">                        if (hasTTL)</span>
                        {
<span class="nc" id="L517">                            header.readTTL(in);</span>
<span class="nc" id="L518">                            header.readLocalDeletionTime(in);</span>
                        }
                    }

<span class="nc" id="L522">                    Deletion deletion = new Row.Deletion(header.readDeletionTime(in), deletionIsShadowable);</span>
<span class="nc" id="L523">                    in.seek(nextPosition);</span>
<span class="nc" id="L524">                    return BTreeRow.emptyDeletedRow(clustering, deletion);</span>
                }
                else
                {
<span class="nc" id="L528">                    Clustering.serializer.skip(in, helper.version, header.clusteringTypes());</span>
<span class="nc" id="L529">                    skipRowBody(in);</span>
                    // Continue with next item.
                }
            }
<span class="nc" id="L533">        }</span>
    }

    public Row deserializeStaticRow(DataInputPlus in, SerializationHeader header, DeserializationHelper helper)
    throws IOException
    {
<span class="nc" id="L539">        int flags = in.readUnsignedByte();</span>
<span class="nc bnc" id="L540" title="All 6 branches missed.">        assert !isEndOfPartition(flags) &amp;&amp; kind(flags) == Unfiltered.Kind.ROW &amp;&amp; isExtended(flags) : flags;</span>
<span class="nc" id="L541">        int extendedFlags = in.readUnsignedByte();</span>
<span class="nc" id="L542">        Row.Builder builder = BTreeRow.sortedBuilder();</span>
<span class="nc" id="L543">        builder.newRow(Clustering.STATIC_CLUSTERING);</span>
<span class="nc" id="L544">        return deserializeRowBody(in, header, helper, flags, extendedFlags, builder);</span>
    }

    public RangeTombstoneMarker deserializeMarkerBody(DataInputPlus in, SerializationHeader header, ClusteringBoundOrBoundary&lt;?&gt; bound)
    throws IOException
    {
<span class="nc bnc" id="L550" title="All 2 branches missed.">        if (header.isForSSTable())</span>
        {
<span class="nc" id="L552">            in.readUnsignedVInt(); // marker size</span>
<span class="nc" id="L553">            in.readUnsignedVInt(); // previous unfiltered size</span>
        }

<span class="nc bnc" id="L556" title="All 2 branches missed.">        if (bound.isBoundary())</span>
<span class="nc" id="L557">            return new RangeTombstoneBoundaryMarker((ClusteringBoundary&lt;?&gt;) bound, header.readDeletionTime(in), header.readDeletionTime(in));</span>
        else
<span class="nc" id="L559">            return new RangeTombstoneBoundMarker((ClusteringBound&lt;?&gt;) bound, header.readDeletionTime(in));</span>
    }

    public Row deserializeRowBody(DataInputPlus in,
                                  SerializationHeader header,
                                  DeserializationHelper helper,
                                  int flags,
                                  int extendedFlags,
                                  Row.Builder builder)
    throws IOException
    {
        try
        {
<span class="fc" id="L572">            boolean isStatic = isStatic(extendedFlags);</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">            boolean hasTimestamp = (flags &amp; HAS_TIMESTAMP) != 0;</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">            boolean hasTTL = (flags &amp; HAS_TTL) != 0;</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">            boolean hasDeletion = (flags &amp; HAS_DELETION) != 0;</span>
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">            boolean deletionIsShadowable = (extendedFlags &amp; HAS_SHADOWABLE_DELETION) != 0;</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">            boolean hasComplexDeletion = (flags &amp; HAS_COMPLEX_DELETION) != 0;</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">            boolean hasAllColumns = (flags &amp; HAS_ALL_COLUMNS) != 0;</span>
<span class="fc" id="L579">            Columns headerColumns = header.columns(isStatic);</span>

<span class="fc bfc" id="L581" title="All 2 branches covered.">            if (header.isForSSTable())</span>
            {
<span class="fc" id="L583">                long rowSize = in.readUnsignedVInt();</span>
<span class="fc" id="L584">                in.readUnsignedVInt(); // previous unfiltered size</span>
<span class="fc" id="L585">                in = new TrackedDataInputPlus(in, rowSize);</span>
            }

<span class="fc" id="L588">            LivenessInfo rowLiveness = LivenessInfo.EMPTY;</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">            if (hasTimestamp)</span>
            {
<span class="fc" id="L591">                long timestamp = header.readTimestamp(in);</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">                int ttl = hasTTL ? header.readTTL(in) : LivenessInfo.NO_TTL;</span>
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">                assert ttl &gt;= 0 : &quot;Invalid TTL &quot; + ttl;</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">                long localDeletionTime = hasTTL ? header.readLocalDeletionTime(in) : LivenessInfo.NO_EXPIRATION_TIME;</span>

<span class="fc" id="L596">                localDeletionTime = Cell.decodeLocalDeletionTime(localDeletionTime, ttl, helper);</span>

<span class="fc" id="L598">                rowLiveness = LivenessInfo.withExpirationTime(timestamp, ttl, localDeletionTime);</span>
            }

<span class="fc" id="L601">            builder.addPrimaryKeyLivenessInfo(rowLiveness);</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">            builder.addRowDeletion(hasDeletion ? new Row.Deletion(header.readDeletionTime(in), deletionIsShadowable) : Row.Deletion.LIVE);</span>

<span class="fc bfc" id="L604" title="All 2 branches covered.">            Columns columns = hasAllColumns ? headerColumns : Columns.serializer.deserializeSubset(headerColumns, in);</span>

<span class="fc" id="L606">            final LivenessInfo livenessInfo = rowLiveness;</span>

            try
            {
<span class="fc" id="L610">                DataInputPlus finalIn = in;</span>
<span class="fc" id="L611">                columns.apply(column -&gt; {</span>
                    try
                    {
<span class="fc bfc" id="L614" title="All 2 branches covered.">                        if (column.isSimple())</span>
<span class="fc" id="L615">                            readSimpleColumn(column, finalIn, header, helper, builder, livenessInfo);</span>
                        else
<span class="fc" id="L617">                            readComplexColumn(column, finalIn, header, helper, hasComplexDeletion, builder, livenessInfo);</span>
                    }
<span class="nc" id="L619">                    catch (IOException e)</span>
                    {
<span class="nc" id="L621">                        throw new WrappedException(e);</span>
<span class="fc" id="L622">                    }</span>
<span class="fc" id="L623">                });</span>
            }
<span class="nc" id="L625">            catch (WrappedException e)</span>
            {
<span class="nc bnc" id="L627" title="All 2 branches missed.">                if (e.getCause() instanceof IOException)</span>
<span class="nc" id="L628">                    throw (IOException) e.getCause();</span>

<span class="nc" id="L630">                throw e;</span>
<span class="fc" id="L631">            }</span>

<span class="fc" id="L633">            return builder.build();</span>
        }
<span class="nc" id="L635">        catch (RuntimeException | AssertionError e)</span>
        {
            // Corrupted data could be such that it triggers an assertion in the row Builder, or break one of its assumption.
            // Of course, a bug in said builder could also trigger this, but it's impossible a priori to always make the distinction
            // between a real bug and data corrupted in just the bad way. Besides, re-throwing as an IOException doesn't hide the
            // exception, it just make we catch it properly and mark the sstable as corrupted.
<span class="nc" id="L641">            throw new IOException(&quot;Error building row with data deserialized from &quot; + in, e);</span>
        }
    }

    private void readSimpleColumn(ColumnMetadata column, DataInputPlus in, SerializationHeader header, DeserializationHelper helper, Row.Builder builder, LivenessInfo rowLiveness)
    throws IOException
    {
<span class="pc bpc" id="L648" title="1 of 2 branches missed.">        if (helper.includes(column))</span>
        {
<span class="fc" id="L650">            Cell&lt;byte[]&gt; cell = Cell.serializer.deserialize(in, rowLiveness, column, header, helper, ByteArrayAccessor.instance);</span>
<span class="pc bpc" id="L651" title="1 of 4 branches missed.">            if (helper.includes(cell, rowLiveness) &amp;&amp; !helper.isDropped(cell, false))</span>
<span class="fc" id="L652">                builder.addCell(cell);</span>
<span class="fc" id="L653">        }</span>
        else
        {
<span class="nc" id="L656">            Cell.serializer.skip(in, column, header);</span>
        }
<span class="fc" id="L658">    }</span>

    private void readComplexColumn(ColumnMetadata column, DataInputPlus in, SerializationHeader header, DeserializationHelper helper, boolean hasComplexDeletion, Row.Builder builder, LivenessInfo rowLiveness)
    throws IOException
    {
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">        if (helper.includes(column))</span>
        {
<span class="fc" id="L665">            helper.startOfComplexColumn(column);</span>
<span class="fc bfc" id="L666" title="All 2 branches covered.">            if (hasComplexDeletion)</span>
            {
<span class="fc" id="L668">                DeletionTime complexDeletion = header.readDeletionTime(in);</span>
<span class="pc bpc" id="L669" title="1 of 2 branches missed.">                if (complexDeletion.localDeletionTime() &lt; 0)</span>
                {
<span class="nc bnc" id="L671" title="All 2 branches missed.">                    if (helper.version &lt; MessagingService.VERSION_50)</span>
<span class="nc" id="L672">                        complexDeletion = DeletionTime.build(complexDeletion.markedForDeleteAt(), Cell.INVALID_DELETION_TIME);</span>
                    else
<span class="nc" id="L674">                        complexDeletion = DeletionTime.build(complexDeletion.markedForDeleteAt(), Cell.deletionTimeUnsignedIntegerToLong((int) complexDeletion.localDeletionTime()));</span>
                }
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">                if (!helper.isDroppedComplexDeletion(complexDeletion))</span>
<span class="fc" id="L677">                    builder.addComplexDeletion(column, complexDeletion);</span>
            }

<span class="fc" id="L680">            int count = in.readUnsignedVInt32();</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">            while (--count &gt;= 0)</span>
            {
<span class="fc" id="L683">                Cell&lt;byte[]&gt; cell = Cell.serializer.deserialize(in, rowLiveness, column, header, helper, ByteArrayAccessor.instance);</span>
<span class="pc bpc" id="L684" title="2 of 4 branches missed.">                if (helper.includes(cell, rowLiveness) &amp;&amp; !helper.isDropped(cell, true))</span>
<span class="fc" id="L685">                    builder.addCell(cell);</span>
<span class="fc" id="L686">            }</span>

<span class="fc" id="L688">            helper.endOfComplexColumn();</span>
<span class="fc" id="L689">        }</span>
        else
        {
<span class="nc" id="L692">            skipComplexColumn(in, column, header, hasComplexDeletion);</span>
        }
<span class="fc" id="L694">    }</span>

    public void skipRowBody(DataInputPlus in) throws IOException
    {
<span class="fc" id="L698">        int rowSize = in.readUnsignedVInt32();</span>
<span class="fc" id="L699">        in.skipBytesFully(rowSize);</span>
<span class="fc" id="L700">    }</span>

    public void skipStaticRow(DataInputPlus in, SerializationHeader header, DeserializationHelper helper) throws IOException
    {
<span class="nc" id="L704">        int flags = in.readUnsignedByte();</span>
<span class="nc bnc" id="L705" title="All 6 branches missed.">        assert !isEndOfPartition(flags) &amp;&amp; kind(flags) == Unfiltered.Kind.ROW &amp;&amp; isExtended(flags) : &quot;Flags is &quot; + flags;</span>
<span class="nc" id="L706">        int extendedFlags = in.readUnsignedByte();</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">        assert isStatic(extendedFlags);</span>
<span class="nc" id="L708">        skipRowBody(in);</span>
<span class="nc" id="L709">    }</span>

    public void skipMarkerBody(DataInputPlus in) throws IOException
    {
<span class="nc" id="L713">        int markerSize = in.readUnsignedVInt32();</span>
<span class="nc" id="L714">        in.skipBytesFully(markerSize);</span>
<span class="nc" id="L715">    }</span>

    private void skipComplexColumn(DataInputPlus in, ColumnMetadata column, SerializationHeader header, boolean hasComplexDeletion)
    throws IOException
    {
<span class="nc bnc" id="L720" title="All 2 branches missed.">        if (hasComplexDeletion)</span>
<span class="nc" id="L721">            header.skipDeletionTime(in);</span>

<span class="nc" id="L723">        int count = in.readUnsignedVInt32();</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">        while (--count &gt;= 0)</span>
<span class="nc" id="L725">            Cell.serializer.skip(in, column, header);</span>
<span class="nc" id="L726">    }</span>

    public static boolean isEndOfPartition(int flags)
    {
<span class="fc bfc" id="L730" title="All 2 branches covered.">        return (flags &amp; END_OF_PARTITION) != 0;</span>
    }

    public static Unfiltered.Kind kind(int flags)
    {
<span class="pc bpc" id="L735" title="1 of 2 branches missed.">        return (flags &amp; IS_MARKER) != 0 ? Unfiltered.Kind.RANGE_TOMBSTONE_MARKER : Unfiltered.Kind.ROW;</span>
    }

    public static boolean isStatic(int extendedFlags)
    {
<span class="pc bpc" id="L740" title="1 of 2 branches missed.">        return (extendedFlags &amp; IS_STATIC) != 0;</span>
    }

    private static boolean isExtended(int flags)
    {
<span class="pc bpc" id="L745" title="1 of 2 branches missed.">        return (flags &amp; EXTENSION_FLAG) != 0;</span>
    }

    public static int readExtendedFlags(DataInputPlus in, int flags) throws IOException
    {
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">        return isExtended(flags) ? in.readUnsignedByte() : 0;</span>
    }

    public static boolean hasExtendedFlags(Row row)
    {
<span class="pc bpc" id="L755" title="2 of 4 branches missed.">        return row.isStatic() || row.deletion().isShadowable();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>