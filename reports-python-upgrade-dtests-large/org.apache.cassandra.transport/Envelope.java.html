<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Envelope.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.transport</a> &gt; <span class="el_source">Envelope.java</span></div><h1>Envelope.java</h1><pre class="source lang-java linenums">
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.transport;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.EnumSet;
import java.util.List;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.*;
import io.netty.handler.codec.ByteToMessageDecoder;
import io.netty.handler.codec.MessageToMessageDecoder;
import io.netty.handler.codec.MessageToMessageEncoder;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.metrics.ClientMessageSizeMetrics;
import org.apache.cassandra.transport.messages.ErrorMessage;
import org.apache.cassandra.utils.ByteBufferUtil;

public class Envelope
{
    public static final byte PROTOCOL_VERSION_MASK = 0x7f;

    public final Header header;
    public final ByteBuf body;

    /**
     * An on-wire message envelope consists of a header and a body.
     *
     * The header is defined the following way in native protocol version 3 and later:
     *
     *   0         8        16        24        32         40
     *   +---------+---------+---------+---------+---------+
     *   | version |  flags  |      stream       | opcode  |
     *   +---------+---------+---------+---------+---------+
     *   |                length                 |
     *   +---------+---------+---------+---------+
     */
    public Envelope(Header header, ByteBuf body)
<span class="fc" id="L61">    {</span>
<span class="fc" id="L62">        this.header = header;</span>
<span class="fc" id="L63">        this.body = body;</span>
<span class="fc" id="L64">    }</span>

    public void retain()
    {
<span class="nc" id="L68">        body.retain();</span>
<span class="nc" id="L69">    }</span>

    public boolean release()
    {
<span class="fc" id="L73">        return body.release();</span>
    }

    @VisibleForTesting
    public Envelope clone()
    {
<span class="nc" id="L79">        return new Envelope(header, Unpooled.wrappedBuffer(ByteBufferUtil.clone(body.nioBuffer())));</span>
    }

    public static Envelope create(Message.Type type, int streamId, ProtocolVersion version, EnumSet&lt;Header.Flag&gt; flags, ByteBuf body)
    {
<span class="fc" id="L84">        Header header = new Header(version, flags, streamId, type, body.readableBytes());</span>
<span class="fc" id="L85">        return new Envelope(header, body);</span>
    }

    // used by V4 and earlier in Encoder.encode
    public ByteBuf encodeHeader()
    {
<span class="fc" id="L91">        ByteBuf buf = CBUtil.allocator.buffer(Header.LENGTH);</span>

<span class="fc" id="L93">        Message.Type type = header.type;</span>
<span class="fc" id="L94">        buf.writeByte(type.direction.addToVersion(header.version.asInt()));</span>
<span class="fc" id="L95">        buf.writeByte(Header.Flag.serialize(header.flags));</span>

        // Continue to support writing pre-v3 headers so that we can give proper error messages to drivers that
        // connect with the v1/v2 protocol. See CASSANDRA-11464.
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">        if (header.version.isGreaterOrEqualTo(ProtocolVersion.V3))</span>
<span class="fc" id="L100">            buf.writeShort(header.streamId);</span>
        else
<span class="nc" id="L102">            buf.writeByte(header.streamId);</span>

<span class="fc" id="L104">        buf.writeByte(type.opcode);</span>
<span class="fc" id="L105">        buf.writeInt(body.readableBytes());</span>
<span class="fc" id="L106">        return buf;</span>
    }

    // Used by V5 and later
    public void encodeHeaderInto(ByteBuffer buf)
    {
<span class="fc" id="L112">        buf.put((byte) header.type.direction.addToVersion(header.version.asInt()));</span>
<span class="fc" id="L113">        buf.put((byte) Envelope.Header.Flag.serialize(header.flags));</span>

<span class="pc bpc" id="L115" title="1 of 2 branches missed.">        if (header.version.isGreaterOrEqualTo(ProtocolVersion.V3))</span>
<span class="fc" id="L116">            buf.putShort((short) header.streamId);</span>
        else
<span class="nc" id="L118">            buf.put((byte) header.streamId);</span>

<span class="fc" id="L120">        buf.put((byte) header.type.opcode);</span>
<span class="fc" id="L121">        buf.putInt(body.readableBytes());</span>
<span class="fc" id="L122">    }</span>

    // Used by V5 and later
    public void encodeInto(ByteBuffer buf)
    {
<span class="fc" id="L127">        encodeHeaderInto(buf);</span>
<span class="fc" id="L128">        buf.put(body.nioBuffer());</span>
<span class="fc" id="L129">    }</span>

    public static class Header
    {
        // 9 bytes in protocol version 3 and later
        public static final int LENGTH = 9;

        public static final int BODY_LENGTH_SIZE = 4;

        public final ProtocolVersion version;
        public final EnumSet&lt;Flag&gt; flags;
        public final int streamId;
        public final Message.Type type;
        public final long bodySizeInBytes;

        private Header(ProtocolVersion version, EnumSet&lt;Flag&gt; flags, int streamId, Message.Type type, long bodySizeInBytes)
<span class="fc" id="L145">        {</span>
<span class="fc" id="L146">            this.version = version;</span>
<span class="fc" id="L147">            this.flags = flags;</span>
<span class="fc" id="L148">            this.streamId = streamId;</span>
<span class="fc" id="L149">            this.type = type;</span>
<span class="fc" id="L150">            this.bodySizeInBytes = bodySizeInBytes;</span>
<span class="fc" id="L151">        }</span>

<span class="fc" id="L153">        public enum Flag</span>
        {
            // The order of that enum matters!!
<span class="fc" id="L156">            COMPRESSED,</span>
<span class="fc" id="L157">            TRACING,</span>
<span class="fc" id="L158">            CUSTOM_PAYLOAD,</span>
<span class="fc" id="L159">            WARNING,</span>
<span class="fc" id="L160">            USE_BETA;</span>

<span class="fc" id="L162">            private static final Flag[] ALL_VALUES = values();</span>

            public static EnumSet&lt;Flag&gt; deserialize(int flags)
            {
<span class="fc" id="L166">                EnumSet&lt;Flag&gt; set = EnumSet.noneOf(Flag.class);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">                for (int n = 0; n &lt; ALL_VALUES.length; n++)</span>
                {
<span class="fc bfc" id="L169" title="All 2 branches covered.">                    if ((flags &amp; (1 &lt;&lt; n)) != 0)</span>
<span class="fc" id="L170">                        set.add(ALL_VALUES[n]);</span>
                }
<span class="fc" id="L172">                return set;</span>
            }

            public static int serialize(EnumSet&lt;Flag&gt; flags)
            {
<span class="fc" id="L177">                int i = 0;</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">                for (Flag flag : flags)</span>
<span class="fc" id="L179">                    i |= 1 &lt;&lt; flag.ordinal();</span>
<span class="fc" id="L180">                return i;</span>
            }
        }
    }

    public Envelope with(ByteBuf newBody)
    {
<span class="nc" id="L187">        return new Envelope(header, newBody);</span>
    }

<span class="fc" id="L190">    public static class Decoder extends ByteToMessageDecoder</span>
    {
<span class="fc" id="L192">        private static final int MAX_TOTAL_LENGTH = DatabaseDescriptor.getNativeTransportMaxFrameSize();</span>

        private boolean discardingTooLongMessage;
        private long tooLongTotalLength;
        private long bytesToDiscard;
        private int tooLongStreamId;

        /**
         * Used by protocol V5 and later to extract a CQL message header from the buffer containing
         * it, without modifying the position of the underlying buffer. This essentially mirrors the
         * pre-V5 code in {@link Decoder#decode(ByteBuf)}, with three differences:
         * &lt;ul&gt;
         *  &lt;li&gt;The input is a ByteBuffer rather than a ByteBuf&lt;/li&gt;
         *  &lt;li&gt;This cannot return null, as V5 always deals with entire CQL messages. Coalescing of bytes
         *  off the wire happens at the layer below, in {@link org.apache.cassandra.net.FrameDecoder}&lt;/li&gt;
         *  &lt;li&gt;This method never throws {@link ProtocolException}. Instead, a subclass of
         *  {@link HeaderExtractionResult} is returned which may provide either a {@link Header} or a
         *  {@link ProtocolException},depending on the result of its {@link HeaderExtractionResult#isSuccess()}
         *  method.&lt;/li&gt;
         *&lt;/ul&gt;
         *
         * @param buffer ByteBuffer containing the message envelope
         * @return The result of attempting to extract a header from the input buffer.
         */
        HeaderExtractionResult extractHeader(ByteBuffer buffer)
        {
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">            Preconditions.checkArgument(buffer.remaining() &gt;= Header.LENGTH,</span>
                                        &quot;Undersized buffer supplied. Expected %s, actual %s&quot;,
                                        Header.LENGTH,
<span class="fc" id="L221">                                        buffer.remaining());</span>
<span class="fc" id="L222">            int idx = buffer.position();</span>
<span class="fc" id="L223">            int firstByte = buffer.get(idx++);</span>
<span class="fc" id="L224">            int versionNum = firstByte &amp; PROTOCOL_VERSION_MASK;</span>
<span class="fc" id="L225">            int flags = buffer.get(idx++);</span>
<span class="fc" id="L226">            int streamId = buffer.getShort(idx);</span>
<span class="fc" id="L227">            idx += 2;</span>
<span class="fc" id="L228">            int opcode = buffer.get(idx++);</span>
<span class="fc" id="L229">            long bodyLength = buffer.getInt(idx);</span>

            // if a negative length is read, return error but report length as 0 so we don't attempt to skip
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">            if (bodyLength &lt; 0)</span>
<span class="nc" id="L233">                return new HeaderExtractionResult.Error(new ProtocolException(&quot;Invalid value for envelope header body length field: &quot; + bodyLength),</span>
                                                        streamId, bodyLength);

<span class="fc" id="L236">            Message.Direction direction = Message.Direction.extractFromVersion(firstByte);</span>
            Message.Type type;
            ProtocolVersion version;
            EnumSet&lt;Header.Flag&gt; decodedFlags;
            try
            {
                // This throws a protocol exception if the version number is unsupported,
                // the opcode is unknown or invalid flags are set for the version
<span class="fc" id="L244">                version = ProtocolVersion.decode(versionNum, DatabaseDescriptor.getNativeTransportAllowOlderProtocols());</span>
<span class="fc" id="L245">                decodedFlags = decodeFlags(version, flags);</span>
<span class="fc" id="L246">                type = Message.Type.fromOpcode(opcode, direction);</span>
<span class="fc" id="L247">                return new HeaderExtractionResult.Success(new Header(version, decodedFlags, streamId, type, bodyLength));</span>
            }
<span class="nc" id="L249">            catch (ProtocolException e)</span>
            {
                // Including the streamId and bodyLength is a best effort to allow the caller
                // to send a meaningful response to the client and continue processing the
                // rest of the frame. It's possible that these are bogus and may have contributed
                // to the ProtocolException. If so, the upstream CQLMessageHandler should run into
                // further errors and once it breaches its threshold for consecutive errors, it will
                // cause the channel to be closed.
<span class="nc" id="L257">                return new HeaderExtractionResult.Error(e, streamId, bodyLength);</span>
            }
        }

        public static abstract class HeaderExtractionResult
        {
<span class="fc" id="L263">            enum Outcome { SUCCESS, ERROR };</span>

            private final Outcome outcome;
            private final int streamId;
            private final long bodyLength;
            private HeaderExtractionResult(Outcome outcome, int streamId, long bodyLength)
<span class="fc" id="L269">            {</span>
<span class="fc" id="L270">                this.outcome = outcome;</span>
<span class="fc" id="L271">                this.streamId = streamId;</span>
<span class="fc" id="L272">                this.bodyLength = bodyLength;</span>
<span class="fc" id="L273">            }</span>

            boolean isSuccess()
            {
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">                return outcome == Outcome.SUCCESS;</span>
            }

            int streamId()
            {
<span class="nc" id="L282">                return streamId;</span>
            }

            long bodyLength()
            {
<span class="nc" id="L287">                return bodyLength;</span>
            }

            Header header()
            {
<span class="nc" id="L292">                throw new IllegalStateException(String.format(&quot;Unable to provide header from extraction result : %s&quot;, outcome));</span>
            };

            ProtocolException error()
            {
<span class="nc" id="L297">                throw new IllegalStateException(String.format(&quot;Unable to provide error from extraction result : %s&quot;, outcome));</span>
            }

            private static class Success extends HeaderExtractionResult
            {
                private final Header header;
                Success(Header header)
                {
<span class="fc" id="L305">                    super(Outcome.SUCCESS, header.streamId, header.bodySizeInBytes);</span>
<span class="fc" id="L306">                    this.header = header;</span>
<span class="fc" id="L307">                }</span>

                @Override
                Header header()
                {
<span class="fc" id="L312">                    return header;</span>
                }
            }

            private static class Error extends HeaderExtractionResult
            {
                private final ProtocolException error;
                private Error(ProtocolException error, int streamId, long bodyLength)
                {
<span class="nc" id="L321">                    super(Outcome.ERROR, streamId, bodyLength);</span>
<span class="nc" id="L322">                    this.error = error;</span>
<span class="nc" id="L323">                }</span>

                @Override
                ProtocolException error()
                {
<span class="nc" id="L328">                    return error;</span>
                }
            }
        }

        @VisibleForTesting
        Envelope decode(ByteBuf buffer)
        {
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">            if (discardingTooLongMessage)</span>
            {
<span class="nc" id="L338">                bytesToDiscard = discard(buffer, bytesToDiscard);</span>
                // If we have discarded everything, throw the exception
<span class="nc bnc" id="L340" title="All 2 branches missed.">                if (bytesToDiscard &lt;= 0)</span>
<span class="nc" id="L341">                    fail();</span>
<span class="nc" id="L342">                return null;</span>
            }

<span class="fc" id="L345">            int readableBytes = buffer.readableBytes();</span>
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">            if (readableBytes == 0)</span>
<span class="nc" id="L347">                return null;</span>

<span class="fc" id="L349">            int idx = buffer.readerIndex();</span>

            // Check the first byte for the protocol version before we wait for a complete header.  Protocol versions
            // 1 and 2 use a shorter header, so we may never have a complete header's worth of bytes.
<span class="fc" id="L353">            int firstByte = buffer.getByte(idx++);</span>
<span class="fc" id="L354">            Message.Direction direction = Message.Direction.extractFromVersion(firstByte);</span>
<span class="fc" id="L355">            int versionNum = firstByte &amp; PROTOCOL_VERSION_MASK;</span>

            ProtocolVersion version;
            
            try
            {
<span class="fc" id="L361">                version = ProtocolVersion.decode(versionNum, DatabaseDescriptor.getNativeTransportAllowOlderProtocols());</span>
            }
<span class="nc" id="L363">            catch (ProtocolException e)</span>
            {
                // Skip the remaining useless bytes. Otherwise the channel closing logic may try to decode again. 
<span class="nc" id="L366">                buffer.skipBytes(readableBytes);</span>
<span class="nc" id="L367">                throw e;</span>
<span class="fc" id="L368">            }</span>

            // Wait until we have the complete header
<span class="fc bfc" id="L371" title="All 2 branches covered.">            if (readableBytes &lt; Header.LENGTH)</span>
<span class="fc" id="L372">                return null;</span>

<span class="fc" id="L374">            int flags = buffer.getByte(idx++);</span>
<span class="fc" id="L375">            EnumSet&lt;Header.Flag&gt; decodedFlags = decodeFlags(version, flags);</span>

<span class="fc" id="L377">            int streamId = buffer.getShort(idx);</span>
<span class="fc" id="L378">            idx += 2;</span>

            // This throws a protocol exceptions if the opcode is unknown
            Message.Type type;
            try
            {
<span class="fc" id="L384">                type = Message.Type.fromOpcode(buffer.getByte(idx++), direction);</span>
            }
<span class="nc" id="L386">            catch (ProtocolException e)</span>
            {
<span class="nc" id="L388">                throw ErrorMessage.wrap(e, streamId);</span>
<span class="fc" id="L389">            }</span>

<span class="fc" id="L391">            long bodyLength = buffer.getUnsignedInt(idx);</span>
<span class="fc" id="L392">            idx += Header.BODY_LENGTH_SIZE;</span>

<span class="fc" id="L394">            long totalLength = bodyLength + Header.LENGTH;</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">            if (totalLength &gt; MAX_TOTAL_LENGTH)</span>
            {
                // Enter the discard mode and discard everything received so far.
<span class="nc" id="L398">                discardingTooLongMessage = true;</span>
<span class="nc" id="L399">                tooLongStreamId = streamId;</span>
<span class="nc" id="L400">                tooLongTotalLength = totalLength;</span>
<span class="nc" id="L401">                bytesToDiscard = discard(buffer, totalLength);</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">                if (bytesToDiscard &lt;= 0)</span>
<span class="nc" id="L403">                    fail();</span>
<span class="nc" id="L404">                return null;</span>
            }

<span class="fc bfc" id="L407" title="All 2 branches covered.">            if (buffer.readableBytes() &lt; totalLength)</span>
<span class="fc" id="L408">                return null;</span>

<span class="fc" id="L410">            ClientMessageSizeMetrics.bytesReceived.inc(totalLength);</span>
<span class="fc" id="L411">            ClientMessageSizeMetrics.bytesReceivedPerRequest.update(totalLength);</span>

            // extract body
<span class="fc" id="L414">            ByteBuf body = buffer.slice(idx, (int) bodyLength);</span>
<span class="fc" id="L415">            body.retain();</span>

<span class="fc" id="L417">            idx += bodyLength;</span>
<span class="fc" id="L418">            buffer.readerIndex(idx);</span>

<span class="fc" id="L420">            return new Envelope(new Header(version, decodedFlags, streamId, type, bodyLength), body);</span>
        }

        private EnumSet&lt;Header.Flag&gt; decodeFlags(ProtocolVersion version, int flags)
        {
<span class="fc" id="L425">            EnumSet&lt;Header.Flag&gt; decodedFlags = Header.Flag.deserialize(flags);</span>

<span class="pc bpc" id="L427" title="3 of 4 branches missed.">            if (version.isBeta() &amp;&amp; !decodedFlags.contains(Header.Flag.USE_BETA))</span>
<span class="nc" id="L428">                throw new ProtocolException(String.format(&quot;Beta version of the protocol used (%s), but USE_BETA flag is unset&quot;, version),</span>
                                            version);
<span class="fc" id="L430">            return decodedFlags;</span>
        }

        @Override
        protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List&lt;Object&gt; results)
        {
<span class="fc" id="L436">            Envelope envelope = decode(buffer);</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">            if (envelope == null)</span>
<span class="fc" id="L438">                return;</span>

<span class="fc" id="L440">            results.add(envelope);</span>
<span class="fc" id="L441">        }</span>

        private void fail()
        {
            // Reset to the initial state and throw the exception
<span class="nc" id="L446">            long tooLongTotalLength = this.tooLongTotalLength;</span>
<span class="nc" id="L447">            this.tooLongTotalLength = 0;</span>
<span class="nc" id="L448">            discardingTooLongMessage = false;</span>
<span class="nc" id="L449">            String msg = String.format(&quot;Request is too big: length %d exceeds maximum allowed length %d.&quot;, tooLongTotalLength, MAX_TOTAL_LENGTH);</span>
<span class="nc" id="L450">            throw ErrorMessage.wrap(new InvalidRequestException(msg), tooLongStreamId);</span>
        }
    }

    // How much remains to be discarded
    private static long discard(ByteBuf buffer, long remainingToDiscard)
    {
<span class="nc" id="L457">        int availableToDiscard = (int) Math.min(remainingToDiscard, buffer.readableBytes());</span>
<span class="nc" id="L458">        buffer.skipBytes(availableToDiscard);</span>
<span class="nc" id="L459">        return remainingToDiscard - availableToDiscard;</span>
    }

    @ChannelHandler.Sharable
    public static class Encoder extends MessageToMessageEncoder&lt;Envelope&gt;
    {
<span class="fc" id="L465">        public static final Encoder instance = new Envelope.Encoder();</span>
        private Encoder(){}

        public void encode(ChannelHandlerContext ctx, Envelope source, List&lt;Object&gt; results)
        {
<span class="fc" id="L470">            ByteBuf serializedHeader = source.encodeHeader();</span>
<span class="fc" id="L471">            int messageSize = serializedHeader.readableBytes() + source.body.readableBytes();</span>
<span class="fc" id="L472">            ClientMessageSizeMetrics.bytesSent.inc(messageSize);</span>
<span class="fc" id="L473">            ClientMessageSizeMetrics.bytesSentPerResponse.update(messageSize);</span>

<span class="fc" id="L475">            results.add(serializedHeader);</span>
<span class="fc" id="L476">            results.add(source.body);</span>
<span class="fc" id="L477">        }</span>
    }

    @ChannelHandler.Sharable
    public static class Decompressor extends MessageToMessageDecoder&lt;Envelope&gt;
    {
<span class="fc" id="L483">        public static Decompressor instance = new Envelope.Decompressor();</span>
        private Decompressor(){}

        public void decode(ChannelHandlerContext ctx, Envelope source, List&lt;Object&gt; results)
        throws IOException
        {
<span class="fc" id="L489">            Connection connection = ctx.channel().attr(Connection.attributeKey).get();</span>

<span class="pc bpc" id="L491" title="3 of 4 branches missed.">            if (!source.header.flags.contains(Header.Flag.COMPRESSED) || connection == null)</span>
            {
<span class="fc" id="L493">                results.add(source);</span>
<span class="fc" id="L494">                return;</span>
            }

<span class="nc" id="L497">            org.apache.cassandra.transport.Compressor compressor = connection.getCompressor();</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">            if (compressor == null)</span>
            {
<span class="nc" id="L500">                results.add(source);</span>
<span class="nc" id="L501">                return;</span>
            }

<span class="nc" id="L504">            results.add(compressor.decompress(source));</span>
<span class="nc" id="L505">        }</span>
    }

    @ChannelHandler.Sharable
    public static class Compressor extends MessageToMessageEncoder&lt;Envelope&gt;
    {
<span class="fc" id="L511">        public static Compressor instance = new Compressor();</span>
        private Compressor(){}

        public void encode(ChannelHandlerContext ctx, Envelope source, List&lt;Object&gt; results)
        throws IOException
        {
<span class="fc" id="L517">            Connection connection = ctx.channel().attr(Connection.attributeKey).get();</span>

            // Never compress STARTUP messages
<span class="pc bpc" id="L520" title="2 of 4 branches missed.">            if (source.header.type == Message.Type.STARTUP || connection == null)</span>
            {
<span class="nc" id="L522">                results.add(source);</span>
<span class="nc" id="L523">                return;</span>
            }

<span class="fc" id="L526">            org.apache.cassandra.transport.Compressor compressor = connection.getCompressor();</span>
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">            if (compressor == null)</span>
            {
<span class="fc" id="L529">                results.add(source);</span>
<span class="fc" id="L530">                return;</span>
            }
<span class="nc" id="L532">            source.header.flags.add(Header.Flag.COMPRESSED);</span>
<span class="nc" id="L533">            results.add(compressor.compress(source));</span>
<span class="nc" id="L534">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>