<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>File.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.io.util</a> &gt; <span class="el_source">File.java</span></div><h1>File.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.io.util;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.net.URI;
import java.nio.channels.FileChannel;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.Paths; // checkstyle: permit this import
import java.util.Objects;
import java.util.function.BiPredicate;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.Predicate;
import java.util.stream.Stream;
import javax.annotation.Nullable;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.util.concurrent.RateLimiter;

import net.openhft.chronicle.core.util.ThrowingFunction;
import org.apache.cassandra.io.FSWriteError;

import static org.apache.cassandra.io.util.PathUtils.filename;
import static org.apache.cassandra.utils.Throwables.maybeFail;

/**
 * A thin wrapper around java.nio.file.Path to provide more ergonomic functionality.
 *
 * TODO codebase probably should not use tryList, as unexpected exceptions are hidden;
 *      probably want to introduce e.g. listIfExists
 */
public class File implements Comparable&lt;File&gt;
{
<span class="fc" id="L58">    private static FileSystem filesystem = FileSystems.getDefault();</span>

<span class="fc" id="L60">    public enum WriteMode { OVERWRITE, APPEND }</span>

    public static String pathSeparator()
    {
<span class="fc" id="L64">        return filesystem.getSeparator();</span>
    }

    @Nullable final Path path; // nullable to support concept of empty path, that resolves to the working directory if converted to an absolute path

    /**
     * Construct a File representing the child {@code child} of {@code parent}
     */
    public File(String parent, String child)
    {
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">        this(parent.isEmpty() ? null : filesystem.getPath(parent), child);</span>
<span class="fc" id="L75">    }</span>

    /**
     * Construct a File representing the child {@code child} of {@code parent}
     */
    public File(File parent, String child)
    {
<span class="fc" id="L82">        this(parent.path, child);</span>
<span class="fc" id="L83">    }</span>

    /**
     * Construct a File representing the child {@code child} of {@code parent}
     */
    public File(Path parent, String child)
<span class="fc" id="L89">    {</span>
        // if &quot;empty abstract path&quot; (a la java.io.File) is provided, we should behave as though resolving relative path
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">        if (child.startsWith(pathSeparator()))</span>
<span class="nc" id="L92">            child = child.substring(pathSeparator().length());</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">        this.path = parent == null ? filesystem.getPath(child) : parent.resolve(child);</span>
<span class="fc" id="L94">    }</span>

    /**
     * Construct a File representing the provided {@code path}
     */
    public File(String path)
    {
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">        this(path.isEmpty() ? null : filesystem.getPath(path));</span>
<span class="fc" id="L102">    }</span>

    /**
     * Create a File equivalent to the java.io.File provided
     */
    public File(java.io.File file)
    {
<span class="nc bnc" id="L109" title="All 2 branches missed.">        this(file.getPath().isEmpty() ? null : file.toPath());</span>
<span class="nc" id="L110">    }</span>

    /**
     * Construct a File representing the child {@code child} of {@code parent}
     */
    public File(java.io.File parent, String child)
    {
<span class="nc" id="L117">        this(new File(parent), child);</span>
<span class="nc" id="L118">    }</span>

    /**
     * Convenience constructor equivalent to {@code new File(Paths.get(path))}
     */
    public File(URI path)
    {
<span class="nc" id="L125">        this(Paths.get(path)); //TODO unsafe if uri is file:// as it uses default file system and not File.filesystem</span>
<span class="nc bnc" id="L126" title="All 4 branches missed.">        if (!path.isAbsolute() || path.isOpaque()) throw new IllegalArgumentException();</span>
<span class="nc" id="L127">    }</span>

    /**
     * Unsafe constructor that allows a File to use a differet {@link FileSystem} than {@link File#filesystem}.
     *
     * The main caller of such a method are cases such as JVM Dtest functions that need access to the logging framwork
     * files, which exists on in {@link FileSystems#getDefault()}.
     */
    @VisibleForTesting
    public File(FileSystem fs, String first, String... more)
<span class="nc" id="L137">    {</span>
<span class="nc" id="L138">        this.path = fs.getPath(first, more);</span>
<span class="nc" id="L139">    }</span>

    /**
     * @param path the path to wrap
     */
    public File(Path path)
<span class="fc" id="L145">    {</span>
<span class="pc bpc" id="L146" title="2 of 4 branches missed.">        if (path != null &amp;&amp; path.getFileSystem() != filesystem)</span>
<span class="nc" id="L147">            throw new IllegalArgumentException(&quot;Incompatible file system; path FileSystem (&quot; + path.getFileSystem() + &quot;) is not the same reference (&quot; + filesystem + &quot;)&quot;);</span>

<span class="fc" id="L149">        this.path = path;</span>
<span class="fc" id="L150">    }</span>

    public static Path getPath(String first, String... more)
    {
<span class="fc" id="L154">        return filesystem.getPath(first, more);</span>
    }

    /**
     * Try to delete the file, returning true iff it was deleted by us. Does not ordinarily throw exceptions.
     */
    public boolean tryDelete()
    {
<span class="pc bpc" id="L162" title="2 of 4 branches missed.">        return path != null &amp;&amp; PathUtils.tryDelete(path);</span>
    }

    /**
     * This file will be deleted, and any exceptions encountered merged with {@code accumulate} to the return value
     */
    public Throwable delete(Throwable accumulate)
    {
<span class="nc" id="L170">        return delete(accumulate, null);</span>
    }

    /**
     * This file will be deleted, obeying the provided rate limiter.
     * Any exceptions encountered will be merged with {@code accumulate} to the return value
     */
    public Throwable delete(Throwable accumulate, RateLimiter rateLimiter)
    {
<span class="fc" id="L179">        return PathUtils.delete(toPathForWrite(), accumulate, rateLimiter);</span>
    }

    /**
     * This file will be deleted, with any failures being reported with an FSError
     * @throws FSWriteError if cannot be deleted
     */
    public void delete()
    {
<span class="fc" id="L188">        maybeFail(delete(null, null));</span>
<span class="fc" id="L189">    }</span>

    /**
     * This file will be deleted, with any failures being reported with an FSError
     * @throws FSWriteError if cannot be deleted
     */
    public void deleteIfExists()
    {
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (path != null)</span>
<span class="fc" id="L198">            PathUtils.deleteIfExists(path);</span>
<span class="fc" id="L199">    }</span>

    /**
     * This file will be deleted, obeying the provided rate limiter.
     * @throws FSWriteError if cannot be deleted
     */
    public void delete(RateLimiter rateLimiter)
    {
<span class="nc" id="L207">        maybeFail(delete(null, rateLimiter));</span>
<span class="nc" id="L208">    }</span>

    /**
     * Deletes all files and subdirectories under &quot;dir&quot;.
     * @throws FSWriteError if any part of the tree cannot be deleted
     */
    public void deleteRecursive(RateLimiter rateLimiter)
    {
<span class="nc" id="L216">        PathUtils.deleteRecursive(toPathForWrite(), rateLimiter);</span>
<span class="nc" id="L217">    }</span>

    /**
     * Deletes all files and subdirectories under &quot;dir&quot;.
     * @throws FSWriteError if any part of the tree cannot be deleted
     */
    public void deleteRecursive()
    {
<span class="nc" id="L225">        PathUtils.deleteRecursive(toPathForWrite());</span>
<span class="nc" id="L226">    }</span>

    /**
     * Try to delete the file on process exit.
     */
    public void deleteOnExit()
    {
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">        if (path != null) PathUtils.deleteOnExit(path);</span>
<span class="fc" id="L234">    }</span>

    /**
     * This file will be deleted on clean shutdown; if it is a directory, its entire contents
     * &lt;i&gt;at the time of shutdown&lt;/i&gt; will be deleted
     */
    public void deleteRecursiveOnExit()
    {
<span class="nc bnc" id="L242" title="All 2 branches missed.">        if (path != null)</span>
<span class="nc" id="L243">            PathUtils.deleteRecursiveOnExit(path);</span>
<span class="nc" id="L244">    }</span>

    /**
     * Try to rename the file atomically, if the system supports it.
     * @return true iff successful, false if it fails for any reason.
     */
    public boolean tryMove(File to)
    {
<span class="nc bnc" id="L252" title="All 4 branches missed.">        return path != null &amp;&amp; PathUtils.tryRename(path, to.path);</span>
    }

    /**
     * Atomically (if supported) rename/move this file to {@code to}
     * @throws FSWriteError if any part of the tree cannot be deleted
     */
    public void move(File to)
    {
<span class="fc" id="L261">        PathUtils.rename(toPathForRead(), to.toPathForWrite());</span>
<span class="fc" id="L262">    }</span>

    /**
     * @return the length of the file if it exists and if we can read it; 0 otherwise.
     */
    public long length()
    {
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">        return path == null ? 0L : PathUtils.tryGetLength(path);</span>
    }

    /**
     * @return the last modified time in millis of the path if it exists and we can read it; 0 otherwise.
     */
    public long lastModified()
    {
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">        return path == null ? 0L : PathUtils.tryGetLastModified(path);</span>
    }

    /**
     * Try to set the last modified time in millis of the path
     * @return true if it exists and we can write it; return false otherwise.
     */
    public boolean trySetLastModified(long value)
    {
<span class="nc bnc" id="L286" title="All 4 branches missed.">        return path != null &amp;&amp; PathUtils.trySetLastModified(path, value);</span>
    }

    /**
     * Try to set if the path is readable by its owner
     * @return true if it exists and we can write it; return false otherwise.
     */
    public boolean trySetReadable(boolean value)
    {
<span class="nc bnc" id="L295" title="All 4 branches missed.">        return path != null &amp;&amp; PathUtils.trySetReadable(path, value);</span>
    }

    /**
     * Try to set if the path is writable by its owner
     * @return true if it exists and we can write it; return false otherwise.
     */
    public boolean trySetWritable(boolean value)
    {
<span class="nc bnc" id="L304" title="All 4 branches missed.">        return path != null &amp;&amp; PathUtils.trySetWritable(path, value);</span>
    }

    /**
     * Try to set if the path is executable by its owner
     * @return true if it exists and we can write it; return false otherwise.
     */
    public boolean trySetExecutable(boolean value)
    {
<span class="nc bnc" id="L313" title="All 4 branches missed.">        return path != null &amp;&amp; PathUtils.trySetExecutable(path, value);</span>
    }

    /**
     * @return true if the path exists, false if it does not, or we cannot determine due to some exception
     */
    public boolean exists()
    {
<span class="pc bpc" id="L321" title="1 of 4 branches missed.">        return path != null &amp;&amp; PathUtils.exists(path);</span>
    }

    /**
     * @return true if the path refers to a directory
     */
    public boolean isDirectory()
    {
<span class="pc bpc" id="L329" title="1 of 4 branches missed.">        return path != null &amp;&amp; PathUtils.isDirectory(path);</span>
    }

    /**
     * @return true if the path refers to a regular file
     */
    public boolean isFile()
    {
<span class="nc bnc" id="L337" title="All 4 branches missed.">        return path != null &amp;&amp; PathUtils.isFile(path);</span>
    }

    /**
     * @return true if the path can be read by us
     */
    public boolean isReadable()
    {
<span class="pc bpc" id="L345" title="2 of 4 branches missed.">        return path != null &amp;&amp; Files.isReadable(path);</span>
    }

    /**
     * @return true if the path can be written by us
     */
    public boolean isWritable()
    {
<span class="pc bpc" id="L353" title="2 of 4 branches missed.">        return path != null &amp;&amp; Files.isWritable(path);</span>
    }

    /**
     * @return true if the path can be executed by us
     */
    public boolean isExecutable()
    {
<span class="pc bpc" id="L361" title="2 of 4 branches missed.">        return path != null &amp;&amp; Files.isExecutable(path);</span>
    }

    /**
     * Try to create a new regular file at this path.
     * @return true if successful, false if it already exists
     */
    public boolean createFileIfNotExists()
    {
<span class="fc" id="L370">        return PathUtils.createFileIfNotExists(toPathForWrite());</span>
    }

    public boolean createDirectoriesIfNotExists()
    {
<span class="fc" id="L375">        return PathUtils.createDirectoriesIfNotExists(toPathForWrite());</span>
    }

    /**
     * Try to create a directory at this path.
     * Return true if a new directory was created at this path, and false otherwise.
     */
    public boolean tryCreateDirectory()
    {
<span class="nc bnc" id="L384" title="All 4 branches missed.">        return path != null &amp;&amp; PathUtils.tryCreateDirectory(path);</span>
    }

    /**
     * Try to create a directory at this path, creating any parent directories as necessary.
     * @return true if a new directory was created at this path, and false otherwise.
     */
    public boolean tryCreateDirectories()
    {
<span class="pc bpc" id="L393" title="1 of 4 branches missed.">        return path != null &amp;&amp; PathUtils.tryCreateDirectories(path);</span>
    }

    /**
     * @return the parent file, or null if none
     */
    public File parent()
    {
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">        if (path == null) return null;</span>
<span class="fc" id="L402">        Path parent = path.getParent();</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">        if (parent == null) return null;</span>
<span class="fc" id="L404">        return new File(parent);</span>
    }

    /**
     * @return the parent file's path, or null if none
     */
    public String parentPath()
    {
<span class="nc" id="L412">        File parent = parent();</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">        return parent == null ? null : parent.toString();</span>
    }

    /**
     * @return true if the path has no relative path elements
     */
    public boolean isAbsolute()
    {
<span class="pc bpc" id="L421" title="2 of 4 branches missed.">        return path != null &amp;&amp; path.isAbsolute();</span>
    }

    public boolean isAncestorOf(File child)
    {
<span class="nc" id="L426">        return PathUtils.isContained(toPath(), child.toPath());</span>
    }

    /**
     * @return a File that represents the same path as this File with any relative path elements resolved.
     *         If this is the empty File, returns the working directory.
     */
    public File toAbsolute()
    {
<span class="fc" id="L435">        return new File(toPath().toAbsolutePath());</span>
    }

    /** {@link #toAbsolute} */
    public String absolutePath()
    {
<span class="fc" id="L441">        return toPath().toAbsolutePath().toString();</span>
    }

    /**
     * @return a File that represents the same path as this File with any relative path elements and links resolved.
     *         If this is the empty File, returns the working directory.
     */
    public File toCanonical()
    {
<span class="fc" id="L450">        Path canonical = PathUtils.toCanonicalPath(toPath());</span>
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">        return canonical == path ? this : new File(canonical);</span>
    }

    /** {@link #toCanonical} */
    public String canonicalPath()
    {
<span class="fc" id="L457">        return toCanonical().toString();</span>
    }

    /**
     * @return the last path element for this file
     */
    public String name()
    {
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">        return path == null ? &quot;&quot; : filename(path);</span>
    }

    public void forEach(Consumer&lt;File&gt; forEach)
    {
<span class="nc" id="L470">        PathUtils.forEach(path, path -&gt; forEach.accept(new File(path)));</span>
<span class="nc" id="L471">    }</span>

    public void forEachRecursive(Consumer&lt;File&gt; forEach)
    {
<span class="nc" id="L475">        PathUtils.forEachRecursive(path, path -&gt; forEach.accept(new File(path)));</span>
<span class="nc" id="L476">    }</span>

<span class="pc" id="L478">    private static &lt;V&gt; ThrowingFunction&lt;IOException, V, RuntimeException&gt; nulls() { return ignore -&gt; null; }</span>
    private static &lt;V&gt; ThrowingFunction&lt;IOException, V, IOException&gt; rethrow()
    {
<span class="nc" id="L481">        return fail -&gt; {</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">            if (fail == null) throw new FileNotFoundException();</span>
<span class="nc" id="L483">            throw fail;</span>
        };
    }
    private static &lt;V&gt; ThrowingFunction&lt;IOException, V, UncheckedIOException&gt; unchecked()
    {
<span class="fc" id="L488">        return fail -&gt; {</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">            if (fail == null) fail = new FileNotFoundException();</span>
<span class="nc" id="L490">            throw new UncheckedIOException(fail);</span>
        };
    }


    /**
     * @return if a directory, the names of the files within; null otherwise
     */
    public String[] tryListNames()
    {
<span class="nc" id="L500">        return tryListNames(nulls());</span>
    }

    /**
     * @return if a directory, the names of the files within, filtered by the provided predicate; null otherwise
     */
    public String[] tryListNames(BiPredicate&lt;File, String&gt; filter)
    {
<span class="nc" id="L508">        return tryListNames(filter, nulls());</span>
    }

    /**
     * @return if a directory, the files within; null otherwise
     */
    public File[] tryList()
    {
<span class="fc" id="L516">        return tryList(nulls());</span>
    }

    /**
     * @return if a directory, the files within, filtered by the provided predicate; null otherwise
     */
    public File[] tryList(Predicate&lt;File&gt; filter)
    {
<span class="fc" id="L524">        return tryList(filter, nulls());</span>
    }

    /**
     * @return if a directory, the files within, filtered by the provided predicate; null otherwise
     */
    public File[] tryList(BiPredicate&lt;File, String&gt; filter)
    {
<span class="fc" id="L532">        return tryList(filter, nulls());</span>
    }

    /**
     * @return if a directory, the names of the files within; null otherwise
     */
    public String[] listNames() throws IOException
    {
<span class="nc" id="L540">        return tryListNames(rethrow());</span>
    }

    /**
     * @return if a directory, the names of the files within, filtered by the provided predicate; null otherwise
     */
    public String[] listNames(BiPredicate&lt;File, String&gt; filter) throws IOException
    {
<span class="nc" id="L548">        return tryListNames(filter, rethrow());</span>
    }

    /**
     * @return if a directory, the files within; null otherwise
     */
    public File[] list() throws IOException
    {
<span class="nc" id="L556">        return tryList(rethrow());</span>
    }

    /**
     * @return if a directory, the files within, filtered by the provided predicate; null otherwise
     */
    public File[] list(Predicate&lt;File&gt; filter) throws IOException
    {
<span class="nc" id="L564">        return tryList(filter, rethrow());</span>
    }

    /**
     * @return if a directory, the files within, filtered by the provided predicate; null otherwise
     */
    public File[] list(BiPredicate&lt;File, String&gt; filter) throws IOException
    {
<span class="nc" id="L572">        return tryList(filter, rethrow());</span>
    }

    /**
     * @return if a directory, the names of the files within; null otherwise
     */
    public String[] listNamesUnchecked() throws UncheckedIOException
    {
<span class="fc" id="L580">        return tryListNames(unchecked());</span>
    }

    /**
     * @return if a directory, the names of the files within, filtered by the provided predicate; null otherwise
     */
    public String[] listNamesUnchecked(BiPredicate&lt;File, String&gt; filter) throws UncheckedIOException
    {
<span class="nc" id="L588">        return tryListNames(filter, unchecked());</span>
    }

    /**
     * @return if a directory, the files within; null otherwise
     */
    public File[] listUnchecked() throws UncheckedIOException
    {
<span class="nc" id="L596">        return tryList(unchecked());</span>
    }

    /**
     * @return if a directory, the files within, filtered by the provided predicate; null otherwise
     */
    public File[] listUnchecked(Predicate&lt;File&gt; filter) throws UncheckedIOException
    {
<span class="nc" id="L604">        return tryList(filter, unchecked());</span>
    }

    /**
     * @return if a directory, the files within, filtered by the provided predicate; throw an UncheckedIO exception otherwise
     */
    public File[] listUnchecked(BiPredicate&lt;File, String&gt; filter) throws UncheckedIOException
    {
<span class="nc" id="L612">        return tryList(filter, unchecked());</span>
    }

    /**
     * @return if a directory, the names of the files within; null otherwise
     */
    public &lt;T extends Throwable&gt; String[] tryListNames(ThrowingFunction&lt;IOException, String[], T&gt; orElse) throws T
    {
<span class="fc" id="L620">        return tryListNames(path, Function.identity(), orElse);</span>
    }

    /**
     * @return if a directory, the names of the files within, filtered by the provided predicate; null otherwise
     */
    public &lt;T extends Throwable&gt; String[] tryListNames(BiPredicate&lt;File, String&gt; filter, ThrowingFunction&lt;IOException, String[], T&gt; orElse) throws T
    {
<span class="nc" id="L628">        return tryList(path, stream -&gt; stream.map(PathUtils::filename).filter(filename -&gt; filter.test(this, filename)), String[]::new, orElse);</span>
    }

    /**
     * @return if a directory, the files within; null otherwise
     */
    private &lt;T extends Throwable&gt; File[] tryList(ThrowingFunction&lt;IOException, File[], T&gt; orElse) throws T
    {
<span class="fc" id="L636">        return tryList(path, Function.identity(), orElse);</span>
    }

    /**
     * @return if a directory, the files within, filtered by the provided predicate; null otherwise
     */
    private &lt;T extends Throwable&gt; File[] tryList(Predicate&lt;File&gt; filter, ThrowingFunction&lt;IOException, File[], T&gt; orElse) throws T
    {
<span class="fc" id="L644">        return tryList(path, stream -&gt; stream.filter(filter), orElse);</span>
    }

    /**
     * @return if a directory, the files within, filtered by the provided predicate; null otherwise
     */
    private &lt;T extends Throwable&gt; File[] tryList(BiPredicate&lt;File, String&gt; filter, ThrowingFunction&lt;IOException, File[], T&gt; orElse) throws T
    {
<span class="fc" id="L652">        return tryList(path, stream -&gt; stream.filter(file -&gt; filter.test(this, file.name())), orElse);</span>
    }

    private static &lt;T extends Throwable&gt; String[] tryListNames(Path path, Function&lt;Stream&lt;File&gt;, Stream&lt;File&gt;&gt; toFiles, ThrowingFunction&lt;IOException, String[], T&gt; orElse) throws T
    {
<span class="pc bpc" id="L657" title="1 of 2 branches missed.">        if (path == null)</span>
<span class="nc" id="L658">            return orElse.apply(null);</span>
<span class="fc" id="L659">        return PathUtils.tryList(path, stream -&gt; toFiles.apply(stream.map(File::new)).map(File::name), String[]::new, orElse);</span>
    }

    private static &lt;T extends Throwable, V&gt; V[] tryList(Path path, Function&lt;Stream&lt;Path&gt;, Stream&lt;V&gt;&gt; transformation, IntFunction&lt;V[]&gt; constructor, ThrowingFunction&lt;IOException, V[], T&gt; orElse) throws T
    {
<span class="nc bnc" id="L664" title="All 2 branches missed.">        if (path == null)</span>
<span class="nc" id="L665">            return orElse.apply(null);</span>
<span class="nc" id="L666">        return PathUtils.tryList(path, transformation, constructor, orElse);</span>
    }

    private static &lt;T extends Throwable&gt; File[] tryList(Path path, Function&lt;Stream&lt;File&gt;, Stream&lt;File&gt;&gt; toFiles, ThrowingFunction&lt;IOException, File[], T&gt; orElse) throws T
    {
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">        if (path == null)</span>
<span class="nc" id="L672">            return orElse.apply(null);</span>
<span class="fc" id="L673">        return PathUtils.tryList(path, stream -&gt; toFiles.apply(stream.map(File::new)), File[]::new, orElse);</span>
    }

    /**
     * @return the path of this file
     */
    public String path()
    {
<span class="fc" id="L681">        return toString();</span>
    }

    /**
     * @return the {@link Path} of this file
     */
    public Path toPath()
    {
<span class="pc bpc" id="L689" title="1 of 2 branches missed.">        return path == null ? filesystem.getPath(&quot;&quot;) : path;</span>
    }

    /**
     * @return the path of this file
     */
    @Override
    public String toString()
    {
<span class="pc bpc" id="L698" title="1 of 2 branches missed.">        return path == null ? &quot;&quot; : path.toString();</span>
    }

    @Override
    public int hashCode()
    {
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">        return path == null ? 0 : path.hashCode();</span>
    }

    @Override
    public boolean equals(Object obj)
    {
<span class="pc bpc" id="L710" title="1 of 4 branches missed.">        return obj instanceof File &amp;&amp; Objects.equals(path, ((File) obj).path);</span>
    }

    @Override
    public int compareTo(File that)
    {
<span class="pc bpc" id="L716" title="2 of 4 branches missed.">        if (this.path == null || that.path == null)</span>
<span class="nc bnc" id="L717" title="All 6 branches missed.">            return this.path == null &amp;&amp; that.path == null ? 0 : this.path == null ? -1 : 1;</span>
<span class="fc" id="L718">        return this.path.compareTo(that.path);</span>
    }

    public java.io.File toJavaIOFile()
    {
<span class="nc bnc" id="L723" title="All 2 branches missed.">        return path == null ? new java.io.File(&quot;&quot;) // checkstyle: permit this instantiation</span>
<span class="nc" id="L724">                            : path.toFile(); // checkstyle: permit this invocation</span>
    }

    /**
     * @return a new {@link FileChannel} for reading
     */
    public FileChannel newReadChannel() throws NoSuchFileException
    {
<span class="fc" id="L732">        return PathUtils.newReadChannel(toPathForRead());</span>
    }

    /**
     * @return a new {@link FileChannel} for reading or writing; file will be created if it doesn't exist
     */
    public FileChannel newReadWriteChannel() throws NoSuchFileException
    {
<span class="fc" id="L740">        return PathUtils.newReadWriteChannel(toPathForRead());</span>
    }

    /**
     * @param mode whether or not the channel appends to the underlying file
     * @return a new {@link FileChannel} for writing; file will be created if it doesn't exist
     */
    public FileChannel newWriteChannel(WriteMode mode) throws NoSuchFileException
    {
<span class="pc bpc" id="L749" title="1 of 3 branches missed.">        switch (mode)</span>
        {
<span class="nc" id="L751">            default: throw new AssertionError();</span>
<span class="fc" id="L752">            case APPEND: return PathUtils.newWriteAppendChannel(toPathForWrite());</span>
<span class="fc" id="L753">            case OVERWRITE: return PathUtils.newWriteOverwriteChannel(toPathForWrite());</span>
        }
    }

    public FileWriter newWriter(WriteMode mode) throws IOException
    {
<span class="fc" id="L759">        return new FileWriter(this, mode);</span>
    }

    public FileOutputStreamPlus newOutputStream(WriteMode mode) throws NoSuchFileException
    {
<span class="fc" id="L764">        return new FileOutputStreamPlus(this, mode);</span>
    }

    public FileInputStreamPlus newInputStream() throws NoSuchFileException
    {
<span class="fc" id="L769">        return new FileInputStreamPlus(this);</span>
    }

    public File withSuffix(String suffix)
    {
<span class="pc bpc" id="L774" title="1 of 2 branches missed.">        if (path == null)</span>
<span class="nc" id="L775">            throw new IllegalStateException(&quot;Cannot suffix an empty path&quot;);</span>
<span class="fc" id="L776">        return new File(path.getParent().resolve(path.getFileName().toString() + suffix));</span>
    }

    private Path toPathForWrite()
    {
<span class="pc bpc" id="L781" title="1 of 2 branches missed.">        if (path == null)</span>
<span class="nc" id="L782">            throw new IllegalStateException(&quot;Cannot write to an empty path&quot;);</span>
<span class="fc" id="L783">        return path;</span>
    }

    private Path toPathForRead()
    {
<span class="pc bpc" id="L788" title="1 of 2 branches missed.">        if (path == null)</span>
<span class="nc" id="L789">            throw new IllegalStateException(&quot;Cannot read from an empty path&quot;);</span>
<span class="fc" id="L790">        return path;</span>
    }

    @VisibleForTesting
    public static FileSystem unsafeGetFilesystem()
    {
<span class="nc" id="L796">        return filesystem;</span>
    }

    public static void unsafeSetFilesystem(FileSystem fs)
    {
<span class="nc" id="L801">        filesystem = fs;</span>
<span class="nc" id="L802">    }</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>