<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Guardrail.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.guardrails</a> &gt; <span class="el_source">Guardrail.java</span></div><h1>Guardrail.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.db.guardrails;

import java.util.concurrent.TimeUnit;
import javax.annotation.Nullable;

import com.google.common.annotations.VisibleForTesting;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.service.ClientState;
import org.apache.cassandra.service.ClientWarn;
import org.apache.cassandra.tracing.Tracing;
import org.apache.cassandra.utils.Clock;
import org.apache.cassandra.utils.NoSpamLogger;

/**
 * General class defining a given guardrail that guards against some particular usage/condition.
 * &lt;p&gt;
 * Some guardrails only emit warnings when triggered, while others abort the query that triggers them. Some may do one
 * or the other based on specific threshold. The queries are aborted with an {@link InvalidRequestException}.
 * &lt;p&gt;
 * Note that all the defined classes support live updates, which is why each guardrail class constructor takes
 * suppliers of the condition the guardrail acts on rather than the condition itself. This implies that said suppliers
 * should be fast and non-blocking to avoid surprises.
 */
public abstract class Guardrail
{
<span class="fc" id="L47">    protected static final NoSpamLogger logger = NoSpamLogger.getLogger(LoggerFactory.getLogger(Guardrail.class),</span>
                                                                        10, TimeUnit.MINUTES);
    protected static final String REDACTED = &quot;&lt;redacted&gt;&quot;;

    /** A name identifying the guardrail (mainly for shipping with diagnostic events). */
    public final String name;

    /** An optional description of the reason for guarding the operation. */
    @Nullable
    public final String reason;

    /** Minimum logging and triggering interval to avoid spamming downstream. */
<span class="fc" id="L59">    private long minNotifyIntervalInMs = 0;</span>

    /** Time of last warning in milliseconds. */
<span class="fc" id="L62">    private volatile long lastWarnInMs = 0;</span>

    /** Time of last failure in milliseconds. */
<span class="fc" id="L65">    private volatile long lastFailInMs = 0;</span>

    /** Should throw exception if null client state is provided. */
<span class="fc" id="L68">    private volatile boolean throwOnNullClientState = false;</span>

    Guardrail(String name, @Nullable String reason)
<span class="fc" id="L71">    {</span>
<span class="fc" id="L72">        this.name = name;</span>
<span class="fc" id="L73">        this.reason = reason;</span>
<span class="fc" id="L74">    }</span>

    /**
     * Checks whether this guardrail is enabled or not when the check is done for a background opperation that is not
     * associated to a specific {@link ClientState}, such as compaction or other background processes. Operations that
     * are associated to a {@link ClientState}, such as CQL queries, should use {@link Guardrail#enabled(ClientState)}.
     *
     * @return {@code true} if this guardrail is enabled, {@code false} otherwise.
     */
    public boolean enabled()
    {
<span class="fc" id="L85">        return enabled(null);</span>
    }

    /**
     * Checks whether this guardrail is enabled or not. This will be enabled if the database is initialized and the
     * authenticated user (if specified) is not system nor superuser.
     *
     * @param state the client state, used to skip the check if the query is internal or is done by a superuser.
     *              A {@code null} value means that the check should be done regardless of the query.
     * @return {@code true} if this guardrail is enabled, {@code false} otherwise.
     */
    public boolean enabled(@Nullable ClientState state)
    {
<span class="pc bpc" id="L98" title="2 of 6 branches missed.">        return DatabaseDescriptor.isDaemonInitialized() &amp;&amp; (state == null || state.isOrdinaryUser());</span>
    }

    protected void warn(String message)
    {
<span class="nc" id="L103">        warn(message, message);</span>
<span class="nc" id="L104">    }</span>

    protected void warn(String message, String redactedMessage)
    {
<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (skipNotifying(true))</span>
<span class="nc" id="L109">            return;</span>

<span class="nc" id="L111">        message = decorateMessage(message);</span>

<span class="nc" id="L113">        logger.warn(message);</span>
        // Note that ClientWarn will simply ignore the message if we're not running this as part of a user query
        // (the internal &quot;state&quot; will be null)
<span class="nc" id="L116">        ClientWarn.instance.warn(message);</span>
        // Similarly, tracing will also ignore the message if we're not running tracing on the current thread.
<span class="nc" id="L118">        Tracing.trace(message);</span>
<span class="nc" id="L119">        GuardrailsDiagnostics.warned(name, decorateMessage(redactedMessage));</span>
<span class="nc" id="L120">    }</span>

    protected void fail(String message, @Nullable ClientState state)
    {
<span class="nc" id="L124">        fail(message, message, state);</span>
<span class="nc" id="L125">    }</span>

    protected void fail(String message, String redactedMessage, @Nullable ClientState state)
    {
<span class="nc" id="L129">        message = decorateMessage(message);</span>

<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (!skipNotifying(false))</span>
        {
<span class="nc" id="L133">            logger.error(message);</span>
            // Note that ClientWarn will simply ignore the message if we're not running this as part of a user query
            // (the internal &quot;state&quot; will be null)
<span class="nc" id="L136">            ClientWarn.instance.warn(message);</span>
            // Similarly, tracing will also ignore the message if we're not running tracing on the current thread.
<span class="nc" id="L138">            Tracing.trace(message);</span>
<span class="nc" id="L139">            GuardrailsDiagnostics.failed(name, decorateMessage(redactedMessage));</span>
        }

<span class="nc bnc" id="L142" title="All 4 branches missed.">        if (state != null || throwOnNullClientState)</span>
<span class="nc" id="L143">            throw new GuardrailViolatedException(message);</span>
<span class="nc" id="L144">    }</span>

    @VisibleForTesting
    String decorateMessage(String message)
    {
        // Add a prefix to error message so user knows what threw the warning or cause the failure.
<span class="nc" id="L150">        String decoratedMessage = String.format(&quot;Guardrail %s violated: %s&quot;, name, message);</span>

        // Add the reason for the guardrail triggering, if there is any.
<span class="nc bnc" id="L153" title="All 2 branches missed.">        if (reason != null)</span>
        {
<span class="nc bnc" id="L155" title="All 2 branches missed.">            decoratedMessage += (message.endsWith(&quot;.&quot;) ? ' ' : &quot;. &quot;) + reason;</span>
        }

<span class="nc" id="L158">        return decoratedMessage;</span>
    }

    /**
     * Note: this method is not thread safe and should only be used during guardrail initialization
     *
     * @param minNotifyIntervalInMs frequency of logging and triggering listener to avoid spamming,
     *                              default 0 means always log and trigger listeners.
     * @return current guardrail
     */
    Guardrail minNotifyIntervalInMs(long minNotifyIntervalInMs)
    {
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        assert minNotifyIntervalInMs &gt;= 0;</span>
<span class="fc" id="L171">        this.minNotifyIntervalInMs = minNotifyIntervalInMs;</span>
<span class="fc" id="L172">        return this;</span>
    }

    /**
     * Note: this method is not thread safe and should only be used during guardrail initialization
     *
     * @param shouldThrow if exception should throw when Guardrail is violated,
     *                    default false means don't throw expection when client state is not provided.
     * @return current guardrail
     */
    Guardrail throwOnNullClientState(boolean shouldThrow)
    {
<span class="fc" id="L184">        this.throwOnNullClientState = shouldThrow;</span>
<span class="fc" id="L185">        return this;</span>
    }

    /**
     * reset last notify time to make sure it will notify downstream when {@link this#warn(String, String)}
     * or {@link this#fail(String, ClientState)} is called next time.
     */
    @VisibleForTesting
    void resetLastNotifyTime()
    {
<span class="nc" id="L195">        lastFailInMs = 0;</span>
<span class="nc" id="L196">        lastWarnInMs = 0;</span>
<span class="nc" id="L197">    }</span>

    /**
     * @return true if guardrail should not log message and trigger listeners; otherwise, update lastWarnInMs or
     * lastFailInMs respectively.
     */
    private boolean skipNotifying(boolean isWarn)
    {
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (minNotifyIntervalInMs == 0)</span>
<span class="nc" id="L206">            return false;</span>

<span class="nc" id="L208">        long nowInMs = Clock.Global.currentTimeMillis();</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">        long timeElapsedInMs = nowInMs - (isWarn ? lastWarnInMs : lastFailInMs);</span>

<span class="nc bnc" id="L211" title="All 2 branches missed.">        boolean skip = timeElapsedInMs &lt; minNotifyIntervalInMs;</span>

<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (!skip)</span>
        {
<span class="nc bnc" id="L215" title="All 2 branches missed.">            if (isWarn)</span>
<span class="nc" id="L216">                lastWarnInMs = nowInMs;</span>
            else
<span class="nc" id="L218">                lastFailInMs = nowInMs;</span>
        }

<span class="nc" id="L221">        return skip;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>