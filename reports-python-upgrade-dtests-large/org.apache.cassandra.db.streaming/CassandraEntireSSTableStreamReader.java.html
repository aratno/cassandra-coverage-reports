<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CassandraEntireSSTableStreamReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.streaming</a> &gt; <span class="el_source">CassandraEntireSSTableStreamReader.java</span></div><h1>CassandraEntireSSTableStreamReader.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.db.streaming;

import java.io.IOException;
import java.util.Collection;
import java.util.function.UnaryOperator;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.Directories;
import org.apache.cassandra.db.lifecycle.LifecycleNewTracker;
import org.apache.cassandra.io.compress.BufferType;
import org.apache.cassandra.io.sstable.Component;
import org.apache.cassandra.io.sstable.Descriptor;
import org.apache.cassandra.io.sstable.IOOptions;
import org.apache.cassandra.io.sstable.SSTableMultiWriter;
import org.apache.cassandra.io.sstable.SSTableZeroCopyWriter;
import org.apache.cassandra.io.sstable.metadata.StatsMetadata;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.io.util.SequentialWriterOption;
import org.apache.cassandra.schema.TableId;
import org.apache.cassandra.streaming.ProgressInfo;
import org.apache.cassandra.streaming.StreamReceiver;
import org.apache.cassandra.streaming.StreamSession;
import org.apache.cassandra.streaming.messages.StreamMessageHeader;

import static java.lang.String.format;
import static org.apache.cassandra.utils.FBUtilities.prettyPrintMemory;

/**
 * CassandraEntireSSTableStreamReader reads SSTable off the wire and writes it to disk.
 */
public class CassandraEntireSSTableStreamReader implements IStreamReader
{
<span class="nc" id="L56">    private static final Logger logger = LoggerFactory.getLogger(CassandraEntireSSTableStreamReader.class);</span>

    private final TableId tableId;
    private final StreamSession session;
    private final StreamMessageHeader messageHeader;
    private final CassandraStreamHeader header;
    private final int fileSequenceNumber;

    public CassandraEntireSSTableStreamReader(StreamMessageHeader messageHeader, CassandraStreamHeader streamHeader, StreamSession session)
<span class="nc" id="L65">    {</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">        if (session.getPendingRepair() != null)</span>
        {
            // we should only ever be streaming pending repair sstables if the session has a pending repair id
<span class="nc bnc" id="L69" title="All 2 branches missed.">            if (!session.getPendingRepair().equals(messageHeader.pendingRepair))</span>
<span class="nc" id="L70">                throw new IllegalStateException(format(&quot;Stream Session &amp; SSTable (%s) pendingRepair UUID mismatch.&quot;, messageHeader.tableId));</span>
        }

<span class="nc" id="L73">        this.header = streamHeader;</span>
<span class="nc" id="L74">        this.session = session;</span>
<span class="nc" id="L75">        this.messageHeader = messageHeader;</span>
<span class="nc" id="L76">        this.tableId = messageHeader.tableId;</span>
<span class="nc" id="L77">        this.fileSequenceNumber = messageHeader.sequenceNumber;</span>
<span class="nc" id="L78">    }</span>

    /**
     * @param in where this reads data from
     * @return SSTable transferred
     * @throws IOException if reading the remote sstable fails. Will throw an RTE if local write fails.
     */
    @SuppressWarnings(&quot;resource&quot;) // input needs to remain open, streams on top of it can't be closed
    @Override
    public SSTableMultiWriter read(DataInputPlus in) throws IOException
    {
<span class="nc" id="L89">        ColumnFamilyStore cfs = ColumnFamilyStore.getIfExists(tableId);</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">        if (cfs == null)</span>
        {
            // schema was dropped during streaming
<span class="nc" id="L93">            throw new IOException(&quot;Table &quot; + tableId + &quot; was dropped during streaming&quot;);</span>
        }

<span class="nc" id="L96">        ComponentManifest manifest = header.componentManifest;</span>
<span class="nc" id="L97">        long totalSize = manifest.totalSize();</span>

<span class="nc" id="L99">        logger.debug(&quot;[Stream #{}] Started receiving sstable #{} from {}, size = {}, table = {}&quot;,</span>
<span class="nc" id="L100">                     session.planId(),</span>
<span class="nc" id="L101">                     fileSequenceNumber,</span>
                     session.peer,
<span class="nc" id="L103">                     prettyPrintMemory(totalSize),</span>
<span class="nc" id="L104">                     cfs.metadata());</span>

<span class="nc" id="L106">        SSTableZeroCopyWriter writer = null;</span>

        try
        {
<span class="nc" id="L110">            writer = createWriter(cfs, totalSize, manifest.components());</span>
<span class="nc" id="L111">            long bytesRead = 0;</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">            for (Component component : manifest.components())</span>
            {
<span class="nc" id="L114">                long length = manifest.sizeOf(component);</span>

<span class="nc" id="L116">                logger.debug(&quot;[Stream #{}] Started receiving {} component from {}, componentSize = {}, readBytes = {}, totalSize = {}&quot;,</span>
<span class="nc" id="L117">                             session.planId(),</span>
                             component,
                             session.peer,
<span class="nc" id="L120">                             prettyPrintMemory(length),</span>
<span class="nc" id="L121">                             prettyPrintMemory(bytesRead),</span>
<span class="nc" id="L122">                             prettyPrintMemory(totalSize));</span>

<span class="nc" id="L124">                writer.writeComponent(component, in, length);</span>
<span class="nc" id="L125">                session.progress(writer.descriptor.fileFor(component).toString(), ProgressInfo.Direction.IN, length, length, length);</span>
<span class="nc" id="L126">                bytesRead += length;</span>

<span class="nc" id="L128">                logger.debug(&quot;[Stream #{}] Finished receiving {} component from {}, componentSize = {}, readBytes = {}, totalSize = {}&quot;,</span>
<span class="nc" id="L129">                             session.planId(),</span>
                             component,
                             session.peer,
<span class="nc" id="L132">                             prettyPrintMemory(length),</span>
<span class="nc" id="L133">                             prettyPrintMemory(bytesRead),</span>
<span class="nc" id="L134">                             prettyPrintMemory(totalSize));</span>
<span class="nc" id="L135">            }</span>

<span class="nc" id="L137">            UnaryOperator&lt;StatsMetadata&gt; transform = stats -&gt; stats.mutateLevel(header.sstableLevel)</span>
<span class="nc" id="L138">                                                                   .mutateRepairedMetadata(messageHeader.repairedAt, messageHeader.pendingRepair, false);</span>
<span class="nc" id="L139">            String description = String.format(&quot;level %s and repairedAt time %s and pendingRepair %s&quot;,</span>
<span class="nc" id="L140">                                               header.sstableLevel, messageHeader.repairedAt, messageHeader.pendingRepair);</span>
<span class="nc" id="L141">            writer.descriptor.getMetadataSerializer().mutate(writer.descriptor, description, transform);</span>
<span class="nc" id="L142">            return writer;</span>
        }
<span class="nc" id="L144">        catch (Throwable e)</span>
        {
<span class="nc" id="L146">            logger.error(&quot;[Stream {}] Error while reading sstable from stream for table = {}&quot;, session.planId(), cfs.metadata(), e);</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">            if (writer != null)</span>
            {
<span class="nc" id="L149">                Throwable e2 = writer.abort(null);</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">                if (e2 != null)</span>
<span class="nc" id="L151">                    e.addSuppressed(e2);</span>
            }
<span class="nc" id="L153">            throw e;</span>
        }
    }

    private File getDataDir(ColumnFamilyStore cfs, long totalSize) throws IOException
    {
<span class="nc" id="L159">        Directories.DataDirectory localDir = cfs.getDirectories().getWriteableLocation(totalSize);</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (localDir == null)</span>
<span class="nc" id="L161">            throw new IOException(format(&quot;Insufficient disk space to store %s&quot;, prettyPrintMemory(totalSize)));</span>

<span class="nc" id="L163">        File dir = cfs.getDirectories().getLocationForDisk(cfs.getDiskBoundaries().getCorrectDiskForKey(header.firstKey));</span>

<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (dir == null)</span>
<span class="nc" id="L166">            return cfs.getDirectories().getDirectoryForNewSSTables();</span>

<span class="nc" id="L168">        return dir;</span>
    }

    @SuppressWarnings(&quot;resource&quot;)
    protected SSTableZeroCopyWriter createWriter(ColumnFamilyStore cfs, long totalSize, Collection&lt;Component&gt; components) throws IOException
    {
<span class="nc" id="L174">        File dataDir = getDataDir(cfs, totalSize);</span>

<span class="nc" id="L176">        StreamReceiver streamReceiver = session.getAggregator(tableId);</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">        assert streamReceiver instanceof CassandraStreamReceiver;</span>

<span class="nc" id="L179">        LifecycleNewTracker lifecycleNewTracker = CassandraStreamReceiver.fromReceiver(session.getAggregator(tableId)).createLifecycleNewTracker();</span>

<span class="nc" id="L181">        Descriptor desc = cfs.newSSTableDescriptor(dataDir, header.version);</span>

<span class="nc" id="L183">        IOOptions ioOptions = new IOOptions(DatabaseDescriptor.getDiskOptimizationStrategy(),</span>
<span class="nc" id="L184">                                            DatabaseDescriptor.getDiskAccessMode(),</span>
<span class="nc" id="L185">                                            DatabaseDescriptor.getIndexAccessMode(),</span>
<span class="nc" id="L186">                                            DatabaseDescriptor.getDiskOptimizationEstimatePercentile(),</span>
<span class="nc" id="L187">                                            SequentialWriterOption.newBuilder()</span>
<span class="nc" id="L188">                                                                  .trickleFsync(false)</span>
<span class="nc" id="L189">                                                                  .bufferSize(2 &lt;&lt; 20)</span>
<span class="nc" id="L190">                                                                  .bufferType(BufferType.OFF_HEAP)</span>
<span class="nc" id="L191">                                                                  .build(),</span>
<span class="nc" id="L192">                                            DatabaseDescriptor.getFlushCompression());</span>

<span class="nc" id="L194">        logger.debug(&quot;[Table #{}] {} Components to write: {}&quot;, cfs.metadata(), desc, components);</span>
<span class="nc" id="L195">        return desc.getFormat()</span>
<span class="nc" id="L196">                   .getWriterFactory()</span>
<span class="nc" id="L197">                   .builder(desc)</span>
<span class="nc" id="L198">                   .setComponents(components)</span>
<span class="nc" id="L199">                   .setTableMetadataRef(cfs.metadata)</span>
<span class="nc" id="L200">                   .setIOOptions(ioOptions)</span>
<span class="nc" id="L201">                   .createZeroCopyWriter(lifecycleNewTracker, cfs);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>