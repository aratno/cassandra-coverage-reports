<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IncrementalDeepTrieWriterPageAware.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.io.tries</a> &gt; <span class="el_source">IncrementalDeepTrieWriterPageAware.java</span></div><h1>IncrementalDeepTrieWriterPageAware.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.io.tries;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import javax.annotation.concurrent.NotThreadSafe;

import org.apache.cassandra.io.util.DataOutputPlus;

/**
 * This class is a variant of {@link IncrementalTrieWriterPageAware} which is able to build even very deep
 * tries. While the parent class uses recursion for clarity, it may end up with stack overflow for tries with
 * very long keys. This implementation can switch processing from stack to heap at a certain depth (provided
 * as a constructor param).
 * &lt;p&gt;
 * This class intentionally repeats code present in the parent class, both in the in-stack and on-heap versions
 * of each of the three implemented recursive operations. Removing this repetition can cause higher stack usage
 * and thus stack overflow failures.
 */
<span class="fc" id="L40">@NotThreadSafe</span>
public class IncrementalDeepTrieWriterPageAware&lt;VALUE&gt; extends IncrementalTrieWriterPageAware&lt;VALUE&gt;
{
    private final int maxRecursionDepth;

    public IncrementalDeepTrieWriterPageAware(TrieSerializer&lt;VALUE, ? super DataOutputPlus&gt; trieSerializer, DataOutputPlus dest, int maxRecursionDepth)
    {
<span class="fc" id="L47">        super(trieSerializer, dest);</span>
<span class="fc" id="L48">        this.maxRecursionDepth = maxRecursionDepth;</span>
<span class="fc" id="L49">    }</span>

    public IncrementalDeepTrieWriterPageAware(TrieSerializer&lt;VALUE, ? super DataOutputPlus&gt; trieSerializer, DataOutputPlus dest)
    {
<span class="fc" id="L53">        this(trieSerializer, dest, 64);</span>
<span class="fc" id="L54">    }</span>

    /**
     * Simple framework for executing recursion using on-heap linked trace to avoid stack overruns.
     */
    static abstract class Recursion&lt;NODE&gt;
    {
        final Recursion&lt;NODE&gt; parent;
        final NODE node;
        final Iterator&lt;NODE&gt; childIterator;

        Recursion(NODE node, Iterator&lt;NODE&gt; childIterator, Recursion&lt;NODE&gt; parent)
<span class="fc" id="L66">        {</span>
<span class="fc" id="L67">            this.parent = parent;</span>
<span class="fc" id="L68">            this.node = node;</span>
<span class="fc" id="L69">            this.childIterator = childIterator;</span>
<span class="fc" id="L70">        }</span>

        /**
         * Make a child Recursion object for the given node and initialize it as necessary to continue processing
         * with it.
         * &lt;p&gt;
         * May return null if the recursion does not need to continue inside the child branch.
         */
        abstract Recursion&lt;NODE&gt; makeChild(NODE child);

        /**
         * Complete the processing this Recursion object.
         * &lt;p&gt;
         * Note: this method is not called for the nodes for which makeChild() returns null.
         */
        abstract void complete() throws IOException;

        /**
         * Complete processing of the given child (possibly retrieve data to apply to any accumulation performed
         * in this Recursion object).
         * &lt;p&gt;
         * This is called when processing a child completes, including when recursion inside the child branch
         * is skipped by makeChild() returning null.
         */
        void completeChild(NODE child)
<span class="fc" id="L95">        {}</span>

        /**
         * Recursive process, in depth-first order, the branch rooted at this recursion node.
         * &lt;p&gt;
         * Returns this.
         */
        Recursion&lt;NODE&gt; process() throws IOException
        {
<span class="fc" id="L104">            Recursion&lt;NODE&gt; curr = this;</span>

            while (true)
            {
<span class="fc bfc" id="L108" title="All 2 branches covered.">                if (curr.childIterator.hasNext())</span>
                {
<span class="fc" id="L110">                    NODE child = curr.childIterator.next();</span>
<span class="fc" id="L111">                    Recursion&lt;NODE&gt; childRec = curr.makeChild(child);</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">                    if (childRec != null)</span>
<span class="fc" id="L113">                        curr = childRec;</span>
                    else
<span class="fc" id="L115">                        curr.completeChild(child);</span>
<span class="fc" id="L116">                }</span>
                else
                {
<span class="fc" id="L119">                    curr.complete();</span>
<span class="fc" id="L120">                    Recursion&lt;NODE&gt; currParent = curr.parent;</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">                    if (currParent == null)</span>
<span class="fc" id="L122">                        return curr;</span>
<span class="fc" id="L123">                    currParent.completeChild(curr.node);</span>
<span class="fc" id="L124">                    curr = currParent;</span>
<span class="fc" id="L125">                }</span>
            }
        }
    }

    @Override
    protected int recalcTotalSize(Node&lt;VALUE&gt; node, long nodePosition) throws IOException
    {
<span class="fc" id="L133">        return recalcTotalSizeRecursiveOnStack(node, nodePosition, 0);</span>
    }

    @SuppressWarnings(&quot;DuplicatedCode&quot;) // intentionally duplicates IncrementalTrieWriterPageAware
    private int recalcTotalSizeRecursiveOnStack(Node&lt;VALUE&gt; node, long nodePosition, int depth) throws IOException
    {
<span class="fc bfc" id="L139" title="All 2 branches covered.">        if (node.hasOutOfPageInBranch)</span>
        {
<span class="fc" id="L141">            int sz = 0;</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">            for (Node&lt;VALUE&gt; child : node.children)</span>
            {
<span class="fc bfc" id="L144" title="All 2 branches covered.">                if (depth &lt; maxRecursionDepth)</span>
<span class="fc" id="L145">                    sz += recalcTotalSizeRecursiveOnStack(child, nodePosition + sz, depth + 1);</span>
                else
<span class="fc" id="L147">                    sz += recalcTotalSizeRecursiveOnHeap(child, nodePosition + sz);</span>
<span class="fc" id="L148">            }</span>
<span class="fc" id="L149">            node.branchSize = sz;</span>
        }

        // The sizing below will use the branch size calculated above. Since that can change on out-of-page in branch,
        // we need to recalculate the size if either flag is set.
<span class="fc bfc" id="L154" title="All 4 branches covered.">        if (node.hasOutOfPageChildren || node.hasOutOfPageInBranch)</span>
<span class="fc" id="L155">            node.nodeSize = serializer.sizeofNode(node, nodePosition + node.branchSize);</span>

<span class="fc" id="L157">        return node.branchSize + node.nodeSize;</span>
    }

    private int recalcTotalSizeRecursiveOnHeap(Node&lt;VALUE&gt; node, long nodePosition) throws IOException
    {
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (node.hasOutOfPageInBranch)</span>
<span class="fc" id="L163">            new RecalcTotalSizeRecursion(node, null, nodePosition).process();</span>

<span class="fc bfc" id="L165" title="All 4 branches covered.">        if (node.hasOutOfPageChildren || node.hasOutOfPageInBranch)</span>
<span class="fc" id="L166">            node.nodeSize = serializer.sizeofNode(node, nodePosition + node.branchSize);</span>

<span class="fc" id="L168">        return node.branchSize + node.nodeSize;</span>
    }

    class RecalcTotalSizeRecursion extends Recursion&lt;Node&lt;VALUE&gt;&gt;
    {
        final long nodePosition;
        int sz;

        RecalcTotalSizeRecursion(Node&lt;VALUE&gt; node, Recursion&lt;Node&lt;VALUE&gt;&gt; parent, long nodePosition)
<span class="fc" id="L177">        {</span>
<span class="fc" id="L178">            super(node, node.children.iterator(), parent);</span>
<span class="fc" id="L179">            sz = 0;</span>
<span class="fc" id="L180">            this.nodePosition = nodePosition;</span>
<span class="fc" id="L181">        }</span>

        @Override
        Recursion&lt;Node&lt;VALUE&gt;&gt; makeChild(Node&lt;VALUE&gt; child)
        {
<span class="fc bfc" id="L186" title="All 2 branches covered.">            if (child.hasOutOfPageInBranch)</span>
<span class="fc" id="L187">                return new RecalcTotalSizeRecursion(child, this, nodePosition + sz);</span>
            else
<span class="fc" id="L189">                return null;</span>
        }

        @Override
        void complete()
        {
<span class="fc" id="L195">            node.branchSize = sz;</span>
<span class="fc" id="L196">        }</span>

        @SuppressWarnings(&quot;DuplicatedCode&quot;) // intentionally duplicates IncrementalTrieWriterPageAware and onStack code
        @Override
        void completeChild(Node&lt;VALUE&gt; child)
        {
            // This will be called for nodes that were recursively processed as well as the ones that weren't.

            // The sizing below will use the branch size calculated above. Since that can change on out-of-page in branch,
            // we need to recalculate the size if either flag is set.
<span class="fc bfc" id="L206" title="All 4 branches covered.">            if (child.hasOutOfPageChildren || child.hasOutOfPageInBranch)</span>
            {
<span class="fc" id="L208">                long childPosition = this.nodePosition + sz;</span>
<span class="fc" id="L209">                child.nodeSize = serializer.sizeofNode(child, childPosition + child.branchSize);</span>
            }

<span class="fc" id="L212">            sz += child.branchSize + child.nodeSize;</span>
<span class="fc" id="L213">        }</span>
    }

    @Override
    protected long write(Node&lt;VALUE&gt; node) throws IOException
    {
<span class="fc" id="L219">        return writeRecursiveOnStack(node, 0);</span>
    }

    @SuppressWarnings(&quot;DuplicatedCode&quot;) // intentionally duplicates IncrementalTrieWriterPageAware
    private long writeRecursiveOnStack(Node&lt;VALUE&gt; node, int depth) throws IOException
    {
<span class="fc" id="L225">        long nodePosition = dest.position();</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">        for (Node&lt;VALUE&gt; child : node.children)</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">            if (child.filePos == -1)</span>
            {
<span class="fc bfc" id="L229" title="All 2 branches covered.">                if (depth &lt; maxRecursionDepth)</span>
<span class="fc" id="L230">                    child.filePos = writeRecursiveOnStack(child, depth + 1);</span>
                else
<span class="fc" id="L232">                    child.filePos = writeRecursiveOnHeap(child);</span>
            }

<span class="fc" id="L235">        nodePosition += node.branchSize;</span>
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">        assert dest.position() == nodePosition</span>
<span class="nc" id="L237">        : &quot;Expected node position to be &quot; + nodePosition + &quot; but got &quot; + dest.position() + &quot; after writing children.\n&quot; + dumpNode(node, dest.position());</span>

<span class="fc" id="L239">        serializer.write(dest, node, nodePosition);</span>

<span class="pc bfc" id="L241" title="All 2 branches covered.">        assert dest.position() == nodePosition + node.nodeSize</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">               || dest.paddedPosition() == dest.position() // For PartitionIndexTest.testPointerGrowth where position may jump on page boundaries.</span>
<span class="nc" id="L243">        : &quot;Expected node position to be &quot; + (nodePosition + node.nodeSize) + &quot; but got &quot; + dest.position() + &quot; after writing node, nodeSize &quot; + node.nodeSize + &quot;.\n&quot; + dumpNode(node, nodePosition);</span>
<span class="fc" id="L244">        return nodePosition;</span>
    }

    private long writeRecursiveOnHeap(Node&lt;VALUE&gt; node) throws IOException
    {
<span class="fc" id="L249">        return new WriteRecursion(node, null).process().node.filePos;</span>
    }

<span class="fc" id="L252">    class WriteRecursion extends Recursion&lt;Node&lt;VALUE&gt;&gt;</span>
    {
        long nodePosition;

        WriteRecursion(Node&lt;VALUE&gt; node, Recursion&lt;Node&lt;VALUE&gt;&gt; parent)
<span class="fc" id="L257">        {</span>
<span class="fc" id="L258">            super(node, node.children.iterator(), parent);</span>
<span class="fc" id="L259">            nodePosition = dest.position();</span>
<span class="fc" id="L260">        }</span>

        @Override
        Recursion&lt;Node&lt;VALUE&gt;&gt; makeChild(Node&lt;VALUE&gt; child)
        {
<span class="fc bfc" id="L265" title="All 2 branches covered.">            if (child.filePos == -1)</span>
<span class="fc" id="L266">                return new WriteRecursion(child, this);</span>
            else
<span class="fc" id="L268">                return null;</span>
        }

        @SuppressWarnings(&quot;DuplicatedCode&quot;) // intentionally duplicates IncrementalTrieWriterPageAware and onStack code
        @Override
        void complete() throws IOException
        {
<span class="fc" id="L275">            nodePosition = nodePosition + node.branchSize;</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">            assert dest.position() == nodePosition</span>
<span class="nc" id="L277">                    : &quot;Expected node position to be &quot; + nodePosition + &quot; but got &quot; + dest.position() + &quot; after writing children.\n&quot; + dumpNode(node, dest.position());</span>

<span class="fc" id="L279">            serializer.write(dest, node, nodePosition);</span>

<span class="pc bpc" id="L281" title="1 of 2 branches missed.">            assert dest.position() == nodePosition + node.nodeSize</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">                   || dest.paddedPosition() == dest.position() // For PartitionIndexTest.testPointerGrowth where position may jump on page boundaries.</span>
<span class="nc" id="L283">                    : &quot;Expected node position to be &quot; + (nodePosition + node.nodeSize) + &quot; but got &quot; + dest.position() + &quot; after writing node, nodeSize &quot; + node.nodeSize + &quot;.\n&quot; + dumpNode(node, nodePosition);</span>

<span class="fc" id="L285">            node.filePos = nodePosition;</span>
<span class="fc" id="L286">        }</span>
    }

    @Override
    protected long writePartial(Node&lt;VALUE&gt; node, DataOutputPlus dest, long baseOffset) throws IOException
    {
<span class="fc" id="L292">        return writePartialRecursiveOnStack(node, dest, baseOffset, 0);</span>
    }

    @SuppressWarnings(&quot;DuplicatedCode&quot;) // intentionally duplicates IncrementalTrieWriterPageAware
    private long writePartialRecursiveOnStack(Node&lt;VALUE&gt; node, DataOutputPlus dest, long baseOffset, int depth) throws IOException
    {
<span class="fc" id="L298">        long startPosition = dest.position() + baseOffset;</span>

<span class="fc" id="L300">        List&lt;Node&lt;VALUE&gt;&gt; childrenToClear = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">        for (Node&lt;VALUE&gt; child : node.children)</span>
        {
<span class="fc bfc" id="L303" title="All 2 branches covered.">            if (child.filePos == -1)</span>
            {
<span class="fc" id="L305">                childrenToClear.add(child);</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">                if (depth &lt; maxRecursionDepth)</span>
<span class="fc" id="L307">                    child.filePos = writePartialRecursiveOnStack(child, dest, baseOffset, depth + 1);</span>
                else
<span class="fc" id="L309">                    child.filePos = writePartialRecursiveOnHeap(child, dest, baseOffset);</span>
            }
<span class="fc" id="L311">        }</span>

<span class="fc" id="L313">        long nodePosition = dest.position() + baseOffset;</span>

<span class="fc bfc" id="L315" title="All 2 branches covered.">        if (node.hasOutOfPageInBranch)</span>
        {
            // Update the branch size with the size of what we have just written. This may be used by the node's
            // maxPositionDelta, and it's a better approximation for later fitting calculations.
<span class="fc" id="L319">            node.branchSize = (int) (nodePosition - startPosition);</span>
        }

<span class="fc" id="L322">        serializer.write(dest, node, nodePosition);</span>

<span class="fc bfc" id="L324" title="All 4 branches covered.">        if (node.hasOutOfPageChildren || node.hasOutOfPageInBranch)</span>
        {
            // Update the node size with what we have just seen. It's a better approximation for later fitting
            // calculations.
<span class="fc" id="L328">            long endPosition = dest.position() + baseOffset;</span>
<span class="fc" id="L329">            node.nodeSize = (int) (endPosition - nodePosition);</span>
        }

<span class="fc bfc" id="L332" title="All 2 branches covered.">        for (Node&lt;VALUE&gt; child : childrenToClear)</span>
<span class="fc" id="L333">            child.filePos = -1;</span>
<span class="fc" id="L334">        return nodePosition;</span>
    }

    private long writePartialRecursiveOnHeap(Node&lt;VALUE&gt; node, DataOutputPlus dest, long baseOffset) throws IOException
    {
<span class="fc" id="L339">        new WritePartialRecursion(node, dest, baseOffset).process();</span>
<span class="fc" id="L340">        long pos = node.filePos;</span>
<span class="fc" id="L341">        node.filePos = -1;</span>
<span class="fc" id="L342">        return pos;</span>
    }

    class WritePartialRecursion extends Recursion&lt;Node&lt;VALUE&gt;&gt;
    {
        final DataOutputPlus dest;
        final long baseOffset;
        final long startPosition;
        final List&lt;Node&lt;VALUE&gt;&gt; childrenToClear;

        WritePartialRecursion(Node&lt;VALUE&gt; node, WritePartialRecursion parent)
<span class="fc" id="L353">        {</span>
<span class="fc" id="L354">            super(node, node.children.iterator(), parent);</span>
<span class="fc" id="L355">            this.dest = parent.dest;</span>
<span class="fc" id="L356">            this.baseOffset = parent.baseOffset;</span>
<span class="fc" id="L357">            this.startPosition = dest.position() + baseOffset;</span>
<span class="fc" id="L358">            childrenToClear = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L359">        }</span>

        WritePartialRecursion(Node&lt;VALUE&gt; node, DataOutputPlus dest, long baseOffset)
<span class="fc" id="L362">        {</span>
<span class="fc" id="L363">            super(node, node.children.iterator(), null);</span>
<span class="fc" id="L364">            this.dest = dest;</span>
<span class="fc" id="L365">            this.baseOffset = baseOffset;</span>
<span class="fc" id="L366">            this.startPosition = dest.position() + baseOffset;</span>
<span class="fc" id="L367">            childrenToClear = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L368">        }</span>

        @SuppressWarnings(&quot;DuplicatedCode&quot;) // intentionally duplicates IncrementalTrieWriterPageAware and onStack code
        @Override
        Recursion&lt;Node&lt;VALUE&gt;&gt; makeChild(Node&lt;VALUE&gt; child)
        {
<span class="fc bfc" id="L374" title="All 2 branches covered.">            if (child.filePos == -1)</span>
            {
<span class="fc" id="L376">                childrenToClear.add(child);</span>
<span class="fc" id="L377">                return new WritePartialRecursion(child, this);</span>
            }
            else
<span class="fc" id="L380">                return null;</span>
        }

        @Override
        void complete() throws IOException
        {
<span class="fc" id="L386">            long nodePosition = dest.position() + baseOffset;</span>

<span class="fc bfc" id="L388" title="All 2 branches covered.">            if (node.hasOutOfPageInBranch)</span>
            {
                // Update the branch size with the size of what we have just written. This may be used by the node's
                // maxPositionDelta, and it's a better approximation for later fitting calculations.
<span class="fc" id="L392">                node.branchSize = (int) (nodePosition - startPosition);</span>
            }

<span class="fc" id="L395">            serializer.write(dest, node, nodePosition);</span>

<span class="fc bfc" id="L397" title="All 4 branches covered.">            if (node.hasOutOfPageChildren || node.hasOutOfPageInBranch)</span>
            {
                // Update the node size with what we have just seen. It's a better approximation for later fitting
                // calculations.
<span class="fc" id="L401">                long endPosition = dest.position() + baseOffset;</span>
<span class="fc" id="L402">                node.nodeSize = (int) (endPosition - nodePosition);</span>
            }

<span class="fc bfc" id="L405" title="All 2 branches covered.">            for (Node&lt;VALUE&gt; child : childrenToClear)</span>
<span class="fc" id="L406">                child.filePos = -1;</span>

<span class="fc" id="L408">            node.filePos = nodePosition;</span>
<span class="fc" id="L409">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>