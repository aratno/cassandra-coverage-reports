<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BlockBalancedTreeReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.index.sai.disk.v1.bbtree</a> &gt; <span class="el_source">BlockBalancedTreeReader.java</span></div><h1>BlockBalancedTreeReader.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.index.sai.disk.v1.bbtree;

import java.io.Closeable;
import java.io.IOException;
import java.lang.invoke.MethodHandles;
import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.concurrent.TimeUnit;

import com.google.common.base.Stopwatch;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.exceptions.QueryCancelledException;
import org.apache.cassandra.index.sai.IndexContext;
import org.apache.cassandra.index.sai.QueryContext;
import org.apache.cassandra.index.sai.disk.io.IndexFileUtils;
import org.apache.cassandra.index.sai.disk.io.SeekingRandomAccessInput;
import org.apache.cassandra.index.sai.disk.v1.postings.FilteringPostingList;
import org.apache.cassandra.index.sai.disk.v1.postings.MergePostingList;
import org.apache.cassandra.index.sai.disk.v1.postings.PostingsReader;
import org.apache.cassandra.index.sai.metrics.QueryEventListener;
import org.apache.cassandra.index.sai.postings.PeekablePostingList;
import org.apache.cassandra.index.sai.postings.PostingList;
import org.apache.cassandra.io.util.FileHandle;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.utils.ByteArrayUtil;
import org.apache.cassandra.utils.Throwables;
import org.apache.lucene.index.CorruptIndexException;
import org.apache.lucene.index.PointValues.Relation;
import org.apache.lucene.store.IndexInput;
import org.apache.lucene.util.FixedBitSet;
import org.apache.lucene.util.LongValues;
import org.apache.lucene.util.packed.DirectReader;
import org.apache.lucene.util.packed.DirectWriter;

/**
 * Handles intersection of a point or point range with a block balanced tree previously written with
 * {@link BlockBalancedTreeWriter}.
 */
public class BlockBalancedTreeReader extends BlockBalancedTreeWalker implements Closeable
{
<span class="fc" id="L60">    private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());</span>

<span class="fc" id="L62">    private static final Comparator&lt;PeekablePostingList&gt; COMPARATOR = Comparator.comparingLong(PeekablePostingList::peek);</span>

    private final IndexContext indexContext;
    private final FileHandle postingsFile;
    private final BlockBalancedTreePostingsIndex postingsIndex;
    private final int leafOrderMapBitsRequired;
    /**
     * Performs a blocking read.
     */
    public BlockBalancedTreeReader(IndexContext indexContext,
                                   FileHandle treeIndexFile,
                                   long treeIndexRoot,
                                   FileHandle postingsFile,
                                   long treePostingsRoot) throws IOException
    {
<span class="fc" id="L77">        super(treeIndexFile, treeIndexRoot);</span>
<span class="fc" id="L78">        this.indexContext = indexContext;</span>
<span class="fc" id="L79">        this.postingsFile = postingsFile;</span>
<span class="fc" id="L80">        this.postingsIndex = new BlockBalancedTreePostingsIndex(postingsFile, treePostingsRoot);</span>
<span class="fc" id="L81">        leafOrderMapBitsRequired = DirectWriter.unsignedBitsRequired(maxValuesInLeafNode - 1);</span>
<span class="fc" id="L82">    }</span>

    public int getBytesPerValue()
    {
<span class="fc" id="L86">        return bytesPerValue;</span>
    }

    public long getPointCount()
    {
<span class="nc" id="L91">        return valueCount;</span>
    }

    @Override
    public void close()
    {
<span class="fc" id="L97">        super.close();</span>
<span class="fc" id="L98">        FileUtils.closeQuietly(postingsFile);</span>
<span class="fc" id="L99">    }</span>

    @SuppressWarnings({&quot;resource&quot;, &quot;RedundantSuppression&quot;})
    public PostingList intersect(IntersectVisitor visitor, QueryEventListener.BalancedTreeEventListener listener, QueryContext context)
    {
<span class="fc" id="L104">        Relation relation = visitor.compare(minPackedValue, maxPackedValue);</span>

<span class="fc bfc" id="L106" title="All 2 branches covered.">        if (relation == Relation.CELL_OUTSIDE_QUERY)</span>
        {
<span class="fc" id="L108">            listener.onIntersectionEarlyExit();</span>
<span class="fc" id="L109">            return null;</span>
        }

<span class="fc" id="L112">        listener.onSegmentHit();</span>
<span class="fc" id="L113">        IndexInput treeInput = IndexFileUtils.instance.openInput(treeIndexFile);</span>
<span class="fc" id="L114">        IndexInput postingsInput = IndexFileUtils.instance.openInput(postingsFile);</span>
<span class="fc" id="L115">        IndexInput postingsSummaryInput = IndexFileUtils.instance.openInput(postingsFile);</span>

<span class="fc bfc" id="L117" title="All 2 branches covered.">        Intersection intersection = relation == Relation.CELL_INSIDE_QUERY</span>
<span class="fc" id="L118">                                    ? new Intersection(treeInput, postingsInput, postingsSummaryInput, listener, context)</span>
<span class="fc" id="L119">                                    : new FilteringIntersection(treeInput, postingsInput, postingsSummaryInput, visitor, listener, context);</span>

<span class="fc" id="L121">        return intersection.execute();</span>
    }

    /**
     * Synchronous intersection of a point or point range with a block balanced tree previously written
     * with {@link BlockBalancedTreeWriter}.
     */
    private class Intersection
    {
<span class="fc" id="L130">        private final Stopwatch queryExecutionTimer = Stopwatch.createStarted();</span>
        final QueryContext context;

        final TraversalState state;
        final IndexInput treeInput;
        final IndexInput postingsInput;
        final IndexInput postingsSummaryInput;
        final QueryEventListener.BalancedTreeEventListener listener;
        final PriorityQueue&lt;PeekablePostingList&gt; postingLists;

        Intersection(IndexInput treeInput, IndexInput postingsInput, IndexInput postingsSummaryInput,
                     QueryEventListener.BalancedTreeEventListener listener, QueryContext context)
<span class="fc" id="L142">        {</span>
<span class="fc" id="L143">            this.state = newTraversalState();</span>
<span class="fc" id="L144">            this.treeInput = treeInput;</span>
<span class="fc" id="L145">            this.postingsInput = postingsInput;</span>
<span class="fc" id="L146">            this.postingsSummaryInput = postingsSummaryInput;</span>
<span class="fc" id="L147">            this.listener = listener;</span>
<span class="fc" id="L148">            this.context = context;</span>
<span class="fc" id="L149">            postingLists = new PriorityQueue&lt;&gt;(numLeaves, COMPARATOR);</span>
<span class="fc" id="L150">        }</span>

        public PostingList execute()
        {
            try
            {
<span class="fc" id="L156">                executeInternal();</span>

<span class="fc" id="L158">                FileUtils.closeQuietly(treeInput);</span>

<span class="fc" id="L160">                return mergePostings();</span>
            }
<span class="nc" id="L162">            catch (Throwable t)</span>
            {
<span class="nc bnc" id="L164" title="All 2 branches missed.">                if (!(t instanceof QueryCancelledException))</span>
<span class="nc" id="L165">                    logger.error(indexContext.logMessage(&quot;Balanced tree intersection failed on {}&quot;), treeIndexFile.path(), t);</span>

<span class="nc" id="L167">                closeOnException();</span>
<span class="nc" id="L168">                throw Throwables.cleaned(t);</span>
            }
        }

        protected void executeInternal() throws IOException
        {
<span class="fc" id="L174">            collectPostingLists();</span>
<span class="fc" id="L175">        }</span>

        protected void closeOnException()
        {
<span class="nc" id="L179">            FileUtils.closeQuietly(treeInput);</span>
<span class="nc" id="L180">            FileUtils.closeQuietly(postingsInput);</span>
<span class="nc" id="L181">            FileUtils.closeQuietly(postingsSummaryInput);</span>
<span class="nc" id="L182">        }</span>

        protected PostingList mergePostings()
        {
<span class="fc" id="L186">            final long elapsedMicros = queryExecutionTimer.stop().elapsed(TimeUnit.MICROSECONDS);</span>

<span class="fc" id="L188">            listener.onIntersectionComplete(elapsedMicros, TimeUnit.MICROSECONDS);</span>
<span class="fc" id="L189">            listener.postingListsHit(postingLists.size());</span>

<span class="fc bfc" id="L191" title="All 2 branches covered.">            if (postingLists.isEmpty())</span>
            {
<span class="fc" id="L193">                FileUtils.closeQuietly(postingsInput);</span>
<span class="fc" id="L194">                FileUtils.closeQuietly(postingsSummaryInput);</span>
<span class="fc" id="L195">                return null;</span>
            }
            else
            {
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">                if (logger.isTraceEnabled())</span>
<span class="nc" id="L200">                    logger.trace(indexContext.logMessage(&quot;[{}] Intersection completed in {} microseconds. {} leaf and internal posting lists hit.&quot;),</span>
<span class="nc" id="L201">                                 treeIndexFile.path(), elapsedMicros, postingLists.size());</span>
<span class="fc" id="L202">                return MergePostingList.merge(postingLists, () -&gt; FileUtils.close(postingsInput, postingsSummaryInput));</span>
            }
        }

        private void collectPostingLists() throws IOException
        {
<span class="fc" id="L208">            context.checkpoint();</span>

            // This will return true if the node is a child leaf that has postings or if there is postings for the
            // entire subtree under a leaf
<span class="fc bfc" id="L212" title="All 2 branches covered.">            if (postingsIndex.exists(state.nodeID))</span>
            {
<span class="fc" id="L214">                postingLists.add(initPostingReader(postingsIndex.getPostingsFilePointer(state.nodeID)));</span>
<span class="fc" id="L215">                return;</span>
            }

<span class="pc bpc" id="L218" title="1 of 2 branches missed.">            if (state.atLeafNode())</span>
<span class="nc" id="L219">                throw new CorruptIndexException(indexContext.logMessage(String.format(&quot;Leaf node %s does not have balanced tree postings.&quot;, state.nodeID)), &quot;&quot;);</span>

            // Recurse on left subtree:
<span class="fc" id="L222">            state.pushLeft();</span>
<span class="fc" id="L223">            collectPostingLists();</span>
<span class="fc" id="L224">            state.pop();</span>

            // Recurse on right subtree:
<span class="fc" id="L227">            state.pushRight();</span>
<span class="fc" id="L228">            collectPostingLists();</span>
<span class="fc" id="L229">            state.pop();</span>
<span class="fc" id="L230">        }</span>

        @SuppressWarnings({&quot;resource&quot;, &quot;RedundantSuppression&quot;})
        private PeekablePostingList initPostingReader(long offset) throws IOException
        {
<span class="fc" id="L235">            final PostingsReader.BlocksSummary summary = new PostingsReader.BlocksSummary(postingsSummaryInput, offset);</span>
<span class="fc" id="L236">            return PeekablePostingList.makePeekable(new PostingsReader(postingsInput, summary, listener.postingListEventListener()));</span>
        }
    }

<span class="fc" id="L240">    private class FilteringIntersection extends Intersection</span>
    {
        private final IntersectVisitor visitor;
        private final byte[] packedValue;
        private final short[] origIndex;

        FilteringIntersection(IndexInput treeInput, IndexInput postingsInput, IndexInput postingsSummaryInput,
                              IntersectVisitor visitor, QueryEventListener.BalancedTreeEventListener listener, QueryContext context)
<span class="fc" id="L248">        {</span>
<span class="fc" id="L249">            super(treeInput, postingsInput, postingsSummaryInput, listener, context);</span>
<span class="fc" id="L250">            this.visitor = visitor;</span>
<span class="fc" id="L251">            this.packedValue = new byte[bytesPerValue];</span>
<span class="fc" id="L252">            this.origIndex = new short[maxValuesInLeafNode];</span>
<span class="fc" id="L253">        }</span>

        @Override
        public void executeInternal() throws IOException
        {
<span class="fc" id="L258">            collectPostingLists(minPackedValue, maxPackedValue);</span>
<span class="fc" id="L259">        }</span>

        private void collectPostingLists(byte[] minPackedValue, byte[] maxPackedValue) throws IOException
        {
<span class="fc" id="L263">            context.checkpoint();</span>

<span class="fc" id="L265">            final Relation r = visitor.compare(minPackedValue, maxPackedValue);</span>

            // This value range is fully outside the query shape: stop recursing
<span class="fc bfc" id="L268" title="All 2 branches covered.">            if (r == Relation.CELL_OUTSIDE_QUERY)</span>
<span class="fc" id="L269">                return;</span>

<span class="fc bfc" id="L271" title="All 2 branches covered.">            if (r == Relation.CELL_INSIDE_QUERY)</span>
            {
                // This value range is fully inside the query shape: recursively add all points from this node without filtering
<span class="fc" id="L274">                super.collectPostingLists();</span>
<span class="fc" id="L275">                return;</span>
            }

<span class="fc bfc" id="L278" title="All 2 branches covered.">            if (state.atLeafNode())</span>
            {
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">                if (state.nodeExists())</span>
<span class="fc" id="L281">                    filterLeaf();</span>
<span class="fc" id="L282">                return;</span>
            }

<span class="fc" id="L285">            visitNode(minPackedValue, maxPackedValue);</span>
<span class="fc" id="L286">        }</span>

        private void filterLeaf() throws IOException
        {
<span class="fc" id="L290">            treeInput.seek(state.getLeafBlockFP());</span>

<span class="fc" id="L292">            int count = treeInput.readVInt();</span>
<span class="fc" id="L293">            int orderMapLength = treeInput.readVInt();</span>
<span class="fc" id="L294">            long orderMapPointer = treeInput.getFilePointer();</span>

<span class="fc" id="L296">            SeekingRandomAccessInput randomAccessInput = new SeekingRandomAccessInput(treeInput);</span>
<span class="fc" id="L297">            LongValues leafOrderMapReader = DirectReader.getInstance(randomAccessInput, leafOrderMapBitsRequired, orderMapPointer);</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">            for (int index = 0; index &lt; count; index++)</span>
            {
<span class="fc" id="L300">                origIndex[index] = (short) Math.toIntExact(leafOrderMapReader.get(index));</span>
            }

            // seek beyond the ordermap
<span class="fc" id="L304">            treeInput.seek(orderMapPointer + orderMapLength);</span>

<span class="fc" id="L306">            FixedBitSet fixedBitSet = buildPostingsFilter(treeInput, count, visitor, origIndex);</span>

<span class="pc bpc" id="L308" title="1 of 4 branches missed.">            if (postingsIndex.exists(state.nodeID) &amp;&amp; fixedBitSet.cardinality() &gt; 0)</span>
            {
<span class="fc" id="L310">                long pointer = postingsIndex.getPostingsFilePointer(state.nodeID);</span>
<span class="fc" id="L311">                postingLists.add(initFilteringPostingReader(pointer, fixedBitSet));</span>
            }
<span class="fc" id="L313">        }</span>

        void visitNode(byte[] minPackedValue, byte[] maxPackedValue) throws IOException
        {
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">            assert !state.atLeafNode() : &quot;Cannot recurse down tree because nodeID &quot; + state.nodeID + &quot; is a leaf node&quot;;</span>

<span class="fc" id="L319">            byte[] splitValue = state.getSplitValue();</span>

<span class="pc bpc" id="L321" title="1 of 2 branches missed.">            if (BlockBalancedTreeWriter.DEBUG)</span>
            {
                // make sure cellMin &lt;= splitValue &lt;= cellMax:
<span class="nc bnc" id="L324" title="All 2 branches missed.">                assert ByteArrayUtil.compareUnsigned(minPackedValue, 0, splitValue, 0, bytesPerValue) &lt;= 0 :&quot;bytesPerValue=&quot; + bytesPerValue;</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">                assert ByteArrayUtil.compareUnsigned(maxPackedValue, 0, splitValue, 0, bytesPerValue) &gt;= 0 : &quot;bytesPerValue=&quot; + bytesPerValue;</span>
            }

            // Recurse on left subtree:
<span class="fc" id="L329">            state.pushLeft();</span>
<span class="fc" id="L330">            collectPostingLists(minPackedValue, splitValue);</span>
<span class="fc" id="L331">            state.pop();</span>

            // Recurse on right subtree:
<span class="fc" id="L334">            state.pushRight();</span>
<span class="fc" id="L335">            collectPostingLists(splitValue, maxPackedValue);</span>
<span class="fc" id="L336">            state.pop();</span>
<span class="fc" id="L337">        }</span>

        @SuppressWarnings({&quot;resource&quot;, &quot;RedundantSuppression&quot;})
        private PeekablePostingList initFilteringPostingReader(long offset, FixedBitSet filter) throws IOException
        {
<span class="fc" id="L342">            final PostingsReader.BlocksSummary summary = new PostingsReader.BlocksSummary(postingsSummaryInput, offset);</span>
<span class="fc" id="L343">            PostingsReader postingsReader = new PostingsReader(postingsInput, summary, listener.postingListEventListener());</span>
<span class="fc" id="L344">            return PeekablePostingList.makePeekable(new FilteringPostingList(filter, postingsReader));</span>
        }

        private FixedBitSet buildPostingsFilter(IndexInput in, int count, IntersectVisitor visitor, short[] origIndex) throws IOException
        {
<span class="fc" id="L349">            int commonPrefixLength = readCommonPrefixLength(in);</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">            return commonPrefixLength == bytesPerValue ? buildPostingsFilterForSingleValueLeaf(count, visitor, origIndex)</span>
<span class="fc" id="L351">                                                       : buildPostingsFilterForMultiValueLeaf(commonPrefixLength, in, count, visitor, origIndex);</span>
        }

        private FixedBitSet buildPostingsFilterForMultiValueLeaf(int commonPrefixLength,
                                                                 IndexInput in,
                                                                 int count,
                                                                 IntersectVisitor visitor,
                                                                 short[] origIndex) throws IOException
        {
            // the byte at `compressedByteOffset` is compressed using run-length compression,
            // other suffix bytes are stored verbatim
<span class="fc" id="L362">            int compressedByteOffset = commonPrefixLength;</span>
<span class="fc" id="L363">            commonPrefixLength++;</span>
            int i;

<span class="fc" id="L366">            FixedBitSet fixedBitSet = new FixedBitSet(maxValuesInLeafNode);</span>

<span class="fc bfc" id="L368" title="All 2 branches covered.">            for (i = 0; i &lt; count; )</span>
            {
<span class="fc" id="L370">                packedValue[compressedByteOffset] = in.readByte();</span>
<span class="fc" id="L371">                final int runLen = Byte.toUnsignedInt(in.readByte());</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">                for (int j = 0; j &lt; runLen; ++j)</span>
                {
<span class="fc" id="L374">                    in.readBytes(packedValue, commonPrefixLength, bytesPerValue - commonPrefixLength);</span>
<span class="fc" id="L375">                    final int rowIDIndex = origIndex[i + j];</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">                    if (visitor.contains(packedValue))</span>
<span class="fc" id="L377">                        fixedBitSet.set(rowIDIndex);</span>
                }
<span class="fc" id="L379">                i += runLen;</span>
<span class="fc" id="L380">            }</span>
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">            if (i != count)</span>
<span class="nc" id="L382">                throw new CorruptIndexException(String.format(&quot;Expected %d sub-blocks but read %d.&quot;, count, i), in);</span>

<span class="fc" id="L384">            return fixedBitSet;</span>
        }

        private FixedBitSet buildPostingsFilterForSingleValueLeaf(int count, IntersectVisitor visitor, final short[] origIndex)
        {
<span class="fc" id="L389">            FixedBitSet fixedBitSet = new FixedBitSet(maxValuesInLeafNode);</span>

            // All the values in the leaf are the same, so we only
            // need to visit once then set the bits for the relevant indexes
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">            if (visitor.contains(packedValue))</span>
            {
<span class="fc bfc" id="L395" title="All 2 branches covered.">                for (int i = 0; i &lt; count; ++i)</span>
<span class="fc" id="L396">                    fixedBitSet.set(origIndex[i]);</span>
            }
<span class="fc" id="L398">            return fixedBitSet;</span>
        }

        private int readCommonPrefixLength(IndexInput in) throws IOException
        {
<span class="fc" id="L403">            int prefixLength = in.readVInt();</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">            if (prefixLength &gt; 0)</span>
<span class="fc" id="L405">                in.readBytes(packedValue, 0, prefixLength);</span>
<span class="fc" id="L406">            return prefixLength;</span>
        }
    }

    /**
     * We recurse the balanced tree, using a provided instance of this to guide the recursion.
     */
    public interface IntersectVisitor
    {
        /**
         * Called for all values in a leaf cell that crosses the query.  The consumer should scrutinize the packedValue
         * to decide whether to accept it. Values are visited in increasing order, and in the case of ties,
         * in increasing order by segment row ID.
         */
        boolean contains(byte[] packedValue);

        /**
         * Called for non-leaf cells to test how the cell relates to the query, to
         * determine how to further recurse down the tree.
         */
        Relation compare(byte[] minPackedValue, byte[] maxPackedValue);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>