<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TokenTree.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.index.sasi.disk</a> &gt; <span class="el_source">TokenTree.java</span></div><h1>TokenTree.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.index.sasi.disk;

import java.io.IOException;
import java.util.*;

import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.index.sasi.utils.CombinedValue;
import org.apache.cassandra.index.sasi.utils.MappedBuffer;
import org.apache.cassandra.index.sasi.utils.RangeIterator;
import org.apache.cassandra.utils.AbstractGuavaIterator;
import org.apache.cassandra.utils.MergeIterator;

import com.carrotsearch.hppc.LongHashSet;
import com.carrotsearch.hppc.LongSet;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.collect.Iterators;
import org.apache.commons.lang3.builder.HashCodeBuilder;

import static org.apache.cassandra.index.sasi.disk.TokenTreeBuilder.EntryType;

// Note: all of the seek-able offsets contained in TokenTree should be sizeof(long)
// even if currently only lower int portion of them if used, because that makes
// it possible to switch to mmap implementation which supports long positions
// without any on-disk format changes and/or re-indexing if one day we'll have a need to.
public class TokenTree
{
    private static final int LONG_BYTES = Long.SIZE / 8;
    private static final int SHORT_BYTES = Short.SIZE / 8;

    private final Descriptor descriptor;
    private final MappedBuffer file;
    private final long startPos;
    private final long treeMinToken;
    private final long treeMaxToken;
    private final long tokenCount;

    @VisibleForTesting
    protected TokenTree(MappedBuffer tokenTree)
    {
<span class="fc" id="L58">        this(Descriptor.CURRENT, tokenTree);</span>
<span class="fc" id="L59">    }</span>

    public TokenTree(Descriptor d, MappedBuffer tokenTree)
<span class="fc" id="L62">    {</span>
<span class="fc" id="L63">        descriptor = d;</span>
<span class="fc" id="L64">        file = tokenTree;</span>
<span class="fc" id="L65">        startPos = file.position();</span>

<span class="fc" id="L67">        file.position(startPos + TokenTreeBuilder.SHARED_HEADER_BYTES);</span>

<span class="pc bpc" id="L69" title="1 of 2 branches missed.">        if (!validateMagic())</span>
<span class="nc" id="L70">            throw new IllegalArgumentException(&quot;invalid token tree&quot;);</span>

<span class="fc" id="L72">        tokenCount = file.getLong();</span>
<span class="fc" id="L73">        treeMinToken = file.getLong();</span>
<span class="fc" id="L74">        treeMaxToken = file.getLong();</span>
<span class="fc" id="L75">    }</span>

    public long getCount()
    {
<span class="fc" id="L79">        return tokenCount;</span>
    }

    public RangeIterator&lt;Long, Token&gt; iterator(Function&lt;Long, DecoratedKey&gt; keyFetcher)
    {
<span class="fc" id="L84">        return new TokenTreeIterator(file.duplicate(), keyFetcher);</span>
    }

    public OnDiskToken get(final long searchToken, Function&lt;Long, DecoratedKey&gt; keyFetcher)
    {
<span class="fc" id="L89">        seekToLeaf(searchToken, file);</span>
<span class="fc" id="L90">        long leafStart = file.position();</span>
<span class="fc" id="L91">        short leafSize = file.getShort(leafStart + 1); // skip the info byte</span>

<span class="fc" id="L93">        file.position(leafStart + TokenTreeBuilder.BLOCK_HEADER_BYTES); // skip to tokens</span>
<span class="fc" id="L94">        short tokenIndex = searchLeaf(searchToken, leafSize);</span>

<span class="fc" id="L96">        file.position(leafStart + TokenTreeBuilder.BLOCK_HEADER_BYTES);</span>

<span class="fc" id="L98">        OnDiskToken token = OnDiskToken.getTokenAt(file, tokenIndex, leafSize, keyFetcher);</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">        return token.get().equals(searchToken) ? token : null;</span>
    }

    private boolean validateMagic()
    {
<span class="pc bpc" id="L104" title="1 of 3 branches missed.">        switch (descriptor.version.toString())</span>
        {
            case Descriptor.VERSION_AA:
<span class="fc" id="L107">                return true;</span>
            case Descriptor.VERSION_AB:
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">                return TokenTreeBuilder.AB_MAGIC == file.getShort();</span>
            default:
<span class="nc" id="L111">                return false;</span>
        }
    }

    // finds leaf that *could* contain token
    private void seekToLeaf(long token, MappedBuffer file)
    {
        // this loop always seeks forward except for the first iteration
        // where it may seek back to the root
<span class="fc" id="L120">        long blockStart = startPos;</span>
        while (true)
        {
<span class="fc" id="L123">            file.position(blockStart);</span>

<span class="fc" id="L125">            byte info = file.get();</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">            boolean isLeaf = (info &amp; 1) == 1;</span>

<span class="fc bfc" id="L128" title="All 2 branches covered.">            if (isLeaf)</span>
            {
<span class="fc" id="L130">                file.position(blockStart);</span>
<span class="fc" id="L131">                break;</span>
            }

<span class="fc" id="L134">            short tokenCount = file.getShort();</span>

<span class="fc" id="L136">            long minToken = file.getLong();</span>
<span class="fc" id="L137">            long maxToken = file.getLong();</span>

<span class="fc" id="L139">            long seekBase = blockStart + TokenTreeBuilder.BLOCK_HEADER_BYTES;</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">            if (minToken &gt; token)</span>
            {
                // seek to beginning of child offsets to locate first child
<span class="fc" id="L143">                file.position(seekBase + tokenCount * LONG_BYTES);</span>
<span class="fc" id="L144">                blockStart = (startPos + (int) file.getLong());</span>
            }
<span class="fc bfc" id="L146" title="All 2 branches covered.">            else if (maxToken &lt; token)</span>
            {
                // seek to end of child offsets to locate last child
<span class="fc" id="L149">                file.position(seekBase + (2 * tokenCount) * LONG_BYTES);</span>
<span class="fc" id="L150">                blockStart = (startPos + (int) file.getLong());</span>
            }
            else
            {
                // skip to end of block header/start of interior block tokens
<span class="fc" id="L155">                file.position(seekBase);</span>

<span class="fc" id="L157">                short offsetIndex = searchBlock(token, tokenCount, file);</span>

                // file pointer is now at beginning of offsets
<span class="fc bfc" id="L160" title="All 2 branches covered.">                if (offsetIndex == tokenCount)</span>
<span class="fc" id="L161">                    file.position(file.position() + (offsetIndex * LONG_BYTES));</span>
                else
<span class="fc" id="L163">                    file.position(file.position() + ((tokenCount - offsetIndex - 1) + offsetIndex) * LONG_BYTES);</span>

<span class="fc" id="L165">                blockStart = (startPos + (int) file.getLong());</span>
            }
<span class="fc" id="L167">        }</span>
<span class="fc" id="L168">    }</span>

    private short searchBlock(long searchToken, short tokenCount, MappedBuffer file)
    {
<span class="fc" id="L172">        short offsetIndex = 0;</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">        for (int i = 0; i &lt; tokenCount; i++)</span>
        {
<span class="fc" id="L175">            long readToken = file.getLong();</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">            if (searchToken &lt; readToken)</span>
<span class="fc" id="L177">                break;</span>

<span class="fc" id="L179">            offsetIndex++;</span>
        }

<span class="fc" id="L182">        return offsetIndex;</span>
    }

    private short searchLeaf(long searchToken, short tokenCount)
    {
<span class="fc" id="L187">        long base = file.position();</span>

<span class="fc" id="L189">        int start = 0;</span>
<span class="fc" id="L190">        int end = tokenCount;</span>
<span class="fc" id="L191">        int middle = 0;</span>

<span class="fc bfc" id="L193" title="All 2 branches covered.">        while (start &lt;= end)</span>
        {
<span class="fc" id="L195">            middle = start + ((end - start) &gt;&gt; 1);</span>

            // each entry is 16 bytes wide, token is in bytes 4-11
<span class="fc" id="L198">            long token = file.getLong(base + (middle * (2 * LONG_BYTES) + 4));</span>

<span class="fc bfc" id="L200" title="All 2 branches covered.">            if (token == searchToken)</span>
<span class="fc" id="L201">                break;</span>

<span class="fc bfc" id="L203" title="All 2 branches covered.">            if (token &lt; searchToken)</span>
<span class="fc" id="L204">                start = middle + 1;</span>
            else
<span class="fc" id="L206">                end = middle - 1;</span>
<span class="fc" id="L207">        }</span>

<span class="fc" id="L209">        return (short) middle;</span>
    }

<span class="fc" id="L212">    public class TokenTreeIterator extends RangeIterator&lt;Long, Token&gt;</span>
    {
        private final Function&lt;Long, DecoratedKey&gt; keyFetcher;
        private final MappedBuffer file;

        private long currentLeafStart;
        private int currentTokenIndex;

        private long leafMinToken;
        private long leafMaxToken;
        private short leafSize;

<span class="fc" id="L224">        protected boolean firstIteration = true;</span>
        private boolean lastLeaf;

        TokenTreeIterator(MappedBuffer file, Function&lt;Long, DecoratedKey&gt; keyFetcher)
<span class="fc" id="L228">        {</span>
<span class="fc" id="L229">            super(treeMinToken, treeMaxToken, tokenCount);</span>

<span class="fc" id="L231">            this.file = file;</span>
<span class="fc" id="L232">            this.keyFetcher = keyFetcher;</span>
<span class="fc" id="L233">        }</span>

        protected Token computeNext()
        {
<span class="fc" id="L237">            maybeFirstIteration();</span>

<span class="fc bfc" id="L239" title="All 4 branches covered.">            if (currentTokenIndex &gt;= leafSize &amp;&amp; lastLeaf)</span>
<span class="fc" id="L240">                return endOfData();</span>

<span class="fc bfc" id="L242" title="All 2 branches covered.">            if (currentTokenIndex &lt; leafSize) // tokens remaining in this leaf</span>
            {
<span class="fc" id="L244">                return getTokenAt(currentTokenIndex++);</span>
            }
            else // no more tokens remaining in this leaf
            {
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">                assert !lastLeaf;</span>

<span class="fc" id="L250">                seekToNextLeaf();</span>
<span class="fc" id="L251">                setupBlock();</span>
<span class="fc" id="L252">                return computeNext();</span>
            }
        }

        protected void performSkipTo(Long nextToken)
        {
<span class="fc" id="L258">            maybeFirstIteration();</span>

<span class="fc bfc" id="L260" title="All 2 branches covered.">            if (nextToken &lt;= leafMaxToken) // next is in this leaf block</span>
            {
<span class="fc" id="L262">                searchLeaf(nextToken);</span>
            }
            else // next is in a leaf block that needs to be found
            {
<span class="fc" id="L266">                seekToLeaf(nextToken, file);</span>
<span class="fc" id="L267">                setupBlock();</span>
<span class="fc" id="L268">                findNearest(nextToken);</span>
            }
<span class="fc" id="L270">        }</span>

        private void setupBlock()
        {
<span class="fc" id="L274">            currentLeafStart = file.position();</span>
<span class="fc" id="L275">            currentTokenIndex = 0;</span>

<span class="fc bfc" id="L277" title="All 2 branches covered.">            lastLeaf = (file.get() &amp; (1 &lt;&lt; TokenTreeBuilder.LAST_LEAF_SHIFT)) &gt; 0;</span>
<span class="fc" id="L278">            leafSize = file.getShort();</span>

<span class="fc" id="L280">            leafMinToken = file.getLong();</span>
<span class="fc" id="L281">            leafMaxToken = file.getLong();</span>

            // seek to end of leaf header/start of data
<span class="fc" id="L284">            file.position(currentLeafStart + TokenTreeBuilder.BLOCK_HEADER_BYTES);</span>
<span class="fc" id="L285">        }</span>

        private void findNearest(Long next)
        {
<span class="pc bpc" id="L289" title="3 of 4 branches missed.">            if (next &gt; leafMaxToken &amp;&amp; !lastLeaf)</span>
            {
<span class="nc" id="L291">                seekToNextLeaf();</span>
<span class="nc" id="L292">                setupBlock();</span>
<span class="nc" id="L293">                findNearest(next);</span>
            }
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">            else if (next &gt; leafMinToken)</span>
<span class="fc" id="L296">                searchLeaf(next);</span>
<span class="fc" id="L297">        }</span>

        private void searchLeaf(long next)
        {
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">            for (int i = currentTokenIndex; i &lt; leafSize; i++)</span>
            {
<span class="fc bfc" id="L303" title="All 2 branches covered.">                if (compareTokenAt(currentTokenIndex, next) &gt;= 0)</span>
<span class="fc" id="L304">                    break;</span>

<span class="fc" id="L306">                currentTokenIndex++;</span>
            }
<span class="fc" id="L308">        }</span>

        private int compareTokenAt(int idx, long toToken)
        {
<span class="fc" id="L312">            return Long.compare(file.getLong(getTokenPosition(idx)), toToken);</span>
        }

        private Token getTokenAt(int idx)
        {
<span class="fc" id="L317">            return OnDiskToken.getTokenAt(file, idx, leafSize, keyFetcher);</span>
        }

        private long getTokenPosition(int idx)
        {
            // skip 4 byte entry header to get position pointing directly at the entry's token
<span class="fc" id="L323">            return OnDiskToken.getEntryPosition(idx, file) + (2 * SHORT_BYTES);</span>
        }

        private void seekToNextLeaf()
        {
<span class="fc" id="L328">            file.position(currentLeafStart + TokenTreeBuilder.BLOCK_BYTES);</span>
<span class="fc" id="L329">        }</span>

        public void close() throws IOException
        {
            // nothing to do here
<span class="fc" id="L334">        }</span>

        private void maybeFirstIteration()
        {
            // seek to the first token only when requested for the first time,
            // highly predictable branch and saves us a lot by not traversing the tree
            // on creation time because it's not at all required.
<span class="fc bfc" id="L341" title="All 2 branches covered.">            if (!firstIteration)</span>
<span class="fc" id="L342">                return;</span>

<span class="fc" id="L344">            seekToLeaf(treeMinToken, file);</span>
<span class="fc" id="L345">            setupBlock();</span>
<span class="fc" id="L346">            firstIteration = false;</span>
<span class="fc" id="L347">        }</span>
    }

    public static class OnDiskToken extends Token
    {
<span class="fc" id="L352">        private final Set&lt;TokenInfo&gt; info = new HashSet&lt;&gt;(2);</span>
<span class="fc" id="L353">        private final Set&lt;DecoratedKey&gt; loadedKeys = new TreeSet&lt;&gt;(DecoratedKey.comparator);</span>

        public OnDiskToken(MappedBuffer buffer, long position, short leafSize, Function&lt;Long, DecoratedKey&gt; keyFetcher)
        {
<span class="fc" id="L357">            super(buffer.getLong(position + (2 * SHORT_BYTES)));</span>
<span class="fc" id="L358">            info.add(new TokenInfo(buffer, position, leafSize, keyFetcher));</span>
<span class="fc" id="L359">        }</span>

        public void merge(CombinedValue&lt;Long&gt; other)
        {
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">            if (!(other instanceof Token))</span>
<span class="nc" id="L364">                return;</span>

<span class="fc" id="L366">            Token o = (Token) other;</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">            if (token != o.token)</span>
<span class="fc" id="L368">                throw new IllegalArgumentException(String.format(&quot;%s != %s&quot;, token, o.token));</span>

<span class="fc bfc" id="L370" title="All 2 branches covered.">            if (o instanceof OnDiskToken)</span>
            {
<span class="fc" id="L372">                info.addAll(((OnDiskToken) other).info);</span>
            }
            else
            {
<span class="fc" id="L376">                Iterators.addAll(loadedKeys, o.iterator());</span>
            }
<span class="fc" id="L378">        }</span>

        public Iterator&lt;DecoratedKey&gt; iterator()
        {
<span class="fc" id="L382">            List&lt;Iterator&lt;DecoratedKey&gt;&gt; keys = new ArrayList&lt;&gt;(info.size());</span>

<span class="fc bfc" id="L384" title="All 2 branches covered.">            for (TokenInfo i : info)</span>
<span class="fc" id="L385">                keys.add(i.iterator());</span>

<span class="fc bfc" id="L387" title="All 2 branches covered.">            if (!loadedKeys.isEmpty())</span>
<span class="fc" id="L388">                keys.add(loadedKeys.iterator());</span>

<span class="fc" id="L390">            return MergeIterator.get(keys, DecoratedKey.comparator, new MergeIterator.Reducer&lt;DecoratedKey, DecoratedKey&gt;()</span>
<span class="fc" id="L391">            {</span>
<span class="fc" id="L392">                DecoratedKey reduced = null;</span>

                public boolean trivialReduceIsTrivial()
                {
<span class="fc" id="L396">                    return true;</span>
                }

                public void reduce(int idx, DecoratedKey current)
                {
<span class="fc" id="L401">                    reduced = current;</span>
<span class="fc" id="L402">                }</span>

                protected DecoratedKey getReduced()
                {
<span class="fc" id="L406">                    return reduced;</span>
                }
            });
        }

        public LongSet getOffsets()
        {
<span class="fc" id="L413">            LongSet offsets = new LongHashSet(4);</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">            for (TokenInfo i : info)</span>
            {
<span class="fc bfc" id="L416" title="All 2 branches covered.">                for (long offset : i.fetchOffsets())</span>
<span class="fc" id="L417">                    offsets.add(offset);</span>
<span class="fc" id="L418">            }</span>

<span class="fc" id="L420">            return offsets;</span>
        }

        public static OnDiskToken getTokenAt(MappedBuffer buffer, int idx, short leafSize, Function&lt;Long, DecoratedKey&gt; keyFetcher)
        {
<span class="fc" id="L425">            return new OnDiskToken(buffer, getEntryPosition(idx, buffer), leafSize, keyFetcher);</span>
        }

        private static long getEntryPosition(int idx, MappedBuffer file)
        {
            // info (4 bytes) + token (8 bytes) + offset (4 bytes) = 16 bytes
<span class="fc" id="L431">            return file.position() + (idx * (2 * LONG_BYTES));</span>
        }
    }

    private static class TokenInfo
    {
        private final MappedBuffer buffer;
        private final Function&lt;Long, DecoratedKey&gt; keyFetcher;

        private final long position;
        private final short leafSize;

        public TokenInfo(MappedBuffer buffer, long position, short leafSize, Function&lt;Long, DecoratedKey&gt; keyFetcher)
<span class="fc" id="L444">        {</span>
<span class="fc" id="L445">            this.keyFetcher = keyFetcher;</span>
<span class="fc" id="L446">            this.buffer = buffer;</span>
<span class="fc" id="L447">            this.position = position;</span>
<span class="fc" id="L448">            this.leafSize = leafSize;</span>
<span class="fc" id="L449">        }</span>

        public Iterator&lt;DecoratedKey&gt; iterator()
        {
<span class="fc" id="L453">            return new KeyIterator(keyFetcher, fetchOffsets());</span>
        }

        public int hashCode()
        {
<span class="fc" id="L458">            return new HashCodeBuilder().append(keyFetcher).append(position).append(leafSize).build();</span>
        }

        public boolean equals(Object other)
        {
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">            if (!(other instanceof TokenInfo))</span>
<span class="nc" id="L464">                return false;</span>

<span class="fc" id="L466">            TokenInfo o = (TokenInfo) other;</span>
<span class="pc bpc" id="L467" title="3 of 4 branches missed.">            return keyFetcher == o.keyFetcher &amp;&amp; position == o.position;</span>
        }

        private long[] fetchOffsets()
        {
<span class="fc" id="L472">            short info = buffer.getShort(position);</span>
            // offset extra is unsigned short (right-most 16 bits of 48 bits allowed for an offset)
<span class="fc" id="L474">            int offsetExtra = buffer.getShort(position + SHORT_BYTES) &amp; 0xFFFF;</span>
            // is the it left-most (32-bit) base of the actual offset in the index file
<span class="fc" id="L476">            int offsetData = buffer.getInt(position + (2 * SHORT_BYTES) + LONG_BYTES);</span>

<span class="fc" id="L478">            EntryType type = EntryType.of(info &amp; TokenTreeBuilder.ENTRY_TYPE_MASK);</span>

<span class="pc bpc" id="L480" title="1 of 5 branches missed.">            switch (type)</span>
            {
                case SIMPLE:
<span class="fc" id="L483">                    return new long[] { offsetData };</span>

                case OVERFLOW:
<span class="fc" id="L486">                    long[] offsets = new long[offsetExtra]; // offsetShort contains count of tokens</span>
<span class="fc" id="L487">                    long offsetPos = (buffer.position() + (2 * (leafSize * LONG_BYTES)) + (offsetData * LONG_BYTES));</span>

<span class="fc bfc" id="L489" title="All 2 branches covered.">                    for (int i = 0; i &lt; offsetExtra; i++)</span>
<span class="fc" id="L490">                        offsets[i] = buffer.getLong(offsetPos + (i * LONG_BYTES));</span>

<span class="fc" id="L492">                    return offsets;</span>

                case FACTORED:
<span class="fc" id="L495">                    return new long[] { (((long) offsetData) &lt;&lt; Short.SIZE) + offsetExtra };</span>

                case PACKED:
<span class="fc" id="L498">                    return new long[] { offsetExtra, offsetData };</span>

                default:
<span class="nc" id="L501">                    throw new IllegalStateException(&quot;Unknown entry type: &quot; + type);</span>
            }
        }
    }

    private static class KeyIterator extends AbstractGuavaIterator&lt;DecoratedKey&gt;
    {
        private final Function&lt;Long, DecoratedKey&gt; keyFetcher;
        private final long[] offsets;
<span class="fc" id="L510">        private int index = 0;</span>

        public KeyIterator(Function&lt;Long, DecoratedKey&gt; keyFetcher, long[] offsets)
<span class="fc" id="L513">        {</span>
<span class="fc" id="L514">            this.keyFetcher = keyFetcher;</span>
<span class="fc" id="L515">            this.offsets = offsets;</span>
<span class="fc" id="L516">        }</span>

        public DecoratedKey computeNext()
        {
<span class="fc bfc" id="L520" title="All 2 branches covered.">            return index &lt; offsets.length ? keyFetcher.apply(offsets[index++]) : endOfData();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>