<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ResultMessage.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.transport.messages</a> &gt; <span class="el_source">ResultMessage.java</span></div><h1>ResultMessage.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.transport.messages;


import com.google.common.annotations.VisibleForTesting;

import io.netty.buffer.ByteBuf;

import org.apache.cassandra.cql3.ResultSet;
import org.apache.cassandra.transport.*;
import org.apache.cassandra.utils.MD5Digest;

public abstract class ResultMessage extends Message.Response
{
<span class="fc" id="L31">    public static final Message.Codec&lt;ResultMessage&gt; codec = new Message.Codec&lt;ResultMessage&gt;()</span>
<span class="fc" id="L32">    {</span>
        public ResultMessage decode(ByteBuf body, ProtocolVersion version)
        {
<span class="fc" id="L35">            Kind kind = Kind.fromId(body.readInt());</span>
<span class="fc" id="L36">            return kind.subcodec.decode(body, version);</span>
        }

        public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
        {
<span class="fc" id="L41">            dest.writeInt(msg.kind.id);</span>
<span class="fc" id="L42">            msg.kind.subcodec.encode(msg, dest, version);</span>
<span class="fc" id="L43">        }</span>

        public int encodedSize(ResultMessage msg, ProtocolVersion version)
        {
<span class="fc" id="L47">            return 4 + msg.kind.subcodec.encodedSize(msg, version);</span>
        }
    };

<span class="fc" id="L51">    public enum Kind</span>
    {

<span class="fc" id="L54">        VOID               (1, Void.subcodec),</span>
<span class="fc" id="L55">        ROWS               (2, Rows.subcodec),</span>
<span class="fc" id="L56">        SET_KEYSPACE       (3, SetKeyspace.subcodec),</span>
<span class="fc" id="L57">        PREPARED           (4, Prepared.subcodec),</span>
<span class="fc" id="L58">        SCHEMA_CHANGE      (5, SchemaChange.subcodec);</span>
        public final int id;
        public final Message.Codec&lt;ResultMessage&gt; subcodec;

        private static final Kind[] ids;
        static
        {
<span class="fc" id="L65">            int maxId = -1;</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">            for (Kind k : Kind.values())</span>
<span class="fc" id="L67">                maxId = Math.max(maxId, k.id);</span>
<span class="fc" id="L68">            ids = new Kind[maxId + 1];</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">            for (Kind k : Kind.values())</span>
            {
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">                if (ids[k.id] != null)</span>
<span class="nc" id="L72">                    throw new IllegalStateException(&quot;Duplicate kind id&quot;);</span>
<span class="fc" id="L73">                ids[k.id] = k;</span>
            }
<span class="fc" id="L75">        }</span>

        private Kind(int id, Message.Codec&lt;ResultMessage&gt; subcodec)
<span class="fc" id="L78">        {</span>
<span class="fc" id="L79">            this.id = id;</span>
<span class="fc" id="L80">            this.subcodec = subcodec;</span>
<span class="fc" id="L81">        }</span>

        public static Kind fromId(int id)
        {
<span class="fc" id="L85">            Kind k = ids[id];</span>
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">            if (k == null)</span>
<span class="nc" id="L87">                throw new ProtocolException(String.format(&quot;Unknown kind id %d in RESULT message&quot;, id));</span>
<span class="fc" id="L88">            return k;</span>
        }
    }

    public final Kind kind;

    protected ResultMessage(Kind kind)
    {
<span class="fc" id="L96">        super(Message.Type.RESULT);</span>
<span class="fc" id="L97">        this.kind = kind;</span>
<span class="fc" id="L98">    }</span>

    public static class Void extends ResultMessage
    {
        // Even though we have no specific information here, don't make a
        // singleton since as each message it has in fact a streamid and connection.
        public Void()
        {
<span class="fc" id="L106">            super(Kind.VOID);</span>
<span class="fc" id="L107">        }</span>

<span class="fc" id="L109">        public static final Message.Codec&lt;ResultMessage&gt; subcodec = new Message.Codec&lt;ResultMessage&gt;()</span>
<span class="fc" id="L110">        {</span>
            public ResultMessage decode(ByteBuf body, ProtocolVersion version)
            {
<span class="fc" id="L113">                return new Void();</span>
            }

            public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
            {
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">                assert msg instanceof Void;</span>
<span class="fc" id="L119">            }</span>

            public int encodedSize(ResultMessage msg, ProtocolVersion version)
            {
<span class="fc" id="L123">                return 0;</span>
            }
        };

        @Override
        public String toString()
        {
<span class="nc" id="L130">            return &quot;EMPTY RESULT&quot;;</span>
        }
    }

    public static class SetKeyspace extends ResultMessage
    {
        public final String keyspace;

        public SetKeyspace(String keyspace)
        {
<span class="fc" id="L140">            super(Kind.SET_KEYSPACE);</span>
<span class="fc" id="L141">            this.keyspace = keyspace;</span>
<span class="fc" id="L142">        }</span>

<span class="fc" id="L144">        public static final Message.Codec&lt;ResultMessage&gt; subcodec = new Message.Codec&lt;ResultMessage&gt;()</span>
<span class="fc" id="L145">        {</span>
            public ResultMessage decode(ByteBuf body, ProtocolVersion version)
            {
<span class="nc" id="L148">                String keyspace = CBUtil.readString(body);</span>
<span class="nc" id="L149">                return new SetKeyspace(keyspace);</span>
            }

            public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
            {
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">                assert msg instanceof SetKeyspace;</span>
<span class="fc" id="L155">                CBUtil.writeAsciiString(((SetKeyspace)msg).keyspace, dest);</span>
<span class="fc" id="L156">            }</span>

            public int encodedSize(ResultMessage msg, ProtocolVersion version)
            {
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">                assert msg instanceof SetKeyspace;</span>
<span class="fc" id="L161">                return CBUtil.sizeOfAsciiString(((SetKeyspace)msg).keyspace);</span>
            }
        };

        @Override
        public String toString()
        {
<span class="nc" id="L168">            return &quot;RESULT set keyspace &quot; + keyspace;</span>
        }
    }

    public static class Rows extends ResultMessage
    {
<span class="fc" id="L174">        public static final Message.Codec&lt;ResultMessage&gt; subcodec = new Message.Codec&lt;ResultMessage&gt;()</span>
<span class="fc" id="L175">        {</span>
            public ResultMessage decode(ByteBuf body, ProtocolVersion version)
            {
<span class="fc" id="L178">                return new Rows(ResultSet.codec.decode(body, version));</span>
            }

            public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
            {
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">                assert msg instanceof Rows;</span>
<span class="fc" id="L184">                Rows rowMsg = (Rows)msg;</span>
<span class="fc" id="L185">                ResultSet.codec.encode(rowMsg.result, dest, version);</span>
<span class="fc" id="L186">            }</span>

            public int encodedSize(ResultMessage msg, ProtocolVersion version)
            {
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">                assert msg instanceof Rows;</span>
<span class="fc" id="L191">                Rows rowMsg = (Rows)msg;</span>
<span class="fc" id="L192">                return ResultSet.codec.encodedSize(rowMsg.result, version);</span>
            }
        };

        public final ResultSet result;

        public Rows(ResultSet result)
        {
<span class="fc" id="L200">            super(Kind.ROWS);</span>
<span class="fc" id="L201">            this.result = result;</span>
<span class="fc" id="L202">        }</span>

        @Override
        public String toString()
        {
<span class="nc" id="L207">            return &quot;ROWS &quot; + result;</span>
        }
    }

    public static class Prepared extends ResultMessage
    {
<span class="fc" id="L213">        public static final Message.Codec&lt;ResultMessage&gt; subcodec = new Message.Codec&lt;ResultMessage&gt;()</span>
<span class="fc" id="L214">        {</span>
            public ResultMessage decode(ByteBuf body, ProtocolVersion version)
            {
<span class="fc" id="L217">                MD5Digest id = MD5Digest.wrap(CBUtil.readBytes(body));</span>
<span class="fc" id="L218">                MD5Digest resultMetadataId = null;</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">                if (version.isGreaterOrEqualTo(ProtocolVersion.V5))</span>
<span class="fc" id="L220">                    resultMetadataId = MD5Digest.wrap(CBUtil.readBytes(body));</span>
<span class="fc" id="L221">                ResultSet.PreparedMetadata metadata = ResultSet.PreparedMetadata.codec.decode(body, version);</span>

<span class="fc" id="L223">                ResultSet.ResultMetadata resultMetadata = ResultSet.ResultMetadata.EMPTY;</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">                if (version.isGreaterThan(ProtocolVersion.V1))</span>
<span class="fc" id="L225">                    resultMetadata = ResultSet.ResultMetadata.codec.decode(body, version);</span>

<span class="fc" id="L227">                return new Prepared(id, resultMetadataId, metadata, resultMetadata);</span>
            }

            public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
            {
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">                assert msg instanceof Prepared;</span>
<span class="fc" id="L233">                Prepared prepared = (Prepared)msg;</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">                assert prepared.statementId != null;</span>

<span class="fc" id="L236">                CBUtil.writeBytes(prepared.statementId.bytes, dest);</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">                if (version.isGreaterOrEqualTo(ProtocolVersion.V5))</span>
<span class="fc" id="L238">                    CBUtil.writeBytes(prepared.resultMetadataId.bytes, dest);</span>

<span class="fc" id="L240">                ResultSet.PreparedMetadata.codec.encode(prepared.metadata, dest, version);</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">                if (version.isGreaterThan(ProtocolVersion.V1))</span>
<span class="fc" id="L242">                    ResultSet.ResultMetadata.codec.encode(prepared.resultMetadata, dest, version);</span>
<span class="fc" id="L243">            }</span>

            public int encodedSize(ResultMessage msg, ProtocolVersion version)
            {
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">                assert msg instanceof Prepared;</span>
<span class="fc" id="L248">                Prepared prepared = (Prepared)msg;</span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">                assert prepared.statementId != null;</span>

<span class="fc" id="L251">                int size = 0;</span>
<span class="fc" id="L252">                size += CBUtil.sizeOfBytes(prepared.statementId.bytes);</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">                if (version.isGreaterOrEqualTo(ProtocolVersion.V5))</span>
<span class="fc" id="L254">                    size += CBUtil.sizeOfBytes(prepared.resultMetadataId.bytes);</span>
<span class="fc" id="L255">                size += ResultSet.PreparedMetadata.codec.encodedSize(prepared.metadata, version);</span>
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">                if (version.isGreaterThan(ProtocolVersion.V1))</span>
<span class="fc" id="L257">                    size += ResultSet.ResultMetadata.codec.encodedSize(prepared.resultMetadata, version);</span>
<span class="fc" id="L258">                return size;</span>
            }
        };

        public final MD5Digest statementId;
        public final MD5Digest resultMetadataId;

        /** Describes the variables to be bound in the prepared statement */
        public final ResultSet.PreparedMetadata metadata;

        /** Describes the results of executing this prepared statement */
        public final ResultSet.ResultMetadata resultMetadata;

        public Prepared(MD5Digest statementId, MD5Digest resultMetadataId, ResultSet.PreparedMetadata metadata, ResultSet.ResultMetadata resultMetadata)
        {
<span class="fc" id="L273">            super(Kind.PREPARED);</span>
<span class="fc" id="L274">            this.statementId = statementId;</span>
<span class="fc" id="L275">            this.resultMetadataId = resultMetadataId;</span>
<span class="fc" id="L276">            this.metadata = metadata;</span>
<span class="fc" id="L277">            this.resultMetadata = resultMetadata;</span>
<span class="fc" id="L278">        }</span>

        @VisibleForTesting
        public Prepared withResultMetadata(ResultSet.ResultMetadata resultMetadata)
        {
<span class="fc" id="L283">            return new Prepared(statementId, resultMetadata.getResultMetadataId(), metadata, resultMetadata);</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L289">            return &quot;RESULT PREPARED &quot; + statementId + &quot; &quot; + metadata + &quot; (resultMetadata=&quot; + resultMetadata + &quot;)&quot;;</span>
        }
    }

    public static class SchemaChange extends ResultMessage
    {
        public final Event.SchemaChange change;

        public SchemaChange(Event.SchemaChange change)
        {
<span class="fc" id="L299">            super(Kind.SCHEMA_CHANGE);</span>
<span class="fc" id="L300">            this.change = change;</span>
<span class="fc" id="L301">        }</span>

<span class="fc" id="L303">        public static final Message.Codec&lt;ResultMessage&gt; subcodec = new Message.Codec&lt;ResultMessage&gt;()</span>
<span class="fc" id="L304">        {</span>
            public ResultMessage decode(ByteBuf body, ProtocolVersion version)
            {
<span class="fc" id="L307">                return new SchemaChange(Event.SchemaChange.deserializeEvent(body, version));</span>
            }

            public void encode(ResultMessage msg, ByteBuf dest, ProtocolVersion version)
            {
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">                assert msg instanceof SchemaChange;</span>
<span class="fc" id="L313">                SchemaChange scm = (SchemaChange)msg;</span>
<span class="fc" id="L314">                scm.change.serializeEvent(dest, version);</span>
<span class="fc" id="L315">            }</span>

            public int encodedSize(ResultMessage msg, ProtocolVersion version)
            {
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">                assert msg instanceof SchemaChange;</span>
<span class="fc" id="L320">                SchemaChange scm = (SchemaChange)msg;</span>
<span class="fc" id="L321">                return scm.change.eventSerializedSize(version);</span>
            }
        };

        @Override
        public String toString()
        {
<span class="nc" id="L328">            return &quot;RESULT schema change &quot; + change;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>