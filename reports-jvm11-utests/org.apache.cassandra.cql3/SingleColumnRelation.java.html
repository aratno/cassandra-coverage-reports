<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SingleColumnRelation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3</a> &gt; <span class="el_source">SingleColumnRelation.java</span></div><h1>SingleColumnRelation.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3;

import java.util.Collections;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.cql3.Term.Raw;
import org.apache.cassandra.cql3.restrictions.Restriction;
import org.apache.cassandra.cql3.restrictions.SingleColumnRestriction;
import org.apache.cassandra.cql3.statements.Bound;
import org.apache.cassandra.db.marshal.CollectionType;
import org.apache.cassandra.db.marshal.ListType;
import org.apache.cassandra.db.marshal.MapType;
import org.apache.cassandra.exceptions.InvalidRequestException;

import static org.apache.cassandra.cql3.statements.RequestValidations.checkFalse;
import static org.apache.cassandra.cql3.statements.RequestValidations.checkTrue;
import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;

/**
 * Relations encapsulate the relationship between an entity of some kind, and
 * a value (term). For example, {@code &lt;key&gt; &gt; &quot;start&quot; or &quot;colname1&quot; = &quot;somevalue&quot;}.
 *
 */
<span class="fc" id="L45">public final class SingleColumnRelation extends Relation</span>
{
    private final ColumnIdentifier entity;
    private final Term.Raw mapKey;
    private final Term.Raw value;
    private final List&lt;Term.Raw&gt; inValues;

    private SingleColumnRelation(ColumnIdentifier entity, Term.Raw mapKey, Operator type, Term.Raw value, List&lt;Term.Raw&gt; inValues)
<span class="fc" id="L53">    {</span>
<span class="fc" id="L54">        this.entity = entity;</span>
<span class="fc" id="L55">        this.mapKey = mapKey;</span>
<span class="fc" id="L56">        this.relationType = type;</span>
<span class="fc" id="L57">        this.value = value;</span>
<span class="fc" id="L58">        this.inValues = inValues;</span>

<span class="fc bfc" id="L60" title="All 2 branches covered.">        if (type == Operator.IS_NOT)</span>
<span class="pc bpc" id="L61" title="1 of 2 branches missed.">            assert value == Constants.NULL_LITERAL;</span>
<span class="fc" id="L62">    }</span>

    /**
     * Creates a new relation.
     *
     * @param entity the kind of relation this is; what the term is being compared to.
     * @param mapKey the key into the entity identifying the value the term is being compared to.
     * @param type the type that describes how this entity relates to the value.
     * @param value the value being compared.
     */
    public SingleColumnRelation(ColumnIdentifier entity, Term.Raw mapKey, Operator type, Term.Raw value)
    {
<span class="fc" id="L74">        this(entity, mapKey, type, value, null);</span>
<span class="fc" id="L75">    }</span>

    /**
     * Creates a new relation.
     *
     * @param entity the kind of relation this is; what the term is being compared to.
     * @param type the type that describes how this entity relates to the value.
     * @param value the value being compared.
     */
    public SingleColumnRelation(ColumnIdentifier entity, Operator type, Term.Raw value)
    {
<span class="fc" id="L86">        this(entity, null, type, value);</span>
<span class="fc" id="L87">    }</span>

    public Term.Raw getValue()
    {
<span class="nc" id="L91">        return value;</span>
    }

    public List&lt;? extends Term.Raw&gt; getInValues()
    {
<span class="nc" id="L96">        return inValues;</span>
    }

    public static SingleColumnRelation createInRelation(ColumnIdentifier entity, List&lt;Term.Raw&gt; inValues)
    {
<span class="fc" id="L101">        return new SingleColumnRelation(entity, null, Operator.IN, null, inValues);</span>
    }

    public ColumnIdentifier getEntity()
    {
<span class="nc" id="L106">        return entity;</span>
    }

    public Term.Raw getMapKey()
    {
<span class="nc" id="L111">        return mapKey;</span>
    }

    @Override
    protected Term toTerm(List&lt;? extends ColumnSpecification&gt; receivers,
                          Raw raw,
                          String keyspace,
                          VariableSpecifications boundNames)
                          throws InvalidRequestException
    {
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">        assert receivers.size() == 1;</span>

<span class="fc" id="L123">        Term term = raw.prepare(keyspace, receivers.get(0));</span>
<span class="fc" id="L124">        term.collectMarkerSpecification(boundNames);</span>
<span class="fc" id="L125">        return term;</span>
    }

    public SingleColumnRelation withNonStrictOperator()
    {
<span class="nc bnc" id="L130" title="All 3 branches missed.">        switch (relationType)</span>
        {
<span class="nc" id="L132">            case GT: return new SingleColumnRelation(entity, Operator.GTE, value);</span>
<span class="nc" id="L133">            case LT: return new SingleColumnRelation(entity, Operator.LTE, value);</span>
<span class="nc" id="L134">            default: return this;</span>
        }
    }

    public Relation renameIdentifier(ColumnIdentifier from, ColumnIdentifier to)
    {
<span class="fc bfc" id="L140" title="All 2 branches covered.">        return entity.equals(from)</span>
<span class="fc" id="L141">               ? new SingleColumnRelation(to, mapKey, operator(), value, inValues)</span>
<span class="fc" id="L142">               : this;</span>
    }

    @Override
    public String toCQLString()
    {
<span class="fc" id="L148">        String entityAsString = entity.toCQLString();</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        if (mapKey != null)</span>
<span class="nc" id="L150">            entityAsString = String.format(&quot;%s[%s]&quot;, entityAsString, mapKey);</span>

<span class="fc bfc" id="L152" title="All 2 branches covered.">        if (isIN())</span>
<span class="fc" id="L153">            return String.format(&quot;%s IN %s&quot;, entityAsString, Tuples.tupleToString(inValues));</span>

<span class="fc" id="L155">        return String.format(&quot;%s %s %s&quot;, entityAsString, relationType, value);</span>
    }

    @Override
    public int hashCode()
    {
<span class="fc" id="L161">        return Objects.hash(relationType, entity, mapKey, value, inValues);</span>
    }

    @Override
    public boolean equals(Object o)
    {
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">        if (this == o)</span>
<span class="nc" id="L168">            return true;</span>

<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        if (!(o instanceof SingleColumnRelation))</span>
<span class="nc" id="L171">            return false;</span>

<span class="fc" id="L173">        SingleColumnRelation scr = (SingleColumnRelation) o;</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">        return Objects.equals(entity, scr.entity)</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">            &amp;&amp; Objects.equals(relationType, scr.relationType)</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">            &amp;&amp; Objects.equals(mapKey, scr.mapKey)</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">            &amp;&amp; Objects.equals(value, scr.value)</span>
<span class="pc bnc" id="L178" title="All 2 branches missed.">            &amp;&amp; Objects.equals(inValues, scr.inValues);</span>
    }

    @Override
    protected Restriction newEQRestriction(TableMetadata table, VariableSpecifications boundNames)
    {
<span class="fc" id="L184">        ColumnMetadata columnDef = table.getExistingColumn(entity);</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        if (mapKey == null)</span>
        {
<span class="fc" id="L187">            Term term = toTerm(toReceivers(columnDef), value, table.keyspace, boundNames);</span>
<span class="fc" id="L188">            return new SingleColumnRestriction.EQRestriction(columnDef, term);</span>
        }
<span class="fc" id="L190">        List&lt;? extends ColumnSpecification&gt; receivers = toReceivers(columnDef);</span>
<span class="fc" id="L191">        Term entryKey = toTerm(Collections.singletonList(receivers.get(0)), mapKey, table.keyspace, boundNames);</span>
<span class="fc" id="L192">        Term entryValue = toTerm(Collections.singletonList(receivers.get(1)), value, table.keyspace, boundNames);</span>
<span class="fc" id="L193">        return new SingleColumnRestriction.ContainsRestriction(columnDef, entryKey, entryValue);</span>
    }

    @Override
    protected Restriction newINRestriction(TableMetadata table, VariableSpecifications boundNames)
    {
<span class="fc" id="L199">        ColumnMetadata columnDef = table.getExistingColumn(entity);</span>
<span class="fc" id="L200">        List&lt;? extends ColumnSpecification&gt; receivers = toReceivers(columnDef);</span>
<span class="fc" id="L201">        List&lt;Term&gt; terms = toTerms(receivers, inValues, table.keyspace, boundNames);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (terms == null)</span>
        {
<span class="fc" id="L204">            Term term = toTerm(receivers, value, table.keyspace, boundNames);</span>
<span class="fc" id="L205">            return new SingleColumnRestriction.InRestrictionWithMarker(columnDef, (Lists.Marker) term);</span>
        }

        // An IN restrictions with only one element is the same than an EQ restriction
<span class="fc bfc" id="L209" title="All 2 branches covered.">        if (terms.size() == 1)</span>
<span class="fc" id="L210">            return new SingleColumnRestriction.EQRestriction(columnDef, terms.get(0));</span>

<span class="fc" id="L212">        return new SingleColumnRestriction.InRestrictionWithValues(columnDef, terms);</span>
    }

    @Override
    protected Restriction newSliceRestriction(TableMetadata table,
                                              VariableSpecifications boundNames,
                                              Bound bound,
                                              boolean inclusive)
    {
<span class="fc" id="L221">        ColumnMetadata columnDef = table.getExistingColumn(entity);</span>

<span class="fc bfc" id="L223" title="All 2 branches covered.">        if (columnDef.type.referencesDuration())</span>
        {
<span class="fc" id="L225">            checkFalse(columnDef.type.isCollection(), &quot;Slice restrictions are not supported on collections containing durations&quot;);</span>
<span class="fc" id="L226">            checkFalse(columnDef.type.isTuple(), &quot;Slice restrictions are not supported on tuples containing durations&quot;);</span>
<span class="fc" id="L227">            checkFalse(columnDef.type.isUDT(), &quot;Slice restrictions are not supported on UDTs containing durations&quot;);</span>
<span class="fc" id="L228">            throw invalidRequest(&quot;Slice restrictions are not supported on duration columns&quot;);</span>
        }

<span class="fc" id="L231">        Term term = toTerm(toReceivers(columnDef), value, table.keyspace, boundNames);</span>
<span class="fc" id="L232">        return new SingleColumnRestriction.SliceRestriction(columnDef, bound, inclusive, term);</span>
    }

    @Override
    protected Restriction newContainsRestriction(TableMetadata table,
                                                 VariableSpecifications boundNames,
                                                 boolean isKey) throws InvalidRequestException
    {
<span class="fc" id="L240">        ColumnMetadata columnDef = table.getExistingColumn(entity);</span>
<span class="fc" id="L241">        Term term = toTerm(toReceivers(columnDef), value, table.keyspace, boundNames);</span>
<span class="fc" id="L242">        return new SingleColumnRestriction.ContainsRestriction(columnDef, term, isKey);</span>
    }

    @Override
    protected Restriction newIsNotRestriction(TableMetadata table,
                                              VariableSpecifications boundNames) throws InvalidRequestException
    {
<span class="fc" id="L249">        ColumnMetadata columnDef = table.getExistingColumn(entity);</span>
        // currently enforced by the grammar
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">        assert value == Constants.NULL_LITERAL : &quot;Expected null literal for IS NOT relation: &quot; + this.toString();</span>
<span class="fc" id="L252">        return new SingleColumnRestriction.IsNotNullRestriction(columnDef);</span>
    }

    @Override
    protected Restriction newLikeRestriction(TableMetadata table, VariableSpecifications boundNames, Operator operator)
    {
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">        if (mapKey != null)</span>
<span class="nc" id="L259">            throw invalidRequest(&quot;%s can't be used with collections.&quot;, operator());</span>

<span class="fc" id="L261">        ColumnMetadata columnDef = table.getExistingColumn(entity);</span>
<span class="fc" id="L262">        Term term = toTerm(toReceivers(columnDef), value, table.keyspace, boundNames);</span>

<span class="fc" id="L264">        return new SingleColumnRestriction.LikeRestriction(columnDef, operator, term);</span>
    }

    /**
     * Returns the receivers for this relation.
     * @param columnDef the column definition
     * @return the receivers for the specified relation.
     * @throws InvalidRequestException if the relation is invalid
     */
    private List&lt;? extends ColumnSpecification&gt; toReceivers(ColumnMetadata columnDef) throws InvalidRequestException
    {
<span class="fc" id="L275">        ColumnSpecification receiver = columnDef;</span>

<span class="fc bfc" id="L277" title="All 4 branches covered.">        checkFalse(isContainsKey() &amp;&amp; !(receiver.type instanceof MapType), &quot;Cannot use CONTAINS KEY on non-map column %s&quot;, receiver.name);</span>
<span class="fc bfc" id="L278" title="All 4 branches covered.">        checkFalse(isContains() &amp;&amp; !(receiver.type.isCollection()), &quot;Cannot use CONTAINS on non-collection column %s&quot;, receiver.name);</span>

<span class="fc bfc" id="L280" title="All 2 branches covered.">        if (mapKey != null)</span>
        {
<span class="fc" id="L282">            checkFalse(receiver.type instanceof ListType, &quot;Indexes on list entries (%s[index] = value) are not currently supported.&quot;, receiver.name);</span>
<span class="fc" id="L283">            checkTrue(receiver.type instanceof MapType, &quot;Column %s cannot be used as a map&quot;, receiver.name);</span>
<span class="fc" id="L284">            checkTrue(receiver.type.isMultiCell(), &quot;Map-entry equality predicates on frozen map column %s are not supported&quot;, receiver.name);</span>
<span class="fc" id="L285">            checkTrue(isEQ(), &quot;Only EQ relations are supported on map entries&quot;);</span>
        }

        // Non-frozen UDTs don't support any operator
<span class="fc bfc" id="L289" title="All 4 branches covered.">        checkFalse(receiver.type.isUDT() &amp;&amp; receiver.type.isMultiCell(),</span>
                   &quot;Non-frozen UDT column '%s' (%s) cannot be restricted by any relation&quot;,
                   receiver.name,
<span class="fc" id="L292">                   receiver.type.asCQL3Type());</span>

<span class="fc bfc" id="L294" title="All 2 branches covered.">        if (receiver.type.isCollection())</span>
        {
            // We don't support relations against entire collections (unless they're frozen), like &quot;numbers = {1, 2, 3}&quot;
<span class="fc bfc" id="L297" title="All 4 branches covered.">            checkFalse(receiver.type.isMultiCell() &amp;&amp; !isLegalRelationForNonFrozenCollection(),</span>
                       &quot;Collection column '%s' (%s) cannot be restricted by a '%s' relation&quot;,
                       receiver.name,
<span class="fc" id="L300">                       receiver.type.asCQL3Type(),</span>
<span class="fc" id="L301">                       operator());</span>

<span class="fc bfc" id="L303" title="All 4 branches covered.">            if (isContainsKey() || isContains())</span>
            {
<span class="fc" id="L305">                receiver = makeCollectionReceiver(receiver, isContainsKey());</span>
            }
<span class="pc bpc" id="L307" title="2 of 6 branches missed.">            else if (receiver.type.isMultiCell() &amp;&amp; mapKey != null &amp;&amp; isEQ())</span>
            {
<span class="fc" id="L309">                List&lt;ColumnSpecification&gt; receivers = new ArrayList&lt;&gt;(2);</span>
<span class="fc" id="L310">                receivers.add(makeCollectionReceiver(receiver, true));</span>
<span class="fc" id="L311">                receivers.add(makeCollectionReceiver(receiver, false));</span>
<span class="fc" id="L312">                return receivers;</span>
            }
        }

<span class="fc" id="L316">        return Collections.singletonList(receiver);</span>
    }

    private static ColumnSpecification makeCollectionReceiver(ColumnSpecification receiver, boolean forKey)
    {
<span class="fc" id="L321">        return ((CollectionType&lt;?&gt;) receiver.type).makeCollectionReceiver(receiver, forKey);</span>
    }

    private boolean isLegalRelationForNonFrozenCollection()
    {
<span class="fc bfc" id="L326" title="All 6 branches covered.">        return isContainsKey() || isContains() || isMapEntryEquality();</span>
    }

    private boolean isMapEntryEquality()
    {
<span class="pc bpc" id="L331" title="1 of 4 branches missed.">        return mapKey != null &amp;&amp; isEQ();</span>
    }

    private boolean canHaveOnlyOneValue()
    {
<span class="nc bnc" id="L336" title="All 10 branches missed.">        return isEQ() || isLIKE() || (isIN() &amp;&amp; inValues != null &amp;&amp; inValues.size() == 1);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>