<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AsyncChannelOutputPlus.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.net</a> &gt; <span class="el_source">AsyncChannelOutputPlus.java</span></div><h1>AsyncChannelOutputPlus.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.net;

import java.io.IOException;
import java.nio.channels.WritableByteChannel;
import java.util.concurrent.locks.LockSupport;

import io.netty.channel.Channel;
import io.netty.channel.ChannelPromise;
import org.apache.cassandra.io.util.BufferedDataOutputStreamPlus;
import org.apache.cassandra.io.util.DataOutputStreamPlus;

import static java.lang.Math.max;

/**
 * A {@link DataOutputStreamPlus} that writes ASYNCHRONOUSLY to a Netty Channel.
 *
 * The close() and flush() methods synchronously wait for pending writes, and will propagate any exceptions
 * encountered in writing them to the wire.
 *
 * The correctness of this class depends on the ChannelPromise we create against a Channel always being completed,
 * which appears to be a guarantee provided by Netty so long as the event loop is running.
 *
 * There are two logical threads accessing the state in this class: the eventLoop of the channel, and the writer
 * (the writer thread may change, so long as only one utilises the class at any time).
 * Each thread has exclusive write access to certain state in the class, with the other thread only viewing the state,
 * simplifying concurrency considerations.
 */
<span class="fc" id="L45">public abstract class AsyncChannelOutputPlus extends BufferedDataOutputStreamPlus</span>
{
    public static class FlushException extends IOException
    {
        public FlushException(String message)
        {
<span class="nc" id="L51">            super(message);</span>
<span class="nc" id="L52">        }</span>

        public FlushException(String message, Throwable cause)
        {
<span class="nc" id="L56">            super(message, cause);</span>
<span class="nc" id="L57">        }</span>
    }

    final Channel channel;

    /** the number of bytes we have begun flushing; updated only by writer */
    private volatile long flushing;
    /** the number of bytes we have finished flushing, successfully or otherwise; updated only by eventLoop */
    private volatile long flushed;
    /** the number of bytes we have finished flushing to the network; updated only by eventLoop */
    private          long flushedToNetwork;
    /** any error that has been thrown during a flush; updated only by eventLoop */
    private volatile Throwable flushFailed;

    /**
     * state for pausing until flushing has caught up - store the number of bytes we need to be flushed before
     * we should be signalled, and store ourselves in {@link #waiting}; once the flushing thread exceeds this many
     * total bytes flushed, any Thread stored in waiting will be signalled.
     *
     * This works exactly like using a WaitQueue, except that we only need to manage a single waiting thread.
     */
    private volatile long signalWhenFlushed; // updated only by writer
    private volatile Thread waiting; // updated only by writer

    public AsyncChannelOutputPlus(Channel channel)
    {
<span class="fc" id="L83">        super(null, null);</span>
<span class="fc" id="L84">        this.channel = channel;</span>
<span class="fc" id="L85">    }</span>

    /**
     * Create a ChannelPromise for a flush of the given size.
     * &lt;p&gt;
     * This method will not return until the write is permitted by the provided watermarks and in flight bytes,
     * and on its completion will mark the requested bytes flushed.
     * &lt;p&gt;
     * If this method returns normally, the ChannelPromise MUST be writtenAndFlushed, or else completed exceptionally.
     */
    protected ChannelPromise beginFlush(long byteCount, long lowWaterMark, long highWaterMark) throws IOException
    {
<span class="fc" id="L97">        waitForSpace(byteCount, lowWaterMark, highWaterMark);</span>

<span class="fc" id="L99">        return AsyncChannelPromise.withListener(channel, future -&gt; {</span>
<span class="pc bpc" id="L100" title="2 of 4 branches missed.">            if (future.isSuccess() &amp;&amp; null == flushFailed)</span>
            {
<span class="fc" id="L102">                flushedToNetwork += byteCount;</span>
<span class="fc" id="L103">                releaseSpace(byteCount);</span>
            }
<span class="nc bnc" id="L105" title="All 2 branches missed.">            else if (null == flushFailed)</span>
            {
<span class="nc" id="L107">                Throwable cause = future.cause();</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">                if (cause == null)</span>
                {
<span class="nc" id="L110">                    cause = new FlushException(&quot;Flush failed for unknown reason&quot;);</span>
<span class="nc" id="L111">                    cause.fillInStackTrace();</span>
                }
<span class="nc" id="L113">                flushFailed = cause;</span>
<span class="nc" id="L114">                releaseSpace(flushing - flushed);</span>
<span class="nc" id="L115">            }</span>
            else
            {
<span class="nc bnc" id="L118" title="All 2 branches missed.">                assert flushing == flushed;</span>
            }
<span class="fc" id="L120">        });</span>
    }

    /**
     * Imposes our lowWaterMark/highWaterMark constraints, and propagates any exceptions thrown by prior flushes.
     *
     * If we currently have lowWaterMark or fewer bytes flushing, we are good to go.
     * If our new write will not take us over our highWaterMark, we are good to go.
     * Otherwise, we wait until either of these conditions are met.
     *
     * This may only be invoked by the writer thread, never by the eventLoop.
     *
     * @throws IOException if a prior asynchronous flush failed
     */
    private void waitForSpace(long bytesToWrite, long lowWaterMark, long highWaterMark) throws IOException
    {
        // decide when we would be willing to carry on writing
        // we are always writable if we have lowWaterMark or fewer bytes, no matter how many bytes we are flushing
        // our callers should not be supplying more than (highWaterMark - lowWaterMark) bytes, but we must work correctly if they do
<span class="fc" id="L139">        long wakeUpWhenFlushing = highWaterMark - bytesToWrite;</span>
<span class="fc" id="L140">        waitUntilFlushed(max(lowWaterMark, wakeUpWhenFlushing), lowWaterMark);</span>
<span class="fc" id="L141">        flushing += bytesToWrite;</span>
<span class="fc" id="L142">    }</span>

    /**
     * Implementation of waitForSpace, which calculates what flushed points we need to wait for,
     * parks if necessary and propagates flush failures.
     *
     * This may only be invoked by the writer thread, never by the eventLoop.
     */
    void waitUntilFlushed(long wakeUpWhenExcessBytesWritten, long signalWhenExcessBytesWritten) throws IOException
    {
        // we assume that we are happy to wake up at least as early as we will be signalled; otherwise we will never exit
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">        assert signalWhenExcessBytesWritten &lt;= wakeUpWhenExcessBytesWritten;</span>
        // flushing shouldn't change during this method invocation, so our calculations for signal and flushed are consistent
<span class="fc" id="L155">        long wakeUpWhenFlushed = flushing - wakeUpWhenExcessBytesWritten;</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">        if (flushed &lt; wakeUpWhenFlushed)</span>
<span class="fc" id="L157">            parkUntilFlushed(wakeUpWhenFlushed, flushing - signalWhenExcessBytesWritten);</span>
<span class="fc" id="L158">        propagateFailedFlush();</span>
<span class="fc" id="L159">    }</span>

    /**
     * Utility method for waitUntilFlushed, which actually parks the current thread until the necessary
     * number of bytes have been flushed
     *
     * This may only be invoked by the writer thread, never by the eventLoop.
     */
    protected void parkUntilFlushed(long wakeUpWhenFlushed, long signalWhenFlushed)
    {
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">        assert wakeUpWhenFlushed &lt;= signalWhenFlushed;</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        assert waiting == null;</span>
<span class="fc" id="L171">        this.waiting = Thread.currentThread();</span>
<span class="fc" id="L172">        this.signalWhenFlushed = signalWhenFlushed;</span>

<span class="fc bfc" id="L174" title="All 2 branches covered.">        while (flushed &lt; wakeUpWhenFlushed)</span>
<span class="fc" id="L175">            LockSupport.park();</span>
<span class="fc" id="L176">        waiting = null;</span>
<span class="fc" id="L177">    }</span>

    /**
     * Update our flushed count, and signal any waiters.
     *
     * This may only be invoked by the eventLoop, never by the writer thread.
     */
    protected void releaseSpace(long bytesFlushed)
    {
<span class="fc" id="L186">        long newFlushed = flushed + bytesFlushed;</span>
<span class="fc" id="L187">        flushed = newFlushed;</span>

<span class="fc" id="L189">        Thread thread = waiting;</span>
<span class="fc bfc" id="L190" title="All 4 branches covered.">        if (thread != null &amp;&amp; signalWhenFlushed &lt;= newFlushed)</span>
<span class="fc" id="L191">            LockSupport.unpark(thread);</span>
<span class="fc" id="L192">    }</span>

    private void propagateFailedFlush() throws IOException
    {
<span class="fc" id="L196">        Throwable t = flushFailed;</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (t != null)</span>
        {
<span class="nc bnc" id="L199" title="All 2 branches missed.">            if (SocketFactory.isCausedByConnectionReset(t))</span>
<span class="nc" id="L200">                throw new FlushException(&quot;The channel this output stream was writing to has been closed&quot;, t);</span>
<span class="nc" id="L201">            throw new FlushException(&quot;This output stream is in an unsafe state after an asynchronous flush failed&quot;, t);</span>
        }
<span class="fc" id="L203">    }</span>

    @Override
    abstract protected void doFlush(int count) throws IOException;

    abstract public long position();

    public long flushed()
    {
        // external flushed (that which has had flush() invoked implicitly or otherwise) == internal flushing
<span class="fc" id="L213">        return flushing;</span>
    }

    public long flushedToNetwork()
    {
<span class="fc" id="L218">        return flushedToNetwork;</span>
    }

    /**
     * Perform an asynchronous flush, then waits until all outstanding flushes have completed
     *
     * @throws IOException if any flush fails
     */
    @Override
    public void flush() throws IOException
    {
<span class="fc" id="L229">        doFlush(0);</span>
<span class="fc" id="L230">        waitUntilFlushed(0, 0);</span>
<span class="fc" id="L231">    }</span>

    /**
     * Flush any remaining writes, and release any buffers.
     *
     * The channel is not closed, as it is assumed to be managed externally.
     *
     * WARNING: This method requires mutual exclusivity with all other producer methods to run safely.
     * It should only be invoked by the owning thread, never the eventLoop; the eventLoop should propagate
     * errors to {@link #flushFailed}, which will propagate them to the producer thread no later than its
     * final invocation to {@link #close()} or {@link #flush()} (that must not be followed by any further writes).
     */
    @Override
    public void close() throws IOException
    {
        try
        {
<span class="fc" id="L248">            flush();</span>
        }
        finally
        {
<span class="fc" id="L252">            discard();</span>
        }
<span class="fc" id="L254">    }</span>

    /**
     * Discard any buffered data, and the buffers that contain it.
     * May be invoked instead of {@link #close()} if we terminate exceptionally.
     */
    public abstract void discard();

    @Override
    protected WritableByteChannel newDefaultChannel()
    {
<span class="nc" id="L265">        throw new UnsupportedOperationException();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>