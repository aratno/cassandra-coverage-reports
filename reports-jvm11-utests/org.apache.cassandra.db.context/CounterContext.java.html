<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CounterContext.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.context</a> &gt; <span class="el_source">CounterContext.java</span></div><h1>CounterContext.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.context;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;

import com.google.common.annotations.VisibleForTesting;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.db.ClockAndCount;
import org.apache.cassandra.db.TypeSizes;
import org.apache.cassandra.db.compaction.CompactionManager;
import org.apache.cassandra.db.marshal.ByteBufferAccessor;
import org.apache.cassandra.db.marshal.ValueAccessor;
import org.apache.cassandra.db.rows.Cell;
import org.apache.cassandra.serializers.MarshalException;
import org.apache.cassandra.utils.*;

/**
 * An implementation of a partitioned counter context.
 *
 * A context is primarily a list of tuples (counter id, clock, count) -- called
 * shards, with some shards flagged as global or local (with
 * special resolution rules in merge()).
 *
 * The data structure has two parts:
 *   a) a header containing the lists of global and local shard indexes in the body
 *   b) a list of shards -- (counter id, logical clock, count) tuples -- (the so-called 'body' below)
 *
 * The exact layout is:
 *            | header  |   body   |
 * context :  |--|------|----------|
 *             ^     ^
 *             |   list of indices in the body list (2*#elt bytes)
 *    #elt in rest of header (2 bytes)
 *
 * Non-negative indices refer to local shards. Global shard indices are encoded as [idx + Short.MIN_VALUE],
 * and are thus always negative.
 *
 * The body layout being:
 *
 * body:     |----|----|----|----|----|----|....
 *             ^    ^    ^     ^   ^    ^
 *             |    |  count_1 |   |   count_2
 *             |  clock_1      |  clock_2
 *       counterid_1         counterid_2
 *
 * The rules when merging two shard with the same counter id are:
 *   - global + global = keep the shard with the highest logical clock
 *   - global + local  = keep the global one
 *   - global + remote = keep the global one
 *   - local  + local  = sum counts (and logical clocks)
 *   - local  + remote = keep the local one
 *   - remote + remote = keep the shard with the highest logical clock
 *
 * For a detailed description of the meaning of a local and why the merging
 * rules work this way, see CASSANDRA-1938 - specifically the 1938_discussion
 * attachment (doesn't cover global shards, see CASSANDRA-4775 for that).
 */
<span class="fc" id="L78">public class CounterContext</span>
{
<span class="fc" id="L80">    private static final int HEADER_SIZE_LENGTH = TypeSizes.sizeof(Short.MAX_VALUE);</span>
<span class="fc" id="L81">    private static final int HEADER_ELT_LENGTH = TypeSizes.sizeof(Short.MAX_VALUE);</span>
<span class="fc" id="L82">    private static final int CLOCK_LENGTH = TypeSizes.sizeof(Long.MAX_VALUE);</span>
<span class="fc" id="L83">    private static final int COUNT_LENGTH = TypeSizes.sizeof(Long.MAX_VALUE);</span>
<span class="fc" id="L84">    private static final int STEP_LENGTH = CounterId.LENGTH + CLOCK_LENGTH + COUNT_LENGTH;</span>

    /*
     * A special hard-coded value we use for clock ids to differentiate between regular local shards
     * and 'fake' local shards used to emulate pre-3.0 CounterUpdateCell-s in UpdateParameters.
     *
     * Important for handling counter writes and reads during rolling 2.1/2.2 -&gt; 3.0 upgrades.
     */
<span class="fc" id="L92">    static final CounterId UPDATE_CLOCK_ID = CounterId.fromInt(0);</span>

<span class="fc" id="L94">    private static final Logger logger = LoggerFactory.getLogger(CounterContext.class);</span>

<span class="fc" id="L96">    public enum Relationship</span>
    {
<span class="fc" id="L98">        EQUAL, GREATER_THAN, LESS_THAN, DISJOINT</span>
    }

    // lazy-load singleton
    private static class LazyHolder
    {
<span class="fc" id="L104">        private static final CounterContext counterContext = new CounterContext();</span>
    }

    public static CounterContext instance()
    {
<span class="fc" id="L109">        return LazyHolder.counterContext;</span>
    }

    /**
     * Creates a counter context with a single local shard with clock id of UPDATE_CLOCK_ID.
     *
     * This is only used in a PartitionUpdate until the update has gone through
     * CounterMutation.apply(), at which point this special local shard will be replaced by a regular global one.
     * It should never hit commitlog / memtable / disk, but can hit network.
     *
     * We use this so that if an update statement has multiple increments of the same counter we properly
     * add them rather than keeping only one of them.
     *
     * NOTE: Before CASSANDRA-13691 we used a regular local shard without a hard-coded clock id value here.
     * It was problematic, because it was possible to return a false positive, and on read path encode an old counter
     * cell from 2.0 era with a regular local shard as a counter update, and to break the 2.1 coordinator.
     */
    public ByteBuffer createUpdate(long count)
    {
<span class="fc" id="L128">        ContextState state = ContextState.allocate(0, 1, 0);</span>
<span class="fc" id="L129">        state.writeLocal(UPDATE_CLOCK_ID, 1L, count);</span>
<span class="fc" id="L130">        return state.context;</span>
    }

    /**
     * Checks if a context is an update (see createUpdate() for justification).
     */
    public boolean isUpdate(ByteBuffer context)
    {
<span class="fc" id="L138">        return ContextState.wrap(context).getCounterId().equals(UPDATE_CLOCK_ID);</span>
    }

    /**
     * Creates a counter context with a single global, 2.1+ shard (a result of increment).
     */
    public ByteBuffer createGlobal(CounterId id, long clock, long count)
    {
<span class="fc" id="L146">        ContextState state = ContextState.allocate(1, 0, 0);</span>
<span class="fc" id="L147">        state.writeGlobal(id, clock, count);</span>
<span class="fc" id="L148">        return state.context;</span>
    }

    /**
     * Creates a counter context with a single local shard.
     * For use by tests of compatibility with pre-2.1 counters only.
     */
    public ByteBuffer createLocal(long count)
    {
<span class="fc" id="L157">        ContextState state = ContextState.allocate(0, 1, 0);</span>
<span class="fc" id="L158">        state.writeLocal(CounterId.getLocalId(), 1L, count);</span>
<span class="fc" id="L159">        return state.context;</span>
    }

    /**
     * Creates a counter context with a single remote shard.
     * For use by tests of compatibility with pre-2.1 counters only.
     */
    public ByteBuffer createRemote(CounterId id, long clock, long count)
    {
<span class="nc" id="L168">        ContextState state = ContextState.allocate(0, 0, 1);</span>
<span class="nc" id="L169">        state.writeRemote(id, clock, count);</span>
<span class="nc" id="L170">        return state.context;</span>
    }

    public static &lt;V&gt; int headerLength(V context, ValueAccessor&lt;V&gt; accessor)
    {
<span class="fc" id="L175">        return HEADER_SIZE_LENGTH + Math.abs(accessor.getShort(context, 0)) * HEADER_ELT_LENGTH;</span>
    }

    private static int compareId(ByteBuffer bb1, int pos1, ByteBuffer bb2, int pos2)
    {
<span class="fc" id="L180">        return ByteBufferUtil.compareSubArrays(bb1, pos1, bb2, pos2, CounterId.LENGTH);</span>
    }

    /**
     * Determine the count relationship between two contexts.
     *
     * EQUAL:        Equal set of nodes and every count is equal.
     * GREATER_THAN: Superset of nodes and every count is equal or greater than its corollary.
     * LESS_THAN:    Subset of nodes and every count is equal or less than its corollary.
     * DISJOINT:     Node sets are not equal and/or counts are not all greater or less than.
     *
     * Strategy: compare node logical clocks (like a version vector).
     *
     * @param left counter context.
     * @param right counter context.
     * @return the Relationship between the contexts.
     */
    public Relationship diff(ByteBuffer left, ByteBuffer right)
    {
<span class="fc" id="L199">        Relationship relationship = Relationship.EQUAL;</span>
<span class="fc" id="L200">        ContextState leftState = ContextState.wrap(left);</span>
<span class="fc" id="L201">        ContextState rightState = ContextState.wrap(right);</span>

<span class="fc bfc" id="L203" title="All 4 branches covered.">        while (leftState.hasRemaining() &amp;&amp; rightState.hasRemaining())</span>
        {
            // compare id bytes
<span class="fc" id="L206">            int compareId = leftState.compareIdTo(rightState);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">            if (compareId == 0)</span>
            {
<span class="fc" id="L209">                long leftClock  = leftState.getClock();</span>
<span class="fc" id="L210">                long rightClock = rightState.getClock();</span>
<span class="fc" id="L211">                long leftCount = leftState.getCount();</span>
<span class="fc" id="L212">                long rightCount = rightState.getCount();</span>

                // advance
<span class="fc" id="L215">                leftState.moveToNext();</span>
<span class="fc" id="L216">                rightState.moveToNext();</span>

                // process clock comparisons
<span class="fc bfc" id="L219" title="All 2 branches covered.">                if (leftClock == rightClock)</span>
                {
<span class="fc bfc" id="L221" title="All 2 branches covered.">                    if (leftCount != rightCount)</span>
                    {
                        // Inconsistent shard (see the corresponding code in merge()). We return DISJOINT in this
                        // case so that it will be treated as a difference, allowing read-repair to work.
<span class="fc" id="L225">                        return Relationship.DISJOINT;</span>
                    }
                }
<span class="pc bpc" id="L228" title="7 of 12 branches missed.">                else if ((leftClock &gt;= 0 &amp;&amp; rightClock &gt; 0 &amp;&amp; leftClock &gt; rightClock)</span>
                      || (leftClock &lt; 0 &amp;&amp; (rightClock &gt; 0 || leftClock &lt; rightClock)))
                {
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">                    if (relationship == Relationship.EQUAL)</span>
<span class="fc" id="L232">                        relationship = Relationship.GREATER_THAN;</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">                    else if (relationship == Relationship.LESS_THAN)</span>
<span class="nc" id="L234">                        return Relationship.DISJOINT;</span>
                    // relationship == Relationship.GREATER_THAN
                }
                else
                {
<span class="fc bfc" id="L239" title="All 2 branches covered.">                    if (relationship == Relationship.EQUAL)</span>
<span class="fc" id="L240">                        relationship = Relationship.LESS_THAN;</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">                    else if (relationship == Relationship.GREATER_THAN)</span>
<span class="fc" id="L242">                        return Relationship.DISJOINT;</span>
                    // relationship == Relationship.LESS_THAN
                }
<span class="fc" id="L245">            }</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">            else if (compareId &gt; 0)</span>
            {
                // only advance the right context
<span class="fc" id="L249">                rightState.moveToNext();</span>

<span class="fc bfc" id="L251" title="All 2 branches covered.">                if (relationship == Relationship.EQUAL)</span>
<span class="fc" id="L252">                    relationship = Relationship.LESS_THAN;</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">                else if (relationship == Relationship.GREATER_THAN)</span>
<span class="fc" id="L254">                    return Relationship.DISJOINT;</span>
                // relationship == Relationship.LESS_THAN
            }
            else // compareId &lt; 0
            {
                // only advance the left context
<span class="fc" id="L260">                leftState.moveToNext();</span>

<span class="fc bfc" id="L262" title="All 2 branches covered.">                if (relationship == Relationship.EQUAL)</span>
<span class="fc" id="L263">                    relationship = Relationship.GREATER_THAN;</span>
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">                else if (relationship == Relationship.LESS_THAN)</span>
<span class="fc" id="L265">                    return Relationship.DISJOINT;</span>
                // relationship == Relationship.GREATER_THAN
            }
<span class="fc" id="L268">        }</span>

        // check final lengths
<span class="fc bfc" id="L271" title="All 2 branches covered.">        if (leftState.hasRemaining())</span>
        {
<span class="fc bfc" id="L273" title="All 2 branches covered.">            if (relationship == Relationship.EQUAL)</span>
<span class="fc" id="L274">                return Relationship.GREATER_THAN;</span>
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">            else if (relationship == Relationship.LESS_THAN)</span>
<span class="fc" id="L276">                return Relationship.DISJOINT;</span>
        }

<span class="fc bfc" id="L279" title="All 2 branches covered.">        if (rightState.hasRemaining())</span>
        {
<span class="fc bfc" id="L281" title="All 2 branches covered.">            if (relationship == Relationship.EQUAL)</span>
<span class="fc" id="L282">                return Relationship.LESS_THAN;</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">            else if (relationship == Relationship.GREATER_THAN)</span>
<span class="fc" id="L284">                return Relationship.DISJOINT;</span>
        }

<span class="fc" id="L287">        return relationship;</span>
    }

    /**
     * Return a context w/ an aggregated count for each counter id.
     *
     * @param left counter context.
     * @param right counter context.
     */
    public ByteBuffer merge(ByteBuffer left, ByteBuffer right)
    {
<span class="fc" id="L298">        boolean leftIsSuperSet = true;</span>
<span class="fc" id="L299">        boolean rightIsSuperSet = true;</span>

<span class="fc" id="L301">        int globalCount = 0;</span>
<span class="fc" id="L302">        int localCount = 0;</span>
<span class="fc" id="L303">        int remoteCount = 0;</span>

<span class="fc" id="L305">        ContextState leftState = ContextState.wrap(left);</span>
<span class="fc" id="L306">        ContextState rightState = ContextState.wrap(right);</span>

<span class="pc bpc" id="L308" title="1 of 4 branches missed.">        while (leftState.hasRemaining() &amp;&amp; rightState.hasRemaining())</span>
        {
<span class="fc" id="L310">            int cmp = leftState.compareIdTo(rightState);</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">            if (cmp == 0)</span>
            {
<span class="fc" id="L313">                Relationship rel = compare(leftState, rightState);</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">                if (rel == Relationship.GREATER_THAN)</span>
<span class="fc" id="L315">                    rightIsSuperSet = false;</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">                else if (rel == Relationship.LESS_THAN)</span>
<span class="fc" id="L317">                    leftIsSuperSet = false;</span>
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">                else if (rel == Relationship.DISJOINT)</span>
<span class="fc" id="L319">                    leftIsSuperSet = rightIsSuperSet = false;</span>

<span class="pc bpc" id="L321" title="1 of 4 branches missed.">                if (leftState.isGlobal() || rightState.isGlobal())</span>
<span class="fc" id="L322">                    globalCount += 1;</span>
<span class="pc bpc" id="L323" title="1 of 4 branches missed.">                else if (leftState.isLocal() || rightState.isLocal())</span>
<span class="fc" id="L324">                    localCount += 1;</span>
                else
<span class="fc" id="L326">                    remoteCount += 1;</span>

<span class="fc" id="L328">                leftState.moveToNext();</span>
<span class="fc" id="L329">                rightState.moveToNext();</span>
<span class="fc" id="L330">            }</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">            else if (cmp &gt; 0)</span>
            {
<span class="fc" id="L333">                leftIsSuperSet = false;</span>

<span class="pc bpc" id="L335" title="1 of 2 branches missed.">                if (rightState.isGlobal())</span>
<span class="nc" id="L336">                    globalCount += 1;</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">                else if (rightState.isLocal())</span>
<span class="nc" id="L338">                    localCount += 1;</span>
                else
<span class="fc" id="L340">                    remoteCount += 1;</span>

<span class="fc" id="L342">                rightState.moveToNext();</span>
            }
            else // cmp &lt; 0
            {
<span class="fc" id="L346">                rightIsSuperSet = false;</span>

<span class="fc bfc" id="L348" title="All 2 branches covered.">                if (leftState.isGlobal())</span>
<span class="fc" id="L349">                    globalCount += 1;</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">                else if (leftState.isLocal())</span>
<span class="nc" id="L351">                    localCount += 1;</span>
                else
<span class="fc" id="L353">                    remoteCount += 1;</span>

<span class="fc" id="L355">                leftState.moveToNext();</span>
            }
<span class="fc" id="L357">        }</span>

<span class="pc bpc" id="L359" title="1 of 2 branches missed.">        if (leftState.hasRemaining())</span>
<span class="nc" id="L360">            rightIsSuperSet = false;</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">        else if (rightState.hasRemaining())</span>
<span class="fc" id="L362">            leftIsSuperSet = false;</span>

        // if one of the contexts is a superset, return it early.
<span class="fc bfc" id="L365" title="All 2 branches covered.">        if (leftIsSuperSet)</span>
<span class="fc" id="L366">            return left;</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">        else if (rightIsSuperSet)</span>
<span class="fc" id="L368">            return right;</span>

<span class="pc bpc" id="L370" title="1 of 2 branches missed.">        while (leftState.hasRemaining())</span>
        {
<span class="nc bnc" id="L372" title="All 2 branches missed.">            if (leftState.isGlobal())</span>
<span class="nc" id="L373">                globalCount += 1;</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">            else if (leftState.isLocal())</span>
<span class="nc" id="L375">                localCount += 1;</span>
            else
<span class="nc" id="L377">                remoteCount += 1;</span>

<span class="nc" id="L379">            leftState.moveToNext();</span>
        }

<span class="fc bfc" id="L382" title="All 2 branches covered.">        while (rightState.hasRemaining())</span>
        {
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">            if (rightState.isGlobal())</span>
<span class="fc" id="L385">                globalCount += 1;</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">            else if (rightState.isLocal())</span>
<span class="nc" id="L387">                localCount += 1;</span>
            else
<span class="nc" id="L389">                remoteCount += 1;</span>

<span class="fc" id="L391">            rightState.moveToNext();</span>
        }

<span class="fc" id="L394">        leftState.reset();</span>
<span class="fc" id="L395">        rightState.reset();</span>

<span class="fc" id="L397">        return merge(ContextState.allocate(globalCount, localCount, remoteCount), leftState, rightState);</span>
    }

    private ByteBuffer merge(ContextState mergedState, ContextState leftState, ContextState rightState)
    {
<span class="pc bpc" id="L402" title="1 of 4 branches missed.">        while (leftState.hasRemaining() &amp;&amp; rightState.hasRemaining())</span>
        {
<span class="fc" id="L404">            int cmp = leftState.compareIdTo(rightState);</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">            if (cmp == 0)</span>
            {
<span class="fc" id="L407">                Relationship rel = compare(leftState, rightState);</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">                if (rel == Relationship.DISJOINT) // two local shards</span>
<span class="fc" id="L409">                    mergedState.writeLocal(leftState.getCounterId(),</span>
<span class="fc" id="L410">                                           leftState.getClock() + rightState.getClock(),</span>
<span class="fc" id="L411">                                           leftState.getCount() + rightState.getCount());</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">                else if (rel == Relationship.GREATER_THAN)</span>
<span class="fc" id="L413">                    leftState.copyTo(mergedState);</span>
                else // EQUAL or LESS_THAN
<span class="fc" id="L415">                    rightState.copyTo(mergedState);</span>

<span class="fc" id="L417">                rightState.moveToNext();</span>
<span class="fc" id="L418">                leftState.moveToNext();</span>
<span class="fc" id="L419">            }</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">            else if (cmp &gt; 0)</span>
            {
<span class="fc" id="L422">                rightState.copyTo(mergedState);</span>
<span class="fc" id="L423">                rightState.moveToNext();</span>
            }
            else // cmp &lt; 0
            {
<span class="fc" id="L427">                leftState.copyTo(mergedState);</span>
<span class="fc" id="L428">                leftState.moveToNext();</span>
            }
<span class="fc" id="L430">        }</span>

<span class="pc bpc" id="L432" title="1 of 2 branches missed.">        while (leftState.hasRemaining())</span>
        {
<span class="nc" id="L434">            leftState.copyTo(mergedState);</span>
<span class="nc" id="L435">            leftState.moveToNext();</span>
        }

<span class="fc bfc" id="L438" title="All 2 branches covered.">        while (rightState.hasRemaining())</span>
        {
<span class="fc" id="L440">            rightState.copyTo(mergedState);</span>
<span class="fc" id="L441">            rightState.moveToNext();</span>
        }

<span class="fc" id="L444">        return mergedState.context;</span>
    }

    /*
     * Compares two shards, returns:
     * - GREATER_THAN if leftState overrides rightState
     * - LESS_THAN if rightState overrides leftState
     * - EQUAL for two equal, non-local, shards
     * - DISJOINT for any two local shards
     */
    private Relationship compare(ContextState leftState, ContextState rightState)
    {
<span class="fc" id="L456">        long leftClock = leftState.getClock();</span>
<span class="fc" id="L457">        long leftCount = leftState.getCount();</span>
<span class="fc" id="L458">        long rightClock = rightState.getClock();</span>
<span class="fc" id="L459">        long rightCount = rightState.getCount();</span>

<span class="pc bpc" id="L461" title="1 of 4 branches missed.">        if (leftState.isGlobal() || rightState.isGlobal())</span>
        {
<span class="pc bpc" id="L463" title="1 of 4 branches missed.">            if (leftState.isGlobal() &amp;&amp; rightState.isGlobal())</span>
            {
<span class="fc bfc" id="L465" title="All 2 branches covered.">                if (leftClock == rightClock)</span>
                {
                    // Can happen if an sstable gets lost and disk failure policy is set to 'best effort'
<span class="pc bpc" id="L468" title="2 of 4 branches missed.">                    if (leftCount != rightCount &amp;&amp; CompactionManager.isCompactor(Thread.currentThread()))</span>
                    {
<span class="nc" id="L470">                        logger.warn(&quot;invalid global counter shard detected; ({}, {}, {}) and ({}, {}, {}) differ only in &quot;</span>
                                    + &quot;count; will pick highest to self-heal on compaction&quot;,
<span class="nc" id="L472">                                    leftState.getCounterId(), leftClock, leftCount,</span>
<span class="nc" id="L473">                                    rightState.getCounterId(), rightClock, rightCount);</span>
                    }

<span class="pc bpc" id="L476" title="1 of 2 branches missed.">                    if (leftCount &gt; rightCount)</span>
<span class="nc" id="L477">                        return Relationship.GREATER_THAN;</span>
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">                    else if (leftCount == rightCount)</span>
<span class="nc" id="L479">                        return Relationship.EQUAL;</span>
                    else
<span class="fc" id="L481">                        return Relationship.LESS_THAN;</span>
                }
                else
                {
<span class="fc bfc" id="L485" title="All 2 branches covered.">                    return leftClock &gt; rightClock ? Relationship.GREATER_THAN : Relationship.LESS_THAN;</span>
                }
            }
            else // only one is global - keep that one
            {
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">                return leftState.isGlobal() ? Relationship.GREATER_THAN : Relationship.LESS_THAN;</span>
            }
        }

<span class="pc bpc" id="L494" title="1 of 4 branches missed.">        if (leftState.isLocal() || rightState.isLocal())</span>
        {
            // Local id and at least one is a local shard.
<span class="pc bpc" id="L497" title="2 of 4 branches missed.">            if (leftState.isLocal() &amp;&amp; rightState.isLocal())</span>
<span class="fc" id="L498">                return Relationship.DISJOINT;</span>
            else // only one is local - keep that one
<span class="nc bnc" id="L500" title="All 2 branches missed.">                return leftState.isLocal() ? Relationship.GREATER_THAN : Relationship.LESS_THAN;</span>
        }

        // both are remote shards
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">        if (leftClock == rightClock)</span>
        {
            // We should never see non-local shards w/ same id+clock but different counts. However, if we do
            // we should &quot;heal&quot; the problem by being deterministic in our selection of shard - and
            // log the occurrence so that the operator will know something is wrong.
<span class="nc bnc" id="L509" title="All 4 branches missed.">            if (leftCount != rightCount &amp;&amp; CompactionManager.isCompactor(Thread.currentThread()))</span>
            {
<span class="nc" id="L511">                logger.warn(&quot;invalid remote counter shard detected; ({}, {}, {}) and ({}, {}, {}) differ only in &quot;</span>
                            + &quot;count; will pick highest to self-heal on compaction&quot;,
<span class="nc" id="L513">                            leftState.getCounterId(), leftClock, leftCount,</span>
<span class="nc" id="L514">                            rightState.getCounterId(), rightClock, rightCount);</span>
            }

<span class="nc bnc" id="L517" title="All 2 branches missed.">            if (leftCount &gt; rightCount)</span>
<span class="nc" id="L518">                return Relationship.GREATER_THAN;</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">            else if (leftCount == rightCount)</span>
<span class="nc" id="L520">                return Relationship.EQUAL;</span>
            else
<span class="nc" id="L522">                return Relationship.LESS_THAN;</span>
        }
        else
        {
<span class="pc bpc" id="L526" title="9 of 12 branches missed.">            if ((leftClock &gt;= 0 &amp;&amp; rightClock &gt; 0 &amp;&amp; leftClock &gt;= rightClock)</span>
                    || (leftClock &lt; 0 &amp;&amp; (rightClock &gt; 0 || leftClock &lt; rightClock)))
<span class="fc" id="L528">                return Relationship.GREATER_THAN;</span>
            else
<span class="nc" id="L530">                return Relationship.LESS_THAN;</span>
        }
    }

    /**
     * Human-readable String from context.
     *
     * @param context counter context.
     * @return a human-readable String of the context.
     */
    public String toString(ByteBuffer context)
    {
<span class="nc" id="L542">        ContextState state = ContextState.wrap(context);</span>
<span class="nc" id="L543">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L544">        sb.append(&quot;[&quot;);</span>

<span class="nc bnc" id="L546" title="All 2 branches missed.">        while (state.hasRemaining())</span>
        {
<span class="nc bnc" id="L548" title="All 2 branches missed.">            if (state.getElementIndex() &gt; 0)</span>
<span class="nc" id="L549">                sb.append(&quot;,&quot;);</span>
<span class="nc" id="L550">            sb.append(&quot;{&quot;);</span>
<span class="nc" id="L551">            sb.append(state.getCounterId()).append(&quot;, &quot;);</span>
<span class="nc" id="L552">            sb.append(state.getClock()).append(&quot;, &quot;);</span>
<span class="nc" id="L553">            sb.append(state.getCount());</span>
<span class="nc" id="L554">            sb.append(&quot;}&quot;);</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">            if (state.isGlobal())</span>
<span class="nc" id="L556">                sb.append(&quot;$&quot;);</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">            else if (state.isLocal())</span>
<span class="nc" id="L558">                sb.append(&quot;*&quot;);</span>
<span class="nc" id="L559">            state.moveToNext();</span>
        }

<span class="nc" id="L562">        sb.append(&quot;]&quot;);</span>
<span class="nc" id="L563">        return sb.toString();</span>
    }

    /**
     * Returns the aggregated count across all counter ids.
     *
     * @param context a counter context
     * @return the aggregated count represented by {@code context}
     */
    public &lt;V&gt; long total(V context, ValueAccessor&lt;V&gt; accessor)
    {
<span class="fc" id="L574">        long total = 0L;</span>
        // we could use a ContextState but it is easy enough that we avoid the object creation
<span class="fc bfc" id="L576" title="All 2 branches covered.">        for (int offset = headerLength(context, accessor), size=accessor.size(context); offset &lt; size; offset += STEP_LENGTH)</span>
<span class="fc" id="L577">            total += accessor.getLong(context, offset + CounterId.LENGTH + CLOCK_LENGTH);</span>
<span class="fc" id="L578">        return total;</span>
    }

    public &lt;V&gt; long total(Cell&lt;V&gt; cell)
    {
<span class="fc" id="L583">        return total(cell.value(), cell.accessor());</span>
    }

    public &lt;V&gt; boolean shouldClearLocal(V context, ValueAccessor&lt;V&gt; accessor)
    {
        // #elt being negative means we have to clean local shards.
<span class="fc bfc" id="L589" title="All 2 branches covered.">        return accessor.getShort(context, 0) &lt; 0;</span>
    }

    /**
     * Detects whether or not the context has any legacy (local or remote) shards in it.
     */
    public &lt;V&gt;  boolean hasLegacyShards(V context, ValueAccessor&lt;V&gt; accessor)
    {
<span class="fc" id="L597">        int totalCount = (accessor.size(context) - headerLength(context, accessor)) / STEP_LENGTH;</span>
<span class="fc" id="L598">        int localAndGlobalCount = Math.abs(accessor.getShort(context, 0));</span>

<span class="pc bpc" id="L600" title="1 of 2 branches missed.">        if (localAndGlobalCount &lt; totalCount)</span>
<span class="nc" id="L601">            return true; // remote shard(s) present</span>

<span class="fc bfc" id="L603" title="All 2 branches covered.">        for (int i = 0; i &lt; localAndGlobalCount; i++)</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">            if (accessor.getShort(context, HEADER_SIZE_LENGTH + i * HEADER_ELT_LENGTH) &gt;= 0)</span>
<span class="fc" id="L605">                return true; // found a local shard</span>

<span class="fc" id="L607">        return false;</span>
    }

    /**
     * Mark context to delete local references afterward.
     * Marking is done by multiply #elt by -1 to preserve header length
     * and #elt count in order to clear all local refs later.
     *
     * @param context a counter context
     * @return context that marked to delete local refs
     */
    public ByteBuffer markLocalToBeCleared(ByteBuffer context)
    {
<span class="fc" id="L620">        short count = context.getShort(context.position());</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">        if (count &lt;= 0)</span>
<span class="fc" id="L622">            return context; // already marked or all are remote.</span>

<span class="fc" id="L624">        boolean hasLocalShards = false;</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">        for (int i = 0; i &lt; count; i++)</span>
        {
<span class="fc bfc" id="L627" title="All 2 branches covered.">            if (context.getShort(context.position() + HEADER_SIZE_LENGTH + i * HEADER_ELT_LENGTH) &gt;= 0)</span>
            {
<span class="fc" id="L629">                hasLocalShards = true;</span>
<span class="fc" id="L630">                break;</span>
            }
        }

<span class="fc bfc" id="L634" title="All 2 branches covered.">        if (!hasLocalShards)</span>
<span class="fc" id="L635">            return context; // all shards are global or remote.</span>

<span class="fc" id="L637">        ByteBuffer marked = ByteBuffer.allocate(context.remaining());</span>
<span class="fc" id="L638">        marked.putShort(marked.position(), (short) (count * -1));</span>
<span class="fc" id="L639">        ByteBufferUtil.copyBytes(context,</span>
<span class="fc" id="L640">                                 context.position() + HEADER_SIZE_LENGTH,</span>
                                 marked,
<span class="fc" id="L642">                                 marked.position() + HEADER_SIZE_LENGTH,</span>
<span class="fc" id="L643">                                 context.remaining() - HEADER_SIZE_LENGTH);</span>
<span class="fc" id="L644">        return marked;</span>
    }

    public &lt;V&gt; V clearAllLocal(V context, ValueAccessor&lt;V&gt; accessor)
    {
<span class="fc" id="L649">        int count = Math.abs(accessor.getShort(context, 0));</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">        if (count == 0)</span>
<span class="fc" id="L651">            return context; // no local or global shards present.</span>

<span class="fc" id="L653">        List&lt;Short&gt; globalShardIndexes = new ArrayList&lt;&gt;(count);</span>
<span class="fc bfc" id="L654" title="All 2 branches covered.">        for (int i = 0; i &lt; count; i++)</span>
        {
<span class="fc" id="L656">            short elt = accessor.getShort(context, HEADER_SIZE_LENGTH + i * HEADER_ELT_LENGTH);</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">            if (elt &lt; 0)</span>
<span class="fc" id="L658">                globalShardIndexes.add(elt);</span>
        }

<span class="fc bfc" id="L661" title="All 2 branches covered.">        if (count == globalShardIndexes.size())</span>
<span class="fc" id="L662">            return context; // no local shards detected.</span>

        // allocate a smaller BB for the cleared context - with no local header elts.
<span class="fc" id="L665">        V cleared = accessor.allocate(accessor.size(context) - (count - globalShardIndexes.size()) * HEADER_ELT_LENGTH);</span>

<span class="fc" id="L667">        accessor.putShort(cleared, 0, (short) globalShardIndexes.size());</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">        for (int i = 0; i &lt; globalShardIndexes.size(); i++)</span>
<span class="fc" id="L669">            accessor.putShort(cleared, HEADER_SIZE_LENGTH + i * HEADER_ELT_LENGTH, globalShardIndexes.get(i));</span>

<span class="fc" id="L671">        int origHeaderLength = headerLength(context, accessor);</span>
<span class="fc" id="L672">        accessor.copyTo(context,</span>
                        origHeaderLength,
                        cleared,
                        accessor,
<span class="fc" id="L676">                        headerLength(cleared, accessor),</span>
<span class="fc" id="L677">                        accessor.size(context) - origHeaderLength);</span>

<span class="fc" id="L679">        return cleared;</span>
    }

    public &lt;V&gt; void validateContext(V context, ValueAccessor&lt;V&gt; accessor) throws MarshalException
    {
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">        if ((accessor.size(context) - headerLength(context, accessor)) % STEP_LENGTH != 0)</span>
<span class="nc" id="L685">            throw new MarshalException(&quot;Invalid size for a counter context&quot;);</span>
<span class="fc" id="L686">    }</span>

    /**
     * Returns the clock and the count associated with the local counter id, or (0, 0) if no such shard is present.
     */
    public ClockAndCount getLocalClockAndCount(ByteBuffer context)
    {
<span class="fc" id="L693">        return getClockAndCountOf(context, CounterId.getLocalId());</span>
    }

    /**
     * Returns the count associated with the local counter id, or 0 if no such shard is present.
     */
    public long getLocalCount(ByteBuffer context)
    {
<span class="nc" id="L701">        return getLocalClockAndCount(context).count;</span>
    }

    /**
     * Returns the clock and the count associated with the given counter id, or (0, 0) if no such shard is present.
     */
    @VisibleForTesting
    public ClockAndCount getClockAndCountOf(ByteBuffer context, CounterId id)
    {
<span class="fc" id="L710">        int position = findPositionOf(context, id);</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">        if (position == -1)</span>
<span class="fc" id="L712">            return ClockAndCount.BLANK;</span>

<span class="fc" id="L714">        long clock = context.getLong(position + CounterId.LENGTH);</span>
<span class="fc" id="L715">        long count = context.getLong(position + CounterId.LENGTH + CLOCK_LENGTH);</span>
<span class="fc" id="L716">        return ClockAndCount.create(clock, count);</span>
    }

    /**
     * Finds the position of a shard with the given id within the context (via binary search).
     */
    @VisibleForTesting
    public int findPositionOf(ByteBuffer context, CounterId id)
    {
<span class="fc" id="L725">        int headerLength = headerLength(context, ByteBufferAccessor.instance);</span>
<span class="fc" id="L726">        int offset = context.position() + headerLength;</span>

<span class="fc" id="L728">        int left = 0;</span>
<span class="fc" id="L729">        int right = (context.remaining() - headerLength) / STEP_LENGTH - 1;</span>

<span class="fc bfc" id="L731" title="All 2 branches covered.">        while (right &gt;= left)</span>
        {
<span class="fc" id="L733">            int middle = (left + right) / 2;</span>
<span class="fc" id="L734">            int cmp = compareId(context, offset + middle * STEP_LENGTH, id.bytes(), id.bytes().position());</span>

<span class="fc bfc" id="L736" title="All 2 branches covered.">            if (cmp == -1)</span>
<span class="fc" id="L737">                left = middle + 1;</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">            else if (cmp == 0)</span>
<span class="fc" id="L739">                return offset + middle * STEP_LENGTH;</span>
            else
<span class="fc" id="L741">                right = middle - 1;</span>
<span class="fc" id="L742">        }</span>

<span class="fc" id="L744">        return -1; // position not found</span>
    }

    /**
     * Helper class to work on contexts (works by iterating over them).
     * A context being abstractly a list of tuple (counterid, clock, count), a
     * ContextState encapsulate a context and a position to one of the tuple.
     * It also allow to create new context iteratively.
     *
     * Note: this is intrinsically a private class intended for use by the
     * methods of CounterContext only. It is however public because it is
     * convenient to create handcrafted context for unit tests.
     */
    public static class ContextState
    {
        public final ByteBuffer context;
        public final int headerLength;

        private int headerOffset;        // offset from context.position()
        private int bodyOffset;          // offset from context.position()
        private boolean currentIsGlobal;
        private boolean currentIsLocal;

        private ContextState(ByteBuffer context)
<span class="fc" id="L768">        {</span>
<span class="fc" id="L769">            this.context = context;</span>
<span class="fc" id="L770">            this.headerLength = this.bodyOffset = headerLength(context, ByteBufferAccessor.instance);</span>
<span class="fc" id="L771">            this.headerOffset = HEADER_SIZE_LENGTH;</span>
<span class="fc" id="L772">            updateIsGlobalOrLocal();</span>
<span class="fc" id="L773">        }</span>

        public static ContextState wrap(ByteBuffer context)
        {
<span class="fc" id="L777">            return new ContextState(context);</span>
        }

        /**
         * Allocate a new context big enough for globalCount + localCount + remoteCount elements
         * and return the initial corresponding ContextState.
         */
        public static ContextState allocate(int globalCount, int localCount, int remoteCount)
        {
<span class="fc" id="L786">            int headerLength = HEADER_SIZE_LENGTH + (globalCount + localCount) * HEADER_ELT_LENGTH;</span>
<span class="fc" id="L787">            int bodyLength = (globalCount + localCount + remoteCount) * STEP_LENGTH;</span>

<span class="fc" id="L789">            ByteBuffer buffer = ByteBuffer.allocate(headerLength + bodyLength);</span>
<span class="fc" id="L790">            buffer.putShort(buffer.position(), (short) (globalCount + localCount));</span>

<span class="fc" id="L792">            return ContextState.wrap(buffer);</span>
        }

        public boolean isGlobal()
        {
<span class="fc" id="L797">            return currentIsGlobal;</span>
        }

        public boolean isLocal()
        {
<span class="fc" id="L802">            return currentIsLocal;</span>
        }

        public boolean isRemote()
        {
<span class="nc bnc" id="L807" title="All 4 branches missed.">            return !(currentIsGlobal || currentIsLocal);</span>
        }

        private void updateIsGlobalOrLocal()
        {
<span class="fc bfc" id="L812" title="All 2 branches covered.">            if (headerOffset &gt;= headerLength)</span>
            {
<span class="fc" id="L814">                currentIsGlobal = currentIsLocal = false;</span>
            }
            else
            {
<span class="fc" id="L818">                short headerElt = context.getShort(context.position() + headerOffset);</span>
<span class="fc bfc" id="L819" title="All 2 branches covered.">                currentIsGlobal = headerElt == getElementIndex() + Short.MIN_VALUE;</span>
<span class="fc bfc" id="L820" title="All 2 branches covered.">                currentIsLocal = headerElt == getElementIndex();</span>
            }
<span class="fc" id="L822">        }</span>

        public boolean hasRemaining()
        {
<span class="fc bfc" id="L826" title="All 2 branches covered.">            return bodyOffset &lt; context.remaining();</span>
        }

        public void moveToNext()
        {
<span class="fc" id="L831">            bodyOffset += STEP_LENGTH;</span>
<span class="fc bfc" id="L832" title="All 4 branches covered.">            if (currentIsGlobal || currentIsLocal)</span>
<span class="fc" id="L833">                headerOffset += HEADER_ELT_LENGTH;</span>
<span class="fc" id="L834">            updateIsGlobalOrLocal();</span>
<span class="fc" id="L835">        }</span>

        public void copyTo(ContextState other)
        {
<span class="fc" id="L839">            other.writeElement(getCounterId(), getClock(), getCount(), currentIsGlobal, currentIsLocal);</span>
<span class="fc" id="L840">        }</span>

        public int compareIdTo(ContextState other)
        {
<span class="fc" id="L844">            return compareId(context, context.position() + bodyOffset, other.context, other.context.position() + other.bodyOffset);</span>
        }

        public void reset()
        {
<span class="fc" id="L849">            this.headerOffset = HEADER_SIZE_LENGTH;</span>
<span class="fc" id="L850">            this.bodyOffset = headerLength;</span>
<span class="fc" id="L851">            updateIsGlobalOrLocal();</span>
<span class="fc" id="L852">        }</span>

        public int getElementIndex()
        {
<span class="fc" id="L856">            return (bodyOffset - headerLength) / STEP_LENGTH;</span>
        }

        public CounterId getCounterId()
        {
<span class="fc" id="L861">            return CounterId.wrap(context, context.position() + bodyOffset);</span>
        }

        public long getClock()
        {
<span class="fc" id="L866">            return context.getLong(context.position() + bodyOffset + CounterId.LENGTH);</span>
        }

        public long getCount()
        {
<span class="fc" id="L871">            return context.getLong(context.position() + bodyOffset + CounterId.LENGTH + CLOCK_LENGTH);</span>
        }

        public void writeGlobal(CounterId id, long clock, long count)
        {
<span class="fc" id="L876">            writeElement(id, clock, count, true, false);</span>
<span class="fc" id="L877">        }</span>

        // In 2.1 only used by the unit tests.
        public void writeLocal(CounterId id, long clock, long count)
        {
<span class="fc" id="L882">            writeElement(id, clock, count, false, true);</span>
<span class="fc" id="L883">        }</span>

        // In 2.1 only used by the unit tests.
        public void writeRemote(CounterId id, long clock, long count)
        {
<span class="fc" id="L888">            writeElement(id, clock, count, false, false);</span>
<span class="fc" id="L889">        }</span>

        private void writeElement(CounterId id, long clock, long count, boolean isGlobal, boolean isLocal)
        {
<span class="fc" id="L893">            writeElementAtOffset(context, context.position() + bodyOffset, id, clock, count);</span>

<span class="fc bfc" id="L895" title="All 2 branches covered.">            if (isGlobal)</span>
<span class="fc" id="L896">                context.putShort(context.position() + headerOffset, (short) (getElementIndex() + Short.MIN_VALUE));</span>
<span class="fc bfc" id="L897" title="All 2 branches covered.">            else if (isLocal)</span>
<span class="fc" id="L898">                context.putShort(context.position() + headerOffset, (short) getElementIndex());</span>

<span class="fc" id="L900">            currentIsGlobal = isGlobal;</span>
<span class="fc" id="L901">            currentIsLocal = isLocal;</span>
<span class="fc" id="L902">            moveToNext();</span>
<span class="fc" id="L903">        }</span>

        // write a tuple (counter id, clock, count) at an absolute (bytebuffer-wise) offset
        private void writeElementAtOffset(ByteBuffer ctx, int offset, CounterId id, long clock, long count)
        {
<span class="fc" id="L908">            ctx = ctx.duplicate();</span>
<span class="fc" id="L909">            ctx.position(offset);</span>
<span class="fc" id="L910">            ctx.put(id.bytes().duplicate());</span>
<span class="fc" id="L911">            ctx.putLong(clock);</span>
<span class="fc" id="L912">            ctx.putLong(count);</span>
<span class="fc" id="L913">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>