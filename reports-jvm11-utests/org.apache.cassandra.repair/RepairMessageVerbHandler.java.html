<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RepairMessageVerbHandler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.repair</a> &gt; <span class="el_source">RepairMessageVerbHandler.java</span></div><h1>RepairMessageVerbHandler.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.repair;

import java.util.*;
import java.util.function.BiFunction;
import java.util.function.Function;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.exceptions.RequestFailureReason;
import org.apache.cassandra.net.IVerbHandler;
import org.apache.cassandra.net.Message;
import org.apache.cassandra.repair.messages.*;
import org.apache.cassandra.repair.state.AbstractCompletable;
import org.apache.cassandra.repair.state.AbstractState;
import org.apache.cassandra.repair.state.Completable;
import org.apache.cassandra.repair.state.ParticipateState;
import org.apache.cassandra.repair.state.SyncState;
import org.apache.cassandra.repair.state.ValidationState;
import org.apache.cassandra.schema.TableId;
import org.apache.cassandra.service.ActiveRepairService;
import org.apache.cassandra.streaming.PreviewKind;
import org.apache.cassandra.utils.JVMStabilityInspector;
import org.apache.cassandra.utils.TimeUUID;

/**
 * Handles all repair related message.
 *
 * @since 2.0
 */
public class RepairMessageVerbHandler implements IVerbHandler&lt;RepairMessage&gt;
{
    private static class Holder
    {
<span class="fc" id="L53">        private static final RepairMessageVerbHandler instance = new RepairMessageVerbHandler();</span>
    }

    public static RepairMessageVerbHandler instance()
    {
<span class="fc" id="L58">        return Holder.instance;</span>
    }

    private final SharedContext ctx;

    private RepairMessageVerbHandler()
    {
<span class="fc" id="L65">        this(SharedContext.Global.instance);</span>
<span class="fc" id="L66">    }</span>

    public RepairMessageVerbHandler(SharedContext ctx)
<span class="fc" id="L69">    {</span>
<span class="fc" id="L70">        this.ctx = ctx;</span>
<span class="fc" id="L71">    }</span>

<span class="fc" id="L73">    private static final Logger logger = LoggerFactory.getLogger(RepairMessageVerbHandler.class);</span>

    private boolean isIncremental(TimeUUID sessionID)
    {
<span class="fc" id="L77">        return ctx.repair().consistent.local.isSessionInProgress(sessionID);</span>
    }

    private PreviewKind previewKind(TimeUUID sessionID) throws NoSuchRepairSessionException
    {
<span class="fc" id="L82">        ActiveRepairService.ParentRepairSession prs = ctx.repair().getParentRepairSession(sessionID);</span>
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">        return prs != null ? prs.previewKind : PreviewKind.NONE;</span>
    }

    public void doVerb(final Message&lt;RepairMessage&gt; message)
    {
        // TODO add cancel/interrupt message
<span class="fc" id="L89">        RepairJobDesc desc = message.payload.desc;</span>
        try
        {
<span class="pc bpc" id="L92" title="2 of 14 branches missed.">            switch (message.verb())</span>
            {
                case PREPARE_MSG:
                {
<span class="fc" id="L96">                    PrepareMessage prepareMessage = (PrepareMessage) message.payload;</span>
<span class="fc" id="L97">                    logger.debug(&quot;Preparing, {}&quot;, prepareMessage);</span>
<span class="fc" id="L98">                    ParticipateState state = new ParticipateState(ctx.clock(), message.from(), prepareMessage);</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">                    if (!ctx.repair().register(state))</span>
                    {
<span class="fc" id="L101">                        replyDedup(ctx.repair().participate(state.id), message);</span>
<span class="fc" id="L102">                        return;</span>
                    }
<span class="fc bfc" id="L104" title="All 2 branches covered.">                    if (!ctx.repair().verifyCompactionsPendingThreshold(prepareMessage.parentRepairSession, prepareMessage.previewKind))</span>
                    {
                        // error is logged in verifyCompactionsPendingThreshold
<span class="fc" id="L107">                        state.phase.fail(&quot;Too many pending compactions&quot;);</span>

<span class="fc" id="L109">                        sendFailureResponse(message);</span>
<span class="fc" id="L110">                        return;</span>
                    }

<span class="fc" id="L113">                    List&lt;ColumnFamilyStore&gt; columnFamilyStores = new ArrayList&lt;&gt;(prepareMessage.tableIds.size());</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">                    for (TableId tableId : prepareMessage.tableIds)</span>
                    {
<span class="fc" id="L116">                        ColumnFamilyStore columnFamilyStore = ColumnFamilyStore.getIfExists(tableId);</span>
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">                        if (columnFamilyStore == null)</span>
                        {
<span class="nc" id="L119">                            String reason = String.format(&quot;Table with id %s was dropped during prepare phase of repair&quot;,</span>
                                                          tableId);
<span class="nc" id="L121">                            state.phase.fail(reason);</span>
<span class="nc" id="L122">                            logErrorAndSendFailureResponse(reason, message);</span>
<span class="nc" id="L123">                            return;</span>
                        }
<span class="fc" id="L125">                        columnFamilyStores.add(columnFamilyStore);</span>
<span class="fc" id="L126">                    }</span>
<span class="fc" id="L127">                    state.phase.accept();</span>
<span class="fc" id="L128">                    ctx.repair().registerParentRepairSession(prepareMessage.parentRepairSession,</span>
<span class="fc" id="L129">                                                                    message.from(),</span>
                                                                    columnFamilyStores,
                                                                    prepareMessage.ranges,
                                                                    prepareMessage.isIncremental,
                                                                    prepareMessage.repairedAt,
                                                                    prepareMessage.isGlobal,
                                                                    prepareMessage.previewKind);
<span class="fc" id="L136">                    sendAck(message);</span>
                }
<span class="fc" id="L138">                    break;</span>

                case SNAPSHOT_MSG:
                {
<span class="fc" id="L142">                    logger.debug(&quot;Snapshotting {}&quot;, desc);</span>
<span class="fc" id="L143">                    ParticipateState state = ctx.repair().participate(desc.parentSessionId);</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">                    if (state == null)</span>
                    {
<span class="nc" id="L146">                        logErrorAndSendFailureResponse(&quot;Unknown repair &quot; + desc.parentSessionId, message);</span>
<span class="nc" id="L147">                        return;</span>
                    }
<span class="fc" id="L149">                    final ColumnFamilyStore cfs = ColumnFamilyStore.getIfExists(desc.keyspace, desc.columnFamily);</span>
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">                    if (cfs == null)</span>
                    {
<span class="nc" id="L152">                        String reason = String.format(&quot;Table %s.%s was dropped during snapshot phase of repair %s&quot;,</span>
                                                      desc.keyspace, desc.columnFamily, desc.parentSessionId);
<span class="nc" id="L154">                        state.phase.fail(reason);</span>
<span class="nc" id="L155">                        logErrorAndSendFailureResponse(reason, message);</span>
<span class="nc" id="L156">                        return;</span>
                    }

<span class="fc" id="L159">                    ActiveRepairService.ParentRepairSession prs = ctx.repair().getParentRepairSession(desc.parentSessionId);</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">                    if (prs.setHasSnapshots())</span>
                    {
<span class="fc" id="L162">                        state.getOrCreateJob(desc).snapshot();</span>
<span class="fc" id="L163">                        TableRepairManager repairManager = cfs.getRepairManager();</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">                        if (prs.isGlobal)</span>
                        {
<span class="fc" id="L166">                            repairManager.snapshot(desc.parentSessionId.toString(), prs.getRanges(), false);</span>
                        }
                        else
                        {
<span class="nc" id="L170">                            repairManager.snapshot(desc.parentSessionId.toString(), desc.ranges, true);</span>
                        }
<span class="fc" id="L172">                        logger.debug(&quot;Enqueuing response to snapshot request {} to {}&quot;, desc.sessionId, message.from());</span>
                    }
<span class="fc" id="L174">                    sendAck(message);</span>
                }
<span class="fc" id="L176">                    break;</span>

                case VALIDATION_REQ:
                {
<span class="fc" id="L180">                    ValidationRequest validationRequest = (ValidationRequest) message.payload;</span>
<span class="fc" id="L181">                    logger.debug(&quot;Validating {}&quot;, validationRequest);</span>

<span class="fc" id="L183">                    ParticipateState participate = ctx.repair().participate(desc.parentSessionId);</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">                    if (participate == null)</span>
                    {
<span class="nc" id="L186">                        logErrorAndSendFailureResponse(&quot;Unknown repair &quot; + desc.parentSessionId, message);</span>
<span class="nc" id="L187">                        return;</span>
                    }

<span class="fc" id="L190">                    ValidationState vState = new ValidationState(ctx.clock(), desc, message.from());</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">                    if (!register(message, participate, vState,</span>
<span class="fc" id="L192">                                  participate::register,</span>
<span class="fc" id="L193">                                  (d, i) -&gt; participate.validation(d)))</span>
<span class="fc" id="L194">                        return;</span>
                    try
                    {
                        // trigger read-only compaction
<span class="fc" id="L198">                        ColumnFamilyStore store = ColumnFamilyStore.getIfExists(desc.keyspace, desc.columnFamily);</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">                        if (store == null)</span>
                        {
<span class="nc" id="L201">                            String msg = String.format(&quot;Table %s.%s was dropped during validation phase of repair %s&quot;, desc.keyspace, desc.columnFamily, desc.parentSessionId);</span>
<span class="nc" id="L202">                            vState.phase.fail(msg);</span>
<span class="nc" id="L203">                            logErrorAndSendFailureResponse(msg, message);</span>
<span class="nc" id="L204">                            return;</span>
                        }

                        try
                        {
<span class="fc" id="L209">                            ctx.repair().consistent.local.maybeSetRepairing(desc.parentSessionId);</span>
                        }
<span class="fc" id="L211">                        catch (Throwable t)</span>
                        {
<span class="fc" id="L213">                            JVMStabilityInspector.inspectThrowable(t);</span>
<span class="fc" id="L214">                            vState.phase.fail(t.toString());</span>
<span class="fc" id="L215">                            logErrorAndSendFailureResponse(t.toString(), message);</span>
<span class="fc" id="L216">                            return;</span>
<span class="fc" id="L217">                        }</span>
                        PreviewKind previewKind;
                        try
                        {
<span class="fc" id="L221">                            previewKind = previewKind(desc.parentSessionId);</span>
                        }
<span class="fc" id="L223">                        catch (NoSuchRepairSessionException e)</span>
                        {
<span class="fc" id="L225">                            logger.warn(&quot;Parent repair session {} has been removed, failing repair&quot;, desc.parentSessionId);</span>
<span class="fc" id="L226">                            vState.phase.fail(e);</span>
<span class="fc" id="L227">                            sendFailureResponse(message);</span>
<span class="fc" id="L228">                            return;</span>
<span class="fc" id="L229">                        }</span>
<span class="fc" id="L230">                        vState.phase.accept();</span>
<span class="fc" id="L231">                        sendAck(message);</span>

<span class="fc" id="L233">                        Validator validator = new Validator(ctx, vState, validationRequest.nowInSec,</span>
<span class="fc" id="L234">                                                            isIncremental(desc.parentSessionId), previewKind);</span>
<span class="fc" id="L235">                        ctx.validationManager().submitValidation(store, validator);</span>
                    }
<span class="nc" id="L237">                    catch (Throwable t)</span>
                    {
<span class="nc" id="L239">                        vState.phase.fail(t);</span>
<span class="nc" id="L240">                        throw t;</span>
<span class="fc" id="L241">                    }</span>
                }
<span class="fc" id="L243">                    break;</span>

                case SYNC_REQ:
                {
                    // forwarded sync request
<span class="fc" id="L248">                    SyncRequest request = (SyncRequest) message.payload;</span>
<span class="fc" id="L249">                    logger.debug(&quot;Syncing {}&quot;, request);</span>

<span class="fc" id="L251">                    ParticipateState participate = ctx.repair().participate(desc.parentSessionId);</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">                    if (participate == null)</span>
                    {
<span class="nc" id="L254">                        logErrorAndSendFailureResponse(&quot;Unknown repair &quot; + desc.parentSessionId, message);</span>
<span class="nc" id="L255">                        return;</span>
                    }
<span class="fc" id="L257">                    SyncState state = new SyncState(ctx.clock(), desc, request.initiator, request.src, request.dst);</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">                    if (!register(message, participate, state,</span>
<span class="fc" id="L259">                                  participate::register,</span>
<span class="fc" id="L260">                                  participate::sync))</span>
<span class="fc" id="L261">                        return;</span>
<span class="fc" id="L262">                    state.phase.accept();</span>
<span class="fc" id="L263">                    StreamingRepairTask task = new StreamingRepairTask(ctx, state, desc,</span>
                                                                       request.initiator,
                                                                       request.src,
                                                                       request.dst,
                                                                       request.ranges,
<span class="fc bfc" id="L268" title="All 2 branches covered.">                                                                       isIncremental(desc.parentSessionId) ? desc.parentSessionId : null,</span>
                                                                       request.previewKind,
                                                                       request.asymmetric);
<span class="fc" id="L271">                    task.run();</span>
<span class="fc" id="L272">                    sendAck(message);</span>
                }
<span class="fc" id="L274">                    break;</span>

                case CLEANUP_MSG:
                {
<span class="fc" id="L278">                    logger.debug(&quot;cleaning up repair&quot;);</span>
<span class="fc" id="L279">                    CleanupMessage cleanup = (CleanupMessage) message.payload;</span>
<span class="fc" id="L280">                    ParticipateState state = ctx.repair().participate(cleanup.parentRepairSession);</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">                    if (state != null)</span>
<span class="fc" id="L282">                        state.phase.success(&quot;Cleanup message recieved&quot;);</span>
<span class="fc" id="L283">                    ctx.repair().removeParentRepairSession(cleanup.parentRepairSession);</span>
<span class="fc" id="L284">                    sendAck(message);</span>
                }
<span class="fc" id="L286">                    break;</span>

                case PREPARE_CONSISTENT_REQ:
<span class="fc" id="L289">                    ctx.repair().consistent.local.handlePrepareMessage(message.from(), (PrepareConsistentRequest) message.payload);</span>
<span class="fc" id="L290">                    break;</span>

                case PREPARE_CONSISTENT_RSP:
<span class="fc" id="L293">                    ctx.repair().consistent.coordinated.handlePrepareResponse((PrepareConsistentResponse) message.payload);</span>
<span class="fc" id="L294">                    break;</span>

                case FINALIZE_PROPOSE_MSG:
<span class="fc" id="L297">                    ctx.repair().consistent.local.handleFinalizeProposeMessage(message.from(), (FinalizePropose) message.payload);</span>
<span class="fc" id="L298">                    break;</span>

                case FINALIZE_PROMISE_MSG:
<span class="fc" id="L301">                    ctx.repair().consistent.coordinated.handleFinalizePromiseMessage((FinalizePromise) message.payload);</span>
<span class="fc" id="L302">                    break;</span>

                case FINALIZE_COMMIT_MSG:
<span class="fc" id="L305">                    ctx.repair().consistent.local.handleFinalizeCommitMessage(message.from(), (FinalizeCommit) message.payload);</span>
<span class="fc" id="L306">                    break;</span>

                case FAILED_SESSION_MSG:
<span class="fc" id="L309">                    FailSession failure = (FailSession) message.payload;</span>
<span class="fc" id="L310">                    ctx.repair().consistent.coordinated.handleFailSessionMessage(failure);</span>
<span class="fc" id="L311">                    ctx.repair().consistent.local.handleFailSessionMessage(message.from(), failure);</span>
<span class="fc" id="L312">                    break;</span>

                case STATUS_REQ:
<span class="nc" id="L315">                    ctx.repair().consistent.local.handleStatusRequest(message.from(), (StatusRequest) message.payload);</span>
<span class="nc" id="L316">                    break;</span>

                case STATUS_RSP:
<span class="nc" id="L319">                    ctx.repair().consistent.local.handleStatusResponse(message.from(), (StatusResponse) message.payload);</span>
<span class="nc" id="L320">                    break;</span>

                default:
<span class="fc" id="L323">                    ctx.repair().handleMessage(message);</span>
                    break;
            }
        }
<span class="nc" id="L327">        catch (Exception e)</span>
        {
<span class="nc" id="L329">            logger.error(&quot;Got error, removing parent repair session&quot;);</span>
<span class="nc bnc" id="L330" title="All 4 branches missed.">            if (desc != null &amp;&amp; desc.parentSessionId != null)</span>
            {
<span class="nc" id="L332">                ParticipateState parcipate = ctx.repair().participate(desc.parentSessionId);</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">                if (parcipate != null)</span>
<span class="nc" id="L334">                    parcipate.phase.fail(e);</span>
<span class="nc" id="L335">                ctx.repair().removeParentRepairSession(desc.parentSessionId);</span>
            }
<span class="nc" id="L337">            throw new RuntimeException(e);</span>
<span class="fc" id="L338">        }</span>
<span class="fc" id="L339">    }</span>

    private &lt;I, T extends AbstractState&lt;?, I&gt;&gt; boolean register(Message&lt;RepairMessage&gt; message,
                                                                ParticipateState participate,
                                                                T vState,
                                                                Function&lt;T, ParticipateState.RegisterStatus&gt; register,
                                                                BiFunction&lt;RepairJobDesc, I, T&gt; getter)
    {
<span class="fc" id="L347">        ParticipateState.RegisterStatus registerStatus = register.apply(vState);</span>
<span class="pc bpc" id="L348" title="1 of 4 branches missed.">        switch (registerStatus)</span>
        {
            case ACCEPTED:
<span class="fc" id="L351">                return true;</span>
            case EXISTS:
<span class="fc" id="L353">                logger.debug(&quot;Duplicate validation message found for parent={}, validation={}&quot;, participate.id, vState.id);</span>
<span class="fc" id="L354">                replyDedup(getter.apply(message.payload.desc, vState.id), message);</span>
<span class="fc" id="L355">                return false;</span>
            case ALREADY_COMPLETED:
            case STATUS_REJECTED:
                // the repair is complete (most likely failed as we don't know success always), or is at a later phase such as sync
                // so send a nack saying that the validation could not be accepted
<span class="fc" id="L360">                sendFailureResponse(message);</span>
<span class="fc" id="L361">                return false;</span>
            default:
<span class="nc" id="L363">                throw new IllegalStateException(&quot;Unexpected status: &quot; + registerStatus);</span>
        }
    }

<span class="fc" id="L367">    private enum DedupResult { UNKNOWN, ACCEPT, REJECT }</span>

    private static DedupResult dedupResult(AbstractCompletable&lt;?&gt; state)
    {
<span class="fc" id="L371">        AbstractCompletable.Status status = state.getCompletionStatus();</span>
<span class="pc bpc" id="L372" title="2 of 4 branches missed.">        switch (status)</span>
        {
            case INIT:
<span class="nc" id="L375">                return DedupResult.UNKNOWN;</span>
            case ACCEPTED:
<span class="fc" id="L377">                return DedupResult.ACCEPT;</span>
            case COMPLETED:
<span class="fc bfc" id="L379" title="All 2 branches covered.">                return state.getResult().kind == Completable.Result.Kind.FAILURE ? DedupResult.REJECT: DedupResult.ACCEPT;</span>
            default:
<span class="nc" id="L381">                throw new IllegalStateException(&quot;Unknown status: &quot; + state);</span>
        }
    }

    private void replyDedup(AbstractCompletable&lt;?&gt; state, Message&lt;RepairMessage&gt; message)
    {
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">        if (state == null)</span>
<span class="nc" id="L388">            throw new IllegalStateException(&quot;State is null&quot;);</span>
<span class="fc" id="L389">        DedupResult result = dedupResult(state);</span>
<span class="pc bpc" id="L390" title="2 of 4 branches missed.">        switch (result)</span>
        {
            case ACCEPT:
<span class="fc" id="L393">                sendAck(message);</span>
<span class="fc" id="L394">                break;</span>
            case REJECT:
<span class="fc" id="L396">                sendFailureResponse(message);</span>
<span class="fc" id="L397">                break;</span>
            case UNKNOWN:
<span class="nc" id="L399">                break;</span>
            default:
<span class="nc" id="L401">                throw new IllegalStateException(&quot;Unknown result: &quot; + result);</span>
        }
<span class="fc" id="L403">    }</span>

    private void logErrorAndSendFailureResponse(String errorMessage, Message&lt;?&gt; respondTo)
    {
<span class="fc" id="L407">        logger.error(errorMessage);</span>
<span class="fc" id="L408">        sendFailureResponse(respondTo);</span>
<span class="fc" id="L409">    }</span>

    private void sendFailureResponse(Message&lt;?&gt; respondTo)
    {
<span class="fc" id="L413">        Message&lt;?&gt; reply = respondTo.failureResponse(RequestFailureReason.UNKNOWN);</span>
<span class="fc" id="L414">        ctx.messaging().send(reply, respondTo.from());</span>
<span class="fc" id="L415">    }</span>

    private void sendAck(Message&lt;RepairMessage&gt; message)
    {
<span class="fc" id="L419">        ctx.messaging().send(message.emptyResponse(), message.from());</span>
<span class="fc" id="L420">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>