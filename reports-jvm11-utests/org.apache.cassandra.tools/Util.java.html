<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Util.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.tools</a> &gt; <span class="el_source">Util.java</span></div><h1>Util.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.tools;

import java.io.IOException;
import java.io.PrintStream;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.TreeMap;
import java.util.function.LongFunction;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import com.google.common.base.Strings;
import com.google.common.collect.Lists;

import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.cql3.ColumnIdentifier;
import org.apache.cassandra.db.SerializationHeader;
import org.apache.cassandra.db.marshal.UTF8Type;
import org.apache.cassandra.dht.IPartitioner;
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.index.SecondaryIndexManager;
import org.apache.cassandra.io.sstable.Descriptor;
import org.apache.cassandra.io.sstable.format.StatsComponent;
import org.apache.cassandra.io.sstable.metadata.MetadataType;
import org.apache.cassandra.schema.IndexMetadata;
import org.apache.cassandra.schema.Indexes;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.utils.EstimatedHistogram;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.streamhist.TombstoneHistogram;

import static java.lang.String.format;

@SuppressWarnings(&quot;serial&quot;)
public final class Util
{
    static final String RESET = &quot;\u001B[0m&quot;;
    static final String BLUE = &quot;\u001B[34m&quot;;
    static final String CYAN = &quot;\u001B[36m&quot;;
    static final String WHITE = &quot;\u001B[37m&quot;;
<span class="fc" id="L63">    private static final List&lt;String&gt; ANSI_COLORS = Lists.newArrayList(RESET, BLUE, CYAN, WHITE);</span>

<span class="fc" id="L65">    private static final String FULL_BAR_UNICODE = Strings.repeat(&quot;\u2593&quot;, 30);</span>
<span class="fc" id="L66">    private static final String EMPTY_BAR_UNICODE = Strings.repeat(&quot;\u2591&quot;, 30);</span>
<span class="fc" id="L67">    private static final String FULL_BAR_ASCII = Strings.repeat(&quot;#&quot;, 30);</span>
<span class="fc" id="L68">    private static final String EMPTY_BAR_ASCII = Strings.repeat(&quot;-&quot;, 30);</span>

<span class="fc" id="L70">    private static final TreeMap&lt;Double, String&gt; BARS_UNICODE = new TreeMap&lt;Double, String&gt;()</span>
<span class="fc" id="L71">    {{</span>
<span class="fc" id="L72">        this.put(1.0,       &quot;\u2589&quot;); // full, actually using 7/8th for bad font impls of fullblock</span>
<span class="fc" id="L73">        this.put(7.0 / 8.0, &quot;\u2589&quot;); // 7/8ths left block</span>
<span class="fc" id="L74">        this.put(3.0 / 4.0, &quot;\u258A&quot;); // 3/4th block</span>
<span class="fc" id="L75">        this.put(5.0 / 8.0, &quot;\u258B&quot;); // 5/8th</span>
<span class="fc" id="L76">        this.put(3.0 / 8.0, &quot;\u258D&quot;); // three eighths, skips 1/2 due to font inconsistencies</span>
<span class="fc" id="L77">        this.put(1.0 / 4.0, &quot;\u258E&quot;); // 1/4th</span>
<span class="fc" id="L78">        this.put(1.0 / 8.0, &quot;\u258F&quot;); // 1/8th</span>
<span class="fc" id="L79">    }};</span>

<span class="fc" id="L81">    private static final TreeMap&lt;Double, String&gt; BARS_ASCII = new TreeMap&lt;Double, String&gt;()</span>
<span class="fc" id="L82">    {{</span>
<span class="fc" id="L83">        this.put(1.00, &quot;O&quot;);</span>
<span class="fc" id="L84">        this.put(0.75, &quot;o&quot;);</span>
<span class="fc" id="L85">        this.put(0.30, &quot;.&quot;);</span>
<span class="fc" id="L86">    }};</span>

    private static TreeMap&lt;Double, String&gt; barmap(boolean unicode)
    {
<span class="fc bfc" id="L90" title="All 2 branches covered.">        return unicode ? BARS_UNICODE : BARS_ASCII;</span>
    }

    public static String progress(double percentComplete, int width, boolean unicode)
    {
<span class="pc bpc" id="L95" title="2 of 4 branches missed.">        assert percentComplete &gt;= 0 &amp;&amp; percentComplete &lt;= 1;</span>
<span class="fc" id="L96">        int cols = (int) (percentComplete * width);</span>
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">        return (unicode ? FULL_BAR_UNICODE : FULL_BAR_ASCII).substring(width - cols) +</span>
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">               (unicode ? EMPTY_BAR_UNICODE : EMPTY_BAR_ASCII ).substring(cols);</span>
    }

    public static String stripANSI(String string)
    {
<span class="fc" id="L103">        return ANSI_COLORS.stream().reduce(string, (a, b) -&gt; a.replace(b, &quot;&quot;));</span>
    }

    public static int countANSI(String string)
    {
<span class="fc" id="L108">        return string.length() - stripANSI(string).length();</span>
    }

    public static String wrapQuiet(String toWrap, boolean color)
    {
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        if (Strings.isNullOrEmpty(toWrap))</span>
        {
<span class="nc" id="L115">            return &quot;&quot;;</span>
        }
<span class="fc" id="L117">        StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">        if (color) sb.append(WHITE);</span>
<span class="fc" id="L119">        sb.append(&quot;(&quot;);</span>
<span class="fc" id="L120">        sb.append(toWrap);</span>
<span class="fc" id="L121">        sb.append(&quot;)&quot;);</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">        if (color) sb.append(RESET);</span>
<span class="fc" id="L123">        return sb.toString();</span>
    }

    public static class TermHistogram
    {
        public long max;
        public long min;
        public double sum;
<span class="fc" id="L131">        int maxCountLength = 5;</span>
<span class="fc" id="L132">        int maxOffsetLength = 5;</span>
        Map&lt;? extends Number, Long&gt; histogram;
        LongFunction&lt;String&gt; offsetName;
        LongFunction&lt;String&gt; countName;
        String title;

        public TermHistogram(Map&lt;? extends Number, Long&gt; histogram,
                String title,
                LongFunction&lt;String&gt; offsetName,
                LongFunction&lt;String&gt; countName)
<span class="fc" id="L142">        {</span>
<span class="fc" id="L143">            this.offsetName = offsetName;</span>
<span class="fc" id="L144">            this.countName = countName;</span>
<span class="fc" id="L145">            this.histogram = histogram;</span>
<span class="fc" id="L146">            this.title = title;</span>
<span class="fc" id="L147">            maxOffsetLength = title.length();</span>
<span class="fc" id="L148">            histogram.entrySet().stream().forEach(e -&gt;</span>
            {
<span class="fc" id="L150">                max = Math.max(max, e.getValue());</span>
<span class="fc" id="L151">                min = Math.min(min, e.getValue());</span>
<span class="fc" id="L152">                sum += e.getValue();</span>
                // find max width, but remove ansi sequences first
<span class="fc" id="L154">                maxCountLength = Math.max(maxCountLength, stripANSI(countName.apply(e.getValue())).length());</span>
<span class="fc" id="L155">                maxOffsetLength = Math.max(maxOffsetLength, stripANSI(offsetName.apply(e.getKey().longValue())).length());</span>
<span class="fc" id="L156">            });</span>
<span class="fc" id="L157">        }</span>

        public TermHistogram(TombstoneHistogram histogram,
                String title,
                LongFunction&lt;String&gt; offsetName,
                LongFunction&lt;String&gt; countName)
        {
<span class="fc" id="L164">            this(new TreeMap&lt;Number, Long&gt;()</span>
<span class="fc" id="L165">            {</span>
                {
<span class="fc" id="L167">                    histogram.forEach((point, value) -&gt; {</span>
<span class="fc" id="L168">                        this.put(point, (long) value);</span>
<span class="fc" id="L169">                    });</span>
<span class="fc" id="L170">                }</span>
            }, title, offsetName, countName);
<span class="fc" id="L172">        }</span>

        public TermHistogram(EstimatedHistogram histogram,
                String title,
                LongFunction&lt;String&gt; offsetName,
                LongFunction&lt;String&gt; countName)
        {
<span class="fc" id="L179">            this(new TreeMap&lt;Number, Long&gt;()</span>
<span class="fc" id="L180">            {</span>
                {
<span class="fc" id="L182">                    long[] counts = histogram.getBuckets(false);</span>
<span class="fc" id="L183">                    long[] offsets = histogram.getBucketOffsets();</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">                    for (int i = 0; i &lt; counts.length; i++)</span>
                    {
<span class="fc" id="L186">                        long e = counts[i];</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">                        if (e &gt; 0)</span>
                        {
<span class="fc" id="L189">                            put(offsets[i], e);</span>
                        }
                    }
<span class="fc" id="L192">                }</span>
            }, title, offsetName, countName);
<span class="fc" id="L194">        }</span>

        public String bar(long count, int length, String color, boolean unicode)
        {
<span class="fc bfc" id="L198" title="All 2 branches covered.">            if (color == null) color = &quot;&quot;;</span>
<span class="fc" id="L199">            StringBuilder sb = new StringBuilder(color);</span>
<span class="fc" id="L200">            long barVal = count;</span>
<span class="fc" id="L201">            int intWidth = (int) (barVal * 1.0 / max * length);</span>
<span class="fc" id="L202">            double remainderWidth = (barVal * 1.0 / max * length) - intWidth;</span>
<span class="fc" id="L203">            sb.append(Strings.repeat(barmap(unicode).get(1.0), intWidth));</span>

<span class="pc bpc" id="L205" title="1 of 2 branches missed.">            if (barmap(unicode).floorKey(remainderWidth) != null)</span>
<span class="nc" id="L206">                sb.append(barmap(unicode).get(barmap(unicode).floorKey(remainderWidth)));</span>

<span class="fc bfc" id="L208" title="All 2 branches covered.">            if(!Strings.isNullOrEmpty(color))</span>
<span class="fc" id="L209">                sb.append(RESET);</span>

<span class="fc" id="L211">            return sb.toString();</span>
        }

        public void printHistogram(PrintStream out, boolean color, boolean unicode)
        {
            // String.format includes ansi sequences in the count, so need to modify the lengths
<span class="fc bfc" id="L217" title="All 2 branches covered.">            int offsetTitleLength = color ? maxOffsetLength + BLUE.length() : maxOffsetLength;</span>
<span class="fc" id="L218">            out.printf(&quot;   %-&quot; + offsetTitleLength + &quot;s %s %-&quot; + maxCountLength + &quot;s  %s  %sHistogram%s %n&quot;,</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">                       color ? BLUE + title : title,</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">                       color ? CYAN + &quot;|&quot; + BLUE : &quot;|&quot;,</span>
                       &quot;Count&quot;,
<span class="fc" id="L222">                       wrapQuiet(&quot;%&quot;, color),</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">                       color ? BLUE : &quot;&quot;,</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">                       color ? RESET : &quot;&quot;);</span>
<span class="fc" id="L225">            histogram.entrySet().stream().forEach(e -&gt;</span>
            {
<span class="fc" id="L227">                String offset = offsetName.apply(e.getKey().longValue());</span>
<span class="fc" id="L228">                long count = e.getValue();</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">                String histo = bar(count, 30, color? WHITE : null, unicode);</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">                int mol = color ? maxOffsetLength + countANSI(offset) : maxOffsetLength;</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">                int mcl = color ? maxCountLength + countANSI(countName.apply(count)) : maxCountLength;</span>
<span class="fc" id="L232">                out.printf(&quot;   %-&quot; + mol + &quot;s %s %&quot; + mcl + &quot;s %s %s%n&quot;,</span>
                           offset,
<span class="fc bfc" id="L234" title="All 2 branches covered.">                           color ? CYAN + &quot;|&quot; + RESET : &quot;|&quot;,</span>
<span class="fc" id="L235">                           countName.apply(count),</span>
<span class="fc" id="L236">                           wrapQuiet(String.format(&quot;%3s&quot;, (int) (100 * ((double) count / sum))), color),</span>
                           histo);
<span class="fc" id="L238">            });</span>
<span class="fc" id="L239">            EstimatedHistogram eh = new EstimatedHistogram(165);</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">            for (Entry&lt;? extends Number, Long&gt; e : histogram.entrySet())</span>
            {
<span class="fc" id="L242">                eh.add(e.getKey().longValue(), e.getValue());</span>
<span class="fc" id="L243">            }</span>
<span class="fc" id="L244">            String[] percentiles = new String[]{&quot;50th&quot;, &quot;75th&quot;, &quot;95th&quot;, &quot;98th&quot;, &quot;99th&quot;, &quot;Min&quot;, &quot;Max&quot;};</span>
<span class="fc" id="L245">            long[] data = new long[]</span>
            {
<span class="fc" id="L247">                eh.percentile(.5),</span>
<span class="fc" id="L248">                eh.percentile(.75),</span>
<span class="fc" id="L249">                eh.percentile(.95),</span>
<span class="fc" id="L250">                eh.percentile(.98),</span>
<span class="fc" id="L251">                eh.percentile(.99),</span>
<span class="fc" id="L252">                eh.min(),</span>
<span class="fc" id="L253">                eh.max(),</span>
            };
<span class="fc bfc" id="L255" title="All 4 branches covered.">            out.println((color ? BLUE : &quot;&quot;) + &quot;   Percentiles&quot; + (color ? RESET : &quot;&quot;));</span>

<span class="fc bfc" id="L257" title="All 2 branches covered.">            for (int i = 0; i &lt; percentiles.length; i++)</span>
            {
<span class="fc" id="L259">                out.println(format(&quot;   %s%-10s%s%s&quot;,</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">                                   (color ? BLUE : &quot;&quot;),</span>
                                   percentiles[i],
<span class="fc bfc" id="L262" title="All 2 branches covered.">                                   (color ? RESET : &quot;&quot;),</span>
<span class="fc" id="L263">                                   offsetName.apply(data[i])));</span>
            }
<span class="fc" id="L265">        }</span>
    }
    private Util()
    {
    }

    /**
     * This is used by standalone tools to force static initialization of DatabaseDescriptor, and fail if configuration
     * is bad.
     */
    public static void initDatabaseDescriptor()
    {
        try
        {
<span class="fc" id="L279">            DatabaseDescriptor.toolInitialization();</span>
        }
<span class="nc" id="L281">        catch (Throwable e)</span>
        {
<span class="nc bnc" id="L283" title="All 4 branches missed.">            boolean logStackTrace = !(e instanceof ConfigurationException) || ((ConfigurationException) e).logStackTrace;</span>
<span class="nc" id="L284">            System.out.println(&quot;Exception (&quot; + e.getClass().getName() + &quot;) encountered during startup: &quot; + e.getMessage());</span>

<span class="nc bnc" id="L286" title="All 2 branches missed.">            if (logStackTrace)</span>
            {
<span class="nc" id="L288">                e.printStackTrace();</span>
<span class="nc" id="L289">                System.exit(3);</span>
            }
            else
            {
<span class="nc" id="L293">                System.err.println(e.getMessage());</span>
<span class="nc" id="L294">                System.exit(3);</span>
            }
<span class="fc" id="L296">        }</span>
<span class="fc" id="L297">    }</span>

    public static &lt;T&gt; Stream&lt;T&gt; iterToStream(Iterator&lt;T&gt; iter)
    {
<span class="fc" id="L301">        Spliterator&lt;T&gt; splititer = Spliterators.spliteratorUnknownSize(iter, Spliterator.IMMUTABLE);</span>
<span class="fc" id="L302">        return StreamSupport.stream(splititer, false);</span>
    }

    /**
     * Construct table schema from info stored in SSTable's Stats.db
     *
     * @param desc SSTable's descriptor
     * @return Restored CFMetaData
     * @throws IOException when Stats.db cannot be read
     */
    public static TableMetadata metadataFromSSTable(Descriptor desc) throws IOException
    {
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">        if (!desc.version.isCompatible())</span>
<span class="nc" id="L315">            throw new IOException(&quot;Unsupported SSTable version &quot; + desc.getFormat().name() + &quot;/&quot; + desc.version);</span>

<span class="fc" id="L317">        StatsComponent statsComponent = StatsComponent.load(desc, MetadataType.STATS, MetadataType.HEADER);</span>
<span class="fc" id="L318">        SerializationHeader.Component header = statsComponent.serializationHeader();</span>

<span class="fc" id="L320">        IPartitioner partitioner = FBUtilities.newPartitioner(desc);</span>

<span class="fc" id="L322">        TableMetadata.Builder builder = TableMetadata.builder(&quot;keyspace&quot;, &quot;table&quot;).partitioner(partitioner);</span>
<span class="fc" id="L323">        header.getStaticColumns().entrySet().stream()</span>
<span class="fc" id="L324">                .forEach(entry -&gt; {</span>
<span class="fc" id="L325">                    ColumnIdentifier ident = ColumnIdentifier.getInterned(UTF8Type.instance.getString(entry.getKey()), true);</span>
<span class="fc" id="L326">                    builder.addStaticColumn(ident, entry.getValue());</span>
<span class="fc" id="L327">                });</span>
<span class="fc" id="L328">        header.getRegularColumns().entrySet().stream()</span>
<span class="fc" id="L329">                .forEach(entry -&gt; {</span>
<span class="fc" id="L330">                    ColumnIdentifier ident = ColumnIdentifier.getInterned(UTF8Type.instance.getString(entry.getKey()), true);</span>
<span class="fc" id="L331">                    builder.addRegularColumn(ident, entry.getValue());</span>
<span class="fc" id="L332">                });</span>
<span class="fc" id="L333">        builder.addPartitionKeyColumn(&quot;PartitionKey&quot;, header.getKeyType());</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">        for (int i = 0; i &lt; header.getClusteringTypes().size(); i++)</span>
        {
<span class="fc bfc" id="L336" title="All 2 branches covered.">            builder.addClusteringColumn(&quot;clustering&quot; + (i &gt; 0 ? i : &quot;&quot;), header.getClusteringTypes().get(i));</span>
        }
<span class="fc bfc" id="L338" title="All 2 branches covered.">        if (SecondaryIndexManager.isIndexColumnFamily(desc.cfname))</span>
        {
<span class="fc" id="L340">            String index = SecondaryIndexManager.getIndexName(desc.cfname);</span>
            // Just set the Kind of index to CUSTOM, which is an irrelevant parameter that doesn't make any effect on the result
<span class="fc" id="L342">            IndexMetadata indexMetadata = IndexMetadata.fromSchemaMetadata(index, IndexMetadata.Kind.CUSTOM, null);</span>
<span class="fc" id="L343">            Indexes indexes = Indexes.of(indexMetadata);</span>
<span class="fc" id="L344">            builder.indexes(indexes);</span>
<span class="fc" id="L345">            builder.kind(TableMetadata.Kind.INDEX);</span>
        }
<span class="fc" id="L347">        return builder.build();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>