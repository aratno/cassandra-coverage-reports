<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WaitQueue.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.utils.concurrent</a> &gt; <span class="el_source">WaitQueue.java</span></div><h1>WaitQueue.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cassandra.utils.concurrent;

import java.util.Iterator;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import java.util.concurrent.locks.LockSupport;
import java.util.function.BooleanSupplier;
import java.util.function.Consumer;

import org.apache.cassandra.utils.Intercept;
import org.apache.cassandra.utils.Shared;
import org.apache.cassandra.utils.concurrent.Awaitable.AbstractAwaitable;

import static org.apache.cassandra.utils.Clock.Global.nanoTime;
import static org.apache.cassandra.utils.Shared.Recursive.INTERFACES;
import static org.apache.cassandra.utils.Shared.Scope.SIMULATION;

/**
 * &lt;p&gt;A relatively easy to use utility for general purpose thread signalling.&lt;/p&gt;
 * &lt;p&gt;Usage on a thread awaiting a state change using a WaitQueue q is:&lt;/p&gt;
 * &lt;pre&gt;
 * {@code
 *      while (!conditionMet())
 *          Signal s = q.register();
 *              if (!conditionMet())    // or, perhaps more correctly, !conditionChanged()
 *                  s.await();
 *              else
 *                  s.cancel();
 * }
 * &lt;/pre&gt;
 * A signalling thread, AFTER changing the state, then calls q.signal() to wake up one, or q.signalAll()
 * to wake up all, waiting threads.
 * &lt;p&gt;To understand intuitively how this class works, the idea is simply that a thread, once it considers itself
 * incapable of making progress, registers to be awoken once that changes. Since this could have changed between
 * checking and registering (in which case the thread that made this change would have been unable to signal it),
 * it checks the condition again, sleeping only if it hasn't changed/still is not met.&lt;/p&gt;
 * &lt;p&gt;This thread synchronisation scheme has some advantages over Condition objects and Object.wait/notify in that no monitor
 * acquisition is necessary and, in fact, besides the actual waiting on a signal, all operations are non-blocking.
 * As a result consumers can never block producers, nor each other, or vice versa, from making progress.
 * Threads that are signalled are also put into a RUNNABLE state almost simultaneously, so they can all immediately make
 * progress without having to serially acquire the monitor/lock, reducing scheduler delay incurred.&lt;/p&gt;
 *
 * &lt;p&gt;A few notes on utilisation:&lt;/p&gt;
 * &lt;p&gt;1. A thread will only exit await() when it has been signalled, but this does not guarantee the condition has not
 * been altered since it was signalled, and depending on your design it is likely the outer condition will need to be
 * checked in a loop, though this is not always the case.&lt;/p&gt;
 * &lt;p&gt;2. Each signal is single use, so must be re-registered after each await(). This is true even if it times out.&lt;/p&gt;
 * &lt;p&gt;3. If you choose not to wait on the signal (because the condition has been met before you waited on it)
 * you must cancel() the signal if the signalling thread uses signal() to awake waiters; otherwise signals will be
 * lost. If signalAll() is used but infrequent, and register() is frequent, cancel() should still be used to prevent the
 * queue growing unboundedly. Similarly, if you provide a TimerContext, cancel should be used to ensure it is not erroneously
 * counted towards wait time.&lt;/p&gt;
 * &lt;p&gt;4. Care must be taken when selecting conditionMet() to ensure we are waiting on the condition that actually
 * indicates progress is possible. In some complex cases it may be tempting to wait on a condition that is only indicative
 * of local progress, not progress on the task we are aiming to complete, and a race may leave us waiting for a condition
 * to be met that we no longer need.
 * &lt;p&gt;5. This scheme is not fair&lt;/p&gt;
 * &lt;p&gt;6. Only the thread that calls register() may call await()&lt;/p&gt;
 *
 * TODO: this class should not be backed by CLQ (should use an intrusive linked-list with lower overhead)
 */
@Shared(scope = SIMULATION, inner = INTERFACES)
public interface WaitQueue
{
    /**
     * A Signal is a one-time-use mechanism for a thread to wait for notification that some condition
     * state has transitioned that it may be interested in (and hence should check if it is).
     * It is potentially transient, i.e. the state can change in the meantime, it only indicates
     * that it should be checked, not necessarily anything about what the expected state should be.
     *
     * Signal implementations should never wake up spuriously, they are always woken up by a
     * signal() or signalAll().
     *
     * This abstract definition of Signal does not need to be tied to a WaitQueue.
     * Whilst RegisteredSignal is the main building block of Signals, this abstract
     * definition allows us to compose Signals in useful ways. The Signal is 'owned' by the
     * thread that registered itself with WaitQueue(s) to obtain the underlying RegisteredSignal(s);
     * only the owning thread should use a Signal.
     */
    public static interface Signal extends Condition
    {
        /**
         * @return true if cancelled; once cancelled, must be discarded by the owning thread.
         */
        public boolean isCancelled();

        /**
         * @return isSignalled() || isCancelled(). Once true, the state is fixed and the Signal should be discarded
         * by the owning thread.
         */
        public boolean isSet();

        /**
         * atomically: cancels the Signal if !isSet(), or returns true if isSignalled()
         *
         * @return true if isSignalled()
         */
        public boolean checkAndClear();

        /**
         * Should only be called by the owning thread. Indicates the signal can be retired,
         * and if signalled propagates the signal to another waiting thread
         */
        public abstract void cancel();
    }

    /**
     * The calling thread MUST be the thread that uses the signal
     */
    public Signal register();

    /**
     * The calling thread MUST be the thread that uses the signal.
     * If the Signal is waited on, context.stop() will be called when the wait times out, the Signal is signalled,
     * or the waiting thread is interrupted.
     */
    public &lt;V&gt; Signal register(V supplyOnDone, Consumer&lt;V&gt; receiveOnDone);

    /**
     * Signal one waiting thread
     */
    public boolean signal();

    /**
     * Signal all waiting threads
     */
    public void signalAll();

    /** getWaiting() &gt; 0 */
    public boolean hasWaiters();

    /** Return how many threads are waiting */
    public int getWaiting();

    /**
     * Factory method used to capture and redirect instantiations for simulation
     */
    @Intercept
    public static WaitQueue newWaitQueue()
    {
<span class="fc" id="L159">        return new Standard();</span>
    }

    class Standard implements WaitQueue
    {
        private static final int CANCELLED = -1;
        private static final int SIGNALLED = 1;
        private static final int NOT_SET = 0;

<span class="fc" id="L168">        private static final AtomicIntegerFieldUpdater&lt;RegisteredSignal&gt; signalledUpdater = AtomicIntegerFieldUpdater.newUpdater(RegisteredSignal.class, &quot;state&quot;);</span>

        // the waiting signals
<span class="fc" id="L171">        private final ConcurrentLinkedQueue&lt;RegisteredSignal&gt; queue = new ConcurrentLinkedQueue&lt;&gt;();</span>

<span class="fc" id="L173">        protected Standard() {}</span>

        /**
         * The calling thread MUST be the thread that uses the signal
         * @return                                x
         */
        public Signal register()
        {
<span class="fc" id="L181">            RegisteredSignal signal = new RegisteredSignal();</span>
<span class="fc" id="L182">            queue.add(signal);</span>
<span class="fc" id="L183">            return signal;</span>
        }

        /**
         * The calling thread MUST be the thread that uses the signal.
         * If the Signal is waited on, context.stop() will be called when the wait times out, the Signal is signalled,
         * or the waiting thread is interrupted.
         */
        public &lt;V&gt; Signal register(V supplyOnDone, Consumer&lt;V&gt; receiveOnDone)
        {
<span class="fc" id="L193">            RegisteredSignal signal = new SignalWithListener&lt;&gt;(supplyOnDone, receiveOnDone);</span>
<span class="fc" id="L194">            queue.add(signal);</span>
<span class="fc" id="L195">            return signal;</span>
        }

        /**
         * Signal one waiting thread
         */
        public boolean signal()
        {
            while (true)
            {
<span class="fc" id="L205">                RegisteredSignal s = queue.poll();</span>
<span class="fc bfc" id="L206" title="All 4 branches covered.">                if (s == null || s.doSignal() != null)</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">                    return s != null;</span>
<span class="fc" id="L208">            }</span>
        }

        /**
         * Signal all waiting threads
         */
        public void signalAll()
        {
<span class="fc bfc" id="L216" title="All 2 branches covered.">            if (!hasWaiters())</span>
<span class="fc" id="L217">                return;</span>

            // to avoid a race where the condition is not met and the woken thread managed to wait on the queue before
            // we finish signalling it all, we pick a random thread we have woken-up and hold onto it, so that if we encounter
            // it again we know we're looping. We reselect a random thread periodically, progressively less often.
            // the &quot;correct&quot; solution to this problem is to use a queue that permits snapshot iteration, but this solution is sufficient
            // TODO: this is only necessary because we use CLQ - which is only for historical any-NIH reasons
<span class="fc" id="L224">            int i = 0, s = 5;</span>
<span class="fc" id="L225">            Thread randomThread = null;</span>
<span class="fc" id="L226">            Iterator&lt;RegisteredSignal&gt; iter = queue.iterator();</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">            while (iter.hasNext())</span>
            {
<span class="fc" id="L229">                RegisteredSignal signal = iter.next();</span>
<span class="fc" id="L230">                Thread signalled = signal.doSignal();</span>

<span class="fc bfc" id="L232" title="All 2 branches covered.">                if (signalled != null)</span>
                {
<span class="fc bfc" id="L234" title="All 2 branches covered.">                    if (signalled == randomThread)</span>
<span class="fc" id="L235">                        break;</span>

<span class="fc bfc" id="L237" title="All 2 branches covered.">                    if (++i == s)</span>
                    {
<span class="fc" id="L239">                        randomThread = signalled;</span>
<span class="fc" id="L240">                        s &lt;&lt;= 1;</span>
                    }
                }

<span class="fc" id="L244">                iter.remove();</span>
<span class="fc" id="L245">            }</span>
<span class="fc" id="L246">        }</span>

        private void cleanUpCancelled()
        {
            // TODO: attempt to remove the cancelled from the beginning only (need atomic cas of head)
<span class="fc" id="L251">            queue.removeIf(RegisteredSignal::isCancelled);</span>
<span class="fc" id="L252">        }</span>

        public boolean hasWaiters()
        {
<span class="fc bfc" id="L256" title="All 2 branches covered.">            return !queue.isEmpty();</span>
        }

        /**
         * @return how many threads are waiting
         */
        public int getWaiting()
        {
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">            if (!hasWaiters())</span>
<span class="fc" id="L265">                return 0;</span>
<span class="nc" id="L266">            Iterator&lt;RegisteredSignal&gt; iter = queue.iterator();</span>
<span class="nc" id="L267">            int count = 0;</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">            while (iter.hasNext())</span>
            {
<span class="nc" id="L270">                Signal next = iter.next();</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">                if (!next.isCancelled())</span>
<span class="nc" id="L272">                    count++;</span>
<span class="nc" id="L273">            }</span>
<span class="nc" id="L274">            return count;</span>
        }

        /**
         * An abstract signal implementation
         *
         * TODO: use intrusive linked list
         */
<span class="fc" id="L282">        public static abstract class AbstractSignal extends AbstractAwaitable implements Signal</span>
        {
            public Signal await() throws InterruptedException
            {
<span class="fc bfc" id="L286" title="All 2 branches covered.">                while (!isSignalled())</span>
                {
<span class="fc" id="L288">                    checkInterrupted();</span>
<span class="fc" id="L289">                    LockSupport.park();</span>
                }
<span class="fc" id="L291">                checkAndClear();</span>
<span class="fc" id="L292">                return this;</span>
            }

            public boolean awaitUntil(long nanoTimeDeadline) throws InterruptedException
            {
                long now;
<span class="fc bfc" id="L298" title="All 4 branches covered.">                while (nanoTimeDeadline &gt; (now = nanoTime()) &amp;&amp; !isSignalled())</span>
                {
<span class="fc" id="L300">                    checkInterrupted();</span>
<span class="fc" id="L301">                    long delta = nanoTimeDeadline - now;</span>
<span class="fc" id="L302">                    LockSupport.parkNanos(delta);</span>
<span class="fc" id="L303">                }</span>
<span class="fc" id="L304">                return checkAndClear();</span>
            }

            private void checkInterrupted() throws InterruptedException
            {
<span class="fc bfc" id="L309" title="All 2 branches covered.">                if (Thread.interrupted())</span>
                {
<span class="fc" id="L311">                    cancel();</span>
<span class="fc" id="L312">                    throw new InterruptedException();</span>
                }
<span class="fc" id="L314">            }</span>
        }

        /**
         * A signal registered with this WaitQueue
         */
<span class="fc" id="L320">        private class RegisteredSignal extends AbstractSignal</span>
        {
<span class="fc" id="L322">            private volatile Thread thread = Thread.currentThread();</span>
            volatile int state;

            public boolean isSignalled()
            {
<span class="fc bfc" id="L327" title="All 2 branches covered.">                return state == SIGNALLED;</span>
            }

            public boolean isCancelled()
            {
<span class="fc bfc" id="L332" title="All 2 branches covered.">                return state == CANCELLED;</span>
            }

            public boolean isSet()
            {
<span class="fc bfc" id="L337" title="All 2 branches covered.">                return state != NOT_SET;</span>
            }

            private Thread doSignal()
            {
<span class="fc bfc" id="L342" title="All 4 branches covered.">                if (!isSet() &amp;&amp; signalledUpdater.compareAndSet(this, NOT_SET, SIGNALLED))</span>
                {
<span class="fc" id="L344">                    Thread thread = this.thread;</span>
<span class="fc" id="L345">                    LockSupport.unpark(thread);</span>
<span class="fc" id="L346">                    this.thread = null;</span>
<span class="fc" id="L347">                    return thread;</span>
                }
<span class="fc" id="L349">                return null;</span>
            }

            public void signal()
            {
<span class="fc" id="L354">                doSignal();</span>
<span class="fc" id="L355">            }</span>

            public boolean checkAndClear()
            {
<span class="pc bpc" id="L359" title="1 of 4 branches missed.">                if (!isSet() &amp;&amp; signalledUpdater.compareAndSet(this, NOT_SET, CANCELLED))</span>
                {
<span class="fc" id="L361">                    thread = null;</span>
<span class="fc" id="L362">                    cleanUpCancelled();</span>
<span class="fc" id="L363">                    return false;</span>
                }
                // must now be signalled assuming correct API usage
<span class="fc" id="L366">                return true;</span>
            }

            /**
             * Should only be called by the registered thread. Indicates the signal can be retired,
             * and if signalled propagates the signal to another waiting thread
             */
            public void cancel()
            {
<span class="fc bfc" id="L375" title="All 2 branches covered.">                if (isCancelled())</span>
<span class="fc" id="L376">                    return;</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">                if (!signalledUpdater.compareAndSet(this, NOT_SET, CANCELLED))</span>
                {
                    // must already be signalled - switch to cancelled and
<span class="fc" id="L380">                    state = CANCELLED;</span>
                    // propagate the signal
<span class="fc" id="L382">                    WaitQueue.Standard.this.signal();</span>
                }
<span class="fc" id="L384">                thread = null;</span>
<span class="fc" id="L385">                cleanUpCancelled();</span>
<span class="fc" id="L386">            }</span>
        }

        /**
         * A RegisteredSignal that stores a TimerContext, and stops the timer when either cancelled or
         * finished waiting. i.e. if the timer is started when the signal is registered it tracks the
         * time in between registering and invalidating the signal.
         */
        private final class SignalWithListener&lt;V&gt; extends RegisteredSignal
        {
            private final V supplyOnDone;
            private final Consumer&lt;V&gt; receiveOnDone;

            private SignalWithListener(V supplyOnDone, Consumer&lt;V&gt; receiveOnDone)
<span class="fc" id="L400">            {</span>
<span class="fc" id="L401">                this.receiveOnDone = receiveOnDone;</span>
<span class="fc" id="L402">                this.supplyOnDone = supplyOnDone;</span>
<span class="fc" id="L403">            }</span>


            @Override
            public boolean checkAndClear()
            {
<span class="fc" id="L409">                receiveOnDone.accept(supplyOnDone);</span>
<span class="fc" id="L410">                return super.checkAndClear();</span>
            }

            @Override
            public void cancel()
            {
<span class="nc bnc" id="L416" title="All 2 branches missed.">                if (!isCancelled())</span>
                {
<span class="nc" id="L418">                    receiveOnDone.accept(supplyOnDone);</span>
<span class="nc" id="L419">                    super.cancel();</span>
                }
<span class="nc" id="L421">            }</span>
        }
    }

    /**
     * Loops waiting on the supplied condition and WaitQueue and will not return until the condition is true
     */
    public static void waitOnCondition(BooleanSupplier condition, WaitQueue queue) throws InterruptedException
    {
<span class="fc bfc" id="L430" title="All 2 branches covered.">        while (!condition.getAsBoolean())</span>
        {
<span class="fc" id="L432">            Signal s = queue.register();</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">            if (!condition.getAsBoolean()) s.await();</span>
<span class="fc" id="L434">            else s.cancel();</span>
<span class="fc" id="L435">        }</span>
<span class="fc" id="L436">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>