<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BtiFormat.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.io.sstable.format.bti</a> &gt; <span class="el_source">BtiFormat.java</span></div><h1>BtiFormat.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.io.sstable.format.bti;

import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
import org.apache.cassandra.dht.IPartitioner;
import org.apache.cassandra.io.sstable.Component;
import org.apache.cassandra.io.sstable.Descriptor;
import org.apache.cassandra.io.sstable.GaugeProvider;
import org.apache.cassandra.io.sstable.IScrubber;
import org.apache.cassandra.io.sstable.MetricsProviders;
import org.apache.cassandra.io.sstable.SSTable;
import org.apache.cassandra.io.sstable.filter.BloomFilterMetrics;
import org.apache.cassandra.io.sstable.format.AbstractSSTableFormat;
import org.apache.cassandra.io.sstable.format.SSTableFormat;
import org.apache.cassandra.io.sstable.format.SSTableReader;
import org.apache.cassandra.io.sstable.format.SSTableReaderLoadingBuilder;
import org.apache.cassandra.io.sstable.format.SSTableWriter;
import org.apache.cassandra.io.sstable.format.SortedTableScrubber;
import org.apache.cassandra.io.sstable.format.Version;
import org.apache.cassandra.net.MessagingService;
import org.apache.cassandra.schema.TableMetadataRef;
import org.apache.cassandra.utils.JVMStabilityInspector;
import org.apache.cassandra.utils.OutputHandler;
import org.apache.cassandra.utils.Pair;

/**
 * Bigtable format with trie indices. See BTIFormat.md for the format documentation.
 */
public class BtiFormat extends AbstractSSTableFormat&lt;BtiTableReader, BtiTableWriter&gt;
{
<span class="fc" id="L62">    private final static Logger logger = LoggerFactory.getLogger(BtiFormat.class);</span>

    public static final String NAME = &quot;bti&quot;;

<span class="fc" id="L66">    private final Version latestVersion = new BtiVersion(this, BtiVersion.current_version);</span>
<span class="fc" id="L67">    static final BtiTableReaderFactory readerFactory = new BtiTableReaderFactory();</span>
<span class="fc" id="L68">    static final BtiTableWriterFactory writerFactory = new BtiTableWriterFactory();</span>

<span class="nc" id="L70">    public static class Components extends SSTableFormat.Components</span>
    {
<span class="nc" id="L72">        public static class Types extends AbstractSSTableFormat.Components.Types</span>
        {
<span class="fc" id="L74">            public static final Component.Type PARTITION_INDEX = Component.Type.createSingleton(&quot;PARTITION_INDEX&quot;, &quot;Partitions.db&quot;, true, BtiFormat.class);</span>
<span class="fc" id="L75">            public static final Component.Type ROW_INDEX = Component.Type.createSingleton(&quot;ROW_INDEX&quot;, &quot;Rows.db&quot;, true, BtiFormat.class);</span>
        }

<span class="fc" id="L78">        public final static Component PARTITION_INDEX = Types.PARTITION_INDEX.getSingleton();</span>

<span class="fc" id="L80">        public final static Component ROW_INDEX = Types.ROW_INDEX.getSingleton();</span>

<span class="fc" id="L82">        private final static Set&lt;Component&gt; PRIMARY_COMPONENTS = ImmutableSet.of(DATA,</span>
                                                                                 PARTITION_INDEX);

<span class="fc" id="L85">        private final static Set&lt;Component&gt; MUTABLE_COMPONENTS = ImmutableSet.of(STATS);</span>

<span class="fc" id="L87">        private static final Set&lt;Component&gt; UPLOAD_COMPONENTS = ImmutableSet.of(DATA,</span>
                                                                                PARTITION_INDEX,
                                                                                ROW_INDEX,
                                                                                COMPRESSION_INFO,
                                                                                STATS);

<span class="fc" id="L93">        private static final Set&lt;Component&gt; BATCH_COMPONENTS = ImmutableSet.of(DATA,</span>
                                                                               PARTITION_INDEX,
                                                                               ROW_INDEX,
                                                                               COMPRESSION_INFO,
                                                                               FILTER,
                                                                               STATS);

<span class="fc" id="L100">        private final static Set&lt;Component&gt; ALL_COMPONENTS = ImmutableSet.of(DATA,</span>
                                                                             PARTITION_INDEX,
                                                                             ROW_INDEX,
                                                                             STATS,
                                                                             COMPRESSION_INFO,
                                                                             FILTER,
                                                                             DIGEST,
                                                                             CRC,
                                                                             TOC);

<span class="fc" id="L110">        private final static Set&lt;Component&gt; GENERATED_ON_LOAD_COMPONENTS = ImmutableSet.of(FILTER);</span>
    }


    public BtiFormat(Map&lt;String, String&gt; options)
    {
<span class="fc" id="L116">        super(NAME, options);</span>
<span class="fc" id="L117">    }</span>

    public static boolean is(SSTableFormat&lt;?, ?&gt; format)
    {
<span class="fc" id="L121">        return format.name().equals(NAME);</span>
    }

    public static boolean isSelected()
    {
<span class="fc" id="L126">        return is(DatabaseDescriptor.getSelectedSSTableFormat());</span>
    }

    @Override
    public Version getLatestVersion()
    {
<span class="fc" id="L132">        return latestVersion;</span>
    }

    @Override
    public Version getVersion(String version)
    {
<span class="fc" id="L138">        return new BtiVersion(this, version);</span>
    }

    @Override
    public BtiTableWriterFactory getWriterFactory()
    {
<span class="fc" id="L144">        return writerFactory;</span>
    }

    @Override
    public BtiTableReaderFactory getReaderFactory()
    {
<span class="fc" id="L150">        return readerFactory;</span>
    }

    @Override
    public Set&lt;Component&gt; primaryComponents()
    {
<span class="fc" id="L156">        return Components.PRIMARY_COMPONENTS;</span>
    }

    @Override
    public Set&lt;Component&gt; batchComponents()
    {
<span class="nc" id="L162">        return Components.BATCH_COMPONENTS;</span>
    }

    @Override
    public Set&lt;Component&gt; uploadComponents()
    {
<span class="nc" id="L168">        return Components.UPLOAD_COMPONENTS;</span>
    }

    @Override
    public Set&lt;Component&gt; mutableComponents()
    {
<span class="fc" id="L174">        return Components.MUTABLE_COMPONENTS;</span>
    }

    @Override
    public Set&lt;Component&gt; allComponents()
    {
<span class="fc" id="L180">        return Components.ALL_COMPONENTS;</span>
    }

    @Override
    public Set&lt;Component&gt; generatedOnLoadComponents()
    {
<span class="fc" id="L186">        return Components.GENERATED_ON_LOAD_COMPONENTS;</span>
    }

    @Override
    public SSTableFormat.KeyCacheValueSerializer&lt;BtiTableReader, TrieIndexEntry&gt; getKeyCacheValueSerializer()
    {
<span class="nc" id="L192">        throw new AssertionError(&quot;BTI sstables do not use key cache&quot;);</span>
    }

    @Override
    public IScrubber getScrubber(ColumnFamilyStore cfs, LifecycleTransaction transaction, OutputHandler outputHandler, IScrubber.Options options)
    {
<span class="nc" id="L198">        Preconditions.checkArgument(cfs.metadata().equals(transaction.onlyOne().metadata()), &quot;SSTable metadata does not match current definition&quot;);</span>
<span class="nc" id="L199">        return new BtiTableScrubber(cfs, transaction, outputHandler, options);</span>
    }

    @Override
    public MetricsProviders getFormatSpecificMetricsProviders()
    {
<span class="fc" id="L205">        return BtiTableSpecificMetricsProviders.instance;</span>
    }

    @Override
    public void deleteOrphanedComponents(Descriptor descriptor, Set&lt;Component&gt; components)
    {
<span class="nc" id="L211">        SortedTableScrubber.deleteOrphanedComponents(descriptor, components);</span>
<span class="nc" id="L212">    }</span>

    private void delete(Descriptor desc, List&lt;Component&gt; components)
    {
<span class="fc" id="L216">        logger.info(&quot;Deleting sstable: {}&quot;, desc);</span>

<span class="pc bpc" id="L218" title="1 of 2 branches missed.">        if (components.remove(SSTableFormat.Components.DATA))</span>
<span class="fc" id="L219">            components.add(0, SSTableFormat.Components.DATA); // DATA component should be first</span>

<span class="fc bfc" id="L221" title="All 2 branches covered.">        for (Component component : components)</span>
        {
<span class="fc" id="L223">            logger.trace(&quot;Deleting component {} of {}&quot;, component, desc);</span>
<span class="fc" id="L224">            desc.fileFor(component).deleteIfExists();</span>
<span class="fc" id="L225">        }</span>
<span class="fc" id="L226">    }</span>

    @Override
    public void delete(Descriptor desc)
    {
        try
        {
<span class="fc" id="L233">            delete(desc, Lists.newArrayList(Sets.intersection(allComponents(), desc.discoverComponents())));</span>
        }
<span class="nc" id="L235">        catch (Throwable t)</span>
        {
<span class="nc" id="L237">            JVMStabilityInspector.inspectThrowable(t);</span>
<span class="fc" id="L238">        }</span>
<span class="fc" id="L239">    }</span>

<span class="fc" id="L241">    static class BtiTableReaderFactory implements SSTableReaderFactory&lt;BtiTableReader, BtiTableReader.Builder&gt;</span>
    {
        @Override
        public SSTableReader.Builder&lt;BtiTableReader, BtiTableReader.Builder&gt; builder(Descriptor descriptor)
        {
<span class="fc" id="L246">            return new BtiTableReader.Builder(descriptor);</span>
        }

        @Override
        public SSTableReaderLoadingBuilder&lt;BtiTableReader, BtiTableReader.Builder&gt; loadingBuilder(Descriptor descriptor, TableMetadataRef tableMetadataRef, Set&lt;Component&gt; components)
        {
<span class="fc" id="L252">            return new BtiTableReaderLoadingBuilder(new SSTable.Builder&lt;&gt;(descriptor).setTableMetadataRef(tableMetadataRef)</span>
<span class="fc" id="L253">                                                                                     .setComponents(components));</span>
        }

        @Override
        public Pair&lt;DecoratedKey, DecoratedKey&gt; readKeyRange(Descriptor descriptor, IPartitioner partitioner) throws IOException
        {
<span class="nc" id="L259">            return PartitionIndex.readFirstAndLastKey(descriptor.fileFor(Components.PARTITION_INDEX), partitioner);</span>
        }

        @Override
        public Class&lt;BtiTableReader&gt; getReaderClass()
        {
<span class="nc" id="L265">            return BtiTableReader.class;</span>
        }
    }

<span class="fc" id="L269">    static class BtiTableWriterFactory implements SSTableWriterFactory&lt;BtiTableWriter, BtiTableWriter.Builder&gt;</span>
    {
        @Override
        public BtiTableWriter.Builder builder(Descriptor descriptor)
        {
<span class="fc" id="L274">            return new BtiTableWriter.Builder(descriptor);</span>
        }

        @Override
        public long estimateSize(SSTableWriter.SSTableSizeParameters parameters)
        {
<span class="fc" id="L280">            return (long) ((parameters.partitionCount() * 8 // index entries</span>
<span class="fc" id="L281">                            + parameters.partitionKeysSize() // keys in data file</span>
<span class="fc" id="L282">                            + parameters.dataSize()) // data</span>
                           * 1.2); // bloom filter and row index overhead
        }
    }

    static class BtiVersion extends Version
    {
        public static final String current_version = &quot;da&quot;;
        public static final String earliest_supported_version = &quot;da&quot;;

        // versions aa-cz are not supported in OSS
        // da (5.0): initial version of the BIT format
        // NOTE: when adding a new version, please add that to LegacySSTableTest, too.

        private final boolean isLatestVersion;

        private final int correspondingMessagingVersion;

        BtiVersion(BtiFormat format, String version)
        {
<span class="fc" id="L302">            super(format, version);</span>

<span class="fc bfc" id="L304" title="All 2 branches covered.">            isLatestVersion = version.compareTo(current_version) == 0;</span>
<span class="fc" id="L305">            correspondingMessagingVersion = MessagingService.VERSION_40;</span>
<span class="fc" id="L306">        }</span>

        @Override
        public boolean isLatestVersion()
        {
<span class="fc" id="L311">            return isLatestVersion;</span>
        }

        @Override
        public int correspondingMessagingVersion()
        {
<span class="fc" id="L317">            return correspondingMessagingVersion;</span>
        }

        @Override
        public boolean hasCommitLogLowerBound()
        {
<span class="fc" id="L323">            return true;</span>
        }

        @Override
        public boolean hasCommitLogIntervals()
        {
<span class="fc" id="L329">            return true;</span>
        }

        @Override
        public boolean hasMaxCompressedLength()
        {
<span class="fc" id="L335">            return true;</span>
        }

        @Override
        public boolean hasPendingRepair()
        {
<span class="fc" id="L341">            return true;</span>
        }

        @Override
        public boolean hasIsTransient()
        {
<span class="fc" id="L347">            return true;</span>
        }

        @Override
        public boolean hasMetadataChecksum()
        {
<span class="fc" id="L353">            return true;</span>
        }

        @Override
        public boolean hasOldBfFormat()
        {
<span class="fc" id="L359">            return false;</span>
        }

        @Override
        public boolean hasAccurateMinMax()
        {
<span class="nc" id="L365">            return true;</span>
        }

        public boolean hasLegacyMinMax()
        {
<span class="fc" id="L370">            return false;</span>
        }

        @Override
        public boolean hasOriginatingHostId()
        {
<span class="fc" id="L376">            return true;</span>
        }

        @Override
        public boolean hasImprovedMinMax() {
<span class="fc" id="L381">            return true;</span>
        }

        @Override
        public boolean hasTokenSpaceCoverage()
        {
<span class="fc" id="L387">            return true;</span>
        }

        @Override
        public boolean hasPartitionLevelDeletionsPresenceMarker()
        {
<span class="fc" id="L393">            return true;</span>
        }

        @Override
        public boolean hasKeyRange()
        {
<span class="fc" id="L399">            return true;</span>
        }

        @Override
        public boolean isCompatible()
        {
<span class="pc bpc" id="L405" title="2 of 4 branches missed.">            return version.compareTo(earliest_supported_version) &gt;= 0 &amp;&amp; version.charAt(0) &lt;= current_version.charAt(0);</span>
        }

        @Override
        public boolean isCompatibleForStreaming()
        {
<span class="nc bnc" id="L411" title="All 4 branches missed.">            return isCompatible() &amp;&amp; version.charAt(0) == current_version.charAt(0);</span>
        }

        @Override
        public boolean hasUIntDeletionTime()
        {
<span class="fc" id="L417">            return true;</span>
        }

    }

<span class="fc" id="L422">    private static class BtiTableSpecificMetricsProviders implements MetricsProviders</span>
    {
<span class="fc" id="L424">        private final static BtiTableSpecificMetricsProviders instance = new BtiTableSpecificMetricsProviders();</span>

<span class="fc" id="L426">        private final Iterable&lt;GaugeProvider&lt;?&gt;&gt; gaugeProviders = BloomFilterMetrics.instance.getGaugeProviders();</span>

        @Override
        public Iterable&lt;GaugeProvider&lt;?&gt;&gt; getGaugeProviders()
        {
<span class="fc" id="L431">            return gaugeProviders;</span>
        }
    }

    @SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L436">    public static class BtiFormatFactory implements Factory</span>
    {
        @Override
        public String name()
        {
<span class="fc" id="L441">            return NAME;</span>
        }

        @Override
        public SSTableFormat&lt;?, ?&gt; getInstance(Map&lt;String, String&gt; options)
        {
<span class="fc" id="L447">            return new BtiFormat(options);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>