<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NativeSSTableLoaderClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.utils</a> &gt; <span class="el_source">NativeSSTableLoaderClient.java</span></div><h1>NativeSSTableLoaderClient.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.utils;

import java.nio.ByteBuffer;
import java.net.InetSocketAddress;
import java.util.*;

import com.datastax.driver.core.*;

import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.schema.*;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.ColumnMetadata.ClusteringOrder;
import org.apache.cassandra.cql3.ColumnIdentifier;
import org.apache.cassandra.db.marshal.*;
import org.apache.cassandra.dht.*;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.dht.Token.TokenFactory;
import org.apache.cassandra.io.sstable.SSTableLoader;
import org.apache.cassandra.schema.TableMetadata;

public class NativeSSTableLoaderClient extends SSTableLoader.Client
{
    protected final Map&lt;String, TableMetadataRef&gt; tables;
    private final Collection&lt;InetSocketAddress&gt; hosts;
    private final int storagePort;
    private final AuthProvider authProvider;
    private final SSLOptions sslOptions;

    public NativeSSTableLoaderClient(Collection&lt;InetSocketAddress&gt; hosts, int storagePort, String username, String password, SSLOptions sslOptions)
    {
<span class="nc" id="L48">        this(hosts, storagePort, new PlainTextAuthProvider(username, password), sslOptions);</span>
<span class="nc" id="L49">    }</span>

    public NativeSSTableLoaderClient(Collection&lt;InetSocketAddress&gt; hosts, int storagePort, AuthProvider authProvider, SSLOptions sslOptions)
    {
<span class="fc" id="L53">        super();</span>
<span class="fc" id="L54">        this.tables = new HashMap&lt;&gt;();</span>
<span class="fc" id="L55">        this.hosts = hosts;</span>
<span class="fc" id="L56">        this.authProvider = authProvider;</span>
<span class="fc" id="L57">        this.sslOptions = sslOptions;</span>
<span class="fc" id="L58">        this.storagePort = storagePort;</span>
<span class="fc" id="L59">    }</span>

    public void init(String keyspace)
    {
<span class="fc" id="L63">        Cluster.Builder builder = Cluster.builder().addContactPointsWithPorts(hosts).allowBetaProtocolVersion();</span>

<span class="pc bpc" id="L65" title="1 of 2 branches missed.">        if (sslOptions != null)</span>
<span class="nc" id="L66">            builder.withSSL(sslOptions);</span>
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">        if (authProvider != null)</span>
<span class="nc" id="L68">            builder = builder.withAuthProvider(authProvider);</span>

<span class="pc" id="L70">        try (Cluster cluster = builder.build(); Session session = cluster.connect())</span>
        {

<span class="nc" id="L73">            Metadata metadata = cluster.getMetadata();</span>

<span class="nc" id="L75">            Set&lt;TokenRange&gt; tokenRanges = metadata.getTokenRanges();</span>

<span class="nc" id="L77">            IPartitioner partitioner = FBUtilities.newPartitioner(metadata.getPartitioner());</span>
<span class="nc" id="L78">            TokenFactory tokenFactory = partitioner.getTokenFactory();</span>

<span class="nc bnc" id="L80" title="All 2 branches missed.">            for (TokenRange tokenRange : tokenRanges)</span>
            {
<span class="nc" id="L82">                Set&lt;Host&gt; endpoints = metadata.getReplicas(Metadata.quote(keyspace), tokenRange);</span>
<span class="nc" id="L83">                Range&lt;Token&gt; range = new Range&lt;&gt;(tokenFactory.fromString(tokenRange.getStart().getValue().toString()),</span>
<span class="nc" id="L84">                                                 tokenFactory.fromString(tokenRange.getEnd().getValue().toString()));</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">                for (Host endpoint : endpoints)</span>
                {
<span class="nc" id="L87">                    int broadcastPort = endpoint.getBroadcastSocketAddress().getPort();</span>
                    // use port from broadcast address if set.
<span class="nc bnc" id="L89" title="All 2 branches missed.">                    int portToUse = broadcastPort != 0 ? broadcastPort : storagePort;</span>
<span class="nc" id="L90">                    addRangeForEndpoint(range, InetAddressAndPort.getByNameOverrideDefaults(endpoint.getAddress().getHostAddress(), portToUse));</span>
<span class="nc" id="L91">                }</span>
<span class="nc" id="L92">            }</span>

<span class="nc" id="L94">            Types types = fetchTypes(keyspace, session);</span>

<span class="nc" id="L96">            tables.putAll(fetchTables(keyspace, session, partitioner, types));</span>
            // We only need the TableMetadata for the views, so we only load that.
<span class="nc" id="L98">            tables.putAll(fetchViews(keyspace, session, partitioner, types));</span>
        }
<span class="fc" id="L100">        catch (Exception e)</span>
        {
<span class="fc" id="L102">            throw new RuntimeException(&quot;Unable to initialise &quot; + NativeSSTableLoaderClient.class.getName(), e);</span>
<span class="nc" id="L103">        }</span>
<span class="nc" id="L104">    }</span>

    public TableMetadataRef getTableMetadata(String tableName)
    {
<span class="nc" id="L108">        return tables.get(tableName);</span>
    }

    @Override
    public void setTableMetadata(TableMetadataRef cfm)
    {
<span class="nc" id="L114">        tables.put(cfm.name, cfm);</span>
<span class="nc" id="L115">    }</span>

    private static Types fetchTypes(String keyspace, Session session)
    {
<span class="nc" id="L119">        String query = String.format(&quot;SELECT * FROM %s.%s WHERE keyspace_name = ?&quot;, SchemaConstants.SCHEMA_KEYSPACE_NAME, SchemaKeyspaceTables.TYPES);</span>

<span class="nc" id="L121">        Types.RawBuilder types = Types.rawBuilder(keyspace);</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">        for (Row row : session.execute(query, keyspace))</span>
        {
<span class="nc" id="L124">            String name = row.getString(&quot;type_name&quot;);</span>
<span class="nc" id="L125">            List&lt;String&gt; fieldNames = row.getList(&quot;field_names&quot;, String.class);</span>
<span class="nc" id="L126">            List&lt;String&gt; fieldTypes = row.getList(&quot;field_types&quot;, String.class);</span>
<span class="nc" id="L127">            types.add(name, fieldNames, fieldTypes);</span>
<span class="nc" id="L128">        }</span>
<span class="nc" id="L129">        return types.build();</span>
    }

    /*
     * The following is a slightly simplified but otherwise duplicated version of
     * SchemaKeyspace.createTableFromTableRowAndColumnRows().
     * It might be safer to have a simple wrapper of the driver ResultSet/Row implementing
     * UntypedResultSet/UntypedResultSet.Row and reuse the original method.
     *
     * Note: It is not safe for this class to use static methods from SchemaKeyspace (static final fields are ok)
     * as that triggers initialization of the class, which fails in client mode.
     */
    private static Map&lt;String, TableMetadataRef&gt; fetchTables(String keyspace, Session session, IPartitioner partitioner, Types types)
    {
<span class="nc" id="L143">        Map&lt;String, TableMetadataRef&gt; tables = new HashMap&lt;&gt;();</span>
<span class="nc" id="L144">        String query = String.format(&quot;SELECT * FROM %s.%s WHERE keyspace_name = ?&quot;, SchemaConstants.SCHEMA_KEYSPACE_NAME, SchemaKeyspaceTables.TABLES);</span>

<span class="nc bnc" id="L146" title="All 2 branches missed.">        for (Row row : session.execute(query, keyspace))</span>
        {
<span class="nc" id="L148">            String name = row.getString(&quot;table_name&quot;);</span>
<span class="nc" id="L149">            tables.put(name, createTableMetadata(keyspace, session, partitioner, false, row, name, types));</span>
<span class="nc" id="L150">        }</span>

<span class="nc" id="L152">        return tables;</span>
    }

    private static Map&lt;String, TableMetadataRef&gt; fetchViews(String keyspace, Session session, IPartitioner partitioner, Types types)
    {
<span class="nc" id="L157">        Map&lt;String, TableMetadataRef&gt; tables = new HashMap&lt;&gt;();</span>
<span class="nc" id="L158">        String query = String.format(&quot;SELECT * FROM %s.%s WHERE keyspace_name = ?&quot;, SchemaConstants.SCHEMA_KEYSPACE_NAME, SchemaKeyspaceTables.VIEWS);</span>

<span class="nc bnc" id="L160" title="All 2 branches missed.">        for (Row row : session.execute(query, keyspace))</span>
        {
<span class="nc" id="L162">            String name = row.getString(&quot;view_name&quot;);</span>
<span class="nc" id="L163">            tables.put(name, createTableMetadata(keyspace, session, partitioner, true, row, name, types));</span>
<span class="nc" id="L164">        }</span>

<span class="nc" id="L166">        return tables;</span>
    }

    private static TableMetadataRef createTableMetadata(String keyspace,
                                                        Session session,
                                                        IPartitioner partitioner,
                                                        boolean isView,
                                                        Row row,
                                                        String name,
                                                        Types types)
    {
<span class="nc" id="L177">        TableMetadata.Builder builder = TableMetadata.builder(keyspace, name, TableId.fromUUID(row.getUUID(&quot;id&quot;)))</span>
<span class="nc" id="L178">                                                     .partitioner(partitioner);</span>

<span class="nc bnc" id="L180" title="All 2 branches missed.">        if (!isView)</span>
<span class="nc" id="L181">            builder.flags(TableMetadata.Flag.fromStringSet(row.getSet(&quot;flags&quot;, String.class)));</span>

<span class="nc" id="L183">        String columnsQuery = String.format(&quot;SELECT * FROM %s.%s WHERE keyspace_name = ? AND table_name = ?&quot;,</span>
                                            SchemaConstants.SCHEMA_KEYSPACE_NAME,
                                            SchemaKeyspaceTables.COLUMNS);

<span class="nc bnc" id="L187" title="All 2 branches missed.">        for (Row colRow : session.execute(columnsQuery, keyspace, name))</span>
<span class="nc" id="L188">            builder.addColumn(createDefinitionFromRow(colRow, keyspace, name, types));</span>

<span class="nc" id="L190">        String droppedColumnsQuery = String.format(&quot;SELECT * FROM %s.%s WHERE keyspace_name = ? AND table_name = ?&quot;,</span>
                                                   SchemaConstants.SCHEMA_KEYSPACE_NAME,
                                                   SchemaKeyspaceTables.DROPPED_COLUMNS);
<span class="nc" id="L193">        Map&lt;ByteBuffer, DroppedColumn&gt; droppedColumns = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">        for (Row colRow : session.execute(droppedColumnsQuery, keyspace, name))</span>
        {
<span class="nc" id="L196">            DroppedColumn droppedColumn = createDroppedColumnFromRow(colRow, keyspace, name);</span>
<span class="nc" id="L197">            droppedColumns.put(droppedColumn.column.name.bytes, droppedColumn);</span>
<span class="nc" id="L198">        }</span>
<span class="nc" id="L199">        builder.droppedColumns(droppedColumns);</span>

<span class="nc" id="L201">        return TableMetadataRef.forOfflineTools(builder.build());</span>
    }

    private static ColumnMetadata createDefinitionFromRow(Row row, String keyspace, String table, Types types)
    {
<span class="nc" id="L206">        ClusteringOrder order = ClusteringOrder.valueOf(row.getString(&quot;clustering_order&quot;).toUpperCase());</span>
<span class="nc" id="L207">        AbstractType&lt;?&gt; type = CQLTypeParser.parse(keyspace, row.getString(&quot;type&quot;), types);</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (order == ClusteringOrder.DESC)</span>
<span class="nc" id="L209">            type = ReversedType.getInstance(type);</span>

<span class="nc" id="L211">        ColumnIdentifier name = new ColumnIdentifier(row.getBytes(&quot;column_name_bytes&quot;), row.getString(&quot;column_name&quot;));</span>

<span class="nc" id="L213">        int position = row.getInt(&quot;position&quot;);</span>
<span class="nc" id="L214">        org.apache.cassandra.schema.ColumnMetadata.Kind kind = ColumnMetadata.Kind.valueOf(row.getString(&quot;kind&quot;).toUpperCase());</span>
<span class="nc" id="L215">        return new ColumnMetadata(keyspace, table, name, type, position, kind, null);</span>
    }

    private static DroppedColumn createDroppedColumnFromRow(Row row, String keyspace, String table)
    {
<span class="nc" id="L220">        String name = row.getString(&quot;column_name&quot;);</span>
<span class="nc" id="L221">        AbstractType&lt;?&gt; type = CQLTypeParser.parse(keyspace, row.getString(&quot;type&quot;), Types.none());</span>
<span class="nc" id="L222">        ColumnMetadata.Kind kind = ColumnMetadata.Kind.valueOf(row.getString(&quot;kind&quot;).toUpperCase());</span>
<span class="nc" id="L223">        ColumnMetadata column = new ColumnMetadata(keyspace, table, ColumnIdentifier.getInterned(name, true), type, ColumnMetadata.NO_POSITION, kind, null);</span>
<span class="nc" id="L224">        long droppedTime = row.getTimestamp(&quot;dropped_time&quot;).getTime();</span>
<span class="nc" id="L225">        return new DroppedColumn(column, droppedTime);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>