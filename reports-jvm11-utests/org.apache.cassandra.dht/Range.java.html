<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Range.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.dht</a> &gt; <span class="el_source">Range.java</span></div><h1>Range.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.dht;

import java.io.Serializable;
import java.util.*;
import java.util.function.Predicate;

import com.google.common.collect.Iterables;
import org.apache.commons.lang3.ObjectUtils;

import org.apache.cassandra.db.PartitionPosition;
import org.apache.cassandra.utils.Pair;

/**
 * A representation of the range that a node is responsible for on the DHT ring.
 *
 * A Range is responsible for the tokens between (left, right].
 *
 * Used by the partitioner and by map/reduce by-token range scans.
 *
 * Note: this class has a natural ordering that is inconsistent with equals
 */
<span class="fc" id="L39">public class Range&lt;T extends RingPosition&lt;T&gt;&gt; extends AbstractBounds&lt;T&gt; implements Comparable&lt;Range&lt;T&gt;&gt;, Serializable</span>
{
    public static final long serialVersionUID = 1L;

    public Range(T left, T right)
    {
<span class="fc" id="L45">        super(left, right);</span>
<span class="fc" id="L46">    }</span>

    public static &lt;T extends RingPosition&lt;T&gt;&gt; boolean contains(T left, T right, T point)
    {
<span class="fc bfc" id="L50" title="All 2 branches covered.">        if (isWrapAround(left, right))</span>
        {
            /*
             * We are wrapping around, so the interval is (a,b] where a &gt;= b,
             * then we have 3 cases which hold for any given token k:
             * (1) a &lt; k -- return true
             * (2) k &lt;= b -- return true
             * (3) b &lt; k &lt;= a -- return false
             */
<span class="fc bfc" id="L59" title="All 2 branches covered.">            if (point.compareTo(left) &gt; 0)</span>
<span class="fc" id="L60">                return true;</span>
            else
<span class="fc bfc" id="L62" title="All 2 branches covered.">                return right.compareTo(point) &gt;= 0;</span>
        }
        else
        {
            /*
             * This is the range (a, b] where a &lt; b.
             */
<span class="fc bfc" id="L69" title="All 4 branches covered.">            return point.compareTo(left) &gt; 0 &amp;&amp; right.compareTo(point) &gt;= 0;</span>
        }
    }

    public boolean contains(Range&lt;T&gt; that)
    {
<span class="fc bfc" id="L75" title="All 2 branches covered.">        if (this.left.equals(this.right))</span>
        {
            // full ring always contains all other ranges
<span class="fc" id="L78">            return true;</span>
        }

<span class="fc" id="L81">        boolean thiswraps = isWrapAround(left, right);</span>
<span class="fc" id="L82">        boolean thatwraps = isWrapAround(that.left, that.right);</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">        if (thiswraps == thatwraps)</span>
        {
<span class="fc bfc" id="L85" title="All 4 branches covered.">            return left.compareTo(that.left) &lt;= 0 &amp;&amp; that.right.compareTo(right) &lt;= 0;</span>
        }
<span class="fc bfc" id="L87" title="All 2 branches covered.">        else if (thiswraps)</span>
        {
            // wrapping might contain non-wrapping
            // that is contained if both its tokens are in one of our wrap segments
<span class="fc bfc" id="L91" title="All 4 branches covered.">            return left.compareTo(that.left) &lt;= 0 || that.right.compareTo(right) &lt;= 0;</span>
        }
        else
        {
            // (thatwraps)
            // non-wrapping cannot contain wrapping
<span class="fc" id="L97">            return false;</span>
        }
    }

    /**
     * Helps determine if a given point on the DHT ring is contained
     * in the range in question.
     * @param point point in question
     * @return true if the point contains within the range else false.
     */
    public boolean contains(T point)
    {
<span class="fc" id="L109">        return contains(left, right, point);</span>
    }

    /**
     * @param that range to check for intersection
     * @return true if the given range intersects with this range.
     */
    public boolean intersects(Range&lt;T&gt; that)
    {
<span class="fc bfc" id="L118" title="All 2 branches covered.">        return intersectionWith(that).size() &gt; 0;</span>
    }

    public boolean intersects(AbstractBounds&lt;T&gt; that)
    {
        // implemented for cleanup compaction membership test, so only Range + Bounds are supported for now
<span class="fc bfc" id="L124" title="All 2 branches covered.">        if (that instanceof Range)</span>
<span class="fc" id="L125">            return intersects((Range&lt;T&gt;) that);</span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">        if (that instanceof Bounds)</span>
<span class="fc" id="L127">            return intersects((Bounds&lt;T&gt;) that);</span>
<span class="nc" id="L128">        throw new UnsupportedOperationException(&quot;Intersection is only supported for Bounds and Range objects; found &quot; + that.getClass());</span>
    }

    /**
     * @param that range to check for intersection
     * @return true if the given range intersects with this range.
     */
    public boolean intersects(Bounds&lt;T&gt; that)
    {
        // Same punishment than in Bounds.contains(), we must be carefull if that.left == that.right as
        // as new Range&lt;T&gt;(that.left, that.right) will then cover the full ring which is not what we
        // want.
<span class="fc bfc" id="L140" title="All 6 branches covered.">        return contains(that.left) || (!that.left.equals(that.right) &amp;&amp; intersects(new Range&lt;T&gt;(that.left, that.right)));</span>
    }

    public static boolean intersects(Iterable&lt;Range&lt;Token&gt;&gt; l, Iterable&lt;Range&lt;Token&gt;&gt; r)
    {
<span class="fc" id="L145">        return Iterables.any(l, rng -&gt; rng.intersects(r));</span>
    }

    @SafeVarargs
    public static &lt;T extends RingPosition&lt;T&gt;&gt; Set&lt;Range&lt;T&gt;&gt; rangeSet(Range&lt;T&gt; ... ranges)
    {
<span class="fc" id="L151">        return Collections.unmodifiableSet(new HashSet&lt;Range&lt;T&gt;&gt;(Arrays.asList(ranges)));</span>
    }

    public static &lt;T extends RingPosition&lt;T&gt;&gt; Set&lt;Range&lt;T&gt;&gt; rangeSet(Range&lt;T&gt; range)
    {
<span class="fc" id="L156">        return Collections.singleton(range);</span>
    }

    /**
     * @param that
     * @return the intersection of the two Ranges.  this can be two disjoint Ranges if one is wrapping and one is not.
     * say you have nodes G and M, with query range (D,T]; the intersection is (M-T] and (D-G].
     * If there is no intersection, an empty list is returned.
     */
    public Set&lt;Range&lt;T&gt;&gt; intersectionWith(Range&lt;T&gt; that)
    {
<span class="fc bfc" id="L167" title="All 2 branches covered.">        if (that.contains(this))</span>
<span class="fc" id="L168">            return rangeSet(this);</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (this.contains(that))</span>
<span class="fc" id="L170">            return rangeSet(that);</span>

<span class="fc" id="L172">        boolean thiswraps = isWrapAround(left, right);</span>
<span class="fc" id="L173">        boolean thatwraps = isWrapAround(that.left, that.right);</span>
<span class="fc bfc" id="L174" title="All 4 branches covered.">        if (!thiswraps &amp;&amp; !thatwraps)</span>
        {
            // neither wraps:  the straightforward case.
<span class="fc bfc" id="L177" title="All 4 branches covered.">            if (!(left.compareTo(that.right) &lt; 0 &amp;&amp; that.left.compareTo(right) &lt; 0))</span>
<span class="fc" id="L178">                return Collections.emptySet();</span>
<span class="fc" id="L179">            return rangeSet(new Range&lt;T&gt;(ObjectUtils.max(this.left, that.left),</span>
<span class="fc" id="L180">                                         ObjectUtils.min(this.right, that.right)));</span>
        }
<span class="fc bfc" id="L182" title="All 4 branches covered.">        if (thiswraps &amp;&amp; thatwraps)</span>
        {
            //both wrap: if the starts are the same, one contains the other, which we have already ruled out.
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">            assert !this.left.equals(that.left);</span>
            // two wrapping ranges always intersect.
            // since we have already determined that neither this nor that contains the other, we have 2 cases,
            // and mirror images of those case.
            // (1) both of that's (1, 2] endpoints lie in this's (A, B] right segment:
            //  ---------B--------A--1----2------&gt;
            // (2) only that's start endpoint lies in this's right segment:
            //  ---------B----1---A-------2------&gt;
            // or, we have the same cases on the left segement, which we can handle by swapping this and that.
<span class="fc bfc" id="L194" title="All 2 branches covered.">            return this.left.compareTo(that.left) &lt; 0</span>
<span class="fc" id="L195">                   ? intersectionBothWrapping(this, that)</span>
<span class="fc" id="L196">                   : intersectionBothWrapping(that, this);</span>
        }
<span class="fc bfc" id="L198" title="All 2 branches covered.">        if (thiswraps) // this wraps, that does not wrap</span>
<span class="fc" id="L199">            return intersectionOneWrapping(this, that);</span>
        // the last case: this does not wrap, that wraps
<span class="fc" id="L201">        return intersectionOneWrapping(that, this);</span>
    }

    private static &lt;T extends RingPosition&lt;T&gt;&gt; Set&lt;Range&lt;T&gt;&gt; intersectionBothWrapping(Range&lt;T&gt; first, Range&lt;T&gt; that)
    {
<span class="fc" id="L206">        Set&lt;Range&lt;T&gt;&gt; intersection = new HashSet&lt;Range&lt;T&gt;&gt;(2);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if (that.right.compareTo(first.left) &gt; 0)</span>
<span class="fc" id="L208">            intersection.add(new Range&lt;T&gt;(first.left, that.right));</span>
<span class="fc" id="L209">        intersection.add(new Range&lt;T&gt;(that.left, first.right));</span>
<span class="fc" id="L210">        return Collections.unmodifiableSet(intersection);</span>
    }

    private static &lt;T extends RingPosition&lt;T&gt;&gt; Set&lt;Range&lt;T&gt;&gt; intersectionOneWrapping(Range&lt;T&gt; wrapping, Range&lt;T&gt; other)
    {
<span class="fc" id="L215">        Set&lt;Range&lt;T&gt;&gt; intersection = new HashSet&lt;Range&lt;T&gt;&gt;(2);</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">        if (other.contains(wrapping.right))</span>
<span class="fc" id="L217">            intersection.add(new Range&lt;T&gt;(other.left, wrapping.right));</span>
        // need the extra compareto here because ranges are asymmetrical; wrapping.left _is not_ contained by the wrapping range
<span class="fc bfc" id="L219" title="All 4 branches covered.">        if (other.contains(wrapping.left) &amp;&amp; wrapping.left.compareTo(other.right) &lt; 0)</span>
<span class="fc" id="L220">            intersection.add(new Range&lt;T&gt;(wrapping.left, other.right));</span>
<span class="fc" id="L221">        return Collections.unmodifiableSet(intersection);</span>
    }

    /**
     * Returns the intersection of this range with the provided one, assuming neither are wrapping.
     *
     * @param that the other range to return the intersection with. It must not be wrapping.
     * @return the intersection of {@code this} and {@code that}, or {@code null} if both ranges don't intersect.
     */
    public Range&lt;T&gt; intersectionNonWrapping(Range&lt;T&gt; that)
    {
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">        assert !isTrulyWrapAround() : &quot;wraparound &quot; + this;</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">        assert !that.isTrulyWrapAround() : &quot;wraparound &quot; + that;</span>

<span class="fc bfc" id="L235" title="All 2 branches covered.">        if (left.compareTo(that.left) &lt; 0)</span>
        {
<span class="fc bfc" id="L237" title="All 6 branches covered.">            if (right.isMinimum() || (!that.right.isMinimum() &amp;&amp; right.compareTo(that.right) &gt;= 0))</span>
<span class="fc" id="L238">                return that;  // this contains that.</span>

<span class="fc bfc" id="L240" title="All 2 branches covered.">            if (right.compareTo(that.left) &lt;= 0)</span>
<span class="fc" id="L241">                return null;  // this is fully before that.</span>

<span class="fc" id="L243">            return new Range&lt;&gt;(that.left, right);</span>
        }
        else
        {
<span class="fc bfc" id="L247" title="All 6 branches covered.">            if (that.right.isMinimum() || (!right.isMinimum() &amp;&amp; that.right.compareTo(right) &gt;= 0))</span>
<span class="fc" id="L248">                return this;  // that contains this.</span>

<span class="fc bfc" id="L250" title="All 2 branches covered.">            if (that.right.compareTo(left) &lt;= 0)</span>
<span class="fc" id="L251">                return null;  // that is fully before this.</span>

<span class="fc" id="L253">            return new Range&lt;&gt;(left, that.right);</span>
        }
    }

    public Pair&lt;AbstractBounds&lt;T&gt;, AbstractBounds&lt;T&gt;&gt; split(T position)
    {
<span class="pc bpc" id="L259" title="1 of 4 branches missed.">        assert contains(position) || left.equals(position);</span>
        // Check if the split would have no effect on the range
<span class="fc bfc" id="L261" title="All 4 branches covered.">        if (position.equals(left) || position.equals(right))</span>
<span class="fc" id="L262">            return null;</span>

<span class="fc" id="L264">        AbstractBounds&lt;T&gt; lb = new Range&lt;T&gt;(left, position);</span>
<span class="fc" id="L265">        AbstractBounds&lt;T&gt; rb = new Range&lt;T&gt;(position, right);</span>
<span class="fc" id="L266">        return Pair.create(lb, rb);</span>
    }

    public boolean inclusiveLeft()
    {
<span class="fc" id="L271">        return false;</span>
    }

    public boolean inclusiveRight()
    {
<span class="fc" id="L276">        return true;</span>
    }

    public List&lt;Range&lt;T&gt;&gt; unwrap()
    {
<span class="fc" id="L281">        T minValue = right.minValue();</span>
<span class="fc bfc" id="L282" title="All 4 branches covered.">        if (!isWrapAround() || right.equals(minValue))</span>
<span class="fc" id="L283">            return Arrays.asList(this);</span>
<span class="fc" id="L284">        List&lt;Range&lt;T&gt;&gt; unwrapped = new ArrayList&lt;Range&lt;T&gt;&gt;(2);</span>
<span class="fc" id="L285">        unwrapped.add(new Range&lt;T&gt;(left, minValue));</span>
<span class="fc" id="L286">        unwrapped.add(new Range&lt;T&gt;(minValue, right));</span>
<span class="fc" id="L287">        return unwrapped;</span>
    }

    /**
     * Tells if the given range is a wrap around.
     */
    public static &lt;T extends RingPosition&lt;T&gt;&gt; boolean isWrapAround(T left, T right)
    {
<span class="fc bfc" id="L295" title="All 2 branches covered.">       return left.compareTo(right) &gt;= 0;</span>
    }

    /**
     * Checks if the range truly wraps around.
     *
     * This exists only because {@link #isWrapAround()} is a tad dumb and return true if right is the minimum token,
     * no matter what left is, but for most intent and purposes, such range doesn't truly warp around (unwrap produces
     * the identity in this case).
     * &lt;p&gt;
     * Also note that it could be that the remaining uses of {@link #isWrapAround()} could be replaced by this method,
     * but that is to be checked carefully at some other time (Sylvain).
     * &lt;p&gt;
     * The one thing this method guarantees is that if it's true, then {@link #unwrap()} will return a list with
     * exactly 2 ranges, never one.
     */
    public boolean isTrulyWrapAround()
    {
<span class="fc" id="L313">        return isTrulyWrapAround(left, right);</span>
    }

    public static &lt;T extends RingPosition&lt;T&gt;&gt; boolean isTrulyWrapAround(T left, T right)
    {
<span class="pc bpc" id="L318" title="1 of 4 branches missed.">        return isWrapAround(left, right) &amp;&amp; !right.isMinimum();</span>
    }

    /**
     * Tells if the given range covers the entire ring
     */
    private static &lt;T extends RingPosition&lt;T&gt;&gt; boolean isFull(T left, T right)
    {
<span class="fc" id="L326">        return left.equals(right);</span>
    }

    /**
     * Note: this class has a natural ordering that is inconsistent with equals
     */
    public int compareTo(Range&lt;T&gt; rhs)
    {
<span class="fc" id="L334">        boolean lhsWrap = isWrapAround(left, right);</span>
<span class="fc" id="L335">        boolean rhsWrap = isWrapAround(rhs.left, rhs.right);</span>

        // if one of the two wraps, that's the smaller one.
<span class="fc bfc" id="L338" title="All 2 branches covered.">        if (lhsWrap != rhsWrap)</span>
<span class="fc bfc" id="L339" title="All 4 branches covered.">            return Boolean.compare(!lhsWrap, !rhsWrap);</span>
        // otherwise compare by right.
<span class="fc" id="L341">        return right.compareTo(rhs.right);</span>
    }

    /**
     * Subtracts a portion of this range.
     * @param contained The range to subtract from this. It must be totally
     * contained by this range.
     * @return A List of the Ranges left after subtracting contained
     * from this.
     */
    private List&lt;Range&lt;T&gt;&gt; subtractContained(Range&lt;T&gt; contained)
    {
        // both ranges cover the entire ring, their difference is an empty set
<span class="fc bfc" id="L354" title="All 4 branches covered.">        if(isFull(left, right) &amp;&amp; isFull(contained.left, contained.right))</span>
        {
<span class="fc" id="L356">            return Collections.emptyList();</span>
        }

        // a range is subtracted from another range that covers the entire ring
<span class="fc bfc" id="L360" title="All 2 branches covered.">        if(isFull(left, right))</span>
        {
<span class="fc" id="L362">            return Collections.singletonList(new Range&lt;&gt;(contained.right, contained.left));</span>
        }

<span class="fc" id="L365">        List&lt;Range&lt;T&gt;&gt; difference = new ArrayList&lt;&gt;(2);</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">        if (!left.equals(contained.left))</span>
<span class="fc" id="L367">            difference.add(new Range&lt;T&gt;(left, contained.left));</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">        if (!right.equals(contained.right))</span>
<span class="fc" id="L369">            difference.add(new Range&lt;T&gt;(contained.right, right));</span>
<span class="fc" id="L370">        return difference;</span>
    }

    public Set&lt;Range&lt;T&gt;&gt; subtract(Range&lt;T&gt; rhs)
    {
<span class="fc" id="L375">        return rhs.differenceToFetch(this);</span>
    }

    public Set&lt;Range&lt;T&gt;&gt; subtractAll(Collection&lt;Range&lt;T&gt;&gt; ranges)
    {
<span class="fc" id="L380">        Set&lt;Range&lt;T&gt;&gt; result = new HashSet&lt;&gt;();</span>
<span class="fc" id="L381">        result.add(this);</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">        for(Range&lt;T&gt; range : ranges)</span>
        {
<span class="fc" id="L384">            result = substractAllFromToken(result, range);</span>
<span class="fc" id="L385">        }</span>

<span class="fc" id="L387">        return result;</span>
    }

    private static &lt;T extends RingPosition&lt;T&gt;&gt; Set&lt;Range&lt;T&gt;&gt; substractAllFromToken(Set&lt;Range&lt;T&gt;&gt; ranges, Range&lt;T&gt; subtract)
    {
<span class="fc" id="L392">        Set&lt;Range&lt;T&gt;&gt; result = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">        for(Range&lt;T&gt; range : ranges)</span>
        {
<span class="fc" id="L395">            result.addAll(range.subtract(subtract));</span>
<span class="fc" id="L396">        }</span>

<span class="fc" id="L398">        return result;</span>
    }

    public static &lt;T extends RingPosition&lt;T&gt;&gt; Set&lt;Range&lt;T&gt;&gt; subtract(Collection&lt;Range&lt;T&gt;&gt; ranges, Collection&lt;Range&lt;T&gt;&gt; subtract)
    {
<span class="fc" id="L403">        Set&lt;Range&lt;T&gt;&gt; result = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">        for (Range&lt;T&gt; range : ranges)</span>
        {
<span class="fc" id="L406">            result.addAll(range.subtractAll(subtract));</span>
<span class="fc" id="L407">        }</span>
<span class="fc" id="L408">        return result;</span>
    }

    /**
     * Calculate set of the difference ranges of given two ranges
     * (as current (A, B] and rhs is (C, D])
     * which node will need to fetch when moving to a given new token
     *
     * @param rhs range to calculate difference
     * @return set of difference ranges
     */
    public Set&lt;Range&lt;T&gt;&gt; differenceToFetch(Range&lt;T&gt; rhs)
    {
        Set&lt;Range&lt;T&gt;&gt; result;
<span class="fc" id="L422">        Set&lt;Range&lt;T&gt;&gt; intersectionSet = this.intersectionWith(rhs);</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">        if (intersectionSet.isEmpty())</span>
        {
<span class="fc" id="L425">            result = new HashSet&lt;Range&lt;T&gt;&gt;();</span>
<span class="fc" id="L426">            result.add(rhs);</span>
        }
        else
        {
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L431">            Range&lt;T&gt;[] intersections = new Range[intersectionSet.size()];</span>
<span class="fc" id="L432">            intersectionSet.toArray(intersections);</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">            if (intersections.length == 1)</span>
            {
<span class="fc" id="L435">                result = new HashSet&lt;Range&lt;T&gt;&gt;(rhs.subtractContained(intersections[0]));</span>
            }
            else
            {
                // intersections.length must be 2
<span class="fc" id="L440">                Range&lt;T&gt; first = intersections[0];</span>
<span class="fc" id="L441">                Range&lt;T&gt; second = intersections[1];</span>
<span class="fc" id="L442">                List&lt;Range&lt;T&gt;&gt; temp = rhs.subtractContained(first);</span>

                // Because there are two intersections, subtracting only one of them
                // will yield a single Range.
<span class="fc" id="L446">                Range&lt;T&gt; single = temp.get(0);</span>
<span class="fc" id="L447">                result = new HashSet&lt;Range&lt;T&gt;&gt;(single.subtractContained(second));</span>
            }
        }
<span class="fc" id="L450">        return result;</span>
    }

    public static &lt;T extends RingPosition&lt;T&gt;&gt; boolean isInRanges(T token, Iterable&lt;Range&lt;T&gt;&gt; ranges)
    {
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">        assert ranges != null;</span>

<span class="fc bfc" id="L457" title="All 2 branches covered.">        for (Range&lt;T&gt; range : ranges)</span>
        {
<span class="fc bfc" id="L459" title="All 2 branches covered.">            if (range.contains(token))</span>
            {
<span class="fc" id="L461">                return true;</span>
            }
<span class="fc" id="L463">        }</span>
<span class="fc" id="L464">        return false;</span>
    }

    @Override
    public boolean equals(Object o)
    {
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">        if (!(o instanceof Range))</span>
<span class="nc" id="L471">            return false;</span>
<span class="fc" id="L472">        Range&lt;?&gt; rhs = (Range&lt;?&gt;)o;</span>
<span class="fc bfc" id="L473" title="All 4 branches covered.">        return left.equals(rhs.left) &amp;&amp; right.equals(rhs.right);</span>
    }

    @Override
    public String toString()
    {
<span class="fc" id="L479">        return &quot;(&quot; + left + &quot;,&quot; + right + &quot;]&quot;;</span>
    }

    protected String getOpeningString()
    {
<span class="fc" id="L484">        return &quot;(&quot;;</span>
    }

    protected String getClosingString()
    {
<span class="fc" id="L489">        return &quot;]&quot;;</span>
    }

    public boolean isStartInclusive()
    {
<span class="fc" id="L494">        return false;</span>
    }

    public boolean isEndInclusive()
    {
<span class="fc" id="L499">        return true;</span>
    }

    public List&lt;String&gt; asList()
    {
<span class="nc" id="L504">        ArrayList&lt;String&gt; ret = new ArrayList&lt;String&gt;(2);</span>
<span class="nc" id="L505">        ret.add(left.toString());</span>
<span class="nc" id="L506">        ret.add(right.toString());</span>
<span class="nc" id="L507">        return ret;</span>
    }

    public boolean isWrapAround()
    {
<span class="fc" id="L512">        return isWrapAround(left, right);</span>
    }

    /**
     * @return A copy of the given list of with all ranges unwrapped, sorted by left bound and with overlapping bounds merged.
     */
    public static &lt;T extends RingPosition&lt;T&gt;&gt; List&lt;Range&lt;T&gt;&gt; normalize(Collection&lt;Range&lt;T&gt;&gt; ranges)
    {
        // unwrap all
<span class="fc" id="L521">        List&lt;Range&lt;T&gt;&gt; output = new ArrayList&lt;Range&lt;T&gt;&gt;(ranges.size());</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">        for (Range&lt;T&gt; range : ranges)</span>
<span class="fc" id="L523">            output.addAll(range.unwrap());</span>

        // sort by left
<span class="fc" id="L526">        Collections.sort(output, new Comparator&lt;Range&lt;T&gt;&gt;()</span>
<span class="fc" id="L527">        {</span>
            public int compare(Range&lt;T&gt; b1, Range&lt;T&gt; b2)
            {
<span class="fc" id="L530">                return b1.left.compareTo(b2.left);</span>
            }
        });

        // deoverlap
<span class="fc" id="L535">        return deoverlap(output);</span>
    }

    /**
     * Given a list of unwrapped ranges sorted by left position, return an
     * equivalent list of ranges but with no overlapping ranges.
     */
    public static &lt;T extends RingPosition&lt;T&gt;&gt; List&lt;Range&lt;T&gt;&gt; deoverlap(List&lt;Range&lt;T&gt;&gt; ranges)
    {
<span class="fc bfc" id="L544" title="All 2 branches covered.">        if (ranges.isEmpty())</span>
<span class="fc" id="L545">            return ranges;</span>

<span class="fc" id="L547">        List&lt;Range&lt;T&gt;&gt; output = new ArrayList&lt;Range&lt;T&gt;&gt;();</span>

<span class="fc" id="L549">        Iterator&lt;Range&lt;T&gt;&gt; iter = ranges.iterator();</span>
<span class="fc" id="L550">        Range&lt;T&gt; current = iter.next();</span>

<span class="fc" id="L552">        T min = current.left.minValue();</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">        while (iter.hasNext())</span>
        {
            // If current goes to the end of the ring, we're done
<span class="fc bfc" id="L556" title="All 2 branches covered.">            if (current.right.equals(min))</span>
            {
                // If one range is the full range, we return only that
<span class="fc bfc" id="L559" title="All 2 branches covered.">                if (current.left.equals(min))</span>
<span class="fc" id="L560">                    return Collections.&lt;Range&lt;T&gt;&gt;singletonList(current);</span>

<span class="fc" id="L562">                output.add(new Range&lt;T&gt;(current.left, min));</span>
<span class="fc" id="L563">                return output;</span>
            }

<span class="fc" id="L566">            Range&lt;T&gt; next = iter.next();</span>

            // if next left is equal to current right, we do not intersect per se, but replacing (A, B] and (B, C] by (A, C] is
            // legit, and since this avoid special casing and will result in more &quot;optimal&quot; ranges, we do the transformation
<span class="fc bfc" id="L570" title="All 2 branches covered.">            if (next.left.compareTo(current.right) &lt;= 0)</span>
            {
                // We do overlap
                // (we've handled current.right.equals(min) already)
<span class="fc bfc" id="L574" title="All 4 branches covered.">                if (next.right.equals(min) || current.right.compareTo(next.right) &lt; 0)</span>
<span class="fc" id="L575">                    current = new Range&lt;T&gt;(current.left, next.right);</span>
            }
            else
            {
<span class="fc" id="L579">                output.add(current);</span>
<span class="fc" id="L580">                current = next;</span>
            }
<span class="fc" id="L582">        }</span>
<span class="fc" id="L583">        output.add(current);</span>
<span class="fc" id="L584">        return output;</span>
    }

    public AbstractBounds&lt;T&gt; withNewRight(T newRight)
    {
<span class="fc" id="L589">        return new Range&lt;T&gt;(left, newRight);</span>
    }

    public static &lt;T extends RingPosition&lt;T&gt;&gt; List&lt;Range&lt;T&gt;&gt; sort(Collection&lt;Range&lt;T&gt;&gt; ranges)
    {
<span class="fc" id="L594">        List&lt;Range&lt;T&gt;&gt; output = new ArrayList&lt;&gt;(ranges.size());</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">        for (Range&lt;T&gt; r : ranges)</span>
<span class="fc" id="L596">            output.addAll(r.unwrap());</span>
        // sort by left
<span class="fc" id="L598">        Collections.sort(output, new Comparator&lt;Range&lt;T&gt;&gt;()</span>
<span class="fc" id="L599">        {</span>
            public int compare(Range&lt;T&gt; b1, Range&lt;T&gt; b2)
            {
<span class="fc" id="L602">                return b1.left.compareTo(b2.left);</span>
            }
        });
<span class="fc" id="L605">        return output;</span>
    }


    /**
     * Compute a range of keys corresponding to a given range of token.
     */
    public static Range&lt;PartitionPosition&gt; makeRowRange(Token left, Token right)
    {
<span class="fc" id="L614">        return new Range&lt;PartitionPosition&gt;(left.maxKeyBound(), right.maxKeyBound());</span>
    }

    public static Range&lt;PartitionPosition&gt; makeRowRange(Range&lt;Token&gt; tokenBounds)
    {
<span class="fc" id="L619">        return makeRowRange(tokenBounds.left, tokenBounds.right);</span>
    }

    /**
     * Helper class to check if a token is contained within a given collection of ranges
     */
<span class="fc" id="L625">    public static class OrderedRangeContainmentChecker implements Predicate&lt;Token&gt;</span>
    {
        private final Iterator&lt;Range&lt;Token&gt;&gt; normalizedRangesIterator;
<span class="fc" id="L628">        private Token lastToken = null;</span>
        private Range&lt;Token&gt; currentRange;

        public OrderedRangeContainmentChecker(Collection&lt;Range&lt;Token&gt;&gt; ranges)
<span class="fc" id="L632">        {</span>
<span class="fc" id="L633">            normalizedRangesIterator = normalize(ranges).iterator();</span>
<span class="pc bpc" id="L634" title="1 of 2 branches missed.">            assert normalizedRangesIterator.hasNext();</span>
<span class="fc" id="L635">            currentRange = normalizedRangesIterator.next();</span>
<span class="fc" id="L636">        }</span>

        /**
         * Returns true if the ranges given in the constructor contains the token, false otherwise.
         *
         * The tokens passed to this method must be in increasing order
         *
         * @param t token to check, must be larger than or equal to the last token passed
         * @return true if the token is contained within the ranges given to the constructor.
         */
        @Override
        public boolean test(Token t)
        {
<span class="pc bpc" id="L649" title="1 of 4 branches missed.">            assert lastToken == null || lastToken.compareTo(t) &lt;= 0;</span>
<span class="fc" id="L650">            lastToken = t;</span>
            while (true)
            {
<span class="fc bfc" id="L653" title="All 2 branches covered.">                if (t.compareTo(currentRange.left) &lt;= 0)</span>
<span class="fc" id="L654">                    return false;</span>
<span class="pc bpc" id="L655" title="1 of 4 branches missed.">                else if (t.compareTo(currentRange.right) &lt;= 0 || currentRange.right.compareTo(currentRange.left) &lt;= 0)</span>
<span class="fc" id="L656">                    return true;</span>

<span class="fc bfc" id="L658" title="All 2 branches covered.">                if (!normalizedRangesIterator.hasNext())</span>
<span class="fc" id="L659">                    return false;</span>
<span class="fc" id="L660">                currentRange = normalizedRangesIterator.next();</span>
            }
        }
    }

    public static &lt;T extends RingPosition&lt;T&gt;&gt; void assertNormalized(List&lt;Range&lt;T&gt;&gt; ranges)
    {
<span class="fc" id="L667">        Range&lt;T&gt; lastRange = null;</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">        for (Range&lt;T&gt; range : ranges)</span>
        {
<span class="fc bfc" id="L670" title="All 2 branches covered.">            if (lastRange == null)</span>
            {
<span class="fc" id="L672">                lastRange = range;</span>
            }
<span class="pc bpc" id="L674" title="2 of 4 branches missed.">            else if (lastRange.left.compareTo(range.left) &gt;= 0 || lastRange.intersects(range))</span>
            {
<span class="nc" id="L676">                throw new AssertionError(String.format(&quot;Ranges aren't properly normalized. lastRange %s, range %s, compareTo %d, intersects %b, all ranges %s%n&quot;,</span>
                                                       lastRange,
                                                       range,
<span class="nc" id="L679">                                                       lastRange.compareTo(range),</span>
<span class="nc" id="L680">                                                       lastRange.intersects(range),</span>
                                                       ranges));
            }
<span class="fc" id="L683">        }</span>
<span class="fc" id="L684">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>