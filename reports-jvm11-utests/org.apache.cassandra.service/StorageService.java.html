<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StorageService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.service</a> &gt; <span class="el_source">StorageService.java</span></div><h1>StorageService.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.service;

import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.IOError;
import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.time.Instant;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Scanner;
import java.util.Set;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Supplier;
import java.util.regex.MatchResult;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import javax.annotation.Nullable;
import javax.management.ListenerNotFoundException;
import javax.management.NotificationBroadcasterSupport;
import javax.management.NotificationFilter;
import javax.management.NotificationListener;
import javax.management.openmbean.CompositeData;
import javax.management.openmbean.OpenDataException;
import javax.management.openmbean.TabularData;
import javax.management.openmbean.TabularDataSupport;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Joiner;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;
import com.google.common.collect.Ordering;
import com.google.common.collect.Sets;
import com.google.common.util.concurrent.FutureCallback;
import com.google.common.util.concurrent.RateLimiter;
import com.google.common.util.concurrent.Uninterruptibles;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.audit.AuditLogManager;
import org.apache.cassandra.audit.AuditLogOptions;
import org.apache.cassandra.auth.AuthCacheService;
import org.apache.cassandra.auth.AuthKeyspace;
import org.apache.cassandra.auth.AuthSchemaChangeListener;
import org.apache.cassandra.batchlog.BatchlogManager;
import org.apache.cassandra.concurrent.ExecutorLocals;
import org.apache.cassandra.concurrent.FutureTask;
import org.apache.cassandra.concurrent.FutureTaskWithResources;
import org.apache.cassandra.concurrent.NamedThreadFactory;
import org.apache.cassandra.concurrent.ScheduledExecutors;
import org.apache.cassandra.concurrent.Stage;
import org.apache.cassandra.config.CassandraRelevantProperties;
import org.apache.cassandra.config.Config;
import org.apache.cassandra.config.Config.PaxosStatePurging;
import org.apache.cassandra.config.Converters;
import org.apache.cassandra.config.DataStorageSpec;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.config.DurationSpec;
import org.apache.cassandra.cql3.QueryHandler;
import org.apache.cassandra.cql3.QueryProcessor;
import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.Keyspace;
import org.apache.cassandra.db.SizeEstimatesRecorder;
import org.apache.cassandra.db.SnapshotDetailsTabularData;
import org.apache.cassandra.db.SystemKeyspace;
import org.apache.cassandra.db.commitlog.CommitLog;
import org.apache.cassandra.db.compaction.CompactionManager;
import org.apache.cassandra.db.compaction.OperationType;
import org.apache.cassandra.db.guardrails.Guardrails;
import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
import org.apache.cassandra.db.virtual.VirtualKeyspaceRegistry;
import org.apache.cassandra.dht.BootStrapper;
import org.apache.cassandra.dht.IPartitioner;
import org.apache.cassandra.dht.Range;
import org.apache.cassandra.dht.Token.TokenFactory;
import org.apache.cassandra.hints.HintsService;
import org.apache.cassandra.dht.RangeStreamer;
import org.apache.cassandra.dht.RangeStreamer.FetchReplica;
import org.apache.cassandra.dht.StreamStateStore;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.exceptions.UnavailableException;
import org.apache.cassandra.fql.FullQueryLogger;
import org.apache.cassandra.fql.FullQueryLoggerOptions;
import org.apache.cassandra.fql.FullQueryLoggerOptionsCompositeData;
import org.apache.cassandra.gms.ApplicationState;
import org.apache.cassandra.gms.EndpointState;
import org.apache.cassandra.gms.FailureDetector;
import org.apache.cassandra.gms.Gossiper;
import org.apache.cassandra.gms.IEndpointStateChangeSubscriber;
import org.apache.cassandra.gms.IFailureDetector;
import org.apache.cassandra.gms.TokenSerializer;
import org.apache.cassandra.gms.VersionedValue;
import org.apache.cassandra.index.IndexStatusManager;
import org.apache.cassandra.io.sstable.IScrubber;
import org.apache.cassandra.io.sstable.IVerifier;
import org.apache.cassandra.io.sstable.SSTableLoader;
import org.apache.cassandra.io.sstable.format.Version;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.io.util.PathUtils;
import org.apache.cassandra.locator.AbstractReplicationStrategy;
import org.apache.cassandra.locator.DynamicEndpointSnitch;
import org.apache.cassandra.locator.EndpointsByRange;
import org.apache.cassandra.locator.EndpointsByReplica;
import org.apache.cassandra.locator.EndpointsForRange;
import org.apache.cassandra.locator.EndpointsForToken;
import org.apache.cassandra.locator.IEndpointSnitch;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.locator.LocalStrategy;
import org.apache.cassandra.locator.NetworkTopologyStrategy;
import org.apache.cassandra.locator.RangesAtEndpoint;
import org.apache.cassandra.locator.RangesByEndpoint;
import org.apache.cassandra.locator.Replica;
import org.apache.cassandra.locator.ReplicaCollection.Builder.Conflict;
import org.apache.cassandra.locator.Replicas;
import org.apache.cassandra.locator.SystemReplicas;
import org.apache.cassandra.locator.TokenMetadata;
import org.apache.cassandra.metrics.Sampler;
import org.apache.cassandra.metrics.SamplingManager;
import org.apache.cassandra.metrics.StorageMetrics;
import org.apache.cassandra.net.AsyncOneResponse;
import org.apache.cassandra.net.Message;
import org.apache.cassandra.net.MessagingService;
import org.apache.cassandra.repair.RepairCoordinator;
import org.apache.cassandra.repair.messages.RepairOption;
import org.apache.cassandra.schema.CompactionParams.TombstoneOption;
import org.apache.cassandra.schema.KeyspaceMetadata;
import org.apache.cassandra.schema.Keyspaces;
import org.apache.cassandra.schema.ReplicationParams;
import org.apache.cassandra.schema.Schema;
import org.apache.cassandra.schema.SchemaConstants;
import org.apache.cassandra.schema.SchemaTransformations;
import org.apache.cassandra.schema.SystemDistributedKeyspace;
import org.apache.cassandra.schema.TableId;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.schema.TableMetadataRef;
import org.apache.cassandra.schema.ViewMetadata;
import org.apache.cassandra.service.disk.usage.DiskUsageBroadcaster;
import org.apache.cassandra.service.paxos.Paxos;
import org.apache.cassandra.service.paxos.PaxosCommit;
import org.apache.cassandra.service.paxos.PaxosRepair;
import org.apache.cassandra.service.paxos.PaxosState;
import org.apache.cassandra.service.paxos.cleanup.PaxosCleanupLocalCoordinator;
import org.apache.cassandra.service.paxos.cleanup.PaxosTableRepairs;
import org.apache.cassandra.service.snapshot.SnapshotManager;
import org.apache.cassandra.service.snapshot.TableSnapshot;
import org.apache.cassandra.streaming.StreamManager;
import org.apache.cassandra.streaming.StreamOperation;
import org.apache.cassandra.streaming.StreamPlan;
import org.apache.cassandra.streaming.StreamResultFuture;
import org.apache.cassandra.streaming.StreamState;
import org.apache.cassandra.tracing.TraceKeyspace;
import org.apache.cassandra.transport.ClientResourceLimits;
import org.apache.cassandra.transport.ProtocolVersion;
import org.apache.cassandra.utils.Clock;
import org.apache.cassandra.utils.ExecutorUtils;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.JVMStabilityInspector;
import org.apache.cassandra.utils.MBeanWrapper;
import org.apache.cassandra.utils.MD5Digest;
import org.apache.cassandra.utils.OutputHandler;
import org.apache.cassandra.utils.Pair;
import org.apache.cassandra.utils.Throwables;
import org.apache.cassandra.utils.WrappedRunnable;
import org.apache.cassandra.utils.concurrent.Future;
import org.apache.cassandra.utils.concurrent.FutureCombiner;
import org.apache.cassandra.utils.concurrent.ImmediateFuture;
import org.apache.cassandra.utils.concurrent.UncheckedInterruptedException;
import org.apache.cassandra.utils.logging.LoggingSupportFactory;
import org.apache.cassandra.utils.progress.ProgressEvent;
import org.apache.cassandra.utils.progress.ProgressEventType;
import org.apache.cassandra.utils.progress.ProgressListener;
import org.apache.cassandra.utils.progress.jmx.JMXBroadcastExecutor;
import org.apache.cassandra.utils.progress.jmx.JMXProgressSupport;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.collect.Iterables.transform;
import static com.google.common.collect.Iterables.tryFind;
import static java.util.Arrays.asList;
import static java.util.Arrays.stream;
import static java.util.concurrent.TimeUnit.MILLISECONDS;
import static java.util.concurrent.TimeUnit.MINUTES;
import static java.util.concurrent.TimeUnit.NANOSECONDS;
import static java.util.concurrent.TimeUnit.SECONDS;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toMap;
import static org.apache.cassandra.config.CassandraRelevantProperties.ALLOW_UNSAFE_JOIN;
import static org.apache.cassandra.config.CassandraRelevantProperties.ALLOW_UNSAFE_REPLACE;
import static org.apache.cassandra.config.CassandraRelevantProperties.BOOTSTRAP_SCHEMA_DELAY_MS;
import static org.apache.cassandra.config.CassandraRelevantProperties.BOOTSTRAP_SKIP_SCHEMA_CHECK;
import static org.apache.cassandra.config.CassandraRelevantProperties.CONSISTENT_RANGE_MOVEMENT;
import static org.apache.cassandra.config.CassandraRelevantProperties.CONSISTENT_SIMULTANEOUS_MOVES_ALLOW;
import static org.apache.cassandra.config.CassandraRelevantProperties.DRAIN_EXECUTOR_TIMEOUT_MS;
import static org.apache.cassandra.config.CassandraRelevantProperties.JOIN_RING;
import static org.apache.cassandra.config.CassandraRelevantProperties.LOAD_RING_STATE;
import static org.apache.cassandra.config.CassandraRelevantProperties.OVERRIDE_DECOMMISSION;
import static org.apache.cassandra.config.CassandraRelevantProperties.PAXOS_REPAIR_ON_TOPOLOGY_CHANGE_RETRIES;
import static org.apache.cassandra.config.CassandraRelevantProperties.PAXOS_REPAIR_ON_TOPOLOGY_CHANGE_RETRY_DELAY_SECONDS;
import static org.apache.cassandra.config.CassandraRelevantProperties.REPLACEMENT_ALLOW_EMPTY;
import static org.apache.cassandra.config.CassandraRelevantProperties.REPLACE_ADDRESS;
import static org.apache.cassandra.config.CassandraRelevantProperties.REPLACE_ADDRESS_FIRST_BOOT;
import static org.apache.cassandra.config.CassandraRelevantProperties.RESET_BOOTSTRAP_PROGRESS;
import static org.apache.cassandra.config.CassandraRelevantProperties.START_GOSSIP;
import static org.apache.cassandra.config.CassandraRelevantProperties.TEST_WRITE_SURVEY;
import static org.apache.cassandra.index.SecondaryIndexManager.getIndexName;
import static org.apache.cassandra.index.SecondaryIndexManager.isIndexColumnFamily;
import static org.apache.cassandra.net.NoPayload.noPayload;
import static org.apache.cassandra.net.Verb.REPLICATION_DONE_REQ;
import static org.apache.cassandra.service.ActiveRepairService.ParentRepairStatus;
import static org.apache.cassandra.service.ActiveRepairService.repairCommandExecutor;
import static org.apache.cassandra.service.StorageService.Mode.DECOMMISSIONED;
import static org.apache.cassandra.service.StorageService.Mode.DECOMMISSION_FAILED;
import static org.apache.cassandra.service.StorageService.Mode.JOINING_FAILED;
import static org.apache.cassandra.utils.Clock.Global.currentTimeMillis;
import static org.apache.cassandra.utils.Clock.Global.nanoTime;
import static org.apache.cassandra.utils.FBUtilities.getBroadcastAddressAndPort;
import static org.apache.cassandra.utils.FBUtilities.now;

/**
 * This abstraction contains the token/identifier of this node
 * on the identifier space. This token gets gossiped around.
 * This class will also maintain histograms of the load information
 * of other nodes in the cluster.
 */
public class StorageService extends NotificationBroadcasterSupport implements IEndpointStateChangeSubscriber, StorageServiceMBean
{
<span class="fc" id="L285">    private static final Logger logger = LoggerFactory.getLogger(StorageService.class);</span>

    public static final int INDEFINITE = -1;
<span class="fc" id="L288">    public static final int RING_DELAY_MILLIS = getRingDelay(); // delay after which we assume ring has stablized</span>
<span class="fc" id="L289">    public static final int SCHEMA_DELAY_MILLIS = getSchemaDelay();</span>

<span class="pc bpc" id="L291" title="1 of 2 branches missed.">    private static final boolean REQUIRE_SCHEMAS = !BOOTSTRAP_SKIP_SCHEMA_CHECK.getBoolean();</span>

<span class="fc" id="L293">    private final JMXProgressSupport progressSupport = new JMXProgressSupport(this);</span>

    private static int getRingDelay()
    {
<span class="fc" id="L297">        String newdelay = CassandraRelevantProperties.RING_DELAY.getString();</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        if (newdelay != null)</span>
        {
<span class="fc" id="L300">            logger.info(&quot;Overriding RING_DELAY to {}ms&quot;, newdelay);</span>
<span class="fc" id="L301">            return Integer.parseInt(newdelay);</span>
        }
        else
        {
<span class="nc" id="L305">            return 30 * 1000;</span>
        }
    }

    private static int getSchemaDelay()
    {
<span class="fc" id="L311">        String newdelay = BOOTSTRAP_SCHEMA_DELAY_MS.getString();</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">        if (newdelay != null)</span>
        {
<span class="nc" id="L314">            logger.info(&quot;Overriding SCHEMA_DELAY_MILLIS to {}ms&quot;, newdelay);</span>
<span class="nc" id="L315">            return Integer.parseInt(newdelay);</span>
        }
        else
        {
<span class="fc" id="L319">            return 30 * 1000;</span>
        }
    }

    /* This abstraction maintains the token/endpoint metadata information */
<span class="fc" id="L324">    private TokenMetadata tokenMetadata = new TokenMetadata();</span>

<span class="fc" id="L326">    public volatile VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(tokenMetadata.partitioner);</span>

<span class="fc" id="L328">    private Thread drainOnShutdown = null;</span>
<span class="fc" id="L329">    private volatile boolean isShutdown = false;</span>
<span class="fc" id="L330">    private final List&lt;Runnable&gt; preShutdownHooks = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L331">    private final List&lt;Runnable&gt; postShutdownHooks = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L333">    public final SnapshotManager snapshotManager = new SnapshotManager();</span>

<span class="fc" id="L335">    public static final StorageService instance = new StorageService();</span>

<span class="fc" id="L337">    private final SamplingManager samplingManager = new SamplingManager();</span>

<span class="fc" id="L339">    @VisibleForTesting // this is used for dtests only, see CASSANDRA-18152</span>
    public volatile boolean skipNotificationListeners = false;

    @Deprecated
    public boolean isInShutdownHook()
    {
<span class="nc" id="L345">        return isShutdown();</span>
    }

    public boolean isShutdown()
    {
<span class="fc" id="L350">        return isShutdown;</span>
    }

    /**
     * for in-jvm dtest use - forces isShutdown to be set to whatever passed in.
     */
    @VisibleForTesting
    public void setIsShutdownUnsafeForTests(boolean isShutdown)
    {
<span class="nc" id="L359">        this.isShutdown = isShutdown;</span>
<span class="nc" id="L360">    }</span>

    public RangesAtEndpoint getLocalReplicas(String keyspaceName)
    {
<span class="fc" id="L364">        return getReplicas(keyspaceName, FBUtilities.getBroadcastAddressAndPort());</span>
    }

    public RangesAtEndpoint getReplicas(String keyspaceName, InetAddressAndPort endpoint)
    {
<span class="fc" id="L369">        return Keyspace.open(keyspaceName).getReplicationStrategy().getAddressReplicas(endpoint);</span>
    }

    public List&lt;Range&lt;Token&gt;&gt; getLocalRanges(String ks)
    {
<span class="nc" id="L374">        InetAddressAndPort broadcastAddress = FBUtilities.getBroadcastAddressAndPort();</span>
<span class="nc" id="L375">        Keyspace keyspace = Keyspace.open(ks);</span>
<span class="nc" id="L376">        List&lt;Range&lt;Token&gt;&gt; ranges = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">        for (Replica r : keyspace.getReplicationStrategy().getAddressReplicas(broadcastAddress))</span>
<span class="nc" id="L378">            ranges.add(r.range());</span>
<span class="nc" id="L379">        return ranges;</span>
    }

    public List&lt;Range&lt;Token&gt;&gt; getLocalAndPendingRanges(String ks)
    {
<span class="fc" id="L384">        InetAddressAndPort broadcastAddress = FBUtilities.getBroadcastAddressAndPort();</span>
<span class="fc" id="L385">        Keyspace keyspace = Keyspace.open(ks);</span>
<span class="fc" id="L386">        List&lt;Range&lt;Token&gt;&gt; ranges = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">        for (Replica r : keyspace.getReplicationStrategy().getAddressReplicas(broadcastAddress))</span>
<span class="fc" id="L388">            ranges.add(r.range());</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        for (Replica r : getTokenMetadata().getPendingRanges(ks, broadcastAddress))</span>
<span class="nc" id="L390">            ranges.add(r.range());</span>
<span class="fc" id="L391">        return ranges;</span>
    }

    public Collection&lt;Range&lt;Token&gt;&gt; getPrimaryRanges(String keyspace)
    {
<span class="fc" id="L396">        return getPrimaryRangesForEndpoint(keyspace, FBUtilities.getBroadcastAddressAndPort());</span>
    }

    public Collection&lt;Range&lt;Token&gt;&gt; getPrimaryRangesWithinDC(String keyspace)
    {
<span class="nc" id="L401">        return getPrimaryRangeForEndpointWithinDC(keyspace, FBUtilities.getBroadcastAddressAndPort());</span>
    }

<span class="fc" id="L404">    private final Set&lt;InetAddressAndPort&gt; replicatingNodes = Sets.newConcurrentHashSet();</span>
    private CassandraDaemon daemon;

    private InetAddressAndPort removingNode;

    /* Are we starting this node in bootstrap mode? */
    private volatile boolean isBootstrapMode;

    /* we bootstrap but do NOT join the ring unless told to do so */
<span class="fc" id="L413">    private boolean isSurveyMode = TEST_WRITE_SURVEY.getBoolean(false);</span>
    /* true if node is rebuilding and receiving data */
<span class="fc" id="L415">    private final AtomicBoolean isRebuilding = new AtomicBoolean();</span>
<span class="fc" id="L416">    private final AtomicBoolean isDecommissioning = new AtomicBoolean();</span>

<span class="fc" id="L418">    private volatile boolean initialized = false;</span>
<span class="fc" id="L419">    private volatile boolean joined = false;</span>
<span class="fc" id="L420">    private volatile boolean gossipActive = false;</span>
<span class="fc" id="L421">    private final AtomicBoolean authSetupCalled = new AtomicBoolean(false);</span>
<span class="fc" id="L422">    private volatile boolean authSetupComplete = false;</span>

    /* the probability for tracing any particular request, 0 disables tracing and 1 enables for all */
<span class="fc" id="L425">    private double traceProbability = 0.0;</span>

<span class="fc" id="L427">    public enum Mode { STARTING, NORMAL, JOINING, JOINING_FAILED, LEAVING, DECOMMISSIONED, DECOMMISSION_FAILED, MOVING, DRAINING, DRAINED }</span>
<span class="fc" id="L428">    private volatile Mode operationMode = Mode.STARTING;</span>

    /* Used for tracking drain progress */
    private volatile int totalCFs, remainingCFs;

<span class="fc" id="L433">    private static final AtomicInteger nextRepairCommand = new AtomicInteger();</span>

<span class="fc" id="L435">    private final List&lt;IEndpointLifecycleSubscriber&gt; lifecycleSubscribers = new CopyOnWriteArrayList&lt;&gt;();</span>

    private final String jmxObjectName;

<span class="fc" id="L439">    private Collection&lt;Token&gt; bootstrapTokens = null;</span>

    // true when keeping strict consistency while bootstrapping
<span class="fc" id="L442">    public static final boolean useStrictConsistency = CONSISTENT_RANGE_MOVEMENT.getBoolean();</span>
<span class="fc" id="L443">    private static final boolean allowSimultaneousMoves = CONSISTENT_SIMULTANEOUS_MOVES_ALLOW.getBoolean();</span>
<span class="fc" id="L444">    private static final boolean joinRing = JOIN_RING.getBoolean();</span>
    private boolean replacing;

<span class="fc" id="L447">    private final StreamStateStore streamStateStore = new StreamStateStore();</span>

    public final SSTablesGlobalTracker sstablesTracker;

    public boolean isSurveyMode()
    {
<span class="fc" id="L453">        return isSurveyMode;</span>
    }

    public boolean hasJoined()
    {
<span class="fc" id="L458">        return joined;</span>
    }

    /**
     * This method updates the local token on disk
     */
    public void setTokens(Collection&lt;Token&gt; tokens)
    {
<span class="pc bpc" id="L466" title="2 of 4 branches missed.">        assert tokens != null &amp;&amp; !tokens.isEmpty() : &quot;Node needs at least one token.&quot;;</span>
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="fc" id="L468">            logger.debug(&quot;Setting tokens to {}&quot;, tokens);</span>
<span class="fc" id="L469">        SystemKeyspace.updateTokens(tokens);</span>
<span class="fc" id="L470">        Collection&lt;Token&gt; localTokens = getLocalTokens();</span>
<span class="fc" id="L471">        setGossipTokens(localTokens);</span>
<span class="fc" id="L472">        tokenMetadata.updateNormalTokens(tokens, FBUtilities.getBroadcastAddressAndPort());</span>
<span class="fc" id="L473">        setMode(Mode.NORMAL, false);</span>
<span class="fc" id="L474">        invalidateLocalRanges();</span>
<span class="fc" id="L475">    }</span>

    public void setGossipTokens(Collection&lt;Token&gt; tokens)
    {
<span class="fc" id="L479">        List&lt;Pair&lt;ApplicationState, VersionedValue&gt;&gt; states = new ArrayList&lt;Pair&lt;ApplicationState, VersionedValue&gt;&gt;();</span>
<span class="fc" id="L480">        states.add(Pair.create(ApplicationState.TOKENS, valueFactory.tokens(tokens)));</span>
<span class="fc" id="L481">        states.add(Pair.create(ApplicationState.STATUS_WITH_PORT, valueFactory.normal(tokens)));</span>
<span class="fc" id="L482">        states.add(Pair.create(ApplicationState.STATUS, valueFactory.normal(tokens)));</span>
<span class="fc" id="L483">        Gossiper.instance.addLocalApplicationStates(states);</span>
<span class="fc" id="L484">    }</span>

    public StorageService()
    {
        // use dedicated executor for handling JMX notifications
<span class="fc" id="L489">        super(JMXBroadcastExecutor.executor);</span>

<span class="fc" id="L491">        jmxObjectName = &quot;org.apache.cassandra.db:type=StorageService&quot;;</span>

<span class="fc" id="L493">        sstablesTracker = new SSTablesGlobalTracker(DatabaseDescriptor.getSelectedSSTableFormat());</span>
<span class="fc" id="L494">    }</span>

    private void registerMBeans()
    {
<span class="fc" id="L498">        MBeanWrapper.instance.registerMBean(this, jmxObjectName);</span>
<span class="fc" id="L499">        MBeanWrapper.instance.registerMBean(StreamManager.instance, StreamManager.OBJECT_NAME);</span>
<span class="fc" id="L500">    }</span>

    public void registerDaemon(CassandraDaemon daemon)
    {
<span class="fc" id="L504">        this.daemon = daemon;</span>
<span class="fc" id="L505">    }</span>

    public void register(IEndpointLifecycleSubscriber subscriber)
    {
<span class="fc" id="L509">        lifecycleSubscribers.add(subscriber);</span>
<span class="fc" id="L510">    }</span>

    public void unregister(IEndpointLifecycleSubscriber subscriber)
    {
<span class="nc" id="L514">        lifecycleSubscribers.remove(subscriber);</span>
<span class="nc" id="L515">    }</span>

    // should only be called via JMX
    public void stopGossiping()
    {
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">        if (gossipActive)</span>
        {
<span class="pc bpc" id="L522" title="3 of 4 branches missed.">            if (!isNormal() &amp;&amp; joinRing)</span>
<span class="nc" id="L523">                throw new IllegalStateException(&quot;Unable to stop gossip because the node is not in the normal state. Try to stop the node instead.&quot;);</span>

<span class="fc" id="L525">            logger.warn(&quot;Stopping gossip by operator request&quot;);</span>

<span class="pc bpc" id="L527" title="1 of 2 branches missed.">            if (isNativeTransportRunning())</span>
            {
<span class="nc" id="L529">                logger.warn(&quot;Disabling gossip while native transport is still active is unsafe&quot;);</span>
            }

<span class="fc" id="L532">            Gossiper.instance.stop();</span>
<span class="fc" id="L533">            gossipActive = false;</span>
        }
<span class="fc" id="L535">    }</span>

    // should only be called via JMX
    public synchronized void startGossiping()
    {
<span class="fc bfc" id="L540" title="All 2 branches covered.">        if (!gossipActive)</span>
        {
<span class="fc" id="L542">            checkServiceAllowedToStart(&quot;gossip&quot;);</span>

<span class="fc" id="L544">            logger.warn(&quot;Starting gossip by operator request&quot;);</span>
<span class="fc" id="L545">            Collection&lt;Token&gt; tokens = SystemKeyspace.getSavedTokens();</span>

<span class="pc bpc" id="L547" title="2 of 4 branches missed.">            boolean validTokens = tokens != null &amp;&amp; !tokens.isEmpty();</span>

            // shouldn't be called before these are set if we intend to join the ring/are in the process of doing so
<span class="pc bpc" id="L550" title="3 of 4 branches missed.">            if (joined || joinRing)</span>
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">                assert validTokens : &quot;Cannot start gossiping for a node intended to join without valid tokens&quot;;</span>

<span class="pc bpc" id="L553" title="1 of 2 branches missed.">            if (validTokens)</span>
<span class="fc" id="L554">                setGossipTokens(tokens);</span>

<span class="fc" id="L556">            Gossiper.instance.forceNewerGeneration();</span>
<span class="fc" id="L557">            Gossiper.instance.start((int) (currentTimeMillis() / 1000));</span>
<span class="fc" id="L558">            gossipActive = true;</span>
        }
<span class="fc" id="L560">    }</span>

    // should only be called via JMX
    public boolean isGossipRunning()
    {
<span class="nc" id="L565">        return Gossiper.instance.isEnabled();</span>
    }

    public synchronized void startNativeTransport()
    {
<span class="nc" id="L570">        checkServiceAllowedToStart(&quot;native transport&quot;);</span>

<span class="nc bnc" id="L572" title="All 2 branches missed.">        if (daemon == null)</span>
        {
<span class="nc" id="L574">            throw new IllegalStateException(&quot;No configured daemon&quot;);</span>
        }

        try
        {
<span class="nc" id="L579">            daemon.startNativeTransport();</span>
        }
<span class="nc" id="L581">        catch (Exception e)</span>
        {
<span class="nc" id="L583">            throw new RuntimeException(&quot;Error starting native transport: &quot; + e.getMessage());</span>
<span class="nc" id="L584">        }</span>
<span class="nc" id="L585">    }</span>

    public void stopNativeTransport()
    {
<span class="pc bpc" id="L589" title="1 of 2 branches missed.">        if (daemon == null)</span>
        {
<span class="nc" id="L591">            throw new IllegalStateException(&quot;No configured daemon&quot;);</span>
        }
<span class="fc" id="L593">        daemon.stopNativeTransport();</span>
<span class="fc" id="L594">    }</span>

    public boolean isNativeTransportRunning()
    {
<span class="fc bfc" id="L598" title="All 2 branches covered.">        if (daemon == null)</span>
        {
<span class="fc" id="L600">            return false;</span>
        }
<span class="fc" id="L602">        return daemon.isNativeTransportRunning();</span>
    }

    @Override
    public void enableNativeTransportOldProtocolVersions()
    {
<span class="nc" id="L608">        DatabaseDescriptor.setNativeTransportAllowOlderProtocols(true);</span>
<span class="nc" id="L609">    }</span>

    @Override
    public void disableNativeTransportOldProtocolVersions()
    {
<span class="nc" id="L614">        DatabaseDescriptor.setNativeTransportAllowOlderProtocols(false);</span>
<span class="nc" id="L615">    }</span>

    public void stopTransports()
    {
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">        if (isNativeTransportRunning())</span>
        {
<span class="nc" id="L621">            logger.error(&quot;Stopping native transport&quot;);</span>
<span class="nc" id="L622">            stopNativeTransport();</span>
        }
<span class="fc bfc" id="L624" title="All 2 branches covered.">        if (isGossipActive())</span>
        {
<span class="fc" id="L626">            logger.error(&quot;Stopping gossiper&quot;);</span>
<span class="fc" id="L627">            stopGossiping();</span>
        }
<span class="fc" id="L629">    }</span>

    /**
     * Set the Gossip flag RPC_READY to false and then
     * shutdown the client services (thrift and CQL).
     *
     * Note that other nodes will do this for us when
     * they get the Gossip shutdown message, so even if
     * we don't get time to broadcast this, it is not a problem.
     *
     * See {@code Gossiper#markAsShutdown(InetAddressAndPort)}
     */
    private void shutdownClientServers()
    {
<span class="fc" id="L643">        setRpcReady(false);</span>
<span class="fc" id="L644">        stopNativeTransport();</span>
<span class="fc" id="L645">    }</span>

    public void stopClient()
    {
<span class="fc" id="L649">        Gossiper.instance.unregister(this);</span>
<span class="fc" id="L650">        Gossiper.instance.stop();</span>
<span class="fc" id="L651">        MessagingService.instance().shutdown();</span>
        // give it a second so that task accepted before the MessagingService shutdown gets submitted to the stage (to avoid RejectedExecutionException)
<span class="fc" id="L653">        Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);</span>
<span class="fc" id="L654">        Stage.shutdownNow();</span>
<span class="fc" id="L655">    }</span>

    public boolean isInitialized()
    {
<span class="fc" id="L659">        return initialized;</span>
    }

    public boolean isGossipActive()
    {
<span class="fc" id="L664">        return gossipActive;</span>
    }

    public boolean isDaemonSetupCompleted()
    {
<span class="fc bfc" id="L669" title="All 4 branches covered.">        return daemon != null &amp;&amp; daemon.setupCompleted();</span>
    }

    public void stopDaemon()
    {
<span class="nc bnc" id="L674" title="All 2 branches missed.">        if (daemon == null)</span>
<span class="nc" id="L675">            throw new IllegalStateException(&quot;No configured daemon&quot;);</span>
<span class="nc" id="L676">        daemon.deactivate();</span>
<span class="nc" id="L677">    }</span>

    private synchronized UUID prepareForReplacement() throws ConfigurationException
    {
<span class="nc bnc" id="L681" title="All 2 branches missed.">        if (SystemKeyspace.bootstrapComplete())</span>
<span class="nc" id="L682">            throw new RuntimeException(&quot;Cannot replace address with a node that is already bootstrapped&quot;);</span>

<span class="nc bnc" id="L684" title="All 2 branches missed.">        if (!joinRing)</span>
<span class="nc" id="L685">            throw new ConfigurationException(&quot;Cannot set both join_ring=false and attempt to replace a node&quot;);</span>

<span class="nc bnc" id="L687" title="All 4 branches missed.">        if (!shouldBootstrap() &amp;&amp; !ALLOW_UNSAFE_REPLACE.getBoolean())</span>
<span class="nc" id="L688">            throw new RuntimeException(&quot;Replacing a node without bootstrapping risks invalidating consistency &quot; +</span>
                                       &quot;guarantees as the expected data may not be present until repair is run. &quot; +
                                       &quot;To perform this operation, please restart with &quot; +
<span class="nc" id="L691">                                       &quot;-D&quot; + ALLOW_UNSAFE_REPLACE.getKey() + &quot;=true&quot;);</span>

<span class="nc" id="L693">        InetAddressAndPort replaceAddress = DatabaseDescriptor.getReplaceAddress();</span>
<span class="nc" id="L694">        logger.info(&quot;Gathering node replacement information for {}&quot;, replaceAddress);</span>
<span class="nc" id="L695">        Map&lt;InetAddressAndPort, EndpointState&gt; epStates = Gossiper.instance.doShadowRound();</span>
        // as we've completed the shadow round of gossip, we should be able to find the node we're replacing
<span class="nc" id="L697">        EndpointState state = epStates.get(replaceAddress);</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">        if (state == null)</span>
<span class="nc" id="L699">            throw new RuntimeException(String.format(&quot;Cannot replace_address %s because it doesn't exist in gossip&quot;, replaceAddress));</span>

<span class="nc" id="L701">        validateEndpointSnitch(epStates.values().iterator());</span>

        try
        {
<span class="nc" id="L705">            VersionedValue tokensVersionedValue = state.getApplicationState(ApplicationState.TOKENS);</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">            if (tokensVersionedValue == null)</span>
<span class="nc" id="L707">                throw new RuntimeException(String.format(&quot;Could not find tokens for %s to replace&quot;, replaceAddress));</span>

<span class="nc" id="L709">            Collection&lt;Token&gt; tokens = TokenSerializer.deserialize(tokenMetadata.partitioner, new DataInputStream(new ByteArrayInputStream(tokensVersionedValue.toBytes())));</span>
<span class="nc" id="L710">            bootstrapTokens = validateReplacementBootstrapTokens(tokenMetadata, replaceAddress, tokens);</span>

<span class="nc bnc" id="L712" title="All 4 branches missed.">            if (state.isEmptyWithoutStatus() &amp;&amp; REPLACEMENT_ALLOW_EMPTY.getBoolean())</span>
            {
<span class="nc" id="L714">                logger.warn(&quot;Gossip state not present for replacing node {}. Adding temporary entry to continue.&quot;, replaceAddress);</span>

                // When replacing a node, we take ownership of all its tokens.
                // If that node is currently down and not present in the gossip info
                // of any other live peers, then we will not be able to take ownership
                // of its tokens during bootstrap as they have no way of being propagated
                // to this node's TokenMetadata. TM is loaded at startup (in which case
                // it will be/ empty for a new replacement node) and only updated with
                // tokens for an endpoint during normal state propagation (which will not
                // occur if no peers have gossip state for it).
                // However, the presence of host id and tokens in the system tables implies
                // that the node managed to complete bootstrap at some point in the past.
                // Peers may include this information loaded directly from system tables
                // in a GossipDigestAck *only if* the GossipDigestSyn was sent as part of a
                // shadow round (otherwise, a GossipDigestAck contains only state about peers
                // learned via gossip).
                // It is safe to do this here as since we completed a shadow round we know
                // that :
                // * replaceAddress successfully bootstrapped at some point and owned these
                //   tokens
                // * we know that no other node currently owns these tokens
                // * we are going to completely take over replaceAddress's ownership of
                //   these tokens.
<span class="nc" id="L737">                tokenMetadata.updateNormalTokens(bootstrapTokens, replaceAddress);</span>
<span class="nc" id="L738">                UUID hostId = Gossiper.instance.getHostId(replaceAddress, epStates);</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">                if (hostId != null)</span>
<span class="nc" id="L740">                    tokenMetadata.updateHostId(hostId, replaceAddress);</span>

                // If we were only able to learn about the node being replaced through the
                // shadow gossip round (i.e. there is no state in gossip across the cluster
                // about it, perhaps because the entire cluster has been bounced since it went
                // down), then we're safe to proceed with the replacement. In this case, there
                // will be no local endpoint state as we discard the results of the shadow
                // round after preparing replacement info. We inject a minimal EndpointState
                // to keep FailureDetector::isAlive and Gossiper::compareEndpointStartup from
                // failing later in the replacement, as they both expect the replaced node to
                // be fully present in gossip.
                // Otherwise, if the replaced node is present in gossip, we need check that
                // it is not in fact live.
                // We choose to not include the EndpointState provided during the shadow round
                // as its possible to include more state than is desired, so by creating a
                // new empty endpoint without that information we can control what is in our
                // local gossip state
<span class="nc" id="L757">                Gossiper.instance.initializeUnreachableNodeUnsafe(replaceAddress);</span>
            }
        }
<span class="nc" id="L760">        catch (IOException e)</span>
        {
<span class="nc" id="L762">            throw new RuntimeException(e);</span>
<span class="nc" id="L763">        }</span>

<span class="nc" id="L765">        UUID localHostId = SystemKeyspace.getOrInitializeLocalHostId();</span>

<span class="nc bnc" id="L767" title="All 2 branches missed.">        if (isReplacingSameAddress())</span>
        {
<span class="nc" id="L769">            localHostId = Gossiper.instance.getHostId(replaceAddress, epStates);</span>
<span class="nc" id="L770">            SystemKeyspace.setLocalHostId(localHostId); // use the replacee's host Id as our own so we receive hints, etc</span>
        }

<span class="nc" id="L773">        return localHostId;</span>
    }

    private static Collection&lt;Token&gt; validateReplacementBootstrapTokens(TokenMetadata tokenMetadata,
                                                                        InetAddressAndPort replaceAddress,
                                                                        Collection&lt;Token&gt; bootstrapTokens)
    {
<span class="nc" id="L780">        Map&lt;Token, InetAddressAndPort&gt; conflicts = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">        for (Token token : bootstrapTokens)</span>
        {
<span class="nc" id="L783">            InetAddressAndPort conflict = tokenMetadata.getEndpoint(token);</span>
<span class="nc bnc" id="L784" title="All 4 branches missed.">            if (null != conflict &amp;&amp; !conflict.equals(replaceAddress))</span>
<span class="nc" id="L785">                conflicts.put(token, tokenMetadata.getEndpoint(token));</span>
<span class="nc" id="L786">        }</span>

<span class="nc bnc" id="L788" title="All 2 branches missed.">        if (!conflicts.isEmpty())</span>
        {
<span class="nc" id="L790">            String error = String.format(&quot;Conflicting token ownership information detected between &quot; +</span>
                                         &quot;gossip and current ring view during proposed replacement &quot; +
                                         &quot;of %s. Some tokens identified in gossip for the node being &quot; +
                                         &quot;replaced are currently owned by other peers: %s&quot;,
                                         replaceAddress,
<span class="nc" id="L795">                                         conflicts.entrySet()</span>
<span class="nc" id="L796">                                                  .stream()</span>
<span class="nc" id="L797">                                                  .map(e -&gt; e.getKey() + &quot;(&quot; + e.getValue() + &quot;)&quot; )</span>
<span class="nc" id="L798">                                                  .collect(Collectors.joining(&quot;,&quot;)));</span>
<span class="nc" id="L799">            throw new RuntimeException(error);</span>

        }
<span class="nc" id="L802">        return bootstrapTokens;</span>
    }

    public synchronized void checkForEndpointCollision(UUID localHostId, Set&lt;InetAddressAndPort&gt; peers) throws ConfigurationException
    {
<span class="fc bfc" id="L807" title="All 2 branches covered.">        if (ALLOW_UNSAFE_JOIN.getBoolean())</span>
        {
<span class="fc" id="L809">            logger.warn(&quot;Skipping endpoint collision check as &quot; + ALLOW_UNSAFE_JOIN.getKey() + &quot;=true&quot;);</span>
<span class="fc" id="L810">            return;</span>
        }

<span class="fc" id="L813">        logger.debug(&quot;Starting shadow gossip round to check for endpoint collision&quot;);</span>
<span class="fc" id="L814">        Map&lt;InetAddressAndPort, EndpointState&gt; epStates = Gossiper.instance.doShadowRound(peers);</span>

<span class="pc bpc" id="L816" title="1 of 4 branches missed.">        if (epStates.isEmpty() &amp;&amp; DatabaseDescriptor.getSeeds().contains(FBUtilities.getBroadcastAddressAndPort()))</span>
<span class="fc" id="L817">            logger.info(&quot;Unable to gossip with any peers but continuing anyway since node is in its own seed list&quot;);</span>

        // If bootstrapping, check whether any previously known status for the endpoint makes it unsafe to do so.
        // If not bootstrapping, compare the host id for this endpoint learned from gossip (if any) with the local
        // one, which was either read from system.local or generated at startup. If a learned id is present &amp;
        // doesn't match the local, then the node needs replacing
<span class="pc bpc" id="L823" title="1 of 2 branches missed.">        if (!Gossiper.instance.isSafeForStartup(FBUtilities.getBroadcastAddressAndPort(), localHostId, shouldBootstrap(), epStates))</span>
        {
<span class="nc" id="L825">            throw new RuntimeException(String.format(&quot;A node with address %s already exists, cancelling join. &quot; +</span>
                                                     &quot;Use %s if you want to replace this node.&quot;,
<span class="nc" id="L827">                                                     FBUtilities.getBroadcastAddressAndPort(), REPLACE_ADDRESS.getKey()));</span>
        }

<span class="fc" id="L830">        validateEndpointSnitch(epStates.values().iterator());</span>

<span class="pc bpc" id="L832" title="2 of 6 branches missed.">        if (shouldBootstrap() &amp;&amp; useStrictConsistency &amp;&amp; !allowSimultaneousMoves())</span>
        {
<span class="fc bfc" id="L834" title="All 2 branches covered.">            for (Map.Entry&lt;InetAddressAndPort, EndpointState&gt; entry : epStates.entrySet())</span>
            {
                // ignore local node or empty status
<span class="pc bpc" id="L837" title="4 of 8 branches missed.">                if (entry.getKey().equals(FBUtilities.getBroadcastAddressAndPort()) || (entry.getValue().getApplicationState(ApplicationState.STATUS_WITH_PORT) == null &amp; entry.getValue().getApplicationState(ApplicationState.STATUS) == null))</span>
<span class="fc" id="L838">                    continue;</span>

<span class="nc" id="L840">                VersionedValue value = entry.getValue().getApplicationState(ApplicationState.STATUS_WITH_PORT);</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">                if (value == null)</span>
                {
<span class="nc" id="L843">                    value = entry.getValue().getApplicationState(ApplicationState.STATUS);</span>
                }

<span class="nc" id="L846">                String[] pieces = splitValue(value);</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">                assert (pieces.length &gt; 0);</span>
<span class="nc" id="L848">                String state = pieces[0];</span>
<span class="nc bnc" id="L849" title="All 6 branches missed.">                if (state.equals(VersionedValue.STATUS_BOOTSTRAPPING) || state.equals(VersionedValue.STATUS_LEAVING) || state.equals(VersionedValue.STATUS_MOVING))</span>
<span class="nc" id="L850">                    throw new UnsupportedOperationException(&quot;Other bootstrapping/leaving/moving nodes detected, cannot bootstrap while &quot; + CONSISTENT_RANGE_MOVEMENT.getKey() + &quot; is true&quot;);</span>
<span class="nc" id="L851">            }</span>
        }
<span class="fc" id="L853">    }</span>

    private static void validateEndpointSnitch(Iterator&lt;EndpointState&gt; endpointStates)
    {
<span class="fc" id="L857">        Set&lt;String&gt; datacenters = new HashSet&lt;&gt;();</span>
<span class="fc" id="L858">        Set&lt;String&gt; racks = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L859" title="All 2 branches covered.">        while (endpointStates.hasNext())</span>
        {
<span class="fc" id="L861">            EndpointState state = endpointStates.next();</span>
<span class="fc" id="L862">            VersionedValue val = state.getApplicationState(ApplicationState.DC);</span>
<span class="pc bpc" id="L863" title="1 of 2 branches missed.">            if (val != null)</span>
<span class="nc" id="L864">                datacenters.add(val.value);</span>
<span class="fc" id="L865">            val = state.getApplicationState(ApplicationState.RACK);</span>
<span class="pc bpc" id="L866" title="1 of 2 branches missed.">            if (val != null)</span>
<span class="nc" id="L867">                racks.add(val.value);</span>
<span class="fc" id="L868">        }</span>

<span class="fc" id="L870">        IEndpointSnitch snitch = DatabaseDescriptor.getEndpointSnitch();</span>
<span class="pc bpc" id="L871" title="1 of 2 branches missed.">        if (!snitch.validate(datacenters, racks))</span>
        {
<span class="nc" id="L873">            throw new IllegalStateException();</span>
        }
<span class="fc" id="L875">    }</span>

    private boolean allowSimultaneousMoves()
    {
<span class="pc bpc" id="L879" title="3 of 4 branches missed.">        return allowSimultaneousMoves &amp;&amp; DatabaseDescriptor.getNumTokens() == 1;</span>
    }

    // for testing only
    public void unsafeInitialize() throws ConfigurationException
    {
<span class="fc" id="L885">        initialized = true;</span>
<span class="fc" id="L886">        gossipActive = true;</span>
<span class="fc" id="L887">        Gossiper.instance.register(this);</span>
<span class="fc" id="L888">        Gossiper.instance.start((int) (currentTimeMillis() / 1000)); // needed for node-ring gathering.</span>
<span class="fc" id="L889">        Gossiper.instance.addLocalApplicationState(ApplicationState.NET_VERSION, valueFactory.networkVersion());</span>
<span class="fc" id="L890">        MessagingService.instance().listen();</span>
<span class="fc" id="L891">    }</span>

    public synchronized void initServer() throws ConfigurationException
    {
<span class="fc" id="L895">        initServer(SCHEMA_DELAY_MILLIS, RING_DELAY_MILLIS);</span>
<span class="fc" id="L896">    }</span>

    public synchronized void initServer(int schemaAndRingDelayMillis) throws ConfigurationException
    {
<span class="fc" id="L900">        initServer(schemaAndRingDelayMillis, RING_DELAY_MILLIS);</span>
<span class="fc" id="L901">    }</span>

    public synchronized void initServer(int schemaTimeoutMillis, int ringTimeoutMillis) throws ConfigurationException
    {
<span class="fc" id="L905">        logger.info(&quot;Cassandra version: {}&quot;, FBUtilities.getReleaseVersionString());</span>
<span class="fc" id="L906">        logger.info(&quot;Git SHA: {}&quot;, FBUtilities.getGitSHA());</span>
<span class="fc" id="L907">        logger.info(&quot;CQL version: {}&quot;, QueryProcessor.CQL_VERSION);</span>
<span class="fc" id="L908">        logger.info(&quot;Native protocol supported versions: {} (default: {})&quot;,</span>
<span class="fc" id="L909">                    StringUtils.join(ProtocolVersion.supportedVersions(), &quot;, &quot;), ProtocolVersion.CURRENT);</span>

        try
        {
            // Ensure StorageProxy is initialized on start-up; see CASSANDRA-3797.
<span class="fc" id="L914">            Class.forName(&quot;org.apache.cassandra.service.StorageProxy&quot;);</span>
            // also IndexSummaryManager, which is otherwise unreferenced
<span class="fc" id="L916">            Class.forName(&quot;org.apache.cassandra.io.sstable.indexsummary.IndexSummaryManager&quot;);</span>
        }
<span class="nc" id="L918">        catch (ClassNotFoundException e)</span>
        {
<span class="nc" id="L920">            throw new AssertionError(e);</span>
<span class="fc" id="L921">        }</span>

<span class="pc bpc" id="L923" title="1 of 2 branches missed.">        if (LOAD_RING_STATE.getBoolean())</span>
        {
<span class="fc" id="L925">            logger.info(&quot;Loading persisted ring state&quot;);</span>
<span class="fc" id="L926">            populatePeerTokenMetadata();</span>
<span class="fc bfc" id="L927" title="All 2 branches covered.">            for (InetAddressAndPort endpoint : tokenMetadata.getAllEndpoints())</span>
<span class="fc" id="L928">                Gossiper.runInGossipStageBlocking(() -&gt; Gossiper.instance.addSavedEndpoint(endpoint));</span>
        }

        // daemon threads, like our executors', continue to run while shutdown hooks are invoked
<span class="fc" id="L932">        drainOnShutdown = NamedThreadFactory.createThread(new WrappedRunnable()</span>
<span class="fc" id="L933">        {</span>
            @Override
            public void runMayThrow() throws InterruptedException, ExecutionException, IOException
            {
<span class="fc" id="L937">                drain(true);</span>
                try
                {
<span class="fc" id="L940">                    ExecutorUtils.shutdownNowAndWait(1, MINUTES, ScheduledExecutors.scheduledFastTasks);</span>
                }
<span class="nc" id="L942">                catch (Throwable t)</span>
                {
<span class="nc" id="L944">                    logger.warn(&quot;Unable to terminate fast tasks within 1 minute.&quot;, t);</span>
                }
                finally
                {
<span class="nc" id="L948">                    LoggingSupportFactory.getLoggingSupport().onShutdown();</span>
                }
<span class="nc" id="L950">            }</span>
        }, &quot;StorageServiceShutdownHook&quot;);
<span class="fc" id="L952">        Runtime.getRuntime().addShutdownHook(drainOnShutdown);</span>

<span class="fc" id="L954">        replacing = isReplacing();</span>

<span class="pc bpc" id="L956" title="1 of 2 branches missed.">        if (!START_GOSSIP.getBoolean())</span>
        {
<span class="nc" id="L958">            logger.info(&quot;Not starting gossip as requested.&quot;);</span>
<span class="nc" id="L959">            completeInitialization();</span>
<span class="nc" id="L960">            return;</span>
        }

<span class="fc" id="L963">        prepareToJoin();</span>

        // Has to be called after the host id has potentially changed in prepareToJoin().
        try
        {
<span class="fc" id="L968">            CacheService.instance.counterCache.loadSavedAsync().get();</span>
        }
<span class="nc" id="L970">        catch (Throwable t)</span>
        {
<span class="nc" id="L972">            JVMStabilityInspector.inspectThrowable(t);</span>
<span class="nc" id="L973">            logger.warn(&quot;Error loading counter cache&quot;, t);</span>
<span class="fc" id="L974">        }</span>

<span class="pc bpc" id="L976" title="1 of 2 branches missed.">        if (joinRing)</span>
        {
<span class="fc" id="L978">            joinTokenRing(schemaTimeoutMillis, ringTimeoutMillis);</span>
        }
        else
        {
<span class="nc" id="L982">            Collection&lt;Token&gt; tokens = SystemKeyspace.getSavedTokens();</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">            if (!tokens.isEmpty())</span>
            {
<span class="nc" id="L985">                tokenMetadata.updateNormalTokens(tokens, FBUtilities.getBroadcastAddressAndPort());</span>
                // order is important here, the gossiper can fire in between adding these two states.  It's ok to send TOKENS without STATUS, but *not* vice versa.
<span class="nc" id="L987">                List&lt;Pair&lt;ApplicationState, VersionedValue&gt;&gt; states = new ArrayList&lt;Pair&lt;ApplicationState, VersionedValue&gt;&gt;();</span>
<span class="nc" id="L988">                states.add(Pair.create(ApplicationState.TOKENS, valueFactory.tokens(tokens)));</span>
<span class="nc" id="L989">                states.add(Pair.create(ApplicationState.STATUS_WITH_PORT, valueFactory.hibernate(true)));</span>
<span class="nc" id="L990">                states.add(Pair.create(ApplicationState.STATUS, valueFactory.hibernate(true)));</span>
<span class="nc" id="L991">                Gossiper.instance.addLocalApplicationStates(states);</span>
            }
<span class="nc" id="L993">            doAuthSetup(true);</span>
<span class="nc" id="L994">            logger.info(&quot;Not joining ring as requested. Use JMX (StorageService-&gt;joinRing()) to initiate ring joining&quot;);</span>
        }

<span class="fc" id="L997">        completeInitialization();</span>
<span class="fc" id="L998">    }</span>

    @VisibleForTesting
    public void completeInitialization()
    {
<span class="fc bfc" id="L1003" title="All 2 branches covered.">        if (!initialized)</span>
<span class="fc" id="L1004">            registerMBeans();</span>
<span class="fc" id="L1005">        initialized = true;</span>
<span class="fc" id="L1006">    }</span>

    public void populateTokenMetadata()
    {
<span class="pc bpc" id="L1010" title="1 of 2 branches missed.">        if (LOAD_RING_STATE.getBoolean())</span>
        {
<span class="fc" id="L1012">            populatePeerTokenMetadata();</span>
            // if we have not completed bootstrapping, we should not add ourselves as a normal token
<span class="pc bpc" id="L1014" title="1 of 2 branches missed.">            if (!shouldBootstrap())</span>
<span class="fc" id="L1015">                tokenMetadata.updateNormalTokens(SystemKeyspace.getSavedTokens(), FBUtilities.getBroadcastAddressAndPort());</span>

<span class="fc" id="L1017">            logger.info(&quot;Token metadata: {}&quot;, tokenMetadata);</span>
        }
<span class="fc" id="L1019">    }</span>

    private void populatePeerTokenMetadata()
    {
<span class="fc" id="L1023">        logger.info(&quot;Populating token metadata from system tables&quot;);</span>
<span class="fc" id="L1024">        Multimap&lt;InetAddressAndPort, Token&gt; loadedTokens = SystemKeyspace.loadTokens();</span>

        // entry has been mistakenly added, delete it
<span class="pc bpc" id="L1027" title="1 of 2 branches missed.">        if (loadedTokens.containsKey(FBUtilities.getBroadcastAddressAndPort()))</span>
<span class="nc" id="L1028">            SystemKeyspace.removeEndpoint(FBUtilities.getBroadcastAddressAndPort());</span>

<span class="fc" id="L1030">        Map&lt;InetAddressAndPort, UUID&gt; loadedHostIds = SystemKeyspace.loadHostIds();</span>
<span class="fc" id="L1031">        Map&lt;UUID, InetAddressAndPort&gt; hostIdToEndpointMap = new HashMap&lt;&gt;();</span>
<span class="pc bpc" id="L1032" title="1 of 2 branches missed.">        for (InetAddressAndPort ep : loadedTokens.keySet())</span>
        {
<span class="nc" id="L1034">            UUID hostId = loadedHostIds.get(ep);</span>
<span class="nc bnc" id="L1035" title="All 2 branches missed.">            if (hostId != null)</span>
<span class="nc" id="L1036">                hostIdToEndpointMap.put(hostId, ep);</span>
<span class="nc" id="L1037">        }</span>
<span class="fc" id="L1038">        tokenMetadata.updateNormalTokens(loadedTokens);</span>
<span class="fc" id="L1039">        tokenMetadata.updateHostIds(hostIdToEndpointMap);</span>
<span class="fc" id="L1040">    }</span>

    public boolean isReplacing()
    {
<span class="pc bpc" id="L1044" title="1 of 2 branches missed.">        if (replacing)</span>
<span class="nc" id="L1045">            return true;</span>

<span class="pc bpc" id="L1047" title="3 of 4 branches missed.">        if (REPLACE_ADDRESS_FIRST_BOOT.getString() != null &amp;&amp; SystemKeyspace.bootstrapComplete())</span>
        {
<span class="nc" id="L1049">            logger.info(&quot;Replace address on the first boot requested; this node is already bootstrapped&quot;);</span>
<span class="nc" id="L1050">            return false;</span>
        }

<span class="pc bpc" id="L1053" title="1 of 2 branches missed.">        return DatabaseDescriptor.getReplaceAddress() != null;</span>
    }

    /**
     * In the event of forceful termination we need to remove the shutdown hook to prevent hanging (OOM for instance)
     */
    public void removeShutdownHook()
    {
<span class="fc" id="L1061">        PathUtils.clearOnExitThreads();</span>

<span class="fc bfc" id="L1063" title="All 2 branches covered.">        if (drainOnShutdown != null)</span>
<span class="fc" id="L1064">            Runtime.getRuntime().removeShutdownHook(drainOnShutdown);</span>
<span class="fc" id="L1065">    }</span>

    private boolean shouldBootstrap()
    {
<span class="fc bfc" id="L1069" title="All 6 branches covered.">        return DatabaseDescriptor.isAutoBootstrap() &amp;&amp; !SystemKeyspace.bootstrapComplete() &amp;&amp; !isSeed();</span>
    }

    public static boolean isSeed()
    {
<span class="fc" id="L1074">        return DatabaseDescriptor.getSeeds().contains(FBUtilities.getBroadcastAddressAndPort());</span>
    }

    private void prepareToJoin() throws ConfigurationException
    {
<span class="fc bfc" id="L1079" title="All 2 branches covered.">        if (!joined)</span>
        {
<span class="fc" id="L1081">            Map&lt;ApplicationState, VersionedValue&gt; appStates = new EnumMap&lt;&gt;(ApplicationState.class);</span>

<span class="pc bpc" id="L1083" title="1 of 2 branches missed.">            if (SystemKeyspace.wasDecommissioned())</span>
            {
<span class="nc bnc" id="L1085" title="All 2 branches missed.">                if (OVERRIDE_DECOMMISSION.getBoolean())</span>
                {
<span class="nc" id="L1087">                    logger.warn(&quot;This node was decommissioned, but overriding by operator request.&quot;);</span>
<span class="nc" id="L1088">                    SystemKeyspace.setBootstrapState(SystemKeyspace.BootstrapState.COMPLETED);</span>
                }
                else
                {
<span class="nc" id="L1092">                    throw new ConfigurationException(&quot;This node was decommissioned and will not rejoin the ring unless -D&quot; + OVERRIDE_DECOMMISSION.getKey() +</span>
                                                     &quot;=true has been set, or all existing data is removed and the node is bootstrapped again&quot;);
                }
            }

<span class="pc bpc" id="L1097" title="2 of 4 branches missed.">            if (DatabaseDescriptor.getReplaceTokens().size() &gt; 0 || DatabaseDescriptor.getReplaceNode() != null)</span>
<span class="nc" id="L1098">                throw new RuntimeException(&quot;Replace method removed; use &quot; + REPLACE_ADDRESS.getKey() + &quot; system property instead.&quot;);</span>

<span class="fc" id="L1100">            DatabaseDescriptor.getInternodeAuthenticator().setupInternode();</span>
<span class="fc" id="L1101">            MessagingService.instance().listen();</span>

<span class="fc" id="L1103">            UUID localHostId = SystemKeyspace.getOrInitializeLocalHostId();</span>

<span class="pc bpc" id="L1105" title="1 of 2 branches missed.">            if (replacing)</span>
            {
<span class="nc" id="L1107">                localHostId = prepareForReplacement();</span>
<span class="nc" id="L1108">                appStates.put(ApplicationState.TOKENS, valueFactory.tokens(bootstrapTokens));</span>

<span class="nc bnc" id="L1110" title="All 2 branches missed.">                if (!shouldBootstrap())</span>
                {
                    // Will not do replace procedure, persist the tokens we're taking over locally
                    // so that they don't get clobbered with auto generated ones in joinTokenRing
<span class="nc" id="L1114">                    SystemKeyspace.updateTokens(bootstrapTokens);</span>
                }
<span class="nc bnc" id="L1116" title="All 2 branches missed.">                else if (isReplacingSameAddress())</span>
                {
                    //only go into hibernate state if replacing the same address (CASSANDRA-8523)
<span class="nc" id="L1119">                    logger.warn(&quot;Writes will not be forwarded to this node during replacement because it has the same address as &quot; +</span>
                                &quot;the node to be replaced ({}). If the previous node has been down for longer than max_hint_window, &quot; +
                                &quot;repair must be run after the replacement process in order to make this node consistent.&quot;,
<span class="nc" id="L1122">                                DatabaseDescriptor.getReplaceAddress());</span>
<span class="nc" id="L1123">                    appStates.put(ApplicationState.STATUS_WITH_PORT, valueFactory.hibernate(true));</span>
<span class="nc" id="L1124">                    appStates.put(ApplicationState.STATUS, valueFactory.hibernate(true));</span>
                }
            }
            else
            {
<span class="fc" id="L1129">                checkForEndpointCollision(localHostId, SystemKeyspace.loadHostIds().keySet());</span>
<span class="pc bpc" id="L1130" title="1 of 2 branches missed.">                if (SystemKeyspace.bootstrapComplete())</span>
                {
<span class="nc bnc" id="L1132" title="All 2 branches missed.">                    Preconditions.checkState(!Config.isClientMode());</span>
                    // tokens are only ever saved to system.local after bootstrap has completed and we're joining the ring,
                    // or when token update operations (move, decom) are completed
<span class="nc" id="L1135">                    Collection&lt;Token&gt; savedTokens = SystemKeyspace.getSavedTokens();</span>
<span class="nc bnc" id="L1136" title="All 2 branches missed.">                    if (!savedTokens.isEmpty())</span>
<span class="nc" id="L1137">                        appStates.put(ApplicationState.TOKENS, valueFactory.tokens(savedTokens));</span>
                }
            }

            // have to start the gossip service before we can see any info on other nodes.  this is necessary
            // for bootstrap to get the load info it needs.
            // (we won't be part of the storage ring though until we add a counterId to our state, below.)
            // Seed the host ID-to-endpoint map with our own ID.
<span class="fc" id="L1145">            getTokenMetadata().updateHostId(localHostId, FBUtilities.getBroadcastAddressAndPort());</span>
<span class="fc" id="L1146">            appStates.put(ApplicationState.NET_VERSION, valueFactory.networkVersion());</span>
<span class="fc" id="L1147">            appStates.put(ApplicationState.HOST_ID, valueFactory.hostId(localHostId));</span>
<span class="fc" id="L1148">            appStates.put(ApplicationState.NATIVE_ADDRESS_AND_PORT, valueFactory.nativeaddressAndPort(FBUtilities.getBroadcastNativeAddressAndPort()));</span>
<span class="fc" id="L1149">            appStates.put(ApplicationState.RPC_ADDRESS, valueFactory.rpcaddress(FBUtilities.getJustBroadcastNativeAddress()));</span>
<span class="fc" id="L1150">            appStates.put(ApplicationState.RELEASE_VERSION, valueFactory.releaseVersion());</span>
<span class="fc" id="L1151">            appStates.put(ApplicationState.SSTABLE_VERSIONS, valueFactory.sstableVersions(sstablesTracker.versionsInUse()));</span>

<span class="fc" id="L1153">            logger.info(&quot;Starting up server gossip&quot;);</span>
<span class="fc" id="L1154">            Gossiper.instance.register(this);</span>
<span class="fc" id="L1155">            Gossiper.instance.start(SystemKeyspace.incrementAndGetGeneration(), appStates); // needed for node-ring gathering.</span>
<span class="fc" id="L1156">            gossipActive = true;</span>

<span class="fc" id="L1158">            sstablesTracker.register((notification, o) -&gt; {</span>
<span class="pc bpc" id="L1159" title="1 of 2 branches missed.">                if (!(notification instanceof SSTablesVersionsInUseChangeNotification))</span>
<span class="nc" id="L1160">                    return;</span>

<span class="fc" id="L1162">                Set&lt;Version&gt; versions = ((SSTablesVersionsInUseChangeNotification)notification).versionsInUse;</span>
<span class="fc" id="L1163">                logger.debug(&quot;Updating local sstables version in Gossip to {}&quot;, versions);</span>

<span class="fc" id="L1165">                Gossiper.instance.addLocalApplicationState(ApplicationState.SSTABLE_VERSIONS,</span>
<span class="fc" id="L1166">                                                           valueFactory.sstableVersions(versions));</span>
<span class="fc" id="L1167">            });</span>

            // gossip snitch infos (local DC and rack)
<span class="fc" id="L1170">            gossipSnitchInfo();</span>
<span class="fc" id="L1171">            Schema.instance.startSync();</span>
<span class="fc" id="L1172">            LoadBroadcaster.instance.startBroadcasting();</span>
<span class="fc" id="L1173">            DiskUsageBroadcaster.instance.startBroadcasting();</span>
<span class="fc" id="L1174">            HintsService.instance.startDispatch();</span>
<span class="fc" id="L1175">            BatchlogManager.instance.start();</span>
<span class="fc" id="L1176">            startSnapshotManager();</span>
        }
<span class="fc" id="L1178">    }</span>

    @VisibleForTesting
    public void startSnapshotManager()
    {
<span class="fc" id="L1183">        snapshotManager.start();</span>
<span class="fc" id="L1184">    }</span>

    public void waitForSchema(long schemaTimeoutMillis, long ringTimeoutMillis)
    {
<span class="fc" id="L1188">        Instant deadline = FBUtilities.now().plus(java.time.Duration.ofMillis(ringTimeoutMillis));</span>

<span class="pc bpc" id="L1190" title="1 of 4 branches missed.">        while (Schema.instance.isEmpty() &amp;&amp; FBUtilities.now().isBefore(deadline))</span>
<span class="fc" id="L1191">            Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);</span>

<span class="pc bpc" id="L1193" title="1 of 2 branches missed.">        if (!Schema.instance.waitUntilReady(java.time.Duration.ofMillis(schemaTimeoutMillis)))</span>
<span class="nc" id="L1194">            throw new IllegalStateException(&quot;Could not achieve schema readiness in &quot; + java.time.Duration.ofMillis(schemaTimeoutMillis));</span>
<span class="fc" id="L1195">    }</span>

    private void joinTokenRing(long schemaTimeoutMillis, long ringTimeoutMillis) throws ConfigurationException
    {
<span class="pc bpc" id="L1199" title="1 of 2 branches missed.">        joinTokenRing(!isSurveyMode, shouldBootstrap(), schemaTimeoutMillis, INDEFINITE, ringTimeoutMillis);</span>
<span class="fc" id="L1200">    }</span>

    @VisibleForTesting
    public void joinTokenRing(boolean finishJoiningRing,
                              boolean shouldBootstrap,
                              long schemaTimeoutMillis,
                              long bootstrapTimeoutMillis,
                              long ringTimeoutMillis) throws ConfigurationException
    {
<span class="fc" id="L1209">        joined = true;</span>

        // We bootstrap if we haven't successfully bootstrapped before, as long as we are not a seed.
        // If we are a seed, or if the user manually sets auto_bootstrap to false,
        // we'll skip streaming data from other nodes and jump directly into the ring.
        //
        // The seed check allows us to skip the RING_DELAY sleep for the single-node cluster case,
        // which is useful for both new users and testing.
        //
        // We attempted to replace this with a schema-presence check, but you need a meaningful sleep
        // to get schema info from gossip which defeats the purpose.  See CASSANDRA-4427 for the gory details.
<span class="fc" id="L1220">        Set&lt;InetAddressAndPort&gt; current = new HashSet&lt;&gt;();</span>
<span class="pc bpc" id="L1221" title="1 of 2 branches missed.">        if (logger.isDebugEnabled())</span>
        {
<span class="fc" id="L1223">            logger.debug(&quot;Bootstrap variables: {} {} {} {}&quot;,</span>
<span class="fc" id="L1224">                         DatabaseDescriptor.isAutoBootstrap(),</span>
<span class="fc" id="L1225">                         SystemKeyspace.bootstrapInProgress(),</span>
<span class="fc" id="L1226">                         SystemKeyspace.bootstrapComplete(),</span>
<span class="fc" id="L1227">                         DatabaseDescriptor.getSeeds().contains(FBUtilities.getBroadcastAddressAndPort()));</span>
        }
<span class="pc bpc" id="L1229" title="1 of 6 branches missed.">        if (DatabaseDescriptor.isAutoBootstrap() &amp;&amp; !SystemKeyspace.bootstrapComplete() &amp;&amp; DatabaseDescriptor.getSeeds().contains(FBUtilities.getBroadcastAddressAndPort()))</span>
        {
<span class="fc" id="L1231">            logger.info(&quot;This node will not auto bootstrap because it is configured to be a seed node.&quot;);</span>
        }

<span class="fc" id="L1234">        boolean dataAvailable = true; // make this to false when bootstrap streaming failed</span>

<span class="fc bfc" id="L1236" title="All 2 branches covered.">        if (shouldBootstrap)</span>
        {
<span class="fc" id="L1238">            current.addAll(prepareForBootstrap(schemaTimeoutMillis, ringTimeoutMillis));</span>
<span class="nc" id="L1239">            dataAvailable = bootstrap(bootstrapTokens, bootstrapTimeoutMillis);</span>
        }
        else
        {
<span class="fc" id="L1243">            bootstrapTokens = SystemKeyspace.getSavedTokens();</span>
<span class="fc bfc" id="L1244" title="All 2 branches covered.">            if (bootstrapTokens.isEmpty())</span>
            {
<span class="fc" id="L1246">                bootstrapTokens = BootStrapper.getBootstrapTokens(tokenMetadata, FBUtilities.getBroadcastAddressAndPort(), schemaTimeoutMillis, ringTimeoutMillis);</span>
            }
            else
            {
<span class="pc bpc" id="L1250" title="1 of 2 branches missed.">                if (bootstrapTokens.size() != DatabaseDescriptor.getNumTokens())</span>
<span class="nc" id="L1251">                    throw new ConfigurationException(&quot;Cannot change the number of tokens from &quot; + bootstrapTokens.size() + &quot; to &quot; + DatabaseDescriptor.getNumTokens());</span>
                else
<span class="fc" id="L1253">                    logger.info(&quot;Using saved tokens {}&quot;, bootstrapTokens);</span>
            }
        }

<span class="fc" id="L1257">        setUpDistributedSystemKeyspaces();</span>

<span class="pc bpc" id="L1259" title="1 of 2 branches missed.">        if (finishJoiningRing)</span>
        {
<span class="pc bpc" id="L1261" title="1 of 2 branches missed.">            if (dataAvailable)</span>
            {
<span class="fc" id="L1263">                finishJoiningRing(shouldBootstrap, bootstrapTokens);</span>
                // remove the existing info about the replaced node.
<span class="pc bpc" id="L1265" title="1 of 2 branches missed.">                if (!current.isEmpty())</span>
                {
<span class="nc" id="L1267">                    Gossiper.runInGossipStageBlocking(() -&gt; {</span>
<span class="nc bnc" id="L1268" title="All 2 branches missed.">                        for (InetAddressAndPort existing : current)</span>
<span class="nc" id="L1269">                            Gossiper.instance.replacedEndpoint(existing);</span>
<span class="nc" id="L1270">                    });</span>
                }
            }
            else
            {
<span class="nc" id="L1275">                logger.warn(&quot;Some data streaming failed. Use nodetool to check bootstrap state and resume. For more, see `nodetool help bootstrap`. {}&quot;, SystemKeyspace.getBootstrapState());</span>
            }

<span class="fc" id="L1278">            StorageProxy.instance.initialLoadPartitionDenylist();</span>
        }
        else
        {
<span class="nc bnc" id="L1282" title="All 2 branches missed.">            if (dataAvailable)</span>
<span class="nc" id="L1283">                logger.info(&quot;Startup complete, but write survey mode is active, not becoming an active ring member. Use JMX (StorageService-&gt;joinRing()) to finalize ring joining.&quot;);</span>
            else
<span class="nc" id="L1285">                logger.warn(&quot;Some data streaming failed. Use nodetool to check bootstrap state and resume. For more, see `nodetool help bootstrap`. {}&quot;, SystemKeyspace.getBootstrapState());</span>
        }
<span class="fc" id="L1287">    }</span>

    public static boolean isReplacingSameAddress()
    {
<span class="fc" id="L1291">        InetAddressAndPort replaceAddress = DatabaseDescriptor.getReplaceAddress();</span>
<span class="pc bpc" id="L1292" title="1 of 4 branches missed.">        return replaceAddress != null &amp;&amp; replaceAddress.equals(FBUtilities.getBroadcastAddressAndPort());</span>
    }

    public void gossipSnitchInfo()
    {
<span class="fc" id="L1297">        IEndpointSnitch snitch = DatabaseDescriptor.getEndpointSnitch();</span>
<span class="fc" id="L1298">        String dc = snitch.getLocalDatacenter();</span>
<span class="fc" id="L1299">        String rack = snitch.getLocalRack();</span>
<span class="fc" id="L1300">        Gossiper.instance.addLocalApplicationState(ApplicationState.DC, StorageService.instance.valueFactory.datacenter(dc));</span>
<span class="fc" id="L1301">        Gossiper.instance.addLocalApplicationState(ApplicationState.RACK, StorageService.instance.valueFactory.rack(rack));</span>
<span class="fc" id="L1302">    }</span>

    public void joinRing() throws IOException
    {
<span class="fc" id="L1306">        SystemKeyspace.BootstrapState state = SystemKeyspace.getBootstrapState();</span>
<span class="fc" id="L1307">        joinRing(state.equals(SystemKeyspace.BootstrapState.IN_PROGRESS));</span>
<span class="fc" id="L1308">    }</span>

    private synchronized void joinRing(boolean resumedBootstrap) throws IOException
    {
<span class="pc bpc" id="L1312" title="1 of 2 branches missed.">        if (!joined)</span>
        {
<span class="fc" id="L1314">            logger.info(&quot;Joining ring by operator request&quot;);</span>
            try
            {
<span class="fc" id="L1317">                joinTokenRing(SCHEMA_DELAY_MILLIS, 0);</span>
<span class="fc" id="L1318">                doAuthSetup(false);</span>
            }
<span class="nc" id="L1320">            catch (ConfigurationException e)</span>
            {
<span class="nc" id="L1322">                throw new IOException(e.getMessage());</span>
<span class="fc" id="L1323">            }</span>
        }
<span class="nc bnc" id="L1325" title="All 2 branches missed.">        else if (isSurveyMode)</span>
        {
            // if isSurveyMode is on then verify isBootstrapMode
            // node can join the ring even if isBootstrapMode is true which should not happen
<span class="nc bnc" id="L1329" title="All 2 branches missed.">            if (!isBootstrapMode())</span>
            {
<span class="nc" id="L1331">                logger.info(&quot;Leaving write survey mode and joining ring at operator request&quot;);</span>
<span class="nc" id="L1332">                finishJoiningRing(resumedBootstrap, SystemKeyspace.getSavedTokens());</span>
<span class="nc" id="L1333">                doAuthSetup(false);</span>
<span class="nc" id="L1334">                isSurveyMode = false;</span>
<span class="nc" id="L1335">                daemon.start();</span>
            }
            else
            {
<span class="nc" id="L1339">                logger.warn(&quot;Can't join the ring because in write_survey mode and bootstrap hasn't completed&quot;);</span>
            }
        }
<span class="nc bnc" id="L1342" title="All 2 branches missed.">        else if (isBootstrapMode())</span>
        {
            // bootstrap is not complete hence node cannot join the ring
<span class="nc" id="L1345">            logger.warn(&quot;Can't join the ring because bootstrap hasn't completed.&quot;);</span>
        }
<span class="fc" id="L1347">    }</span>

    private void executePreJoinTasks(boolean bootstrap)
    {
<span class="fc" id="L1351">        StreamSupport.stream(ColumnFamilyStore.all().spliterator(), false)</span>
<span class="fc" id="L1352">                .filter(cfs -&gt; Schema.instance.getUserKeyspaces().names().contains(cfs.getKeyspaceName()))</span>
<span class="fc" id="L1353">                .forEach(cfs -&gt; cfs.indexManager.executePreJoinTasksBlocking(bootstrap));</span>
<span class="fc" id="L1354">    }</span>

    @VisibleForTesting
    public void finishJoiningRing(boolean didBootstrap, Collection&lt;Token&gt; tokens)
    {
        // start participating in the ring.
<span class="fc" id="L1360">        setMode(Mode.JOINING, &quot;Finish joining ring&quot;, true);</span>
<span class="fc" id="L1361">        SystemKeyspace.setBootstrapState(SystemKeyspace.BootstrapState.COMPLETED);</span>
<span class="fc" id="L1362">        executePreJoinTasks(didBootstrap);</span>
<span class="fc" id="L1363">        setTokens(tokens);</span>

<span class="pc bpc" id="L1365" title="1 of 2 branches missed.">        assert tokenMetadata.sortedTokens().size() &gt; 0;</span>
<span class="fc" id="L1366">    }</span>

    @VisibleForTesting
    public void doAuthSetup(boolean setUpSchema)
    {
<span class="pc bpc" id="L1371" title="1 of 2 branches missed.">        if (!authSetupCalled.getAndSet(true))</span>
        {
<span class="pc bpc" id="L1373" title="1 of 2 branches missed.">            if (setUpSchema)</span>
            {
<span class="nc" id="L1375">                Schema.instance.transform(SchemaTransformations.updateSystemKeyspace(AuthKeyspace.metadata(), AuthKeyspace.GENERATION));</span>
            }

<span class="fc" id="L1378">            DatabaseDescriptor.getRoleManager().setup();</span>
<span class="fc" id="L1379">            DatabaseDescriptor.getAuthenticator().setup();</span>
<span class="fc" id="L1380">            DatabaseDescriptor.getAuthorizer().setup();</span>
<span class="fc" id="L1381">            DatabaseDescriptor.getNetworkAuthorizer().setup();</span>
<span class="fc" id="L1382">            DatabaseDescriptor.getCIDRAuthorizer().setup();</span>
<span class="fc" id="L1383">            AuthCacheService.initializeAndRegisterCaches();</span>
<span class="fc" id="L1384">            Schema.instance.registerListener(new AuthSchemaChangeListener());</span>
<span class="fc" id="L1385">            authSetupComplete = true;</span>
        }
<span class="fc" id="L1387">    }</span>

    public boolean isAuthSetupComplete()
    {
<span class="nc" id="L1391">        return authSetupComplete;</span>
    }

    @VisibleForTesting
    public boolean authSetupCalled()
    {
<span class="nc" id="L1397">        return authSetupCalled.get();</span>
    }


    @VisibleForTesting
    public void setUpDistributedSystemKeyspaces()
    {
<span class="fc" id="L1404">        Schema.instance.transform(SchemaTransformations.updateSystemKeyspace(TraceKeyspace.metadata(), TraceKeyspace.GENERATION));</span>
<span class="fc" id="L1405">        Schema.instance.transform(SchemaTransformations.updateSystemKeyspace(SystemDistributedKeyspace.metadata(), SystemDistributedKeyspace.GENERATION));</span>
<span class="fc" id="L1406">        Schema.instance.transform(SchemaTransformations.updateSystemKeyspace(AuthKeyspace.metadata(), AuthKeyspace.GENERATION));</span>
<span class="fc" id="L1407">    }</span>

    public boolean isJoined()
    {
<span class="pc bpc" id="L1411" title="1 of 4 branches missed.">        return tokenMetadata.isMember(FBUtilities.getBroadcastAddressAndPort()) &amp;&amp; !isSurveyMode;</span>
    }

    public void rebuild(String sourceDc)
    {
<span class="nc" id="L1416">        rebuild(sourceDc, null, null, null, false);</span>
<span class="nc" id="L1417">    }</span>

    public void rebuild(String sourceDc, String keyspace, String tokens, String specificSources)
    {
<span class="nc" id="L1421">        rebuild(sourceDc, keyspace, tokens, specificSources, false);</span>
<span class="nc" id="L1422">    }</span>

    public void rebuild(String sourceDc, String keyspace, String tokens, String specificSources, boolean excludeLocalDatacenterNodes)
    {
        // fail if source DC is local and --exclude-local-dc is set
<span class="pc bpc" id="L1427" title="1 of 6 branches missed.">        if (sourceDc != null &amp;&amp; sourceDc.equals(DatabaseDescriptor.getLocalDataCenter()) &amp;&amp; excludeLocalDatacenterNodes)</span>
        {
<span class="fc" id="L1429">            throw new IllegalArgumentException(&quot;Cannot set source data center to be local data center, when excludeLocalDataCenter flag is set&quot;);</span>
        }

<span class="pc bpc" id="L1432" title="1 of 2 branches missed.">        if (sourceDc != null)</span>
        {
<span class="fc" id="L1434">            TokenMetadata.Topology topology = getTokenMetadata().cloneOnlyTokenMap().getTopology();</span>
<span class="fc" id="L1435">            Set&lt;String&gt; availableDCs = topology.getDatacenterEndpoints().keySet();</span>
<span class="fc bfc" id="L1436" title="All 2 branches covered.">            if (!availableDCs.contains(sourceDc))</span>
            {
<span class="fc" id="L1438">                throw new IllegalArgumentException(String.format(&quot;Provided datacenter '%s' is not a valid datacenter, available datacenters are: %s&quot;,</span>
<span class="fc" id="L1439">                                                                 sourceDc, String.join(&quot;,&quot;, availableDCs)));</span>
            }
        }

<span class="pc bpc" id="L1443" title="2 of 4 branches missed.">        if (keyspace == null &amp;&amp; tokens != null)</span>
        {
<span class="fc" id="L1445">            throw new IllegalArgumentException(&quot;Cannot specify tokens without keyspace.&quot;);</span>
        }

        // check ongoing rebuild
<span class="nc bnc" id="L1449" title="All 2 branches missed.">        if (!isRebuilding.compareAndSet(false, true))</span>
        {
<span class="nc" id="L1451">            throw new IllegalStateException(&quot;Node is still rebuilding. Check nodetool netstats.&quot;);</span>
        }

        try
        {
<span class="nc bnc" id="L1456" title="All 2 branches missed.">            logger.info(&quot;rebuild from dc: {}, {}, {}&quot;, sourceDc == null ? &quot;(any dc)&quot; : sourceDc,</span>
<span class="nc bnc" id="L1457" title="All 2 branches missed.">                        keyspace == null ? &quot;(All keyspaces)&quot; : keyspace,</span>
<span class="nc bnc" id="L1458" title="All 2 branches missed.">                        tokens == null ? &quot;(All tokens)&quot; : tokens);</span>

<span class="nc" id="L1460">            repairPaxosForTopologyChange(&quot;rebuild&quot;);</span>

<span class="nc" id="L1462">            RangeStreamer streamer = new RangeStreamer(tokenMetadata,</span>
                                                       null,
<span class="nc bnc" id="L1464" title="All 4 branches missed.">                                                       FBUtilities.getBroadcastAddressAndPort(),</span>
                                                       StreamOperation.REBUILD,
                                                       useStrictConsistency &amp;&amp; !replacing,
<span class="nc" id="L1467">                                                       DatabaseDescriptor.getEndpointSnitch(),</span>
                                                       streamStateStore,
                                                       false,
<span class="nc" id="L1470">                                                       DatabaseDescriptor.getStreamingConnectionsPerHost());</span>
<span class="nc bnc" id="L1471" title="All 2 branches missed.">            if (sourceDc != null)</span>
<span class="nc" id="L1472">                streamer.addSourceFilter(new RangeStreamer.SingleDatacenterFilter(DatabaseDescriptor.getEndpointSnitch(), sourceDc));</span>

<span class="nc bnc" id="L1474" title="All 2 branches missed.">            if (excludeLocalDatacenterNodes)</span>
<span class="nc" id="L1475">                streamer.addSourceFilter(new RangeStreamer.ExcludeLocalDatacenterFilter(DatabaseDescriptor.getEndpointSnitch()));</span>

<span class="nc bnc" id="L1477" title="All 2 branches missed.">            if (keyspace == null)</span>
            {
<span class="nc bnc" id="L1479" title="All 2 branches missed.">                for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())</span>
<span class="nc" id="L1480">                    streamer.addRanges(keyspaceName, getLocalReplicas(keyspaceName));</span>
            }
<span class="nc bnc" id="L1482" title="All 2 branches missed.">            else if (tokens == null)</span>
            {
<span class="nc" id="L1484">                streamer.addRanges(keyspace, getLocalReplicas(keyspace));</span>
            }
            else
            {
<span class="nc" id="L1488">                Token.TokenFactory factory = getTokenFactory();</span>
<span class="nc" id="L1489">                List&lt;Range&lt;Token&gt;&gt; ranges = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1490">                Pattern rangePattern = Pattern.compile(&quot;\\(\\s*(-?\\w+)\\s*,\\s*(-?\\w+)\\s*\\]&quot;);</span>
<span class="nc" id="L1491">                try (Scanner tokenScanner = new Scanner(tokens))</span>
                {
<span class="nc bnc" id="L1493" title="All 2 branches missed.">                    while (tokenScanner.findInLine(rangePattern) != null)</span>
                    {
<span class="nc" id="L1495">                        MatchResult range = tokenScanner.match();</span>
<span class="nc" id="L1496">                        Token startToken = factory.fromString(range.group(1));</span>
<span class="nc" id="L1497">                        Token endToken = factory.fromString(range.group(2));</span>
<span class="nc" id="L1498">                        logger.info(&quot;adding range: ({},{}]&quot;, startToken, endToken);</span>
<span class="nc" id="L1499">                        ranges.add(new Range&lt;&gt;(startToken, endToken));</span>
<span class="nc" id="L1500">                    }</span>
<span class="nc bnc" id="L1501" title="All 2 branches missed.">                    if (tokenScanner.hasNext())</span>
<span class="nc" id="L1502">                        throw new IllegalArgumentException(&quot;Unexpected string: &quot; + tokenScanner.next());</span>
                }

                // Ensure all specified ranges are actually ranges owned by this host
<span class="nc" id="L1506">                RangesAtEndpoint localReplicas = getLocalReplicas(keyspace);</span>
<span class="nc" id="L1507">                RangesAtEndpoint.Builder streamRanges = new RangesAtEndpoint.Builder(FBUtilities.getBroadcastAddressAndPort(), ranges.size());</span>
<span class="nc bnc" id="L1508" title="All 2 branches missed.">                for (Range&lt;Token&gt; specifiedRange : ranges)</span>
                {
<span class="nc" id="L1510">                    boolean foundParentRange = false;</span>
<span class="nc bnc" id="L1511" title="All 2 branches missed.">                    for (Replica localReplica : localReplicas)</span>
                    {
<span class="nc bnc" id="L1513" title="All 2 branches missed.">                        if (localReplica.contains(specifiedRange))</span>
                        {
<span class="nc" id="L1515">                            streamRanges.add(localReplica.decorateSubrange(specifiedRange));</span>
<span class="nc" id="L1516">                            foundParentRange = true;</span>
<span class="nc" id="L1517">                            break;</span>
                        }
<span class="nc" id="L1519">                    }</span>
<span class="nc bnc" id="L1520" title="All 2 branches missed.">                    if (!foundParentRange)</span>
                    {
<span class="nc" id="L1522">                        throw new IllegalArgumentException(String.format(&quot;The specified range %s is not a range that is owned by this node. Please ensure that all token ranges specified to be rebuilt belong to this node.&quot;, specifiedRange.toString()));</span>
                    }
<span class="nc" id="L1524">                }</span>

<span class="nc bnc" id="L1526" title="All 2 branches missed.">                if (specificSources != null)</span>
                {
<span class="nc" id="L1528">                    String[] stringHosts = specificSources.split(&quot;,&quot;);</span>
<span class="nc" id="L1529">                    Set&lt;InetAddressAndPort&gt; sources = new HashSet&lt;&gt;(stringHosts.length);</span>
<span class="nc bnc" id="L1530" title="All 2 branches missed.">                    for (String stringHost : stringHosts)</span>
                    {
                        try
                        {
<span class="nc" id="L1534">                            InetAddressAndPort endpoint = InetAddressAndPort.getByName(stringHost);</span>
<span class="nc bnc" id="L1535" title="All 2 branches missed.">                            if (FBUtilities.getBroadcastAddressAndPort().equals(endpoint))</span>
                            {
<span class="nc" id="L1537">                                throw new IllegalArgumentException(&quot;This host was specified as a source for rebuilding. Sources for a rebuild can only be other nodes in the cluster.&quot;);</span>
                            }
<span class="nc" id="L1539">                            sources.add(endpoint);</span>
                        }
<span class="nc" id="L1541">                        catch (UnknownHostException ex)</span>
                        {
<span class="nc" id="L1543">                            throw new IllegalArgumentException(&quot;Unknown host specified &quot; + stringHost, ex);</span>
<span class="nc" id="L1544">                        }</span>
                    }
<span class="nc" id="L1546">                    streamer.addSourceFilter(new RangeStreamer.AllowedSourcesFilter(sources));</span>
                }

<span class="nc" id="L1549">                streamer.addRanges(keyspace, streamRanges.build());</span>
            }

<span class="nc" id="L1552">            StreamResultFuture resultFuture = streamer.fetchAsync();</span>
            // wait for result
<span class="nc" id="L1554">            resultFuture.get();</span>
        }
<span class="nc" id="L1556">        catch (InterruptedException e)</span>
        {
<span class="nc" id="L1558">            throw new UncheckedInterruptedException(e);</span>
        }
<span class="nc" id="L1560">        catch (ExecutionException e)</span>
        {
            // This is used exclusively through JMX, so log the full trace but only throw a simple RTE
<span class="nc" id="L1563">            logger.error(&quot;Error while rebuilding node&quot;, e.getCause());</span>
<span class="nc" id="L1564">            throw new RuntimeException(&quot;Error while rebuilding node: &quot; + e.getCause().getMessage());</span>
        }
        finally
        {
            // rebuild is done (successfully or not)
<span class="nc" id="L1569">            isRebuilding.set(false);</span>
        }
<span class="nc" id="L1571">    }</span>

    public void setRpcTimeout(long value)
    {
<span class="nc" id="L1575">        DatabaseDescriptor.setRpcTimeout(value);</span>
<span class="nc" id="L1576">        logger.info(&quot;set rpc timeout to {} ms&quot;, value);</span>
<span class="nc" id="L1577">    }</span>

    public long getRpcTimeout()
    {
<span class="nc" id="L1581">        return DatabaseDescriptor.getRpcTimeout(MILLISECONDS);</span>
    }

    public void setReadRpcTimeout(long value)
    {
<span class="nc" id="L1586">        DatabaseDescriptor.setReadRpcTimeout(value);</span>
<span class="nc" id="L1587">        logger.info(&quot;set read rpc timeout to {} ms&quot;, value);</span>
<span class="nc" id="L1588">    }</span>

    public long getReadRpcTimeout()
    {
<span class="nc" id="L1592">        return DatabaseDescriptor.getReadRpcTimeout(MILLISECONDS);</span>
    }

    public void setRangeRpcTimeout(long value)
    {
<span class="nc" id="L1597">        DatabaseDescriptor.setRangeRpcTimeout(value);</span>
<span class="nc" id="L1598">        logger.info(&quot;set range rpc timeout to {} ms&quot;, value);</span>
<span class="nc" id="L1599">    }</span>

    public long getRangeRpcTimeout()
    {
<span class="nc" id="L1603">        return DatabaseDescriptor.getRangeRpcTimeout(MILLISECONDS);</span>
    }

    public void setWriteRpcTimeout(long value)
    {
<span class="nc" id="L1608">        DatabaseDescriptor.setWriteRpcTimeout(value);</span>
<span class="nc" id="L1609">        logger.info(&quot;set write rpc timeout to {} ms&quot;, value);</span>
<span class="nc" id="L1610">    }</span>

    public long getWriteRpcTimeout()
    {
<span class="nc" id="L1614">        return DatabaseDescriptor.getWriteRpcTimeout(MILLISECONDS);</span>
    }

    public void setInternodeTcpConnectTimeoutInMS(int value)
    {
<span class="nc" id="L1619">        DatabaseDescriptor.setInternodeTcpConnectTimeoutInMS(value);</span>
<span class="nc" id="L1620">        logger.info(&quot;set internode tcp connect timeout to {} ms&quot;, value);</span>
<span class="nc" id="L1621">    }</span>

    public int getInternodeTcpConnectTimeoutInMS()
    {
<span class="nc" id="L1625">        return DatabaseDescriptor.getInternodeTcpConnectTimeoutInMS();</span>
    }

    public void setInternodeTcpUserTimeoutInMS(int value)
    {
<span class="nc" id="L1630">        DatabaseDescriptor.setInternodeTcpUserTimeoutInMS(value);</span>
<span class="nc" id="L1631">        logger.info(&quot;set internode tcp user timeout to {} ms&quot;, value);</span>
<span class="nc" id="L1632">    }</span>

    public int getInternodeTcpUserTimeoutInMS()
    {
<span class="nc" id="L1636">        return DatabaseDescriptor.getInternodeTcpUserTimeoutInMS();</span>
    }

    public void setInternodeStreamingTcpUserTimeoutInMS(int value)
    {
<span class="nc bnc" id="L1641" title="All 2 branches missed.">        Preconditions.checkArgument(value &gt;= 0, &quot;TCP user timeout cannot be negative for internode streaming connection. Got %s&quot;, value);</span>
<span class="nc" id="L1642">        DatabaseDescriptor.setInternodeStreamingTcpUserTimeoutInMS(value);</span>
<span class="nc" id="L1643">        logger.info(&quot;set internode streaming tcp user timeout to {} ms&quot;, value);</span>
<span class="nc" id="L1644">    }</span>

    public int getInternodeStreamingTcpUserTimeoutInMS()
    {
<span class="nc" id="L1648">        return DatabaseDescriptor.getInternodeStreamingTcpUserTimeoutInMS();</span>
    }

    public void setCounterWriteRpcTimeout(long value)
    {
<span class="nc" id="L1653">        DatabaseDescriptor.setCounterWriteRpcTimeout(value);</span>
<span class="nc" id="L1654">        logger.info(&quot;set counter write rpc timeout to {} ms&quot;, value);</span>
<span class="nc" id="L1655">    }</span>

    public long getCounterWriteRpcTimeout()
    {
<span class="nc" id="L1659">        return DatabaseDescriptor.getCounterWriteRpcTimeout(MILLISECONDS);</span>
    }

    public void setCasContentionTimeout(long value)
    {
<span class="nc" id="L1664">        DatabaseDescriptor.setCasContentionTimeout(value);</span>
<span class="nc" id="L1665">        logger.info(&quot;set cas contention rpc timeout to {} ms&quot;, value);</span>
<span class="nc" id="L1666">    }</span>

    public long getCasContentionTimeout()
    {
<span class="nc" id="L1670">        return DatabaseDescriptor.getCasContentionTimeout(MILLISECONDS);</span>
    }

    public void setTruncateRpcTimeout(long value)
    {
<span class="nc" id="L1675">        DatabaseDescriptor.setTruncateRpcTimeout(value);</span>
<span class="nc" id="L1676">        logger.info(&quot;set truncate rpc timeout to {} ms&quot;, value);</span>
<span class="nc" id="L1677">    }</span>

    public long getTruncateRpcTimeout()
    {
<span class="nc" id="L1681">        return DatabaseDescriptor.getTruncateRpcTimeout(MILLISECONDS);</span>
    }

    @Deprecated
    public void setStreamThroughputMbPerSec(int value)
    {
<span class="nc" id="L1687">        setStreamThroughputMbitPerSec(value);</span>
<span class="nc" id="L1688">    }</span>

    public void setStreamThroughputMbitPerSec(int value)
    {
<span class="fc" id="L1692">        double oldValue = DatabaseDescriptor.getStreamThroughputOutboundMegabitsPerSecAsDouble();</span>
<span class="fc" id="L1693">        DatabaseDescriptor.setStreamThroughputOutboundMegabitsPerSec(value);</span>
<span class="fc" id="L1694">        StreamManager.StreamRateLimiter.updateThroughput();</span>
<span class="fc" id="L1695">        logger.info(&quot;setstreamthroughput: throttle set to {}{} megabits per second (was approximately {} megabits per second)&quot;,</span>
<span class="fc bfc" id="L1696" title="All 2 branches covered.">                    value, value &lt;= 0 ? &quot; (unlimited)&quot; : &quot;&quot;, oldValue);</span>
<span class="fc" id="L1697">    }</span>

    public void setStreamThroughputMebibytesPerSec(int value)
    {
<span class="fc" id="L1701">        double oldValue = DatabaseDescriptor.getStreamThroughputOutboundMebibytesPerSec();</span>
<span class="fc" id="L1702">        DatabaseDescriptor.setStreamThroughputOutboundMebibytesPerSecAsInt(value);</span>
<span class="fc" id="L1703">        StreamManager.StreamRateLimiter.updateThroughput();</span>
<span class="fc bfc" id="L1704" title="All 2 branches covered.">        logger.info(&quot;setstreamthroughput: throttle set to {}{} MiB/s (was {} MiB/s)&quot;, value, value &lt;= 0 ? &quot; (unlimited)&quot; : &quot;&quot;, oldValue);</span>
<span class="fc" id="L1705">    }</span>

    public double getStreamThroughputMebibytesPerSecAsDouble()
    {
<span class="fc" id="L1709">        return DatabaseDescriptor.getStreamThroughputOutboundMebibytesPerSec();</span>
    }

    public int getStreamThroughputMebibytesPerSec()
    {
<span class="nc" id="L1714">        return DatabaseDescriptor.getStreamThroughputOutboundMebibytesPerSecAsInt();</span>
    }

    @Deprecated
    public int getStreamThroughputMbPerSec()
    {
<span class="nc" id="L1720">        return getStreamThroughputMbitPerSec();</span>
    }

    @Deprecated
    public int getStreamThroughputMbitPerSec()
    {
<span class="fc" id="L1726">        return DatabaseDescriptor.getStreamThroughputOutboundMegabitsPerSec();</span>
    }

    public double getStreamThroughputMbitPerSecAsDouble()
    {
<span class="fc" id="L1731">        return DatabaseDescriptor.getStreamThroughputOutboundMegabitsPerSecAsDouble();</span>
    }

    public void setEntireSSTableStreamThroughputMebibytesPerSec(int value)
    {
<span class="fc" id="L1736">        double oldValue = DatabaseDescriptor.getEntireSSTableStreamThroughputOutboundMebibytesPerSec();</span>
<span class="fc" id="L1737">        DatabaseDescriptor.setEntireSSTableStreamThroughputOutboundMebibytesPerSec(value);</span>
<span class="fc" id="L1738">        StreamManager.StreamRateLimiter.updateEntireSSTableThroughput();</span>
<span class="fc" id="L1739">        logger.info(&quot;setstreamthroughput (entire SSTable): throttle set to {}{} MiB/s (was {} MiB/s)&quot;,</span>
<span class="fc bfc" id="L1740" title="All 2 branches covered.">                    value, value &lt;= 0 ? &quot; (unlimited)&quot; : &quot;&quot;, oldValue);</span>
<span class="fc" id="L1741">    }</span>

    public double getEntireSSTableStreamThroughputMebibytesPerSecAsDouble()
    {
<span class="fc" id="L1745">        return DatabaseDescriptor.getEntireSSTableStreamThroughputOutboundMebibytesPerSec();</span>
    }

    @Deprecated
    public void setInterDCStreamThroughputMbPerSec(int value)
    {
<span class="nc" id="L1751">        setInterDCStreamThroughputMbitPerSec(value);</span>
<span class="nc" id="L1752">    }</span>

    public void setInterDCStreamThroughputMbitPerSec(int value)
    {
<span class="fc" id="L1756">        double oldValue = DatabaseDescriptor.getInterDCStreamThroughputOutboundMegabitsPerSecAsDouble();</span>
<span class="fc" id="L1757">        DatabaseDescriptor.setInterDCStreamThroughputOutboundMegabitsPerSec(value);</span>
<span class="fc" id="L1758">        StreamManager.StreamRateLimiter.updateInterDCThroughput();</span>
<span class="fc bfc" id="L1759" title="All 2 branches covered.">        logger.info(&quot;setinterdcstreamthroughput: throttle set to {}{} megabits per second (was {} megabits per second)&quot;, value, value &lt;= 0 ? &quot; (unlimited)&quot; : &quot;&quot;, oldValue);</span>
<span class="fc" id="L1760">    }</span>

    @Deprecated
    public int getInterDCStreamThroughputMbPerSec()
    {
<span class="nc" id="L1765">        return getInterDCStreamThroughputMbitPerSec();</span>
    }

    @Deprecated
    public int getInterDCStreamThroughputMbitPerSec()
    {
<span class="fc" id="L1771">        return DatabaseDescriptor.getInterDCStreamThroughputOutboundMegabitsPerSec();</span>
    }

    public double getInterDCStreamThroughputMbitPerSecAsDouble()
    {
<span class="fc" id="L1776">        return DatabaseDescriptor.getInterDCStreamThroughputOutboundMegabitsPerSecAsDouble();</span>
    }

    public void setInterDCStreamThroughputMebibytesPerSec(int value)
    {
<span class="fc" id="L1781">        double oldValue = DatabaseDescriptor.getInterDCStreamThroughputOutboundMebibytesPerSec();</span>
<span class="fc" id="L1782">        DatabaseDescriptor.setInterDCStreamThroughputOutboundMebibytesPerSecAsInt(value);</span>
<span class="fc" id="L1783">        StreamManager.StreamRateLimiter.updateInterDCThroughput();</span>
<span class="fc bfc" id="L1784" title="All 2 branches covered.">        logger.info(&quot;setinterdcstreamthroughput: throttle set to {}{} MiB/s (was {} MiB/s)&quot;, value, value &lt;= 0 ? &quot; (unlimited)&quot; : &quot;&quot;, oldValue);</span>
<span class="fc" id="L1785">    }</span>

    public int getInterDCStreamThroughputMebibytesPerSec()
    {
<span class="nc" id="L1789">        return DatabaseDescriptor.getInterDCStreamThroughputOutboundMebibytesPerSecAsInt();</span>
    }

    public double getInterDCStreamThroughputMebibytesPerSecAsDouble()
    {
<span class="fc" id="L1794">        return DatabaseDescriptor.getInterDCStreamThroughputOutboundMebibytesPerSec();</span>
    }

    public void setEntireSSTableInterDCStreamThroughputMebibytesPerSec(int value)
    {
<span class="fc" id="L1799">        double oldValue = DatabaseDescriptor.getEntireSSTableInterDCStreamThroughputOutboundMebibytesPerSec();</span>
<span class="fc" id="L1800">        DatabaseDescriptor.setEntireSSTableInterDCStreamThroughputOutboundMebibytesPerSec(value);</span>
<span class="fc" id="L1801">        StreamManager.StreamRateLimiter.updateEntireSSTableInterDCThroughput();</span>
<span class="fc bfc" id="L1802" title="All 2 branches covered.">        logger.info(&quot;setinterdcstreamthroughput (entire SSTable): throttle set to {}{} MiB/s (was {} MiB/s)&quot;, value, value &lt;= 0 ? &quot; (unlimited)&quot; : &quot;&quot;, oldValue);</span>
<span class="fc" id="L1803">    }</span>

    public double getEntireSSTableInterDCStreamThroughputMebibytesPerSecAsDouble()
    {
<span class="fc" id="L1807">        return DatabaseDescriptor.getEntireSSTableInterDCStreamThroughputOutboundMebibytesPerSec();</span>
    }

    public double getCompactionThroughtputMibPerSecAsDouble()
    {
<span class="fc" id="L1812">        return DatabaseDescriptor.getCompactionThroughputMebibytesPerSec();</span>
    }

    public long getCompactionThroughtputBytesPerSec()
    {
<span class="fc" id="L1817">        return (long)DatabaseDescriptor.getCompactionThroughputBytesPerSec();</span>
    }

    @Deprecated
    public int getCompactionThroughputMbPerSec()
    {
<span class="fc" id="L1823">        return DatabaseDescriptor.getCompactionThroughputMebibytesPerSecAsInt();</span>
    }

    public void setCompactionThroughputMbPerSec(int value)
    {
<span class="fc" id="L1828">        double oldValue = DatabaseDescriptor.getCompactionThroughputMebibytesPerSec();</span>
<span class="fc" id="L1829">        DatabaseDescriptor.setCompactionThroughputMebibytesPerSec(value);</span>
<span class="fc" id="L1830">        double valueInBytes = value * 1024.0 * 1024.0;</span>
<span class="fc" id="L1831">        CompactionManager.instance.setRateInBytes(valueInBytes);</span>
<span class="fc" id="L1832">        logger.info(&quot;compactionthroughput: throttle set to {} mebibytes per second (was {} mebibytes per second)&quot;,</span>
<span class="fc" id="L1833">                    value, oldValue);</span>
<span class="fc" id="L1834">    }</span>

    public int getBatchlogReplayThrottleInKB()
    {
<span class="nc" id="L1838">        return DatabaseDescriptor.getBatchlogReplayThrottleInKiB();</span>
    }

    public void setBatchlogReplayThrottleInKB(int throttleInKB)
    {
<span class="nc" id="L1843">        DatabaseDescriptor.setBatchlogReplayThrottleInKiB(throttleInKB);</span>
<span class="nc" id="L1844">        BatchlogManager.instance.setRate(throttleInKB);</span>
<span class="nc" id="L1845">    }</span>

    public int getConcurrentCompactors()
    {
<span class="fc" id="L1849">        return DatabaseDescriptor.getConcurrentCompactors();</span>
    }

    public void setConcurrentCompactors(int value)
    {
<span class="pc bpc" id="L1854" title="1 of 2 branches missed.">        if (value &lt;= 0)</span>
<span class="nc" id="L1855">            throw new IllegalArgumentException(&quot;Number of concurrent compactors should be greater than 0.&quot;);</span>
<span class="fc" id="L1856">        DatabaseDescriptor.setConcurrentCompactors(value);</span>
<span class="fc" id="L1857">        CompactionManager.instance.setConcurrentCompactors(value);</span>
<span class="fc" id="L1858">    }</span>

    public void bypassConcurrentValidatorsLimit()
    {
<span class="nc" id="L1862">        logger.info(&quot;Enabling the ability to set concurrent validations to an unlimited value&quot;);</span>
<span class="nc" id="L1863">        DatabaseDescriptor.allowUnlimitedConcurrentValidations = true ;</span>
<span class="nc" id="L1864">    }</span>

    public void enforceConcurrentValidatorsLimit()
    {
<span class="nc" id="L1868">        logger.info(&quot;Disabling the ability to set concurrent validations to an unlimited value&quot;);</span>
<span class="nc" id="L1869">        DatabaseDescriptor.allowUnlimitedConcurrentValidations = false ;</span>
<span class="nc" id="L1870">    }</span>

    public boolean isConcurrentValidatorsLimitEnforced()
    {
<span class="nc" id="L1874">        return DatabaseDescriptor.allowUnlimitedConcurrentValidations;</span>
    }

    public int getConcurrentValidators()
    {
<span class="nc" id="L1879">        return DatabaseDescriptor.getConcurrentValidations();</span>
    }

    public void setConcurrentValidators(int value)
    {
<span class="nc" id="L1884">        int concurrentCompactors = DatabaseDescriptor.getConcurrentCompactors();</span>
<span class="nc bnc" id="L1885" title="All 4 branches missed.">        if (value &gt; concurrentCompactors &amp;&amp; !DatabaseDescriptor.allowUnlimitedConcurrentValidations)</span>
<span class="nc" id="L1886">            throw new IllegalArgumentException(</span>
<span class="nc" id="L1887">            String.format(&quot;Cannot set concurrent_validations greater than concurrent_compactors (%d)&quot;,</span>
<span class="nc" id="L1888">                          concurrentCompactors));</span>

<span class="nc bnc" id="L1890" title="All 2 branches missed.">        if (value &lt;= 0)</span>
        {
<span class="nc" id="L1892">            logger.info(&quot;Using default value of concurrent_compactors ({}) for concurrent_validations&quot;, concurrentCompactors);</span>
<span class="nc" id="L1893">            value = concurrentCompactors;</span>
        }
        else
        {
<span class="nc" id="L1897">            logger.info(&quot;Setting concurrent_validations to {}&quot;, value);</span>
        }

<span class="nc" id="L1900">        DatabaseDescriptor.setConcurrentValidations(value);</span>
<span class="nc" id="L1901">        CompactionManager.instance.setConcurrentValidations();</span>
<span class="nc" id="L1902">    }</span>

    public int getConcurrentViewBuilders()
    {
<span class="nc" id="L1906">        return DatabaseDescriptor.getConcurrentViewBuilders();</span>
    }

    public void setConcurrentViewBuilders(int value)
    {
<span class="nc bnc" id="L1911" title="All 2 branches missed.">        if (value &lt;= 0)</span>
<span class="nc" id="L1912">            throw new IllegalArgumentException(&quot;Number of concurrent view builders should be greater than 0.&quot;);</span>
<span class="nc" id="L1913">        DatabaseDescriptor.setConcurrentViewBuilders(value);</span>
<span class="nc" id="L1914">        CompactionManager.instance.setConcurrentViewBuilders(DatabaseDescriptor.getConcurrentViewBuilders());</span>
<span class="nc" id="L1915">    }</span>

    public boolean isIncrementalBackupsEnabled()
    {
<span class="nc" id="L1919">        return DatabaseDescriptor.isIncrementalBackupsEnabled();</span>
    }

    public void setIncrementalBackupsEnabled(boolean value)
    {
<span class="nc" id="L1924">        DatabaseDescriptor.setIncrementalBackupsEnabled(value);</span>
<span class="nc" id="L1925">    }</span>

    @VisibleForTesting // only used by test
    public void setMovingModeUnsafe()
    {
<span class="nc" id="L1930">        setMode(Mode.MOVING, true);</span>
<span class="nc" id="L1931">    }</span>

    /**
     * Only used in jvm dtest when not using GOSSIP.
     * See org.apache.cassandra.distributed.impl.Instance#startup(org.apache.cassandra.distributed.api.ICluster)
     */
    @VisibleForTesting
    public void setNormalModeUnsafe()
    {
<span class="nc" id="L1940">        setMode(Mode.NORMAL, true);</span>
<span class="nc" id="L1941">    }</span>

    private void setMode(Mode m, boolean log)
    {
<span class="fc" id="L1945">        setMode(m, null, log);</span>
<span class="fc" id="L1946">    }</span>

    private void setMode(Mode m, String msg, boolean log)
    {
<span class="fc" id="L1950">        operationMode = m;</span>
<span class="fc bfc" id="L1951" title="All 2 branches covered.">        String logMsg = msg == null ? m.toString() : String.format(&quot;%s: %s&quot;, m, msg);</span>
<span class="fc bfc" id="L1952" title="All 2 branches covered.">        if (log)</span>
<span class="fc" id="L1953">            logger.info(logMsg);</span>
        else
<span class="fc" id="L1955">            logger.debug(logMsg);</span>
<span class="fc" id="L1956">    }</span>

    @VisibleForTesting
    public Collection&lt;InetAddressAndPort&gt; prepareForBootstrap(long schemaTimeoutMillis, long ringTimeoutMillis)
    {
<span class="fc" id="L1961">        Set&lt;InetAddressAndPort&gt; collisions = new HashSet&lt;&gt;();</span>
<span class="pc bpc" id="L1962" title="1 of 2 branches missed.">        if (SystemKeyspace.bootstrapInProgress())</span>
<span class="nc" id="L1963">            logger.warn(&quot;Detected previous bootstrap failure; retrying&quot;);</span>
        else
<span class="fc" id="L1965">            SystemKeyspace.setBootstrapState(SystemKeyspace.BootstrapState.IN_PROGRESS);</span>
<span class="fc" id="L1966">        setMode(Mode.JOINING, &quot;waiting for ring information&quot;, true);</span>
<span class="fc" id="L1967">        waitForSchema(schemaTimeoutMillis, ringTimeoutMillis);</span>
<span class="fc" id="L1968">        setMode(Mode.JOINING, &quot;schema complete, ready to bootstrap&quot;, true);</span>
<span class="fc" id="L1969">        setMode(Mode.JOINING, &quot;waiting for pending range calculation&quot;, true);</span>
<span class="fc" id="L1970">        PendingRangeCalculatorService.instance.blockUntilFinished();</span>
<span class="fc" id="L1971">        setMode(Mode.JOINING, &quot;calculation complete, ready to bootstrap&quot;, true);</span>

<span class="fc" id="L1973">        logger.debug(&quot;... got ring + schema info&quot;);</span>

<span class="pc bpc" id="L1975" title="2 of 4 branches missed.">        if (useStrictConsistency &amp;&amp; !allowSimultaneousMoves() &amp;&amp;</span>
            (
<span class="pc bpc" id="L1977" title="1 of 2 branches missed.">            tokenMetadata.getBootstrapTokens().valueSet().size() &gt; 0 ||</span>
<span class="pc bpc" id="L1978" title="1 of 2 branches missed.">            tokenMetadata.getSizeOfLeavingEndpoints() &gt; 0 ||</span>
<span class="pc bpc" id="L1979" title="1 of 2 branches missed.">            tokenMetadata.getSizeOfMovingEndpoints() &gt; 0</span>
            ))
        {
<span class="nc" id="L1982">            String bootstrapTokens = StringUtils.join(tokenMetadata.getBootstrapTokens().valueSet(), ',');</span>
<span class="nc" id="L1983">            String leavingTokens = StringUtils.join(tokenMetadata.getLeavingEndpoints(), ',');</span>
<span class="nc" id="L1984">            String movingTokens = StringUtils.join(tokenMetadata.getMovingEndpoints().stream().map(e -&gt; e.right).toArray(), ',');</span>
<span class="nc" id="L1985">            throw new UnsupportedOperationException(String.format(&quot;Other bootstrapping/leaving/moving nodes detected, cannot bootstrap while %s is true. Nodes detected, bootstrapping: %s; leaving: %s; moving: %s;&quot;,</span>
<span class="nc" id="L1986">                                                                  CONSISTENT_RANGE_MOVEMENT.getKey(), bootstrapTokens, leavingTokens, movingTokens));</span>
        }

        // get bootstrap tokens
<span class="pc bpc" id="L1990" title="1 of 2 branches missed.">        if (!replacing)</span>
        {
<span class="pc bpc" id="L1992" title="1 of 2 branches missed.">            if (tokenMetadata.isMember(FBUtilities.getBroadcastAddressAndPort()))</span>
            {
<span class="nc" id="L1994">                String s = &quot;This node is already a member of the token ring; bootstrap aborted. (If replacing a dead node, remove the old one from the ring first.)&quot;;</span>
<span class="nc" id="L1995">                throw new UnsupportedOperationException(s);</span>
            }
<span class="fc" id="L1997">            setMode(Mode.JOINING, &quot;getting bootstrap token&quot;, true);</span>
<span class="fc" id="L1998">            bootstrapTokens = BootStrapper.getBootstrapTokens(tokenMetadata, FBUtilities.getBroadcastAddressAndPort(), schemaTimeoutMillis, ringTimeoutMillis);</span>
        }
        else
        {
<span class="nc bnc" id="L2002" title="All 2 branches missed.">            if (!isReplacingSameAddress())</span>
            {
                // Historically BROADCAST_INTERVAL was used, but this is unrelated to ring_delay, so using it to know
                // how long to sleep only works with the default settings (ring_delay=30s, broadcast=60s).  For users
                // who are aware of this relationship, this coupling should not be broken, but for most users this
                // relationship isn't known and instead we should rely on the ring_delay.
                // See CASSANDRA-17776
<span class="nc" id="L2009">                long sleepDelayMillis = Math.max(LoadBroadcaster.BROADCAST_INTERVAL, ringTimeoutMillis * 2);</span>
                try
                {
                    // Sleep additionally to make sure that the server actually is not alive
                    // and giving it more time to gossip if alive.
<span class="nc" id="L2014">                    logger.info(&quot;Sleeping for {}ms waiting to make sure no new gossip updates happen for {}&quot;, sleepDelayMillis, DatabaseDescriptor.getReplaceAddress());</span>
<span class="nc" id="L2015">                    Thread.sleep(sleepDelayMillis);</span>
                }
<span class="nc" id="L2017">                catch (InterruptedException e)</span>
                {
<span class="nc" id="L2019">                    throw new UncheckedInterruptedException(e);</span>
<span class="nc" id="L2020">                }</span>

                // check for operator errors...
<span class="nc" id="L2023">                long nanoDelay = MILLISECONDS.toNanos(ringTimeoutMillis);</span>
<span class="nc bnc" id="L2024" title="All 2 branches missed.">                for (Token token : bootstrapTokens)</span>
                {
<span class="nc" id="L2026">                    InetAddressAndPort existing = tokenMetadata.getEndpoint(token);</span>
<span class="nc bnc" id="L2027" title="All 2 branches missed.">                    if (existing != null)</span>
                    {
<span class="nc" id="L2029">                        EndpointState endpointStateForExisting = Gossiper.instance.getEndpointStateForEndpoint(existing);</span>
<span class="nc" id="L2030">                        long updateTimestamp = endpointStateForExisting.getUpdateTimestamp();</span>
<span class="nc" id="L2031">                        long allowedDelay = nanoTime() - nanoDelay;</span>

                        // if the node was updated within the ring delay or the node is alive, we should fail
<span class="nc bnc" id="L2034" title="All 4 branches missed.">                        if (updateTimestamp &gt; allowedDelay || endpointStateForExisting.isAlive())</span>
                        {
<span class="nc" id="L2036">                            logger.error(&quot;Unable to replace node for token={}. The node is reporting as {}alive with updateTimestamp={}, allowedDelay={}&quot;,</span>
<span class="nc bnc" id="L2037" title="All 2 branches missed.">                                         token, endpointStateForExisting.isAlive() ? &quot;&quot; : &quot;not &quot;, updateTimestamp, allowedDelay);</span>
<span class="nc" id="L2038">                            throw new UnsupportedOperationException(&quot;Cannot replace a live node... &quot;);</span>
                        }
<span class="nc" id="L2040">                        collisions.add(existing);</span>
<span class="nc" id="L2041">                    }</span>
                    else
                    {
<span class="nc" id="L2044">                        throw new UnsupportedOperationException(&quot;Cannot replace token &quot; + token + &quot; which does not exist!&quot;);</span>
                    }
<span class="nc" id="L2046">                }</span>
<span class="nc" id="L2047">            }</span>
            else
            {
                try
                {
<span class="nc" id="L2052">                    Thread.sleep(RING_DELAY_MILLIS);</span>
                }
<span class="nc" id="L2054">                catch (InterruptedException e)</span>
                {
<span class="nc" id="L2056">                    throw new UncheckedInterruptedException(e);</span>
<span class="nc" id="L2057">                }</span>

            }
<span class="nc" id="L2060">            setMode(Mode.JOINING, &quot;Replacing a node with token(s): &quot; + bootstrapTokens, true);</span>
        }
<span class="fc" id="L2062">        return collisions;</span>
    }

    /**
     * Bootstrap node by fetching data from other nodes.
     * If node is bootstrapping as a new node, then this also announces bootstrapping to the cluster.
     *
     * This blocks until streaming is done.
     *
     * @param tokens bootstrapping tokens
     * @return true if bootstrap succeeds.
     */
    @VisibleForTesting
    public boolean bootstrap(final Collection&lt;Token&gt; tokens, long bootstrapTimeoutMillis)
    {
<span class="fc" id="L2077">        isBootstrapMode = true;</span>
<span class="fc" id="L2078">        SystemKeyspace.updateTokens(tokens); // DON'T use setToken, that makes us part of the ring locally which is incorrect until we are done bootstrapping</span>

<span class="pc bpc" id="L2080" title="3 of 4 branches missed.">        if (!replacing || !isReplacingSameAddress())</span>
        {
            // if not an existing token then bootstrap
<span class="fc" id="L2083">            List&lt;Pair&lt;ApplicationState, VersionedValue&gt;&gt; states = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2084">            states.add(Pair.create(ApplicationState.TOKENS, valueFactory.tokens(tokens)));</span>
<span class="pc bpc" id="L2085" title="1 of 2 branches missed.">            states.add(Pair.create(ApplicationState.STATUS_WITH_PORT, replacing?</span>
<span class="nc" id="L2086">                                                            valueFactory.bootReplacingWithPort(DatabaseDescriptor.getReplaceAddress()) :</span>
<span class="fc" id="L2087">                                                            valueFactory.bootstrapping(tokens)));</span>
<span class="pc bpc" id="L2088" title="1 of 2 branches missed.">            states.add(Pair.create(ApplicationState.STATUS, replacing ?</span>
<span class="nc" id="L2089">                                                            valueFactory.bootReplacing(DatabaseDescriptor.getReplaceAddress().getAddress()) :</span>
<span class="fc" id="L2090">                                                            valueFactory.bootstrapping(tokens)));</span>
<span class="fc" id="L2091">            Gossiper.instance.addLocalApplicationStates(states);</span>
<span class="fc" id="L2092">            setMode(Mode.JOINING, &quot;sleeping &quot; + RING_DELAY_MILLIS + &quot; ms for pending range setup&quot;, true);</span>
<span class="fc" id="L2093">            Uninterruptibles.sleepUninterruptibly(RING_DELAY_MILLIS, MILLISECONDS);</span>
<span class="fc" id="L2094">        }</span>
        else
        {
            // Dont set any state for the node which is bootstrapping the existing token...
<span class="nc" id="L2098">            tokenMetadata.updateNormalTokens(tokens, FBUtilities.getBroadcastAddressAndPort());</span>
<span class="nc" id="L2099">            SystemKeyspace.removeEndpoint(DatabaseDescriptor.getReplaceAddress());</span>
        }
<span class="pc bpc" id="L2101" title="1 of 2 branches missed.">        if (!Gossiper.instance.seenAnySeed())</span>
<span class="fc" id="L2102">            throw new IllegalStateException(&quot;Unable to contact any seeds: &quot; + Gossiper.instance.getSeeds());</span>

<span class="nc bnc" id="L2104" title="All 2 branches missed.">        if (RESET_BOOTSTRAP_PROGRESS.getBoolean())</span>
        {
<span class="nc" id="L2106">            logger.info(&quot;Resetting bootstrap progress to start fresh&quot;);</span>
<span class="nc" id="L2107">            SystemKeyspace.resetAvailableStreamedRanges();</span>
        }

        // Force disk boundary invalidation now that local tokens are set
<span class="nc" id="L2111">        invalidateLocalRanges();</span>
<span class="nc" id="L2112">        repairPaxosForTopologyChange(&quot;bootstrap&quot;);</span>

<span class="nc" id="L2114">        Future&lt;StreamState&gt; bootstrapStream = startBootstrap(tokens);</span>
        try
        {
<span class="nc bnc" id="L2117" title="All 2 branches missed.">            if (bootstrapTimeoutMillis &gt; 0)</span>
<span class="nc" id="L2118">                bootstrapStream.get(bootstrapTimeoutMillis, MILLISECONDS);</span>
            else
<span class="nc" id="L2120">                bootstrapStream.get();</span>
<span class="nc" id="L2121">            bootstrapFinished();</span>
<span class="nc" id="L2122">            logger.info(&quot;Bootstrap completed for tokens {}&quot;, tokens);</span>
<span class="nc" id="L2123">            return true;</span>
        }
<span class="nc" id="L2125">        catch (Throwable e)</span>
        {
<span class="nc" id="L2127">            logger.error(&quot;Error while waiting on bootstrap to complete. Bootstrap will have to be restarted.&quot;, e);</span>
<span class="nc" id="L2128">            setMode(JOINING_FAILED, true);</span>
<span class="nc" id="L2129">            return false;</span>
        }
    }

    public Future&lt;StreamState&gt; startBootstrap(Collection&lt;Token&gt; tokens)
    {
<span class="nc" id="L2135">        return startBootstrap(tokens, replacing);</span>
    }

    public Future&lt;StreamState&gt; startBootstrap(Collection&lt;Token&gt; tokens, boolean replacing)
    {
<span class="nc" id="L2140">        setMode(Mode.JOINING, &quot;Starting to bootstrap...&quot;, true);</span>
<span class="nc" id="L2141">        BootStrapper bootstrapper = new BootStrapper(FBUtilities.getBroadcastAddressAndPort(), tokens, tokenMetadata);</span>
<span class="nc" id="L2142">        bootstrapper.addProgressListener(progressSupport);</span>
<span class="nc bnc" id="L2143" title="All 4 branches missed.">        return bootstrapper.bootstrap(streamStateStore, useStrictConsistency &amp;&amp; !replacing); // handles token update</span>
    }

    private void invalidateLocalRanges()
    {
<span class="fc bfc" id="L2148" title="All 2 branches covered.">        for (Keyspace keyspace : Keyspace.all())</span>
        {
<span class="fc bfc" id="L2150" title="All 2 branches covered.">            for (ColumnFamilyStore cfs : keyspace.getColumnFamilyStores())</span>
            {
<span class="fc bfc" id="L2152" title="All 2 branches covered.">                for (final ColumnFamilyStore store : cfs.concatWithIndexes())</span>
                {
<span class="fc" id="L2154">                    store.invalidateLocalRanges();</span>
<span class="fc" id="L2155">                }</span>
<span class="fc" id="L2156">            }</span>
<span class="fc" id="L2157">        }</span>
<span class="fc" id="L2158">    }</span>

    /**
     * All MVs have been created during bootstrap, so mark them as built
     */
    private void markViewsAsBuilt()
    {
<span class="nc bnc" id="L2165" title="All 2 branches missed.">        for (String keyspace : Schema.instance.getUserKeyspaces().names())</span>
        {
<span class="nc bnc" id="L2167" title="All 2 branches missed.">            for (ViewMetadata view: Schema.instance.getKeyspaceMetadata(keyspace).views)</span>
<span class="nc" id="L2168">                SystemKeyspace.finishViewBuildStatus(view.keyspace(), view.name());</span>
<span class="nc" id="L2169">        }</span>
<span class="nc" id="L2170">    }</span>

    /**
     * Called when bootstrap did finish successfully
     */
    private void bootstrapFinished()
    {
<span class="nc" id="L2177">        markViewsAsBuilt();</span>
<span class="nc" id="L2178">        isBootstrapMode = false;</span>
<span class="nc" id="L2179">    }</span>

    @Override
    public String getBootstrapState()
    {
<span class="nc" id="L2184">        return SystemKeyspace.getBootstrapState().name();</span>
    }

    public boolean resumeBootstrap()
    {
<span class="nc bnc" id="L2189" title="All 4 branches missed.">        if (isBootstrapMode &amp;&amp; SystemKeyspace.bootstrapInProgress())</span>
        {
<span class="nc" id="L2191">            logger.info(&quot;Resuming bootstrap...&quot;);</span>

            // get bootstrap tokens saved in system keyspace
<span class="nc" id="L2194">            final Collection&lt;Token&gt; tokens = SystemKeyspace.getSavedTokens();</span>
            // already bootstrapped ranges are filtered during bootstrap
<span class="nc" id="L2196">            BootStrapper bootstrapper = new BootStrapper(FBUtilities.getBroadcastAddressAndPort(), tokens, tokenMetadata);</span>
<span class="nc" id="L2197">            bootstrapper.addProgressListener(progressSupport);</span>
<span class="nc bnc" id="L2198" title="All 4 branches missed.">            Future&lt;StreamState&gt; bootstrapStream = bootstrapper.bootstrap(streamStateStore, useStrictConsistency &amp;&amp; !replacing); // handles token update</span>
<span class="nc" id="L2199">            bootstrapStream.addCallback(new FutureCallback&lt;StreamState&gt;()</span>
<span class="nc" id="L2200">            {</span>
                @Override
                public void onSuccess(StreamState streamState)
                {
                    try
                    {
<span class="nc" id="L2206">                        bootstrapFinished();</span>
<span class="nc bnc" id="L2207" title="All 2 branches missed.">                        if (isSurveyMode)</span>
                        {
<span class="nc" id="L2209">                            logger.info(&quot;Startup complete, but write survey mode is active, not becoming an active ring member. Use JMX (StorageService-&gt;joinRing()) to finalize ring joining.&quot;);</span>
                        }
                        else
                        {
<span class="nc" id="L2213">                            isSurveyMode = false;</span>
<span class="nc" id="L2214">                            progressSupport.progress(&quot;bootstrap&quot;, ProgressEvent.createNotification(&quot;Joining ring...&quot;));</span>
<span class="nc" id="L2215">                            finishJoiningRing(true, bootstrapTokens);</span>
<span class="nc" id="L2216">                            doAuthSetup(false);</span>
                        }
<span class="nc" id="L2218">                        progressSupport.progress(&quot;bootstrap&quot;, new ProgressEvent(ProgressEventType.COMPLETE, 1, 1, &quot;Resume bootstrap complete&quot;));</span>
<span class="nc bnc" id="L2219" title="All 2 branches missed.">                        if (!isNativeTransportRunning())</span>
<span class="nc" id="L2220">                            daemon.initializeClientTransports();</span>
<span class="nc" id="L2221">                        daemon.start();</span>
<span class="nc" id="L2222">                        logger.info(&quot;Resume complete&quot;);</span>
                    }
<span class="nc" id="L2224">                    catch(Exception e)</span>
                    {
<span class="nc" id="L2226">                        onFailure(e);</span>
<span class="nc" id="L2227">                        throw e;</span>
<span class="nc" id="L2228">                    }</span>
<span class="nc" id="L2229">                }</span>

                @Override
                public void onFailure(Throwable e)
                {
<span class="nc" id="L2234">                    String message = &quot;Error during bootstrap: &quot;;</span>
<span class="nc bnc" id="L2235" title="All 4 branches missed.">                    if (e instanceof ExecutionException &amp;&amp; e.getCause() != null)</span>
                    {
<span class="nc" id="L2237">                        message += e.getCause().getMessage();</span>
                    }
                    else
                    {
<span class="nc" id="L2241">                        message += e.getMessage();</span>
                    }
<span class="nc" id="L2243">                    logger.error(message, e);</span>
<span class="nc" id="L2244">                    progressSupport.progress(&quot;bootstrap&quot;, new ProgressEvent(ProgressEventType.ERROR, 1, 1, message));</span>
<span class="nc" id="L2245">                    progressSupport.progress(&quot;bootstrap&quot;, new ProgressEvent(ProgressEventType.COMPLETE, 1, 1, &quot;Resume bootstrap complete&quot;));</span>
<span class="nc" id="L2246">                }</span>
            });
<span class="nc" id="L2248">            return true;</span>
        }
        else
        {
<span class="nc" id="L2252">            logger.info(&quot;Resuming bootstrap is requested, but the node is already bootstrapped.&quot;);</span>
<span class="nc" id="L2253">            return false;</span>
        }
    }

    public Map&lt;String,List&lt;Integer&gt;&gt; getConcurrency(List&lt;String&gt; stageNames)
    {
<span class="nc bnc" id="L2259" title="All 2 branches missed.">        Stream&lt;Stage&gt; stageStream = stageNames.isEmpty() ? stream(Stage.values()) : stageNames.stream().map(Stage::fromPoolName);</span>
<span class="nc" id="L2260">        return stageStream.collect(toMap(s -&gt; s.jmxName,</span>
<span class="nc" id="L2261">                                         s -&gt; Arrays.asList(s.getCorePoolSize(), s.getMaximumPoolSize())));</span>
    }

    public void setConcurrency(String threadPoolName, int newCorePoolSize, int newMaximumPoolSize)
    {
<span class="nc" id="L2266">        Stage stage = Stage.fromPoolName(threadPoolName);</span>
<span class="nc bnc" id="L2267" title="All 2 branches missed.">        if (newCorePoolSize &gt;= 0)</span>
<span class="nc" id="L2268">            stage.setCorePoolSize(newCorePoolSize);</span>
<span class="nc" id="L2269">        stage.setMaximumPoolSize(newMaximumPoolSize);</span>
<span class="nc" id="L2270">    }</span>

    public boolean isBootstrapMode()
    {
<span class="fc" id="L2274">        return isBootstrapMode;</span>
    }

    public TokenMetadata getTokenMetadata()
    {
<span class="fc" id="L2279">        return tokenMetadata;</span>
    }

    public Map&lt;List&lt;String&gt;, List&lt;String&gt;&gt; getRangeToEndpointMap(String keyspace)
    {
<span class="nc" id="L2284">        return getRangeToEndpointMap(keyspace, false);</span>
    }

    public Map&lt;List&lt;String&gt;, List&lt;String&gt;&gt; getRangeToEndpointWithPortMap(String keyspace)
    {
<span class="nc" id="L2289">         return getRangeToEndpointMap(keyspace, true);</span>
    }

    /**
     * for a keyspace, return the ranges and corresponding listen addresses.
     * @param keyspace
     * @return the endpoint map
     */
    public Map&lt;List&lt;String&gt;, List&lt;String&gt;&gt; getRangeToEndpointMap(String keyspace, boolean withPort)
    {
        /* All the ranges for the tokens */
<span class="nc" id="L2300">        Map&lt;List&lt;String&gt;, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L2301" title="All 2 branches missed.">        for (Map.Entry&lt;Range&lt;Token&gt;, EndpointsForRange&gt; entry : getRangeToAddressMap(keyspace).entrySet())</span>
        {
<span class="nc" id="L2303">            map.put(entry.getKey().asList(), Replicas.stringify(entry.getValue(), withPort));</span>
<span class="nc" id="L2304">        }</span>
<span class="nc" id="L2305">        return map;</span>
    }

    /**
     * Return the native address associated with an endpoint as a string.
     * @param endpoint The endpoint to get rpc address for
     * @return the native address
     */
    public String getNativeaddress(InetAddressAndPort endpoint, boolean withPort)
    {
<span class="fc bfc" id="L2315" title="All 2 branches covered.">        if (endpoint.equals(FBUtilities.getBroadcastAddressAndPort()))</span>
<span class="fc" id="L2316">            return FBUtilities.getBroadcastNativeAddressAndPort().getHostAddress(withPort);</span>
<span class="fc bfc" id="L2317" title="All 2 branches covered.">        else if (Gossiper.instance.getEndpointStateForEndpoint(endpoint).getApplicationState(ApplicationState.NATIVE_ADDRESS_AND_PORT) != null)</span>
        {
            try
            {
<span class="fc" id="L2321">                InetAddressAndPort address = InetAddressAndPort.getByName(Gossiper.instance.getEndpointStateForEndpoint(endpoint).getApplicationState(ApplicationState.NATIVE_ADDRESS_AND_PORT).value);</span>
<span class="fc" id="L2322">                return address.getHostAddress(withPort);</span>
            }
<span class="nc" id="L2324">            catch (UnknownHostException e)</span>
            {
<span class="nc" id="L2326">                throw new RuntimeException(e);</span>
            }
        }
        else
        {
             final String ipAddress;
             // If RPC_ADDRESS present in gossip for this endpoint use it.  This is expected for 3.x nodes.
<span class="fc bfc" id="L2333" title="All 2 branches covered.">             if (Gossiper.instance.getEndpointStateForEndpoint(endpoint).getApplicationState(ApplicationState.RPC_ADDRESS) != null)</span>
             {
<span class="fc" id="L2335">                 ipAddress = Gossiper.instance.getEndpointStateForEndpoint(endpoint).getApplicationState(ApplicationState.RPC_ADDRESS).value;</span>
             }
             else
             {
                 // otherwise just use the IP of the endpoint itself.
<span class="fc" id="L2340">                 ipAddress = endpoint.getHostAddress(false);</span>
             }

             // include the configured native_transport_port.
             try
             {
<span class="fc" id="L2346">                 InetAddressAndPort address = InetAddressAndPort.getByNameOverrideDefaults(ipAddress, DatabaseDescriptor.getNativeTransportPort());</span>
<span class="fc" id="L2347">                 return address.getHostAddress(withPort);</span>
             }
<span class="nc" id="L2349">             catch (UnknownHostException e)</span>
             {
<span class="nc" id="L2351">                 throw new RuntimeException(e);</span>
             }
         }
    }

    public Map&lt;List&lt;String&gt;, List&lt;String&gt;&gt; getRangeToRpcaddressMap(String keyspace)
    {
<span class="nc" id="L2358">        return getRangeToNativeaddressMap(keyspace, false);</span>
    }

    public Map&lt;List&lt;String&gt;, List&lt;String&gt;&gt; getRangeToNativeaddressWithPortMap(String keyspace)
    {
<span class="nc" id="L2363">        return getRangeToNativeaddressMap(keyspace, true);</span>
    }

    /**
     * for a keyspace, return the ranges and corresponding RPC addresses for a given keyspace.
     * @param keyspace
     * @return the endpoint map
     */
    private Map&lt;List&lt;String&gt;, List&lt;String&gt;&gt; getRangeToNativeaddressMap(String keyspace, boolean withPort)
    {
        /* All the ranges for the tokens */
<span class="nc" id="L2374">        Map&lt;List&lt;String&gt;, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L2375" title="All 2 branches missed.">        for (Map.Entry&lt;Range&lt;Token&gt;, EndpointsForRange&gt; entry : getRangeToAddressMap(keyspace).entrySet())</span>
        {
<span class="nc" id="L2377">            List&lt;String&gt; rpcaddrs = new ArrayList&lt;&gt;(entry.getValue().size());</span>
<span class="nc bnc" id="L2378" title="All 2 branches missed.">            for (Replica replicas: entry.getValue())</span>
            {
<span class="nc" id="L2380">                rpcaddrs.add(getNativeaddress(replicas.endpoint(), withPort));</span>
<span class="nc" id="L2381">            }</span>
<span class="nc" id="L2382">            map.put(entry.getKey().asList(), rpcaddrs);</span>
<span class="nc" id="L2383">        }</span>
<span class="nc" id="L2384">        return map;</span>
    }

    public Map&lt;List&lt;String&gt;, List&lt;String&gt;&gt; getPendingRangeToEndpointMap(String keyspace)
    {
<span class="nc" id="L2389">        return getPendingRangeToEndpointMap(keyspace, false);</span>
    }

    public Map&lt;List&lt;String&gt;, List&lt;String&gt;&gt; getPendingRangeToEndpointWithPortMap(String keyspace)
    {
<span class="nc" id="L2394">        return getPendingRangeToEndpointMap(keyspace, true);</span>
    }

    private Map&lt;List&lt;String&gt;, List&lt;String&gt;&gt; getPendingRangeToEndpointMap(String keyspace, boolean withPort)
    {
        // some people just want to get a visual representation of things. Allow null and set it to the first
        // non-system keyspace.
<span class="nc bnc" id="L2401" title="All 2 branches missed.">        if (keyspace == null)</span>
<span class="nc" id="L2402">            keyspace = Schema.instance.getNonLocalStrategyKeyspaces().iterator().next().name;</span>

<span class="nc" id="L2404">        Map&lt;List&lt;String&gt;, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L2405" title="All 2 branches missed.">        for (Map.Entry&lt;Range&lt;Token&gt;, EndpointsForRange&gt; entry : tokenMetadata.getPendingRangesMM(keyspace).asMap().entrySet())</span>
        {
<span class="nc" id="L2407">            map.put(entry.getKey().asList(), Replicas.stringify(entry.getValue(), withPort));</span>
<span class="nc" id="L2408">        }</span>
<span class="nc" id="L2409">        return map;</span>
    }

    public EndpointsByRange getRangeToAddressMap(String keyspace)
    {
<span class="fc" id="L2414">        return getRangeToAddressMap(keyspace, tokenMetadata.sortedTokens());</span>
    }

    public EndpointsByRange getRangeToAddressMapInLocalDC(String keyspace)
    {
<span class="nc" id="L2419">        Predicate&lt;Replica&gt; isLocalDC = replica -&gt; isLocalDC(replica.endpoint());</span>

<span class="nc" id="L2421">        EndpointsByRange origMap = getRangeToAddressMap(keyspace, getTokensInLocalDC());</span>
<span class="nc" id="L2422">        Map&lt;Range&lt;Token&gt;, EndpointsForRange&gt; filteredMap = Maps.newHashMap();</span>
<span class="nc bnc" id="L2423" title="All 2 branches missed.">        for (Map.Entry&lt;Range&lt;Token&gt;, EndpointsForRange&gt; entry : origMap.entrySet())</span>
        {
<span class="nc" id="L2425">            EndpointsForRange endpointsInLocalDC = entry.getValue().filter(isLocalDC);</span>
<span class="nc" id="L2426">            filteredMap.put(entry.getKey(), endpointsInLocalDC);</span>
<span class="nc" id="L2427">        }</span>

<span class="nc" id="L2429">        return new EndpointsByRange(filteredMap);</span>
    }

    private List&lt;Token&gt; getTokensInLocalDC()
    {
<span class="nc" id="L2434">        List&lt;Token&gt; filteredTokens = Lists.newArrayList();</span>
<span class="nc bnc" id="L2435" title="All 2 branches missed.">        for (Token token : tokenMetadata.sortedTokens())</span>
        {
<span class="nc" id="L2437">            InetAddressAndPort endpoint = tokenMetadata.getEndpoint(token);</span>
<span class="nc bnc" id="L2438" title="All 2 branches missed.">            if (isLocalDC(endpoint))</span>
<span class="nc" id="L2439">                filteredTokens.add(token);</span>
<span class="nc" id="L2440">        }</span>
<span class="nc" id="L2441">        return filteredTokens;</span>
    }

    private boolean isLocalDC(InetAddressAndPort targetHost)
    {
<span class="nc" id="L2446">        String remoteDC = DatabaseDescriptor.getEndpointSnitch().getDatacenter(targetHost);</span>
<span class="nc" id="L2447">        String localDC = DatabaseDescriptor.getEndpointSnitch().getLocalDatacenter();</span>
<span class="nc" id="L2448">        return remoteDC.equals(localDC);</span>
    }

    private EndpointsByRange getRangeToAddressMap(String keyspace, List&lt;Token&gt; sortedTokens)
    {
        // some people just want to get a visual representation of things. Allow null and set it to the first
        // non-system keyspace.
<span class="pc bpc" id="L2455" title="1 of 2 branches missed.">        if (keyspace == null)</span>
<span class="nc" id="L2456">            keyspace = Schema.instance.getNonLocalStrategyKeyspaces().iterator().next().name;</span>

<span class="fc" id="L2458">        List&lt;Range&lt;Token&gt;&gt; ranges = getAllRanges(sortedTokens);</span>
<span class="fc" id="L2459">        return constructRangeToEndpointMap(keyspace, ranges);</span>
    }


    public List&lt;String&gt; describeRingJMX(String keyspace) throws IOException
    {
<span class="nc" id="L2465">        return describeRingJMX(keyspace, false);</span>
    }

    public List&lt;String&gt; describeRingWithPortJMX(String keyspace) throws IOException
    {
<span class="nc" id="L2470">        return describeRingJMX(keyspace,true);</span>
    }

    /**
     * The same as {@code describeRing(String)} but converts TokenRange to the String for JMX compatibility
     *
     * @param keyspace The keyspace to fetch information about
     *
     * @return a List of TokenRange(s) converted to String for the given keyspace
     */
    private List&lt;String&gt; describeRingJMX(String keyspace, boolean withPort) throws IOException
    {
        List&lt;TokenRange&gt; tokenRanges;
        try
        {
<span class="nc" id="L2485">            tokenRanges = describeRing(keyspace, false, withPort);</span>
        }
<span class="nc" id="L2487">        catch (InvalidRequestException e)</span>
        {
<span class="nc" id="L2489">            throw new IOException(e.getMessage());</span>
<span class="nc" id="L2490">        }</span>
<span class="nc" id="L2491">        List&lt;String&gt; result = new ArrayList&lt;&gt;(tokenRanges.size());</span>

<span class="nc bnc" id="L2493" title="All 2 branches missed.">        for (TokenRange tokenRange : tokenRanges)</span>
<span class="nc" id="L2494">            result.add(tokenRange.toString(withPort));</span>

<span class="nc" id="L2496">        return result;</span>
    }

    /**
     * The TokenRange for a given keyspace.
     *
     * @param keyspace The keyspace to fetch information about
     *
     * @return a List of TokenRange(s) for the given keyspace
     *
     * @throws InvalidRequestException if there is no ring information available about keyspace
     */
    public List&lt;TokenRange&gt; describeRing(String keyspace) throws InvalidRequestException
    {
<span class="nc" id="L2510">        return describeRing(keyspace, false, false);</span>
    }

    /**
     * The same as {@code describeRing(String)} but considers only the part of the ring formed by nodes in the local DC.
     */
    public List&lt;TokenRange&gt; describeLocalRing(String keyspace) throws InvalidRequestException
    {
<span class="nc" id="L2518">        return describeRing(keyspace, true, false);</span>
    }

    private List&lt;TokenRange&gt; describeRing(String keyspace, boolean includeOnlyLocalDC, boolean withPort) throws InvalidRequestException
    {
<span class="nc bnc" id="L2523" title="All 2 branches missed.">        if (!Schema.instance.getKeyspaces().contains(keyspace))</span>
<span class="nc" id="L2524">            throw new InvalidRequestException(&quot;No such keyspace: &quot; + keyspace);</span>

<span class="nc bnc" id="L2526" title="All 4 branches missed.">        if (keyspace == null || Keyspace.open(keyspace).getReplicationStrategy() instanceof LocalStrategy)</span>
<span class="nc" id="L2527">            throw new InvalidRequestException(&quot;There is no ring for the keyspace: &quot; + keyspace);</span>

<span class="nc" id="L2529">        List&lt;TokenRange&gt; ranges = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2530">        Token.TokenFactory tf = getTokenFactory();</span>

        EndpointsByRange rangeToAddressMap =
<span class="nc bnc" id="L2533" title="All 2 branches missed.">                includeOnlyLocalDC</span>
<span class="nc" id="L2534">                        ? getRangeToAddressMapInLocalDC(keyspace)</span>
<span class="nc" id="L2535">                        : getRangeToAddressMap(keyspace);</span>

<span class="nc bnc" id="L2537" title="All 2 branches missed.">        for (Map.Entry&lt;Range&lt;Token&gt;, EndpointsForRange&gt; entry : rangeToAddressMap.entrySet())</span>
<span class="nc" id="L2538">            ranges.add(TokenRange.create(tf, entry.getKey(), ImmutableList.copyOf(entry.getValue().endpoints()), withPort));</span>

<span class="nc" id="L2540">        return ranges;</span>
    }

    public Map&lt;String, String&gt; getTokenToEndpointMap()
    {
<span class="nc" id="L2545">        return getTokenToEndpointMap(false);</span>
    }

    public Map&lt;String, String&gt; getTokenToEndpointWithPortMap()
    {
<span class="fc" id="L2550">        return getTokenToEndpointMap(true);</span>
    }

    private Map&lt;String, String&gt; getTokenToEndpointMap(boolean withPort)
    {
<span class="fc" id="L2555">        Map&lt;Token, InetAddressAndPort&gt; mapInetAddress = tokenMetadata.getNormalAndBootstrappingTokenToEndpointMap();</span>
        // in order to preserve tokens in ascending order, we use LinkedHashMap here
<span class="fc" id="L2557">        Map&lt;String, String&gt; mapString = new LinkedHashMap&lt;&gt;(mapInetAddress.size());</span>
<span class="fc" id="L2558">        List&lt;Token&gt; tokens = new ArrayList&lt;&gt;(mapInetAddress.keySet());</span>
<span class="fc" id="L2559">        Collections.sort(tokens);</span>
<span class="fc bfc" id="L2560" title="All 2 branches covered.">        for (Token token : tokens)</span>
        {
<span class="fc" id="L2562">            mapString.put(token.toString(), mapInetAddress.get(token).getHostAddress(withPort));</span>
<span class="fc" id="L2563">        }</span>
<span class="fc" id="L2564">        return mapString;</span>
    }

    public String getLocalHostId()
    {
<span class="fc" id="L2569">        UUID id = getLocalHostUUID();</span>
<span class="pc bpc" id="L2570" title="1 of 2 branches missed.">        return id != null ? id.toString() : null;</span>
    }

    public UUID getLocalHostUUID()
    {
<span class="fc" id="L2575">        UUID id = getTokenMetadata().getHostId(FBUtilities.getBroadcastAddressAndPort());</span>
<span class="fc bfc" id="L2576" title="All 2 branches covered.">        if (id != null)</span>
<span class="fc" id="L2577">            return id;</span>
        // this condition is to prevent accessing the tables when the node is not started yet, and in particular,
        // when it is not going to be started at all (e.g. when running some unit tests or client tools).
<span class="pc bpc" id="L2580" title="1 of 6 branches missed.">        else if ((DatabaseDescriptor.isDaemonInitialized() || DatabaseDescriptor.isToolInitialized()) &amp;&amp; CommitLog.instance.isStarted())</span>
<span class="fc" id="L2581">            return SystemKeyspace.getLocalHostId();</span>

<span class="fc" id="L2583">        return null;</span>
    }

    public Map&lt;String, String&gt; getHostIdMap()
    {
<span class="nc" id="L2588">        return getEndpointToHostId();</span>
    }


    public Map&lt;String, String&gt; getEndpointToHostId()
    {
<span class="nc" id="L2594">        return getEndpointToHostId(false);</span>
    }

    public Map&lt;String, String&gt; getEndpointWithPortToHostId()
    {
<span class="fc" id="L2599">        return getEndpointToHostId(true);</span>
    }

    private  Map&lt;String, String&gt; getEndpointToHostId(boolean withPort)
    {
<span class="fc" id="L2604">        Map&lt;String, String&gt; mapOut = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L2605" title="All 2 branches covered.">        for (Map.Entry&lt;InetAddressAndPort, UUID&gt; entry : getTokenMetadata().getEndpointToHostIdMapForReading().entrySet())</span>
<span class="fc" id="L2606">            mapOut.put(entry.getKey().getHostAddress(withPort), entry.getValue().toString());</span>
<span class="fc" id="L2607">        return mapOut;</span>
    }

    public Map&lt;String, String&gt; getHostIdToEndpoint()
    {
<span class="fc" id="L2612">        return getHostIdToEndpoint(false);</span>
    }

    public Map&lt;String, String&gt; getHostIdToEndpointWithPort()
    {
<span class="nc" id="L2617">        return getHostIdToEndpoint(true);</span>
    }

    private Map&lt;String, String&gt; getHostIdToEndpoint(boolean withPort)
    {
<span class="fc" id="L2622">        Map&lt;String, String&gt; mapOut = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L2623" title="All 2 branches covered.">        for (Map.Entry&lt;InetAddressAndPort, UUID&gt; entry : getTokenMetadata().getEndpointToHostIdMapForReading().entrySet())</span>
<span class="fc" id="L2624">            mapOut.put(entry.getValue().toString(), entry.getKey().getHostAddress(withPort));</span>
<span class="fc" id="L2625">        return mapOut;</span>
    }

    /**
     * Construct the range to endpoint mapping based on the true view
     * of the world.
     * @param ranges
     * @return mapping of ranges to the replicas responsible for them.
    */
    private EndpointsByRange constructRangeToEndpointMap(String keyspace, List&lt;Range&lt;Token&gt;&gt; ranges)
    {
<span class="fc" id="L2636">        AbstractReplicationStrategy strategy = Keyspace.open(keyspace).getReplicationStrategy();</span>
<span class="fc" id="L2637">        Map&lt;Range&lt;Token&gt;, EndpointsForRange&gt; rangeToEndpointMap = new HashMap&lt;&gt;(ranges.size());</span>
<span class="fc bfc" id="L2638" title="All 2 branches covered.">        for (Range&lt;Token&gt; range : ranges)</span>
<span class="fc" id="L2639">            rangeToEndpointMap.put(range, strategy.getNaturalReplicas(range.right));</span>
<span class="fc" id="L2640">        return new EndpointsByRange(rangeToEndpointMap);</span>
    }

    public void beforeChange(InetAddressAndPort endpoint, EndpointState currentState, ApplicationState newStateKey, VersionedValue newValue)
    {
        // no-op
<span class="fc" id="L2646">    }</span>

    /*
     * Handle the reception of a new particular ApplicationState for a particular endpoint. Note that the value of the
     * ApplicationState has not necessarily &quot;changed&quot; since the last known value, if we already received the same update
     * from somewhere else.
     *
     * onChange only ever sees one ApplicationState piece change at a time (even if many ApplicationState updates were
     * received at the same time), so we perform a kind of state machine here. We are concerned with two events: knowing
     * the token associated with an endpoint, and knowing its operation mode. Nodes can start in either bootstrap or
     * normal mode, and from bootstrap mode can change mode to normal. A node in bootstrap mode needs to have
     * pendingranges set in TokenMetadata; a node in normal mode should instead be part of the token ring.
     *
     * Normal progression of ApplicationState.STATUS values for a node should be like this:
     * STATUS_BOOTSTRAPPING,token
     *   if bootstrapping. stays this way until all files are received.
     * STATUS_NORMAL,token
     *   ready to serve reads and writes.
     * STATUS_LEAVING,token
     *   get ready to leave the cluster as part of a decommission
     * STATUS_LEFT,token
     *   set after decommission is completed.
     *
     * Other STATUS values that may be seen (possibly anywhere in the normal progression):
     * STATUS_MOVING,newtoken
     *   set if node is currently moving to a new token in the ring
     * REMOVING_TOKEN,deadtoken
     *   set if the node is dead and is being removed by its REMOVAL_COORDINATOR
     * REMOVED_TOKEN,deadtoken
     *   set if the node is dead and has been removed by its REMOVAL_COORDINATOR
     *
     * Note: Any time a node state changes from STATUS_NORMAL, it will not be visible to new nodes. So it follows that
     * you should never bootstrap a new node during a removenode, decommission or move.
     */
    public void onChange(InetAddressAndPort endpoint, ApplicationState state, VersionedValue value)
    {
<span class="fc bfc" id="L2682" title="All 4 branches covered.">        if (state == ApplicationState.STATUS || state == ApplicationState.STATUS_WITH_PORT)</span>
        {
<span class="fc" id="L2684">            String[] pieces = splitValue(value);</span>
<span class="pc bpc" id="L2685" title="1 of 2 branches missed.">            assert (pieces.length &gt; 0);</span>

<span class="fc" id="L2687">            String moveName = pieces[0];</span>

<span class="pc bpc" id="L2689" title="2 of 9 branches missed.">            switch (moveName)</span>
            {
                case VersionedValue.STATUS_BOOTSTRAPPING_REPLACE:
<span class="nc" id="L2692">                    handleStateBootreplacing(endpoint, pieces);</span>
<span class="nc" id="L2693">                    break;</span>
                case VersionedValue.STATUS_BOOTSTRAPPING:
<span class="fc" id="L2695">                    handleStateBootstrap(endpoint);</span>
<span class="fc" id="L2696">                    break;</span>
                case VersionedValue.STATUS_NORMAL:
<span class="fc" id="L2698">                    handleStateNormal(endpoint, VersionedValue.STATUS_NORMAL);</span>
<span class="fc" id="L2699">                    break;</span>
                case VersionedValue.SHUTDOWN:
<span class="fc" id="L2701">                    handleStateNormal(endpoint, VersionedValue.SHUTDOWN);</span>
<span class="fc" id="L2702">                    break;</span>
                case VersionedValue.REMOVING_TOKEN:
                case VersionedValue.REMOVED_TOKEN:
<span class="fc" id="L2705">                    handleStateRemoving(endpoint, pieces);</span>
<span class="fc" id="L2706">                    break;</span>
                case VersionedValue.STATUS_LEAVING:
<span class="fc" id="L2708">                    handleStateLeaving(endpoint);</span>
<span class="fc" id="L2709">                    break;</span>
                case VersionedValue.STATUS_LEFT:
<span class="fc" id="L2711">                    handleStateLeft(endpoint, pieces);</span>
<span class="fc" id="L2712">                    break;</span>
                case VersionedValue.STATUS_MOVING:
<span class="fc" id="L2714">                    handleStateMoving(endpoint, pieces);</span>
                    break;
            }
<span class="fc" id="L2717">        }</span>
        else
        {
<span class="fc bfc" id="L2720" title="All 2 branches covered.">            if (state == ApplicationState.INDEX_STATUS)</span>
            {
<span class="fc" id="L2722">                updateIndexStatus(endpoint, value);</span>
<span class="fc" id="L2723">                return;</span>
            }

<span class="fc" id="L2726">            EndpointState epState = Gossiper.instance.getEndpointStateForEndpoint(endpoint);</span>
<span class="pc bpc" id="L2727" title="1 of 4 branches missed.">            if (epState == null || Gossiper.instance.isDeadState(epState))</span>
            {
<span class="fc" id="L2729">                logger.debug(&quot;Ignoring state change for dead or unknown endpoint: {}&quot;, endpoint);</span>
<span class="fc" id="L2730">                return;</span>
            }

<span class="fc bfc" id="L2733" title="All 2 branches covered.">            if (getTokenMetadata().isMember(endpoint))</span>
            {
<span class="pc bpc" id="L2735" title="3 of 10 branches missed.">                switch (state)</span>
                {
                    case RELEASE_VERSION:
<span class="nc" id="L2738">                        SystemKeyspace.updatePeerInfo(endpoint, &quot;release_version&quot;, value.value);</span>
<span class="nc" id="L2739">                        break;</span>
                    case DC:
<span class="fc" id="L2741">                        updateTopology(endpoint);</span>
<span class="fc" id="L2742">                        SystemKeyspace.updatePeerInfo(endpoint, &quot;data_center&quot;, value.value);</span>
<span class="fc" id="L2743">                        break;</span>
                    case RACK:
<span class="fc" id="L2745">                        updateTopology(endpoint);</span>
<span class="fc" id="L2746">                        SystemKeyspace.updatePeerInfo(endpoint, &quot;rack&quot;, value.value);</span>
<span class="fc" id="L2747">                        break;</span>
                    case RPC_ADDRESS:
                        try
                        {
<span class="nc" id="L2751">                            SystemKeyspace.updatePeerInfo(endpoint, &quot;rpc_address&quot;, InetAddress.getByName(value.value));</span>
                        }
<span class="nc" id="L2753">                        catch (UnknownHostException e)</span>
                        {
<span class="nc" id="L2755">                            throw new RuntimeException(e);</span>
<span class="nc" id="L2756">                        }</span>
                        break;
                    case NATIVE_ADDRESS_AND_PORT:
                        try
                        {
<span class="nc" id="L2761">                            InetAddressAndPort address = InetAddressAndPort.getByName(value.value);</span>
<span class="nc" id="L2762">                            SystemKeyspace.updatePeerNativeAddress(endpoint, address);</span>
                        }
<span class="nc" id="L2764">                        catch (UnknownHostException e)</span>
                        {
<span class="nc" id="L2766">                            throw new RuntimeException(e);</span>
<span class="nc" id="L2767">                        }</span>
                        break;
                    case SCHEMA:
<span class="fc" id="L2770">                        SystemKeyspace.updatePeerInfo(endpoint, &quot;schema_version&quot;, UUID.fromString(value.value));</span>
<span class="fc" id="L2771">                        break;</span>
                    case HOST_ID:
<span class="fc" id="L2773">                        SystemKeyspace.updatePeerInfo(endpoint, &quot;host_id&quot;, UUID.fromString(value.value));</span>
<span class="fc" id="L2774">                        break;</span>
                    case RPC_READY:
<span class="fc" id="L2776">                        notifyRpcChange(endpoint, epState.isRpcReady());</span>
<span class="fc" id="L2777">                        break;</span>
                    case NET_VERSION:
<span class="fc" id="L2779">                        updateNetVersion(endpoint, value);</span>
<span class="fc" id="L2780">                        break;</span>
                }
            }
            else
            {
<span class="fc" id="L2785">                logger.debug(&quot;Ignoring application state {} from {} because it is not a member in token metadata&quot;,</span>
                             state, endpoint);
            }
        }
<span class="fc" id="L2789">    }</span>

    private static String[] splitValue(VersionedValue value)
    {
<span class="fc" id="L2793">        return value.value.split(VersionedValue.DELIMITER_STR, -1);</span>
    }

    private void updateIndexStatus(InetAddressAndPort endpoint, VersionedValue versionedValue)
    {
<span class="fc" id="L2798">        IndexStatusManager.instance.receivePeerIndexStatus(endpoint, versionedValue);</span>
<span class="fc" id="L2799">    }</span>

    private void updateNetVersion(InetAddressAndPort endpoint, VersionedValue value)
    {
        try
        {
<span class="fc" id="L2805">            MessagingService.instance().versions.set(endpoint, Integer.parseInt(value.value));</span>
        }
<span class="nc" id="L2807">        catch (NumberFormatException e)</span>
        {
<span class="nc" id="L2809">            throw new AssertionError(&quot;Got invalid value for NET_VERSION application state: &quot; + value.value);</span>
<span class="fc" id="L2810">        }</span>
<span class="fc" id="L2811">    }</span>

    public void updateTopology(InetAddressAndPort endpoint)
    {
<span class="pc bpc" id="L2815" title="1 of 2 branches missed.">        if (getTokenMetadata().isMember(endpoint))</span>
        {
<span class="fc" id="L2817">            getTokenMetadata().updateTopology(endpoint);</span>
        }
<span class="fc" id="L2819">    }</span>

    public void updateTopology()
    {
<span class="fc" id="L2823">        getTokenMetadata().updateTopology();</span>
<span class="fc" id="L2824">    }</span>

    private void updatePeerInfo(InetAddressAndPort endpoint)
    {
<span class="fc" id="L2828">        EndpointState epState = Gossiper.instance.getEndpointStateForEndpoint(endpoint);</span>
<span class="fc" id="L2829">        InetAddress native_address = null;</span>
<span class="fc" id="L2830">        int native_port = DatabaseDescriptor.getNativeTransportPort();</span>

<span class="fc bfc" id="L2832" title="All 2 branches covered.">        for (Map.Entry&lt;ApplicationState, VersionedValue&gt; entry : epState.states())</span>
        {
<span class="fc bfc" id="L2834" title="All 9 branches covered.">            switch (entry.getKey())</span>
            {
                case RELEASE_VERSION:
<span class="fc" id="L2837">                    SystemKeyspace.updatePeerInfo(endpoint, &quot;release_version&quot;, entry.getValue().value);</span>
<span class="fc" id="L2838">                    break;</span>
                case DC:
<span class="fc" id="L2840">                    SystemKeyspace.updatePeerInfo(endpoint, &quot;data_center&quot;, entry.getValue().value);</span>
<span class="fc" id="L2841">                    break;</span>
                case RACK:
<span class="fc" id="L2843">                    SystemKeyspace.updatePeerInfo(endpoint, &quot;rack&quot;, entry.getValue().value);</span>
<span class="fc" id="L2844">                    break;</span>
                case RPC_ADDRESS:
                    try
                    {
<span class="fc" id="L2848">                        native_address = InetAddress.getByName(entry.getValue().value);</span>
                    }
<span class="nc" id="L2850">                    catch (UnknownHostException e)</span>
                    {
<span class="nc" id="L2852">                        throw new RuntimeException(e);</span>
<span class="fc" id="L2853">                    }</span>
                    break;
                case NATIVE_ADDRESS_AND_PORT:
                    try
                    {
<span class="fc" id="L2858">                        InetAddressAndPort address = InetAddressAndPort.getByName(entry.getValue().value);</span>
<span class="fc" id="L2859">                        native_address = address.getAddress();</span>
<span class="fc" id="L2860">                        native_port = address.getPort();</span>
                    }
<span class="nc" id="L2862">                    catch (UnknownHostException e)</span>
                    {
<span class="nc" id="L2864">                        throw new RuntimeException(e);</span>
<span class="fc" id="L2865">                    }</span>
                    break;
                case SCHEMA:
<span class="fc" id="L2868">                    SystemKeyspace.updatePeerInfo(endpoint, &quot;schema_version&quot;, UUID.fromString(entry.getValue().value));</span>
<span class="fc" id="L2869">                    break;</span>
                case HOST_ID:
<span class="fc" id="L2871">                    SystemKeyspace.updatePeerInfo(endpoint, &quot;host_id&quot;, UUID.fromString(entry.getValue().value));</span>
<span class="fc" id="L2872">                    break;</span>
                case INDEX_STATUS:
                    // Need to set the peer index status in SIM here
                    // to ensure the status is correct before the node
                    // fully joins the ring
<span class="fc" id="L2877">                    updateIndexStatus(endpoint, entry.getValue());</span>
                    break;
            }
<span class="fc" id="L2880">        }</span>

        //Some tests won't set all the states
<span class="fc bfc" id="L2883" title="All 2 branches covered.">        if (native_address != null)</span>
        {
<span class="fc" id="L2885">            SystemKeyspace.updatePeerNativeAddress(endpoint,</span>
<span class="fc" id="L2886">                                                   InetAddressAndPort.getByAddressOverrideDefaults(native_address,</span>
<span class="fc" id="L2887">                                                                                                   native_port));</span>
        }
<span class="fc" id="L2889">    }</span>

    private void notifyRpcChange(InetAddressAndPort endpoint, boolean ready)
    {
<span class="fc bfc" id="L2893" title="All 2 branches covered.">        if (ready)</span>
<span class="fc" id="L2894">            notifyUp(endpoint);</span>
        else
<span class="fc" id="L2896">            notifyDown(endpoint);</span>
<span class="fc" id="L2897">    }</span>

    private void notifyUp(InetAddressAndPort endpoint)
    {
<span class="pc bpc" id="L2901" title="2 of 4 branches missed.">        if (!isRpcReady(endpoint) || !Gossiper.instance.isAlive(endpoint))</span>
<span class="nc" id="L2902">            return;</span>

<span class="fc bfc" id="L2904" title="All 2 branches covered.">        for (IEndpointLifecycleSubscriber subscriber : lifecycleSubscribers)</span>
<span class="fc" id="L2905">            subscriber.onUp(endpoint);</span>
<span class="fc" id="L2906">    }</span>

    private void notifyDown(InetAddressAndPort endpoint)
    {
<span class="fc bfc" id="L2910" title="All 2 branches covered.">        for (IEndpointLifecycleSubscriber subscriber : lifecycleSubscribers)</span>
<span class="fc" id="L2911">            subscriber.onDown(endpoint);</span>
<span class="fc" id="L2912">    }</span>

    private void notifyJoined(InetAddressAndPort endpoint)
    {
<span class="fc bfc" id="L2916" title="All 2 branches covered.">        if (!isStatus(endpoint, VersionedValue.STATUS_NORMAL))</span>
<span class="fc" id="L2917">            return;</span>

<span class="pc bpc" id="L2919" title="1 of 2 branches missed.">        for (IEndpointLifecycleSubscriber subscriber : lifecycleSubscribers)</span>
<span class="nc" id="L2920">            subscriber.onJoinCluster(endpoint);</span>
<span class="fc" id="L2921">    }</span>

    private void notifyMoved(InetAddressAndPort endpoint)
    {
<span class="pc bpc" id="L2925" title="1 of 2 branches missed.">        for (IEndpointLifecycleSubscriber subscriber : lifecycleSubscribers)</span>
<span class="nc" id="L2926">            subscriber.onMove(endpoint);</span>
<span class="fc" id="L2927">    }</span>

    private void notifyLeft(InetAddressAndPort endpoint)
    {
<span class="pc bpc" id="L2931" title="1 of 2 branches missed.">        for (IEndpointLifecycleSubscriber subscriber : lifecycleSubscribers)</span>
<span class="nc" id="L2932">            subscriber.onLeaveCluster(endpoint);</span>
<span class="fc" id="L2933">    }</span>

    private boolean isStatus(InetAddressAndPort endpoint, String status)
    {
<span class="fc" id="L2937">        EndpointState state = Gossiper.instance.getEndpointStateForEndpoint(endpoint);</span>
<span class="pc bpc" id="L2938" title="1 of 4 branches missed.">        return state != null &amp;&amp; state.getStatus().equals(status);</span>
    }

    public boolean isRpcReady(InetAddressAndPort endpoint)
    {
<span class="fc" id="L2943">        EndpointState state = Gossiper.instance.getEndpointStateForEndpoint(endpoint);</span>
<span class="pc bpc" id="L2944" title="2 of 4 branches missed.">        return state != null &amp;&amp; state.isRpcReady();</span>
    }

    /**
     * Set the RPC status. Because when draining a node we need to set the RPC
     * status to not ready, and drain is called by the shutdown hook, it may be that value is false
     * and there is no local endpoint state. In this case it's OK to just do nothing. Therefore,
     * we assert that the local endpoint state is not null only when value is true.
     *
     * @param value - true indicates that RPC is ready, false indicates the opposite.
     */
    public void setRpcReady(boolean value)
    {
<span class="fc" id="L2957">        EndpointState state = Gossiper.instance.getEndpointStateForEndpoint(FBUtilities.getBroadcastAddressAndPort());</span>
        // if value is false we're OK with a null state, if it is true we are not.
<span class="pc bpc" id="L2959" title="1 of 4 branches missed.">        assert !value || state != null;</span>

<span class="pc bpc" id="L2961" title="1 of 2 branches missed.">        if (state != null)</span>
<span class="fc" id="L2962">            Gossiper.instance.addLocalApplicationState(ApplicationState.RPC_READY, valueFactory.rpcReady(value));</span>
<span class="fc" id="L2963">    }</span>

    private Collection&lt;Token&gt; getTokensFor(InetAddressAndPort endpoint)
    {
        try
        {
<span class="fc" id="L2969">            EndpointState state = Gossiper.instance.getEndpointStateForEndpoint(endpoint);</span>
<span class="pc bpc" id="L2970" title="1 of 2 branches missed.">            if (state == null)</span>
<span class="nc" id="L2971">                return Collections.emptyList();</span>

<span class="fc" id="L2973">            VersionedValue versionedValue = state.getApplicationState(ApplicationState.TOKENS);</span>
<span class="pc bpc" id="L2974" title="1 of 2 branches missed.">            if (versionedValue == null)</span>
<span class="nc" id="L2975">                return Collections.emptyList();</span>

<span class="fc" id="L2977">            return TokenSerializer.deserialize(tokenMetadata.partitioner, new DataInputStream(new ByteArrayInputStream(versionedValue.toBytes())));</span>
        }
<span class="nc" id="L2979">        catch (IOException e)</span>
        {
<span class="nc" id="L2981">            throw new RuntimeException(e);</span>
        }
    }

    /**
     * Handle node bootstrap
     *
     * @param endpoint bootstrapping node
     */
    private void handleStateBootstrap(InetAddressAndPort endpoint)
    {
        Collection&lt;Token&gt; tokens;
        // explicitly check for TOKENS, because a bootstrapping node might be bootstrapping in legacy mode; that is, not using vnodes and no token specified
<span class="fc" id="L2994">        tokens = getTokensFor(endpoint);</span>

<span class="pc bpc" id="L2996" title="1 of 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="fc" id="L2997">            logger.debug(&quot;Node {} state bootstrapping, token {}&quot;, endpoint, tokens);</span>

        // if this node is present in token metadata, either we have missed intermediate states
        // or the node had crashed. Print warning if needed, clear obsolete stuff and
        // continue.
<span class="fc bfc" id="L3002" title="All 2 branches covered.">        if (tokenMetadata.isMember(endpoint))</span>
        {
            // If isLeaving is false, we have missed both LEAVING and LEFT. However, if
            // isLeaving is true, we have only missed LEFT. Waiting time between completing
            // leave operation and rebootstrapping is relatively short, so the latter is quite
            // common (not enough time for gossip to spread). Therefore we report only the
            // former in the log.
<span class="fc bfc" id="L3009" title="All 2 branches covered.">            if (!tokenMetadata.isLeaving(endpoint))</span>
<span class="fc" id="L3010">                logger.info(&quot;Node {} state jump to bootstrap&quot;, endpoint);</span>
<span class="fc" id="L3011">            tokenMetadata.removeEndpoint(endpoint);</span>
        }

<span class="fc" id="L3014">        tokenMetadata.addBootstrapTokens(tokens, endpoint);</span>
<span class="fc" id="L3015">        PendingRangeCalculatorService.instance.update();</span>

<span class="fc" id="L3017">        tokenMetadata.updateHostId(Gossiper.instance.getHostId(endpoint), endpoint);</span>
<span class="fc" id="L3018">    }</span>

    private void handleStateBootreplacing(InetAddressAndPort newNode, String[] pieces)
    {
        InetAddressAndPort oldNode;
        try
        {
<span class="nc" id="L3025">            oldNode = InetAddressAndPort.getByName(pieces[1]);</span>
        }
<span class="nc" id="L3027">        catch (Exception e)</span>
        {
<span class="nc" id="L3029">            logger.error(&quot;Node {} tried to replace malformed endpoint {}.&quot;, newNode, pieces[1], e);</span>
<span class="nc" id="L3030">            return;</span>
<span class="nc" id="L3031">        }</span>

<span class="nc bnc" id="L3033" title="All 2 branches missed.">        if (FailureDetector.instance.isAlive(oldNode))</span>
        {
<span class="nc" id="L3035">            throw new RuntimeException(String.format(&quot;Node %s is trying to replace alive node %s.&quot;, newNode, oldNode));</span>
        }

<span class="nc" id="L3038">        Optional&lt;InetAddressAndPort&gt; replacingNode = tokenMetadata.getReplacingNode(newNode);</span>
<span class="nc bnc" id="L3039" title="All 4 branches missed.">        if (replacingNode.isPresent() &amp;&amp; !replacingNode.get().equals(oldNode))</span>
        {
<span class="nc" id="L3041">            throw new RuntimeException(String.format(&quot;Node %s is already replacing %s but is trying to replace %s.&quot;,</span>
<span class="nc" id="L3042">                                                     newNode, replacingNode.get(), oldNode));</span>
        }

<span class="nc" id="L3045">        Collection&lt;Token&gt; tokens = getTokensFor(newNode);</span>

<span class="nc bnc" id="L3047" title="All 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="nc" id="L3048">            logger.debug(&quot;Node {} is replacing {}, tokens {}&quot;, newNode, oldNode, tokens);</span>

<span class="nc" id="L3050">        tokenMetadata.addReplaceTokens(tokens, newNode, oldNode);</span>
<span class="nc" id="L3051">        PendingRangeCalculatorService.instance.update();</span>

<span class="nc" id="L3053">        tokenMetadata.updateHostId(Gossiper.instance.getHostId(newNode), newNode);</span>
<span class="nc" id="L3054">    }</span>

    private void ensureUpToDateTokenMetadata(String status, InetAddressAndPort endpoint)
    {
<span class="fc" id="L3058">        Set&lt;Token&gt; tokens = new TreeSet&lt;&gt;(getTokensFor(endpoint));</span>

<span class="pc bpc" id="L3060" title="1 of 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="fc" id="L3061">            logger.debug(&quot;Node {} state {}, tokens {}&quot;, endpoint, status, tokens);</span>

        // If the node is previously unknown or tokens do not match, update tokenmetadata to
        // have this node as 'normal' (it must have been using this token before the
        // leave). This way we'll get pending ranges right.
<span class="fc bfc" id="L3066" title="All 2 branches covered.">        if (!tokenMetadata.isMember(endpoint))</span>
        {
<span class="fc" id="L3068">            logger.info(&quot;Node {} state jump to {}&quot;, endpoint, status);</span>
<span class="fc" id="L3069">            updateTokenMetadata(endpoint, tokens);</span>
        }
<span class="fc bfc" id="L3071" title="All 2 branches covered.">        else if (!tokens.equals(new TreeSet&lt;&gt;(tokenMetadata.getTokens(endpoint))))</span>
        {
<span class="fc" id="L3073">            logger.warn(&quot;Node {} '{}' token mismatch. Long network partition?&quot;, endpoint, status);</span>
<span class="fc" id="L3074">            updateTokenMetadata(endpoint, tokens);</span>
        }
<span class="fc" id="L3076">    }</span>

    private void updateTokenMetadata(InetAddressAndPort endpoint, Iterable&lt;Token&gt; tokens)
    {
<span class="fc" id="L3080">        updateTokenMetadata(endpoint, tokens, new HashSet&lt;&gt;());</span>
<span class="fc" id="L3081">    }</span>

    private void updateTokenMetadata(InetAddressAndPort endpoint, Iterable&lt;Token&gt; tokens, Set&lt;InetAddressAndPort&gt; endpointsToRemove)
    {
<span class="fc" id="L3085">        Set&lt;Token&gt; tokensToUpdateInMetadata = new HashSet&lt;&gt;();</span>
<span class="fc" id="L3086">        Set&lt;Token&gt; tokensToUpdateInSystemKeyspace = new HashSet&lt;&gt;();</span>

<span class="fc bfc" id="L3088" title="All 2 branches covered.">        for (final Token token : tokens)</span>
        {
            // we don't want to update if this node is responsible for the token and it has a later startup time than endpoint.
<span class="fc" id="L3091">            InetAddressAndPort currentOwner = tokenMetadata.getEndpoint(token);</span>
<span class="fc bfc" id="L3092" title="All 2 branches covered.">            if (currentOwner == null)</span>
            {
<span class="fc" id="L3094">                logger.debug(&quot;New node {} at token {}&quot;, endpoint, token);</span>
<span class="fc" id="L3095">                tokensToUpdateInMetadata.add(token);</span>
<span class="fc" id="L3096">                tokensToUpdateInSystemKeyspace.add(token);</span>
            }
<span class="pc bpc" id="L3098" title="1 of 2 branches missed.">            else if (endpoint.equals(currentOwner))</span>
            {
                // set state back to normal, since the node may have tried to leave, but failed and is now back up
<span class="fc" id="L3101">                tokensToUpdateInMetadata.add(token);</span>
<span class="fc" id="L3102">                tokensToUpdateInSystemKeyspace.add(token);</span>
            }
            // Note: in test scenarios, there may not be any delta between the heartbeat generations of the old
            // and new nodes, so we first check whether the new endpoint is marked as a replacement for the old.
<span class="nc bnc" id="L3106" title="All 4 branches missed.">            else if (endpoint.equals(tokenMetadata.getReplacementNode(currentOwner).orElse(null)) || Gossiper.instance.compareEndpointStartup(endpoint, currentOwner) &gt; 0)</span>
            {
<span class="nc" id="L3108">                tokensToUpdateInMetadata.add(token);</span>
<span class="nc" id="L3109">                tokensToUpdateInSystemKeyspace.add(token);</span>

                // currentOwner is no longer current, endpoint is.  Keep track of these moves, because when
                // a host no longer has any tokens, we'll want to remove it.
<span class="nc" id="L3113">                Multimap&lt;InetAddressAndPort, Token&gt; epToTokenCopy = getTokenMetadata().getEndpointToTokenMapForReading();</span>
<span class="nc" id="L3114">                epToTokenCopy.get(currentOwner).remove(token);</span>
<span class="nc bnc" id="L3115" title="All 2 branches missed.">                if (epToTokenCopy.get(currentOwner).isEmpty())</span>
<span class="nc" id="L3116">                    endpointsToRemove.add(currentOwner);</span>

<span class="nc" id="L3118">                logger.info(&quot;Nodes {} and {} have the same token {}. {} is the new owner&quot;, endpoint, currentOwner, token, endpoint);</span>
<span class="nc" id="L3119">            }</span>
            else
            {
<span class="nc" id="L3122">                logger.info(&quot;Nodes {} and {} have the same token {}.  Ignoring {}&quot;, endpoint, currentOwner, token, endpoint);</span>
            }
<span class="fc" id="L3124">        }</span>

<span class="fc" id="L3126">        tokenMetadata.updateNormalTokens(tokensToUpdateInMetadata, endpoint);</span>
<span class="pc bpc" id="L3127" title="1 of 2 branches missed.">        for (InetAddressAndPort ep : endpointsToRemove)</span>
        {
<span class="nc" id="L3129">            removeEndpoint(ep);</span>
<span class="nc bnc" id="L3130" title="All 4 branches missed.">            if (replacing &amp;&amp; ep.equals(DatabaseDescriptor.getReplaceAddress()))</span>
<span class="nc" id="L3131">                Gossiper.instance.replacementQuarantine(ep); // quarantine locally longer than normally; see CASSANDRA-8260</span>
<span class="nc" id="L3132">        }</span>
<span class="pc bpc" id="L3133" title="1 of 2 branches missed.">        if (!tokensToUpdateInSystemKeyspace.isEmpty())</span>
<span class="fc" id="L3134">            SystemKeyspace.updateTokens(endpoint, tokensToUpdateInSystemKeyspace);</span>

        // Tokens changed, the local range ownership probably changed too.
<span class="fc" id="L3137">        invalidateLocalRanges();</span>
<span class="fc" id="L3138">    }</span>

    @VisibleForTesting
    public boolean isReplacingSameHostAddressAndHostId(UUID hostId)
    {
        try
        {
<span class="fc bfc" id="L3145" title="All 2 branches covered.">            return isReplacingSameAddress() &amp;&amp;</span>
<span class="pc bpc" id="L3146" title="1 of 2 branches missed.">                    Gossiper.instance.getEndpointStateForEndpoint(DatabaseDescriptor.getReplaceAddress()) != null</span>
<span class="fc bfc" id="L3147" title="All 2 branches covered.">                    &amp;&amp; hostId.equals(Gossiper.instance.getHostId(DatabaseDescriptor.getReplaceAddress()));</span>
        }
<span class="fc" id="L3149">        catch (RuntimeException ex)</span>
        {
            // If a host is decomissioned and the DNS entry is removed before the
            // bootstrap completes, when it completes and advertises NORMAL state to other nodes, they will be unable
            // to resolve it to an InetAddress unless it happens to be cached. This could happen on nodes
            // storing large amounts of data or with long index rebuild times or if new instances have been added
            // to the cluster through expansion or additional host replacement.
            //
            // The original host replacement must have been able to resolve the replacing address on startup
            // when setting StorageService.replacing, so if it is impossible to resolve now it is probably
            // decommissioned and did not have the same IP address or host id.  Allow the handleStateNormal
            // handling to proceed, otherwise gossip state will be inconistent with some nodes believing the
            // replacement host to be normal, and nodes unable to resolve the hostname will be left in JOINING.
<span class="pc bpc" id="L3162" title="2 of 4 branches missed.">            if (ex.getCause() != null &amp;&amp; ex.getCause().getClass() == UnknownHostException.class)</span>
            {
<span class="fc" id="L3164">                logger.info(&quot;Suppressed exception while checking isReplacingSameHostAddressAndHostId({}). Original host was probably decommissioned. ({})&quot;,</span>
<span class="fc" id="L3165">                        hostId, ex.getMessage());</span>
<span class="fc" id="L3166">                return false;</span>
            }
<span class="nc" id="L3168">            throw ex; // otherwise rethrow</span>
        }
    }

    /**
     * Handle node move to normal state. That is, node is entering token ring and participating
     * in reads.
     *
     * @param endpoint node
     */
    private void handleStateNormal(final InetAddressAndPort endpoint, final String status)
    {
<span class="fc" id="L3180">        Collection&lt;Token&gt; tokens = getTokensFor(endpoint);</span>
<span class="fc" id="L3181">        Set&lt;InetAddressAndPort&gt; endpointsToRemove = new HashSet&lt;&gt;();</span>

<span class="pc bpc" id="L3183" title="1 of 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="fc" id="L3184">            logger.debug(&quot;Node {} state {}, token {}&quot;, endpoint, status, tokens);</span>

<span class="fc bfc" id="L3186" title="All 2 branches covered.">        if (tokenMetadata.isMember(endpoint))</span>
<span class="fc" id="L3187">            logger.info(&quot;Node {} state jump to {}&quot;, endpoint, status);</span>

<span class="pc bpc" id="L3189" title="3 of 4 branches missed.">        if (tokens.isEmpty() &amp;&amp; status.equals(VersionedValue.STATUS_NORMAL))</span>
<span class="nc" id="L3190">            logger.error(&quot;Node {} is in state normal but it has no tokens, state: {}&quot;,</span>
                         endpoint,
<span class="nc" id="L3192">                         Gossiper.instance.getEndpointStateForEndpoint(endpoint));</span>

<span class="fc" id="L3194">        Optional&lt;InetAddressAndPort&gt; replacingNode = tokenMetadata.getReplacingNode(endpoint);</span>
<span class="pc bpc" id="L3195" title="1 of 2 branches missed.">        if (replacingNode.isPresent())</span>
        {
<span class="nc bnc" id="L3197" title="All 2 branches missed.">            assert !endpoint.equals(replacingNode.get()) : &quot;Pending replacement endpoint with same address is not supported&quot;;</span>
<span class="nc" id="L3198">            logger.info(&quot;Node {} will complete replacement of {} for tokens {}&quot;, endpoint, replacingNode.get(), tokens);</span>
<span class="nc bnc" id="L3199" title="All 2 branches missed.">            if (FailureDetector.instance.isAlive(replacingNode.get()))</span>
            {
<span class="nc" id="L3201">                logger.error(&quot;Node {} cannot complete replacement of alive node {}.&quot;, endpoint, replacingNode.get());</span>
<span class="nc" id="L3202">                return;</span>
            }
<span class="nc" id="L3204">            endpointsToRemove.add(replacingNode.get());</span>
        }

<span class="fc" id="L3207">        Optional&lt;InetAddressAndPort&gt; replacementNode = tokenMetadata.getReplacementNode(endpoint);</span>
<span class="pc bpc" id="L3208" title="1 of 2 branches missed.">        if (replacementNode.isPresent())</span>
        {
<span class="nc" id="L3210">            logger.warn(&quot;Node {} is currently being replaced by node {}.&quot;, endpoint, replacementNode.get());</span>
        }

<span class="fc" id="L3213">        updatePeerInfo(endpoint);</span>
        // Order Matters, TM.updateHostID() should be called before TM.updateNormalToken(), (see CASSANDRA-4300).
<span class="fc" id="L3215">        UUID hostId = Gossiper.instance.getHostId(endpoint);</span>
<span class="fc" id="L3216">        InetAddressAndPort existing = tokenMetadata.getEndpointForHostId(hostId);</span>
<span class="pc bpc" id="L3217" title="3 of 4 branches missed.">        if (replacing &amp;&amp; isReplacingSameHostAddressAndHostId(hostId))</span>
        {
<span class="nc" id="L3219">            logger.warn(&quot;Not updating token metadata for {} because I am replacing it&quot;, endpoint);</span>
        }
        else
        {
<span class="pc bpc" id="L3223" title="1 of 4 branches missed.">            if (existing != null &amp;&amp; !existing.equals(endpoint))</span>
            {
<span class="nc bnc" id="L3225" title="All 2 branches missed.">                if (existing.equals(FBUtilities.getBroadcastAddressAndPort()))</span>
                {
<span class="nc" id="L3227">                    logger.warn(&quot;Not updating host ID {} for {} because it's mine&quot;, hostId, endpoint);</span>
<span class="nc" id="L3228">                    tokenMetadata.removeEndpoint(endpoint);</span>
<span class="nc" id="L3229">                    endpointsToRemove.add(endpoint);</span>
                }
<span class="nc bnc" id="L3231" title="All 2 branches missed.">                else if (Gossiper.instance.compareEndpointStartup(endpoint, existing) &gt; 0)</span>
                {
<span class="nc" id="L3233">                    logger.warn(&quot;Host ID collision for {} between {} and {}; {} is the new owner&quot;, hostId, existing, endpoint, endpoint);</span>
<span class="nc" id="L3234">                    tokenMetadata.removeEndpoint(existing);</span>
<span class="nc" id="L3235">                    endpointsToRemove.add(existing);</span>
<span class="nc" id="L3236">                    tokenMetadata.updateHostId(hostId, endpoint);</span>
                }
                else
                {
<span class="nc" id="L3240">                    logger.warn(&quot;Host ID collision for {} between {} and {}; ignored {}&quot;, hostId, existing, endpoint, endpoint);</span>
<span class="nc" id="L3241">                    tokenMetadata.removeEndpoint(endpoint);</span>
<span class="nc" id="L3242">                    endpointsToRemove.add(endpoint);</span>
                }
            }
            else
<span class="fc" id="L3246">                tokenMetadata.updateHostId(hostId, endpoint);</span>
        }

        // capture because updateNormalTokens clears moving and member status
<span class="fc" id="L3250">        boolean isMember = tokenMetadata.isMember(endpoint);</span>
<span class="fc" id="L3251">        boolean isMoving = tokenMetadata.isMoving(endpoint);</span>

<span class="fc" id="L3253">        updateTokenMetadata(endpoint, tokens, endpointsToRemove);</span>

<span class="pc bpc" id="L3255" title="1 of 4 branches missed.">        if (isMoving || operationMode == Mode.MOVING)</span>
        {
<span class="fc" id="L3257">            tokenMetadata.removeFromMoving(endpoint);</span>
            // The above may change the local ownership.
<span class="fc" id="L3259">            invalidateLocalRanges();</span>
<span class="fc" id="L3260">            notifyMoved(endpoint);</span>
        }
<span class="fc bfc" id="L3262" title="All 2 branches covered.">        else if (!isMember) // prior to this, the node was not a member</span>
        {
<span class="fc" id="L3264">            notifyJoined(endpoint);</span>
        }

<span class="fc" id="L3267">        PendingRangeCalculatorService.instance.update();</span>
<span class="fc" id="L3268">    }</span>

    /**
     * Handle node preparing to leave the ring
     *
     * @param endpoint node
     */
    private void handleStateLeaving(InetAddressAndPort endpoint)
    {
        // If the node is previously unknown or tokens do not match, update tokenmetadata to
        // have this node as 'normal' (it must have been using this token before the
        // leave). This way we'll get pending ranges right.

<span class="fc" id="L3281">        ensureUpToDateTokenMetadata(VersionedValue.STATUS_LEAVING, endpoint);</span>

        // at this point the endpoint is certainly a member with this token, so let's proceed
        // normally
<span class="fc" id="L3285">        tokenMetadata.addLeavingEndpoint(endpoint);</span>
<span class="fc" id="L3286">        PendingRangeCalculatorService.instance.update();</span>
<span class="fc" id="L3287">    }</span>

    /**
     * Handle node leaving the ring. This will happen when a node is decommissioned
     *
     * @param endpoint If reason for leaving is decommission, endpoint is the leaving node.
     * @param pieces STATE_LEFT,token
     */
    private void handleStateLeft(InetAddressAndPort endpoint, String[] pieces)
    {
<span class="pc bpc" id="L3297" title="1 of 2 branches missed.">        assert pieces.length &gt;= 2;</span>
<span class="fc" id="L3298">        Collection&lt;Token&gt; tokens = getTokensFor(endpoint);</span>

<span class="pc bpc" id="L3300" title="1 of 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="fc" id="L3301">            logger.debug(&quot;Node {} state left, tokens {}&quot;, endpoint, tokens);</span>

<span class="fc" id="L3303">        excise(tokens, endpoint, extractExpireTime(pieces));</span>
<span class="fc" id="L3304">    }</span>

    /**
     * Handle node moving inside the ring.
     *
     * @param endpoint moving endpoint address
     * @param pieces STATE_MOVING, token
     */
    private void handleStateMoving(InetAddressAndPort endpoint, String[] pieces)
    {
<span class="fc" id="L3314">        ensureUpToDateTokenMetadata(VersionedValue.STATUS_MOVING, endpoint);</span>

<span class="pc bpc" id="L3316" title="1 of 2 branches missed.">        assert pieces.length &gt;= 2;</span>
<span class="fc" id="L3317">        Token token = getTokenFactory().fromString(pieces[1]);</span>

<span class="pc bpc" id="L3319" title="1 of 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="fc" id="L3320">            logger.debug(&quot;Node {} state moving, new token {}&quot;, endpoint, token);</span>

<span class="fc" id="L3322">        tokenMetadata.addMovingEndpoint(token, endpoint);</span>

<span class="fc" id="L3324">        PendingRangeCalculatorService.instance.update();</span>
<span class="fc" id="L3325">    }</span>

    /**
     * Handle notification that a node being actively removed from the ring via 'removenode'
     *
     * @param endpoint node
     * @param pieces either REMOVED_TOKEN (node is gone) or REMOVING_TOKEN (replicas need to be restored)
     */
    private void handleStateRemoving(InetAddressAndPort endpoint, String[] pieces)
    {
<span class="pc bpc" id="L3335" title="1 of 2 branches missed.">        assert (pieces.length &gt; 0);</span>

<span class="pc bpc" id="L3337" title="1 of 2 branches missed.">        if (endpoint.equals(FBUtilities.getBroadcastAddressAndPort()))</span>
        {
<span class="nc" id="L3339">            logger.info(&quot;Received removenode gossip about myself. Is this node rejoining after an explicit removenode?&quot;);</span>
            try
            {
<span class="nc" id="L3342">                drain();</span>
            }
<span class="nc" id="L3344">            catch (Exception e)</span>
            {
<span class="nc" id="L3346">                throw new RuntimeException(e);</span>
<span class="nc" id="L3347">            }</span>
<span class="nc" id="L3348">            return;</span>
        }
<span class="pc bpc" id="L3350" title="1 of 2 branches missed.">        if (tokenMetadata.isMember(endpoint))</span>
        {
<span class="nc" id="L3352">            String state = pieces[0];</span>
<span class="nc" id="L3353">            Collection&lt;Token&gt; removeTokens = tokenMetadata.getTokens(endpoint);</span>

<span class="nc bnc" id="L3355" title="All 2 branches missed.">            if (VersionedValue.REMOVED_TOKEN.equals(state))</span>
            {
<span class="nc" id="L3357">                excise(removeTokens, endpoint, extractExpireTime(pieces));</span>
            }
<span class="nc bnc" id="L3359" title="All 2 branches missed.">            else if (VersionedValue.REMOVING_TOKEN.equals(state))</span>
            {
<span class="nc" id="L3361">                ensureUpToDateTokenMetadata(state, endpoint);</span>

<span class="nc bnc" id="L3363" title="All 2 branches missed.">                if (logger.isDebugEnabled())</span>
<span class="nc" id="L3364">                    logger.debug(&quot;Tokens {} removed manually (endpoint was {})&quot;, removeTokens, endpoint);</span>

                // Note that the endpoint is being removed
<span class="nc" id="L3367">                tokenMetadata.addLeavingEndpoint(endpoint);</span>
<span class="nc" id="L3368">                PendingRangeCalculatorService.instance.update();</span>

                // find the endpoint coordinating this removal that we need to notify when we're done
<span class="nc" id="L3371">                String[] coordinator = splitValue(Gossiper.instance.getEndpointStateForEndpoint(endpoint).getApplicationState(ApplicationState.REMOVAL_COORDINATOR));</span>
<span class="nc" id="L3372">                UUID hostId = UUID.fromString(coordinator[1]);</span>
                // grab any data we are now responsible for and notify responsible node
<span class="nc" id="L3374">                restoreReplicaCount(endpoint, tokenMetadata.getEndpointForHostId(hostId));</span>
            }
<span class="nc" id="L3376">        }</span>
        else // now that the gossiper has told us about this nonexistent member, notify the gossiper to remove it
        {
<span class="pc bpc" id="L3379" title="1 of 2 branches missed.">            if (VersionedValue.REMOVED_TOKEN.equals(pieces[0]))</span>
<span class="nc" id="L3380">                addExpireTimeIfFound(endpoint, extractExpireTime(pieces));</span>
<span class="fc" id="L3381">            removeEndpoint(endpoint);</span>
        }
<span class="fc" id="L3383">    }</span>

    private void excise(Collection&lt;Token&gt; tokens, InetAddressAndPort endpoint)
    {
<span class="fc" id="L3387">        logger.info(&quot;Removing tokens {} for {}&quot;, tokens, endpoint);</span>

<span class="fc" id="L3389">        UUID hostId = tokenMetadata.getHostId(endpoint);</span>
<span class="pc bpc" id="L3390" title="1 of 4 branches missed.">        if (hostId != null &amp;&amp; tokenMetadata.isMember(endpoint))</span>
        {
            // enough time for writes to expire and MessagingService timeout reporter callback to fire, which is where
            // hints are mostly written from - using getMinRpcTimeout() / 2 for the interval.
<span class="fc" id="L3394">            long delay = DatabaseDescriptor.getMinRpcTimeout(MILLISECONDS) + DatabaseDescriptor.getWriteRpcTimeout(MILLISECONDS);</span>
<span class="pc" id="L3395">            ScheduledExecutors.optionalTasks.schedule(() -&gt; HintsService.instance.excise(hostId), delay, MILLISECONDS);</span>
        }

<span class="fc" id="L3398">        removeEndpoint(endpoint);</span>
<span class="fc" id="L3399">        tokenMetadata.removeEndpoint(endpoint);</span>
<span class="pc bpc" id="L3400" title="1 of 2 branches missed.">        if (!tokens.isEmpty())</span>
<span class="fc" id="L3401">            tokenMetadata.removeBootstrapTokens(tokens);</span>
<span class="fc" id="L3402">        notifyLeft(endpoint);</span>
<span class="fc" id="L3403">        PendingRangeCalculatorService.instance.update();</span>
<span class="fc" id="L3404">    }</span>

    private void excise(Collection&lt;Token&gt; tokens, InetAddressAndPort endpoint, long expireTime)
    {
<span class="fc" id="L3408">        addExpireTimeIfFound(endpoint, expireTime);</span>
<span class="fc" id="L3409">        excise(tokens, endpoint);</span>
<span class="fc" id="L3410">    }</span>

    /** unlike excise we just need this endpoint gone without going through any notifications **/
    private void removeEndpoint(InetAddressAndPort endpoint)
    {
<span class="fc" id="L3415">        Gossiper.runInGossipStageBlocking(() -&gt; Gossiper.instance.removeEndpoint(endpoint));</span>
<span class="fc" id="L3416">        SystemKeyspace.removeEndpoint(endpoint);</span>
<span class="fc" id="L3417">    }</span>

    protected void addExpireTimeIfFound(InetAddressAndPort endpoint, long expireTime)
    {
<span class="pc bpc" id="L3421" title="1 of 2 branches missed.">        if (expireTime != 0L)</span>
        {
<span class="fc" id="L3423">            Gossiper.instance.addExpireTimeForEndpoint(endpoint, expireTime);</span>
        }
<span class="fc" id="L3425">    }</span>

    protected long extractExpireTime(String[] pieces)
    {
<span class="fc" id="L3429">        return Long.parseLong(pieces[2]);</span>
    }

    /**
     * Finds living endpoints responsible for the given ranges
     *
     * @param keyspaceName the keyspace ranges belong to
     * @param leavingReplicas the ranges to find sources for
     * @return multimap of addresses to ranges the address is responsible for
     */
    private Multimap&lt;InetAddressAndPort, FetchReplica&gt; getNewSourceReplicas(String keyspaceName, Set&lt;LeavingReplica&gt; leavingReplicas)
    {
<span class="nc" id="L3441">        InetAddressAndPort myAddress = FBUtilities.getBroadcastAddressAndPort();</span>
<span class="nc" id="L3442">        EndpointsByRange rangeReplicas = Keyspace.open(keyspaceName).getReplicationStrategy().getRangeAddresses(tokenMetadata.cloneOnlyTokenMap());</span>
<span class="nc" id="L3443">        Multimap&lt;InetAddressAndPort, FetchReplica&gt; sourceRanges = HashMultimap.create();</span>
<span class="nc" id="L3444">        IFailureDetector failureDetector = FailureDetector.instance;</span>

<span class="nc" id="L3446">        logger.debug(&quot;Getting new source replicas for {}&quot;, leavingReplicas);</span>

        // find alive sources for our new ranges
<span class="nc bnc" id="L3449" title="All 2 branches missed.">        for (LeavingReplica leaver : leavingReplicas)</span>
        {
            //We need this to find the replicas from before leaving to supply the data
<span class="nc" id="L3452">            Replica leavingReplica = leaver.leavingReplica;</span>
            //We need this to know what to fetch and what the transient status is
<span class="nc" id="L3454">            Replica ourReplica = leaver.ourReplica;</span>
            //If we are going to be a full replica only consider full replicas
<span class="nc bnc" id="L3456" title="All 2 branches missed.">            Predicate&lt;Replica&gt; replicaFilter = ourReplica.isFull() ? Replica::isFull : Predicates.alwaysTrue();</span>
<span class="nc bnc" id="L3457" title="All 2 branches missed.">            Predicate&lt;Replica&gt; notSelf = replica -&gt; !replica.endpoint().equals(myAddress);</span>
<span class="nc" id="L3458">            EndpointsForRange possibleReplicas = rangeReplicas.get(leavingReplica.range());</span>
<span class="nc" id="L3459">            logger.info(&quot;Possible replicas for newReplica {} are {}&quot;, ourReplica, possibleReplicas);</span>
<span class="nc" id="L3460">            IEndpointSnitch snitch = DatabaseDescriptor.getEndpointSnitch();</span>
<span class="nc" id="L3461">            EndpointsForRange sortedPossibleReplicas = snitch.sortedByProximity(myAddress, possibleReplicas);</span>
<span class="nc" id="L3462">            logger.info(&quot;Sorted possible replicas starts as {}&quot;, sortedPossibleReplicas);</span>
<span class="nc" id="L3463">            Optional&lt;Replica&gt; myCurrentReplica = tryFind(possibleReplicas, replica -&gt; replica.endpoint().equals(myAddress)).toJavaUtil();</span>

<span class="nc bnc" id="L3465" title="All 6 branches missed.">            boolean transientToFull = myCurrentReplica.isPresent() &amp;&amp; myCurrentReplica.get().isTransient() &amp;&amp; ourReplica.isFull();</span>
<span class="nc bnc" id="L3466" title="All 4 branches missed.">            assert !sortedPossibleReplicas.endpoints().contains(myAddress) || transientToFull : String.format(&quot;My address %s, sortedPossibleReplicas %s, myCurrentReplica %s, myNewReplica %s&quot;, myAddress, sortedPossibleReplicas, myCurrentReplica, ourReplica);</span>

            //Originally this didn't log if it couldn't restore replication and that seems wrong
<span class="nc" id="L3469">            boolean foundLiveReplica = false;</span>
<span class="nc bnc" id="L3470" title="All 2 branches missed.">            for (Replica possibleReplica : sortedPossibleReplicas.filter(Predicates.and(replicaFilter, notSelf)))</span>
            {
<span class="nc bnc" id="L3472" title="All 2 branches missed.">                if (failureDetector.isAlive(possibleReplica.endpoint()))</span>
                {
<span class="nc" id="L3474">                    foundLiveReplica = true;</span>
<span class="nc" id="L3475">                    sourceRanges.put(possibleReplica.endpoint(), new FetchReplica(ourReplica, possibleReplica));</span>
<span class="nc" id="L3476">                    break;</span>
                }
                else
                {
<span class="nc" id="L3480">                    logger.debug(&quot;Skipping down replica {}&quot;, possibleReplica);</span>
                }
<span class="nc" id="L3482">            }</span>
<span class="nc bnc" id="L3483" title="All 2 branches missed.">            if (!foundLiveReplica)</span>
            {
<span class="nc" id="L3485">                logger.warn(&quot;Didn't find live replica to restore replication for &quot; + ourReplica);</span>
            }
<span class="nc" id="L3487">        }</span>
<span class="nc" id="L3488">        return sourceRanges;</span>
    }

    /**
     * Sends a notification to a node indicating we have finished replicating data.
     *
     * @param remote node to send notification to
     */
    private void sendReplicationNotification(InetAddressAndPort remote)
    {
        // notify the remote token
<span class="fc" id="L3499">        Message msg = Message.out(REPLICATION_DONE_REQ, noPayload);</span>
<span class="fc" id="L3500">        IFailureDetector failureDetector = FailureDetector.instance;</span>
<span class="pc bpc" id="L3501" title="1 of 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="fc" id="L3502">            logger.debug(&quot;Notifying {} of replication completion\n&quot;, remote);</span>
<span class="pc bpc" id="L3503" title="1 of 2 branches missed.">        while (failureDetector.isAlive(remote))</span>
        {
<span class="fc" id="L3505">            AsyncOneResponse ior = new AsyncOneResponse();</span>
<span class="fc" id="L3506">            MessagingService.instance().sendWithCallback(msg, remote, ior);</span>

<span class="pc bpc" id="L3508" title="1 of 2 branches missed.">            if (!ior.awaitUninterruptibly(DatabaseDescriptor.getRpcTimeout(NANOSECONDS), NANOSECONDS))</span>
<span class="nc" id="L3509">                continue; // try again if we timeout</span>

<span class="pc bpc" id="L3511" title="1 of 2 branches missed.">            if (!ior.isSuccess())</span>
<span class="nc" id="L3512">                throw new AssertionError(ior.cause());</span>

<span class="fc" id="L3514">            return;</span>
        }
<span class="nc" id="L3516">    }</span>

    private static class LeavingReplica
    {
        //The node that is leaving
        private final Replica leavingReplica;

        //Our range and transient status
        private final Replica ourReplica;

        public LeavingReplica(Replica leavingReplica, Replica ourReplica)
<span class="nc" id="L3527">        {</span>
<span class="nc" id="L3528">            Preconditions.checkNotNull(leavingReplica);</span>
<span class="nc" id="L3529">            Preconditions.checkNotNull(ourReplica);</span>
<span class="nc" id="L3530">            this.leavingReplica = leavingReplica;</span>
<span class="nc" id="L3531">            this.ourReplica = ourReplica;</span>
<span class="nc" id="L3532">        }</span>

        public boolean equals(Object o)
        {
<span class="nc bnc" id="L3536" title="All 2 branches missed.">            if (this == o) return true;</span>
<span class="nc bnc" id="L3537" title="All 4 branches missed.">            if (o == null || getClass() != o.getClass()) return false;</span>

<span class="nc" id="L3539">            LeavingReplica that = (LeavingReplica) o;</span>

<span class="nc bnc" id="L3541" title="All 2 branches missed.">            if (!leavingReplica.equals(that.leavingReplica)) return false;</span>
<span class="nc" id="L3542">            return ourReplica.equals(that.ourReplica);</span>
        }

        public int hashCode()
        {
<span class="nc" id="L3547">            int result = leavingReplica.hashCode();</span>
<span class="nc" id="L3548">            result = 31 * result + ourReplica.hashCode();</span>
<span class="nc" id="L3549">            return result;</span>
        }

        public String toString()
        {
<span class="nc" id="L3554">            return &quot;LeavingReplica{&quot; +</span>
                   &quot;leavingReplica=&quot; + leavingReplica +
                   &quot;, ourReplica=&quot; + ourReplica +
                   '}';
        }
    }

    /**
     * Called when an endpoint is removed from the ring. This function checks
     * whether this node becomes responsible for new ranges as a
     * consequence and streams data if needed.
     *
     * This is rather ineffective, but it does not matter so much
     * since this is called very seldom
     *
     * @param endpoint the node that left
     */
    private void restoreReplicaCount(InetAddressAndPort endpoint, final InetAddressAndPort notifyEndpoint)
    {
<span class="fc" id="L3573">        Map&lt;String, Multimap&lt;InetAddressAndPort, FetchReplica&gt;&gt; replicasToFetch = new HashMap&lt;&gt;();</span>

<span class="fc" id="L3575">        InetAddressAndPort myAddress = FBUtilities.getBroadcastAddressAndPort();</span>

<span class="pc bpc" id="L3577" title="1 of 2 branches missed.">        for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())</span>
        {
<span class="nc" id="L3579">            logger.debug(&quot;Restoring replica count for keyspace {}&quot;, keyspaceName);</span>
<span class="nc" id="L3580">            EndpointsByReplica changedReplicas = getChangedReplicasForLeaving(keyspaceName, endpoint, tokenMetadata, Keyspace.open(keyspaceName).getReplicationStrategy());</span>
<span class="nc" id="L3581">            Set&lt;LeavingReplica&gt; myNewReplicas = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L3582" title="All 2 branches missed.">            for (Map.Entry&lt;Replica, Replica&gt; entry : changedReplicas.flattenEntries())</span>
            {
<span class="nc" id="L3584">                Replica replica = entry.getValue();</span>
<span class="nc bnc" id="L3585" title="All 2 branches missed.">                if (replica.endpoint().equals(myAddress))</span>
                {
                    //Maybe we don't technically need to fetch transient data from somewhere
                    //but it's probably not a lot and it probably makes things a hair more resilient to people
                    //not running repair when they should.
<span class="nc" id="L3590">                    myNewReplicas.add(new LeavingReplica(entry.getKey(), entry.getValue()));</span>
                }
<span class="nc" id="L3592">            }</span>
<span class="nc" id="L3593">            logger.debug(&quot;Changed replicas for leaving {}, myNewReplicas {}&quot;, changedReplicas, myNewReplicas);</span>
<span class="nc" id="L3594">            replicasToFetch.put(keyspaceName, getNewSourceReplicas(keyspaceName, myNewReplicas));</span>
<span class="nc" id="L3595">        }</span>

<span class="fc" id="L3597">        StreamPlan stream = new StreamPlan(StreamOperation.RESTORE_REPLICA_COUNT);</span>
<span class="fc" id="L3598">        replicasToFetch.forEach((keyspaceName, sources) -&gt; {</span>
<span class="nc" id="L3599">            logger.debug(&quot;Requesting keyspace {} sources&quot;, keyspaceName);</span>
<span class="nc" id="L3600">            sources.asMap().forEach((sourceAddress, fetchReplicas) -&gt; {</span>
<span class="nc" id="L3601">                logger.debug(&quot;Source and our replicas are {}&quot;, fetchReplicas);</span>
                //Remember whether this node is providing the full or transient replicas for this range. We are going
                //to pass streaming the local instance of Replica for the range which doesn't tell us anything about the source
                //By encoding it as two separate sets we retain this information about the source.
<span class="nc" id="L3605">                RangesAtEndpoint full = fetchReplicas.stream()</span>
<span class="nc" id="L3606">                                                             .filter(f -&gt; f.remote.isFull())</span>
<span class="nc" id="L3607">                                                             .map(f -&gt; f.local)</span>
<span class="nc" id="L3608">                                                             .collect(RangesAtEndpoint.collector(myAddress));</span>
<span class="nc" id="L3609">                RangesAtEndpoint transientReplicas = fetchReplicas.stream()</span>
<span class="nc" id="L3610">                                                                  .filter(f -&gt; f.remote.isTransient())</span>
<span class="nc" id="L3611">                                                                  .map(f -&gt; f.local)</span>
<span class="nc" id="L3612">                                                                  .collect(RangesAtEndpoint.collector(myAddress));</span>
<span class="nc bnc" id="L3613" title="All 2 branches missed.">                if (logger.isDebugEnabled())</span>
<span class="nc" id="L3614">                    logger.debug(&quot;Requesting from {} full replicas {} transient replicas {}&quot;, sourceAddress, StringUtils.join(full, &quot;, &quot;), StringUtils.join(transientReplicas, &quot;, &quot;));</span>

<span class="nc" id="L3616">                stream.requestRanges(sourceAddress, keyspaceName, full, transientReplicas);</span>
<span class="nc" id="L3617">            });</span>
<span class="nc" id="L3618">        });</span>
<span class="fc" id="L3619">        StreamResultFuture future = stream.execute();</span>
<span class="fc" id="L3620">        future.addCallback(new FutureCallback&lt;StreamState&gt;()</span>
<span class="fc" id="L3621">        {</span>
            public void onSuccess(StreamState finalState)
            {
<span class="fc" id="L3624">                sendReplicationNotification(notifyEndpoint);</span>
<span class="fc" id="L3625">            }</span>

            public void onFailure(Throwable t)
            {
<span class="nc" id="L3629">                logger.warn(&quot;Streaming to restore replica count failed&quot;, t);</span>
                // We still want to send the notification
<span class="nc" id="L3631">                sendReplicationNotification(notifyEndpoint);</span>
<span class="nc" id="L3632">            }</span>
        });
<span class="fc" id="L3634">    }</span>

    /**
     * This is used in three contexts, graceful decomission, and restoreReplicaCount/removeNode.
     * Graceful decomission should never lose data and it's going to be important that transient data
     * is streamed to at least one other node from this one for each range.
     *
     * For ranges this node replicates its removal should cause a new replica to be selected either as transient or full
     * for every range. So I believe the current code doesn't have to do anything special because it will engage in streaming
     * for every range it replicates to at least one other node and that should propagate the transient data that was here.
     * When I graphed this out on paper the result of removal looked correct and there are no issues such as
     * this node needing to create a full replica for a range it transiently replicates because what is created is just another
     * transient replica to replace this node.
     * @param keyspaceName
     * @param endpoint
     * @return
     */
    // needs to be modified to accept either a keyspace or ARS.
    static EndpointsByReplica getChangedReplicasForLeaving(String keyspaceName, InetAddressAndPort endpoint, TokenMetadata tokenMetadata, AbstractReplicationStrategy strat)
    {
        // First get all ranges the leaving endpoint is responsible for
<span class="fc" id="L3655">        RangesAtEndpoint replicas = strat.getAddressReplicas(endpoint);</span>

<span class="pc bpc" id="L3657" title="1 of 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="fc" id="L3658">            logger.debug(&quot;Node {} replicas [{}]&quot;, endpoint, StringUtils.join(replicas, &quot;, &quot;));</span>

<span class="fc" id="L3660">        Map&lt;Replica, EndpointsForRange&gt; currentReplicaEndpoints = Maps.newHashMapWithExpectedSize(replicas.size());</span>

        // Find (for each range) all nodes that store replicas for these ranges as well
<span class="fc" id="L3663">        TokenMetadata metadata = tokenMetadata.cloneOnlyTokenMap(); // don't do this in the loop! #7758</span>
<span class="fc bfc" id="L3664" title="All 2 branches covered.">        for (Replica replica : replicas)</span>
<span class="fc" id="L3665">            currentReplicaEndpoints.put(replica, strat.calculateNaturalReplicas(replica.range().right, metadata));</span>

<span class="fc" id="L3667">        TokenMetadata temp = tokenMetadata.cloneAfterAllLeft();</span>

        // endpoint might or might not be 'leaving'. If it was not leaving (that is, removenode
        // command was used), it is still present in temp and must be removed.
<span class="pc bpc" id="L3671" title="1 of 2 branches missed.">        if (temp.isMember(endpoint))</span>
<span class="nc" id="L3672">            temp.removeEndpoint(endpoint);</span>

<span class="fc" id="L3674">        EndpointsByReplica.Builder changedRanges = new EndpointsByReplica.Builder();</span>

        // Go through the ranges and for each range check who will be
        // storing replicas for these ranges when the leaving endpoint
        // is gone. Whoever is present in newReplicaEndpoints list, but
        // not in the currentReplicaEndpoints list, will be needing the
        // range.
<span class="fc bfc" id="L3681" title="All 2 branches covered.">        for (Replica replica : replicas)</span>
        {
<span class="fc" id="L3683">            EndpointsForRange newReplicaEndpoints = strat.calculateNaturalReplicas(replica.range().right, temp);</span>
<span class="fc" id="L3684">            newReplicaEndpoints = newReplicaEndpoints.filter(newReplica -&gt; {</span>
<span class="fc" id="L3685">                Optional&lt;Replica&gt; currentReplicaOptional =</span>
<span class="fc" id="L3686">                    tryFind(currentReplicaEndpoints.get(replica),</span>
<span class="fc" id="L3687">                            currentReplica -&gt; newReplica.endpoint().equals(currentReplica.endpoint())</span>
<span class="fc" id="L3688">                    ).toJavaUtil();</span>
                //If it is newly replicating then yes we must do something to get the data there
<span class="fc bfc" id="L3690" title="All 2 branches covered.">                if (!currentReplicaOptional.isPresent())</span>
<span class="fc" id="L3691">                    return true;</span>

<span class="fc" id="L3693">                Replica currentReplica = currentReplicaOptional.get();</span>
                //This transition requires streaming to occur
                //Full -&gt; transient is handled by nodetool cleanup
                //transient -&gt; transient and full -&gt; full don't require any action
<span class="pc bpc" id="L3697" title="1 of 4 branches missed.">                if (currentReplica.isTransient() &amp;&amp; newReplica.isFull())</span>
<span class="fc" id="L3698">                    return true;</span>
<span class="fc" id="L3699">                return false;</span>
            });

<span class="pc bpc" id="L3702" title="1 of 2 branches missed.">            if (logger.isDebugEnabled())</span>
<span class="pc bpc" id="L3703" title="1 of 2 branches missed.">                if (newReplicaEndpoints.isEmpty())</span>
<span class="nc" id="L3704">                    logger.debug(&quot;Replica {} already in all replicas&quot;, replica);</span>
                else
<span class="fc" id="L3706">                    logger.debug(&quot;Replica {} will be responsibility of {}&quot;, replica, StringUtils.join(newReplicaEndpoints, &quot;, &quot;));</span>
<span class="fc" id="L3707">            changedRanges.putAll(replica, newReplicaEndpoints, Conflict.NONE);</span>
<span class="fc" id="L3708">        }</span>

<span class="fc" id="L3710">        return changedRanges.build();</span>
    }


    public void onJoin(InetAddressAndPort endpoint, EndpointState epState)
    {
        // Explicitly process STATUS or STATUS_WITH_PORT before the other
        // application states to maintain pre-4.0 semantics with the order
        // they are processed.  Otherwise the endpoint will not be added
        // to TokenMetadata so non-STATUS* appstates will be ignored.
<span class="fc" id="L3720">        ApplicationState statusState = ApplicationState.STATUS_WITH_PORT;</span>
        VersionedValue statusValue;
<span class="fc" id="L3722">        statusValue = epState.getApplicationState(statusState);</span>
<span class="pc bpc" id="L3723" title="1 of 2 branches missed.">        if (statusValue == null)</span>
        {
<span class="fc" id="L3725">            statusState = ApplicationState.STATUS;</span>
<span class="fc" id="L3726">            statusValue = epState.getApplicationState(statusState);</span>
        }
<span class="pc bpc" id="L3728" title="1 of 2 branches missed.">        if (statusValue != null)</span>
<span class="fc" id="L3729">            Gossiper.instance.doOnChangeNotifications(endpoint, statusState, statusValue);</span>

<span class="fc bfc" id="L3731" title="All 2 branches covered.">        for (Map.Entry&lt;ApplicationState, VersionedValue&gt; entry : epState.states())</span>
        {
<span class="pc bpc" id="L3733" title="1 of 4 branches missed.">            if (entry.getKey() == ApplicationState.STATUS_WITH_PORT || entry.getKey() == ApplicationState.STATUS)</span>
<span class="fc" id="L3734">                continue;</span>
<span class="fc" id="L3735">            Gossiper.instance.doOnChangeNotifications(endpoint, entry.getKey(), entry.getValue());</span>
<span class="fc" id="L3736">        }</span>
<span class="fc" id="L3737">    }</span>

    public void onAlive(InetAddressAndPort endpoint, EndpointState state)
    {
<span class="nc bnc" id="L3741" title="All 2 branches missed.">        if (tokenMetadata.isMember(endpoint))</span>
<span class="nc" id="L3742">            notifyUp(endpoint);</span>
<span class="nc" id="L3743">    }</span>

    public void onRemove(InetAddressAndPort endpoint)
    {
<span class="fc" id="L3747">        tokenMetadata.removeEndpoint(endpoint);</span>
<span class="fc" id="L3748">        PendingRangeCalculatorService.instance.update();</span>
<span class="fc" id="L3749">    }</span>

    public void onDead(InetAddressAndPort endpoint, EndpointState state)
    {
        // interrupt any outbound connection; if the node is failing and we cannot reconnect,
        // this will rapidly lower the number of bytes we are willing to queue to the node
<span class="nc" id="L3755">        MessagingService.instance().interruptOutbound(endpoint);</span>
<span class="nc" id="L3756">        notifyDown(endpoint);</span>
<span class="nc" id="L3757">    }</span>

    public void onRestart(InetAddressAndPort endpoint, EndpointState state)
    {
        // If we have restarted before the node was even marked down, we need to reset the connection pool
<span class="nc bnc" id="L3762" title="All 2 branches missed.">        if (state.isAlive())</span>
<span class="nc" id="L3763">            onDead(endpoint, state);</span>

        // Then, the node may have been upgraded and changed its messaging protocol version. If so, we
        // want to update that before we mark the node live again to avoid problems like CASSANDRA-11128.
<span class="nc" id="L3767">        VersionedValue netVersion = state.getApplicationState(ApplicationState.NET_VERSION);</span>
<span class="nc bnc" id="L3768" title="All 2 branches missed.">        if (netVersion != null)</span>
<span class="nc" id="L3769">            updateNetVersion(endpoint, netVersion);</span>
<span class="nc" id="L3770">    }</span>

    @Override
    public String getLoadString()
    {
<span class="fc" id="L3775">        return FileUtils.stringifyFileSize(StorageMetrics.load.getCount());</span>
    }

    @Override
    public String getUncompressedLoadString()
    {
<span class="nc" id="L3781">        return FileUtils.stringifyFileSize(StorageMetrics.uncompressedLoad.getCount());</span>
    }

    public Map&lt;String, String&gt; getLoadMapWithPort()
    {
<span class="fc" id="L3786">        return getLoadMap(true);</span>
    }

    public Map&lt;String, String&gt; getLoadMap()
    {
<span class="nc" id="L3791">        return getLoadMap(false);</span>
    }

    private Map&lt;String, String&gt; getLoadMap(boolean withPort)
    {
<span class="fc" id="L3796">        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L3797" title="All 2 branches covered.">        for (Map.Entry&lt;InetAddressAndPort,Double&gt; entry : LoadBroadcaster.instance.getLoadInfo().entrySet())</span>
        {
<span class="fc" id="L3799">            map.put(entry.getKey().getHostAddress(withPort), FileUtils.stringifyFileSize(entry.getValue()));</span>
<span class="fc" id="L3800">        }</span>
        // gossiper doesn't see its own updates, so we need to special-case the local node
<span class="fc" id="L3802">        map.put(FBUtilities.getBroadcastAddressAndPort().getHostAddress(withPort), getLoadString());</span>
<span class="fc" id="L3803">        return map;</span>
    }

    // TODO
    public final void deliverHints(String host)
    {
<span class="nc" id="L3809">        throw new UnsupportedOperationException();</span>
    }

    public Collection&lt;Token&gt; getLocalTokens()
    {
<span class="fc" id="L3814">        Collection&lt;Token&gt; tokens = SystemKeyspace.getSavedTokens();</span>
<span class="pc bpc" id="L3815" title="2 of 4 branches missed.">        assert tokens != null &amp;&amp; !tokens.isEmpty(); // should not be called before initServer sets this</span>
<span class="fc" id="L3816">        return tokens;</span>
    }

    @Nullable
    public InetAddressAndPort getEndpointForHostId(UUID hostId)
    {
<span class="fc" id="L3822">        return tokenMetadata.getEndpointForHostId(hostId);</span>
    }

    @Nullable
    public UUID getHostIdForEndpoint(InetAddressAndPort address)
    {
<span class="fc" id="L3828">        return tokenMetadata.getHostId(address);</span>
    }

    /* These methods belong to the MBean interface */

    public List&lt;String&gt; getTokens()
    {
<span class="fc" id="L3835">        return getTokens(FBUtilities.getBroadcastAddressAndPort());</span>
    }

    public List&lt;String&gt; getTokens(String endpoint) throws UnknownHostException
    {
<span class="nc" id="L3840">        return getTokens(InetAddressAndPort.getByName(endpoint));</span>
    }

    private List&lt;String&gt; getTokens(InetAddressAndPort endpoint)
    {
<span class="fc" id="L3845">        List&lt;String&gt; strTokens = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L3846" title="All 2 branches covered.">        for (Token tok : getTokenMetadata().getTokens(endpoint))</span>
<span class="fc" id="L3847">            strTokens.add(tok.toString());</span>
<span class="fc" id="L3848">        return strTokens;</span>
    }

    public String getReleaseVersion()
    {
<span class="nc" id="L3853">        return FBUtilities.getReleaseVersionString();</span>
    }

    @Override
    public String getGitSHA()
    {
<span class="nc" id="L3859">        return FBUtilities.getGitSHA();</span>
    }

    public String getSchemaVersion()
    {
<span class="nc" id="L3864">        return Schema.instance.getVersion().toString();</span>
    }

    public String getKeyspaceReplicationInfo(String keyspaceName)
    {
<span class="nc" id="L3869">        Keyspace keyspaceInstance = Schema.instance.getKeyspaceInstance(keyspaceName);</span>
<span class="nc bnc" id="L3870" title="All 2 branches missed.">        if (keyspaceInstance == null)</span>
<span class="nc" id="L3871">            throw new IllegalArgumentException(); // ideally should never happen</span>
<span class="nc" id="L3872">        ReplicationParams replicationParams = keyspaceInstance.getMetadata().params.replication;</span>
<span class="nc" id="L3873">        String replicationInfo = replicationParams.klass.getSimpleName() + &quot; &quot; + replicationParams.options.toString();</span>
<span class="nc" id="L3874">        return replicationInfo;</span>
    }

    @Deprecated
    public List&lt;String&gt; getLeavingNodes()
    {
<span class="nc" id="L3880">        return stringify(tokenMetadata.getLeavingEndpoints(), false);</span>
    }

    public List&lt;String&gt; getLeavingNodesWithPort()
    {
<span class="fc" id="L3885">        return stringify(tokenMetadata.getLeavingEndpoints(), true);</span>
    }

    @Deprecated
    public List&lt;String&gt; getMovingNodes()
    {
<span class="nc" id="L3891">        List&lt;String&gt; endpoints = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L3893" title="All 2 branches missed.">        for (Pair&lt;Token, InetAddressAndPort&gt; node : tokenMetadata.getMovingEndpoints())</span>
        {
<span class="nc" id="L3895">            endpoints.add(node.right.getAddress().getHostAddress());</span>
<span class="nc" id="L3896">        }</span>

<span class="nc" id="L3898">        return endpoints;</span>
    }

    public List&lt;String&gt; getMovingNodesWithPort()
    {
<span class="fc" id="L3903">        List&lt;String&gt; endpoints = new ArrayList&lt;&gt;();</span>

<span class="pc bpc" id="L3905" title="1 of 2 branches missed.">        for (Pair&lt;Token, InetAddressAndPort&gt; node : tokenMetadata.getMovingEndpoints())</span>
        {
<span class="nc" id="L3907">            endpoints.add(node.right.getHostAddressAndPort());</span>
<span class="nc" id="L3908">        }</span>

<span class="fc" id="L3910">        return endpoints;</span>
    }

    @Deprecated
    public List&lt;String&gt; getJoiningNodes()
    {
<span class="nc" id="L3916">        return stringify(tokenMetadata.getBootstrapTokens().valueSet(), false);</span>
    }

    public List&lt;String&gt; getJoiningNodesWithPort()
    {
<span class="fc" id="L3921">        return stringify(tokenMetadata.getBootstrapTokens().valueSet(), true);</span>
    }

    @Deprecated
    public List&lt;String&gt; getLiveNodes()
    {
<span class="nc" id="L3927">        return stringify(Gossiper.instance.getLiveMembers(), false);</span>
    }

    public List&lt;String&gt; getLiveNodesWithPort()
    {
<span class="fc" id="L3932">        return stringify(Gossiper.instance.getLiveMembers(), true);</span>
    }

    public Set&lt;InetAddressAndPort&gt; getLiveRingMembers()
    {
<span class="fc" id="L3937">        return getLiveRingMembers(false);</span>
    }

    public Set&lt;InetAddressAndPort&gt; getLiveRingMembers(boolean excludeDeadStates)
    {
<span class="fc" id="L3942">        Set&lt;InetAddressAndPort&gt; ret = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L3943" title="All 2 branches covered.">        for (InetAddressAndPort ep : Gossiper.instance.getLiveMembers())</span>
        {
<span class="fc bfc" id="L3945" title="All 2 branches covered.">            if (excludeDeadStates)</span>
            {
<span class="fc" id="L3947">                EndpointState epState = Gossiper.instance.getEndpointStateForEndpoint(ep);</span>
<span class="pc bpc" id="L3948" title="1 of 4 branches missed.">                if (epState == null || Gossiper.instance.isDeadState(epState))</span>
<span class="nc" id="L3949">                    continue;</span>
            }

<span class="fc bfc" id="L3952" title="All 2 branches covered.">            if (tokenMetadata.isMember(ep))</span>
<span class="fc" id="L3953">                ret.add(ep);</span>
<span class="fc" id="L3954">        }</span>
<span class="fc" id="L3955">        return ret;</span>
    }


    @Deprecated
    public List&lt;String&gt; getUnreachableNodes()
    {
<span class="nc" id="L3962">        return stringify(Gossiper.instance.getUnreachableMembers(), false);</span>
    }

    public List&lt;String&gt; getUnreachableNodesWithPort()
    {
<span class="fc" id="L3967">        return stringify(Gossiper.instance.getUnreachableMembers(), true);</span>
    }

    @Override
    public String[] getAllDataFileLocations()
    {
<span class="nc" id="L3973">        return getCanonicalPaths(DatabaseDescriptor.getAllDataFileLocations());</span>
    }

    private String[] getCanonicalPaths(String[] paths)
    {
<span class="nc" id="L3978">        String[] locations = new String[paths.length];</span>
<span class="nc bnc" id="L3979" title="All 2 branches missed.">        for (int i = 0; i &lt; paths.length; i++)</span>
<span class="nc" id="L3980">            locations[i] = FileUtils.getCanonicalPath(paths[i]);</span>
<span class="nc" id="L3981">        return locations;</span>
    }

    @Override
    public String[] getLocalSystemKeyspacesDataFileLocations()
    {
<span class="nc" id="L3987">        return getCanonicalPaths(DatabaseDescriptor.getLocalSystemKeyspacesDataFileLocations());</span>
    }

    @Override
    public String[] getNonLocalSystemKeyspacesDataFileLocations()
    {
<span class="nc" id="L3993">        return getCanonicalPaths(DatabaseDescriptor.getNonLocalSystemKeyspacesDataFileLocations());</span>
    }

    public String getCommitLogLocation()
    {
<span class="nc" id="L3998">        return FileUtils.getCanonicalPath(DatabaseDescriptor.getCommitLogLocation());</span>
    }

    public String getSavedCachesLocation()
    {
<span class="nc" id="L4003">        return FileUtils.getCanonicalPath(DatabaseDescriptor.getSavedCachesLocation());</span>
    }

    private List&lt;String&gt; stringify(Iterable&lt;InetAddressAndPort&gt; endpoints, boolean withPort)
    {
<span class="fc" id="L4008">        List&lt;String&gt; stringEndpoints = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L4009" title="All 2 branches covered.">        for (InetAddressAndPort ep : endpoints)</span>
        {
<span class="fc" id="L4011">            stringEndpoints.add(ep.getHostAddress(withPort));</span>
<span class="fc" id="L4012">        }</span>
<span class="fc" id="L4013">        return stringEndpoints;</span>
    }

    public int getCurrentGenerationNumber()
    {
<span class="nc" id="L4018">        return Gossiper.instance.getCurrentGenerationNumber(FBUtilities.getBroadcastAddressAndPort());</span>
    }

    public int forceKeyspaceCleanup(String keyspaceName, String... tables) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L4023">        return forceKeyspaceCleanup(0, keyspaceName, tables);</span>
    }

    public int forceKeyspaceCleanup(int jobs, String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc bnc" id="L4028" title="All 2 branches missed.">        if (SchemaConstants.isLocalSystemKeyspace(keyspaceName))</span>
<span class="nc" id="L4029">            throw new RuntimeException(&quot;Cleanup of the system keyspace is neither necessary nor wise&quot;);</span>

<span class="nc bnc" id="L4031" title="All 2 branches missed.">        if (tokenMetadata.getPendingRanges(keyspaceName, getBroadcastAddressAndPort()).size() &gt; 0)</span>
<span class="nc" id="L4032">            throw new RuntimeException(&quot;Node is involved in cluster membership changes. Not safe to run cleanup.&quot;);</span>

<span class="nc" id="L4034">        CompactionManager.AllSSTableOpStatus status = CompactionManager.AllSSTableOpStatus.SUCCESSFUL;</span>
<span class="nc" id="L4035">        logger.info(&quot;Starting {} on {}.{}&quot;, OperationType.CLEANUP, keyspaceName, Arrays.toString(tableNames));</span>
<span class="nc bnc" id="L4036" title="All 2 branches missed.">        for (ColumnFamilyStore cfStore : getValidColumnFamilies(false, false, keyspaceName, tableNames))</span>
        {
<span class="nc" id="L4038">            CompactionManager.AllSSTableOpStatus oneStatus = cfStore.forceCleanup(jobs);</span>
<span class="nc bnc" id="L4039" title="All 2 branches missed.">            if (oneStatus != CompactionManager.AllSSTableOpStatus.SUCCESSFUL)</span>
<span class="nc" id="L4040">                status = oneStatus;</span>
<span class="nc" id="L4041">        }</span>
<span class="nc" id="L4042">        logger.info(&quot;Completed {} with status {}&quot;, OperationType.CLEANUP, status);</span>
<span class="nc" id="L4043">        return status.statusCode;</span>
    }

    public int scrub(boolean disableSnapshot, boolean skipCorrupted, boolean checkData, boolean reinsertOverflowedTTL, int jobs, String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="fc" id="L4048">        IScrubber.Options options = IScrubber.options()</span>
<span class="fc" id="L4049">                                             .skipCorrupted(skipCorrupted)</span>
<span class="fc" id="L4050">                                             .checkData(checkData)</span>
<span class="fc" id="L4051">                                             .reinsertOverflowedTTLRows(reinsertOverflowedTTL)</span>
<span class="fc" id="L4052">                                             .build();</span>
<span class="nc" id="L4053">        return scrub(disableSnapshot, options, jobs, keyspaceName, tableNames);</span>
    }

    public int scrub(boolean disableSnapshot, IScrubber.Options options, int jobs, String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="fc" id="L4058">        CompactionManager.AllSSTableOpStatus status = CompactionManager.AllSSTableOpStatus.SUCCESSFUL;</span>
<span class="fc" id="L4059">        logger.info(&quot;Starting {} on {}.{}&quot;, OperationType.SCRUB, keyspaceName, Arrays.toString(tableNames));</span>
<span class="nc bnc" id="L4060" title="All 2 branches missed.">        for (ColumnFamilyStore cfStore : getValidColumnFamilies(true, false, keyspaceName, tableNames))</span>
        {
<span class="nc" id="L4062">            CompactionManager.AllSSTableOpStatus oneStatus = cfStore.scrub(disableSnapshot, options, jobs);</span>
<span class="nc bnc" id="L4063" title="All 2 branches missed.">            if (oneStatus != CompactionManager.AllSSTableOpStatus.SUCCESSFUL)</span>
<span class="nc" id="L4064">                status = oneStatus;</span>
<span class="nc" id="L4065">        }</span>
<span class="nc" id="L4066">        logger.info(&quot;Completed {} with status {}&quot;, OperationType.SCRUB, status);</span>
<span class="nc" id="L4067">        return status.statusCode;</span>
    }

    @Deprecated
    public int verify(boolean extendedVerify, String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L4073">        return verify(extendedVerify, false, false, false, false, false, keyspaceName, tableNames);</span>
    }

    public int verify(boolean extendedVerify, boolean checkVersion, boolean diskFailurePolicy, boolean mutateRepairStatus, boolean checkOwnsTokens, boolean quick, String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="fc" id="L4078">        CompactionManager.AllSSTableOpStatus status = CompactionManager.AllSSTableOpStatus.SUCCESSFUL;</span>
<span class="fc" id="L4079">        IVerifier.Options options = IVerifier.options().invokeDiskFailurePolicy(diskFailurePolicy)</span>
<span class="fc" id="L4080">                                             .extendedVerification(extendedVerify)</span>
<span class="fc" id="L4081">                                             .checkVersion(checkVersion)</span>
<span class="fc" id="L4082">                                             .mutateRepairStatus(mutateRepairStatus)</span>
<span class="fc" id="L4083">                                             .checkOwnsTokens(checkOwnsTokens)</span>
<span class="fc" id="L4084">                                             .quick(quick).build();</span>
<span class="fc" id="L4085">        logger.info(&quot;Staring {} on {}.{} with options = {}&quot;, OperationType.VERIFY, keyspaceName, Arrays.toString(tableNames), options);</span>
<span class="nc bnc" id="L4086" title="All 2 branches missed.">        for (ColumnFamilyStore cfStore : getValidColumnFamilies(false, false, keyspaceName, tableNames))</span>
        {
<span class="nc" id="L4088">            CompactionManager.AllSSTableOpStatus oneStatus = cfStore.verify(options);</span>
<span class="nc bnc" id="L4089" title="All 2 branches missed.">            if (oneStatus != CompactionManager.AllSSTableOpStatus.SUCCESSFUL)</span>
<span class="nc" id="L4090">                status = oneStatus;</span>
<span class="nc" id="L4091">        }</span>
<span class="nc" id="L4092">        logger.info(&quot;Completed {} with status {}&quot;, OperationType.VERIFY, status);</span>
<span class="nc" id="L4093">        return status.statusCode;</span>
    }

    public int upgradeSSTables(String keyspaceName, boolean excludeCurrentVersion, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="fc" id="L4098">        return upgradeSSTables(keyspaceName, excludeCurrentVersion, 0, tableNames);</span>
    }

    public int upgradeSSTables(String keyspaceName,
                               final boolean skipIfCurrentVersion,
                               final long skipIfNewerThanTimestamp,
                               int jobs,
                               String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="fc" id="L4107">        return rewriteSSTables(keyspaceName, skipIfCurrentVersion, skipIfNewerThanTimestamp, false, jobs, tableNames);</span>
    }

    public int recompressSSTables(String keyspaceName,
                                  int jobs,
                                  String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L4114">        return rewriteSSTables(keyspaceName, false, Long.MAX_VALUE, true, jobs, tableNames);</span>
    }


    public int rewriteSSTables(String keyspaceName,
                               final boolean skipIfCurrentVersion,
                               final long skipIfNewerThanTimestamp,
                               final boolean skipIfCompressionMatches,
                               int jobs,
                               String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="fc" id="L4125">        CompactionManager.AllSSTableOpStatus status = CompactionManager.AllSSTableOpStatus.SUCCESSFUL;</span>
<span class="fc" id="L4126">        logger.info(&quot;Starting {} on {}.{}&quot;, OperationType.UPGRADE_SSTABLES, keyspaceName, Arrays.toString(tableNames));</span>
<span class="fc bfc" id="L4127" title="All 2 branches covered.">        for (ColumnFamilyStore cfStore : getValidColumnFamilies(true, true, keyspaceName, tableNames))</span>
        {
<span class="fc" id="L4129">            CompactionManager.AllSSTableOpStatus oneStatus = cfStore.sstablesRewrite(skipIfCurrentVersion, skipIfNewerThanTimestamp, skipIfCompressionMatches, jobs);</span>
<span class="pc bpc" id="L4130" title="1 of 2 branches missed.">            if (oneStatus != CompactionManager.AllSSTableOpStatus.SUCCESSFUL)</span>
<span class="nc" id="L4131">                status = oneStatus;</span>
<span class="fc" id="L4132">        }</span>
<span class="fc" id="L4133">        logger.info(&quot;Completed {} with status {}&quot;, OperationType.UPGRADE_SSTABLES, status);</span>
<span class="fc" id="L4134">        return status.statusCode;</span>
    }

    public List&lt;Pair&lt;String, String&gt;&gt; getPreparedStatements()
    {
<span class="nc" id="L4139">        List&lt;Pair&lt;String, String&gt;&gt; statements = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L4140" title="All 2 branches missed.">        for (Entry&lt;MD5Digest, QueryHandler.Prepared&gt; e : QueryProcessor.instance.getPreparedStatements().entrySet())</span>
<span class="nc" id="L4141">            statements.add(Pair.create(e.getKey().toString(), e.getValue().rawCQLStatement));</span>
<span class="nc" id="L4142">        return statements;</span>
    }

    public void dropPreparedStatements(boolean memoryOnly)
    {
<span class="nc" id="L4147">        QueryProcessor.instance.clearPreparedStatements(memoryOnly);</span>
<span class="nc" id="L4148">    }</span>


    public void forceKeyspaceCompaction(boolean splitOutput, String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="fc bfc" id="L4153" title="All 2 branches covered.">        for (ColumnFamilyStore cfStore : getValidColumnFamilies(true, false, keyspaceName, tableNames))</span>
        {
<span class="fc" id="L4155">            cfStore.forceMajorCompaction(splitOutput);</span>
<span class="fc" id="L4156">        }</span>
<span class="fc" id="L4157">    }</span>

    public int relocateSSTables(String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L4161">        return relocateSSTables(0, keyspaceName, tableNames);</span>
    }

    public int relocateSSTables(int jobs, String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L4166">        CompactionManager.AllSSTableOpStatus status = CompactionManager.AllSSTableOpStatus.SUCCESSFUL;</span>
<span class="nc" id="L4167">        logger.info(&quot;Starting {} on {}.{}&quot;, OperationType.RELOCATE, keyspaceName, Arrays.toString(tableNames));</span>
<span class="nc bnc" id="L4168" title="All 2 branches missed.">        for (ColumnFamilyStore cfs : getValidColumnFamilies(false, false, keyspaceName, tableNames))</span>
        {
<span class="nc" id="L4170">            CompactionManager.AllSSTableOpStatus oneStatus = cfs.relocateSSTables(jobs);</span>
<span class="nc bnc" id="L4171" title="All 2 branches missed.">            if (oneStatus != CompactionManager.AllSSTableOpStatus.SUCCESSFUL)</span>
<span class="nc" id="L4172">                status = oneStatus;</span>
<span class="nc" id="L4173">        }</span>
<span class="nc" id="L4174">        logger.info(&quot;Completed {} with status {}&quot;, OperationType.RELOCATE, status);</span>
<span class="nc" id="L4175">        return status.statusCode;</span>
    }

    public int garbageCollect(String tombstoneOptionString, int jobs, String keyspaceName, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="fc" id="L4180">        TombstoneOption tombstoneOption = TombstoneOption.valueOf(tombstoneOptionString);</span>
<span class="fc" id="L4181">        CompactionManager.AllSSTableOpStatus status = CompactionManager.AllSSTableOpStatus.SUCCESSFUL;</span>
<span class="fc" id="L4182">        logger.info(&quot;Starting {} on {}.{}&quot;, OperationType.GARBAGE_COLLECT, keyspaceName, Arrays.toString(tableNames));</span>
<span class="fc bfc" id="L4183" title="All 2 branches covered.">        for (ColumnFamilyStore cfs : getValidColumnFamilies(false, false, keyspaceName, tableNames))</span>
        {
<span class="fc" id="L4185">            CompactionManager.AllSSTableOpStatus oneStatus = cfs.garbageCollect(tombstoneOption, jobs);</span>
<span class="pc bpc" id="L4186" title="1 of 2 branches missed.">            if (oneStatus != CompactionManager.AllSSTableOpStatus.SUCCESSFUL)</span>
<span class="nc" id="L4187">                status = oneStatus;</span>
<span class="fc" id="L4188">        }</span>
<span class="fc" id="L4189">        logger.info(&quot;Completed {} with status {}&quot;, OperationType.GARBAGE_COLLECT, status);</span>
<span class="fc" id="L4190">        return status.statusCode;</span>
    }

    /**
     * Takes the snapshot of a multiple column family from different keyspaces. A snapshot name must be specified.
     *
     * @param tag
     *            the tag given to the snapshot; may not be null or empty
     * @param options
     *            Map of options (skipFlush is the only supported option for now)
     * @param entities
     *            list of keyspaces / tables in the form of empty | ks1 ks2 ... | ks1.cf1,ks2.cf2,...
     */
    @Override
    public void takeSnapshot(String tag, Map&lt;String, String&gt; options, String... entities) throws IOException
    {
<span class="fc bfc" id="L4206" title="All 2 branches covered.">        DurationSpec.IntSecondsBound ttl = options.containsKey(&quot;ttl&quot;) ? new DurationSpec.IntSecondsBound(options.get(&quot;ttl&quot;)) : null;</span>
<span class="fc bfc" id="L4207" title="All 2 branches covered.">        if (ttl != null)</span>
        {
<span class="fc" id="L4209">            int minAllowedTtlSecs = CassandraRelevantProperties.SNAPSHOT_MIN_ALLOWED_TTL_SECONDS.getInt();</span>
<span class="pc bpc" id="L4210" title="1 of 2 branches missed.">            if (ttl.toSeconds() &lt; minAllowedTtlSecs)</span>
<span class="nc" id="L4211">                throw new IllegalArgumentException(String.format(&quot;ttl for snapshot must be at least %d seconds&quot;, minAllowedTtlSecs));</span>
        }

<span class="fc" id="L4214">        boolean skipFlush = Boolean.parseBoolean(options.getOrDefault(&quot;skipFlush&quot;, &quot;false&quot;));</span>
<span class="pc bpc" id="L4215" title="1 of 6 branches missed.">        if (entities != null &amp;&amp; entities.length &gt; 0 &amp;&amp; entities[0].contains(&quot;.&quot;))</span>
        {
<span class="fc" id="L4217">            takeMultipleTableSnapshot(tag, skipFlush, ttl, entities);</span>
        }
        else
        {
<span class="fc" id="L4221">            takeSnapshot(tag, skipFlush, ttl, entities);</span>
        }
<span class="fc" id="L4223">    }</span>

    /**
     * Takes the snapshot of a specific table. A snapshot name must be
     * specified.
     *
     * @param keyspaceName
     *            the keyspace which holds the specified table
     * @param tableName
     *            the table to snapshot
     * @param tag
     *            the tag given to the snapshot; may not be null or empty
     */
    public void takeTableSnapshot(String keyspaceName, String tableName, String tag)
            throws IOException
    {
<span class="fc" id="L4239">        takeMultipleTableSnapshot(tag, false, null, keyspaceName + &quot;.&quot; + tableName);</span>
<span class="fc" id="L4240">    }</span>

    @Override
    public void forceKeyspaceCompactionForTokenRange(String keyspaceName, String startToken, String endToken, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L4245">        Collection&lt;Range&lt;Token&gt;&gt; tokenRanges = createRepairRangeFrom(startToken, endToken);</span>

<span class="nc bnc" id="L4247" title="All 2 branches missed.">        for (ColumnFamilyStore cfStore : getValidColumnFamilies(true, false, keyspaceName, tableNames))</span>
        {
<span class="nc" id="L4249">            cfStore.forceCompactionForTokenRange(tokenRanges);</span>
<span class="nc" id="L4250">        }</span>
<span class="nc" id="L4251">    }</span>

    @Override
    public void forceKeyspaceCompactionForPartitionKey(String keyspaceName, String partitionKey, String... tableNames) throws IOException, ExecutionException, InterruptedException
    {
        // validate that the key parses before attempting compaction
<span class="fc bfc" id="L4257" title="All 2 branches covered.">        for (ColumnFamilyStore cfStore : getValidColumnFamilies(true, false, keyspaceName, tableNames))</span>
        {
            try
            {
<span class="fc" id="L4261">                getKeyFromPartition(keyspaceName, cfStore.name, partitionKey);</span>
            }
<span class="fc" id="L4263">            catch (Exception e)</span>
            {
                // JMX can not handle exceptions defined outside of java.* and javax.*, so safer to rewrite the exception
<span class="fc" id="L4266">                IllegalArgumentException exception = new IllegalArgumentException(String.format(&quot;Unable to parse partition key '%s' for table %s; %s&quot;, partitionKey, cfStore.metadata, e.getMessage()));</span>
<span class="fc" id="L4267">                exception.setStackTrace(e.getStackTrace());</span>
<span class="fc" id="L4268">                throw exception;</span>
<span class="fc" id="L4269">            }</span>
<span class="fc" id="L4270">        }</span>
<span class="fc bfc" id="L4271" title="All 2 branches covered.">        for (ColumnFamilyStore cfStore : getValidColumnFamilies(true, false, keyspaceName, tableNames))</span>
        {
<span class="fc" id="L4273">            cfStore.forceCompactionForKey(getKeyFromPartition(keyspaceName, cfStore.name, partitionKey));</span>
<span class="fc" id="L4274">        }</span>
<span class="fc" id="L4275">    }</span>

    /***
     * Forces compaction for a list of partition keys in a table
     * The method will ignore the gc_grace_seconds for the partitionKeysIgnoreGcGrace during the comapction,
     * in order to purge the tombstones and free up space quicker.
     * @param keyspaceName keyspace name
     * @param tableName table name
     * @param partitionKeysIgnoreGcGrace partition keys ignoring the gc_grace_seconds
     * @throws IOException on any I/O operation error
     * @throws ExecutionException when attempting to retrieve the result of a task that aborted by throwing an exception
     * @throws InterruptedException when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity
     */
    public void forceCompactionKeysIgnoringGcGrace(String keyspaceName,
                                                   String tableName, String... partitionKeysIgnoreGcGrace) throws IOException, ExecutionException, InterruptedException
    {
<span class="nc" id="L4291">        ColumnFamilyStore cfStore = getValidKeyspace(keyspaceName).getColumnFamilyStore(tableName);</span>
<span class="nc" id="L4292">        cfStore.forceCompactionKeysIgnoringGcGrace(partitionKeysIgnoreGcGrace);</span>
<span class="nc" id="L4293">    }</span>

    /**
     * Takes the snapshot for the given keyspaces. A snapshot name must be specified.
     *
     * @param tag the tag given to the snapshot; may not be null or empty
     * @param keyspaceNames the names of the keyspaces to snapshot; empty means &quot;all.&quot;
     */
    public void takeSnapshot(String tag, String... keyspaceNames) throws IOException
    {
<span class="fc" id="L4303">        takeSnapshot(tag, false, null, keyspaceNames);</span>
<span class="fc" id="L4304">    }</span>

    /**
     * Takes the snapshot of a multiple column family from different keyspaces. A snapshot name must be specified.
     *
     * @param tag
     *            the tag given to the snapshot; may not be null or empty
     * @param tableList
     *            list of tables from different keyspace in the form of ks1.cf1 ks2.cf2
     */
    public void takeMultipleTableSnapshot(String tag, String... tableList)
            throws IOException
    {
<span class="nc" id="L4317">        takeMultipleTableSnapshot(tag, false, null, tableList);</span>
<span class="nc" id="L4318">    }</span>

    /**
     * Takes the snapshot for the given keyspaces. A snapshot name must be specified.
     *
     * @param tag the tag given to the snapshot; may not be null or empty
     * @param skipFlush Skip blocking flush of memtable
     * @param keyspaceNames the names of the keyspaces to snapshot; empty means &quot;all.&quot;
     */
    private void takeSnapshot(String tag, boolean skipFlush, DurationSpec.IntSecondsBound ttl, String... keyspaceNames) throws IOException
    {
<span class="pc bpc" id="L4329" title="1 of 2 branches missed.">        if (operationMode == Mode.JOINING)</span>
<span class="nc" id="L4330">            throw new IOException(&quot;Cannot snapshot until bootstrap completes&quot;);</span>
<span class="pc bpc" id="L4331" title="2 of 4 branches missed.">        if (tag == null || tag.equals(&quot;&quot;))</span>
<span class="nc" id="L4332">            throw new IOException(&quot;You must supply a snapshot name.&quot;);</span>

        Iterable&lt;Keyspace&gt; keyspaces;
<span class="fc bfc" id="L4335" title="All 2 branches covered.">        if (keyspaceNames.length == 0)</span>
        {
<span class="fc" id="L4337">            keyspaces = Keyspace.all();</span>
        }
        else
        {
<span class="fc" id="L4341">            ArrayList&lt;Keyspace&gt; t = new ArrayList&lt;&gt;(keyspaceNames.length);</span>
<span class="fc bfc" id="L4342" title="All 2 branches covered.">            for (String keyspaceName : keyspaceNames)</span>
<span class="fc" id="L4343">                t.add(getValidKeyspace(keyspaceName));</span>
<span class="fc" id="L4344">            keyspaces = t;</span>
        }

        // Do a check to see if this snapshot exists before we actually snapshot
<span class="fc bfc" id="L4348" title="All 2 branches covered.">        for (Keyspace keyspace : keyspaces)</span>
<span class="pc bpc" id="L4349" title="1 of 2 branches missed.">            if (keyspace.snapshotExists(tag))</span>
<span class="nc" id="L4350">                throw new IOException(&quot;Snapshot &quot; + tag + &quot; already exists.&quot;);</span>


<span class="fc" id="L4353">        RateLimiter snapshotRateLimiter = DatabaseDescriptor.getSnapshotRateLimiter();</span>
<span class="fc" id="L4354">        Instant creationTime = now();</span>

<span class="fc bfc" id="L4356" title="All 2 branches covered.">        for (Keyspace keyspace : keyspaces)</span>
        {
<span class="fc" id="L4358">            keyspace.snapshot(tag, null, skipFlush, ttl, snapshotRateLimiter, creationTime);</span>
<span class="fc" id="L4359">        }</span>
<span class="fc" id="L4360">    }</span>

    /**
     * Takes the snapshot of a multiple column family from different keyspaces. A snapshot name must be specified.
     *
     *
     * @param tag
     *            the tag given to the snapshot; may not be null or empty
     * @param skipFlush
     *            Skip blocking flush of memtable
     * @param tableList
     *            list of tables from different keyspace in the form of ks1.cf1 ks2.cf2
     */
    private void takeMultipleTableSnapshot(String tag, boolean skipFlush, DurationSpec.IntSecondsBound ttl, String... tableList)
            throws IOException
    {
<span class="fc" id="L4376">        Map&lt;Keyspace, List&lt;String&gt;&gt; keyspaceColumnfamily = new HashMap&lt;Keyspace, List&lt;String&gt;&gt;();</span>
<span class="fc bfc" id="L4377" title="All 2 branches covered.">        for (String table : tableList)</span>
        {
<span class="fc" id="L4379">            String splittedString[] = StringUtils.split(table, '.');</span>
<span class="pc bpc" id="L4380" title="1 of 2 branches missed.">            if (splittedString.length == 2)</span>
            {
<span class="fc" id="L4382">                String keyspaceName = splittedString[0];</span>
<span class="fc" id="L4383">                String tableName = splittedString[1];</span>

<span class="pc bpc" id="L4385" title="1 of 2 branches missed.">                if (keyspaceName == null)</span>
<span class="nc" id="L4386">                    throw new IOException(&quot;You must supply a keyspace name&quot;);</span>
<span class="pc bpc" id="L4387" title="1 of 2 branches missed.">                if (operationMode.equals(Mode.JOINING))</span>
<span class="nc" id="L4388">                    throw new IOException(&quot;Cannot snapshot until bootstrap completes&quot;);</span>

<span class="pc bpc" id="L4390" title="1 of 2 branches missed.">                if (tableName == null)</span>
<span class="nc" id="L4391">                    throw new IOException(&quot;You must supply a table name&quot;);</span>
<span class="pc bpc" id="L4392" title="2 of 4 branches missed.">                if (tag == null || tag.equals(&quot;&quot;))</span>
<span class="nc" id="L4393">                    throw new IOException(&quot;You must supply a snapshot name.&quot;);</span>

<span class="fc" id="L4395">                Keyspace keyspace = getValidKeyspace(keyspaceName);</span>
<span class="fc" id="L4396">                ColumnFamilyStore columnFamilyStore = keyspace.getColumnFamilyStore(tableName);</span>
                // As there can be multiple column family from same keyspace check if snapshot exist for that specific
                // columnfamily and not for whole keyspace

<span class="pc bpc" id="L4400" title="1 of 2 branches missed.">                if (columnFamilyStore.snapshotExists(tag))</span>
<span class="nc" id="L4401">                    throw new IOException(&quot;Snapshot &quot; + tag + &quot; already exists.&quot;);</span>
<span class="fc bfc" id="L4402" title="All 2 branches covered.">                if (!keyspaceColumnfamily.containsKey(keyspace))</span>
                {
<span class="fc" id="L4404">                    keyspaceColumnfamily.put(keyspace, new ArrayList&lt;String&gt;());</span>
                }

                // Add Keyspace columnfamily to map in order to support atomicity for snapshot process.
                // So no snapshot should happen if any one of the above conditions fail for any keyspace or columnfamily
<span class="fc" id="L4409">                keyspaceColumnfamily.get(keyspace).add(tableName);</span>

<span class="fc" id="L4411">            }</span>
            else
            {
<span class="nc" id="L4414">                throw new IllegalArgumentException(</span>
                        &quot;Cannot take a snapshot on secondary index or invalid column family name. You must supply a column family name in the form of keyspace.columnfamily&quot;);
            }
        }

<span class="fc" id="L4419">        RateLimiter snapshotRateLimiter = DatabaseDescriptor.getSnapshotRateLimiter();</span>
<span class="fc" id="L4420">        Instant creationTime = now();</span>

<span class="fc bfc" id="L4422" title="All 2 branches covered.">        for (Entry&lt;Keyspace, List&lt;String&gt;&gt; entry : keyspaceColumnfamily.entrySet())</span>
        {
<span class="fc bfc" id="L4424" title="All 2 branches covered.">            for (String table : entry.getValue())</span>
<span class="fc" id="L4425">                entry.getKey().snapshot(tag, table, skipFlush, ttl, snapshotRateLimiter, creationTime);</span>
<span class="fc" id="L4426">        }</span>
<span class="fc" id="L4427">    }</span>

    private void verifyKeyspaceIsValid(String keyspaceName)
    {
<span class="fc bfc" id="L4431" title="All 2 branches covered.">        if (null != VirtualKeyspaceRegistry.instance.getKeyspaceNullable(keyspaceName))</span>
<span class="fc" id="L4432">            throw new IllegalArgumentException(&quot;Cannot perform any operations against virtual keyspace &quot; + keyspaceName);</span>

<span class="pc bpc" id="L4434" title="1 of 2 branches missed.">        if (!Schema.instance.getKeyspaces().contains(keyspaceName))</span>
<span class="nc" id="L4435">            throw new IllegalArgumentException(&quot;Keyspace &quot; + keyspaceName + &quot; does not exist&quot;);</span>
<span class="fc" id="L4436">    }</span>

    private Keyspace getValidKeyspace(String keyspaceName)
    {
<span class="fc" id="L4440">        verifyKeyspaceIsValid(keyspaceName);</span>
<span class="fc" id="L4441">        return Keyspace.open(keyspaceName);</span>
    }

    /**
     * Remove the snapshot with the given name from the given keyspaces.
     * If no tag is specified we will remove all snapshots.
     */
    public void clearSnapshot(String tag, String... keyspaceNames)
    {
<span class="nc" id="L4450">        clearSnapshot(Collections.emptyMap(), tag, keyspaceNames);</span>
<span class="nc" id="L4451">    }</span>

    public void clearSnapshot(Map&lt;String, Object&gt; options, String tag, String... keyspaceNames)
    {
<span class="fc bfc" id="L4455" title="All 2 branches covered.">        if (tag == null)</span>
<span class="fc" id="L4456">            tag = &quot;&quot;;</span>

<span class="pc bpc" id="L4458" title="1 of 2 branches missed.">        if (options == null)</span>
<span class="nc" id="L4459">            options = Collections.emptyMap();</span>

<span class="fc" id="L4461">        Set&lt;String&gt; keyspaces = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L4462" title="All 2 branches covered.">        for (String dataDir : DatabaseDescriptor.getAllDataFileLocations())</span>
        {
<span class="fc bfc" id="L4464" title="All 2 branches covered.">            for (String keyspaceDir : new File(dataDir).tryListNames())</span>
            {
                // Only add a ks if it has been specified as a param, assuming params were actually provided.
<span class="fc bfc" id="L4467" title="All 4 branches covered.">                if (keyspaceNames.length &gt; 0 &amp;&amp; !Arrays.asList(keyspaceNames).contains(keyspaceDir))</span>
<span class="fc" id="L4468">                    continue;</span>
<span class="fc" id="L4469">                keyspaces.add(keyspaceDir);</span>
            }
        }

<span class="fc" id="L4473">        Object olderThan = options.get(&quot;older_than&quot;);</span>
<span class="fc" id="L4474">        Object olderThanTimestamp = options.get(&quot;older_than_timestamp&quot;);</span>

        final long clearOlderThanTimestamp;
<span class="fc bfc" id="L4477" title="All 2 branches covered.">        if (olderThan != null)</span>
        {
<span class="pc bpc" id="L4479" title="1 of 2 branches missed.">            assert olderThan instanceof String : &quot;it is expected that older_than is an instance of java.lang.String&quot;;</span>
<span class="fc" id="L4480">            clearOlderThanTimestamp = Clock.Global.currentTimeMillis() - new DurationSpec.LongSecondsBound((String) olderThan).toMilliseconds();</span>
        }
<span class="fc bfc" id="L4482" title="All 2 branches covered.">        else if (olderThanTimestamp != null)</span>
        {
<span class="pc bpc" id="L4484" title="1 of 2 branches missed.">            assert olderThanTimestamp instanceof String : &quot;it is expected that older_than_timestamp is an instance of java.lang.String&quot;;</span>
            try
            {
<span class="fc" id="L4487">                clearOlderThanTimestamp = Instant.parse((String) olderThanTimestamp).toEpochMilli();</span>
            }
<span class="nc" id="L4489">            catch (DateTimeParseException ex)</span>
            {
<span class="nc" id="L4491">                throw new RuntimeException(&quot;Parameter older_than_timestamp has to be a valid instant in ISO format.&quot;);</span>
<span class="fc" id="L4492">            }</span>
        }
        else
<span class="fc" id="L4495">            clearOlderThanTimestamp = 0L;</span>

<span class="fc bfc" id="L4497" title="All 2 branches covered.">        for (String keyspace : keyspaces)</span>
<span class="fc" id="L4498">            clearKeyspaceSnapshot(keyspace, tag, clearOlderThanTimestamp);</span>

<span class="pc bpc" id="L4500" title="1 of 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="fc" id="L4501">            logger.debug(&quot;Cleared out snapshot directories&quot;);</span>
<span class="fc" id="L4502">    }</span>

    /**
     * Clear snapshots for a given keyspace.
     * @param keyspace keyspace to remove snapshots for
     * @param tag the user supplied snapshot name. If empty or null, all the snapshots will be cleaned
     * @param olderThanTimestamp if a snapshot was created before this timestamp, it will be cleared,
     *                           if its value is 0, this parameter is effectively ignored.
     */
    private void clearKeyspaceSnapshot(String keyspace, String tag, long olderThanTimestamp)
    {
<span class="fc" id="L4513">        Set&lt;TableSnapshot&gt; snapshotsToClear = snapshotManager.loadSnapshots(keyspace)</span>
<span class="fc" id="L4514">                                                             .stream()</span>
<span class="fc" id="L4515">                                                             .filter(TableSnapshot.shouldClearSnapshot(tag, olderThanTimestamp))</span>
<span class="fc" id="L4516">                                                             .collect(Collectors.toSet());</span>
<span class="fc bfc" id="L4517" title="All 2 branches covered.">        for (TableSnapshot snapshot : snapshotsToClear)</span>
<span class="fc" id="L4518">            snapshotManager.clearSnapshot(snapshot);</span>
<span class="fc" id="L4519">    }</span>

    public Map&lt;String, TabularData&gt; getSnapshotDetails(Map&lt;String, String&gt; options)
    {
<span class="pc bpc" id="L4523" title="2 of 4 branches missed.">        boolean skipExpiring = options != null &amp;&amp; Boolean.parseBoolean(options.getOrDefault(&quot;no_ttl&quot;, &quot;false&quot;));</span>
<span class="pc bpc" id="L4524" title="2 of 4 branches missed.">        boolean includeEphemeral = options != null &amp;&amp; Boolean.parseBoolean(options.getOrDefault(&quot;include_ephemeral&quot;, &quot;false&quot;));</span>

<span class="fc" id="L4526">        Map&lt;String, TabularData&gt; snapshotMap = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L4528" title="All 2 branches covered.">        for (TableSnapshot snapshot : snapshotManager.loadSnapshots())</span>
        {
<span class="pc bpc" id="L4530" title="3 of 4 branches missed.">            if (skipExpiring &amp;&amp; snapshot.isExpiring())</span>
<span class="nc" id="L4531">                continue;</span>
<span class="pc bpc" id="L4532" title="2 of 4 branches missed.">            if (!includeEphemeral &amp;&amp; snapshot.isEphemeral())</span>
<span class="nc" id="L4533">                continue;</span>

<span class="fc" id="L4535">            TabularDataSupport data = (TabularDataSupport) snapshotMap.get(snapshot.getTag());</span>
<span class="fc bfc" id="L4536" title="All 2 branches covered.">            if (data == null)</span>
            {
<span class="fc" id="L4538">                data = new TabularDataSupport(SnapshotDetailsTabularData.TABULAR_TYPE);</span>
<span class="fc" id="L4539">                snapshotMap.put(snapshot.getTag(), data);</span>
            }

<span class="fc" id="L4542">            SnapshotDetailsTabularData.from(snapshot, data);</span>
<span class="fc" id="L4543">        }</span>

<span class="fc" id="L4545">        return snapshotMap;</span>
    }

    @Deprecated
    public Map&lt;String, TabularData&gt; getSnapshotDetails()
    {
<span class="nc" id="L4551">        return getSnapshotDetails(ImmutableMap.of());</span>
    }

    public long trueSnapshotsSize()
    {
<span class="fc" id="L4556">        long total = 0;</span>
<span class="fc bfc" id="L4557" title="All 2 branches covered.">        for (Keyspace keyspace : Keyspace.all())</span>
        {
<span class="fc bfc" id="L4559" title="All 2 branches covered.">            if (SchemaConstants.isLocalSystemKeyspace(keyspace.getName()))</span>
<span class="fc" id="L4560">                continue;</span>

<span class="fc bfc" id="L4562" title="All 2 branches covered.">            for (ColumnFamilyStore cfStore : keyspace.getColumnFamilyStores())</span>
            {
<span class="fc" id="L4564">                total += cfStore.trueSnapshotsSize();</span>
<span class="fc" id="L4565">            }</span>
<span class="fc" id="L4566">        }</span>

<span class="fc" id="L4568">        return total;</span>
    }

    public void setSnapshotLinksPerSecond(long throttle)
    {
<span class="nc" id="L4573">        logger.info(&quot;Setting snapshot throttle to {}&quot;, throttle);</span>
<span class="nc" id="L4574">        DatabaseDescriptor.setSnapshotLinksPerSecond(throttle);</span>
<span class="nc" id="L4575">    }</span>

    public long getSnapshotLinksPerSecond()
    {
<span class="nc" id="L4579">        return DatabaseDescriptor.getSnapshotLinksPerSecond();</span>
    }

    public void refreshSizeEstimates() throws ExecutionException
    {
<span class="nc" id="L4584">        cleanupSizeEstimates();</span>
<span class="nc" id="L4585">        FBUtilities.waitOnFuture(ScheduledExecutors.optionalTasks.submit(SizeEstimatesRecorder.instance));</span>
<span class="nc" id="L4586">    }</span>

    public void cleanupSizeEstimates()
    {
<span class="fc" id="L4590">        SystemKeyspace.clearAllEstimates();</span>
<span class="fc" id="L4591">    }</span>

    /**
     * @param allowIndexes Allow index CF names to be passed in
     * @param autoAddIndexes Automatically add secondary indexes if a CF has them
     * @param keyspaceName keyspace
     * @param cfNames CFs
     * @throws java.lang.IllegalArgumentException when given CF name does not exist
     */
    public Iterable&lt;ColumnFamilyStore&gt; getValidColumnFamilies(boolean allowIndexes, boolean autoAddIndexes, String keyspaceName, String... cfNames)
    {
<span class="fc" id="L4602">        Keyspace keyspace = getValidKeyspace(keyspaceName);</span>
<span class="fc" id="L4603">        return keyspace.getValidColumnFamilies(allowIndexes, autoAddIndexes, cfNames);</span>
    }

    /**
     * Flush all memtables for a keyspace and column families.
     * @param keyspaceName
     * @param tableNames
     * @throws IOException
     */
    public void forceKeyspaceFlush(String keyspaceName, String... tableNames) throws IOException
    {
<span class="fc bfc" id="L4614" title="All 2 branches covered.">        for (ColumnFamilyStore cfStore : getValidColumnFamilies(true, false, keyspaceName, tableNames))</span>
        {
<span class="fc" id="L4616">            logger.debug(&quot;Forcing flush on keyspace {}, CF {}&quot;, keyspaceName, cfStore.name);</span>
<span class="fc" id="L4617">            cfStore.forceBlockingFlush(ColumnFamilyStore.FlushReason.USER_FORCED);</span>
<span class="fc" id="L4618">        }</span>
<span class="fc" id="L4619">    }</span>

    /**
     * Flush all memtables for a keyspace and column families.
     * @param keyspaceName
     * @throws IOException
     */
    public void forceKeyspaceFlush(String keyspaceName, ColumnFamilyStore.FlushReason reason) throws IOException
    {
<span class="fc bfc" id="L4628" title="All 2 branches covered.">        for (ColumnFamilyStore cfStore : getValidColumnFamilies(true, false, keyspaceName))</span>
        {
<span class="fc" id="L4630">            logger.debug(&quot;Forcing flush on keyspace {}, CF {}&quot;, keyspaceName, cfStore.name);</span>
<span class="fc" id="L4631">            cfStore.forceBlockingFlush(reason);</span>
<span class="fc" id="L4632">        }</span>
<span class="fc" id="L4633">    }</span>

    public int repairAsync(String keyspace, Map&lt;String, String&gt; repairSpec)
    {
<span class="nc" id="L4637">        return repair(keyspace, repairSpec, Collections.emptyList()).left;</span>
    }

    public Pair&lt;Integer, Future&lt;?&gt;&gt; repair(String keyspace, Map&lt;String, String&gt; repairSpec, List&lt;ProgressListener&gt; listeners)
    {
<span class="nc" id="L4642">        RepairOption option = RepairOption.parse(repairSpec, tokenMetadata.partitioner);</span>
<span class="nc" id="L4643">        return repair(keyspace, option, listeners);</span>
    }

    public Pair&lt;Integer, Future&lt;?&gt;&gt; repair(String keyspace, RepairOption option, List&lt;ProgressListener&gt; listeners)
    {
        // if ranges are not specified
<span class="nc bnc" id="L4649" title="All 2 branches missed.">        if (option.getRanges().isEmpty())</span>
        {
<span class="nc bnc" id="L4651" title="All 2 branches missed.">            if (option.isPrimaryRange())</span>
            {
                // when repairing only primary range, neither dataCenters nor hosts can be set
<span class="nc bnc" id="L4654" title="All 4 branches missed.">                if (option.getDataCenters().isEmpty() &amp;&amp; option.getHosts().isEmpty())</span>
<span class="nc" id="L4655">                    option.getRanges().addAll(getPrimaryRanges(keyspace));</span>
                    // except dataCenters only contain local DC (i.e. -local)
<span class="nc bnc" id="L4657" title="All 2 branches missed.">                else if (option.isInLocalDCOnly())</span>
<span class="nc" id="L4658">                    option.getRanges().addAll(getPrimaryRangesWithinDC(keyspace));</span>
                else
<span class="nc" id="L4660">                    throw new IllegalArgumentException(&quot;You need to run primary range repair on all nodes in the cluster.&quot;);</span>
            }
            else
            {
<span class="nc" id="L4664">                Iterables.addAll(option.getRanges(), getLocalReplicas(keyspace).onlyFull().ranges());</span>
            }
        }
<span class="nc bnc" id="L4667" title="All 4 branches missed.">        if (option.getRanges().isEmpty() || Keyspace.open(keyspace).getReplicationStrategy().getReplicationFactor().allReplicas &lt; 2)</span>
<span class="nc" id="L4668">            return Pair.create(0, ImmediateFuture.success(null));</span>

<span class="nc" id="L4670">        int cmd = nextRepairCommand.incrementAndGet();</span>
<span class="nc" id="L4671">        return Pair.create(cmd, repairCommandExecutor().submit(createRepairTask(cmd, keyspace, option, listeners)));</span>
    }

    /**
     * Create collection of ranges that match ring layout from given tokens.
     *
     * @param beginToken beginning token of the range
     * @param endToken end token of the range
     * @return collection of ranges that match ring layout in TokenMetadata
     */
    @VisibleForTesting
    Collection&lt;Range&lt;Token&gt;&gt; createRepairRangeFrom(String beginToken, String endToken)
    {
<span class="fc" id="L4684">        Token parsedBeginToken = getTokenFactory().fromString(beginToken);</span>
<span class="fc" id="L4685">        Token parsedEndToken = getTokenFactory().fromString(endToken);</span>

        // Break up given range to match ring layout in TokenMetadata
<span class="fc" id="L4688">        ArrayList&lt;Range&lt;Token&gt;&gt; repairingRange = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L4690">        ArrayList&lt;Token&gt; tokens = new ArrayList&lt;&gt;(tokenMetadata.sortedTokens());</span>
<span class="fc bfc" id="L4691" title="All 2 branches covered.">        if (!tokens.contains(parsedBeginToken))</span>
        {
<span class="fc" id="L4693">            tokens.add(parsedBeginToken);</span>
        }
<span class="fc bfc" id="L4695" title="All 2 branches covered.">        if (!tokens.contains(parsedEndToken))</span>
        {
<span class="fc" id="L4697">            tokens.add(parsedEndToken);</span>
        }
        // tokens now contain all tokens including our endpoints
<span class="fc" id="L4700">        Collections.sort(tokens);</span>

<span class="fc" id="L4702">        int start = tokens.indexOf(parsedBeginToken), end = tokens.indexOf(parsedEndToken);</span>
<span class="fc bfc" id="L4703" title="All 2 branches covered.">        for (int i = start; i != end; i = (i+1) % tokens.size())</span>
        {
<span class="fc" id="L4705">            Range&lt;Token&gt; range = new Range&lt;&gt;(tokens.get(i), tokens.get((i+1) % tokens.size()));</span>
<span class="fc" id="L4706">            repairingRange.add(range);</span>
        }

<span class="fc" id="L4709">        return repairingRange;</span>
    }

    public TokenFactory getTokenFactory()
    {
<span class="fc" id="L4714">        return tokenMetadata.partitioner.getTokenFactory();</span>
    }

    private FutureTask&lt;Object&gt; createRepairTask(final int cmd, final String keyspace, final RepairOption options, List&lt;ProgressListener&gt; listeners)
    {
<span class="nc bnc" id="L4719" title="All 4 branches missed.">        if (!options.getDataCenters().isEmpty() &amp;&amp; !options.getDataCenters().contains(DatabaseDescriptor.getLocalDataCenter()))</span>
        {
<span class="nc" id="L4721">            throw new IllegalArgumentException(&quot;the local data center must be part of the repair; requested &quot; + options.getDataCenters() + &quot; but DC is &quot; + DatabaseDescriptor.getLocalDataCenter());</span>
        }
<span class="nc" id="L4723">        Set&lt;String&gt; existingDatacenters = tokenMetadata.cloneOnlyTokenMap().getTopology().getDatacenterEndpoints().keys().elementSet();</span>
<span class="nc" id="L4724">        List&lt;String&gt; datacenters = new ArrayList&lt;&gt;(options.getDataCenters());</span>
<span class="nc bnc" id="L4725" title="All 2 branches missed.">        if (!existingDatacenters.containsAll(datacenters))</span>
        {
<span class="nc" id="L4727">            datacenters.removeAll(existingDatacenters);</span>
<span class="nc" id="L4728">            throw new IllegalArgumentException(&quot;data center(s) &quot; + datacenters.toString() + &quot; not found&quot;);</span>
        }

<span class="nc" id="L4731">        RepairCoordinator task = new RepairCoordinator(this, cmd, options, keyspace);</span>
<span class="nc" id="L4732">        task.addProgressListener(progressSupport);</span>
<span class="nc bnc" id="L4733" title="All 2 branches missed.">        for (ProgressListener listener : listeners)</span>
<span class="nc" id="L4734">            task.addProgressListener(listener);</span>

<span class="nc bnc" id="L4736" title="All 2 branches missed.">        if (options.isTraced())</span>
<span class="nc" id="L4737">            return new FutureTaskWithResources&lt;&gt;(() -&gt; ExecutorLocals::clear, task);</span>
<span class="nc" id="L4738">        return new FutureTask&lt;&gt;(task);</span>
    }

    private void tryRepairPaxosForTopologyChange(String reason)
    {
        try
        {
<span class="nc" id="L4745">            startRepairPaxosForTopologyChange(reason).get();</span>
        }
<span class="nc" id="L4747">        catch (InterruptedException e)</span>
        {
<span class="nc" id="L4749">            logger.error(&quot;Error during paxos repair&quot;, e);</span>
<span class="nc" id="L4750">            throw new AssertionError(e);</span>
        }
<span class="nc" id="L4752">        catch (ExecutionException e)</span>
        {
<span class="nc" id="L4754">            logger.error(&quot;Error during paxos repair&quot;, e);</span>
<span class="nc" id="L4755">            throw new RuntimeException(e);</span>
<span class="nc" id="L4756">        }</span>
<span class="nc" id="L4757">    }</span>

    private void repairPaxosForTopologyChange(String reason)
    {
<span class="nc bnc" id="L4761" title="All 4 branches missed.">        if (getSkipPaxosRepairOnTopologyChange() || !Paxos.useV2())</span>
        {
<span class="nc" id="L4763">            logger.info(&quot;skipping paxos repair for {}. skip_paxos_repair_on_topology_change is set, or v2 paxos variant is not being used&quot;, reason);</span>
<span class="nc" id="L4764">            return;</span>
        }

<span class="nc" id="L4767">        logger.info(&quot;repairing paxos for {}&quot;, reason);</span>

<span class="nc" id="L4769">        int retries = 0;</span>
<span class="nc" id="L4770">        int maxRetries = PAXOS_REPAIR_ON_TOPOLOGY_CHANGE_RETRIES.getInt();</span>
<span class="nc" id="L4771">        int delaySec = PAXOS_REPAIR_ON_TOPOLOGY_CHANGE_RETRY_DELAY_SECONDS.getInt();</span>

<span class="nc" id="L4773">        boolean completed = false;</span>
<span class="nc bnc" id="L4774" title="All 2 branches missed.">        while (!completed)</span>
        {
            try
            {
<span class="nc" id="L4778">                tryRepairPaxosForTopologyChange(reason);</span>
<span class="nc" id="L4779">                completed = true;</span>
            }
<span class="nc" id="L4781">            catch (Exception e)</span>
            {
<span class="nc bnc" id="L4783" title="All 2 branches missed.">                if (retries &gt;= maxRetries)</span>
<span class="nc" id="L4784">                    throw e;</span>

<span class="nc" id="L4786">                retries++;</span>
<span class="nc" id="L4787">                int sleep = delaySec * retries;</span>
<span class="nc" id="L4788">                logger.info(&quot;Sleeping {} seconds before retrying paxos repair...&quot;, sleep);</span>
<span class="nc" id="L4789">                Uninterruptibles.sleepUninterruptibly(sleep, TimeUnit.SECONDS);</span>
<span class="nc" id="L4790">                logger.info(&quot;Retrying paxos repair for {}. Retry {}/{}&quot;, reason, retries, maxRetries);</span>
<span class="nc" id="L4791">            }</span>
        }

<span class="nc" id="L4794">        logger.info(&quot;paxos repair for {} complete&quot;, reason);</span>
<span class="nc" id="L4795">    }</span>

    @VisibleForTesting
    public Future&lt;?&gt; startRepairPaxosForTopologyChange(String reason)
    {
<span class="nc" id="L4800">        logger.info(&quot;repairing paxos for {}&quot;, reason);</span>

<span class="nc" id="L4802">        List&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L4804">        Keyspaces keyspaces = Schema.instance.getNonLocalStrategyKeyspaces();</span>
<span class="nc bnc" id="L4805" title="All 2 branches missed.">        for (String ksName : keyspaces.names())</span>
        {
<span class="nc bnc" id="L4807" title="All 2 branches missed.">            if (SchemaConstants.REPLICATED_SYSTEM_KEYSPACE_NAMES.contains(ksName))</span>
<span class="nc" id="L4808">                continue;</span>

<span class="nc bnc" id="L4810" title="All 2 branches missed.">            if (DatabaseDescriptor.skipPaxosRepairOnTopologyChangeKeyspaces().contains(ksName))</span>
<span class="nc" id="L4811">                continue;</span>

<span class="nc" id="L4813">            List&lt;Range&lt;Token&gt;&gt; ranges = getLocalAndPendingRanges(ksName);</span>
<span class="nc" id="L4814">            futures.add(ActiveRepairService.instance().repairPaxosForTopologyChange(ksName, ranges, reason));</span>
<span class="nc" id="L4815">        }</span>

<span class="nc" id="L4817">        return FutureCombiner.allOf(futures);</span>
    }

    public Future&lt;?&gt; autoRepairPaxos(TableId tableId)
    {
<span class="nc" id="L4822">        TableMetadata table = Schema.instance.getTableMetadata(tableId);</span>
<span class="nc bnc" id="L4823" title="All 2 branches missed.">        if (table == null)</span>
<span class="nc" id="L4824">            return ImmediateFuture.success(null);</span>

<span class="nc" id="L4826">        List&lt;Range&lt;Token&gt;&gt; ranges = getLocalAndPendingRanges(table.keyspace);</span>
<span class="nc" id="L4827">        PaxosCleanupLocalCoordinator coordinator = PaxosCleanupLocalCoordinator.createForAutoRepair(tableId, ranges);</span>
<span class="nc" id="L4828">        ScheduledExecutors.optionalTasks.submit(coordinator::start);</span>
<span class="nc" id="L4829">        return coordinator;</span>
    }

    public void forceTerminateAllRepairSessions()
    {
<span class="nc" id="L4834">        ActiveRepairService.instance().terminateSessions();</span>
<span class="nc" id="L4835">    }</span>

    @Nullable
    public List&lt;String&gt; getParentRepairStatus(int cmd)
    {
<span class="fc" id="L4840">        Pair&lt;ParentRepairStatus, List&lt;String&gt;&gt; pair = ActiveRepairService.instance().getRepairStatus(cmd);</span>
<span class="fc bfc" id="L4841" title="All 2 branches covered.">        return pair == null ? null :</span>
<span class="fc" id="L4842">               ImmutableList.&lt;String&gt;builder().add(pair.left.name()).addAll(pair.right).build();</span>
    }

    @Deprecated
    @Override
    public void setRepairSessionMaxTreeDepth(int depth)
    {
<span class="nc" id="L4849">        DatabaseDescriptor.setRepairSessionMaxTreeDepth(depth);</span>
<span class="nc" id="L4850">    }</span>

    @Deprecated
    @Override
    public int getRepairSessionMaxTreeDepth()
    {
<span class="nc" id="L4856">        return DatabaseDescriptor.getRepairSessionMaxTreeDepth();</span>
    }

    @Override
    public void setRepairSessionMaximumTreeDepth(int depth)
    {
        try
        {
<span class="fc" id="L4864">            DatabaseDescriptor.setRepairSessionMaxTreeDepth(depth);</span>
        }
<span class="fc" id="L4866">        catch (ConfigurationException e)</span>
        {
<span class="fc" id="L4868">            throw new IllegalArgumentException(e.getMessage());</span>
<span class="fc" id="L4869">        }</span>
<span class="fc" id="L4870">    }</span>

    /*
     * In CASSANDRA-17668, JMX setters that did not throw standard exceptions were deprecated in favor of ones that do.
     * For consistency purposes, the respective getter &quot;getRepairSessionMaxTreeDepth&quot; was also deprecated and replaced
     * by this method.
     */
    @Override
    public int getRepairSessionMaximumTreeDepth()
    {
<span class="fc" id="L4880">        return DatabaseDescriptor.getRepairSessionMaxTreeDepth();</span>
    }

    /* End of MBean interface methods */

    /**
     * Get the &quot;primary ranges&quot; for the specified keyspace and endpoint.
     * &quot;Primary ranges&quot; are the ranges that the node is responsible for storing replica primarily.
     * The node that stores replica primarily is defined as the first node returned
     * by {@link AbstractReplicationStrategy#calculateNaturalReplicas}.
     *
     * @param keyspace Keyspace name to check primary ranges
     * @param ep endpoint we are interested in.
     * @return primary ranges for the specified endpoint.
     */
    public Collection&lt;Range&lt;Token&gt;&gt; getPrimaryRangesForEndpoint(String keyspace, InetAddressAndPort ep)
    {
<span class="fc" id="L4897">        AbstractReplicationStrategy strategy = Keyspace.open(keyspace).getReplicationStrategy();</span>
<span class="fc" id="L4898">        Collection&lt;Range&lt;Token&gt;&gt; primaryRanges = new HashSet&lt;&gt;();</span>
<span class="fc" id="L4899">        TokenMetadata metadata = tokenMetadata.cloneOnlyTokenMap();</span>
<span class="fc bfc" id="L4900" title="All 2 branches covered.">        for (Token token : metadata.sortedTokens())</span>
        {
<span class="fc" id="L4902">            EndpointsForRange replicas = strategy.calculateNaturalReplicas(token, metadata);</span>
<span class="pc bpc" id="L4903" title="1 of 4 branches missed.">            if (replicas.size() &gt; 0 &amp;&amp; replicas.get(0).endpoint().equals(ep))</span>
            {
<span class="fc" id="L4905">                Preconditions.checkState(replicas.get(0).isFull());</span>
<span class="fc" id="L4906">                primaryRanges.add(new Range&lt;&gt;(metadata.getPredecessor(token), token));</span>
            }
<span class="fc" id="L4908">        }</span>
<span class="fc" id="L4909">        return primaryRanges;</span>
    }

    /**
     * Get the &quot;primary ranges&quot; within local DC for the specified keyspace and endpoint.
     *
     * @see #getPrimaryRangesForEndpoint(String, InetAddressAndPort)
     * @param keyspace Keyspace name to check primary ranges
     * @param referenceEndpoint endpoint we are interested in.
     * @return primary ranges within local DC for the specified endpoint.
     */
    public Collection&lt;Range&lt;Token&gt;&gt; getPrimaryRangeForEndpointWithinDC(String keyspace, InetAddressAndPort referenceEndpoint)
    {
<span class="fc" id="L4922">        TokenMetadata metadata = tokenMetadata.cloneOnlyTokenMap();</span>
<span class="fc" id="L4923">        String localDC = DatabaseDescriptor.getEndpointSnitch().getDatacenter(referenceEndpoint);</span>
<span class="fc" id="L4924">        Collection&lt;InetAddressAndPort&gt; localDcNodes = metadata.getTopology().getDatacenterEndpoints().get(localDC);</span>
<span class="fc" id="L4925">        AbstractReplicationStrategy strategy = Keyspace.open(keyspace).getReplicationStrategy();</span>

<span class="fc" id="L4927">        Collection&lt;Range&lt;Token&gt;&gt; localDCPrimaryRanges = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L4928" title="All 2 branches covered.">        for (Token token : metadata.sortedTokens())</span>
        {
<span class="fc" id="L4930">            EndpointsForRange replicas = strategy.calculateNaturalReplicas(token, metadata);</span>
<span class="fc bfc" id="L4931" title="All 2 branches covered.">            for (Replica replica : replicas)</span>
            {
<span class="fc bfc" id="L4933" title="All 2 branches covered.">                if (localDcNodes.contains(replica.endpoint()))</span>
                {
<span class="fc bfc" id="L4935" title="All 2 branches covered.">                    if (replica.endpoint().equals(referenceEndpoint))</span>
                    {
<span class="fc" id="L4937">                        localDCPrimaryRanges.add(new Range&lt;&gt;(metadata.getPredecessor(token), token));</span>
                    }
                    break;
                }
<span class="fc" id="L4941">            }</span>
<span class="fc" id="L4942">        }</span>

<span class="fc" id="L4944">        return localDCPrimaryRanges;</span>
    }

    public Collection&lt;Range&lt;Token&gt;&gt; getLocalPrimaryRange()
    {
<span class="fc" id="L4949">        return getLocalPrimaryRangeForEndpoint(FBUtilities.getBroadcastAddressAndPort());</span>
    }

    public Collection&lt;Range&lt;Token&gt;&gt; getLocalPrimaryRangeForEndpoint(InetAddressAndPort referenceEndpoint)
    {
<span class="fc" id="L4954">        IEndpointSnitch snitch = DatabaseDescriptor.getEndpointSnitch();</span>
<span class="fc" id="L4955">        TokenMetadata tokenMetadata = this.tokenMetadata.cloneOnlyTokenMap();</span>
<span class="pc bpc" id="L4956" title="1 of 2 branches missed.">        if (!tokenMetadata.isMember(referenceEndpoint))</span>
<span class="nc" id="L4957">            return Collections.emptySet();</span>
<span class="fc" id="L4958">        String dc = snitch.getDatacenter(referenceEndpoint);</span>
<span class="fc" id="L4959">        Set&lt;Token&gt; tokens = new HashSet&lt;&gt;(tokenMetadata.getTokens(referenceEndpoint));</span>

        // filter tokens to the single DC
<span class="fc" id="L4962">        List&lt;Token&gt; filteredTokens = Lists.newArrayList();</span>
<span class="fc bfc" id="L4963" title="All 2 branches covered.">        for (Token token : tokenMetadata.sortedTokens())</span>
        {
<span class="fc" id="L4965">            InetAddressAndPort endpoint = tokenMetadata.getEndpoint(token);</span>
<span class="fc bfc" id="L4966" title="All 2 branches covered.">            if (dc.equals(snitch.getDatacenter(endpoint)))</span>
<span class="fc" id="L4967">                filteredTokens.add(token);</span>
<span class="fc" id="L4968">        }</span>

<span class="fc" id="L4970">        return getAllRanges(filteredTokens).stream()</span>
<span class="fc" id="L4971">                                           .filter(t -&gt; tokens.contains(t.right))</span>
<span class="fc" id="L4972">                                           .collect(Collectors.toList());</span>
    }

    /**
     * Get all ranges that span the ring given a set
     * of tokens. All ranges are in sorted order of
     * ranges.
     * @return ranges in sorted order
    */
    public List&lt;Range&lt;Token&gt;&gt; getAllRanges(List&lt;Token&gt; sortedTokens)
    {
<span class="pc bpc" id="L4983" title="1 of 2 branches missed.">        if (logger.isTraceEnabled())</span>
<span class="nc" id="L4984">            logger.trace(&quot;computing ranges for {}&quot;, StringUtils.join(sortedTokens, &quot;, &quot;));</span>

<span class="fc bfc" id="L4986" title="All 2 branches covered.">        if (sortedTokens.isEmpty())</span>
<span class="fc" id="L4987">            return Collections.emptyList();</span>
<span class="fc" id="L4988">        int size = sortedTokens.size();</span>
<span class="fc" id="L4989">        List&lt;Range&lt;Token&gt;&gt; ranges = new ArrayList&lt;&gt;(size + 1);</span>
<span class="fc bfc" id="L4990" title="All 2 branches covered.">        for (int i = 1; i &lt; size; ++i)</span>
        {
<span class="fc" id="L4992">            Range&lt;Token&gt; range = new Range&lt;&gt;(sortedTokens.get(i - 1), sortedTokens.get(i));</span>
<span class="fc" id="L4993">            ranges.add(range);</span>
        }
<span class="fc" id="L4995">        Range&lt;Token&gt; range = new Range&lt;&gt;(sortedTokens.get(size - 1), sortedTokens.get(0));</span>
<span class="fc" id="L4996">        ranges.add(range);</span>

<span class="fc" id="L4998">        return ranges;</span>
    }

    /**
     * This method returns the N endpoints that are responsible for storing the
     * specified key i.e for replication.
     *
     * @param keyspaceName keyspace name also known as keyspace
     * @param cf Column family name
     * @param key key for which we need to find the endpoint
     * @return the endpoint responsible for this key
     */
    @Deprecated
    public List&lt;InetAddress&gt; getNaturalEndpoints(String keyspaceName, String cf, String key)
    {
<span class="nc" id="L5013">        EndpointsForToken replicas = getNaturalReplicasForToken(keyspaceName, cf, key);</span>
<span class="nc" id="L5014">        List&lt;InetAddress&gt; inetList = new ArrayList&lt;&gt;(replicas.size());</span>
<span class="nc" id="L5015">        replicas.forEach(r -&gt; inetList.add(r.endpoint().getAddress()));</span>
<span class="nc" id="L5016">        return inetList;</span>
    }

    public List&lt;String&gt; getNaturalEndpointsWithPort(String keyspaceName, String cf, String key)
    {
<span class="nc" id="L5021">        return Replicas.stringify(getNaturalReplicasForToken(keyspaceName, cf, key), true);</span>
    }

    @Deprecated
    public List&lt;InetAddress&gt; getNaturalEndpoints(String keyspaceName, ByteBuffer key)
    {
<span class="nc" id="L5027">        EndpointsForToken replicas = getNaturalReplicasForToken(keyspaceName, key);</span>
<span class="nc" id="L5028">        List&lt;InetAddress&gt; inetList = new ArrayList&lt;&gt;(replicas.size());</span>
<span class="nc" id="L5029">        replicas.forEach(r -&gt; inetList.add(r.endpoint().getAddress()));</span>
<span class="nc" id="L5030">        return inetList;</span>
    }

    public List&lt;String&gt; getNaturalEndpointsWithPort(String keyspaceName, ByteBuffer key)
    {
<span class="nc" id="L5035">        EndpointsForToken replicas = getNaturalReplicasForToken(keyspaceName, key);</span>
<span class="nc" id="L5036">        return Replicas.stringify(replicas, true);</span>
    }

    public EndpointsForToken getNaturalReplicasForToken(String keyspaceName, String cf, String key)
    {
<span class="nc" id="L5041">        return getNaturalReplicasForToken(keyspaceName, partitionKeyToBytes(keyspaceName, cf, key));</span>
    }

    public EndpointsForToken getNaturalReplicasForToken(String keyspaceName, ByteBuffer key)
    {
<span class="nc" id="L5046">        Token token = tokenMetadata.partitioner.getToken(key);</span>
<span class="nc" id="L5047">        return Keyspace.open(keyspaceName).getReplicationStrategy().getNaturalReplicasForToken(token);</span>
    }

    public DecoratedKey getKeyFromPartition(String keyspaceName, String table, String partitionKey)
    {
<span class="fc" id="L5052">        return tokenMetadata.partitioner.decorateKey(partitionKeyToBytes(keyspaceName, table, partitionKey));</span>
    }

    private static ByteBuffer partitionKeyToBytes(String keyspaceName, String cf, String key)
    {
<span class="fc" id="L5057">        KeyspaceMetadata ksMetaData = Schema.instance.getKeyspaceMetadata(keyspaceName);</span>
<span class="pc bpc" id="L5058" title="1 of 2 branches missed.">        if (ksMetaData == null)</span>
<span class="nc" id="L5059">            throw new IllegalArgumentException(&quot;Unknown keyspace '&quot; + keyspaceName + &quot;'&quot;);</span>

<span class="fc" id="L5061">        TableMetadata metadata = ksMetaData.getTableOrViewNullable(cf);</span>
<span class="pc bpc" id="L5062" title="1 of 2 branches missed.">        if (metadata == null)</span>
<span class="nc" id="L5063">            throw new IllegalArgumentException(&quot;Unknown table '&quot; + cf + &quot;' in keyspace '&quot; + keyspaceName + &quot;'&quot;);</span>

<span class="fc" id="L5065">        return metadata.partitionKeyType.fromString(key);</span>
    }

    @Override
    public String getToken(String keyspaceName, String table, String key)
    {
<span class="nc" id="L5071">        return tokenMetadata.partitioner.getToken(partitionKeyToBytes(keyspaceName, table, key)).toString();</span>
    }

    public void setLoggingLevel(String classQualifier, String rawLevel) throws Exception
    {
<span class="nc" id="L5076">        LoggingSupportFactory.getLoggingSupport().setLoggingLevel(classQualifier, rawLevel);</span>
<span class="nc" id="L5077">    }</span>

    /**
     * @return the runtime logging levels for all the configured loggers
     */
    @Override
    public Map&lt;String,String&gt; getLoggingLevels()
    {
<span class="nc" id="L5085">        return LoggingSupportFactory.getLoggingSupport().getLoggingLevels();</span>
    }

    /**
     * @return list of Token ranges (_not_ keys!) together with estimated key count,
     *      breaking up the data this node is responsible for into pieces of roughly keysPerSplit
     */
    public List&lt;Pair&lt;Range&lt;Token&gt;, Long&gt;&gt; getSplits(String keyspaceName, String cfName, Range&lt;Token&gt; range, int keysPerSplit)
    {
<span class="fc" id="L5094">        Keyspace t = Keyspace.open(keyspaceName);</span>
<span class="fc" id="L5095">        ColumnFamilyStore cfs = t.getColumnFamilyStore(cfName);</span>
<span class="fc" id="L5096">        List&lt;DecoratedKey&gt; keys = keySamples(Collections.singleton(cfs), range);</span>

<span class="fc" id="L5098">        long totalRowCountEstimate = cfs.estimatedKeysForRange(range);</span>

        // splitCount should be much smaller than number of key samples, to avoid huge sampling error
<span class="fc" id="L5101">        int minSamplesPerSplit = 4;</span>
<span class="fc" id="L5102">        int maxSplitCount = keys.size() / minSamplesPerSplit + 1;</span>
<span class="fc" id="L5103">        int splitCount = Math.max(1, Math.min(maxSplitCount, (int)(totalRowCountEstimate / keysPerSplit)));</span>

<span class="fc" id="L5105">        List&lt;Token&gt; tokens = keysToTokens(range, keys);</span>
<span class="fc" id="L5106">        return getSplits(tokens, splitCount, cfs);</span>
    }

    private List&lt;Pair&lt;Range&lt;Token&gt;, Long&gt;&gt; getSplits(List&lt;Token&gt; tokens, int splitCount, ColumnFamilyStore cfs)
    {
<span class="fc" id="L5111">        double step = (double) (tokens.size() - 1) / splitCount;</span>
<span class="fc" id="L5112">        Token prevToken = tokens.get(0);</span>
<span class="fc" id="L5113">        List&lt;Pair&lt;Range&lt;Token&gt;, Long&gt;&gt; splits = Lists.newArrayListWithExpectedSize(splitCount);</span>
<span class="fc bfc" id="L5114" title="All 2 branches covered.">        for (int i = 1; i &lt;= splitCount; i++)</span>
        {
<span class="fc" id="L5116">            int index = (int) Math.round(i * step);</span>
<span class="fc" id="L5117">            Token token = tokens.get(index);</span>
<span class="fc" id="L5118">            Range&lt;Token&gt; range = new Range&lt;&gt;(prevToken, token);</span>
            // always return an estimate &gt; 0 (see CASSANDRA-7322)
<span class="fc" id="L5120">            splits.add(Pair.create(range, Math.max(cfs.metadata().params.minIndexInterval, cfs.estimatedKeysForRange(range))));</span>
<span class="fc" id="L5121">            prevToken = token;</span>
        }
<span class="fc" id="L5123">        return splits;</span>
    }

    private List&lt;Token&gt; keysToTokens(Range&lt;Token&gt; range, List&lt;DecoratedKey&gt; keys)
    {
<span class="fc" id="L5128">        List&lt;Token&gt; tokens = Lists.newArrayListWithExpectedSize(keys.size() + 2);</span>
<span class="fc" id="L5129">        tokens.add(range.left);</span>
<span class="pc bpc" id="L5130" title="1 of 2 branches missed.">        for (DecoratedKey key : keys)</span>
<span class="nc" id="L5131">            tokens.add(key.getToken());</span>
<span class="fc" id="L5132">        tokens.add(range.right);</span>
<span class="fc" id="L5133">        return tokens;</span>
    }

    private List&lt;DecoratedKey&gt; keySamples(Iterable&lt;ColumnFamilyStore&gt; cfses, Range&lt;Token&gt; range)
    {
<span class="fc" id="L5138">        List&lt;DecoratedKey&gt; keys = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L5139" title="All 2 branches covered.">        for (ColumnFamilyStore cfs : cfses)</span>
<span class="fc" id="L5140">            Iterables.addAll(keys, cfs.keySamples(range));</span>
<span class="fc" id="L5141">        FBUtilities.sortSampledKeys(keys, range);</span>
<span class="fc" id="L5142">        return keys;</span>
    }

    /**
     * Broadcast leaving status and update local tokenMetadata accordingly
     */
    private void startLeaving()
    {
<span class="nc" id="L5150">        DatabaseDescriptor.getSeverityDuringDecommission().ifPresent(DynamicEndpointSnitch::addSeverity);</span>
<span class="nc" id="L5151">        Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS_WITH_PORT, valueFactory.leaving(getLocalTokens()));</span>
<span class="nc" id="L5152">        Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.leaving(getLocalTokens()));</span>
<span class="nc" id="L5153">        tokenMetadata.addLeavingEndpoint(FBUtilities.getBroadcastAddressAndPort());</span>
<span class="nc" id="L5154">        PendingRangeCalculatorService.instance.update();</span>
<span class="nc" id="L5155">    }</span>

    public void decommission(boolean force) throws InterruptedException
    {
<span class="nc bnc" id="L5159" title="All 2 branches missed.">        if (operationMode == DECOMMISSIONED)</span>
        {
<span class="nc" id="L5161">            logger.info(&quot;This node was already decommissioned. There is no point in decommissioning it again.&quot;);</span>
<span class="nc" id="L5162">            return;</span>
        }

<span class="nc bnc" id="L5165" title="All 2 branches missed.">        if (isDecommissioning())</span>
        {
<span class="nc" id="L5167">            logger.info(&quot;This node is still decommissioning.&quot;);</span>
<span class="nc" id="L5168">            return;</span>
        }

<span class="nc" id="L5171">        TokenMetadata metadata = tokenMetadata.cloneAfterAllLeft();</span>
        // there is no point to do this logic again once node was decommissioning but failed to do so
<span class="nc bnc" id="L5173" title="All 2 branches missed.">        if (operationMode != Mode.LEAVING)</span>
        {
<span class="nc bnc" id="L5175" title="All 2 branches missed.">            if (!tokenMetadata.isMember(FBUtilities.getBroadcastAddressAndPort()))</span>
<span class="nc" id="L5176">                throw new UnsupportedOperationException(&quot;local node is not a member of the token ring yet&quot;);</span>
<span class="nc bnc" id="L5177" title="All 4 branches missed.">            if (metadata.getAllEndpoints().size() &lt; 2 &amp;&amp; metadata.getAllEndpoints().contains(FBUtilities.getBroadcastAddressAndPort()))</span>
<span class="nc" id="L5178">                    throw new UnsupportedOperationException(&quot;no other normal nodes in the ring; decommission would be pointless&quot;);</span>
<span class="nc bnc" id="L5179" title="All 4 branches missed.">            if (operationMode != Mode.NORMAL &amp;&amp; operationMode != DECOMMISSION_FAILED)</span>
<span class="nc" id="L5180">                throw new UnsupportedOperationException(&quot;Node in &quot; + operationMode + &quot; state; wait for status to become normal or restart&quot;);</span>
        }

<span class="nc bnc" id="L5183" title="All 2 branches missed.">        if (!isDecommissioning.compareAndSet(false, true))</span>
<span class="nc" id="L5184">            throw new IllegalStateException(&quot;Node is still decommissioning. Check nodetool netstats or nodetool info.&quot;);</span>

<span class="nc bnc" id="L5186" title="All 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="nc" id="L5187">            logger.debug(&quot;DECOMMISSIONING&quot;);</span>

        try
        {
<span class="nc" id="L5191">            PendingRangeCalculatorService.instance.blockUntilFinished();</span>

<span class="nc" id="L5193">            String dc = DatabaseDescriptor.getEndpointSnitch().getLocalDatacenter();</span>

            // If we're already decommissioning there is no point checking RF/pending ranges
<span class="nc bnc" id="L5196" title="All 2 branches missed.">            if (operationMode != Mode.LEAVING)</span>
            {
                int rf, numNodes;
<span class="nc bnc" id="L5199" title="All 2 branches missed.">                for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())</span>
                {
<span class="nc bnc" id="L5201" title="All 2 branches missed.">                    if (!force)</span>
                    {
<span class="nc" id="L5203">                        boolean notEnoughLiveNodes = false;</span>
<span class="nc" id="L5204">                        Keyspace keyspace = Keyspace.open(keyspaceName);</span>
<span class="nc bnc" id="L5205" title="All 2 branches missed.">                        if (keyspace.getReplicationStrategy() instanceof NetworkTopologyStrategy)</span>
                        {
<span class="nc" id="L5207">                            NetworkTopologyStrategy strategy = (NetworkTopologyStrategy) keyspace.getReplicationStrategy();</span>
<span class="nc" id="L5208">                            rf = strategy.getReplicationFactor(dc).allReplicas;</span>
<span class="nc" id="L5209">                            Collection&lt;InetAddressAndPort&gt; datacenterEndpoints = metadata.getTopology().getDatacenterEndpoints().get(dc);</span>
<span class="nc" id="L5210">                            numNodes = datacenterEndpoints.size();</span>
<span class="nc bnc" id="L5211" title="All 4 branches missed.">                            if (numNodes &lt;= rf &amp;&amp; datacenterEndpoints.contains(FBUtilities.getBroadcastAddressAndPort()))</span>
<span class="nc" id="L5212">                                notEnoughLiveNodes = true;</span>
<span class="nc" id="L5213">                        }</span>
                        else
                        {
<span class="nc" id="L5216">                            Set&lt;InetAddressAndPort&gt; allEndpoints = metadata.getAllEndpoints();</span>
<span class="nc" id="L5217">                            numNodes = allEndpoints.size();</span>
<span class="nc" id="L5218">                            rf = keyspace.getReplicationStrategy().getReplicationFactor().allReplicas;</span>
<span class="nc bnc" id="L5219" title="All 4 branches missed.">                            if (numNodes &lt;= rf &amp;&amp; allEndpoints.contains(FBUtilities.getBroadcastAddressAndPort()))</span>
<span class="nc" id="L5220">                                notEnoughLiveNodes = true;</span>
                        }

<span class="nc bnc" id="L5223" title="All 2 branches missed.">                        if (notEnoughLiveNodes)</span>
<span class="nc" id="L5224">                            throw new UnsupportedOperationException(&quot;Not enough live nodes to maintain replication factor in keyspace &quot;</span>
                                                                    + keyspaceName + &quot; (RF = &quot; + rf + &quot;, N = &quot; + numNodes + &quot;).&quot;
                                                                    + &quot; Perform a forceful decommission to ignore.&quot;);
                    }
                    // TODO: do we care about fixing transient/full self-movements here? probably
<span class="nc bnc" id="L5229" title="All 2 branches missed.">                    if (tokenMetadata.getPendingRanges(keyspaceName, FBUtilities.getBroadcastAddressAndPort()).size() &gt; 0)</span>
<span class="nc" id="L5230">                        throw new UnsupportedOperationException(&quot;data is currently moving to this node; unable to leave the ring&quot;);</span>
<span class="nc" id="L5231">                }</span>
            }

<span class="nc" id="L5234">            startLeaving();</span>
<span class="nc" id="L5235">            long timeout = Math.max(RING_DELAY_MILLIS, BatchlogManager.getBatchlogTimeout());</span>
<span class="nc" id="L5236">            setMode(Mode.LEAVING, &quot;sleeping &quot; + timeout + &quot; ms for batch processing and pending range setup&quot;, true);</span>
<span class="nc" id="L5237">            Thread.sleep(timeout);</span>

<span class="nc" id="L5239">            unbootstrap();</span>

            // shutdown cql, gossip, messaging, Stage and set state to DECOMMISSIONED

<span class="nc" id="L5243">            shutdownClientServers();</span>
<span class="nc" id="L5244">            Gossiper.instance.stop();</span>
            try
            {
<span class="nc" id="L5247">                MessagingService.instance().shutdown();</span>
            }
<span class="nc" id="L5249">            catch (IOError ioe)</span>
            {
<span class="nc" id="L5251">                logger.info(&quot;failed to shutdown message service&quot;, ioe);</span>
<span class="nc" id="L5252">            }</span>

<span class="nc" id="L5254">            Stage.shutdownNow();</span>
<span class="nc" id="L5255">            SystemKeyspace.setBootstrapState(SystemKeyspace.BootstrapState.DECOMMISSIONED);</span>
<span class="nc" id="L5256">            setMode(DECOMMISSIONED, true);</span>
            // let op be responsible for killing the process
        }
<span class="nc" id="L5259">        catch (InterruptedException e)</span>
        {
<span class="nc" id="L5261">            setMode(DECOMMISSION_FAILED, true);</span>
<span class="nc" id="L5262">            logger.error(&quot;Node interrupted while decommissioning&quot;);</span>
<span class="nc" id="L5263">            throw new RuntimeException(&quot;Node interrupted while decommissioning&quot;);</span>
        }
<span class="nc" id="L5265">        catch (ExecutionException e)</span>
        {
<span class="nc" id="L5267">            setMode(DECOMMISSION_FAILED, true);</span>
<span class="nc" id="L5268">            logger.error(&quot;Error while decommissioning node: {}&quot;, e.getCause().getMessage());</span>
<span class="nc" id="L5269">            throw new RuntimeException(&quot;Error while decommissioning node: &quot; + e.getCause().getMessage());</span>
        }
<span class="nc" id="L5271">        catch (Throwable t)</span>
        {
<span class="nc" id="L5273">            setMode(DECOMMISSION_FAILED, true);</span>
<span class="nc" id="L5274">            logger.error(&quot;Error while decommissioning node: {}&quot;, t.getMessage());</span>
<span class="nc" id="L5275">            throw t;</span>
        }
        finally
        {
<span class="nc" id="L5279">            isDecommissioning.set(false);</span>
        }
<span class="nc" id="L5281">    }</span>

    private void leaveRing()
    {
<span class="nc" id="L5285">        SystemKeyspace.setBootstrapState(SystemKeyspace.BootstrapState.NEEDS_BOOTSTRAP);</span>
<span class="nc" id="L5286">        tokenMetadata.removeEndpoint(FBUtilities.getBroadcastAddressAndPort());</span>
<span class="nc" id="L5287">        PendingRangeCalculatorService.instance.update();</span>

<span class="nc" id="L5289">        Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS_WITH_PORT, valueFactory.left(getLocalTokens(),Gossiper.computeExpireTime()));</span>
<span class="nc" id="L5290">        Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.left(getLocalTokens(),Gossiper.computeExpireTime()));</span>
<span class="nc" id="L5291">        int delay = Math.max(RING_DELAY_MILLIS, Gossiper.intervalInMillis * 2);</span>
<span class="nc" id="L5292">        logger.info(&quot;Announcing that I have left the ring for {}ms&quot;, delay);</span>
<span class="nc" id="L5293">        Uninterruptibles.sleepUninterruptibly(delay, MILLISECONDS);</span>
<span class="nc" id="L5294">    }</span>

    public Supplier&lt;Future&lt;StreamState&gt;&gt; prepareUnbootstrapStreaming()
    {
<span class="nc" id="L5298">        Map&lt;String, EndpointsByReplica&gt; rangesToStream = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L5300" title="All 2 branches missed.">        for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())</span>
        {
<span class="nc" id="L5302">            EndpointsByReplica rangesMM = getChangedReplicasForLeaving(keyspaceName, FBUtilities.getBroadcastAddressAndPort(), tokenMetadata, Keyspace.open(keyspaceName).getReplicationStrategy());</span>

<span class="nc bnc" id="L5304" title="All 2 branches missed.">            if (logger.isDebugEnabled())</span>
<span class="nc" id="L5305">                logger.debug(&quot;Ranges needing transfer are [{}]&quot;, StringUtils.join(rangesMM.keySet(), &quot;,&quot;));</span>

<span class="nc" id="L5307">            rangesToStream.put(keyspaceName, rangesMM);</span>
<span class="nc" id="L5308">        }</span>

<span class="nc" id="L5310">        return () -&gt; streamRanges(rangesToStream);</span>
    }

    private void unbootstrap() throws ExecutionException, InterruptedException
    {
<span class="nc" id="L5315">        Supplier&lt;Future&lt;StreamState&gt;&gt; startStreaming = prepareUnbootstrapStreaming();</span>

<span class="nc" id="L5317">        setMode(Mode.LEAVING, &quot;replaying batch log and streaming data to other nodes&quot;, true);</span>

<span class="nc" id="L5319">        repairPaxosForTopologyChange(&quot;decommission&quot;);</span>
        // Start with BatchLog replay, which may create hints but no writes since this is no longer a valid endpoint.
<span class="nc" id="L5321">        Future&lt;?&gt; batchlogReplay = BatchlogManager.instance.startBatchlogReplay();</span>
<span class="nc" id="L5322">        Future&lt;StreamState&gt; streamSuccess = startStreaming.get();</span>

        // Wait for batch log to complete before streaming hints.
<span class="nc" id="L5325">        logger.debug(&quot;waiting for batch log processing.&quot;);</span>
<span class="nc" id="L5326">        batchlogReplay.get();</span>

<span class="nc" id="L5328">        Future&lt;?&gt; hintsSuccess = ImmediateFuture.success(null);</span>

<span class="nc bnc" id="L5330" title="All 2 branches missed.">        if (DatabaseDescriptor.getTransferHintsOnDecommission()) </span>
        {
<span class="nc" id="L5332">            setMode(Mode.LEAVING, &quot;streaming hints to other nodes&quot;, true);</span>
<span class="nc" id="L5333">            hintsSuccess = streamHints();</span>
        }
        else
        {
<span class="nc" id="L5337">            setMode(Mode.LEAVING, &quot;pausing dispatch and deleting hints&quot;, true);</span>
<span class="nc" id="L5338">            DatabaseDescriptor.setHintedHandoffEnabled(false);</span>
<span class="nc" id="L5339">            HintsService.instance.pauseDispatch();</span>
<span class="nc" id="L5340">            HintsService.instance.deleteAllHints();</span>
        }

        // wait for the transfer runnables to signal the latch.
<span class="nc" id="L5344">        logger.debug(&quot;waiting for stream acks.&quot;);</span>
<span class="nc" id="L5345">        streamSuccess.get();</span>
<span class="nc" id="L5346">        hintsSuccess.get();</span>
<span class="nc" id="L5347">        logger.debug(&quot;stream acks all received.&quot;);</span>
<span class="nc" id="L5348">        leaveRing();</span>
<span class="nc" id="L5349">    }</span>

    private Future streamHints()
    {
<span class="nc" id="L5353">        return HintsService.instance.transferHints(this::getPreferredHintsStreamTarget);</span>
    }

    private static EndpointsForRange getStreamCandidates(Collection&lt;InetAddressAndPort&gt; endpoints)
    {
<span class="nc" id="L5358">        endpoints = endpoints.stream()</span>
<span class="nc bnc" id="L5359" title="All 4 branches missed.">                             .filter(endpoint -&gt; FailureDetector.instance.isAlive(endpoint) &amp;&amp; !FBUtilities.getBroadcastAddressAndPort().equals(endpoint))</span>
<span class="nc" id="L5360">                             .collect(Collectors.toList());</span>

<span class="nc" id="L5362">        return SystemReplicas.getSystemReplicas(endpoints);</span>
    }
    /**
     * Find the best target to stream hints to. Currently the closest peer according to the snitch
     */
    private UUID getPreferredHintsStreamTarget()
    {
<span class="nc" id="L5369">        Set&lt;InetAddressAndPort&gt; endpoints = StorageService.instance.getTokenMetadata().cloneAfterAllLeft().getAllEndpoints();</span>

<span class="nc" id="L5371">        EndpointsForRange candidates = getStreamCandidates(endpoints);</span>
<span class="nc bnc" id="L5372" title="All 2 branches missed.">        if (candidates.isEmpty())</span>
        {
<span class="nc" id="L5374">            logger.warn(&quot;Unable to stream hints since no live endpoints seen&quot;);</span>
<span class="nc" id="L5375">            throw new RuntimeException(&quot;Unable to stream hints since no live endpoints seen&quot;);</span>
        }
        else
        {
            // stream to the closest peer as chosen by the snitch
<span class="nc" id="L5380">            candidates = DatabaseDescriptor.getEndpointSnitch().sortedByProximity(FBUtilities.getBroadcastAddressAndPort(), candidates);</span>
<span class="nc" id="L5381">            InetAddressAndPort hintsDestinationHost = candidates.get(0).endpoint();</span>
<span class="nc" id="L5382">            return tokenMetadata.getHostId(hintsDestinationHost);</span>
        }
    }

    public void move(String newToken) throws IOException
    {
        try
        {
<span class="nc" id="L5390">            getTokenFactory().validate(newToken);</span>
        }
<span class="nc" id="L5392">        catch (ConfigurationException e)</span>
        {
<span class="nc" id="L5394">            throw new IOException(e.getMessage());</span>
<span class="nc" id="L5395">        }</span>
<span class="nc" id="L5396">        move(getTokenFactory().fromString(newToken));</span>
<span class="nc" id="L5397">    }</span>

    /**
     * move the node to new token or find a new token to boot to according to load
     *
     * @param newToken new token to boot to, or if null, find balanced token to boot to
     *
     * @throws IOException on any I/O operation error
     */
    private void move(Token newToken) throws IOException
    {
<span class="nc bnc" id="L5408" title="All 2 branches missed.">        if (newToken == null)</span>
<span class="nc" id="L5409">            throw new IOException(&quot;Can't move to the undefined (null) token.&quot;);</span>

<span class="nc bnc" id="L5411" title="All 2 branches missed.">        if (tokenMetadata.sortedTokens().contains(newToken))</span>
<span class="nc" id="L5412">            throw new IOException(&quot;target token &quot; + newToken + &quot; is already owned by another node.&quot;);</span>

        // address of the current node
<span class="nc" id="L5415">        InetAddressAndPort localAddress = FBUtilities.getBroadcastAddressAndPort();</span>

        // This doesn't make any sense in a vnodes environment.
<span class="nc bnc" id="L5418" title="All 2 branches missed.">        if (getTokenMetadata().getTokens(localAddress).size() &gt; 1)</span>
        {
<span class="nc" id="L5420">            logger.error(&quot;Invalid request to move(Token); This node has more than one token and cannot be moved thusly.&quot;);</span>
<span class="nc" id="L5421">            throw new UnsupportedOperationException(&quot;This node has more than one token and cannot be moved thusly.&quot;);</span>
        }

<span class="nc" id="L5424">        List&lt;String&gt; keyspacesToProcess = ImmutableList.copyOf(Schema.instance.getNonLocalStrategyKeyspaces().names());</span>

<span class="nc" id="L5426">        PendingRangeCalculatorService.instance.blockUntilFinished();</span>
        // checking if data is moving to this node
<span class="nc bnc" id="L5428" title="All 2 branches missed.">        for (String keyspaceName : keyspacesToProcess)</span>
        {
            // TODO: do we care about fixing transient/full self-movements here?
<span class="nc bnc" id="L5431" title="All 2 branches missed.">            if (tokenMetadata.getPendingRanges(keyspaceName, localAddress).size() &gt; 0)</span>
<span class="nc" id="L5432">                throw new UnsupportedOperationException(&quot;data is currently moving to this node; unable to leave the ring&quot;);</span>
<span class="nc" id="L5433">        }</span>

<span class="nc" id="L5435">        Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS_WITH_PORT, valueFactory.moving(newToken));</span>
<span class="nc" id="L5436">        Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.moving(newToken));</span>
<span class="nc" id="L5437">        setMode(Mode.MOVING, String.format(&quot;Moving %s from %s to %s.&quot;, localAddress, getLocalTokens().iterator().next(), newToken), true);</span>

<span class="nc" id="L5439">        setMode(Mode.MOVING, String.format(&quot;Sleeping %s ms before start streaming/fetching ranges&quot;, RING_DELAY_MILLIS), true);</span>
<span class="nc" id="L5440">        Uninterruptibles.sleepUninterruptibly(RING_DELAY_MILLIS, MILLISECONDS);</span>

<span class="nc" id="L5442">        RangeRelocator relocator = new RangeRelocator(Collections.singleton(newToken), keyspacesToProcess, tokenMetadata);</span>
<span class="nc" id="L5443">        relocator.calculateToFromStreams();</span>

<span class="nc" id="L5445">        repairPaxosForTopologyChange(&quot;move&quot;);</span>
<span class="nc bnc" id="L5446" title="All 2 branches missed.">        if (relocator.streamsNeeded())</span>
        {
<span class="nc" id="L5448">            setMode(Mode.MOVING, &quot;fetching new ranges and streaming old ranges&quot;, true);</span>
            try
            {
<span class="nc" id="L5451">                relocator.stream().get();</span>
            }
<span class="nc" id="L5453">            catch (InterruptedException e)</span>
            {
<span class="nc" id="L5455">                throw new UncheckedInterruptedException(e);</span>
            }
<span class="nc" id="L5457">            catch (ExecutionException e)</span>
            {
<span class="nc" id="L5459">                throw new RuntimeException(&quot;Interrupted while waiting for stream/fetch ranges to finish: &quot; + e.getMessage());</span>
<span class="nc" id="L5460">            }</span>
        }
        else
        {
<span class="nc" id="L5464">            setMode(Mode.MOVING, &quot;No ranges to fetch/stream&quot;, true);</span>
        }

<span class="nc" id="L5467">        setTokens(Collections.singleton(newToken)); // setting new token as we have everything settled</span>

<span class="nc bnc" id="L5469" title="All 2 branches missed.">        if (logger.isDebugEnabled())</span>
<span class="nc" id="L5470">            logger.debug(&quot;Successfully moved to new token {}&quot;, getLocalTokens().iterator().next());</span>
<span class="nc" id="L5471">    }</span>

    public String getRemovalStatus()
    {
<span class="nc" id="L5475">        return getRemovalStatus(false);</span>
    }

    public String getRemovalStatusWithPort()
    {
<span class="nc" id="L5480">        return getRemovalStatus(true);</span>
    }

    /**
     * Get the status of a token removal.
     */
    private String getRemovalStatus(boolean withPort)
    {
<span class="nc bnc" id="L5488" title="All 2 branches missed.">        if (removingNode == null)</span>
        {
<span class="nc" id="L5490">            return &quot;No token removals in process.&quot;;</span>
        }

<span class="nc" id="L5493">        Collection toFormat = replicatingNodes;</span>
<span class="nc bnc" id="L5494" title="All 2 branches missed.">        if (!withPort)</span>
        {
<span class="nc" id="L5496">            toFormat = new ArrayList(replicatingNodes.size());</span>
<span class="nc bnc" id="L5497" title="All 2 branches missed.">            for (InetAddressAndPort node : replicatingNodes)</span>
            {
<span class="nc" id="L5499">                toFormat.add(node.toString(false));</span>
<span class="nc" id="L5500">            }</span>
        }

<span class="nc" id="L5503">        return String.format(&quot;Removing token (%s). Waiting for replication confirmation from [%s].&quot;,</span>
<span class="nc" id="L5504">                             tokenMetadata.getToken(removingNode),</span>
<span class="nc" id="L5505">                             StringUtils.join(toFormat, &quot;,&quot;));</span>
    }

    /**
     * Force a remove operation to complete. This may be necessary if a remove operation
     * blocks forever due to node/stream failure. removeNode() must be called
     * first, this is a last resort measure.  No further attempt will be made to restore replicas.
     */
    public void forceRemoveCompletion()
    {
<span class="nc bnc" id="L5515" title="All 4 branches missed.">        if (!replicatingNodes.isEmpty()  || tokenMetadata.getSizeOfLeavingEndpoints() &gt; 0)</span>
        {
<span class="nc" id="L5517">            logger.warn(&quot;Removal not confirmed for for {}&quot;, StringUtils.join(this.replicatingNodes, &quot;,&quot;));</span>
<span class="nc bnc" id="L5518" title="All 2 branches missed.">            for (InetAddressAndPort endpoint : tokenMetadata.getLeavingEndpoints())</span>
            {
<span class="nc" id="L5520">                UUID hostId = tokenMetadata.getHostId(endpoint);</span>
<span class="nc" id="L5521">                Gossiper.instance.advertiseTokenRemoved(endpoint, hostId);</span>
<span class="nc" id="L5522">                excise(tokenMetadata.getTokens(endpoint), endpoint);</span>
<span class="nc" id="L5523">            }</span>
<span class="nc" id="L5524">            replicatingNodes.clear();</span>
<span class="nc" id="L5525">            removingNode = null;</span>
        }
        else
        {
<span class="nc" id="L5529">            logger.warn(&quot;No nodes to force removal on, call 'removenode' first&quot;);</span>
        }
<span class="nc" id="L5531">    }</span>

    /**
     * Remove a node that has died, attempting to restore the replica count.
     * If the node is alive, decommission should be attempted.  If decommission
     * fails, then removeNode should be called.  If we fail while trying to
     * restore the replica count, finally forceRemoveCompleteion should be
     * called to forcibly remove the node without regard to replica count.
     *
     * @param hostIdString Host ID for the node
     */
    public void removeNode(String hostIdString)
    {
<span class="fc" id="L5544">        InetAddressAndPort myAddress = FBUtilities.getBroadcastAddressAndPort();</span>
<span class="fc" id="L5545">        UUID localHostId = tokenMetadata.getHostId(myAddress);</span>
<span class="fc" id="L5546">        UUID hostId = UUID.fromString(hostIdString);</span>
<span class="fc" id="L5547">        InetAddressAndPort endpoint = tokenMetadata.getEndpointForHostId(hostId);</span>

<span class="fc bfc" id="L5549" title="All 2 branches covered.">        if (endpoint == null)</span>
<span class="fc" id="L5550">            throw new UnsupportedOperationException(&quot;Host ID not found.&quot;);</span>

<span class="fc bfc" id="L5552" title="All 2 branches covered.">        if (!tokenMetadata.isMember(endpoint))</span>
<span class="fc" id="L5553">            throw new UnsupportedOperationException(&quot;Node to be removed is not a member of the token ring&quot;);</span>

<span class="fc bfc" id="L5555" title="All 2 branches covered.">        if (endpoint.equals(myAddress))</span>
<span class="fc" id="L5556">             throw new UnsupportedOperationException(&quot;Cannot remove self&quot;);</span>

<span class="pc bpc" id="L5558" title="1 of 2 branches missed.">        if (Gossiper.instance.getLiveMembers().contains(endpoint))</span>
<span class="nc" id="L5559">            throw new UnsupportedOperationException(&quot;Node &quot; + endpoint + &quot; is alive and owns this ID. Use decommission command to remove it from the ring&quot;);</span>

        // A leaving endpoint that is dead is already being removed.
<span class="pc bpc" id="L5562" title="1 of 2 branches missed.">        if (tokenMetadata.isLeaving(endpoint))</span>
<span class="nc" id="L5563">            logger.warn(&quot;Node {} is already being removed, continuing removal anyway&quot;, endpoint);</span>

<span class="pc bpc" id="L5565" title="1 of 2 branches missed.">        if (!replicatingNodes.isEmpty())</span>
<span class="nc" id="L5566">            throw new UnsupportedOperationException(&quot;This node is already processing a removal. Wait for it to complete, or use 'removenode force' if this has failed.&quot;);</span>

<span class="fc" id="L5568">        Collection&lt;Token&gt; tokens = tokenMetadata.getTokens(endpoint);</span>

        // Find the endpoints that are going to become responsible for data
<span class="pc bpc" id="L5571" title="1 of 2 branches missed.">        for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())</span>
        {
            // if the replication factor is 1 the data is lost so we shouldn't wait for confirmation
<span class="nc bnc" id="L5574" title="All 2 branches missed.">            if (Keyspace.open(keyspaceName).getReplicationStrategy().getReplicationFactor().allReplicas == 1)</span>
<span class="nc" id="L5575">                continue;</span>

            // get all ranges that change ownership (that is, a node needs
            // to take responsibility for new range)
<span class="nc" id="L5579">            EndpointsByReplica changedRanges = getChangedReplicasForLeaving(keyspaceName, endpoint, tokenMetadata, Keyspace.open(keyspaceName).getReplicationStrategy());</span>
<span class="nc" id="L5580">            IFailureDetector failureDetector = FailureDetector.instance;</span>
<span class="nc bnc" id="L5581" title="All 2 branches missed.">            for (InetAddressAndPort ep : transform(changedRanges.flattenValues(), Replica::endpoint))</span>
            {
<span class="nc bnc" id="L5583" title="All 2 branches missed.">                if (failureDetector.isAlive(ep))</span>
<span class="nc" id="L5584">                    replicatingNodes.add(ep);</span>
                else
<span class="nc" id="L5586">                    logger.warn(&quot;Endpoint {} is down and will not receive data for re-replication of {}&quot;, ep, endpoint);</span>
<span class="nc" id="L5587">            }</span>
<span class="nc" id="L5588">        }</span>
<span class="fc" id="L5589">        removingNode = endpoint;</span>

<span class="fc" id="L5591">        tokenMetadata.addLeavingEndpoint(endpoint);</span>
<span class="fc" id="L5592">        PendingRangeCalculatorService.instance.update();</span>

        // the gossiper will handle spoofing this node's state to REMOVING_TOKEN for us
        // we add our own token so other nodes to let us know when they're done
<span class="fc" id="L5596">        Gossiper.instance.advertiseRemoving(endpoint, hostId, localHostId);</span>

        // kick off streaming commands
<span class="fc" id="L5599">        restoreReplicaCount(endpoint, myAddress);</span>

        // wait for ReplicationDoneVerbHandler to signal we're done
<span class="pc bpc" id="L5602" title="1 of 2 branches missed.">        while (!replicatingNodes.isEmpty())</span>
        {
<span class="nc" id="L5604">            Uninterruptibles.sleepUninterruptibly(100, MILLISECONDS);</span>
        }

<span class="fc" id="L5607">        excise(tokens, endpoint);</span>

        // gossiper will indicate the token has left
<span class="fc" id="L5610">        Gossiper.instance.advertiseTokenRemoved(endpoint, hostId);</span>

<span class="fc" id="L5612">        replicatingNodes.clear();</span>
<span class="fc" id="L5613">        removingNode = null;</span>
<span class="fc" id="L5614">    }</span>

    public void confirmReplication(InetAddressAndPort node)
    {
        // replicatingNodes can be empty in the case where this node used to be a removal coordinator,
        // but restarted before all 'replication finished' messages arrived. In that case, we'll
        // still go ahead and acknowledge it.
<span class="pc bpc" id="L5621" title="1 of 2 branches missed.">        if (!replicatingNodes.isEmpty())</span>
        {
<span class="nc" id="L5623">            replicatingNodes.remove(node);</span>
        }
        else
        {
<span class="fc" id="L5627">            logger.info(&quot;Received unexpected REPLICATION_FINISHED message from {}. Was this node recently a removal coordinator?&quot;, node);</span>
        }
<span class="fc" id="L5629">    }</span>

    public String getOperationMode()
    {
<span class="fc" id="L5633">        return operationMode.toString();</span>
    }

    public boolean isStarting()
    {
<span class="fc bfc" id="L5638" title="All 2 branches covered.">        return operationMode == Mode.STARTING;</span>
    }

    public boolean isMoving()
    {
<span class="pc bpc" id="L5643" title="1 of 2 branches missed.">        return operationMode == Mode.MOVING;</span>
    }

    public boolean isJoining()
    {
<span class="pc bpc" id="L5648" title="1 of 2 branches missed.">        return operationMode == Mode.JOINING;</span>
    }

    public boolean isDrained()
    {
<span class="nc bnc" id="L5653" title="All 2 branches missed.">        return operationMode == Mode.DRAINED;</span>
    }

    public boolean isDraining()
    {
<span class="fc bfc" id="L5658" title="All 2 branches covered.">        return operationMode == Mode.DRAINING;</span>
    }

    public boolean isNormal()
    {
<span class="pc bpc" id="L5663" title="1 of 2 branches missed.">        return operationMode == Mode.NORMAL;</span>
    }

    public boolean isDecommissioned()
    {
<span class="nc bnc" id="L5668" title="All 2 branches missed.">        return operationMode == DECOMMISSIONED;</span>
    }

    public boolean isDecommissionFailed()
    {
<span class="nc bnc" id="L5673" title="All 2 branches missed.">        return operationMode == DECOMMISSION_FAILED;</span>
    }

    public boolean isDecommissioning()
    {
<span class="nc" id="L5678">        return isDecommissioning.get();</span>
    }

    public boolean isBootstrapFailed()
    {
<span class="nc bnc" id="L5683" title="All 2 branches missed.">        return operationMode == JOINING_FAILED;</span>
    }

    public String getDrainProgress()
    {
<span class="nc" id="L5688">        return String.format(&quot;Drained %s/%s ColumnFamilies&quot;, remainingCFs, totalCFs);</span>
    }

    /**
     * Shuts node off to writes, empties memtables and the commit log.
     */
    public synchronized void drain() throws IOException, InterruptedException, ExecutionException
    {
<span class="fc" id="L5696">        drain(false);</span>
<span class="fc" id="L5697">    }</span>

    protected synchronized void drain(boolean isFinalShutdown) throws IOException, InterruptedException, ExecutionException
    {
<span class="fc bfc" id="L5701" title="All 2 branches covered.">        if (Stage.areMutationExecutorsTerminated())</span>
        {
<span class="pc bpc" id="L5703" title="1 of 2 branches missed.">            if (!isFinalShutdown)</span>
<span class="nc" id="L5704">                logger.warn(&quot;Cannot drain node (did it already happen?)&quot;);</span>
<span class="fc" id="L5705">            return;</span>
        }

<span class="pc bpc" id="L5708" title="1 of 2 branches missed.">        assert !isShutdown;</span>
<span class="fc" id="L5709">        isShutdown = true;</span>

<span class="pc" id="L5711">        Throwable preShutdownHookThrowable = Throwables.perform(null, preShutdownHooks.stream().map(h -&gt; h::run));</span>
<span class="pc bpc" id="L5712" title="1 of 2 branches missed.">        if (preShutdownHookThrowable != null)</span>
<span class="nc" id="L5713">            logger.error(&quot;Attempting to continue draining after pre-shutdown hooks returned exception&quot;, preShutdownHookThrowable);</span>

        try
        {
<span class="fc bfc" id="L5717" title="All 2 branches covered.">            setMode(Mode.DRAINING, &quot;starting drain process&quot;, !isFinalShutdown);</span>

            try
            {
                /* not clear this is reasonable time, but propagated from prior embedded behaviour */
<span class="fc" id="L5722">                BatchlogManager.instance.shutdownAndWait(1L, MINUTES);</span>
            }
<span class="nc" id="L5724">            catch (TimeoutException t)</span>
            {
<span class="nc" id="L5726">                logger.error(&quot;Batchlog manager timed out shutting down&quot;, t);</span>
<span class="fc" id="L5727">            }</span>

<span class="fc" id="L5729">            snapshotManager.stop();</span>
<span class="fc" id="L5730">            HintsService.instance.pauseDispatch();</span>

<span class="fc bfc" id="L5732" title="All 2 branches covered.">            if (daemon != null)</span>
<span class="fc" id="L5733">                shutdownClientServers();</span>
<span class="fc" id="L5734">            ScheduledExecutors.optionalTasks.shutdown();</span>
<span class="fc" id="L5735">            Gossiper.instance.stop();</span>
<span class="fc" id="L5736">            ActiveRepairService.instance().stop();</span>

<span class="pc bpc" id="L5738" title="1 of 2 branches missed.">            if (!isFinalShutdown)</span>
<span class="fc" id="L5739">                setMode(Mode.DRAINING, &quot;shutting down MessageService&quot;, false);</span>

            // In-progress writes originating here could generate hints to be written,
            // which is currently scheduled on the mutation stage. So shut down MessagingService
            // before mutation stage, so we can get all the hints saved before shutting down.
            try
            {
<span class="fc" id="L5746">                MessagingService.instance().shutdown();</span>
            }
<span class="nc" id="L5748">            catch (Throwable t)</span>
            {
                // prevent messaging service timing out shutdown from aborting
                // drain process; otherwise drain and/or shutdown might throw
<span class="nc" id="L5752">                logger.error(&quot;Messaging service timed out shutting down&quot;, t);</span>
<span class="fc" id="L5753">            }</span>

<span class="pc bpc" id="L5755" title="1 of 2 branches missed.">            if (!isFinalShutdown)</span>
<span class="fc" id="L5756">                setMode(Mode.DRAINING, &quot;clearing mutation stage&quot;, false);</span>
<span class="fc" id="L5757">            Stage.shutdownAndAwaitMutatingExecutors(false,</span>
<span class="fc" id="L5758">                                                    DRAIN_EXECUTOR_TIMEOUT_MS.getInt(), TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L5760">            StorageProxy.instance.verifyNoHintsInProgress();</span>

<span class="pc bpc" id="L5762" title="1 of 2 branches missed.">            if (!isFinalShutdown)</span>
<span class="fc" id="L5763">                setMode(Mode.DRAINING, &quot;flushing column families&quot;, false);</span>

            // we don't want to start any new compactions while we are draining
<span class="fc" id="L5766">            disableAutoCompaction();</span>

            // count CFs first, since forceFlush could block for the flushWriter to get a queue slot empty
<span class="fc" id="L5769">            totalCFs = 0;</span>
<span class="fc bfc" id="L5770" title="All 2 branches covered.">            for (Keyspace keyspace : Keyspace.nonSystem())</span>
<span class="fc" id="L5771">                totalCFs += keyspace.getColumnFamilyStores().size();</span>
<span class="fc" id="L5772">            remainingCFs = totalCFs;</span>
            // flush
<span class="fc" id="L5774">            List&lt;Future&lt;?&gt;&gt; flushes = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L5775" title="All 2 branches covered.">            for (Keyspace keyspace : Keyspace.nonSystem())</span>
            {
<span class="fc bfc" id="L5777" title="All 2 branches covered.">                for (ColumnFamilyStore cfs : keyspace.getColumnFamilyStores())</span>
<span class="fc" id="L5778">                    flushes.add(cfs.forceFlush(ColumnFamilyStore.FlushReason.DRAIN));</span>
<span class="fc" id="L5779">            }</span>
            // wait for the flushes.
            // TODO this is a godawful way to track progress, since they flush in parallel.  a long one could
            // thus make several short ones &quot;instant&quot; if we wait for them later.
<span class="fc bfc" id="L5783" title="All 2 branches covered.">            for (Future f : flushes)</span>
            {
                try
                {
<span class="fc" id="L5787">                    FBUtilities.waitOnFuture(f);</span>
                }
<span class="nc" id="L5789">                catch (Throwable t)</span>
                {
<span class="nc" id="L5791">                    JVMStabilityInspector.inspectThrowable(t);</span>
                    // don't let this stop us from shutting down the commitlog and other thread pools
<span class="nc" id="L5793">                    logger.warn(&quot;Caught exception while waiting for memtable flushes during shutdown hook&quot;, t);</span>
<span class="fc" id="L5794">                }</span>

<span class="fc" id="L5796">                remainingCFs--;</span>
<span class="fc" id="L5797">            }</span>

            // Interrupt ongoing compactions and shutdown CM to prevent further compactions.
<span class="fc" id="L5800">            CompactionManager.instance.forceShutdown();</span>
            // Flush the system tables after all other tables are flushed, just in case flushing modifies any system state
            // like CASSANDRA-5151. Don't bother with progress tracking since system data is tiny.
            // Flush system tables after stopping compactions since they modify
            // system tables (for example compactions can obsolete sstables and the tidiers in SSTableReader update
            // system tables, see SSTableReader.GlobalTidy)
<span class="fc" id="L5806">            flushes.clear();</span>
<span class="fc bfc" id="L5807" title="All 2 branches covered.">            for (Keyspace keyspace : Keyspace.system())</span>
            {
<span class="fc bfc" id="L5809" title="All 2 branches covered.">                for (ColumnFamilyStore cfs : keyspace.getColumnFamilyStores())</span>
<span class="fc" id="L5810">                    flushes.add(cfs.forceFlush(ColumnFamilyStore.FlushReason.DRAIN));</span>
<span class="fc" id="L5811">            }</span>
<span class="fc" id="L5812">            FBUtilities.waitOnFutures(flushes);</span>

<span class="fc" id="L5814">            SnapshotManager.shutdownAndWait(1L, MINUTES);</span>
<span class="fc" id="L5815">            HintsService.instance.shutdownBlocking();</span>

            // Interrupt ongoing compactions and shutdown CM to prevent further compactions.
<span class="fc" id="L5818">            CompactionManager.instance.forceShutdown();</span>

            // whilst we've flushed all the CFs, which will have recycled all completed segments, we want to ensure
            // there are no segments to replay, so we force the recycling of any remaining (should be at most one)
<span class="fc" id="L5822">            CommitLog.instance.forceRecycleAllSegments();</span>

<span class="fc" id="L5824">            CommitLog.instance.shutdownBlocking();</span>

            // wait for miscellaneous tasks like sstable and commitlog segment deletion
<span class="fc" id="L5827">            ColumnFamilyStore.shutdownPostFlushExecutor();</span>

            try
            {
                // we are not shutting down ScheduledExecutors#scheduledFastTasks to be still able to progress time
                // fast-tasks executor is shut down in StorageService's shutdown hook added to Runtime
<span class="fc" id="L5833">                ExecutorUtils.shutdownNowAndWait(1, MINUTES,</span>
                                                 ScheduledExecutors.nonPeriodicTasks,
                                                 ScheduledExecutors.scheduledTasks,
                                                 ScheduledExecutors.optionalTasks);
            }
            finally
            {
<span class="pc bpc" id="L5840" title="1 of 2 branches missed.">                setMode(Mode.DRAINED, !isFinalShutdown);</span>
            }
        }
<span class="nc" id="L5843">        catch (Throwable t)</span>
        {
<span class="nc" id="L5845">            logger.error(&quot;Caught an exception while draining &quot;, t);</span>
        }
        finally
        {
<span class="pc" id="L5849">            Throwable postShutdownHookThrowable = Throwables.perform(null, postShutdownHooks.stream().map(h -&gt; h::run));</span>
<span class="pc bpc" id="L5850" title="1 of 2 branches missed.">            if (postShutdownHookThrowable != null)</span>
<span class="nc" id="L5851">                logger.error(&quot;Post-shutdown hooks returned exception&quot;, postShutdownHookThrowable);</span>
        }
<span class="fc" id="L5853">    }</span>

    @VisibleForTesting
    public void disableAutoCompaction()
    {
<span class="fc bfc" id="L5858" title="All 2 branches covered.">        for (Keyspace keyspace : Keyspace.all())</span>
<span class="fc bfc" id="L5859" title="All 2 branches covered.">            for (ColumnFamilyStore cfs : keyspace.getColumnFamilyStores())</span>
<span class="fc" id="L5860">                cfs.disableAutoCompaction();</span>
<span class="fc" id="L5861">    }</span>

    /**
     * Add a runnable which will be called before shut down or drain. This is useful for other
     * applications running in the same JVM which may want to shut down first rather than time
     * out attempting to use Cassandra calls which will no longer work.
     * @param hook: the code to run
     * @return true on success, false if Cassandra is already shutting down, in which case the runnable
     * has NOT been added.
     */
    public synchronized boolean addPreShutdownHook(Runnable hook)
    {
<span class="nc bnc" id="L5873" title="All 4 branches missed.">        if (!isDraining() &amp;&amp; !isDrained())</span>
<span class="nc" id="L5874">            return preShutdownHooks.add(hook);</span>

<span class="nc" id="L5876">        return false;</span>
    }

    /**
     * Remove a preshutdown hook
     */
    public synchronized boolean removePreShutdownHook(Runnable hook)
    {
<span class="nc" id="L5884">        return preShutdownHooks.remove(hook);</span>
    }

    /**
     * Add a runnable which will be called after shutdown or drain. This is useful for other applications
     * running in the same JVM that Cassandra needs to work and should shut down later.
     * @param hook: the code to run
     * @return true on success, false if Cassandra is already shutting down, in which case the runnable has NOT been
     * added.
     */
    public synchronized boolean addPostShutdownHook(Runnable hook)
    {
<span class="nc bnc" id="L5896" title="All 4 branches missed.">        if (!isDraining() &amp;&amp; !isDrained())</span>
<span class="nc" id="L5897">            return postShutdownHooks.add(hook);</span>

<span class="nc" id="L5899">        return false;</span>
    }

    /**
     * Remove a postshutdownhook
     */
    public synchronized boolean removePostShutdownHook(Runnable hook)
    {
<span class="nc" id="L5907">        return postShutdownHooks.remove(hook);</span>
    }

    /**
     * Some services are shutdown during draining and we should not attempt to start them again.
     *
     * @param service - the name of the service we are trying to start.
     * @throws IllegalStateException - an exception that nodetool is able to convert into a message to display to the user
     */
    synchronized void checkServiceAllowedToStart(String service)
    {
<span class="pc bpc" id="L5918" title="1 of 2 branches missed.">        if (isDraining()) // when draining isShutdown is also true, so we check first to return a more accurate message</span>
<span class="nc" id="L5919">            throw new IllegalStateException(String.format(&quot;Unable to start %s because the node is draining.&quot;, service));</span>

<span class="pc bpc" id="L5921" title="1 of 2 branches missed.">        if (isShutdown()) // do not rely on operationMode in case it gets changed to decomissioned or other</span>
<span class="nc" id="L5922">            throw new IllegalStateException(String.format(&quot;Unable to start %s because the node was drained.&quot;, service));</span>

<span class="pc bpc" id="L5924" title="3 of 4 branches missed.">        if (!isNormal() &amp;&amp; joinRing) // if the node is not joining the ring, it is gossipping-only member which is in STARTING state forever</span>
<span class="nc" id="L5925">            throw new IllegalStateException(String.format(&quot;Unable to start %s because the node is not in the normal state.&quot;, service));</span>
<span class="fc" id="L5926">    }</span>

    // Never ever do this at home. Used by tests.
    @VisibleForTesting
    public IPartitioner setPartitionerUnsafe(IPartitioner newPartitioner)
    {
<span class="fc" id="L5932">        IPartitioner oldPartitioner = DatabaseDescriptor.setPartitionerUnsafe(newPartitioner);</span>
<span class="fc" id="L5933">        tokenMetadata = tokenMetadata.cloneWithNewPartitioner(newPartitioner);</span>
<span class="fc" id="L5934">        valueFactory = new VersionedValue.VersionedValueFactory(newPartitioner);</span>
<span class="fc" id="L5935">        return oldPartitioner;</span>
    }

    TokenMetadata setTokenMetadataUnsafe(TokenMetadata tmd)
    {
<span class="fc" id="L5940">        TokenMetadata old = tokenMetadata;</span>
<span class="fc" id="L5941">        tokenMetadata = tmd;</span>
<span class="fc" id="L5942">        return old;</span>
    }

    public void truncate(String keyspace, String table) throws TimeoutException, IOException
    {
<span class="fc" id="L5947">        verifyKeyspaceIsValid(keyspace);</span>

        try
        {
<span class="fc" id="L5951">            StorageProxy.truncateBlocking(keyspace, table);</span>
        }
<span class="nc" id="L5953">        catch (UnavailableException e)</span>
        {
<span class="nc" id="L5955">            throw new IOException(e.getMessage());</span>
<span class="fc" id="L5956">        }</span>
<span class="fc" id="L5957">    }</span>

    public Map&lt;InetAddress, Float&gt; getOwnership()
    {
<span class="nc" id="L5961">        List&lt;Token&gt; sortedTokens = tokenMetadata.sortedTokens();</span>
        // describeOwnership returns tokens in an unspecified order, let's re-order them
<span class="nc" id="L5963">        Map&lt;Token, Float&gt; tokenMap = new TreeMap&lt;Token, Float&gt;(tokenMetadata.partitioner.describeOwnership(sortedTokens));</span>
<span class="nc" id="L5964">        Map&lt;InetAddress, Float&gt; nodeMap = new LinkedHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L5965" title="All 2 branches missed.">        for (Map.Entry&lt;Token, Float&gt; entry : tokenMap.entrySet())</span>
        {
<span class="nc" id="L5967">            InetAddressAndPort endpoint = tokenMetadata.getEndpoint(entry.getKey());</span>
<span class="nc" id="L5968">            Float tokenOwnership = entry.getValue();</span>
<span class="nc bnc" id="L5969" title="All 2 branches missed.">            if (nodeMap.containsKey(endpoint.getAddress()))</span>
<span class="nc" id="L5970">                nodeMap.put(endpoint.getAddress(), nodeMap.get(endpoint.getAddress()) + tokenOwnership);</span>
            else
<span class="nc" id="L5972">                nodeMap.put(endpoint.getAddress(), tokenOwnership);</span>
<span class="nc" id="L5973">        }</span>
<span class="nc" id="L5974">        return nodeMap;</span>
    }

    public Map&lt;String, Float&gt; getOwnershipWithPort()
    {
<span class="fc" id="L5979">        List&lt;Token&gt; sortedTokens = tokenMetadata.sortedTokens();</span>
        // describeOwnership returns tokens in an unspecified order, let's re-order them
<span class="fc" id="L5981">        Map&lt;Token, Float&gt; tokenMap = new TreeMap&lt;Token, Float&gt;(tokenMetadata.partitioner.describeOwnership(sortedTokens));</span>
<span class="fc" id="L5982">        Map&lt;String, Float&gt; nodeMap = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L5983" title="All 2 branches covered.">        for (Map.Entry&lt;Token, Float&gt; entry : tokenMap.entrySet())</span>
        {
<span class="fc" id="L5985">            InetAddressAndPort endpoint = tokenMetadata.getEndpoint(entry.getKey());</span>
<span class="fc" id="L5986">            Float tokenOwnership = entry.getValue();</span>
<span class="pc bpc" id="L5987" title="1 of 2 branches missed.">            if (nodeMap.containsKey(endpoint.toString()))</span>
<span class="nc" id="L5988">                nodeMap.put(endpoint.toString(), nodeMap.get(endpoint.toString()) + tokenOwnership);</span>
            else
<span class="fc" id="L5990">                nodeMap.put(endpoint.toString(), tokenOwnership);</span>
<span class="fc" id="L5991">        }</span>
<span class="fc" id="L5992">        return nodeMap;</span>
    }

    /**
     * Calculates ownership. If there are multiple DC's and the replication strategy is DC aware then ownership will be
     * calculated per dc, i.e. each DC will have total ring ownership divided amongst its nodes. Without replication
     * total ownership will be a multiple of the number of DC's and this value will then go up within each DC depending
     * on the number of replicas within itself. For DC unaware replication strategies, ownership without replication
     * will be 100%.
     *
     * @throws IllegalStateException when node is not configured properly.
     */
    private LinkedHashMap&lt;InetAddressAndPort, Float&gt; getEffectiveOwnership(String keyspace)
    {
        AbstractReplicationStrategy strategy;
<span class="fc bfc" id="L6007" title="All 2 branches covered.">        if (keyspace != null)</span>
        {
<span class="fc" id="L6009">            Keyspace keyspaceInstance = Schema.instance.getKeyspaceInstance(keyspace);</span>
<span class="fc bfc" id="L6010" title="All 2 branches covered.">            if (keyspaceInstance == null)</span>
<span class="fc" id="L6011">                throw new IllegalArgumentException(&quot;The keyspace &quot; + keyspace + &quot;, does not exist&quot;);</span>

<span class="fc bfc" id="L6013" title="All 2 branches covered.">            if (keyspaceInstance.getReplicationStrategy() instanceof LocalStrategy)</span>
<span class="fc" id="L6014">                throw new IllegalStateException(&quot;Ownership values for keyspaces with LocalStrategy are meaningless&quot;);</span>
<span class="fc" id="L6015">            strategy = keyspaceInstance.getReplicationStrategy();</span>
<span class="fc" id="L6016">        }</span>
        else
        {
<span class="fc" id="L6019">            Collection&lt;String&gt; userKeyspaces = Schema.instance.getUserKeyspaces().names();</span>

<span class="fc bfc" id="L6021" title="All 2 branches covered.">            if (userKeyspaces.size() &gt; 0)</span>
            {
<span class="fc" id="L6023">                keyspace = userKeyspaces.iterator().next();</span>
<span class="fc" id="L6024">                AbstractReplicationStrategy replicationStrategy = Schema.instance.getKeyspaceInstance(keyspace).getReplicationStrategy();</span>
<span class="fc bfc" id="L6025" title="All 2 branches covered.">                for (String keyspaceName : userKeyspaces)</span>
                {
<span class="pc bpc" id="L6027" title="1 of 2 branches missed.">                    if (!Schema.instance.getKeyspaceInstance(keyspaceName).getReplicationStrategy().hasSameSettings(replicationStrategy))</span>
<span class="nc" id="L6028">                        throw new IllegalStateException(&quot;Non-system keyspaces don't have the same replication settings, effective ownership information is meaningless&quot;);</span>
<span class="fc" id="L6029">                }</span>
<span class="fc" id="L6030">            }</span>
            else
            {
<span class="fc" id="L6033">                keyspace = &quot;system_traces&quot;;</span>
            }

<span class="fc" id="L6036">            Keyspace keyspaceInstance = Schema.instance.getKeyspaceInstance(keyspace);</span>
<span class="fc bfc" id="L6037" title="All 2 branches covered.">            if (keyspaceInstance == null)</span>
<span class="fc" id="L6038">                throw new IllegalStateException(&quot;The node does not have &quot; + keyspace + &quot; yet, probably still bootstrapping. Effective ownership information is meaningless.&quot;);</span>
<span class="fc" id="L6039">            strategy = keyspaceInstance.getReplicationStrategy();</span>
        }

<span class="fc" id="L6042">        TokenMetadata metadata = tokenMetadata.cloneOnlyTokenMap();</span>

<span class="fc" id="L6044">        Collection&lt;Collection&lt;InetAddressAndPort&gt;&gt; endpointsGroupedByDc = new ArrayList&lt;&gt;();</span>
        // mapping of dc's to nodes, use sorted map so that we get dcs sorted
<span class="fc" id="L6046">        SortedMap&lt;String, Collection&lt;InetAddressAndPort&gt;&gt; sortedDcsToEndpoints = new TreeMap&lt;&gt;(metadata.getTopology().getDatacenterEndpoints().asMap());</span>
<span class="fc bfc" id="L6047" title="All 2 branches covered.">        for (Collection&lt;InetAddressAndPort&gt; endpoints : sortedDcsToEndpoints.values())</span>
<span class="fc" id="L6048">            endpointsGroupedByDc.add(endpoints);</span>

<span class="fc" id="L6050">        Map&lt;Token, Float&gt; tokenOwnership = tokenMetadata.partitioner.describeOwnership(tokenMetadata.sortedTokens());</span>
<span class="fc" id="L6051">        LinkedHashMap&lt;InetAddressAndPort, Float&gt; finalOwnership = Maps.newLinkedHashMap();</span>

<span class="fc" id="L6053">        RangesByEndpoint endpointToRanges = strategy.getAddressReplicas();</span>
        // calculate ownership per dc
<span class="fc bfc" id="L6055" title="All 2 branches covered.">        for (Collection&lt;InetAddressAndPort&gt; endpoints : endpointsGroupedByDc)</span>
        {
            // calculate the ownership with replication and add the endpoint to the final ownership map
<span class="fc bfc" id="L6058" title="All 2 branches covered.">            for (InetAddressAndPort endpoint : endpoints)</span>
            {
<span class="fc" id="L6060">                float ownership = 0.0f;</span>
<span class="fc bfc" id="L6061" title="All 2 branches covered.">                for (Replica replica : endpointToRanges.get(endpoint))</span>
                {
<span class="pc bpc" id="L6063" title="1 of 2 branches missed.">                    if (tokenOwnership.containsKey(replica.range().right))</span>
<span class="fc" id="L6064">                        ownership += tokenOwnership.get(replica.range().right);</span>
<span class="fc" id="L6065">                }</span>
<span class="fc" id="L6066">                finalOwnership.put(endpoint, ownership);</span>
<span class="fc" id="L6067">            }</span>
<span class="fc" id="L6068">        }</span>
<span class="fc" id="L6069">        return finalOwnership;</span>
    }

    public LinkedHashMap&lt;InetAddress, Float&gt; effectiveOwnership(String keyspace) throws IllegalStateException
    {
<span class="fc" id="L6074">        LinkedHashMap&lt;InetAddressAndPort, Float&gt; result = getEffectiveOwnership(keyspace);</span>
<span class="fc" id="L6075">        LinkedHashMap&lt;InetAddress, Float&gt; asInets = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L6076">        result.entrySet().stream().forEachOrdered(entry -&gt; asInets.put(entry.getKey().getAddress(), entry.getValue()));</span>
<span class="fc" id="L6077">        return asInets;</span>
    }

    public LinkedHashMap&lt;String, Float&gt; effectiveOwnershipWithPort(String keyspace) throws IllegalStateException
    {
<span class="fc" id="L6082">        LinkedHashMap&lt;InetAddressAndPort, Float&gt; result = getEffectiveOwnership(keyspace);</span>
<span class="fc" id="L6083">        LinkedHashMap&lt;String, Float&gt; asStrings = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L6084">        result.entrySet().stream().forEachOrdered(entry -&gt; asStrings.put(entry.getKey().getHostAddressAndPort(), entry.getValue()));</span>
<span class="fc" id="L6085">        return asStrings;</span>
    }

    public List&lt;String&gt; getKeyspaces()
    {
<span class="fc" id="L6090">        return Lists.newArrayList(Schema.instance.distributedAndLocalKeyspaces().names());</span>
    }

    public List&lt;String&gt; getNonSystemKeyspaces()
    {
<span class="nc" id="L6095">        return Lists.newArrayList(Schema.instance.distributedKeyspaces().names());</span>
    }

    public List&lt;String&gt; getNonLocalStrategyKeyspaces()
    {
<span class="nc" id="L6100">        return Lists.newArrayList(Schema.instance.getNonLocalStrategyKeyspaces().names());</span>
    }

    public Map&lt;String, String&gt; getViewBuildStatuses(String keyspace, String view, boolean withPort)
    {
<span class="nc" id="L6105">        Map&lt;UUID, String&gt; coreViewStatus = SystemDistributedKeyspace.viewStatus(keyspace, view);</span>
<span class="nc" id="L6106">        Map&lt;InetAddressAndPort, UUID&gt; hostIdToEndpoint = tokenMetadata.getEndpointToHostIdMapForReading();</span>
<span class="nc" id="L6107">        Map&lt;String, String&gt; result = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L6109" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddressAndPort, UUID&gt; entry : hostIdToEndpoint.entrySet())</span>
        {
<span class="nc" id="L6111">            UUID hostId = entry.getValue();</span>
<span class="nc" id="L6112">            InetAddressAndPort endpoint = entry.getKey();</span>
<span class="nc" id="L6113">            result.put(endpoint.toString(withPort),</span>
<span class="nc" id="L6114">                       coreViewStatus.getOrDefault(hostId, &quot;UNKNOWN&quot;));</span>
<span class="nc" id="L6115">        }</span>

<span class="nc" id="L6117">        return Collections.unmodifiableMap(result);</span>
    }

    public Map&lt;String, String&gt; getViewBuildStatuses(String keyspace, String view)
    {
<span class="nc" id="L6122">        return getViewBuildStatuses(keyspace, view, false);</span>
    }

    public Map&lt;String, String&gt; getViewBuildStatusesWithPort(String keyspace, String view)
    {
<span class="nc" id="L6127">        return getViewBuildStatuses(keyspace, view, true);</span>
    }

    public void setDynamicUpdateInterval(int dynamicUpdateInterval)
    {
<span class="nc bnc" id="L6132" title="All 2 branches missed.">        if (DatabaseDescriptor.getEndpointSnitch() instanceof DynamicEndpointSnitch)</span>
        {

            try
            {
<span class="nc" id="L6137">                updateSnitch(null, true, dynamicUpdateInterval, null, null);</span>
            }
<span class="nc" id="L6139">            catch (ClassNotFoundException e)</span>
            {
<span class="nc" id="L6141">                throw new RuntimeException(e);</span>
<span class="nc" id="L6142">            }</span>
        }
<span class="nc" id="L6144">    }</span>

    public int getDynamicUpdateInterval()
    {
<span class="nc" id="L6148">        return DatabaseDescriptor.getDynamicUpdateInterval();</span>
    }

    public void updateSnitch(String epSnitchClassName, Boolean dynamic, Integer dynamicUpdateInterval, Integer dynamicResetInterval, Double dynamicBadnessThreshold) throws ClassNotFoundException
    {
        // apply dynamic snitch configuration
<span class="nc bnc" id="L6154" title="All 2 branches missed.">        if (dynamicUpdateInterval != null)</span>
<span class="nc" id="L6155">            DatabaseDescriptor.setDynamicUpdateInterval(dynamicUpdateInterval);</span>
<span class="nc bnc" id="L6156" title="All 2 branches missed.">        if (dynamicResetInterval != null)</span>
<span class="nc" id="L6157">            DatabaseDescriptor.setDynamicResetInterval(dynamicResetInterval);</span>
<span class="nc bnc" id="L6158" title="All 2 branches missed.">        if (dynamicBadnessThreshold != null)</span>
<span class="nc" id="L6159">            DatabaseDescriptor.setDynamicBadnessThreshold(dynamicBadnessThreshold);</span>

<span class="nc" id="L6161">        IEndpointSnitch oldSnitch = DatabaseDescriptor.getEndpointSnitch();</span>

        // new snitch registers mbean during construction
<span class="nc bnc" id="L6164" title="All 2 branches missed.">        if(epSnitchClassName != null)</span>
        {

            // need to unregister the mbean _before_ the new dynamic snitch is instantiated (and implicitly initialized
            // and its mbean registered)
<span class="nc bnc" id="L6169" title="All 2 branches missed.">            if (oldSnitch instanceof DynamicEndpointSnitch)</span>
<span class="nc" id="L6170">                ((DynamicEndpointSnitch)oldSnitch).close();</span>

            IEndpointSnitch newSnitch;
            try
            {
<span class="nc bnc" id="L6175" title="All 4 branches missed.">                newSnitch = DatabaseDescriptor.createEndpointSnitch(dynamic != null &amp;&amp; dynamic, epSnitchClassName);</span>
            }
<span class="nc" id="L6177">            catch (ConfigurationException e)</span>
            {
<span class="nc" id="L6179">                throw new ClassNotFoundException(e.getMessage());</span>
<span class="nc" id="L6180">            }</span>

<span class="nc bnc" id="L6182" title="All 2 branches missed.">            if (newSnitch instanceof DynamicEndpointSnitch)</span>
            {
<span class="nc" id="L6184">                logger.info(&quot;Created new dynamic snitch {} with update-interval={}, reset-interval={}, badness-threshold={}&quot;,</span>
<span class="nc" id="L6185">                            ((DynamicEndpointSnitch)newSnitch).subsnitch.getClass().getName(), DatabaseDescriptor.getDynamicUpdateInterval(),</span>
<span class="nc" id="L6186">                            DatabaseDescriptor.getDynamicResetInterval(), DatabaseDescriptor.getDynamicBadnessThreshold());</span>
            }
            else
            {
<span class="nc" id="L6190">                logger.info(&quot;Created new non-dynamic snitch {}&quot;, newSnitch.getClass().getName());</span>
            }

            // point snitch references to the new instance
<span class="nc" id="L6194">            DatabaseDescriptor.setEndpointSnitch(newSnitch);</span>
<span class="nc bnc" id="L6195" title="All 2 branches missed.">            for (String ks : Schema.instance.getKeyspaces())</span>
            {
<span class="nc" id="L6197">                Keyspace.open(ks).getReplicationStrategy().snitch = newSnitch;</span>
<span class="nc" id="L6198">            }</span>
<span class="nc" id="L6199">        }</span>
        else
        {
<span class="nc bnc" id="L6202" title="All 2 branches missed.">            if (oldSnitch instanceof DynamicEndpointSnitch)</span>
            {
<span class="nc" id="L6204">                logger.info(&quot;Applying config change to dynamic snitch {} with update-interval={}, reset-interval={}, badness-threshold={}&quot;,</span>
<span class="nc" id="L6205">                            ((DynamicEndpointSnitch)oldSnitch).subsnitch.getClass().getName(), DatabaseDescriptor.getDynamicUpdateInterval(),</span>
<span class="nc" id="L6206">                            DatabaseDescriptor.getDynamicResetInterval(), DatabaseDescriptor.getDynamicBadnessThreshold());</span>

<span class="nc" id="L6208">                DynamicEndpointSnitch snitch = (DynamicEndpointSnitch)oldSnitch;</span>
<span class="nc" id="L6209">                snitch.applyConfigChanges();</span>
            }
        }

<span class="nc" id="L6213">        updateTopology();</span>
<span class="nc" id="L6214">    }</span>

    /**
     * Send data to the endpoints that will be responsible for it in the future
     *
     * @param rangesToStreamByKeyspace keyspaces and data ranges with endpoints included for each
     * @return async Future for whether stream was success
     */
    private Future&lt;StreamState&gt; streamRanges(Map&lt;String, EndpointsByReplica&gt; rangesToStreamByKeyspace)
    {
        // First, we build a list of ranges to stream to each host, per table
<span class="nc" id="L6225">        Map&lt;String, RangesByEndpoint&gt; sessionsToStreamByKeyspace = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L6227" title="All 2 branches missed.">        for (Map.Entry&lt;String, EndpointsByReplica&gt; entry : rangesToStreamByKeyspace.entrySet())</span>
        {
<span class="nc" id="L6229">            String keyspace = entry.getKey();</span>
<span class="nc" id="L6230">            EndpointsByReplica rangesWithEndpoints = entry.getValue();</span>

<span class="nc bnc" id="L6232" title="All 2 branches missed.">            if (rangesWithEndpoints.isEmpty())</span>
<span class="nc" id="L6233">                continue;</span>

            //Description is always Unbootstrap? Is that right?
<span class="nc" id="L6236">            Map&lt;InetAddressAndPort, Set&lt;Range&lt;Token&gt;&gt;&gt; transferredRangePerKeyspace = SystemKeyspace.getTransferredRanges(&quot;Unbootstrap&quot;,</span>
                                                                                                                         keyspace,
<span class="nc" id="L6238">                                                                                                                         StorageService.instance.getTokenMetadata().partitioner);</span>
<span class="nc" id="L6239">            RangesByEndpoint.Builder replicasPerEndpoint = new RangesByEndpoint.Builder();</span>
<span class="nc bnc" id="L6240" title="All 2 branches missed.">            for (Map.Entry&lt;Replica, Replica&gt; endPointEntry : rangesWithEndpoints.flattenEntries())</span>
            {
<span class="nc" id="L6242">                Replica local = endPointEntry.getKey();</span>
<span class="nc" id="L6243">                Replica remote = endPointEntry.getValue();</span>
<span class="nc" id="L6244">                Set&lt;Range&lt;Token&gt;&gt; transferredRanges = transferredRangePerKeyspace.get(remote.endpoint());</span>
<span class="nc bnc" id="L6245" title="All 4 branches missed.">                if (transferredRanges != null &amp;&amp; transferredRanges.contains(local.range()))</span>
                {
<span class="nc" id="L6247">                    logger.debug(&quot;Skipping transferred range {} of keyspace {}, endpoint {}&quot;, local, keyspace, remote);</span>
<span class="nc" id="L6248">                    continue;</span>
                }

<span class="nc" id="L6251">                replicasPerEndpoint.put(remote.endpoint(), remote.decorateSubrange(local.range()));</span>
<span class="nc" id="L6252">            }</span>

<span class="nc" id="L6254">            sessionsToStreamByKeyspace.put(keyspace, replicasPerEndpoint.build());</span>
<span class="nc" id="L6255">        }</span>

<span class="nc" id="L6257">        StreamPlan streamPlan = new StreamPlan(StreamOperation.DECOMMISSION);</span>

        // Vinculate StreamStateStore to current StreamPlan to update transferred rangeas per StreamSession
<span class="nc" id="L6260">        streamPlan.listeners(streamStateStore);</span>

<span class="nc bnc" id="L6262" title="All 2 branches missed.">        for (Map.Entry&lt;String, RangesByEndpoint&gt; entry : sessionsToStreamByKeyspace.entrySet())</span>
        {
<span class="nc" id="L6264">            String keyspaceName = entry.getKey();</span>
<span class="nc" id="L6265">            RangesByEndpoint replicasPerEndpoint = entry.getValue();</span>

<span class="nc bnc" id="L6267" title="All 2 branches missed.">            for (Map.Entry&lt;InetAddressAndPort, RangesAtEndpoint&gt; rangesEntry : replicasPerEndpoint.asMap().entrySet())</span>
            {
<span class="nc" id="L6269">                RangesAtEndpoint replicas = rangesEntry.getValue();</span>
<span class="nc" id="L6270">                InetAddressAndPort newEndpoint = rangesEntry.getKey();</span>

                // TODO each call to transferRanges re-flushes, this is potentially a lot of waste
<span class="nc" id="L6273">                streamPlan.transferRanges(newEndpoint, keyspaceName, replicas);</span>
<span class="nc" id="L6274">            }</span>
<span class="nc" id="L6275">        }</span>
<span class="nc" id="L6276">        return streamPlan.execute();</span>
    }

    public void bulkLoad(String directory)
    {
        try
        {
<span class="nc" id="L6283">            bulkLoadInternal(directory).get();</span>
        }
<span class="nc" id="L6285">        catch (Exception e)</span>
        {
<span class="nc" id="L6287">            throw new RuntimeException(e);</span>
<span class="nc" id="L6288">        }</span>
<span class="nc" id="L6289">    }</span>

    public String bulkLoadAsync(String directory)
    {
<span class="nc" id="L6293">        return bulkLoadInternal(directory).planId.toString();</span>
    }

    private StreamResultFuture bulkLoadInternal(String directory)
    {
<span class="nc" id="L6298">        File dir = new File(directory);</span>

<span class="nc bnc" id="L6300" title="All 4 branches missed.">        if (!dir.exists() || !dir.isDirectory())</span>
<span class="nc" id="L6301">            throw new IllegalArgumentException(&quot;Invalid directory &quot; + directory);</span>

<span class="nc" id="L6303">        SSTableLoader.Client client = new SSTableLoader.Client()</span>
<span class="nc" id="L6304">        {</span>
            private String keyspace;

            public void init(String keyspace)
            {
<span class="nc" id="L6309">                this.keyspace = keyspace;</span>
                try
                {
<span class="nc bnc" id="L6312" title="All 2 branches missed.">                    for (Map.Entry&lt;Range&lt;Token&gt;, EndpointsForRange&gt; entry : StorageService.instance.getRangeToAddressMap(keyspace).entrySet())</span>
                    {
<span class="nc" id="L6314">                        Range&lt;Token&gt; range = entry.getKey();</span>
<span class="nc" id="L6315">                        EndpointsForRange replicas = entry.getValue();</span>
<span class="nc" id="L6316">                        Replicas.temporaryAssertFull(replicas);</span>
<span class="nc bnc" id="L6317" title="All 2 branches missed.">                        for (InetAddressAndPort endpoint : replicas.endpoints())</span>
<span class="nc" id="L6318">                            addRangeForEndpoint(range, endpoint);</span>
<span class="nc" id="L6319">                    }</span>
                }
<span class="nc" id="L6321">                catch (Exception e)</span>
                {
<span class="nc" id="L6323">                    throw new RuntimeException(e);</span>
<span class="nc" id="L6324">                }</span>
<span class="nc" id="L6325">            }</span>

            public TableMetadataRef getTableMetadata(String tableName)
            {
<span class="nc" id="L6329">                return Schema.instance.getTableMetadataRef(keyspace, tableName);</span>
            }
        };

<span class="nc" id="L6333">        return new SSTableLoader(dir, client, new OutputHandler.LogOutput()).stream();</span>
    }

    public void rescheduleFailedDeletions()
    {
<span class="nc" id="L6338">        LifecycleTransaction.rescheduleFailedDeletions();</span>
<span class="nc" id="L6339">    }</span>

    /**
     * #{@inheritDoc}
     */
    @Deprecated
    public void loadNewSSTables(String ksName, String cfName)
    {
<span class="nc bnc" id="L6347" title="All 2 branches missed.">        if (!isInitialized())</span>
<span class="nc" id="L6348">            throw new RuntimeException(&quot;Not yet initialized, can't load new sstables&quot;);</span>
<span class="nc" id="L6349">        verifyKeyspaceIsValid(ksName);</span>
<span class="nc" id="L6350">        ColumnFamilyStore.loadNewSSTables(ksName, cfName);</span>
<span class="nc" id="L6351">    }</span>

    /**
     * #{@inheritDoc}
     */
    public List&lt;String&gt; sampleKeyRange() // do not rename to getter - see CASSANDRA-4452 for details
    {
<span class="nc" id="L6358">        List&lt;DecoratedKey&gt; keys = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L6359" title="All 2 branches missed.">        for (Keyspace keyspace : Keyspace.nonLocalStrategy())</span>
        {
<span class="nc bnc" id="L6361" title="All 2 branches missed.">            for (Range&lt;Token&gt; range : getPrimaryRangesForEndpoint(keyspace.getName(), FBUtilities.getBroadcastAddressAndPort()))</span>
<span class="nc" id="L6362">                keys.addAll(keySamples(keyspace.getColumnFamilyStores(), range));</span>
<span class="nc" id="L6363">        }</span>

<span class="nc" id="L6365">        List&lt;String&gt; sampledKeys = new ArrayList&lt;&gt;(keys.size());</span>
<span class="nc bnc" id="L6366" title="All 2 branches missed.">        for (DecoratedKey key : keys)</span>
<span class="nc" id="L6367">            sampledKeys.add(key.getToken().toString());</span>
<span class="nc" id="L6368">        return sampledKeys;</span>
    }

    @Override
    public Map&lt;String, List&lt;CompositeData&gt;&gt; samplePartitions(int duration, int capacity, int count, List&lt;String&gt; samplers) throws OpenDataException {
<span class="nc" id="L6373">        return samplePartitions(null, duration, capacity, count, samplers);</span>
    }

    /*
     * { &quot;sampler_name&quot;: [ {table: &quot;&quot;, count: i, error: i, value: &quot;&quot;}, ... ] }
     */
    @Override
    public Map&lt;String, List&lt;CompositeData&gt;&gt; samplePartitions(String keyspace, int durationMillis, int capacity, int count,
                                                             List&lt;String&gt; samplers) throws OpenDataException
    {
<span class="fc" id="L6383">        ConcurrentHashMap&lt;String, List&lt;CompositeData&gt;&gt; result = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L6384">        Iterable&lt;ColumnFamilyStore&gt; tables = SamplingManager.getTables(keyspace, null);</span>
<span class="fc bfc" id="L6385" title="All 2 branches covered.">        for (String sampler : samplers)</span>
        {
<span class="fc bfc" id="L6387" title="All 2 branches covered.">            for (ColumnFamilyStore table : tables)</span>
            {
<span class="fc" id="L6389">                table.beginLocalSampling(sampler, capacity, durationMillis);</span>
<span class="fc" id="L6390">            }</span>
<span class="fc" id="L6391">        }</span>
<span class="fc" id="L6392">        Uninterruptibles.sleepUninterruptibly(durationMillis, MILLISECONDS);</span>

<span class="fc bfc" id="L6394" title="All 2 branches covered.">        for (String sampler : samplers)</span>
        {
<span class="fc" id="L6396">            List&lt;CompositeData&gt; topk = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L6397" title="All 2 branches covered.">            for (ColumnFamilyStore table : tables)</span>
            {
<span class="fc" id="L6399">                topk.addAll(table.finishLocalSampling(sampler, count));</span>
<span class="fc" id="L6400">            }</span>
<span class="fc" id="L6401">            Collections.sort(topk, new Ordering&lt;CompositeData&gt;()</span>
<span class="fc" id="L6402">            {</span>
                public int compare(CompositeData left, CompositeData right)
                {
<span class="nc" id="L6405">                    return Long.compare((long) right.get(&quot;count&quot;), (long) left.get(&quot;count&quot;));</span>
                }
            });
            // sublist is not serializable for jmx
<span class="fc" id="L6409">            topk = new ArrayList&lt;&gt;(topk.subList(0, Math.min(topk.size(), count)));</span>
<span class="fc" id="L6410">            result.put(sampler, topk);</span>
<span class="fc" id="L6411">        }</span>
<span class="fc" id="L6412">        return result;</span>
    }

    @Override // Note from parent javadoc: ks and table are nullable
    public boolean startSamplingPartitions(String ks, String table, int duration, int interval, int capacity, int count, List&lt;String&gt; samplers)
    {
<span class="pc bpc" id="L6418" title="1 of 2 branches missed.">        Preconditions.checkArgument(duration &gt; 0, &quot;Sampling duration %s must be positive.&quot;, duration);</span>

<span class="pc bpc" id="L6420" title="2 of 4 branches missed.">        Preconditions.checkArgument(interval &lt;= 0 || interval &gt;= duration,</span>
                                    &quot;Sampling interval %s should be greater then or equals to duration %s if defined.&quot;,
                                    interval, duration);

<span class="pc bpc" id="L6424" title="2 of 4 branches missed.">        Preconditions.checkArgument(capacity &gt; 0 &amp;&amp; capacity &lt;= 1024,</span>
                                    &quot;Sampling capacity %s must be positive and the max value is 1024 (inclusive).&quot;,
                                    capacity);

<span class="pc bpc" id="L6428" title="2 of 4 branches missed.">        Preconditions.checkArgument(count &gt; 0 &amp;&amp; count &lt; capacity,</span>
                                    &quot;Sampling count %s must be positive and smaller than capacity %s.&quot;,
                                    count, capacity);

<span class="pc bpc" id="L6432" title="1 of 2 branches missed.">        Preconditions.checkArgument(!samplers.isEmpty(), &quot;Samplers cannot be empty.&quot;);</span>

<span class="fc" id="L6434">        Set&lt;Sampler.SamplerType&gt; available = EnumSet.allOf(Sampler.SamplerType.class);</span>
<span class="fc" id="L6435">        samplers.forEach((x) -&gt; checkArgument(available.contains(Sampler.SamplerType.valueOf(x)),</span>
                                              &quot;'%s' sampler is not available from: %s&quot;,
<span class="fc" id="L6437">                                              x, Arrays.toString(Sampler.SamplerType.values())));</span>
<span class="fc" id="L6438">        return samplingManager.register(ks, table, duration, interval, capacity, count, samplers);</span>
    }

    @Override
    public boolean stopSamplingPartitions(String ks, String table)
    {
<span class="fc" id="L6444">        return samplingManager.unregister(ks, table);</span>
    }

    @Override
    public List&lt;String&gt; getSampleTasks()
    {
<span class="fc" id="L6450">        return samplingManager.allJobs();</span>
    }

    public void rebuildSecondaryIndex(String ksName, String cfName, String... idxNames)
    {
<span class="nc" id="L6455">        String[] indices = asList(idxNames).stream()</span>
<span class="nc bnc" id="L6456" title="All 2 branches missed.">                                           .map(p -&gt; isIndexColumnFamily(p) ? getIndexName(p) : p)</span>
<span class="nc" id="L6457">                                           .collect(toList())</span>
<span class="nc" id="L6458">                                           .toArray(new String[idxNames.length]);</span>

<span class="nc" id="L6460">        ColumnFamilyStore.rebuildSecondaryIndex(ksName, cfName, indices);</span>
<span class="nc" id="L6461">    }</span>

    public void resetLocalSchema() throws IOException
    {
<span class="nc" id="L6465">        Schema.instance.resetLocalSchema();</span>
<span class="nc" id="L6466">    }</span>

    public void reloadLocalSchema()
    {
<span class="nc" id="L6470">        Schema.instance.reloadSchemaAndAnnounceVersion();</span>
<span class="nc" id="L6471">    }</span>

    public void setTraceProbability(double probability)
    {
<span class="nc" id="L6475">        this.traceProbability = probability;</span>
<span class="nc" id="L6476">    }</span>

    public double getTraceProbability()
    {
<span class="nc" id="L6480">        return traceProbability;</span>
    }

    public boolean shouldTraceProbablistically()
    {
<span class="pc bpc" id="L6485" title="3 of 4 branches missed.">        return traceProbability != 0 &amp;&amp; ThreadLocalRandom.current().nextDouble() &lt; traceProbability;</span>
    }

    public void disableAutoCompaction(String ks, String... tables) throws IOException
    {
<span class="fc bfc" id="L6490" title="All 2 branches covered.">        for (ColumnFamilyStore cfs : getValidColumnFamilies(true, true, ks, tables))</span>
        {
<span class="fc" id="L6492">            cfs.disableAutoCompaction();</span>
<span class="fc" id="L6493">        }</span>
<span class="fc" id="L6494">    }</span>

    public synchronized void enableAutoCompaction(String ks, String... tables) throws IOException
    {
<span class="nc" id="L6498">        checkServiceAllowedToStart(&quot;auto compaction&quot;);</span>

<span class="nc bnc" id="L6500" title="All 2 branches missed.">        for (ColumnFamilyStore cfs : getValidColumnFamilies(true, true, ks, tables))</span>
        {
<span class="nc" id="L6502">            cfs.enableAutoCompaction();</span>
<span class="nc" id="L6503">        }</span>
<span class="nc" id="L6504">    }</span>

    public Map&lt;String, Boolean&gt; getAutoCompactionStatus(String ks, String... tables) throws IOException
    {
<span class="fc" id="L6508">        Map&lt;String, Boolean&gt; status = new HashMap&lt;String, Boolean&gt;();</span>
<span class="nc bnc" id="L6509" title="All 2 branches missed.">        for (ColumnFamilyStore cfs : getValidColumnFamilies(true, true, ks, tables))</span>
<span class="nc" id="L6510">            status.put(cfs.getTableName(), cfs.isAutoCompactionDisabled());</span>
<span class="nc" id="L6511">        return status;</span>
    }

    /** Returns the name of the cluster */
    public String getClusterName()
    {
<span class="nc" id="L6517">        return DatabaseDescriptor.getClusterName();</span>
    }

    /** Returns the cluster partitioner */
    public String getPartitionerName()
    {
<span class="nc" id="L6523">        return DatabaseDescriptor.getPartitionerName();</span>
    }

    /** Negative number for disabled */
    public void setSSTablePreemptiveOpenIntervalInMB(int intervalInMB)
    {
<span class="fc" id="L6529">        DatabaseDescriptor.setSSTablePreemptiveOpenIntervalInMiB(intervalInMB);</span>
<span class="fc" id="L6530">    }</span>

    /** This method can return negative number for disabled */
    public int getSSTablePreemptiveOpenIntervalInMB()
    {
<span class="fc" id="L6535">        return DatabaseDescriptor.getSSTablePreemptiveOpenIntervalInMiB();</span>
    }

    public boolean getMigrateKeycacheOnCompaction()
    {
<span class="nc" id="L6540">        return DatabaseDescriptor.shouldMigrateKeycacheOnCompaction();</span>
    }

    public void setMigrateKeycacheOnCompaction(boolean invalidateKeyCacheOnCompaction)
    {
<span class="nc" id="L6545">        DatabaseDescriptor.setMigrateKeycacheOnCompaction(invalidateKeyCacheOnCompaction);</span>
<span class="nc" id="L6546">    }</span>

    public int getTombstoneWarnThreshold()
    {
<span class="nc" id="L6550">        return DatabaseDescriptor.getTombstoneWarnThreshold();</span>
    }

    public void setTombstoneWarnThreshold(int threshold)
    {
<span class="nc" id="L6555">        DatabaseDescriptor.setTombstoneWarnThreshold(threshold);</span>
<span class="nc" id="L6556">        logger.info(&quot;updated tombstone_warn_threshold to {}&quot;, threshold);</span>
<span class="nc" id="L6557">    }</span>

    public int getTombstoneFailureThreshold()
    {
<span class="nc" id="L6561">        return DatabaseDescriptor.getTombstoneFailureThreshold();</span>
    }

    public void setTombstoneFailureThreshold(int threshold)
    {
<span class="nc" id="L6566">        DatabaseDescriptor.setTombstoneFailureThreshold(threshold);</span>
<span class="nc" id="L6567">        logger.info(&quot;updated tombstone_failure_threshold to {}&quot;, threshold);</span>
<span class="nc" id="L6568">    }</span>

    public int getCachedReplicaRowsWarnThreshold()
    {
<span class="nc" id="L6572">        return DatabaseDescriptor.getCachedReplicaRowsWarnThreshold();</span>
    }

    public void setCachedReplicaRowsWarnThreshold(int threshold)
    {
<span class="nc" id="L6577">        DatabaseDescriptor.setCachedReplicaRowsWarnThreshold(threshold);</span>
<span class="nc" id="L6578">        logger.info(&quot;updated replica_filtering_protection.cached_rows_warn_threshold to {}&quot;, threshold);</span>
<span class="nc" id="L6579">    }</span>

    public int getCachedReplicaRowsFailThreshold()
    {
<span class="nc" id="L6583">        return DatabaseDescriptor.getCachedReplicaRowsFailThreshold();</span>
    }

    public void setCachedReplicaRowsFailThreshold(int threshold)
    {
<span class="nc" id="L6588">        DatabaseDescriptor.setCachedReplicaRowsFailThreshold(threshold);</span>
<span class="nc" id="L6589">        logger.info(&quot;updated replica_filtering_protection.cached_rows_fail_threshold to {}&quot;, threshold);</span>
<span class="nc" id="L6590">    }</span>

    @Override
    public int getColumnIndexSizeInKiB()
    {
<span class="fc" id="L6595">        return DatabaseDescriptor.getColumnIndexSizeInKiB();</span>
    }

    @Override
    public void setColumnIndexSizeInKiB(int columnIndexSizeInKiB)
    {
<span class="fc" id="L6601">        int oldValueInKiB = DatabaseDescriptor.getColumnIndexSizeInKiB();</span>
        try
        {
<span class="fc" id="L6604">            DatabaseDescriptor.setColumnIndexSizeInKiB(columnIndexSizeInKiB);</span>
        }
<span class="fc" id="L6606">        catch (ConfigurationException e)</span>
        {
<span class="fc" id="L6608">            throw new IllegalArgumentException(e.getMessage());</span>
<span class="fc" id="L6609">        }</span>
<span class="fc" id="L6610">        logger.info(&quot;Updated column_index_size to {} KiB (was {} KiB)&quot;, columnIndexSizeInKiB, oldValueInKiB);</span>
<span class="fc" id="L6611">    }</span>

    @Deprecated
    @Override
    public void setColumnIndexSize(int columnIndexSizeInKB)
    {
<span class="fc" id="L6617">        int oldValueInKiB = DatabaseDescriptor.getColumnIndexSizeInKiB();</span>
<span class="fc" id="L6618">        DatabaseDescriptor.setColumnIndexSizeInKiB(columnIndexSizeInKB);</span>
<span class="fc" id="L6619">        logger.info(&quot;Updated column_index_size to {} KiB (was {} KiB)&quot;, columnIndexSizeInKB, oldValueInKiB);</span>
<span class="fc" id="L6620">    }</span>

    @Deprecated
    @Override
    public int getColumnIndexCacheSize()
    {
<span class="nc" id="L6626">        return DatabaseDescriptor.getColumnIndexCacheSizeInKiB();</span>
    }

    @Deprecated
    @Override
    public void setColumnIndexCacheSize(int cacheSizeInKB)
    {
<span class="nc" id="L6633">        DatabaseDescriptor.setColumnIndexCacheSize(cacheSizeInKB);</span>
<span class="nc" id="L6634">        logger.info(&quot;Updated column_index_cache_size to {}&quot;, cacheSizeInKB);</span>
<span class="nc" id="L6635">    }</span>

    /*
     * In CASSANDRA-17668, JMX setters that did not throw standard exceptions were deprecated in favor of ones that do.
     * For consistency purposes, the respective getter &quot;getColumnIndexCacheSize&quot; was also deprecated and replaced by
     * this method.
     */
    @Override
    public int getColumnIndexCacheSizeInKiB()
    {
<span class="fc" id="L6645">        return DatabaseDescriptor.getColumnIndexCacheSizeInKiB();</span>
    }

    @Override
    public void setColumnIndexCacheSizeInKiB(int cacheSizeInKiB)
    {
        try
        {
<span class="fc" id="L6653">            DatabaseDescriptor.setColumnIndexCacheSize(cacheSizeInKiB);</span>
        }
<span class="fc" id="L6655">        catch (ConfigurationException e)</span>
        {
<span class="fc" id="L6657">            throw new IllegalArgumentException(e.getMessage());</span>
<span class="fc" id="L6658">        }</span>
<span class="fc" id="L6659">        logger.info(&quot;Updated column_index_cache_size to {}&quot;, cacheSizeInKiB);</span>
<span class="fc" id="L6660">    }</span>

    public int getBatchSizeFailureThreshold()
    {
<span class="nc" id="L6664">        return DatabaseDescriptor.getBatchSizeFailThresholdInKiB();</span>
    }

    public void setBatchSizeFailureThreshold(int threshold)
    {
<span class="nc" id="L6669">        DatabaseDescriptor.setBatchSizeFailThresholdInKiB(threshold);</span>
<span class="nc" id="L6670">        logger.info(&quot;updated batch_size_fail_threshold to {}&quot;, threshold);</span>
<span class="nc" id="L6671">    }</span>

    @Deprecated
    @Override
    public int getBatchSizeWarnThreshold()
    {
<span class="nc" id="L6677">        return DatabaseDescriptor.getBatchSizeWarnThresholdInKiB();</span>
    }

    @Deprecated
    @Override
    public void setBatchSizeWarnThreshold(int threshold)
    {
<span class="nc" id="L6684">        DatabaseDescriptor.setBatchSizeWarnThresholdInKiB(threshold);</span>
<span class="nc" id="L6685">        logger.info(&quot;Updated batch_size_warn_threshold to {}&quot;, threshold);</span>
<span class="nc" id="L6686">    }</span>

    /*
     * In CASSANDRA-17668, JMX setters that did not throw standard exceptions were deprecated in favor of ones that do.
     * For consistency purposes, the respective getter &quot;getBatchSizeWarnThreshold&quot; was also deprecated and replaced by
     * this method.
     */
    @Override
    public int getBatchSizeWarnThresholdInKiB()
    {
<span class="fc" id="L6696">        return DatabaseDescriptor.getBatchSizeWarnThresholdInKiB();</span>
    }

    @Override
    public void setBatchSizeWarnThresholdInKiB(int thresholdInKiB)
    {
        try
        {
<span class="fc" id="L6704">            DatabaseDescriptor.setBatchSizeWarnThresholdInKiB(thresholdInKiB);</span>
        }
<span class="fc" id="L6706">        catch (ConfigurationException e)</span>
        {
<span class="fc" id="L6708">            throw new IllegalArgumentException(e.getMessage());</span>
<span class="fc" id="L6709">        }</span>

<span class="fc" id="L6711">        logger.info(&quot;Updated batch_size_warn_threshold to {}&quot;, thresholdInKiB);</span>
<span class="fc" id="L6712">    }</span>

    public int getInitialRangeTombstoneListAllocationSize()
    {
<span class="nc" id="L6716">        return DatabaseDescriptor.getInitialRangeTombstoneListAllocationSize();</span>
    }

    public void setInitialRangeTombstoneListAllocationSize(int size)
    {
<span class="fc bfc" id="L6721" title="All 4 branches covered.">        if (size &lt; 0 || size &gt; 1024)</span>
        {
<span class="fc" id="L6723">            throw new IllegalStateException(&quot;Not updating initial_range_tombstone_allocation_size as it must be in the range [0, 1024] inclusive&quot;);</span>
        }
<span class="fc" id="L6725">        int originalSize = DatabaseDescriptor.getInitialRangeTombstoneListAllocationSize();</span>
<span class="fc" id="L6726">        DatabaseDescriptor.setInitialRangeTombstoneListAllocationSize(size);</span>
<span class="fc" id="L6727">        logger.info(&quot;Updated initial_range_tombstone_allocation_size from {} to {}&quot;, originalSize, size);</span>
<span class="fc" id="L6728">    }</span>

    public double getRangeTombstoneResizeListGrowthFactor()
    {
<span class="nc" id="L6732">        return DatabaseDescriptor.getRangeTombstoneListGrowthFactor();</span>
    }

    public void setRangeTombstoneListResizeGrowthFactor(double growthFactor) throws IllegalStateException
    {
<span class="fc bfc" id="L6737" title="All 4 branches covered.">        if (growthFactor &lt; 1.2 || growthFactor &gt; 5)</span>
        {
<span class="fc" id="L6739">            throw new IllegalStateException(&quot;Not updating range_tombstone_resize_factor as growth factor must be in the range [1.2, 5.0] inclusive&quot;);</span>
        }
        else
        {
<span class="fc" id="L6743">            double originalGrowthFactor = DatabaseDescriptor.getRangeTombstoneListGrowthFactor();</span>
<span class="fc" id="L6744">            DatabaseDescriptor.setRangeTombstoneListGrowthFactor(growthFactor);</span>
<span class="fc" id="L6745">            logger.info(&quot;Updated range_tombstone_resize_factor from {} to {}&quot;, originalGrowthFactor, growthFactor);</span>
        }
<span class="fc" id="L6747">    }</span>

    public void setHintedHandoffThrottleInKB(int throttleInKB)
    {
<span class="nc" id="L6751">        DatabaseDescriptor.setHintedHandoffThrottleInKiB(throttleInKB);</span>
<span class="nc" id="L6752">        logger.info(&quot;updated hinted_handoff_throttle to {} KiB&quot;, throttleInKB);</span>
<span class="nc" id="L6753">    }</span>

    public boolean getTransferHintsOnDecommission()
    {
<span class="nc" id="L6757">        return DatabaseDescriptor.getTransferHintsOnDecommission();</span>
    }

    public void setTransferHintsOnDecommission(boolean enabled)
    {
<span class="nc" id="L6762">        DatabaseDescriptor.setTransferHintsOnDecommission(enabled);</span>
<span class="nc" id="L6763">        logger.info(&quot;updated transfer_hints_on_decommission to {}&quot;, enabled);</span>
<span class="nc" id="L6764">    }</span>

    @Override
    public void clearConnectionHistory()
    {
<span class="fc" id="L6769">        daemon.clearConnectionHistory();</span>
<span class="fc" id="L6770">        logger.info(&quot;Cleared connection history&quot;);</span>
<span class="fc" id="L6771">    }</span>
    public void disableAuditLog()
    {
<span class="fc" id="L6774">        AuditLogManager.instance.disableAuditLog();</span>
<span class="fc" id="L6775">        logger.info(&quot;Auditlog is disabled&quot;);</span>
<span class="fc" id="L6776">    }</span>

    @Deprecated
    public void enableAuditLog(String loggerName, String includedKeyspaces, String excludedKeyspaces, String includedCategories, String excludedCategories,
                               String includedUsers, String excludedUsers) throws ConfigurationException, IllegalStateException
    {
<span class="nc" id="L6782">        enableAuditLog(loggerName, Collections.emptyMap(), includedKeyspaces, excludedKeyspaces, includedCategories, excludedCategories, includedUsers, excludedUsers,</span>
<span class="nc" id="L6783">                       Integer.MIN_VALUE, null, null, Long.MIN_VALUE, Integer.MIN_VALUE, null);</span>
<span class="nc" id="L6784">    }</span>

    public void enableAuditLog(String loggerName, String includedKeyspaces, String excludedKeyspaces, String includedCategories, String excludedCategories,
                               String includedUsers, String excludedUsers, Integer maxArchiveRetries, Boolean block, String rollCycle,
                               Long maxLogSize, Integer maxQueueWeight, String archiveCommand) throws IllegalStateException
    {
<span class="nc" id="L6790">        enableAuditLog(loggerName, Collections.emptyMap(), includedKeyspaces, excludedKeyspaces, includedCategories, excludedCategories, includedUsers, excludedUsers,</span>
                       maxArchiveRetries, block, rollCycle, maxLogSize, maxQueueWeight, archiveCommand);
<span class="nc" id="L6792">    }</span>

    @Deprecated
    public void enableAuditLog(String loggerName, Map&lt;String, String&gt; parameters, String includedKeyspaces, String excludedKeyspaces, String includedCategories, String excludedCategories,
                               String includedUsers, String excludedUsers) throws ConfigurationException, IllegalStateException
    {
<span class="fc" id="L6798">        enableAuditLog(loggerName, parameters, includedKeyspaces, excludedKeyspaces, includedCategories, excludedCategories, includedUsers, excludedUsers,</span>
<span class="fc" id="L6799">                       Integer.MIN_VALUE, null, null, Long.MIN_VALUE, Integer.MIN_VALUE, null);</span>
<span class="fc" id="L6800">    }</span>

    public void enableAuditLog(String loggerName, Map&lt;String, String&gt; parameters, String includedKeyspaces, String excludedKeyspaces, String includedCategories, String excludedCategories,
                               String includedUsers, String excludedUsers, Integer maxArchiveRetries, Boolean block, String rollCycle,
                               Long maxLogSize, Integer maxQueueWeight, String archiveCommand) throws IllegalStateException
    {
<span class="fc" id="L6806">        AuditLogOptions auditOptions = DatabaseDescriptor.getAuditLoggingOptions();</span>
<span class="pc bpc" id="L6807" title="1 of 4 branches missed.">        if (archiveCommand != null &amp;&amp; !auditOptions.allow_nodetool_archive_command)</span>
<span class="fc" id="L6808">            throw new ConfigurationException(&quot;Can't enable audit log archiving via nodetool unless audit_logging_options.allow_nodetool_archive_command is set to true&quot;);</span>

<span class="fc" id="L6810">        final AuditLogOptions options = new AuditLogOptions.Builder(auditOptions)</span>
<span class="fc" id="L6811">                                        .withEnabled(true)</span>
<span class="fc" id="L6812">                                        .withLogger(loggerName, parameters)</span>
<span class="fc" id="L6813">                                        .withIncludedKeyspaces(includedKeyspaces)</span>
<span class="fc" id="L6814">                                        .withExcludedKeyspaces(excludedKeyspaces)</span>
<span class="fc" id="L6815">                                        .withIncludedCategories(includedCategories)</span>
<span class="fc" id="L6816">                                        .withExcludedCategories(excludedCategories)</span>
<span class="fc" id="L6817">                                        .withIncludedUsers(includedUsers)</span>
<span class="fc" id="L6818">                                        .withExcludedUsers(excludedUsers)</span>
<span class="fc" id="L6819">                                        .withMaxArchiveRetries(maxArchiveRetries)</span>
<span class="fc" id="L6820">                                        .withBlock(block)</span>
<span class="fc" id="L6821">                                        .withRollCycle(rollCycle)</span>
<span class="fc" id="L6822">                                        .withMaxLogSize(maxLogSize)</span>
<span class="fc" id="L6823">                                        .withMaxQueueWeight(maxQueueWeight)</span>
<span class="fc" id="L6824">                                        .withArchiveCommand(archiveCommand)</span>
<span class="fc" id="L6825">                                        .build();</span>

<span class="fc" id="L6827">        AuditLogManager.instance.enable(options);</span>
<span class="fc" id="L6828">        logger.info(&quot;AuditLog is enabled with configuration: {}&quot;, options);</span>
<span class="fc" id="L6829">    }</span>

    public boolean isAuditLogEnabled()
    {
<span class="fc" id="L6833">        return AuditLogManager.instance.isEnabled();</span>
    }

    public String getCorruptedTombstoneStrategy()
    {
<span class="nc" id="L6838">        return DatabaseDescriptor.getCorruptedTombstoneStrategy().toString();</span>
    }

    public void setCorruptedTombstoneStrategy(String strategy)
    {
<span class="nc" id="L6843">        DatabaseDescriptor.setCorruptedTombstoneStrategy(Config.CorruptedTombstoneStrategy.valueOf(strategy));</span>
<span class="nc" id="L6844">        logger.info(&quot;Setting corrupted tombstone strategy to {}&quot;, strategy);</span>
<span class="nc" id="L6845">    }</span>

    @Override
    public long getNativeTransportMaxConcurrentRequestsInBytes()
    {
<span class="nc" id="L6850">        return ClientResourceLimits.getGlobalLimit();</span>
    }

    @Override
    public void setNativeTransportMaxConcurrentRequestsInBytes(long newLimit)
    {
<span class="nc" id="L6856">        ClientResourceLimits.setGlobalLimit(newLimit);</span>
<span class="nc" id="L6857">    }</span>

    @Override
    public long getNativeTransportMaxConcurrentRequestsInBytesPerIp()
    {
<span class="nc" id="L6862">        return ClientResourceLimits.getEndpointLimit();</span>
    }

    @Override
    public void setNativeTransportMaxConcurrentRequestsInBytesPerIp(long newLimit)
    {
<span class="nc" id="L6868">        ClientResourceLimits.setEndpointLimit(newLimit);</span>
<span class="nc" id="L6869">    }</span>

    @Override
    public int getNativeTransportMaxRequestsPerSecond()
    {
<span class="fc" id="L6874">        return ClientResourceLimits.getNativeTransportMaxRequestsPerSecond();</span>
    }

    @Override
    public void setNativeTransportMaxRequestsPerSecond(int newPerSecond)
    {
<span class="fc" id="L6880">        ClientResourceLimits.setNativeTransportMaxRequestsPerSecond(newPerSecond);</span>
<span class="fc" id="L6881">    }</span>

    @Override
    public void setNativeTransportRateLimitingEnabled(boolean enabled)
    {
<span class="fc" id="L6886">        DatabaseDescriptor.setNativeTransportRateLimitingEnabled(enabled);</span>
<span class="fc" id="L6887">    }</span>

    @Override
    public boolean getNativeTransportRateLimitingEnabled()
    {
<span class="nc" id="L6892">        return DatabaseDescriptor.getNativeTransportRateLimitingEnabled();</span>
    }

    @VisibleForTesting
    public void shutdownServer()
    {
<span class="nc bnc" id="L6898" title="All 2 branches missed.">        if (drainOnShutdown != null)</span>
        {
<span class="nc" id="L6900">            Runtime.getRuntime().removeShutdownHook(drainOnShutdown);</span>
        }
<span class="nc" id="L6902">    }</span>

    @Override
    public void enableFullQueryLogger(String path, String rollCycle, Boolean blocking, int maxQueueWeight, long maxLogSize, String archiveCommand, int maxArchiveRetries)
    {
<span class="fc" id="L6907">        FullQueryLoggerOptions fqlOptions = DatabaseDescriptor.getFullQueryLogOptions();</span>
<span class="pc bpc" id="L6908" title="1 of 2 branches missed.">        path = path != null ? path : fqlOptions.log_dir;</span>
<span class="pc bpc" id="L6909" title="1 of 2 branches missed.">        rollCycle = rollCycle != null ? rollCycle : fqlOptions.roll_cycle;</span>
<span class="pc bpc" id="L6910" title="1 of 2 branches missed.">        blocking = blocking != null ? blocking : fqlOptions.block;</span>
<span class="pc bpc" id="L6911" title="1 of 2 branches missed.">        maxQueueWeight = maxQueueWeight != Integer.MIN_VALUE ? maxQueueWeight : fqlOptions.max_queue_weight;</span>
<span class="pc bpc" id="L6912" title="1 of 2 branches missed.">        maxLogSize = maxLogSize != Long.MIN_VALUE ? maxLogSize : fqlOptions.max_log_size;</span>
<span class="fc bfc" id="L6913" title="All 4 branches covered.">        if (archiveCommand != null &amp;&amp; !fqlOptions.allow_nodetool_archive_command)</span>
<span class="fc" id="L6914">            throw new ConfigurationException(&quot;Can't enable full query log archiving via nodetool unless full_query_logging_options.allow_nodetool_archive_command is set to true&quot;);</span>
<span class="fc bfc" id="L6915" title="All 2 branches covered.">        archiveCommand = archiveCommand != null ? archiveCommand : fqlOptions.archive_command;</span>
<span class="pc bpc" id="L6916" title="1 of 2 branches missed.">        maxArchiveRetries = maxArchiveRetries != Integer.MIN_VALUE ? maxArchiveRetries : fqlOptions.max_archive_retries;</span>

<span class="fc" id="L6918">        Preconditions.checkNotNull(path, &quot;cassandra.yaml did not set log_dir and not set as parameter&quot;);</span>
<span class="fc" id="L6919">        FullQueryLogger.instance.enableWithoutClean(File.getPath(path), rollCycle, blocking, maxQueueWeight, maxLogSize, archiveCommand, maxArchiveRetries);</span>
<span class="fc" id="L6920">    }</span>

    @Override
    public void resetFullQueryLogger()
    {
<span class="fc" id="L6925">        FullQueryLogger.instance.reset(DatabaseDescriptor.getFullQueryLogOptions().log_dir);</span>
<span class="fc" id="L6926">    }</span>

    @Override
    public void stopFullQueryLogger()
    {
<span class="fc" id="L6931">        FullQueryLogger.instance.stop();</span>
<span class="fc" id="L6932">    }</span>

    @Override
    public boolean isFullQueryLogEnabled()
    {
<span class="fc" id="L6937">        return FullQueryLogger.instance.isEnabled();</span>
    }

    @Override
    public CompositeData getFullQueryLoggerOptions()
    {
<span class="fc" id="L6943">        return FullQueryLoggerOptionsCompositeData.toCompositeData(FullQueryLogger.instance.getFullQueryLoggerOptions());</span>
    }

    @Override
    public Map&lt;String, Set&lt;InetAddress&gt;&gt; getOutstandingSchemaVersions()
    {
<span class="nc" id="L6949">        Map&lt;UUID, Set&lt;InetAddressAndPort&gt;&gt; outstanding = Schema.instance.getOutstandingSchemaVersions();</span>
<span class="nc" id="L6950">        return outstanding.entrySet().stream().collect(Collectors.toMap(e -&gt; e.getKey().toString(),</span>
<span class="nc" id="L6951">                                                                        e -&gt; e.getValue().stream().map(InetSocketAddress::getAddress).collect(Collectors.toSet())));</span>
    }

    @Override
    public Map&lt;String, Set&lt;String&gt;&gt; getOutstandingSchemaVersionsWithPort()
    {
<span class="nc" id="L6957">        Map&lt;UUID, Set&lt;InetAddressAndPort&gt;&gt; outstanding = Schema.instance.getOutstandingSchemaVersions();</span>
<span class="nc" id="L6958">        return outstanding.entrySet().stream().collect(Collectors.toMap(e -&gt; e.getKey().toString(),</span>
<span class="nc" id="L6959">                                                                        e -&gt; e.getValue().stream().map(Object::toString).collect(Collectors.toSet())));</span>
    }

    public boolean autoOptimiseIncRepairStreams()
    {
<span class="nc" id="L6964">        return DatabaseDescriptor.autoOptimiseIncRepairStreams();</span>
    }

    public void setAutoOptimiseIncRepairStreams(boolean enabled)
    {
<span class="nc" id="L6969">        DatabaseDescriptor.setAutoOptimiseIncRepairStreams(enabled);</span>
<span class="nc" id="L6970">    }</span>

    public boolean autoOptimiseFullRepairStreams()
    {
<span class="nc" id="L6974">        return DatabaseDescriptor.autoOptimiseFullRepairStreams();</span>
    }

    public void setAutoOptimiseFullRepairStreams(boolean enabled)
    {
<span class="nc" id="L6979">        DatabaseDescriptor.setAutoOptimiseFullRepairStreams(enabled);</span>
<span class="nc" id="L6980">    }</span>

    public boolean autoOptimisePreviewRepairStreams()
    {
<span class="nc" id="L6984">        return DatabaseDescriptor.autoOptimisePreviewRepairStreams();</span>
    }

    public void setAutoOptimisePreviewRepairStreams(boolean enabled)
    {
<span class="nc" id="L6989">        DatabaseDescriptor.setAutoOptimisePreviewRepairStreams(enabled);</span>
<span class="nc" id="L6990">    }</span>

    @Deprecated
    public int getTableCountWarnThreshold()
    {
<span class="nc" id="L6995">        return (int) Converters.TABLE_COUNT_THRESHOLD_TO_GUARDRAIL.unconvert(Guardrails.instance.getTablesWarnThreshold());</span>
    }

    @Deprecated
    public void setTableCountWarnThreshold(int value)
    {
<span class="nc bnc" id="L7001" title="All 2 branches missed.">        if (value &lt; 0)</span>
<span class="nc" id="L7002">            throw new IllegalStateException(&quot;Table count warn threshold should be positive, not &quot;+value);</span>
<span class="nc" id="L7003">        logger.info(&quot;Changing table count warn threshold from {} to {}&quot;, getTableCountWarnThreshold(), value);</span>
<span class="nc" id="L7004">        Guardrails.instance.setTablesThreshold((int) Converters.TABLE_COUNT_THRESHOLD_TO_GUARDRAIL.convert(value), </span>
<span class="nc" id="L7005">                                               Guardrails.instance.getTablesFailThreshold());</span>
<span class="nc" id="L7006">    }</span>

    @Deprecated
    public int getKeyspaceCountWarnThreshold()
    {
<span class="nc" id="L7011">        return (int) Converters.KEYSPACE_COUNT_THRESHOLD_TO_GUARDRAIL.unconvert(Guardrails.instance.getKeyspacesWarnThreshold());</span>
    }

    @Deprecated
    public void setKeyspaceCountWarnThreshold(int value)
    {
<span class="nc bnc" id="L7017" title="All 2 branches missed.">        if (value &lt; 0)</span>
<span class="nc" id="L7018">            throw new IllegalStateException(&quot;Keyspace count warn threshold should be positive, not &quot;+value);</span>
<span class="nc" id="L7019">        logger.info(&quot;Changing keyspace count warn threshold from {} to {}&quot;, getKeyspaceCountWarnThreshold(), value);</span>
<span class="nc" id="L7020">        Guardrails.instance.setKeyspacesThreshold((int) Converters.KEYSPACE_COUNT_THRESHOLD_TO_GUARDRAIL.convert(value),</span>
<span class="nc" id="L7021">                                                  Guardrails.instance.getKeyspacesFailThreshold());</span>
<span class="nc" id="L7022">    }</span>

    @Override
    public void setCompactionTombstoneWarningThreshold(int count)
    {
<span class="nc bnc" id="L7027" title="All 2 branches missed.">        if (count &lt; 0)</span>
<span class="nc" id="L7028">            throw new IllegalStateException(&quot;compaction tombstone warning threshold needs to be &gt;= 0, not &quot;+count);</span>
<span class="nc" id="L7029">        logger.info(&quot;Setting compaction_tombstone_warning_threshold to {}&quot;, count);</span>
<span class="nc" id="L7030">        Guardrails.instance.setPartitionTombstonesThreshold(count, Guardrails.instance.getPartitionTombstonesFailThreshold());</span>
<span class="nc" id="L7031">    }</span>

    @Override
    public int getCompactionTombstoneWarningThreshold()
    {
<span class="nc" id="L7036">        return Math.toIntExact(Guardrails.instance.getPartitionTombstonesWarnThreshold());</span>
    }

    public void addSnapshot(TableSnapshot snapshot) {
<span class="fc" id="L7040">        snapshotManager.addSnapshot(snapshot);</span>
<span class="fc" id="L7041">    }</span>

    @Override
    public boolean getReadThresholdsEnabled()
    {
<span class="nc" id="L7046">        return DatabaseDescriptor.getReadThresholdsEnabled();</span>
    }

    @Override
    public void setReadThresholdsEnabled(boolean value)
    {
<span class="nc" id="L7052">        DatabaseDescriptor.setReadThresholdsEnabled(value);</span>
<span class="nc" id="L7053">    }</span>

    @Override
    public String getCoordinatorLargeReadWarnThreshold()
    {
<span class="nc" id="L7058">        return toString(DatabaseDescriptor.getCoordinatorReadSizeWarnThreshold());</span>
    }

    @Override
    public void setCoordinatorLargeReadWarnThreshold(String threshold)
    {
<span class="nc" id="L7064">        DatabaseDescriptor.setCoordinatorReadSizeWarnThreshold(parseDataStorageSpec(threshold));</span>
<span class="nc" id="L7065">    }</span>

    @Override
    public String getCoordinatorLargeReadAbortThreshold()
    {
<span class="nc" id="L7070">        return toString(DatabaseDescriptor.getCoordinatorReadSizeFailThreshold());</span>
    }

    @Override
    public void setCoordinatorLargeReadAbortThreshold(String threshold)
    {
<span class="nc" id="L7076">        DatabaseDescriptor.setCoordinatorReadSizeFailThreshold(parseDataStorageSpec(threshold));</span>
<span class="nc" id="L7077">    }</span>

    @Override
    public String getLocalReadTooLargeWarnThreshold()
    {
<span class="nc" id="L7082">        return toString(DatabaseDescriptor.getLocalReadSizeWarnThreshold());</span>
    }

    @Override
    public void setLocalReadTooLargeWarnThreshold(String threshold)
    {
<span class="nc" id="L7088">        DatabaseDescriptor.setLocalReadSizeWarnThreshold(parseDataStorageSpec(threshold));</span>
<span class="nc" id="L7089">    }</span>

    @Override
    public String getLocalReadTooLargeAbortThreshold()
    {
<span class="nc" id="L7094">        return toString(DatabaseDescriptor.getLocalReadSizeFailThreshold());</span>
    }

    @Override
    public void setLocalReadTooLargeAbortThreshold(String threshold)
    {
<span class="nc" id="L7100">        DatabaseDescriptor.setLocalReadSizeFailThreshold(parseDataStorageSpec(threshold));</span>
<span class="nc" id="L7101">    }</span>

    @Override
    public String getRowIndexReadSizeWarnThreshold()
    {
<span class="nc" id="L7106">        return toString(DatabaseDescriptor.getRowIndexReadSizeWarnThreshold());</span>
    }

    @Override
    public void setRowIndexReadSizeWarnThreshold(String threshold)
    {
<span class="nc" id="L7112">        DatabaseDescriptor.setRowIndexReadSizeWarnThreshold(parseDataStorageSpec(threshold));</span>
<span class="nc" id="L7113">    }</span>

    @Override
    public String getRowIndexReadSizeAbortThreshold()
    {
<span class="nc" id="L7118">        return toString(DatabaseDescriptor.getRowIndexReadSizeFailThreshold());</span>
    }

    @Override
    public void setRowIndexReadSizeAbortThreshold(String threshold)
    {
<span class="nc" id="L7124">        DatabaseDescriptor.setRowIndexReadSizeFailThreshold(parseDataStorageSpec(threshold));</span>
<span class="nc" id="L7125">    }</span>

    private static String toString(DataStorageSpec value)
    {
<span class="nc bnc" id="L7129" title="All 2 branches missed.">        return value == null ? null : value.toString();</span>
    }

    public void setDefaultKeyspaceReplicationFactor(int value)
    {
<span class="fc" id="L7134">        DatabaseDescriptor.setDefaultKeyspaceRF(value);</span>
<span class="fc" id="L7135">        logger.info(&quot;set default keyspace rf to {}&quot;, value);</span>
<span class="fc" id="L7136">    }</span>

    private static DataStorageSpec.LongBytesBound parseDataStorageSpec(String threshold)
    {
<span class="nc bnc" id="L7140" title="All 2 branches missed.">        return threshold == null</span>
<span class="nc" id="L7141">               ? null</span>
<span class="nc" id="L7142">               : new DataStorageSpec.LongBytesBound(threshold);</span>
    }

    public int getDefaultKeyspaceReplicationFactor()
    {
<span class="fc" id="L7147">        return DatabaseDescriptor.getDefaultKeyspaceRF();</span>
    }

    public boolean getSkipPaxosRepairOnTopologyChange()
    {
<span class="nc" id="L7152">        return DatabaseDescriptor.skipPaxosRepairOnTopologyChange();</span>
    }

    public void setSkipPaxosRepairOnTopologyChange(boolean v)
    {
<span class="nc" id="L7157">        DatabaseDescriptor.setSkipPaxosRepairOnTopologyChange(v);</span>
<span class="nc bnc" id="L7158" title="All 2 branches missed.">        logger.info(&quot;paxos skip topology change repair {} via jmx&quot;, v ? &quot;enabled&quot; : &quot;disabled&quot;);</span>
<span class="nc" id="L7159">    }</span>

    public String getSkipPaxosRepairOnTopologyChangeKeyspaces()
    {
<span class="nc" id="L7163">        return Joiner.on(',').join(DatabaseDescriptor.skipPaxosRepairOnTopologyChangeKeyspaces());</span>
    }

    public void setSkipPaxosRepairOnTopologyChangeKeyspaces(String v)
    {
<span class="nc" id="L7168">        DatabaseDescriptor.setSkipPaxosRepairOnTopologyChangeKeyspaces(v);</span>
<span class="nc" id="L7169">        logger.info(&quot;paxos skip topology change repair keyspaces set to  {} via jmx&quot;, v);</span>
<span class="nc" id="L7170">    }</span>

    public boolean getPaxosAutoRepairsEnabled()
    {
<span class="nc" id="L7174">        return PaxosState.uncommittedTracker().isAutoRepairsEnabled();</span>
    }

    public void setPaxosAutoRepairsEnabled(boolean enabled)
    {
<span class="nc" id="L7179">        PaxosState.uncommittedTracker().setAutoRepairsEnabled(enabled);</span>
<span class="nc bnc" id="L7180" title="All 2 branches missed.">        logger.info(&quot;paxos auto repairs {} via jmx&quot;, enabled ? &quot;enabled&quot; : &quot;disabled&quot;);</span>
<span class="nc" id="L7181">    }</span>

    public boolean getPaxosStateFlushEnabled()
    {
<span class="nc" id="L7185">        return PaxosState.uncommittedTracker().isStateFlushEnabled();</span>
    }

    public void setPaxosStateFlushEnabled(boolean enabled)
    {
<span class="nc" id="L7190">        PaxosState.uncommittedTracker().setStateFlushEnabled(enabled);</span>
<span class="nc bnc" id="L7191" title="All 2 branches missed.">        logger.info(&quot;paxos state flush {} via jmx&quot;, enabled ? &quot;enabled&quot; : &quot;disabled&quot;);</span>
<span class="nc" id="L7192">    }</span>

    public List&lt;String&gt; getPaxosAutoRepairTables()
    {
<span class="nc" id="L7196">        Set&lt;TableId&gt; tableIds = PaxosState.uncommittedTracker().tableIds();</span>
<span class="nc" id="L7197">        List&lt;String&gt; tables = new ArrayList&lt;&gt;(tableIds.size());</span>
<span class="nc bnc" id="L7198" title="All 2 branches missed.">        for (TableId tableId : tableIds)</span>
        {
<span class="nc" id="L7200">            TableMetadata table = Schema.instance.getTableMetadata(tableId);</span>
<span class="nc bnc" id="L7201" title="All 2 branches missed.">            if (table == null)</span>
<span class="nc" id="L7202">                continue;</span>
<span class="nc" id="L7203">            tables.add(table.keyspace + '.' + table.name);</span>
<span class="nc" id="L7204">        }</span>
<span class="nc" id="L7205">        return tables;</span>
    }

    public long getPaxosPurgeGraceSeconds()
    {
<span class="nc" id="L7210">        return DatabaseDescriptor.getPaxosPurgeGrace(SECONDS);</span>
    }

    public void setPaxosPurgeGraceSeconds(long v)
    {
<span class="nc" id="L7215">        DatabaseDescriptor.setPaxosPurgeGrace(v);</span>
<span class="nc" id="L7216">        logger.info(&quot;paxos purging grace seconds set to {} via jmx&quot;, v);</span>
<span class="nc" id="L7217">    }</span>

    public String getPaxosOnLinearizabilityViolations()
    {
<span class="nc" id="L7221">        return DatabaseDescriptor.paxosOnLinearizabilityViolations().toString();</span>
    }

    public void setPaxosOnLinearizabilityViolations(String v)
    {
<span class="nc" id="L7226">        DatabaseDescriptor.setPaxosOnLinearizabilityViolations(Config.PaxosOnLinearizabilityViolation.valueOf(v));</span>
<span class="nc" id="L7227">        logger.info(&quot;paxos on linearizability violations {} via jmx&quot;, v);</span>
<span class="nc" id="L7228">    }</span>

    public String getPaxosStatePurging()
    {
<span class="nc" id="L7232">        return DatabaseDescriptor.paxosStatePurging().name();</span>
    }

    public void setPaxosStatePurging(String v)
    {
<span class="nc" id="L7237">        DatabaseDescriptor.setPaxosStatePurging(PaxosStatePurging.valueOf(v));</span>
<span class="nc" id="L7238">        logger.info(&quot;paxos state purging {} via jmx&quot;, v);</span>
<span class="nc" id="L7239">    }</span>

    public boolean getPaxosRepairEnabled()
    {
<span class="nc" id="L7243">        return DatabaseDescriptor.paxosRepairEnabled();</span>
    }

    public void setPaxosRepairEnabled(boolean enabled)
    {
<span class="nc" id="L7248">        DatabaseDescriptor.setPaxosRepairEnabled(enabled);</span>
<span class="nc bnc" id="L7249" title="All 2 branches missed.">        logger.info(&quot;paxos repair {} via jmx&quot;, enabled ? &quot;enabled&quot; : &quot;disabled&quot;);</span>
<span class="nc" id="L7250">    }</span>

    public boolean getPaxosDcLocalCommitEnabled()
    {
<span class="nc" id="L7254">        return PaxosCommit.getEnableDcLocalCommit();</span>
    }

    public void setPaxosDcLocalCommitEnabled(boolean enabled)
    {
<span class="nc" id="L7259">        PaxosCommit.setEnableDcLocalCommit(enabled);</span>
<span class="nc bnc" id="L7260" title="All 2 branches missed.">        logger.info(&quot;paxos dc local commit {} via jmx&quot;, enabled ? &quot;enabled&quot; : &quot;disabled&quot;);</span>
<span class="nc" id="L7261">    }</span>

    public String getPaxosBallotLowBound(String ksName, String tblName, String key)
    {
<span class="nc" id="L7265">        Keyspace keyspace = Keyspace.open(ksName);</span>
<span class="nc bnc" id="L7266" title="All 2 branches missed.">        if (keyspace == null)</span>
<span class="nc" id="L7267">            throw new IllegalArgumentException(&quot;Unknown keyspace '&quot; + ksName + &quot;'&quot;);</span>

<span class="nc" id="L7269">        ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(tblName);</span>
<span class="nc bnc" id="L7270" title="All 2 branches missed.">        if (cfs == null)</span>
<span class="nc" id="L7271">            throw new IllegalArgumentException(&quot;Unknown table '&quot; + tblName + &quot;' in keyspace '&quot; + ksName + &quot;'&quot;);</span>

<span class="nc" id="L7273">        TableMetadata table = cfs.metadata.get();</span>
<span class="nc" id="L7274">        DecoratedKey dk = table.partitioner.decorateKey(table.partitionKeyType.fromString(key));</span>
<span class="nc" id="L7275">        return cfs.getPaxosRepairHistory().ballotForToken(dk.getToken()).toString();</span>
    }

    public Long getRepairRpcTimeout()
    {
<span class="nc" id="L7280">        return DatabaseDescriptor.getRepairRpcTimeout(MILLISECONDS);</span>
    }

    public void setRepairRpcTimeout(Long timeoutInMillis)
    {
<span class="nc bnc" id="L7285" title="All 2 branches missed.">        Preconditions.checkState(timeoutInMillis &gt; 0);</span>
<span class="nc" id="L7286">        DatabaseDescriptor.setRepairRpcTimeout(timeoutInMillis);</span>
<span class="nc" id="L7287">        logger.info(&quot;RepairRpcTimeout set to {}ms via JMX&quot;, timeoutInMillis);</span>
<span class="nc" id="L7288">    }</span>
    public void evictHungRepairs()
    {
<span class="nc" id="L7291">        logger.info(&quot;StorageService#clearPaxosRateLimiters called via jmx&quot;);</span>
<span class="nc" id="L7292">        Paxos.evictHungRepairs();</span>
<span class="nc" id="L7293">    }</span>

    public void clearPaxosRepairs()
    {
<span class="nc" id="L7297">        logger.info(&quot;StorageService#clearPaxosRepairs called via jmx&quot;);</span>
<span class="nc" id="L7298">        PaxosTableRepairs.clearRepairs();</span>
<span class="nc" id="L7299">    }</span>

    public void setSkipPaxosRepairCompatibilityCheck(boolean v)
    {
<span class="nc" id="L7303">        PaxosRepair.setSkipPaxosRepairCompatibilityCheck(v);</span>
<span class="nc" id="L7304">        logger.info(&quot;SkipPaxosRepairCompatibilityCheck set to {} via jmx&quot;, v);</span>
<span class="nc" id="L7305">    }</span>

    public boolean getSkipPaxosRepairCompatibilityCheck()
    {
<span class="nc" id="L7309">        return PaxosRepair.getSkipPaxosRepairCompatibilityCheck();</span>
    }

    @Override
    public boolean topPartitionsEnabled()
    {
<span class="nc" id="L7315">        return DatabaseDescriptor.topPartitionsEnabled();</span>
    }

    @Override
    public int getMaxTopSizePartitionCount()
    {
<span class="nc" id="L7321">        return DatabaseDescriptor.getMaxTopSizePartitionCount();</span>
    }

    @Override
    public void setMaxTopSizePartitionCount(int value)
    {
<span class="nc" id="L7327">        DatabaseDescriptor.setMaxTopSizePartitionCount(value);</span>
<span class="nc" id="L7328">    }</span>

    @Override
    public int getMaxTopTombstonePartitionCount()
    {
<span class="nc" id="L7333">        return DatabaseDescriptor.getMaxTopTombstonePartitionCount();</span>
    }

    @Override
    public void setMaxTopTombstonePartitionCount(int value)
    {
<span class="nc" id="L7339">        DatabaseDescriptor.setMaxTopTombstonePartitionCount(value);</span>
<span class="nc" id="L7340">    }</span>

    @Override
    public String getMinTrackedPartitionSize()
    {
<span class="nc" id="L7345">        return DatabaseDescriptor.getMinTrackedPartitionSizeInBytes().toString();</span>
    }

    @Override
    public void setMinTrackedPartitionSize(String value)
    {
<span class="nc" id="L7351">        DatabaseDescriptor.setMinTrackedPartitionSizeInBytes(parseDataStorageSpec(value));</span>
<span class="nc" id="L7352">    }</span>

    @Override
    public long getMinTrackedPartitionTombstoneCount()
    {
<span class="nc" id="L7357">        return DatabaseDescriptor.getMinTrackedPartitionTombstoneCount();</span>
    }

    @Override
    public void setMinTrackedPartitionTombstoneCount(long value)
    {
<span class="nc" id="L7363">        DatabaseDescriptor.setMinTrackedPartitionTombstoneCount(value);</span>
<span class="nc" id="L7364">    }</span>

    public void setSkipStreamDiskSpaceCheck(boolean value)
    {
<span class="nc bnc" id="L7368" title="All 2 branches missed.">        if (value != DatabaseDescriptor.getSkipStreamDiskSpaceCheck())</span>
<span class="nc" id="L7369">            logger.info(&quot;Changing skip_stream_disk_space_check from {} to {}&quot;, DatabaseDescriptor.getSkipStreamDiskSpaceCheck(), value);</span>
<span class="nc" id="L7370">        DatabaseDescriptor.setSkipStreamDiskSpaceCheck(value);</span>
<span class="nc" id="L7371">    }</span>

    public boolean getSkipStreamDiskSpaceCheck()
    {
<span class="nc" id="L7375">        return DatabaseDescriptor.getSkipStreamDiskSpaceCheck();</span>
    }

    @Override
    public void removeNotificationListener(NotificationListener listener) throws ListenerNotFoundException
    {
<span class="nc bnc" id="L7381" title="All 2 branches missed.">        if (!skipNotificationListeners)</span>
<span class="nc" id="L7382">            super.removeNotificationListener(listener);</span>
<span class="nc" id="L7383">    }</span>

    @Override
    public void removeNotificationListener(NotificationListener listener, NotificationFilter filter, Object handback) throws ListenerNotFoundException
    {
<span class="nc bnc" id="L7388" title="All 2 branches missed.">        if (!skipNotificationListeners)</span>
<span class="nc" id="L7389">            super.removeNotificationListener(listener, filter, handback);</span>
<span class="nc" id="L7390">    }</span>

    @Override
    public void addNotificationListener(NotificationListener listener,
                                        NotificationFilter filter,
                                        Object handback) throws java.lang.IllegalArgumentException
    {
<span class="nc bnc" id="L7397" title="All 2 branches missed.">        if (!skipNotificationListeners)</span>
<span class="nc" id="L7398">            super.addNotificationListener(listener, filter, handback);</span>
<span class="nc" id="L7399">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>