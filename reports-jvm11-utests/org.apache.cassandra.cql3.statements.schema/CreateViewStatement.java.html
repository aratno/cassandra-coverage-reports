<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CreateViewStatement.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.statements.schema</a> &gt; <span class="el_source">CreateViewStatement.java</span></div><h1>CreateViewStatement.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3.statements.schema;

import java.util.*;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

import org.apache.cassandra.audit.AuditLogContext;
import org.apache.cassandra.audit.AuditLogEntryType;
import org.apache.cassandra.auth.Permission;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.cql3.*;
import org.apache.cassandra.cql3.restrictions.StatementRestrictions;
import org.apache.cassandra.cql3.selection.RawSelector;
import org.apache.cassandra.cql3.selection.Selectable;
import org.apache.cassandra.cql3.statements.StatementType;
import org.apache.cassandra.db.guardrails.Guardrails;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.marshal.ReversedType;
import org.apache.cassandra.db.view.View;
import org.apache.cassandra.exceptions.AlreadyExistsException;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.schema.*;
import org.apache.cassandra.schema.Keyspaces.KeyspacesDiff;
import org.apache.cassandra.service.ClientState;
import org.apache.cassandra.transport.Event.SchemaChange;
import org.apache.cassandra.transport.Event.SchemaChange.Change;
import org.apache.cassandra.transport.Event.SchemaChange.Target;

import static java.lang.String.join;

import static com.google.common.collect.Iterables.concat;
import static com.google.common.collect.Iterables.filter;
import static com.google.common.collect.Iterables.transform;
import static org.apache.cassandra.config.CassandraRelevantProperties.MV_ALLOW_FILTERING_NONKEY_COLUMNS_UNSAFE;

public final class CreateViewStatement extends AlterSchemaStatement
{
    private final String tableName;
    private final String viewName;

    private final List&lt;RawSelector&gt; rawColumns;
    private final List&lt;ColumnIdentifier&gt; partitionKeyColumns;
    private final List&lt;ColumnIdentifier&gt; clusteringColumns;

    private final WhereClause whereClause;

    private final LinkedHashMap&lt;ColumnIdentifier, Boolean&gt; clusteringOrder;
    private final TableAttributes attrs;

    private final boolean ifNotExists;

    private ClientState state;

    public CreateViewStatement(String keyspaceName,
                               String tableName,
                               String viewName,

                               List&lt;RawSelector&gt; rawColumns,
                               List&lt;ColumnIdentifier&gt; partitionKeyColumns,
                               List&lt;ColumnIdentifier&gt; clusteringColumns,

                               WhereClause whereClause,

                               LinkedHashMap&lt;ColumnIdentifier, Boolean&gt; clusteringOrder,
                               TableAttributes attrs,

                               boolean ifNotExists)
    {
<span class="fc" id="L88">        super(keyspaceName);</span>
<span class="fc" id="L89">        this.tableName = tableName;</span>
<span class="fc" id="L90">        this.viewName = viewName;</span>

<span class="fc" id="L92">        this.rawColumns = rawColumns;</span>
<span class="fc" id="L93">        this.partitionKeyColumns = partitionKeyColumns;</span>
<span class="fc" id="L94">        this.clusteringColumns = clusteringColumns;</span>

<span class="fc" id="L96">        this.whereClause = whereClause;</span>

<span class="fc" id="L98">        this.clusteringOrder = clusteringOrder;</span>
<span class="fc" id="L99">        this.attrs = attrs;</span>

<span class="fc" id="L101">        this.ifNotExists = ifNotExists;</span>
<span class="fc" id="L102">    }</span>

    @Override
    public void validate(ClientState state)
    {
<span class="fc" id="L107">        super.validate(state);</span>

        // save the query state to use it for guardrails validation in #apply
<span class="fc" id="L110">        this.state = state;</span>
<span class="fc" id="L111">    }</span>

    public Keyspaces apply(Keyspaces schema)
    {
<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (!DatabaseDescriptor.getMaterializedViewsEnabled())</span>
<span class="fc" id="L116">            throw ire(&quot;Materialized views are disabled. Enable in cassandra.yaml to use.&quot;);</span>

        /*
         * Basic dependency validations
         */

<span class="fc" id="L122">        KeyspaceMetadata keyspace = schema.getNullable(keyspaceName);</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">        if (null == keyspace)</span>
<span class="nc" id="L124">            throw ire(&quot;Keyspace '%s' doesn't exist&quot;, keyspaceName);</span>

<span class="pc bpc" id="L126" title="1 of 2 branches missed.">        if (keyspace.createReplicationStrategy().hasTransientReplicas())</span>
<span class="nc" id="L127">            throw new InvalidRequestException(&quot;Materialized views are not supported on transiently replicated keyspaces&quot;);</span>

<span class="fc" id="L129">        TableMetadata table = keyspace.tables.getNullable(tableName);</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">        if (null == table)</span>
<span class="nc" id="L131">            throw ire(&quot;Base table '%s' doesn't exist&quot;, tableName);</span>

<span class="pc bpc" id="L133" title="1 of 2 branches missed.">        if (keyspace.hasTable(viewName))</span>
<span class="nc" id="L134">            throw ire(&quot;Cannot create materialized view '%s' - a table with the same name already exists&quot;, viewName);</span>

<span class="fc bfc" id="L136" title="All 2 branches covered.">        if (keyspace.hasView(viewName))</span>
        {
<span class="fc bfc" id="L138" title="All 2 branches covered.">            if (ifNotExists)</span>
<span class="fc" id="L139">                return schema;</span>

<span class="fc" id="L141">            throw new AlreadyExistsException(keyspaceName, viewName);</span>
        }

        /*
         * Base table validation
         */

<span class="fc bfc" id="L148" title="All 2 branches covered.">        if (table.isCounter())</span>
<span class="fc" id="L149">            throw ire(&quot;Materialized views are not supported on counter tables&quot;);</span>

<span class="pc bpc" id="L151" title="1 of 2 branches missed.">        if (table.isView())</span>
<span class="nc" id="L152">            throw ire(&quot;Materialized views cannot be created against other materialized views&quot;);</span>

        // Guardrails on table properties
<span class="fc" id="L155">        Guardrails.tableProperties.guard(attrs.updatedProperties(), attrs::removeProperty, state);</span>

        // Guardrail to limit number of mvs per table
<span class="fc" id="L158">        Iterable&lt;ViewMetadata&gt; tableViews = keyspace.views.forTable(table.id);</span>
<span class="fc" id="L159">        Guardrails.materializedViewsPerTable.guard(Iterables.size(tableViews) + 1,</span>
<span class="fc" id="L160">                                                   String.format(&quot;%s on table %s&quot;, viewName, table.name),</span>
                                                   false,
                                                   state);

<span class="pc bpc" id="L164" title="1 of 2 branches missed.">        if (table.params.gcGraceSeconds == 0)</span>
        {
<span class="nc" id="L166">            throw ire(&quot;Cannot create materialized view '%s' for base table &quot; +</span>
                      &quot;'%s' with gc_grace_seconds of 0, since this value is &quot; +
                      &quot;used to TTL undelivered updates. Setting gc_grace_seconds&quot; +
                      &quot; too low might cause undelivered updates to expire &quot; +
                      &quot;before being replayed.&quot;,
                      viewName, tableName);
        }

        /*
         * Process SELECT clause
         */

<span class="fc" id="L178">        Set&lt;ColumnIdentifier&gt; selectedColumns = new HashSet&lt;&gt;();</span>

<span class="fc bfc" id="L180" title="All 2 branches covered.">        if (rawColumns.isEmpty()) // SELECT *</span>
<span class="fc" id="L181">            table.columns().forEach(c -&gt; selectedColumns.add(c.name));</span>

<span class="fc" id="L183">        rawColumns.forEach(selector -&gt;</span>
        {
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">            if (null != selector.alias)</span>
<span class="nc" id="L186">                throw ire(&quot;Cannot use aliases when defining a materialized view (got %s)&quot;, selector);</span>

<span class="fc bfc" id="L188" title="All 2 branches covered.">            if (!(selector.selectable instanceof Selectable.RawIdentifier))</span>
<span class="fc" id="L189">                throw ire(&quot;Can only select columns by name when defining a materialized view (got %s)&quot;, selector.selectable);</span>

            // will throw IRE if the column doesn't exist in the base table
<span class="fc" id="L192">            Selectable.RawIdentifier rawIdentifier = (Selectable.RawIdentifier) selector.selectable;</span>
<span class="fc" id="L193">            ColumnMetadata column = rawIdentifier.columnMetadata(table);</span>

<span class="fc" id="L195">            selectedColumns.add(column.name);</span>
<span class="fc" id="L196">        });</span>

<span class="fc" id="L198">        selectedColumns.stream()</span>
<span class="fc" id="L199">                       .map(table::getColumn)</span>
<span class="fc" id="L200">                       .filter(ColumnMetadata::isStatic)</span>
<span class="fc" id="L201">                       .findAny()</span>
<span class="fc" id="L202">                       .ifPresent(c -&gt; { throw ire(&quot;Cannot include static column '%s' in materialized view '%s'&quot;, c, viewName); });</span>

        /*
         * Process PRIMARY KEY columns and CLUSTERING ORDER BY clause
         */

<span class="pc bpc" id="L208" title="1 of 2 branches missed.">        if (partitionKeyColumns.isEmpty())</span>
<span class="nc" id="L209">            throw ire(&quot;Must provide at least one partition key column for materialized view '%s'&quot;, viewName);</span>

<span class="fc" id="L211">        HashSet&lt;ColumnIdentifier&gt; primaryKeyColumns = new HashSet&lt;&gt;();</span>

<span class="fc" id="L213">        concat(partitionKeyColumns, clusteringColumns).forEach(name -&gt;</span>
        {
<span class="fc" id="L215">            ColumnMetadata column = table.getColumn(name);</span>
<span class="pc bpc" id="L216" title="1 of 4 branches missed.">            if (null == column || !selectedColumns.contains(name))</span>
<span class="fc" id="L217">                throw ire(&quot;Unknown column '%s' referenced in PRIMARY KEY for materialized view '%s'&quot;, name, viewName);</span>

<span class="fc bfc" id="L219" title="All 2 branches covered.">            if (!primaryKeyColumns.add(name))</span>
<span class="fc" id="L220">                throw ire(&quot;Duplicate column '%s' in PRIMARY KEY clause for materialized view '%s'&quot;, name, viewName);</span>

<span class="fc" id="L222">            AbstractType&lt;?&gt; type = column.type;</span>

<span class="fc bfc" id="L224" title="All 2 branches covered.">            if (type.isMultiCell())</span>
            {
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">                if (type.isCollection())</span>
<span class="fc" id="L227">                    throw ire(&quot;Invalid non-frozen collection type '%s' for PRIMARY KEY column '%s'&quot;, type, name);</span>
                else
<span class="nc" id="L229">                    throw ire(&quot;Invalid non-frozen user-defined type '%s' for PRIMARY KEY column '%s'&quot;, type, name);</span>
            }

<span class="pc bpc" id="L232" title="1 of 2 branches missed.">            if (type.isCounter())</span>
<span class="nc" id="L233">                throw ire(&quot;counter type is not supported for PRIMARY KEY column '%s'&quot;, name);</span>

<span class="fc bfc" id="L235" title="All 2 branches covered.">            if (type.referencesDuration())</span>
<span class="fc" id="L236">                throw ire(&quot;duration type is not supported for PRIMARY KEY column '%s'&quot;, name);</span>
<span class="fc" id="L237">        });</span>

        // If we give a clustering order, we must explicitly do so for all aliases and in the order of the PK
<span class="pc bpc" id="L240" title="1 of 4 branches missed.">        if (!clusteringOrder.isEmpty() &amp;&amp; !clusteringColumns.equals(new ArrayList&lt;&gt;(clusteringOrder.keySet())))</span>
<span class="nc" id="L241">            throw ire(&quot;Clustering key columns must exactly match columns in CLUSTERING ORDER BY directive&quot;);</span>

        /*
         * We need to include all of the primary key columns from the base table in order to make sure that we do not
         * overwrite values in the view. We cannot support &quot;collapsing&quot; the base table into a smaller number of rows in
         * the view because if we need to generate a tombstone, we have no way of knowing which value is currently being
         * used in the view and whether or not to generate a tombstone. In order to not surprise our users, we require
         * that they include all of the columns. We provide them with a list of all of the columns left to include.
         */
<span class="fc" id="L250">        List&lt;ColumnIdentifier&gt; missingPrimaryKeyColumns =</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">            Lists.newArrayList(filter(transform(table.primaryKeyColumns(), c -&gt; c.name), c -&gt; !primaryKeyColumns.contains(c)));</span>

<span class="pc bpc" id="L253" title="1 of 2 branches missed.">        if (!missingPrimaryKeyColumns.isEmpty())</span>
        {
<span class="nc" id="L255">            throw ire(&quot;Cannot create materialized view '%s' without primary key columns %s from base table '%s'&quot;,</span>
<span class="nc" id="L256">                      viewName, join(&quot;, &quot;, transform(missingPrimaryKeyColumns, ColumnIdentifier::toString)), tableName);</span>
        }

<span class="fc" id="L259">        Set&lt;ColumnIdentifier&gt; regularBaseTableColumnsInViewPrimaryKey = new HashSet&lt;&gt;(primaryKeyColumns);</span>
<span class="fc" id="L260">        transform(table.primaryKeyColumns(), c -&gt; c.name).forEach(regularBaseTableColumnsInViewPrimaryKey::remove);</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">        if (regularBaseTableColumnsInViewPrimaryKey.size() &gt; 1)</span>
        {
<span class="fc" id="L263">            throw ire(&quot;Cannot include more than one non-primary key column in materialized view primary key (got %s)&quot;,</span>
<span class="fc" id="L264">                      join(&quot;, &quot;, transform(regularBaseTableColumnsInViewPrimaryKey, ColumnIdentifier::toString)));</span>
        }

        /*
         * Process WHERE clause
         */
<span class="fc bfc" id="L270" title="All 2 branches covered.">        if (whereClause.containsTokenRelations())</span>
<span class="fc" id="L271">            throw new InvalidRequestException(&quot;Cannot use token relation when defining a materialized view&quot;);</span>

<span class="pc bpc" id="L273" title="1 of 2 branches missed.">        if (whereClause.containsCustomExpressions())</span>
<span class="nc" id="L274">            throw ire(&quot;WHERE clause for materialized view '%s' cannot contain custom index expressions&quot;, viewName);</span>

<span class="fc" id="L276">        StatementRestrictions restrictions =</span>
            new StatementRestrictions(state,
                                      StatementType.SELECT,
                                      table,
                                      whereClause,
<span class="fc" id="L281">                                      VariableSpecifications.empty(),</span>
                                      false,
                                      false,
                                      true,
                                      true);

<span class="fc" id="L287">        List&lt;ColumnIdentifier&gt; nonRestrictedPrimaryKeyColumns =</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">            Lists.newArrayList(filter(primaryKeyColumns, name -&gt; !restrictions.isRestricted(table.getColumn(name))));</span>

<span class="fc bfc" id="L290" title="All 2 branches covered.">        if (!nonRestrictedPrimaryKeyColumns.isEmpty())</span>
        {
<span class="fc" id="L292">            throw ire(&quot;Primary key columns %s must be restricted with 'IS NOT NULL' or otherwise&quot;,</span>
<span class="fc" id="L293">                      join(&quot;, &quot;, transform(nonRestrictedPrimaryKeyColumns, ColumnIdentifier::toString)));</span>
        }

        // See CASSANDRA-13798
<span class="fc" id="L297">        Set&lt;ColumnMetadata&gt; restrictedNonPrimaryKeyColumns = restrictions.nonPKRestrictedColumns(false);</span>
<span class="fc bfc" id="L298" title="All 4 branches covered.">        if (!restrictedNonPrimaryKeyColumns.isEmpty() &amp;&amp; !MV_ALLOW_FILTERING_NONKEY_COLUMNS_UNSAFE.getBoolean())</span>
        {
<span class="fc" id="L300">            throw ire(&quot;Non-primary key columns can only be restricted with 'IS NOT NULL' (got: %s restricted illegally)&quot;,</span>
<span class="fc" id="L301">                      join(&quot;,&quot;, transform(restrictedNonPrimaryKeyColumns, ColumnMetadata::toString)));</span>
        }

        /*
         * Validate WITH params
         */

<span class="fc" id="L308">        attrs.validate();</span>

<span class="fc bfc" id="L310" title="All 2 branches covered.">        if (attrs.hasOption(TableParams.Option.DEFAULT_TIME_TO_LIVE)</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">            &amp;&amp; attrs.getInt(TableParams.Option.DEFAULT_TIME_TO_LIVE.toString(), 0) != 0)</span>
        {
<span class="fc" id="L313">            throw ire(&quot;Cannot set default_time_to_live for a materialized view. &quot; +</span>
                      &quot;Data in a materialized view always expire at the same time than &quot; +
                      &quot;the corresponding data in the parent table.&quot;);
        }

        /*
         * Build the thing
         */

<span class="fc" id="L322">        TableMetadata.Builder builder = TableMetadata.builder(keyspaceName, viewName);</span>

<span class="pc bpc" id="L324" title="1 of 2 branches missed.">        if (attrs.hasProperty(TableAttributes.ID))</span>
<span class="nc" id="L325">            builder.id(attrs.getId());</span>

<span class="fc" id="L327">        builder.params(attrs.asNewTableParams())</span>
<span class="fc" id="L328">               .kind(TableMetadata.Kind.VIEW);</span>

<span class="fc" id="L330">        partitionKeyColumns.stream()</span>
<span class="fc" id="L331">                           .map(table::getColumn)</span>
<span class="fc" id="L332">                           .forEach(column -&gt; builder.addPartitionKeyColumn(column.name, getType(column), column.getMask()));</span>

<span class="fc" id="L334">        clusteringColumns.stream()</span>
<span class="fc" id="L335">                         .map(table::getColumn)</span>
<span class="fc" id="L336">                         .forEach(column -&gt; builder.addClusteringColumn(column.name, getType(column), column.getMask()));</span>

<span class="fc" id="L338">        selectedColumns.stream()</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">                       .filter(name -&gt; !primaryKeyColumns.contains(name))</span>
<span class="fc" id="L340">                       .map(table::getColumn)</span>
<span class="fc" id="L341">                       .forEach(column -&gt; builder.addRegularColumn(column.name, getType(column), column.getMask()));</span>

<span class="fc" id="L343">        ViewMetadata view = new ViewMetadata(table.id, table.name, rawColumns.isEmpty(), whereClause, builder.build());</span>
<span class="fc" id="L344">        view.metadata.validate();</span>

<span class="fc" id="L346">        return schema.withAddedOrUpdated(keyspace.withSwapped(keyspace.views.with(view)));</span>
    }

    SchemaChange schemaChangeEvent(KeyspacesDiff diff)
    {
<span class="fc" id="L351">        return new SchemaChange(Change.CREATED, Target.TABLE, keyspaceName, viewName);</span>
    }

    public void authorize(ClientState client)
    {
<span class="fc" id="L356">        client.ensureTablePermission(keyspaceName, tableName, Permission.ALTER);</span>
<span class="fc" id="L357">    }</span>

    private AbstractType&lt;?&gt; getType(ColumnMetadata column)
    {
<span class="fc" id="L361">        AbstractType&lt;?&gt; type = column.type;</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">        if (clusteringOrder.containsKey(column.name))</span>
        {
<span class="fc bfc" id="L364" title="All 2 branches covered.">            boolean reverse = !clusteringOrder.get(column.name);</span>

<span class="fc bfc" id="L366" title="All 4 branches covered.">            if (type.isReversed() &amp;&amp; !reverse)</span>
<span class="fc" id="L367">                return ((ReversedType&lt;?&gt;) type).baseType;</span>

<span class="fc bfc" id="L369" title="All 4 branches covered.">            if (!type.isReversed() &amp;&amp; reverse)</span>
<span class="fc" id="L370">                return ReversedType.getInstance(type);</span>
        }
<span class="fc" id="L372">        return type;</span>
    }

    @Override
    Set&lt;String&gt; clientWarnings(KeyspacesDiff diff)
    {
<span class="fc" id="L378">        return ImmutableSet.of(View.USAGE_WARNING);</span>
    }

    @Override
    public AuditLogContext getAuditLogContext()
    {
<span class="fc" id="L384">        return new AuditLogContext(AuditLogEntryType.CREATE_VIEW, keyspaceName, viewName);</span>
    }

    public String toString()
    {
<span class="nc" id="L389">        return String.format(&quot;%s (%s, %s)&quot;, getClass().getSimpleName(), keyspaceName, viewName);</span>
    }

    public final static class Raw extends CQLStatement.Raw
    {
        private final QualifiedName tableName;
        private final QualifiedName viewName;
        private final boolean ifNotExists;

        private final List&lt;RawSelector&gt; rawColumns;
<span class="fc" id="L399">        private final List&lt;ColumnIdentifier&gt; clusteringColumns = new ArrayList&lt;&gt;();</span>
        private List&lt;ColumnIdentifier&gt; partitionKeyColumns;

        private final WhereClause whereClause;

<span class="fc" id="L404">        private final LinkedHashMap&lt;ColumnIdentifier, Boolean&gt; clusteringOrder = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L405">        public final TableAttributes attrs = new TableAttributes();</span>

        public Raw(QualifiedName tableName, QualifiedName viewName, List&lt;RawSelector&gt; rawColumns, WhereClause whereClause, boolean ifNotExists)
<span class="fc" id="L408">        {</span>
<span class="fc" id="L409">            this.tableName = tableName;</span>
<span class="fc" id="L410">            this.viewName = viewName;</span>
<span class="fc" id="L411">            this.rawColumns = rawColumns;</span>
<span class="fc" id="L412">            this.whereClause = whereClause;</span>
<span class="fc" id="L413">            this.ifNotExists = ifNotExists;</span>
<span class="fc" id="L414">        }</span>

        public CreateViewStatement prepare(ClientState state)
        {
<span class="fc bfc" id="L418" title="All 2 branches covered.">            String keyspaceName = viewName.hasKeyspace() ? viewName.getKeyspace() : state.getKeyspace();</span>

<span class="pc bpc" id="L420" title="1 of 4 branches missed.">            if (tableName.hasKeyspace() &amp;&amp; !keyspaceName.equals(tableName.getKeyspace()))</span>
<span class="nc" id="L421">                throw ire(&quot;Cannot create a materialized view on a table in a different keyspace&quot;);</span>

<span class="fc bfc" id="L423" title="All 2 branches covered.">            if (!bindVariables.isEmpty())</span>
<span class="fc" id="L424">                throw ire(&quot;Bind variables are not allowed in CREATE MATERIALIZED VIEW statements&quot;);</span>

<span class="pc bpc" id="L426" title="1 of 2 branches missed.">            if (null == partitionKeyColumns)</span>
<span class="nc" id="L427">                throw ire(&quot;No PRIMARY KEY specifed for view '%s' (exactly one required)&quot;, viewName);</span>

<span class="fc" id="L429">            return new CreateViewStatement(keyspaceName,</span>
<span class="fc" id="L430">                                           tableName.getName(),</span>
<span class="fc" id="L431">                                           viewName.getName(),</span>

                                           rawColumns,
                                           partitionKeyColumns,
                                           clusteringColumns,

                                           whereClause,

                                           clusteringOrder,
                                           attrs,

                                           ifNotExists);
        }

        public void setPartitionKeyColumns(List&lt;ColumnIdentifier&gt; columns)
        {
<span class="fc" id="L447">            partitionKeyColumns = columns;</span>
<span class="fc" id="L448">        }</span>

        public void markClusteringColumn(ColumnIdentifier column)
        {
<span class="fc" id="L452">            clusteringColumns.add(column);</span>
<span class="fc" id="L453">        }</span>

        public void extendClusteringOrder(ColumnIdentifier column, boolean ascending)
        {
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">            if (null != clusteringOrder.put(column, ascending))</span>
<span class="nc" id="L458">                throw ire(&quot;Duplicate column '%s' in CLUSTERING ORDER BY clause for view '%s'&quot;, column, viewName);</span>
<span class="fc" id="L459">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>