<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Expression.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.index.sasi.plan</a> &gt; <span class="el_source">Expression.java</span></div><h1>Expression.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.index.sasi.plan;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.cql3.Operator;
import org.apache.cassandra.index.sasi.analyzer.AbstractAnalyzer;
import org.apache.cassandra.index.sasi.conf.ColumnIndex;
import org.apache.cassandra.index.sasi.disk.OnDiskIndex;
import org.apache.cassandra.index.sasi.utils.TypeUtil;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.marshal.UTF8Type;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.FBUtilities;

import org.apache.commons.lang3.builder.HashCodeBuilder;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Iterators;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Expression
{
<span class="fc" id="L46">    private static final Logger logger = LoggerFactory.getLogger(Expression.class);</span>

<span class="fc" id="L48">    public enum Op</span>
    {
<span class="fc" id="L50">        EQ, MATCH, PREFIX, SUFFIX, CONTAINS, NOT_EQ, RANGE, IN;</span>

        public static Op valueOf(Operator operator)
        {
<span class="pc bpc" id="L54" title="1 of 9 branches missed.">            switch (operator)</span>
            {
                case EQ:
<span class="fc" id="L57">                    return EQ;</span>

                case IN:
<span class="fc" id="L60">                    return IN;</span>

                case NEQ:
<span class="fc" id="L63">                    return NOT_EQ;</span>

                case LT:
                case GT:
                case LTE:
                case GTE:
<span class="fc" id="L69">                    return RANGE;</span>

                case LIKE_PREFIX:
<span class="fc" id="L72">                    return PREFIX;</span>

                case LIKE_SUFFIX:
<span class="fc" id="L75">                    return SUFFIX;</span>

                case LIKE_CONTAINS:
<span class="fc" id="L78">                    return CONTAINS;</span>

                case LIKE_MATCHES:
<span class="fc" id="L81">                    return MATCH;</span>

                default:
<span class="nc" id="L84">                    throw new IllegalArgumentException(&quot;unknown operator: &quot; + operator);</span>
            }
        }
    }

    private final QueryController controller;

    public final AbstractAnalyzer analyzer;

    public final ColumnIndex index;
    public final AbstractType&lt;?&gt; validator;
    public final boolean isLiteral;

    @VisibleForTesting
    protected Op operation;

    public Bound lower, upper;
<span class="fc" id="L101">    public List&lt;ByteBuffer&gt; exclusions = new ArrayList&lt;&gt;();</span>

    public Expression(Expression other)
    {
<span class="fc" id="L105">        this(other.controller, other.index);</span>
<span class="fc" id="L106">        operation = other.operation;</span>
<span class="fc" id="L107">    }</span>

    public Expression(QueryController controller, ColumnIndex columnIndex)
<span class="fc" id="L110">    {</span>
<span class="fc" id="L111">        this.controller = controller;</span>
<span class="fc" id="L112">        this.index = columnIndex;</span>
<span class="fc" id="L113">        this.analyzer = columnIndex.getAnalyzer();</span>
<span class="fc" id="L114">        this.validator = columnIndex.getValidator();</span>
<span class="fc" id="L115">        this.isLiteral = columnIndex.isLiteral();</span>
<span class="fc" id="L116">    }</span>

    @VisibleForTesting
    public Expression(String name, AbstractType&lt;?&gt; validator)
    {
<span class="fc" id="L121">        this(null, new ColumnIndex(UTF8Type.instance, ColumnMetadata.regularColumn(&quot;sasi&quot;, &quot;internal&quot;, name, validator), null));</span>
<span class="fc" id="L122">    }</span>

    public Expression setLower(Bound newLower)
    {
<span class="fc bfc" id="L126" title="All 2 branches covered.">        lower = newLower == null ? null : new Bound(newLower.value, newLower.inclusive);</span>
<span class="fc" id="L127">        return this;</span>
    }

    public Expression setUpper(Bound newUpper)
    {
<span class="fc bfc" id="L132" title="All 2 branches covered.">        upper = newUpper == null ? null : new Bound(newUpper.value, newUpper.inclusive);</span>
<span class="fc" id="L133">        return this;</span>
    }

    public Expression setOp(Op op)
    {
<span class="fc" id="L138">        this.operation = op;</span>
<span class="fc" id="L139">        return this;</span>
    }

    public Expression add(Operator op, ByteBuffer value)
    {
<span class="fc" id="L144">        boolean lowerInclusive = false, upperInclusive = false;</span>
<span class="pc bpc" id="L145" title="1 of 7 branches missed.">        switch (op)</span>
        {
            case LIKE_PREFIX:
            case LIKE_SUFFIX:
            case LIKE_CONTAINS:
            case LIKE_MATCHES:
            case EQ:
<span class="fc" id="L152">                lower = new Bound(value, true);</span>
<span class="fc" id="L153">                upper = lower;</span>
<span class="fc" id="L154">                operation = Op.valueOf(op);</span>
<span class="fc" id="L155">                break;</span>

            case NEQ:
                // index expressions are priority sorted
                // and NOT_EQ is the lowest priority, which means that operation type
                // is always going to be set before reaching it in case of RANGE or EQ.
<span class="fc bfc" id="L161" title="All 2 branches covered.">                if (operation == null)</span>
                {
<span class="fc" id="L163">                    operation = Op.NOT_EQ;</span>
<span class="fc" id="L164">                    lower = new Bound(value, true);</span>
<span class="fc" id="L165">                    upper = lower;</span>
                }
                else
<span class="fc" id="L168">                    exclusions.add(value);</span>
<span class="fc" id="L169">                break;</span>

            case LTE:
<span class="fc bfc" id="L172" title="All 2 branches covered.">                if (index.getDefinition().isReversedType())</span>
<span class="fc" id="L173">                    lowerInclusive = true;</span>
                else
<span class="fc" id="L175">                    upperInclusive = true;</span>
            case LT:
<span class="fc" id="L177">                operation = Op.RANGE;</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">                if (index.getDefinition().isReversedType())</span>
<span class="fc" id="L179">                    lower = new Bound(value, lowerInclusive);</span>
                else
<span class="fc" id="L181">                    upper = new Bound(value, upperInclusive);</span>
<span class="fc" id="L182">                break;</span>

            case GTE:
<span class="fc bfc" id="L185" title="All 2 branches covered.">                if (index.getDefinition().isReversedType())</span>
<span class="fc" id="L186">                    upperInclusive = true;</span>
                else
<span class="fc" id="L188">                    lowerInclusive = true;</span>
            case GT:
<span class="fc" id="L190">                operation = Op.RANGE;</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">                if (index.getDefinition().isReversedType())</span>
<span class="fc" id="L192">                    upper = new Bound(value, upperInclusive);</span>
                else
<span class="fc" id="L194">                    lower = new Bound(value, lowerInclusive);</span>

                break;
        }

<span class="fc" id="L199">        return this;</span>
    }

    public Expression addExclusion(ByteBuffer value)
    {
<span class="fc" id="L204">        exclusions.add(value);</span>
<span class="fc" id="L205">        return this;</span>
    }

    public boolean isSatisfiedBy(ByteBuffer value)
    {
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">        if (!TypeUtil.isValid(value, validator))</span>
        {
<span class="nc" id="L212">            int size = value.remaining();</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">            if ((value = TypeUtil.tryUpcast(value, validator)) == null)</span>
            {
<span class="nc" id="L215">                logger.error(&quot;Can't cast value for {} to size accepted by {}, value size is {}.&quot;,</span>
<span class="nc" id="L216">                             index.getColumnName(),</span>
                             validator,
<span class="nc" id="L218">                             FBUtilities.prettyPrintMemory(size));</span>
<span class="nc" id="L219">                return false;</span>
            }
        }

<span class="fc bfc" id="L223" title="All 2 branches covered.">        if (lower != null)</span>
        {
            // suffix check
<span class="fc bfc" id="L226" title="All 2 branches covered.">            if (isLiteral)</span>
            {
<span class="fc bfc" id="L228" title="All 2 branches covered.">                if (!validateStringValue(value, lower.value))</span>
<span class="fc" id="L229">                    return false;</span>
            }
            else
            {
                // range or (not-)equals - (mainly) for numeric values
<span class="fc" id="L234">                int cmp = validator.compare(lower.value, value);</span>

                // in case of (NOT_)EQ lower == upper
<span class="fc bfc" id="L237" title="All 4 branches covered.">                if (operation == Op.EQ || operation == Op.NOT_EQ)</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">                    return cmp == 0;</span>

<span class="fc bfc" id="L240" title="All 6 branches covered.">                if (cmp &gt; 0 || (cmp == 0 &amp;&amp; !lower.inclusive))</span>
<span class="fc" id="L241">                    return false;</span>
            }
        }

<span class="fc bfc" id="L245" title="All 4 branches covered.">        if (upper != null &amp;&amp; lower != upper)</span>
        {
            // string (prefix or suffix) check
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">            if (isLiteral)</span>
            {
<span class="nc bnc" id="L250" title="All 2 branches missed.">                if (!validateStringValue(value, upper.value))</span>
<span class="nc" id="L251">                    return false;</span>
            }
            else
            {
                // range - mainly for numeric values
<span class="fc" id="L256">                int cmp = validator.compare(upper.value, value);</span>
<span class="fc bfc" id="L257" title="All 6 branches covered.">                if (cmp &lt; 0 || (cmp == 0 &amp;&amp; !upper.inclusive))</span>
<span class="fc" id="L258">                    return false;</span>
            }
        }

        // as a last step let's check exclusions for the given field,
        // this covers EQ/RANGE with exclusions.
<span class="fc bfc" id="L264" title="All 2 branches covered.">        for (ByteBuffer term : exclusions)</span>
        {
<span class="fc bfc" id="L266" title="All 4 branches covered.">            if (isLiteral &amp;&amp; validateStringValue(value, term))</span>
<span class="fc" id="L267">                return false;</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">            else if (validator.compare(term, value) == 0)</span>
<span class="fc" id="L269">                return false;</span>
<span class="fc" id="L270">        }</span>

<span class="fc" id="L272">        return true;</span>
    }

    private boolean validateStringValue(ByteBuffer columnValue, ByteBuffer requestedValue)
    {
<span class="fc" id="L277">        analyzer.reset(columnValue.duplicate());</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">        while (analyzer.hasNext())</span>
        {
<span class="fc" id="L280">            ByteBuffer term = analyzer.next();</span>

<span class="fc" id="L282">            boolean isMatch = false;</span>
<span class="pc bpc" id="L283" title="1 of 5 branches missed.">            switch (operation)</span>
            {
                case EQ:
                case MATCH:
                // Operation.isSatisfiedBy handles conclusion on !=,
                // here we just need to make sure that term matched it
                case NOT_EQ:
<span class="fc bfc" id="L290" title="All 2 branches covered.">                    isMatch = validator.compare(term, requestedValue) == 0;</span>
<span class="fc" id="L291">                    break;</span>

                case PREFIX:
<span class="fc" id="L294">                    isMatch = ByteBufferUtil.startsWith(term, requestedValue);</span>
<span class="fc" id="L295">                    break;</span>

                case SUFFIX:
<span class="fc" id="L298">                    isMatch = ByteBufferUtil.endsWith(term, requestedValue);</span>
<span class="fc" id="L299">                    break;</span>

                case CONTAINS:
<span class="fc" id="L302">                    isMatch = ByteBufferUtil.contains(term, requestedValue);</span>
                    break;
            }

<span class="fc bfc" id="L306" title="All 2 branches covered.">            if (isMatch)</span>
<span class="fc" id="L307">                return true;</span>
<span class="fc" id="L308">        }</span>

<span class="fc" id="L310">        return false;</span>
    }

    public Op getOp()
    {
<span class="fc" id="L315">        return operation;</span>
    }

    public void checkpoint()
    {
<span class="fc bfc" id="L320" title="All 2 branches covered.">        if (controller == null)</span>
<span class="fc" id="L321">            return;</span>

<span class="fc" id="L323">        controller.checkpoint();</span>
<span class="fc" id="L324">    }</span>

    public boolean hasLower()
    {
<span class="fc bfc" id="L328" title="All 2 branches covered.">        return lower != null;</span>
    }

    public boolean hasUpper()
    {
<span class="fc bfc" id="L333" title="All 2 branches covered.">        return upper != null;</span>
    }

    public boolean isLowerSatisfiedBy(OnDiskIndex.DataTerm term)
    {
<span class="fc bfc" id="L338" title="All 2 branches covered.">        if (!hasLower())</span>
<span class="fc" id="L339">            return true;</span>

<span class="fc bfc" id="L341" title="All 4 branches covered.">        int cmp = term.compareTo(validator, lower.value, operation == Op.RANGE &amp;&amp; !isLiteral);</span>
<span class="pc bpc" id="L342" title="1 of 6 branches missed.">        return cmp &gt; 0 || cmp == 0 &amp;&amp; lower.inclusive;</span>
    }

    public boolean isUpperSatisfiedBy(OnDiskIndex.DataTerm term)
    {
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">        if (!hasUpper())</span>
<span class="nc" id="L348">            return true;</span>

<span class="fc bfc" id="L350" title="All 4 branches covered.">        int cmp = term.compareTo(validator, upper.value, operation == Op.RANGE &amp;&amp; !isLiteral);</span>
<span class="fc bfc" id="L351" title="All 6 branches covered.">        return cmp &lt; 0 || cmp == 0 &amp;&amp; upper.inclusive;</span>
    }

    public boolean isIndexed()
    {
<span class="fc" id="L356">        return index.isIndexed();</span>
    }

    public String toString()
    {
<span class="nc" id="L361">        return String.format(&quot;Expression{name: %s, op: %s, lower: (%s, %s), upper: (%s, %s), exclusions: %s}&quot;,</span>
<span class="nc" id="L362">                             index.getColumnName(),</span>
                             operation,
<span class="nc bnc" id="L364" title="All 6 branches missed.">                             lower == null ? &quot;null&quot; : validator.getString(lower.value),</span>
<span class="nc" id="L365">                             lower != null &amp;&amp; lower.inclusive,</span>
<span class="nc bnc" id="L366" title="All 6 branches missed.">                             upper == null ? &quot;null&quot; : validator.getString(upper.value),</span>
<span class="nc" id="L367">                             upper != null &amp;&amp; upper.inclusive,</span>
<span class="nc" id="L368">                             Iterators.toString(Iterators.transform(exclusions.iterator(), validator::getString)));</span>
    }

    public int hashCode()
    {
<span class="fc" id="L373">        return new HashCodeBuilder().append(index.getColumnName())</span>
<span class="fc" id="L374">                                    .append(operation)</span>
<span class="fc" id="L375">                                    .append(validator)</span>
<span class="fc" id="L376">                                    .append(lower).append(upper)</span>
<span class="fc" id="L377">                                    .append(exclusions).build();</span>
    }

    public boolean equals(Object other)
    {
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">        if (!(other instanceof Expression))</span>
<span class="nc" id="L383">            return false;</span>

<span class="fc bfc" id="L385" title="All 2 branches covered.">        if (this == other)</span>
<span class="fc" id="L386">            return true;</span>

<span class="fc" id="L388">        Expression o = (Expression) other;</span>

<span class="fc bfc" id="L390" title="All 2 branches covered.">        return Objects.equals(index.getColumnName(), o.index.getColumnName())</span>
<span class="pc bpc" id="L391" title="2 of 4 branches missed.">                &amp;&amp; validator.equals(o.validator)</span>
                &amp;&amp; operation == o.operation
<span class="fc bfc" id="L393" title="All 2 branches covered.">                &amp;&amp; Objects.equals(lower, o.lower)</span>
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">                &amp;&amp; Objects.equals(upper, o.upper)</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">                &amp;&amp; exclusions.equals(o.exclusions);</span>
    }

    public static class Bound
    {
        public final ByteBuffer value;
        public final boolean inclusive;

        public Bound(ByteBuffer value, boolean inclusive)
<span class="fc" id="L404">        {</span>
<span class="fc" id="L405">            this.value = value;</span>
<span class="fc" id="L406">            this.inclusive = inclusive;</span>
<span class="fc" id="L407">        }</span>

        public boolean equals(Object other)
        {
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">            if (!(other instanceof Bound))</span>
<span class="nc" id="L412">                return false;</span>

<span class="fc" id="L414">            Bound o = (Bound) other;</span>
<span class="pc bpc" id="L415" title="1 of 4 branches missed.">            return value.equals(o.value) &amp;&amp; inclusive == o.inclusive;</span>
        }

        public int hashCode()
        {
<span class="fc" id="L420">            HashCodeBuilder builder = new HashCodeBuilder();</span>
<span class="fc" id="L421">            builder.append(value);</span>
<span class="fc" id="L422">            builder.append(inclusive);</span>
<span class="fc" id="L423">            return builder.toHashCode();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>