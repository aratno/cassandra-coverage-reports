<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClusteringPrefix.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db</a> &gt; <span class="el_source">ClusteringPrefix.java</span></div><h1>ClusteringPrefix.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.*;
import java.util.function.ToIntFunction;

import org.apache.cassandra.cache.IMeasurableMemory;
import org.apache.cassandra.config.*;
import org.apache.cassandra.db.marshal.ByteArrayAccessor;
import org.apache.cassandra.db.marshal.ByteBufferAccessor;
import org.apache.cassandra.db.marshal.CompositeType;
import org.apache.cassandra.db.marshal.ValueAccessor;
import org.apache.cassandra.db.rows.*;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.utils.ByteArrayUtil;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.bytecomparable.ByteComparable.Version;
import org.apache.cassandra.utils.bytecomparable.ByteSource;

/**
 * A clustering prefix is the unit of what a {@link ClusteringComparator} can compare.
 * &lt;p&gt;
 * It holds values for the clustering columns of a table (potentially only a prefix of all of them) and has
 * a &quot;kind&quot; that allows us to implement slices with inclusive and exclusive bounds.
 * &lt;p&gt;
 * In practice, {@code ClusteringPrefix} is just the common parts to its 3 main subtype: {@link Clustering} and
 * {@link ClusteringBound}/{@link ClusteringBoundary}, where:
 *   1) {@code Clustering} represents the clustering values for a row, i.e. the values for it's clustering columns.
 *   2) {@code ClusteringBound} represents a bound (start or end) of a slice (of rows) or a range tombstone.
 *   3) {@code ClusteringBoundary} represents the threshold between two adjacent range tombstones.
 * See those classes for more details.
 */
public interface ClusteringPrefix&lt;V&gt; extends IMeasurableMemory, Clusterable&lt;V&gt;
{
<span class="fc" id="L57">    public static final Serializer serializer = new Serializer();</span>

    /**
     * The kind of clustering prefix this actually is.
     *
     * The kind {@code STATIC_CLUSTERING} is only implemented by {@link Clustering#STATIC_CLUSTERING} and {@code CLUSTERING} is
     * implemented by the {@link Clustering} class. The rest is used by {@link ClusteringBound} and {@link ClusteringBoundary}.
     */
<span class="fc" id="L65">    public enum Kind</span>
    {
        // WARNING: the ordering of that enum matters because we use ordinal() in the serialization

        // @formatter:off
<span class="fc" id="L70">        EXCL_END_BOUND               ( 0, -1, v -&gt; ByteSource.LT_NEXT_COMPONENT),</span>
<span class="fc" id="L71">        INCL_START_BOUND             ( 0, -1, v -&gt; ByteSource.LT_NEXT_COMPONENT),</span>
<span class="fc" id="L72">        EXCL_END_INCL_START_BOUNDARY ( 0, -1, v -&gt; ByteSource.LT_NEXT_COMPONENT),</span>
<span class="fc bfc" id="L73" title="All 2 branches covered.">        STATIC_CLUSTERING            ( 1, -1, v -&gt; v == Version.LEGACY ? ByteSource.LT_NEXT_COMPONENT + 1</span>
<span class="fc" id="L74">                                                                       : ByteSource.EXCLUDED),</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">        CLUSTERING                   ( 2,  0, v -&gt; v == Version.LEGACY ? ByteSource.NEXT_COMPONENT</span>
<span class="fc" id="L76">                                                                       : ByteSource.TERMINATOR),</span>
<span class="fc" id="L77">        INCL_END_EXCL_START_BOUNDARY ( 3,  1, v -&gt; ByteSource.GT_NEXT_COMPONENT),</span>
<span class="fc" id="L78">        INCL_END_BOUND               ( 3,  1, v -&gt; ByteSource.GT_NEXT_COMPONENT),</span>
<span class="fc" id="L79">        EXCL_START_BOUND             ( 3,  1, v -&gt; ByteSource.GT_NEXT_COMPONENT),</span>
<span class="fc" id="L80">        SSTABLE_LOWER_BOUND          (-1, -1, v -&gt; ByteSource.LTLT_NEXT_COMPONENT),</span>
<span class="fc" id="L81">        SSTABLE_UPPER_BOUND          ( 4,  1, v -&gt; ByteSource.GTGT_NEXT_COMPONENT);</span>
        // @formatter:on

        private final int comparison;

        /**
         * Return the comparison of this kind to CLUSTERING.
         * For bounds/boundaries, this basically tells us if we sort before or after our clustering values.
         */
        public final int comparedToClustering;

        public final ToIntFunction&lt;Version&gt; asByteComparable;

        Kind(int comparison, int comparedToClustering, ToIntFunction&lt;Version&gt; asByteComparable)
<span class="fc" id="L95">        {</span>
<span class="fc" id="L96">            this.comparison = comparison;</span>
<span class="fc" id="L97">            this.comparedToClustering = comparedToClustering;</span>
<span class="fc" id="L98">            this.asByteComparable = asByteComparable;</span>
<span class="fc" id="L99">        }</span>

        /**
         * Compares the 2 provided kind.
         * &lt;p&gt;
         * Note: this should be used instead of {@link #compareTo} when comparing clustering prefixes. We do
         * not override that latter method because it is final for an enum.
         */
        public static int compare(Kind k1, Kind k2)
        {
<span class="fc" id="L109">            return Integer.compare(k1.comparison, k2.comparison);</span>
        }

        /**
         * Returns the inverse of the current kind.
         * &lt;p&gt;
         * This invert both start into end (and vice-versa) and inclusive into exclusive (and vice-versa).
         *
         * @return the invert of this kind. For instance, if this kind is an exlusive start, this return
         * an inclusive end.
         */
        public Kind invert()
        {
<span class="pc bpc" id="L122" title="3 of 7 branches missed.">            switch (this)</span>
            {
<span class="fc" id="L124">                case EXCL_START_BOUND:              return INCL_END_BOUND;</span>
<span class="fc" id="L125">                case INCL_START_BOUND:              return EXCL_END_BOUND;</span>
<span class="fc" id="L126">                case EXCL_END_BOUND:                return INCL_START_BOUND;</span>
<span class="fc" id="L127">                case INCL_END_BOUND:                return EXCL_START_BOUND;</span>
<span class="nc" id="L128">                case EXCL_END_INCL_START_BOUNDARY:  return INCL_END_EXCL_START_BOUNDARY;</span>
<span class="nc" id="L129">                case INCL_END_EXCL_START_BOUNDARY:  return EXCL_END_INCL_START_BOUNDARY;</span>
<span class="nc" id="L130">                default:                            return this;</span>
            }
        }

        public boolean isBound()
        {
<span class="fc bfc" id="L136" title="All 2 branches covered.">            switch (this)</span>
            {
                case INCL_START_BOUND:
                case INCL_END_BOUND:
                case EXCL_START_BOUND:
                case EXCL_END_BOUND:
<span class="fc" id="L142">                    return true;</span>
                default:
<span class="fc" id="L144">                    return false;</span>
            }
        }

        public boolean isBoundary()
        {
<span class="fc bfc" id="L150" title="All 2 branches covered.">            switch (this)</span>
            {
                case INCL_END_EXCL_START_BOUNDARY:
                case EXCL_END_INCL_START_BOUNDARY:
<span class="fc" id="L154">                    return true;</span>
                default:
<span class="fc" id="L156">                    return false;</span>
            }
        }

        public boolean isStart()
        {
<span class="fc bfc" id="L162" title="All 2 branches covered.">            switch (this)</span>
            {
                case INCL_START_BOUND:
                case EXCL_END_INCL_START_BOUNDARY:
                case INCL_END_EXCL_START_BOUNDARY:
                case EXCL_START_BOUND:
<span class="fc" id="L168">                    return true;</span>
                default:
<span class="fc" id="L170">                    return false;</span>
            }
        }

        public boolean isEnd()
        {
<span class="fc bfc" id="L176" title="All 2 branches covered.">            switch (this)</span>
            {
                case INCL_END_BOUND:
                case EXCL_END_INCL_START_BOUNDARY:
                case INCL_END_EXCL_START_BOUNDARY:
                case EXCL_END_BOUND:
<span class="fc" id="L182">                    return true;</span>
                default:
<span class="fc" id="L184">                    return false;</span>
            }
        }

        public boolean isOpen(boolean reversed)
        {
<span class="pc bpc" id="L190" title="1 of 8 branches missed.">            return isBoundary() || (reversed ? isEnd() : isStart());</span>
        }

        public boolean isClose(boolean reversed)
        {
<span class="pc bpc" id="L195" title="1 of 8 branches missed.">            return isBoundary() || (reversed ? isStart() : isEnd());</span>
        }

        public Kind closeBoundOfBoundary(boolean reversed)
        {
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">            assert isBoundary();</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">            return reversed</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">                 ? (this == INCL_END_EXCL_START_BOUNDARY ? EXCL_START_BOUND : INCL_START_BOUND)</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">                 : (this == INCL_END_EXCL_START_BOUNDARY ? INCL_END_BOUND : EXCL_END_BOUND);</span>
        }

        public Kind openBoundOfBoundary(boolean reversed)
        {
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">            assert isBoundary();</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">            return reversed</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">                 ? (this == INCL_END_EXCL_START_BOUNDARY ? INCL_END_BOUND : EXCL_END_BOUND)</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">                 : (this == INCL_END_EXCL_START_BOUNDARY ? EXCL_START_BOUND : INCL_START_BOUND);</span>
        }

        /*
         * Returns a terminator value for this clustering type that is suitable for byte comparison.
         * Inclusive starts / exclusive ends need a lower value than ByteSource.NEXT_COMPONENT and the clustering byte,
         * exclusive starts / inclusive ends -- a higher.
         */
        public int asByteComparableValue(Version version)
        {
<span class="fc" id="L221">            return asByteComparable.applyAsInt(version);</span>
        }
    }

    default boolean isBottom()
    {
<span class="fc bfc" id="L227" title="All 4 branches covered.">        return kind() == Kind.INCL_START_BOUND &amp;&amp; size() == 0;</span>
    }

    default boolean isTop()
    {
<span class="fc bfc" id="L232" title="All 4 branches covered.">        return kind() == Kind.INCL_END_BOUND &amp;&amp; size() == 0;</span>
    }

    public Kind kind();

    /**
     * The number of values in this prefix.
     *
     * There can't be more values that the this is a prefix of has of clustering columns.
     *
     * @return the number of values in this prefix.
     */
    public int size();

    default boolean isEmpty()
    {
<span class="fc bfc" id="L248" title="All 2 branches covered.">        return size() == 0;</span>
    }

    /**
     * Retrieves the ith value of this prefix.
     *
     * @param i the index of the value to retrieve. Must be such that {@code 0 &lt;= i &lt; size()}.
     *
     * @return the ith value of this prefix. Note that a value can be {@code null}.
     */
    public V get(int i);

    public ValueAccessor&lt;V&gt; accessor();

    default ByteBuffer bufferAt(int i)
    {
<span class="fc" id="L264">        return accessor().toBuffer(get(i));</span>
    }

    default String stringAt(int i, ClusteringComparator comparator)
    {
<span class="fc" id="L269">        return comparator.subtype(i).getString(get(i), accessor());</span>
    }

    default void validate()
    {
<span class="fc" id="L274">        ValueAccessor&lt;V&gt; accessor = accessor();</span>
<span class="fc" id="L275">        int sum = 0;</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">        for (V v : getRawValues())</span>
        {
<span class="fc bfc" id="L278" title="All 4 branches covered.">            if (v != null &amp;&amp; accessor.size(v) &gt; FBUtilities.MAX_UNSIGNED_SHORT)</span>
<span class="fc" id="L279">                throw new InvalidRequestException(String.format(&quot;Key length of %d is longer than maximum of %d&quot;,</span>
<span class="fc" id="L280">                                                                dataSize(),</span>
<span class="fc" id="L281">                                                                FBUtilities.MAX_UNSIGNED_SHORT));</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">            sum += v == null ? 0 : accessor.size(v);</span>
        }
<span class="fc bfc" id="L284" title="All 2 branches covered.">        if (sum &gt; FBUtilities.MAX_UNSIGNED_SHORT)</span>
<span class="fc" id="L285">            throw new InvalidRequestException(String.format(&quot;Key length of %d is longer than maximum of %d&quot;,</span>
<span class="fc" id="L286">                                                            sum,</span>
<span class="fc" id="L287">                                                            FBUtilities.MAX_UNSIGNED_SHORT));</span>
<span class="fc" id="L288">    }</span>

    default void validate(int i, ClusteringComparator comparator)
    {
<span class="nc" id="L292">        comparator.subtype(i).validate(get(i), accessor());</span>
<span class="nc" id="L293">    }</span>

    /**
     * Adds the data of this clustering prefix to the provided Digest instance.
     *
     * @param digest the Digest instance to which to add this prefix.
     */
    default void digest(Digest digest)
    {
<span class="fc bfc" id="L302" title="All 2 branches covered.">        for (int i = 0; i &lt; size(); i++)</span>
        {
<span class="fc" id="L304">            V value = get(i);</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">            if (value != null)</span>
<span class="fc" id="L306">                digest.update(value, accessor());</span>
        }
<span class="fc" id="L308">        digest.updateWithByte(kind().ordinal());</span>
<span class="fc" id="L309">    }</span>

    /**
     * The size of the data hold by this prefix.
     *
     * @return the size of the data hold by this prefix (this is not the size of the object in memory, just
     * the size of the data it stores).
     */
    default int dataSize()
    {
<span class="fc" id="L319">        int size = 0;</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">        for (int i = 0; i &lt; size(); i++)</span>
        {
<span class="fc" id="L322">            V v = get(i);</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">            size += v == null ? 0 : accessor().size(v);</span>
        }
<span class="fc" id="L325">        return size;</span>
    }

    /**
     * Generates a proper string representation of the prefix.
     *
     * @param metadata the metadata for the table the clustering prefix is of.
     * @return a human-readable string representation fo this prefix.
     */
    public String toString(TableMetadata metadata);

    /**
     * Returns this prefix as a start bound.
     * If this prefix is a bound, just returns it asserting that it is a start bound.
     * If this prefix is a clustering, returns an included start bound.
     * If this prefix is a boundary, returns an open bound of it
     */
    ClusteringBound&lt;V&gt; asStartBound();

    /**
     * Returns this prefix as an end bound.
     * If this prefix is a bound, just returns it asserting that it is an end bound.
     * If this prefix is a clustering, returns an included end bound.
     * In this prefix is a boundary, returns a close bound of it.
     */
    ClusteringBound&lt;V&gt; asEndBound();

    /*
     * TODO: we should stop using Clustering for partition keys. Maybe we can add
     * a few methods to DecoratedKey so we don't have to (note that while using a Clustering
     * allows to use buildBound(), it's actually used for partition keys only when every restriction
     * is an equal, so we could easily create a specific method for keys for that.
     */
    default ByteBuffer serializeAsPartitionKey()
    {
<span class="fc bfc" id="L360" title="All 2 branches covered.">        if (size() == 1)</span>
<span class="fc" id="L361">            return accessor().toBuffer(get(0));</span>

<span class="fc" id="L363">        ByteBuffer[] values = new ByteBuffer[size()];</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">        for (int i = 0; i &lt; size(); i++)</span>
<span class="fc" id="L365">            values[i] = accessor().toBuffer(get(i));</span>
<span class="fc" id="L366">        return CompositeType.build(ByteBufferAccessor.instance, values);</span>
    }

    /**
     * Produce a human-readable representation of the clustering given the list of types.
     * Easier to access than metadata for debugging.
     */
    public default String clusteringString(List&lt;AbstractType&lt;?&gt;&gt; types)
    {
<span class="fc" id="L375">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L376">        sb.append(kind()).append('(');</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">        for (int i = 0; i &lt; size(); i++)</span>
        {
<span class="fc bfc" id="L379" title="All 2 branches covered.">            if (i &gt; 0)</span>
<span class="fc" id="L380">                sb.append(&quot;, &quot;);</span>
<span class="fc" id="L381">            sb.append(types.get(i).getString(get(i), accessor()));</span>
        }
<span class="fc" id="L383">        return sb.append(')').toString();</span>
    }

    /**
     * The values of this prefix as an array.
     * &lt;p&gt;
     * Please note that this may or may not require an array creation. So 1) you should *not*
     * modify the returned array and 2) it's more efficient to use {@link #size()} and
     * {@link #get} unless you actually need an array.
     *
     * @return the values for this prefix as an array.
     */
    public V[] getRawValues();

    public ByteBuffer[] getBufferArray();

    /**
     * Return the key in a form that can be retained for longer-term use. This means extracting keys stored in shared
     * memory (i.e. in memtables) to minimized on-heap versions.
     * If the object is already in minimal form, no action will be taken.
     */
    public ClusteringPrefix&lt;V&gt; retainable();

<span class="fc" id="L406">    public static class Serializer</span>
    {
        public void serialize(ClusteringPrefix&lt;?&gt; clustering, DataOutputPlus out, int version, List&lt;AbstractType&lt;?&gt;&gt; types) throws IOException
        {
            // We shouldn't serialize static clusterings
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">            assert clustering.kind() != Kind.STATIC_CLUSTERING;</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">            if (clustering.kind() == Kind.CLUSTERING)</span>
            {
<span class="fc" id="L414">                out.writeByte(clustering.kind().ordinal());</span>
<span class="fc" id="L415">                Clustering.serializer.serialize((Clustering&lt;?&gt;)clustering, out, version, types);</span>
            }
            else
            {
<span class="fc" id="L419">                ClusteringBoundOrBoundary.serializer.serialize((ClusteringBoundOrBoundary&lt;?&gt;)clustering, out, version, types);</span>
            }
<span class="fc" id="L421">        }</span>

        public void skip(DataInputPlus in, int version, List&lt;AbstractType&lt;?&gt;&gt; types) throws IOException
        {
<span class="nc" id="L425">            Kind kind = Kind.values()[in.readByte()];</span>
            // We shouldn't serialize static clusterings
<span class="nc bnc" id="L427" title="All 2 branches missed.">            assert kind != Kind.STATIC_CLUSTERING;</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">            if (kind == Kind.CLUSTERING)</span>
<span class="nc" id="L429">                Clustering.serializer.skip(in, version, types);</span>
            else
<span class="nc" id="L431">                ClusteringBoundOrBoundary.serializer.skipValues(in, kind, version, types);</span>
<span class="nc" id="L432">        }</span>

        public ClusteringPrefix&lt;byte[]&gt; deserialize(DataInputPlus in, int version, List&lt;AbstractType&lt;?&gt;&gt; types) throws IOException
        {
<span class="fc" id="L436">            Kind kind = Kind.values()[in.readByte()];</span>
            // We shouldn't serialize static clusterings
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">            assert kind != Kind.STATIC_CLUSTERING;</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">            if (kind == Kind.CLUSTERING)</span>
<span class="fc" id="L440">                return Clustering.serializer.deserialize(in, version, types);</span>
            else
<span class="fc" id="L442">                return ClusteringBoundOrBoundary.serializer.deserializeValues(in, kind, version, types);</span>
        }

        public long serializedSize(ClusteringPrefix&lt;?&gt; clustering, int version, List&lt;AbstractType&lt;?&gt;&gt; types)
        {
            // We shouldn't serialize static clusterings
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">            assert clustering.kind() != Kind.STATIC_CLUSTERING;</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">            if (clustering.kind() == Kind.CLUSTERING)</span>
<span class="fc" id="L450">                return 1 + Clustering.serializer.serializedSize((Clustering&lt;?&gt;)clustering, version, types);</span>
            else
<span class="fc" id="L452">                return ClusteringBoundOrBoundary.serializer.serializedSize((ClusteringBoundOrBoundary&lt;?&gt;)clustering, version, types);</span>
        }

        &lt;V&gt; void serializeValuesWithoutSize(ClusteringPrefix&lt;V&gt; clustering, DataOutputPlus out, int version, List&lt;AbstractType&lt;?&gt;&gt; types) throws IOException
        {
<span class="fc" id="L457">            int offset = 0;</span>
<span class="fc" id="L458">            int clusteringSize = clustering.size();</span>
<span class="fc" id="L459">            ValueAccessor&lt;V&gt; accessor = clustering.accessor();</span>
            // serialize in batches of 32, to avoid garbage when deserializing headers
<span class="fc bfc" id="L461" title="All 2 branches covered.">            while (offset &lt; clusteringSize)</span>
            {
                // we micro-batch the headers, so that we can incur fewer method calls,
                // and generate no garbage on deserialization;
                // we piggyback on vint encoding so that, typically, only 1 byte is used per 32 clustering values,
                // i.e. more than we ever expect to see
<span class="fc" id="L467">                int limit = Math.min(clusteringSize, offset + 32);</span>
<span class="fc" id="L468">                out.writeUnsignedVInt(makeHeader(clustering, offset, limit));</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">                while (offset &lt; limit)</span>
                {
<span class="fc" id="L471">                    V v = clustering.get(offset);</span>
<span class="fc bfc" id="L472" title="All 4 branches covered.">                    if (v != null &amp;&amp; !accessor.isEmpty(v))</span>
<span class="fc" id="L473">                        types.get(offset).writeValue(v, accessor, out);</span>
<span class="fc" id="L474">                    offset++;</span>
<span class="fc" id="L475">                }</span>
<span class="fc" id="L476">            }</span>
<span class="fc" id="L477">        }</span>

        &lt;V&gt; long valuesWithoutSizeSerializedSize(ClusteringPrefix&lt;V&gt; clustering, int version, List&lt;AbstractType&lt;?&gt;&gt; types)
        {
<span class="fc" id="L481">            long result = 0;</span>
<span class="fc" id="L482">            int offset = 0;</span>
<span class="fc" id="L483">            int clusteringSize = clustering.size();</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">            while (offset &lt; clusteringSize)</span>
            {
<span class="fc" id="L486">                int limit = Math.min(clusteringSize, offset + 32);</span>
<span class="fc" id="L487">                result += TypeSizes.sizeofUnsignedVInt(makeHeader(clustering, offset, limit));</span>
<span class="fc" id="L488">                offset = limit;</span>
<span class="fc" id="L489">            }</span>
<span class="fc" id="L490">            ValueAccessor&lt;V&gt; accessor = clustering.accessor();</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">            for (int i = 0; i &lt; clusteringSize; i++)</span>
            {
<span class="fc" id="L493">                V v = clustering.get(i);</span>
<span class="fc bfc" id="L494" title="All 4 branches covered.">                if (v == null || accessor.isEmpty(v))</span>
<span class="fc" id="L495">                    continue; // handled in the header</span>

<span class="fc" id="L497">                result += types.get(i).writtenLength(v, accessor);</span>
            }
<span class="fc" id="L499">            return result;</span>
        }

        byte[][] deserializeValuesWithoutSize(DataInputPlus in, int size, int version, List&lt;AbstractType&lt;?&gt;&gt; types) throws IOException
        {
            // Callers of this method should handle the case where size = 0 (in all case we want to return a special value anyway).
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">            assert size &gt; 0;</span>
<span class="fc" id="L506">            byte[][] values = new byte[size][];</span>
<span class="fc" id="L507">            int offset = 0;</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">            while (offset &lt; size)</span>
            {
<span class="fc" id="L510">                long header = in.readUnsignedVInt();</span>
<span class="fc" id="L511">                int limit = Math.min(size, offset + 32);</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">                while (offset &lt; limit)</span>
                {
<span class="fc bfc" id="L514" title="All 2 branches covered.">                    values[offset] = isNull(header, offset)</span>
<span class="fc" id="L515">                                     ? null</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">                                     : (isEmpty(header, offset) ? ByteArrayUtil.EMPTY_BYTE_ARRAY</span>
<span class="fc" id="L517">                                                                : types.get(offset).readArray(in, DatabaseDescriptor.getMaxValueSize()));</span>
<span class="fc" id="L518">                    offset++;</span>
                }
<span class="fc" id="L520">            }</span>
<span class="fc" id="L521">            return values;</span>
        }

        void skipValuesWithoutSize(DataInputPlus in, int size, int version, List&lt;AbstractType&lt;?&gt;&gt; types) throws IOException
        {
            // Callers of this method should handle the case where size = 0 (in all case we want to return a special value anyway).
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">            assert size &gt; 0;</span>
<span class="fc" id="L528">            int offset = 0;</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">            while (offset &lt; size)</span>
            {
<span class="fc" id="L531">                long header = in.readUnsignedVInt();</span>
<span class="fc" id="L532">                int limit = Math.min(size, offset + 32);</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">                while (offset &lt; limit)</span>
                {
<span class="pc bpc" id="L535" title="2 of 4 branches missed.">                    if (!isNull(header, offset) &amp;&amp; !isEmpty(header, offset))</span>
<span class="fc" id="L536">                         types.get(offset).skipValue(in);</span>
<span class="fc" id="L537">                    offset++;</span>
                }
<span class="fc" id="L539">            }</span>
<span class="fc" id="L540">        }</span>

        /**
         * Whatever the type of a given clustering column is, its value can always be either empty or null. So we at least need to distinguish those
         * 2 values, and because we want to be able to store fixed width values without appending their (fixed) size first, we need a way to encode
         * empty values too. So for that, every clustering prefix includes a &quot;header&quot; that contains 2 bits per element in the prefix. For each element,
         * those 2 bits encode whether the element is null, empty, or none of those.
         */
        private static &lt;V&gt; long makeHeader(ClusteringPrefix&lt;V&gt; clustering, int offset, int limit)
        {
<span class="fc" id="L550">            long header = 0;</span>
<span class="fc" id="L551">            ValueAccessor&lt;V&gt; accessor = clustering.accessor();</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">            for (int i = offset ; i &lt; limit ; i++)</span>
            {
<span class="fc" id="L554">                V v = clustering.get(i);</span>
                // no need to do modulo arithmetic for i, since the left-shift execute on the modulus of RH operand by definition
<span class="fc bfc" id="L556" title="All 2 branches covered.">                if (v == null)</span>
<span class="fc" id="L557">                    header |= (1L &lt;&lt; (i * 2) + 1);</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">                else if (accessor.isEmpty(v))</span>
<span class="fc" id="L559">                    header |= (1L &lt;&lt; (i * 2));</span>
            }
<span class="fc" id="L561">            return header;</span>
        }

        // no need to do modulo arithmetic for i, since the left-shift execute on the modulus of RH operand by definition
        private static boolean isNull(long header, int i)
        {
<span class="fc" id="L567">            long mask = 1L &lt;&lt; (i * 2) + 1;</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">            return (header &amp; mask) != 0;</span>
        }

        // no need to do modulo arithmetic for i, since the left-shift execute on the modulus of RH operand by definition
        private static boolean isEmpty(long header, int i)
        {
<span class="fc" id="L574">            long mask = 1L &lt;&lt; (i * 2);</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">            return (header &amp; mask) != 0;</span>
        }
    }

    /**
     * Helper class that makes the deserialization of clustering prefixes faster.
     * &lt;p&gt;
     * The main reason for this is that when we deserialize rows from sstables, there is many cases where we have
     * a bunch of rows to skip at the beginning of an index block because those rows are before the requested slice.
     * This class make sure we can answer the question &quot;is the next row on disk before the requested slice&quot; with as
     * little work as possible. It does that by providing a comparison method that deserialize only what is needed
     * to decide of the comparison.
     */
<span class="fc" id="L588">    public static class Deserializer</span>
    {
        private final ClusteringComparator comparator;
        private final DataInputPlus in;
        private final SerializationHeader serializationHeader;

        private boolean nextIsRow;
        private long nextHeader;

        private int nextSize;
        private ClusteringPrefix.Kind nextKind;
        private int deserializedSize;
        private byte[][] nextValues;
<span class="fc" id="L601">        private final ValueAccessor&lt;byte[]&gt; accessor = ByteArrayAccessor.instance;</span>

        public Deserializer(ClusteringComparator comparator, DataInputPlus in, SerializationHeader header)
<span class="fc" id="L604">        {</span>
<span class="fc" id="L605">            this.comparator = comparator;</span>
<span class="fc" id="L606">            this.in = in;</span>
<span class="fc" id="L607">            this.serializationHeader = header;</span>
<span class="fc" id="L608">        }</span>

        public void prepare(int flags, int extendedFlags) throws IOException
        {
<span class="fc bfc" id="L612" title="All 2 branches covered.">            if (UnfilteredSerializer.isStatic(extendedFlags))</span>
<span class="fc" id="L613">                throw new IOException(&quot;Corrupt flags value for clustering prefix (isStatic flag set): &quot; + flags);</span>

<span class="fc bfc" id="L615" title="All 2 branches covered.">            this.nextIsRow = UnfilteredSerializer.kind(flags) == Unfiltered.Kind.ROW;</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">            this.nextKind = nextIsRow ? Kind.CLUSTERING : ClusteringPrefix.Kind.values()[in.readByte()];</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">            this.nextSize = nextIsRow ? comparator.size() : in.readUnsignedShort();</span>
<span class="fc" id="L618">            this.deserializedSize = 0;</span>

            // The point of the deserializer is that some of the clustering prefix won't actually be used (because they are not
            // within the bounds of the query), and we want to reduce allocation for them. So we only reuse the values array
            // between elements if 1) we haven't returned the previous element (if we have, nextValues will be null) and 2)
            // nextValues is of the proper size. Note that the 2nd condition may not hold for range tombstone bounds, but all
            // rows have a fixed size clustering, so we'll still save in the common case.
<span class="fc bfc" id="L625" title="All 4 branches covered.">            if (nextValues == null || nextValues.length != nextSize)</span>
<span class="fc" id="L626">                this.nextValues = new byte[nextSize][];</span>
<span class="fc" id="L627">        }</span>

        public &lt;T&gt; int compareNextTo(ClusteringBoundOrBoundary&lt;T&gt; bound) throws IOException
        {
<span class="fc bfc" id="L631" title="All 2 branches covered.">            if (bound.isTop())</span>
<span class="fc" id="L632">                return -1;</span>

<span class="fc bfc" id="L634" title="All 2 branches covered.">            for (int i = 0; i &lt; bound.size(); i++)</span>
            {
<span class="fc bfc" id="L636" title="All 2 branches covered.">                if (!hasComponent(i))</span>
<span class="fc" id="L637">                    return nextKind.comparedToClustering;</span>

<span class="fc" id="L639">                int cmp = comparator.compareComponent(i, nextValues[i], accessor, bound.get(i), bound.accessor());</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">                if (cmp != 0)</span>
<span class="fc" id="L641">                    return cmp;</span>
            }

<span class="fc bfc" id="L644" title="All 2 branches covered.">            if (bound.size() == nextSize)</span>
<span class="fc" id="L645">                return Kind.compare(nextKind, bound.kind());</span>

            // We know that we'll have exited already if nextSize &lt; bound.size
<span class="fc" id="L648">            return -bound.kind().comparedToClustering;</span>
        }

        private boolean hasComponent(int i) throws IOException
        {
<span class="fc bfc" id="L653" title="All 2 branches covered.">            if (i &gt;= nextSize)</span>
<span class="fc" id="L654">                return false;</span>

<span class="fc bfc" id="L656" title="All 2 branches covered.">            while (deserializedSize &lt;= i)</span>
<span class="fc" id="L657">                deserializeOne();</span>

<span class="fc" id="L659">            return true;</span>
        }

        private boolean deserializeOne() throws IOException
        {
<span class="fc bfc" id="L664" title="All 2 branches covered.">            if (deserializedSize == nextSize)</span>
<span class="fc" id="L665">                return false;</span>

<span class="fc bfc" id="L667" title="All 2 branches covered.">            if ((deserializedSize % 32) == 0)</span>
<span class="fc" id="L668">                nextHeader = in.readUnsignedVInt();</span>

<span class="fc" id="L670">            int i = deserializedSize++;</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">            nextValues[i] = Serializer.isNull(nextHeader, i)</span>
<span class="fc" id="L672">                          ? null</span>
<span class="fc bfc" id="L673" title="All 2 branches covered.">                          : (Serializer.isEmpty(nextHeader, i) ? ByteArrayUtil.EMPTY_BYTE_ARRAY</span>
<span class="fc" id="L674">                                                               : serializationHeader.clusteringTypes().get(i).readArray(in, DatabaseDescriptor.getMaxValueSize()));</span>
<span class="fc" id="L675">            return true;</span>
        }

        private void deserializeAll() throws IOException
        {
<span class="fc bfc" id="L680" title="All 2 branches covered.">            while (deserializeOne())</span>
<span class="fc" id="L681">                continue;</span>
<span class="fc" id="L682">        }</span>

        public ClusteringBoundOrBoundary&lt;byte[]&gt; deserializeNextBound() throws IOException
        {
<span class="pc bpc" id="L686" title="1 of 2 branches missed.">            assert !nextIsRow;</span>
<span class="fc" id="L687">            deserializeAll();</span>
<span class="fc" id="L688">            ClusteringBoundOrBoundary&lt;byte[]&gt; bound = accessor.factory().boundOrBoundary(nextKind, nextValues);</span>
<span class="fc" id="L689">            nextValues = null;</span>
<span class="fc" id="L690">            return bound;</span>
        }

        public Clustering&lt;byte[]&gt; deserializeNextClustering() throws IOException
        {
<span class="pc bpc" id="L695" title="1 of 2 branches missed.">            assert nextIsRow;</span>
<span class="fc" id="L696">            deserializeAll();</span>
<span class="fc" id="L697">            Clustering&lt;byte[]&gt; clustering = accessor.factory().clustering(nextValues);</span>
<span class="fc" id="L698">            nextValues = null;</span>
<span class="fc" id="L699">            return clustering;</span>
        }

        public ClusteringPrefix.Kind skipNext() throws IOException
        {
<span class="fc bfc" id="L704" title="All 2 branches covered.">            for (int i = deserializedSize; i &lt; nextSize; i++)</span>
            {
<span class="pc bpc" id="L706" title="1 of 2 branches missed.">                if ((i % 32) == 0)</span>
<span class="nc" id="L707">                    nextHeader = in.readUnsignedVInt();</span>
<span class="pc bpc" id="L708" title="2 of 4 branches missed.">                if (!Serializer.isNull(nextHeader, i) &amp;&amp; !Serializer.isEmpty(nextHeader, i))</span>
<span class="fc" id="L709">                    serializationHeader.clusteringTypes().get(i).skipValue(in);</span>
            }
<span class="fc" id="L711">            deserializedSize = nextSize;</span>
<span class="fc" id="L712">            return nextKind;</span>
        }
    }

    public static &lt;V&gt; int hashCode(ClusteringPrefix&lt;V&gt; prefix)
    {
<span class="fc" id="L718">        int result = 31;</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">        for (int i = 0; i &lt; prefix.size(); i++)</span>
<span class="fc" id="L720">            result += 31 * prefix.accessor().hashCode(prefix.get(i));</span>
<span class="fc" id="L721">        return 31 * result + Objects.hashCode(prefix.kind());</span>
    }

    static &lt;V1, V2&gt; boolean equals(ClusteringPrefix&lt;V1&gt; left, ClusteringPrefix&lt;V2&gt; right)
    {
<span class="pc bpc" id="L726" title="1 of 4 branches missed.">        if (left.kind() != right.kind() || left.size() != right.size())</span>
<span class="fc" id="L727">            return false;</span>

<span class="fc bfc" id="L729" title="All 2 branches covered.">        for (int i = 0; i &lt; left.size(); i++)</span>
        {
<span class="fc" id="L731">            V1 lVal = left.get(i);</span>
<span class="fc" id="L732">            V2 rVal = right.get(i);</span>

<span class="pc bpc" id="L734" title="1 of 4 branches missed.">            if (lVal == null &amp;&amp; rVal == null)</span>
<span class="fc" id="L735">                continue;</span>

<span class="pc bpc" id="L737" title="2 of 4 branches missed.">            if (lVal == null || rVal == null)</span>
<span class="nc" id="L738">                return false;</span>

<span class="fc bfc" id="L740" title="All 2 branches covered.">            if (!ValueAccessor.equals(lVal, left.accessor(), rVal, right.accessor()))</span>
<span class="fc" id="L741">                return false;</span>
        }

<span class="fc" id="L744">        return true;</span>
    }

    public static boolean equals(ClusteringPrefix&lt;?&gt; prefix, Object o)
    {
<span class="pc bpc" id="L749" title="1 of 2 branches missed.">        if(!(o instanceof ClusteringPrefix))</span>
<span class="nc" id="L750">            return false;</span>

<span class="fc" id="L752">        return equals(prefix, (ClusteringPrefix&lt;?&gt;) o);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>