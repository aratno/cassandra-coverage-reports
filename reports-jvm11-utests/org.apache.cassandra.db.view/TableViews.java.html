<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TableViews.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.view</a> &gt; <span class="el_source">TableViews.java</span></div><h1>TableViews.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.view;

import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;

import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import com.google.common.collect.PeekingIterator;

import org.apache.cassandra.db.*;
import org.apache.cassandra.db.commitlog.CommitLogPosition;
import org.apache.cassandra.db.filter.*;
import org.apache.cassandra.db.partitions.*;
import org.apache.cassandra.db.rows.*;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.schema.Schema;
import org.apache.cassandra.schema.TableId;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.schema.TableMetadataRef;
import org.apache.cassandra.service.StorageProxy;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.btree.BTree;
import org.apache.cassandra.utils.btree.BTreeSet;

import static org.apache.cassandra.utils.Clock.Global.nanoTime;


/**
 * Groups all the views for a given table.
 */
<span class="fc" id="L51">public class TableViews extends AbstractCollection&lt;View&gt;</span>
{
    private final TableMetadataRef baseTableMetadata;

    // We need this to be thread-safe, but the number of times this is changed (when a view is created in the keyspace)
    // is massively exceeded by the number of times it's read (for every mutation on the keyspace), so a copy-on-write
    // list is the best option.
<span class="fc" id="L58">    private final List&lt;View&gt; views = new CopyOnWriteArrayList();</span>

    public TableViews(TableId id)
<span class="fc" id="L61">    {</span>
<span class="fc" id="L62">        baseTableMetadata = Schema.instance.getTableMetadataRef(id);</span>
<span class="fc" id="L63">    }</span>

    public boolean hasViews()
    {
<span class="nc bnc" id="L67" title="All 2 branches missed.">        return !views.isEmpty();</span>
    }

    public int size()
    {
<span class="fc" id="L72">        return views.size();</span>
    }

    public Iterator&lt;View&gt; iterator()
    {
<span class="fc" id="L77">        return views.iterator();</span>
    }

    public boolean contains(String viewName)
    {
<span class="fc" id="L82">        return Iterables.any(views, view -&gt; view.name.equals(viewName));</span>
    }

    public boolean add(View view)
    {
        // We should have validated that there is no existing view with this name at this point
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">        assert !contains(view.name);</span>
<span class="fc" id="L89">        return views.add(view);</span>
    }

    public Iterable&lt;ColumnFamilyStore&gt; allViewsCfs()
    {
<span class="fc" id="L94">        Keyspace keyspace = Keyspace.open(baseTableMetadata.keyspace);</span>
<span class="fc" id="L95">        return Iterables.transform(views, view -&gt; keyspace.getColumnFamilyStore(view.getDefinition().name()));</span>
    }

    public void build()
    {
<span class="fc" id="L100">        views.forEach(View::build);</span>
<span class="fc" id="L101">    }</span>

    public void stopBuild()
    {
<span class="fc" id="L105">        views.forEach(View::stopBuild);</span>
<span class="fc" id="L106">    }</span>

    public void forceBlockingFlush(ColumnFamilyStore.FlushReason reason)
    {
<span class="fc bfc" id="L110" title="All 2 branches covered.">        for (ColumnFamilyStore viewCfs : allViewsCfs())</span>
<span class="fc" id="L111">            viewCfs.forceBlockingFlush(reason);</span>
<span class="fc" id="L112">    }</span>

    public void dumpMemtables()
    {
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        for (ColumnFamilyStore viewCfs : allViewsCfs())</span>
<span class="nc" id="L117">            viewCfs.dumpMemtable();</span>
<span class="fc" id="L118">    }</span>

    public void truncateBlocking(CommitLogPosition replayAfter, long truncatedAt)
    {
<span class="fc bfc" id="L122" title="All 2 branches covered.">        for (ColumnFamilyStore viewCfs : allViewsCfs())</span>
        {
<span class="fc" id="L124">            viewCfs.discardSSTables(truncatedAt);</span>
<span class="fc" id="L125">            SystemKeyspace.saveTruncationRecord(viewCfs, truncatedAt, replayAfter);</span>
<span class="fc" id="L126">        }</span>
<span class="fc" id="L127">    }</span>

    public void removeByName(String viewName)
    {
<span class="fc" id="L131">        views.removeIf(v -&gt; v.name.equals(viewName));</span>
<span class="fc" id="L132">    }</span>

    /**
     * Calculates and pushes updates to the views replicas. The replicas are determined by
     * {@link ViewUtils#getViewNaturalEndpoint(String, Token, Token)}.
     *
     * @param update an update on the base table represented by this object.
     * @param writeCommitLog whether we should write the commit log for the view updates.
     * @param baseComplete time from epoch in ms that the local base mutation was (or will be) completed
     */
    public void pushViewReplicaUpdates(PartitionUpdate update, boolean writeCommitLog, AtomicLong baseComplete)
    {
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">        assert update.metadata().id.equals(baseTableMetadata.id);</span>

<span class="fc" id="L146">        Collection&lt;View&gt; views = updatedViews(update);</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">        if (views.isEmpty())</span>
<span class="nc" id="L148">            return;</span>

        // Read modified rows
<span class="fc" id="L151">        long nowInSec = FBUtilities.nowInSeconds();</span>
<span class="fc" id="L152">        long queryStartNanoTime = nanoTime();</span>
<span class="fc" id="L153">        SinglePartitionReadCommand command = readExistingRowsCommand(update, views, nowInSec);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">        if (command == null)</span>
<span class="fc" id="L155">            return;</span>

<span class="fc" id="L157">        ColumnFamilyStore cfs = Keyspace.openAndGetStore(update.metadata());</span>
<span class="fc" id="L158">        long start = nanoTime();</span>
        Collection&lt;Mutation&gt; mutations;
<span class="fc" id="L160">        try (ReadExecutionController orderGroup = command.executionController();</span>
<span class="fc" id="L161">             UnfilteredRowIterator existings = UnfilteredPartitionIterators.getOnlyElement(command.executeLocally(orderGroup), command);</span>
<span class="fc" id="L162">             UnfilteredRowIterator updates = update.unfilteredIterator())</span>
        {
<span class="fc" id="L164">            mutations = Iterators.getOnlyElement(generateViewUpdates(views, updates, existings, nowInSec, false));</span>
        }
<span class="fc" id="L166">        Keyspace.openAndGetStore(update.metadata()).metric.viewReadTime.update(nanoTime() - start, TimeUnit.NANOSECONDS);</span>

<span class="fc bfc" id="L168" title="All 2 branches covered.">        if (!mutations.isEmpty())</span>
<span class="fc" id="L169">            StorageProxy.mutateMV(update.partitionKey().getKey(), mutations, writeCommitLog, baseComplete, queryStartNanoTime);</span>
<span class="fc" id="L170">    }</span>


    /**
     * Given some updates on the base table of this object and the existing values for the rows affected by that update, generates the
     * mutation to be applied to the provided views.
     *
     * @param views the views potentially affected by {@code updates}.
     * @param updates the base table updates being applied.
     * @param existings the existing values for the rows affected by {@code updates}. This is used to decide if a view is
     * obsoleted by the update and should be removed, gather the values for columns that may not be part of the update if
     * a new view entry needs to be created, and compute the minimal updates to be applied if the view entry isn't changed
     * but has simply some updated values. This will be empty for view building as we want to assume anything we'll pass
     * to {@code updates} is new.
     * @param nowInSec the current time in seconds.
     * @param separateUpdates, if false, mutation is per partition.
     * @return the mutations to apply to the {@code views}. This can be empty.
     */
    public Iterator&lt;Collection&lt;Mutation&gt;&gt; generateViewUpdates(Collection&lt;View&gt; views,
                                                              UnfilteredRowIterator updates,
                                                              UnfilteredRowIterator existings,
                                                              long nowInSec,
                                                              boolean separateUpdates)
    {
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">        assert updates.metadata().id.equals(baseTableMetadata.id);</span>

<span class="fc" id="L196">        List&lt;ViewUpdateGenerator&gt; generators = new ArrayList&lt;&gt;(views.size());</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">        for (View view : views)</span>
<span class="fc" id="L198">            generators.add(new ViewUpdateGenerator(view, updates.partitionKey(), nowInSec));</span>

<span class="fc" id="L200">        DeletionTracker existingsDeletion = new DeletionTracker(existings.partitionLevelDeletion());</span>
<span class="fc" id="L201">        DeletionTracker updatesDeletion = new DeletionTracker(updates.partitionLevelDeletion());</span>

        /*
         * We iterate through the updates and the existing rows in parallel. This allows us to know the consequence
         * on the view of each update.
         */
<span class="fc" id="L207">        PeekingIterator&lt;Unfiltered&gt; existingsIter = Iterators.peekingIterator(existings);</span>
<span class="fc" id="L208">        PeekingIterator&lt;Unfiltered&gt; updatesIter = Iterators.peekingIterator(updates);</span>

<span class="fc bfc" id="L210" title="All 4 branches covered.">        while (existingsIter.hasNext() &amp;&amp; updatesIter.hasNext())</span>
        {
<span class="fc" id="L212">            Unfiltered existing = existingsIter.peek();</span>
<span class="fc" id="L213">            Unfiltered update = updatesIter.peek();</span>

            Row existingRow;
            Row updateRow;
<span class="fc" id="L217">            int cmp = baseTableMetadata.get().comparator.compare(update, existing);</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">            if (cmp &lt; 0)</span>
            {
                // We have an update where there was nothing before
<span class="fc bfc" id="L221" title="All 2 branches covered.">                if (update.isRangeTombstoneMarker())</span>
                {
<span class="fc" id="L223">                    updatesDeletion.update(updatesIter.next());</span>
<span class="fc" id="L224">                    continue;</span>
                }

<span class="fc" id="L227">                updateRow = ((Row)updatesIter.next()).withRowDeletion(updatesDeletion.currentDeletion());</span>
<span class="fc" id="L228">                existingRow = emptyRow(updateRow.clustering(), existingsDeletion.currentDeletion());</span>
            }
<span class="fc bfc" id="L230" title="All 2 branches covered.">            else if (cmp &gt; 0)</span>
            {
                // We have something existing but no update (which will happen either because it's a range tombstone marker in
                // existing, or because we've fetched the existing row due to some partition/range deletion in the updates)
<span class="fc bfc" id="L234" title="All 2 branches covered.">                if (existing.isRangeTombstoneMarker())</span>
                {
<span class="fc" id="L236">                    existingsDeletion.update(existingsIter.next());</span>
<span class="fc" id="L237">                    continue;</span>
                }

<span class="fc" id="L240">                existingRow = ((Row)existingsIter.next()).withRowDeletion(existingsDeletion.currentDeletion());</span>
<span class="fc" id="L241">                updateRow = emptyRow(existingRow.clustering(), updatesDeletion.currentDeletion());</span>

                // The way we build the read command used for existing rows, we should always have updatesDeletion.currentDeletion()
                // that is not live, since we wouldn't have read the existing row otherwise. And we could assert that, but if we ever
                // change the read method so that it can slightly over-read in some case, that would be an easily avoiding bug lurking,
                // so we just handle the case.
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">                if (updateRow == null)</span>
<span class="nc" id="L248">                    continue;</span>
            }
            else
            {
                // We're updating a row that had pre-existing data
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">                if (update.isRangeTombstoneMarker())</span>
                {
<span class="nc bnc" id="L255" title="All 2 branches missed.">                    assert existing.isRangeTombstoneMarker();</span>
<span class="nc" id="L256">                    updatesDeletion.update(updatesIter.next());</span>
<span class="nc" id="L257">                    existingsDeletion.update(existingsIter.next());</span>
<span class="nc" id="L258">                    continue;</span>
                }

<span class="pc bpc" id="L261" title="1 of 2 branches missed.">                assert !existing.isRangeTombstoneMarker();</span>
<span class="fc" id="L262">                existingRow = ((Row)existingsIter.next()).withRowDeletion(existingsDeletion.currentDeletion());</span>
<span class="fc" id="L263">                updateRow = ((Row)updatesIter.next()).withRowDeletion(updatesDeletion.currentDeletion());</span>
            }

<span class="fc" id="L266">            addToViewUpdateGenerators(existingRow, updateRow, generators);</span>
<span class="fc" id="L267">        }</span>

        // We only care about more existing rows if the update deletion isn't live, i.e. if we had a partition deletion
<span class="fc bfc" id="L270" title="All 2 branches covered.">        if (!updatesDeletion.currentDeletion().isLive())</span>
        {
<span class="fc bfc" id="L272" title="All 2 branches covered.">            while (existingsIter.hasNext())</span>
            {
<span class="fc" id="L274">                Unfiltered existing = existingsIter.next();</span>
                // If it's a range tombstone, we don't care, we're only looking for existing entry that gets deleted by
                // the new partition deletion
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">                if (existing.isRangeTombstoneMarker())</span>
<span class="nc" id="L278">                    continue;</span>

<span class="fc" id="L280">                Row existingRow = (Row)existing;</span>
<span class="fc" id="L281">                addToViewUpdateGenerators(existingRow, emptyRow(existingRow.clustering(), updatesDeletion.currentDeletion()), generators);</span>
<span class="fc" id="L282">            }</span>
        }

<span class="fc bfc" id="L285" title="All 2 branches covered.">        if (separateUpdates)</span>
        {
<span class="fc" id="L287">            final Collection&lt;Mutation&gt; firstBuild = buildMutations(baseTableMetadata.get(), generators);</span>

<span class="fc" id="L289">            return new Iterator&lt;Collection&lt;Mutation&gt;&gt;()</span>
<span class="fc" id="L290">            {</span>
                // If the previous values are already empty, this update must be either empty or exclusively appending.
                // In the case we are exclusively appending, we need to drop the build that was passed in and try to build a
                // new first update instead.
                // If there are no other updates, next will be null and the iterator will be empty.
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">                Collection&lt;Mutation&gt; next = firstBuild.isEmpty()</span>
<span class="fc" id="L296">                                            ? buildNext()</span>
<span class="pc" id="L297">                                            : firstBuild;</span>

                private Collection&lt;Mutation&gt; buildNext()
                {
<span class="fc bfc" id="L301" title="All 2 branches covered.">                    while (updatesIter.hasNext())</span>
                    {
<span class="fc" id="L303">                        Unfiltered update = updatesIter.next();</span>
                        // If it's a range tombstone, it removes nothing pre-exisiting, so we can ignore it for view updates
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">                        if (update.isRangeTombstoneMarker())</span>
<span class="nc" id="L306">                            continue;</span>

<span class="fc" id="L308">                        Row updateRow = (Row) update;</span>
<span class="fc" id="L309">                        addToViewUpdateGenerators(emptyRow(updateRow.clustering(), existingsDeletion.currentDeletion()),</span>
                                                  updateRow,
                                                  generators);

                        // If the updates have been filtered, then we won't have any mutations; we need to make sure that we
                        // only return if the mutations are empty. Otherwise, we continue to search for an update which is
                        // not filtered
<span class="fc" id="L316">                        Collection&lt;Mutation&gt; mutations = buildMutations(baseTableMetadata.get(), generators);</span>
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">                        if (!mutations.isEmpty())</span>
<span class="fc" id="L318">                            return mutations;</span>
<span class="nc" id="L319">                    }</span>

<span class="fc" id="L321">                    return null;</span>
                }

                public boolean hasNext()
                {
<span class="fc bfc" id="L326" title="All 2 branches covered.">                    return next != null;</span>
                }

                public Collection&lt;Mutation&gt; next()
                {
<span class="fc" id="L331">                    Collection&lt;Mutation&gt; mutations = next;</span>

<span class="fc" id="L333">                    next = buildNext();</span>

<span class="pc bpc" id="L335" title="1 of 2 branches missed.">                    assert !mutations.isEmpty() : &quot;Expected mutations to be non-empty&quot;;</span>
<span class="fc" id="L336">                    return mutations;</span>
                }
            };
        }
        else
        {
<span class="fc bfc" id="L342" title="All 2 branches covered.">            while (updatesIter.hasNext())</span>
            {
<span class="fc" id="L344">                Unfiltered update = updatesIter.next();</span>
                // If it's a range tombstone, it removes nothing pre-exisiting, so we can ignore it for view updates
<span class="fc bfc" id="L346" title="All 2 branches covered.">                if (update.isRangeTombstoneMarker())</span>
<span class="fc" id="L347">                    continue;</span>

<span class="fc" id="L349">                Row updateRow = (Row) update;</span>
<span class="fc" id="L350">                addToViewUpdateGenerators(emptyRow(updateRow.clustering(), existingsDeletion.currentDeletion()),</span>
                                          updateRow,
                                          generators);
<span class="fc" id="L353">            }</span>

<span class="fc" id="L355">            return Iterators.singletonIterator(buildMutations(baseTableMetadata.get(), generators));</span>
        }
    }

    /**
     * Return the views that are potentially updated by the provided updates.
     *
     * @param updates the updates applied to the base table.
     * @return the views affected by {@code updates}.
     */
    public Collection&lt;View&gt; updatedViews(PartitionUpdate updates)
    {
<span class="fc" id="L367">        List&lt;View&gt; matchingViews = new ArrayList&lt;&gt;(views.size());</span>

<span class="fc bfc" id="L369" title="All 2 branches covered.">        for (View view : views)</span>
        {
<span class="fc" id="L371">            ReadQuery selectQuery = view.getReadQuery();</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">            if (!selectQuery.selectsKey(updates.partitionKey()))</span>
<span class="fc" id="L373">                continue;</span>

<span class="fc" id="L375">            matchingViews.add(view);</span>
<span class="fc" id="L376">        }</span>
<span class="fc" id="L377">        return matchingViews;</span>
    }

    /**
     * Returns the command to use to read the existing rows required to generate view updates for the provided base
     * base updates.
     *
     * @param updates the base table updates being applied.
     * @param views the views potentially affected by {@code updates}.
     * @param nowInSec the current time in seconds.
     * @return the command to use to read the base table rows required to generate view updates for {@code updates}.
     */
    private SinglePartitionReadCommand readExistingRowsCommand(PartitionUpdate updates, Collection&lt;View&gt; views, long nowInSec)
    {
<span class="fc" id="L391">        Slices.Builder sliceBuilder = null;</span>
<span class="fc" id="L392">        DeletionInfo deletionInfo = updates.deletionInfo();</span>
<span class="fc" id="L393">        TableMetadata metadata = updates.metadata();</span>
<span class="fc" id="L394">        DecoratedKey key = updates.partitionKey();</span>
        // TODO: This is subtle: we need to gather all the slices that we have to fetch between partition del, range tombstones and rows.
<span class="fc bfc" id="L396" title="All 2 branches covered.">        if (!deletionInfo.isLive())</span>
        {
<span class="fc" id="L398">            sliceBuilder = new Slices.Builder(metadata.comparator);</span>
            // Everything covered by a deletion might invalidate an existing view entry, which means we must read it to know. In practice
            // though, the views involved might filter some base table clustering columns, in which case we can restrict what we read
            // using those restrictions.
            // If there is a partition deletion, then we can simply take each slices from each view select filter. They may overlap but
            // the Slices.Builder handles that for us. Note that in many case this will just involve reading everything (as soon as any
            // view involved has no clustering restrictions for instance).
            // For range tombstone, we should theoretically take the difference between the range tombstoned and the slices selected
            // by every views, but as we don't an easy way to compute that right now, we keep it simple and just use the tombstoned
            // range.
            // TODO: we should improve that latter part.
<span class="fc bfc" id="L409" title="All 2 branches covered.">            if (!deletionInfo.getPartitionDeletion().isLive())</span>
            {
<span class="fc bfc" id="L411" title="All 2 branches covered.">                for (View view : views)</span>
<span class="fc" id="L412">                    sliceBuilder.addAll(view.getSelectStatement().clusteringIndexFilterAsSlices());</span>
            }
            else
            {
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">                assert deletionInfo.hasRanges();</span>
<span class="fc" id="L417">                Iterator&lt;RangeTombstone&gt; iter = deletionInfo.rangeIterator(false);</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">                while (iter.hasNext())</span>
<span class="fc" id="L419">                    sliceBuilder.add(iter.next().deletedSlice());</span>
            }
        }

        // We need to read every row that is updated, unless we can prove that it has no impact on any view entries.

        // If we had some slices from the deletions above, we'll continue using that. Otherwise, it's more efficient to build
        // a names query.
        NavigableSet&lt;Clustering&lt;?&gt;&gt; names;
<span class="fc bfc" id="L428" title="All 2 branches covered.">        try (BTree.FastBuilder&lt;Clustering&lt;?&gt;&gt; namesBuilder = sliceBuilder == null ? BTree.fastBuilder() : null)</span>
        {
<span class="fc bfc" id="L430" title="All 2 branches covered.">            for (Row row : updates)</span>
            {
                // Don't read the existing state if we can prove the update won't affect any views
<span class="fc bfc" id="L433" title="All 2 branches covered.">                if (!affectsAnyViews(key, row, views))</span>
<span class="fc" id="L434">                    continue;</span>

<span class="pc bpc" id="L436" title="1 of 2 branches missed.">                if (namesBuilder == null)</span>
<span class="nc" id="L437">                    sliceBuilder.add(Slice.make(row.clustering()));</span>
                else
<span class="fc" id="L439">                    namesBuilder.add(row.clustering());</span>
<span class="fc" id="L440">            }</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">            names = namesBuilder == null ? null : BTreeSet.wrap(namesBuilder.build(), metadata.comparator);</span>
        }

        // If we have a slice builder, it means we had some deletions and we have to read. But if we had
        // only row updates, it's possible none of them affected the views, in which case we have nothing
        // to do.
<span class="fc bfc" id="L447" title="All 4 branches covered.">        if (names != null &amp;&amp; names.isEmpty())</span>
<span class="fc" id="L448">            return null;</span>

<span class="fc bfc" id="L450" title="All 2 branches covered.">        ClusteringIndexFilter clusteringFilter = names == null</span>
<span class="fc" id="L451">                                               ? new ClusteringIndexSliceFilter(sliceBuilder.build(), false)</span>
<span class="fc" id="L452">                                               : new ClusteringIndexNamesFilter(names, false);</span>
        // since unselected columns also affect view liveness, we need to query all base columns if base and view have same key columns.
        // If we have more than one view, we should merge the queried columns by each views but to keep it simple we just
        // include everything. We could change that in the future.
<span class="pc bpc" id="L456" title="1 of 4 branches missed.">        ColumnFilter queriedColumns = views.size() == 1 &amp;&amp; metadata.enforceStrictLiveness()</span>
<span class="nc" id="L457">                                    ? Iterables.getOnlyElement(views).getSelectStatement().queriedColumns()</span>
<span class="fc" id="L458">                                    : ColumnFilter.all(metadata);</span>
        // Note that the views could have restrictions on regular columns, but even if that's the case we shouldn't apply those
        // when we read, because even if an existing row doesn't match the view filter, the update can change that in which
        // case we'll need to know the existing content. There is also no easy way to merge those RowFilter when we have multiple views.
        // TODO: we could still make sense to special case for when there is a single view and a small number of updates (and
        // no deletions). Indeed, in that case we could check whether any of the update modify any of the restricted regular
        // column, and if that's not the case we could use view filter. We keep it simple for now though.
<span class="fc" id="L465">        RowFilter rowFilter = RowFilter.none();</span>
<span class="fc" id="L466">        return SinglePartitionReadCommand.create(metadata, nowInSec, queriedColumns, rowFilter, DataLimits.NONE, key, clusteringFilter);</span>
    }

    private boolean affectsAnyViews(DecoratedKey partitionKey, Row update, Collection&lt;View&gt; views)
    {
<span class="fc bfc" id="L471" title="All 2 branches covered.">        for (View view : views)</span>
        {
<span class="fc bfc" id="L473" title="All 2 branches covered.">            if (view.mayBeAffectedBy(partitionKey, update))</span>
<span class="fc" id="L474">                return true;</span>
<span class="fc" id="L475">        }</span>
<span class="fc" id="L476">        return false;</span>
    }

    /**
     * Given an existing base row and the update that we're going to apply to this row, generate the modifications
     * to apply to MVs using the provided {@code ViewUpdateGenerator}s.
     *
     * @param existingBaseRow the base table row as it is before an update.
     * @param updateBaseRow the newly updates made to {@code existingBaseRow}.
     * @param generators the view update generators to add the new changes to.
     */
    private static void addToViewUpdateGenerators(Row existingBaseRow, Row updateBaseRow, Collection&lt;ViewUpdateGenerator&gt; generators)
    {
        // Having existing empty is useful, it just means we'll insert a brand new entry for updateBaseRow,
        // but if we have no update at all, we shouldn't get there.
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">        assert !updateBaseRow.isEmpty();</span>

        // We allow existingBaseRow to be null, which we treat the same as being empty as an small optimization
        // to avoid allocating empty row objects when we know there was nothing existing.
<span class="fc bfc" id="L495" title="All 2 branches covered.">        Row mergedBaseRow = existingBaseRow == null ? updateBaseRow : Rows.merge(existingBaseRow, updateBaseRow);</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">        for (ViewUpdateGenerator generator : generators)</span>
<span class="fc" id="L497">            generator.addBaseTableUpdate(existingBaseRow, mergedBaseRow);</span>
<span class="fc" id="L498">    }</span>

    private static Row emptyRow(Clustering&lt;?&gt; clustering, DeletionTime deletion)
    {
        // Returning null for an empty row is slightly ugly, but the case where there is no pre-existing row is fairly common
        // (especially when building the view), so we want to avoid a dummy allocation of an empty row every time.
        // And MultiViewUpdateBuilder knows how to deal with that.
<span class="fc bfc" id="L505" title="All 2 branches covered.">        return deletion.isLive() ? null : BTreeRow.emptyDeletedRow(clustering, Row.Deletion.regular(deletion));</span>
    }

    /**
     * Extracts (and potentially groups) the mutations generated by the provided view update generator.
     * Returns the mutation that needs to be done to the views given the base table updates
     * passed to {@link #addBaseTableUpdate}.
     *
     * @param baseTableMetadata the metadata for the base table being updated.
     * @param generators the generators from which to extract the view mutations from.
     * @return the mutations created by all the generators in {@code generators}.
     */
    private Collection&lt;Mutation&gt; buildMutations(TableMetadata baseTableMetadata, List&lt;ViewUpdateGenerator&gt; generators)
    {
        // One view is probably common enough and we can optimize a bit easily
<span class="fc bfc" id="L520" title="All 2 branches covered.">        if (generators.size() == 1)</span>
        {
<span class="fc" id="L522">            ViewUpdateGenerator generator = generators.get(0);</span>
<span class="fc" id="L523">            Collection&lt;PartitionUpdate&gt; updates = generator.generateViewUpdates();</span>
<span class="fc" id="L524">            List&lt;Mutation&gt; mutations = new ArrayList&lt;&gt;(updates.size());</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">            for (PartitionUpdate update : updates)</span>
<span class="fc" id="L526">                mutations.add(new Mutation(update));</span>

<span class="fc" id="L528">            generator.clear();</span>
<span class="fc" id="L529">            return mutations;</span>
        }

<span class="fc" id="L532">        Map&lt;DecoratedKey, Mutation.PartitionUpdateCollector&gt; mutations = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">        for (ViewUpdateGenerator generator : generators)</span>
        {
<span class="fc bfc" id="L535" title="All 2 branches covered.">            for (PartitionUpdate update : generator.generateViewUpdates())</span>
            {
<span class="fc" id="L537">                DecoratedKey key = update.partitionKey();</span>
<span class="fc" id="L538">                Mutation.PartitionUpdateCollector collector = mutations.get(key);</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">                if (collector == null)</span>
                {
<span class="fc" id="L541">                    collector = new Mutation.PartitionUpdateCollector(baseTableMetadata.keyspace, key);</span>
<span class="fc" id="L542">                    mutations.put(key, collector);</span>
                }
<span class="fc" id="L544">                collector.add(update);</span>
<span class="fc" id="L545">            }</span>
<span class="fc" id="L546">            generator.clear();</span>
<span class="fc" id="L547">        }</span>
<span class="fc" id="L548">        return mutations.values().stream().map(Mutation.PartitionUpdateCollector::build).collect(Collectors.toList());</span>
    }

    /**
     * A simple helper that tracks for a given {@code UnfilteredRowIterator} what is the current deletion at any time of the
     * iteration. It will be the currently open range tombstone deletion if there is one and the partition deletion otherwise.
     */
<span class="fc" id="L555">    private static class DeletionTracker</span>
    {
        private final DeletionTime partitionDeletion;
        private DeletionTime deletion;

        public DeletionTracker(DeletionTime partitionDeletion)
<span class="fc" id="L561">        {</span>
<span class="fc" id="L562">            this.partitionDeletion = partitionDeletion;</span>
<span class="fc" id="L563">        }</span>

        public void update(Unfiltered marker)
        {
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">            assert marker instanceof RangeTombstoneMarker;</span>
<span class="fc" id="L568">            RangeTombstoneMarker rtm = (RangeTombstoneMarker)marker;</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">            this.deletion = rtm.isOpen(false)</span>
<span class="fc" id="L570">                          ? rtm.openDeletionTime(false)</span>
<span class="fc" id="L571">                          : null;</span>
<span class="fc" id="L572">        }</span>

        public DeletionTime currentDeletion()
        {
<span class="fc bfc" id="L576" title="All 2 branches covered.">            return deletion == null ? partitionDeletion : deletion;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>