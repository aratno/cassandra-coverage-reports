<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CQLSSTableWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.io.sstable</a> &gt; <span class="el_source">CQLSSTableWriter.java</span></div><h1>CQLSSTableWriter.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.io.sstable;

import java.io.Closeable;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.NavigableSet;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

import com.google.common.base.Preconditions;
import com.google.common.collect.Sets;

import org.apache.cassandra.config.CassandraRelevantProperties;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.cql3.ColumnSpecification;
import org.apache.cassandra.cql3.QueryOptions;
import org.apache.cassandra.cql3.QueryProcessor;
import org.apache.cassandra.cql3.UpdateParameters;
import org.apache.cassandra.cql3.functions.types.TypeCodec;
import org.apache.cassandra.cql3.functions.types.UserType;
import org.apache.cassandra.cql3.statements.ModificationStatement;
import org.apache.cassandra.cql3.statements.schema.CreateTableStatement;
import org.apache.cassandra.cql3.statements.schema.CreateTypeStatement;
import org.apache.cassandra.db.Clustering;
import org.apache.cassandra.db.Slice;
import org.apache.cassandra.db.Slices;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.dht.IPartitioner;
import org.apache.cassandra.dht.Murmur3Partitioner;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.exceptions.SyntaxException;
import org.apache.cassandra.io.sstable.format.SSTableFormat;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.schema.KeyspaceMetadata;
import org.apache.cassandra.schema.KeyspaceParams;
import org.apache.cassandra.schema.Schema;
import org.apache.cassandra.schema.SchemaConstants;
import org.apache.cassandra.schema.SchemaTransformations;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.schema.TableMetadataRef;
import org.apache.cassandra.schema.Tables;
import org.apache.cassandra.schema.Types;
import org.apache.cassandra.schema.UserFunctions;
import org.apache.cassandra.schema.Views;
import org.apache.cassandra.service.ClientState;
import org.apache.cassandra.transport.ProtocolVersion;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.JavaDriverUtils;

import static org.apache.cassandra.utils.Clock.Global.currentTimeMillis;

/**
 * Utility to write SSTables.
 * &lt;p&gt;
 * Typical usage looks like:
 * &lt;pre&gt;
 *   String type = CREATE TYPE myKs.myType (a int, b int)&quot;;
 *   String schema = &quot;CREATE TABLE myKs.myTable (&quot;
 *                 + &quot;  k int PRIMARY KEY,&quot;
 *                 + &quot;  v1 text,&quot;
 *                 + &quot;  v2 int,&quot;
 *                 + &quot;  v3 myType,&quot;
 *                 + &quot;)&quot;;
 *   String insert = &quot;INSERT INTO myKs.myTable (k, v1, v2, v3) VALUES (?, ?, ?, ?)&quot;;
 *
 *   // Creates a new writer. You need to provide at least the directory where to write the created sstable,
 *   // the schema for the sstable to write and a (prepared) modification statement to use. If you do not use the
 *   // default partitioner (Murmur3Partitioner), you will also need to provide the partitioner in use, see
 *   // CQLSSTableWriter.Builder for more details on the available options.
 *   CQLSSTableWriter writer = CQLSSTableWriter.builder()
 *                                             .inDirectory(&quot;path/to/directory&quot;)
 *                                             .withType(type)
 *                                             .forTable(schema)
 *                                             .using(insert).build();
 *
 *   UserType myType = writer.getUDType(&quot;myType&quot;);
 *   // Adds a nember of rows to the resulting sstable
 *   writer.addRow(0, &quot;test1&quot;, 24, myType.newValue().setInt(&quot;a&quot;, 10).setInt(&quot;b&quot;, 20));
 *   writer.addRow(1, &quot;test2&quot;, null, null);
 *   writer.addRow(2, &quot;test3&quot;, 42, myType.newValue().setInt(&quot;a&quot;, 30).setInt(&quot;b&quot;, 40));
 *
 *   // Close the writer, finalizing the sstable
 *   writer.close();
 * &lt;/pre&gt;
 *
 * Please note that {@code CQLSSTableWriter} is &lt;b&gt;not&lt;/b&gt; thread-safe (multiple threads cannot access the
 * same instance). It is however safe to use multiple instances in parallel (even if those instance write
 * sstables for the same table).
 */
public class CQLSSTableWriter implements Closeable
{
<span class="fc" id="L114">    public static final ByteBuffer UNSET_VALUE = ByteBufferUtil.UNSET_BYTE_BUFFER;</span>

    static
    {
<span class="fc" id="L118">        CassandraRelevantProperties.FORCE_LOAD_LOCAL_KEYSPACES.setBoolean(true);</span>
<span class="fc" id="L119">        DatabaseDescriptor.clientInitialization(false);</span>
        // Partitioner is not set in client mode.
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">        if (DatabaseDescriptor.getPartitioner() == null)</span>
<span class="nc" id="L122">            DatabaseDescriptor.setPartitionerUnsafe(Murmur3Partitioner.instance);</span>
<span class="fc" id="L123">    }</span>

    private final AbstractSSTableSimpleWriter writer;
    private final ModificationStatement modificationStatement;
    private final List&lt;ColumnSpecification&gt; boundNames;
    private final List&lt;TypeCodec&gt; typeCodecs;

    private CQLSSTableWriter(AbstractSSTableSimpleWriter writer, ModificationStatement modificationStatement, List&lt;ColumnSpecification&gt; boundNames)
<span class="fc" id="L131">    {</span>
<span class="fc" id="L132">        this.writer = writer;</span>
<span class="fc" id="L133">        this.modificationStatement = modificationStatement;</span>
<span class="fc" id="L134">        this.boundNames = boundNames;</span>
<span class="fc" id="L135">        this.typeCodecs = boundNames.stream().map(bn -&gt;  JavaDriverUtils.codecFor(JavaDriverUtils.driverType(bn.type)))</span>
<span class="fc" id="L136">                                             .collect(Collectors.toList());</span>
<span class="fc" id="L137">    }</span>

    /**
     * Returns a new builder for a CQLSSTableWriter.
     *
     * @return the new builder.
     */
    public static Builder builder()
    {
<span class="fc" id="L146">        return new Builder();</span>
    }

    /**
     * Adds a new row to the writer.
     * &lt;p&gt;
     * This is a shortcut for {@code addRow(Arrays.asList(values))}.
     *
     * @param values the row values (corresponding to the bind variables of the
     * modification statement used when creating by this writer).
     * @return this writer.
     */
    public CQLSSTableWriter addRow(Object... values)
    throws InvalidRequestException, IOException
    {
<span class="fc" id="L161">        return addRow(Arrays.asList(values));</span>
    }

    /**
     * Adds a new row to the writer.
     * &lt;p&gt;
     * Each provided value type should correspond to the types of the CQL column
     * the value is for. The correspondance between java type and CQL type is the
     * same one than the one documented at
     * www.datastax.com/drivers/java/2.0/apidocs/com/datastax/driver/core/DataType.Name.html#asJavaClass().
     * &lt;p&gt;
     * If you prefer providing the values directly as binary, use
     * {@link #rawAddRow} instead.
     *
     * @param values the row values (corresponding to the bind variables of the
     * modification statement used when creating by this writer).
     * @return this writer.
     */
    public CQLSSTableWriter addRow(List&lt;Object&gt; values)
    throws InvalidRequestException, IOException
    {
<span class="fc" id="L182">        int size = Math.min(values.size(), boundNames.size());</span>
<span class="fc" id="L183">        List&lt;ByteBuffer&gt; rawValues = new ArrayList&lt;&gt;(size);</span>

<span class="fc bfc" id="L185" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="fc" id="L187">            Object value = values.get(i);</span>
<span class="fc" id="L188">            rawValues.add(serialize(value, typeCodecs.get(i), boundNames.get(i)));</span>
        }

<span class="fc" id="L191">        return rawAddRow(rawValues);</span>
    }

    /**
     * Adds a new row to the writer.
     * &lt;p&gt;
     * This is equivalent to the other addRow methods, but takes a map whose
     * keys are the names of the columns to add instead of taking a list of the
     * values in the order of the modification statement used during construction of
     * this write.
     * &lt;p&gt;
     * Please note that the column names in the map keys must be in lowercase unless
     * the declared column name is a
     * &lt;a href=&quot;http://cassandra.apache.org/doc/cql3/CQL.html#identifiers&quot;&gt;case-sensitive quoted identifier&lt;/a&gt;
     * (in which case the map key must use the exact case of the column).
     *
     * @param values a map of colum name to column values representing the new
     * row to add. Note that if a column is not part of the map, it's value will
     * be {@code null}. If the map contains keys that does not correspond to one
     * of the column of the modification statement used when creating this writer, the
     * the corresponding value is ignored.
     * @return this writer.
     */
    public CQLSSTableWriter addRow(Map&lt;String, Object&gt; values)
    throws InvalidRequestException, IOException
    {
<span class="nc" id="L217">        int size = boundNames.size();</span>
<span class="nc" id="L218">        List&lt;ByteBuffer&gt; rawValues = new ArrayList&lt;&gt;(size);</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L221">            ColumnSpecification spec = boundNames.get(i);</span>
<span class="nc" id="L222">            Object value = values.get(spec.name.toString());</span>
<span class="nc" id="L223">            rawValues.add(serialize(value, typeCodecs.get(i), boundNames.get(i)));</span>
        }
<span class="nc" id="L225">        return rawAddRow(rawValues);</span>
    }

    /**
     * Adds a new row to the writer given already serialized values.
     *
     * @param values the row values (corresponding to the bind variables of the
     * modification statement used when creating by this writer) as binary.
     * @return this writer.
     */
    public CQLSSTableWriter rawAddRow(ByteBuffer... values)
    throws InvalidRequestException, IOException
    {
<span class="nc" id="L238">        return rawAddRow(Arrays.asList(values));</span>
    }

    /**
     * Adds a new row to the writer given already serialized values.
     * &lt;p&gt;
     * This is a shortcut for {@code rawAddRow(Arrays.asList(values))}.
     *
     * @param values the row values (corresponding to the bind variables of the
     * modification statement used when creating by this writer) as binary.
     * @return this writer.
     */
    public CQLSSTableWriter rawAddRow(List&lt;ByteBuffer&gt; values)
    throws InvalidRequestException, IOException
    {
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">        if (values.size() != boundNames.size())</span>
<span class="nc" id="L254">            throw new InvalidRequestException(String.format(&quot;Invalid number of arguments, expecting %d values but got %d&quot;, boundNames.size(), values.size()));</span>

<span class="fc" id="L256">        QueryOptions options = QueryOptions.forInternalCalls(null, values);</span>
<span class="fc" id="L257">        ClientState state = ClientState.forInternalCalls();</span>
<span class="fc" id="L258">        List&lt;ByteBuffer&gt; keys = modificationStatement.buildPartitionKeyNames(options, state);</span>

<span class="fc" id="L260">        long now = currentTimeMillis();</span>
        // Note that we asks indexes to not validate values (the last 'false' arg below) because that triggers a 'Keyspace.open'
        // and that forces a lot of initialization that we don't want.
<span class="fc" id="L263">        UpdateParameters params = new UpdateParameters(modificationStatement.metadata,</span>
<span class="fc" id="L264">                                                       modificationStatement.updatedColumns(),</span>
<span class="fc" id="L265">                                                       ClientState.forInternalCalls(),</span>
                                                       options,
<span class="fc" id="L267">                                                       modificationStatement.getTimestamp(TimeUnit.MILLISECONDS.toMicros(now), options),</span>
<span class="fc" id="L268">                                                       options.getNowInSec((int) TimeUnit.MILLISECONDS.toSeconds(now)),</span>
<span class="fc" id="L269">                                                       modificationStatement.getTimeToLive(options),</span>
<span class="fc" id="L270">                                                       Collections.emptyMap());</span>

        try
        {
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">            if (modificationStatement.hasSlices()) {</span>
<span class="nc" id="L275">                Slices slices = modificationStatement.createSlices(options);</span>

<span class="nc bnc" id="L277" title="All 2 branches missed.">                for (ByteBuffer key : keys)</span>
                {
<span class="nc bnc" id="L279" title="All 2 branches missed.">                    for (Slice slice : slices)</span>
<span class="nc" id="L280">                        modificationStatement.addUpdateForKey(writer.getUpdateFor(key), slice, params);</span>
<span class="nc" id="L281">                }</span>
<span class="nc" id="L282">            }</span>
            else
            {
<span class="fc" id="L285">                NavigableSet&lt;Clustering&lt;?&gt;&gt; clusterings = modificationStatement.createClustering(options, state);</span>

<span class="fc bfc" id="L287" title="All 2 branches covered.">                for (ByteBuffer key : keys)</span>
                {
<span class="fc bfc" id="L289" title="All 2 branches covered.">                    for (Clustering clustering : clusterings)</span>
<span class="fc" id="L290">                        modificationStatement.addUpdateForKey(writer.getUpdateFor(key), clustering, params);</span>
<span class="fc" id="L291">                }</span>
            }
<span class="fc" id="L293">            return this;</span>
        }
<span class="nc" id="L295">        catch (SSTableSimpleUnsortedWriter.SyncException e)</span>
        {
            // If we use a BufferedWriter and had a problem writing to disk, the IOException has been
            // wrapped in a SyncException (see BufferedWriter below). We want to extract that IOE.
<span class="nc" id="L299">            throw (IOException)e.getCause();</span>
        }
    }

    /**
     * Adds a new row to the writer given already serialized values.
     * &lt;p&gt;
     * This is equivalent to the other rawAddRow methods, but takes a map whose
     * keys are the names of the columns to add instead of taking a list of the
     * values in the order of the modification statement used during construction of
     * this write.
     *
     * @param values a map of colum name to column values representing the new
     * row to add. Note that if a column is not part of the map, it's value will
     * be {@code null}. If the map contains keys that does not correspond to one
     * of the column of the modification statement used when creating this writer, the
     * the corresponding value is ignored.
     * @return this writer.
     */
    public CQLSSTableWriter rawAddRow(Map&lt;String, ByteBuffer&gt; values)
    throws InvalidRequestException, IOException
    {
<span class="nc" id="L321">        int size = Math.min(values.size(), boundNames.size());</span>
<span class="nc" id="L322">        List&lt;ByteBuffer&gt; rawValues = new ArrayList&lt;&gt;(size);</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L325">            ColumnSpecification spec = boundNames.get(i);</span>
<span class="nc" id="L326">            rawValues.add(values.get(spec.name.toString()));</span>
        }
<span class="nc" id="L328">        return rawAddRow(rawValues);</span>
    }

    /**
     * Returns the User Defined type, used in this SSTable Writer, that can
     * be used to create UDTValue instances.
     *
     * @param dataType name of the User Defined type
     * @return user defined type
     */
    public UserType getUDType(String dataType)
    {
<span class="nc" id="L340">        KeyspaceMetadata ksm = Schema.instance.getKeyspaceMetadata(modificationStatement.keyspace());</span>
<span class="nc" id="L341">        org.apache.cassandra.db.marshal.UserType userType = ksm.types.getNullable(ByteBufferUtil.bytes(dataType));</span>
<span class="nc" id="L342">        return (UserType) JavaDriverUtils.driverType(userType);</span>
    }

    /**
     * Close this writer.
     * &lt;p&gt;
     * This method should be called, otherwise the produced sstables are not
     * guaranteed to be complete (and won't be in practice).
     */
    public void close() throws IOException
    {
<span class="fc" id="L353">        writer.close();</span>
<span class="fc" id="L354">    }</span>

    private ByteBuffer serialize(Object value, TypeCodec codec, ColumnSpecification columnSpecification)
    {
<span class="pc bpc" id="L358" title="2 of 4 branches missed.">        if (value == null || value == UNSET_VALUE)</span>
<span class="nc" id="L359">            return (ByteBuffer) value;</span>

        try
        {
<span class="fc" id="L363">            return codec.serialize(value, ProtocolVersion.CURRENT);</span>
        }
<span class="nc" id="L365">        catch (ClassCastException cce)</span>
        {
            // For backwards-compatibility with consumers that may be passing
            // an Integer for a Date field, for example.
<span class="nc" id="L369">            return ((AbstractType)columnSpecification.type).decompose(value);</span>
        }
    }
    /**
     * A Builder for a CQLSSTableWriter object.
     */
    public static class Builder
    {
        private File directory;

<span class="fc" id="L379">        protected SSTableFormat&lt;?, ?&gt; format = null;</span>

        private CreateTableStatement.Raw schemaStatement;
        private final List&lt;CreateTypeStatement.Raw&gt; typeStatements;
        private ModificationStatement.Parsed modificationStatement;
        private IPartitioner partitioner;

<span class="fc" id="L386">        private boolean sorted = false;</span>
<span class="fc" id="L387">        private long bufferSizeInMiB = 128;</span>

<span class="fc" id="L389">        protected Builder() {</span>
<span class="fc" id="L390">            this.typeStatements = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L391">        }</span>

        /**
         * The directory where to write the sstables.
         * &lt;p&gt;
         * This is a mandatory option.
         *
         * @param directory the directory to use, which should exists and be writable.
         * @return this builder.
         *
         * @throws IllegalArgumentException if {@code directory} doesn't exist or is not writable.
         */
        public Builder inDirectory(String directory)
        {
<span class="nc" id="L405">            return inDirectory(new File(directory));</span>
        }

        /**
         * The directory where to write the sstables (mandatory option).
         * &lt;p&gt;
         * This is a mandatory option.
         *
         * @param directory the directory to use, which should exists and be writable.
         * @return this builder.
         *
         * @throws IllegalArgumentException if {@code directory} doesn't exist or is not writable.
         */
        public Builder inDirectory(File directory)
        {
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">            if (!directory.exists())</span>
<span class="nc" id="L421">                throw new IllegalArgumentException(directory + &quot; doesn't exists&quot;);</span>
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">            if (!directory.isWritable())</span>
<span class="nc" id="L423">                throw new IllegalArgumentException(directory + &quot; exists but is not writable&quot;);</span>

<span class="fc" id="L425">            this.directory = directory;</span>
<span class="fc" id="L426">            return this;</span>
        }

        public Builder withType(String typeDefinition) throws SyntaxException
        {
<span class="nc" id="L431">            typeStatements.add(QueryProcessor.parseStatement(typeDefinition, CreateTypeStatement.Raw.class, &quot;CREATE TYPE&quot;));</span>
<span class="nc" id="L432">            return this;</span>
        }

        /**
         * The schema (CREATE TABLE statement) for the table for which sstable are to be created.
         * &lt;p&gt;
         * Please note that the provided CREATE TABLE statement &lt;b&gt;must&lt;/b&gt; use a fully-qualified
         * table name, one that include the keyspace name.
         * &lt;p&gt;
         * This is a mandatory option.
         *
         * @param schema the schema of the table for which sstables are to be created.
         * @return this builder.
         *
         * @throws IllegalArgumentException if {@code schema} is not a valid CREATE TABLE statement
         * or does not have a fully-qualified table name.
         */
        public Builder forTable(String schema)
        {
<span class="fc" id="L451">            this.schemaStatement = QueryProcessor.parseStatement(schema, CreateTableStatement.Raw.class, &quot;CREATE TABLE&quot;);</span>
<span class="fc" id="L452">            return this;</span>
        }

        /**
         * The partitioner to use.
         * &lt;p&gt;
         * By default, {@code Murmur3Partitioner} will be used. If this is not the partitioner used
         * by the cluster for which the SSTables are created, you need to use this method to
         * provide the correct partitioner.
         *
         * @param partitioner the partitioner to use.
         * @return this builder.
         */
        public Builder withPartitioner(IPartitioner partitioner)
        {
<span class="nc" id="L467">            this.partitioner = partitioner;</span>
<span class="nc" id="L468">            return this;</span>
        }

        /**
         * The INSERT, UPDATE, or DELETE statement defining the order of the values to add for a given CQL row.
         * &lt;p&gt;
         * Please note that the provided statement &lt;b&gt;must&lt;/b&gt; use a fully-qualified
         * table name, one that include the keyspace name. Moreover, said statement must use
         * bind variables since these variables will be bound to values by the resulting writer.
         * &lt;p&gt;
         * This is a mandatory option.
         *
         * @param modificationStatement an insert, update, or delete statement that defines the order
         * of column values to use.
         * @return this builder.
         *
         * @throws IllegalArgumentException if {@code modificationStatement} is not a valid insert, update, or delete
         * statement, does not have a fully-qualified table name or have no bind variables.
         */
        public Builder using(String modificationStatement)
        {
<span class="fc" id="L489">            this.modificationStatement = QueryProcessor.parseStatement(modificationStatement,</span>
                                                                       ModificationStatement.Parsed.class,
                                                                       &quot;INSERT/UPDATE/DELETE&quot;);
<span class="fc" id="L492">            return this;</span>
        }

        /**
         * The size of the buffer to use.
         * &lt;p&gt;
         * This defines how much data will be buffered before being written as
         * a new SSTable. This correspond roughly to the data size that will have the created
         * sstable.
         * &lt;p&gt;
         * The default is 128MiB, which should be reasonable for a 1GiB heap. If you experience
         * OOM while using the writer, you should lower this value.
         *
         * @param size the size to use in MiB.
         * @return this builder.
         */
        public Builder withBufferSizeInMiB(int size)
        {
<span class="fc" id="L510">            this.bufferSizeInMiB = size;</span>
<span class="fc" id="L511">            return this;</span>
        }

        /**
         * This method is deprecated in favor of the new withBufferSizeInMiB(int size)
         * The size of the buffer to use.
         * &lt;p&gt;
         * This defines how much data will be buffered before being written as
         * a new SSTable. This correspond roughly to the data size that will have the created
         * sstable.
         * &lt;p&gt;
         * The default is 128MiB, which should be reasonable for a 1GiB heap. If you experience
         * OOM while using the writer, you should lower this value.
         *
         * @param size the size to use in MiB.
         * @return this builder.
         */
        @Deprecated
        public Builder withBufferSizeInMB(int size)
        {
<span class="fc" id="L531">            return withBufferSizeInMiB(size);</span>
        }

        /**
         * Creates a CQLSSTableWriter that expects sorted inputs.
         * &lt;p&gt;
         * If this option is used, the resulting writer will expect rows to be
         * added in SSTable sorted order (and an exception will be thrown if that
         * is not the case during modification). The SSTable sorted order means that
         * rows are added such that their partition key respect the partitioner
         * order.
         * &lt;p&gt;
         * You should thus only use this option is you know that you can provide
         * the rows in order, which is rarely the case. If you can provide the
         * rows in order however, using this sorted might be more efficient.
         * &lt;p&gt;
         * Note that if used, some option like withBufferSizeInMiB will be ignored.
         *
         * @return this builder.
         */
        public Builder sorted()
        {
<span class="fc" id="L553">            this.sorted = true;</span>
<span class="fc" id="L554">            return this;</span>
        }

        @SuppressWarnings(&quot;resource&quot;)
        public CQLSSTableWriter build()
        {
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">            if (directory == null)</span>
<span class="nc" id="L561">                throw new IllegalStateException(&quot;No ouptut directory specified, you should provide a directory with inDirectory()&quot;);</span>
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">            if (schemaStatement == null)</span>
<span class="nc" id="L563">                throw new IllegalStateException(&quot;Missing schema, you should provide the schema for the SSTable to create with forTable()&quot;);</span>
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">            if (modificationStatement == null)</span>
<span class="nc" id="L565">                throw new IllegalStateException(&quot;No modification (INSERT/UPDATE/DELETE) statement specified, you should provide a modification statement through using()&quot;);</span>

<span class="fc" id="L567">            Preconditions.checkState(Sets.difference(SchemaConstants.LOCAL_SYSTEM_KEYSPACE_NAMES, Schema.instance.getKeyspaces()).isEmpty(),</span>
                                     &quot;Local keyspaces were not loaded. If this is running as a client, please make sure to add %s=true system property.&quot;,
<span class="fc" id="L569">                                     CassandraRelevantProperties.FORCE_LOAD_LOCAL_KEYSPACES.getKey());</span>
<span class="fc" id="L570">            synchronized (CQLSSTableWriter.class)</span>
            {

<span class="fc" id="L573">                String keyspaceName = schemaStatement.keyspace();</span>

<span class="fc" id="L575">                Schema.instance.transform(SchemaTransformations.addKeyspace(KeyspaceMetadata.create(keyspaceName,</span>
<span class="fc" id="L576">                                                                                                    KeyspaceParams.simple(1),</span>
<span class="fc" id="L577">                                                                                                    Tables.none(),</span>
<span class="fc" id="L578">                                                                                                    Views.none(),</span>
<span class="fc" id="L579">                                                                                                    Types.none(),</span>
<span class="fc" id="L580">                                                                                                    UserFunctions.none()), true));</span>

<span class="fc" id="L582">                KeyspaceMetadata ksm = Schema.instance.getKeyspaceMetadata(keyspaceName);</span>

<span class="fc" id="L584">                TableMetadata tableMetadata = ksm.tables.getNullable(schemaStatement.table());</span>
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">                if (tableMetadata == null)</span>
                {
<span class="fc" id="L587">                    Types types = createTypes(keyspaceName);</span>
<span class="fc" id="L588">                    Schema.instance.transform(SchemaTransformations.addTypes(types, true));</span>
<span class="fc" id="L589">                    tableMetadata = createTable(types);</span>
<span class="fc" id="L590">                    Schema.instance.transform(SchemaTransformations.addTable(tableMetadata, true));</span>
                }

<span class="fc" id="L593">                ModificationStatement preparedModificationStatement = prepareModificationStatement();</span>

<span class="fc" id="L595">                TableMetadataRef ref = TableMetadataRef.forOfflineTools(tableMetadata);</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">                AbstractSSTableSimpleWriter writer = sorted</span>
<span class="fc" id="L597">                                                     ? new SSTableSimpleWriter(directory, ref, preparedModificationStatement.updatedColumns())</span>
<span class="fc" id="L598">                                                     : new SSTableSimpleUnsortedWriter(directory, ref, preparedModificationStatement.updatedColumns(), bufferSizeInMiB);</span>

<span class="pc bpc" id="L600" title="1 of 2 branches missed.">                if (format != null)</span>
<span class="nc" id="L601">                    writer.setSSTableFormatType(format);</span>

<span class="fc" id="L603">                return new CQLSSTableWriter(writer, preparedModificationStatement, preparedModificationStatement.getBindVariables());</span>
            }
        }

        private Types createTypes(String keyspace)
        {
<span class="fc" id="L609">            Types.RawBuilder builder = Types.rawBuilder(keyspace);</span>
<span class="pc bpc" id="L610" title="1 of 2 branches missed.">            for (CreateTypeStatement.Raw st : typeStatements)</span>
<span class="nc" id="L611">                st.addToRawBuilder(builder);</span>
<span class="fc" id="L612">            return builder.build();</span>
        }

        /**
         * Creates the table according to schema statement
         *
         * @param types types this table should be created with
         */
        private TableMetadata createTable(Types types)
        {
<span class="fc" id="L622">            ClientState state = ClientState.forInternalCalls();</span>
<span class="fc" id="L623">            CreateTableStatement statement = schemaStatement.prepare(state);</span>
<span class="fc" id="L624">            statement.validate(ClientState.forInternalCalls());</span>

<span class="fc" id="L626">            TableMetadata.Builder builder = statement.builder(types);</span>
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">            if (partitioner != null)</span>
<span class="nc" id="L628">                builder.partitioner(partitioner);</span>

<span class="fc" id="L630">            return builder.build();</span>
        }

        /**
         * Prepares modification statement for writing data to SSTable
         *
         * @return prepared modification statement and it's bound names
         */
        private ModificationStatement prepareModificationStatement()
        {
<span class="fc" id="L640">            ClientState state = ClientState.forInternalCalls();</span>
<span class="fc" id="L641">            ModificationStatement preparedModificationStatement = modificationStatement.prepare(state);</span>
<span class="fc" id="L642">            preparedModificationStatement.validate(state);</span>

<span class="pc bpc" id="L644" title="1 of 2 branches missed.">            if (preparedModificationStatement.hasConditions())</span>
<span class="nc" id="L645">                throw new IllegalArgumentException(&quot;Conditional statements are not supported&quot;);</span>
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">            if (preparedModificationStatement.isCounter())</span>
<span class="nc" id="L647">                throw new IllegalArgumentException(&quot;Counter modification statements are not supported&quot;);</span>
<span class="pc bpc" id="L648" title="1 of 2 branches missed.">            if (preparedModificationStatement.getBindVariables().isEmpty())</span>
<span class="nc" id="L649">                throw new IllegalArgumentException(&quot;Provided preparedModificationStatement statement has no bind variables&quot;);</span>

<span class="fc" id="L651">            return preparedModificationStatement;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>