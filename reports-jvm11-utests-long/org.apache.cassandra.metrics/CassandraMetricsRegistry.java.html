<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CassandraMetricsRegistry.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.metrics</a> &gt; <span class="el_source">CassandraMetricsRegistry.java</span></div><h1>CassandraMetricsRegistry.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.metrics;

import java.lang.reflect.Method;
import java.util.Collection;
import java.util.Collections;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import javax.management.MalformedObjectNameException;
import javax.management.ObjectName;

import com.google.common.annotations.VisibleForTesting;

import com.codahale.metrics.*;
import org.apache.cassandra.utils.MBeanWrapper;

/**
 * Makes integrating 3.0 metrics API with 2.0.
 * &lt;p&gt;
 * The 3.0 API comes with poor JMX integration
 * &lt;/p&gt;
 */
public class CassandraMetricsRegistry extends MetricRegistry
{
<span class="fc" id="L44">    public static final CassandraMetricsRegistry Metrics = new CassandraMetricsRegistry();</span>
<span class="fc" id="L45">    private final Map&lt;String, ThreadPoolMetrics&gt; threadPoolMetrics = new ConcurrentHashMap&lt;&gt;();</span>

<span class="fc" id="L47">    private final MBeanWrapper mBeanServer = MBeanWrapper.instance;</span>
<span class="fc" id="L48">    public final static TimeUnit DEFAULT_TIMER_UNIT = TimeUnit.MICROSECONDS;</span>

    private CassandraMetricsRegistry()
    {
<span class="fc" id="L52">        super();</span>
<span class="fc" id="L53">    }</span>

    public Counter counter(MetricName name)
    {
<span class="fc" id="L57">        Counter counter = counter(name.getMetricName());</span>
<span class="fc" id="L58">        registerMBean(counter, name.getMBeanName());</span>

<span class="fc" id="L60">        return counter;</span>
    }

    public Counter counter(MetricName name, MetricName alias)
    {
<span class="fc" id="L65">        Counter counter = counter(name);</span>
<span class="fc" id="L66">        registerAlias(name, alias);</span>
<span class="fc" id="L67">        return counter;</span>
    }

    public Meter meter(MetricName name)
    {
<span class="fc" id="L72">        Meter meter = meter(name.getMetricName());</span>
<span class="fc" id="L73">        registerMBean(meter, name.getMBeanName());</span>

<span class="fc" id="L75">        return meter;</span>
    }

    public Meter meter(MetricName name, MetricName alias)
    {
<span class="fc" id="L80">        Meter meter = meter(name);</span>
<span class="fc" id="L81">        registerAlias(name, alias);</span>
<span class="fc" id="L82">        return meter;</span>
    }

    public Histogram histogram(MetricName name, boolean considerZeroes)
    {
<span class="fc" id="L87">        Histogram histogram = register(name, new ClearableHistogram(new DecayingEstimatedHistogramReservoir(considerZeroes)));</span>
<span class="fc" id="L88">        registerMBean(histogram, name.getMBeanName());</span>

<span class="fc" id="L90">        return histogram;</span>
    }

    public Histogram histogram(MetricName name, MetricName alias, boolean considerZeroes)
    {
<span class="fc" id="L95">        Histogram histogram = histogram(name, considerZeroes);</span>
<span class="fc" id="L96">        registerAlias(name, alias);</span>
<span class="fc" id="L97">        return histogram;</span>
    }

    public Timer timer(MetricName name)
    {
<span class="fc" id="L102">        return timer(name, DEFAULT_TIMER_UNIT);</span>
    }

    public SnapshottingTimer timer(MetricName name, MetricName alias)
    {
<span class="fc" id="L107">        return timer(name, alias, DEFAULT_TIMER_UNIT);</span>
    }

    public SnapshottingTimer timer(MetricName name, TimeUnit durationUnit)
    {
<span class="fc" id="L112">        SnapshottingTimer timer = register(name, new SnapshottingTimer(CassandraMetricsRegistry.createReservoir(durationUnit)));</span>
<span class="fc" id="L113">        registerMBean(timer, name.getMBeanName());</span>
<span class="fc" id="L114">        return timer;</span>
    }

    public SnapshottingTimer timer(MetricName name, MetricName alias, TimeUnit durationUnit)
    {
<span class="fc" id="L119">        SnapshottingTimer timer = timer(name, durationUnit);</span>
<span class="fc" id="L120">        registerAlias(name, alias);</span>
<span class="fc" id="L121">        return timer;</span>
    }

    public static SnapshottingReservoir createReservoir(TimeUnit durationUnit)
    {
        SnapshottingReservoir reservoir;
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        if (durationUnit != TimeUnit.NANOSECONDS)</span>
        {
<span class="fc" id="L129">            SnapshottingReservoir underlying = new DecayingEstimatedHistogramReservoir(DecayingEstimatedHistogramReservoir.DEFAULT_ZERO_CONSIDERATION,</span>
                                                                           DecayingEstimatedHistogramReservoir.LOW_BUCKET_COUNT,
                                                                           DecayingEstimatedHistogramReservoir.DEFAULT_STRIPE_COUNT);
            // fewer buckets should suffice if timer is not based on nanos
<span class="fc" id="L133">            reservoir = new ScalingReservoir(underlying,</span>
                                             // timer update values in nanos.
<span class="fc" id="L135">                                             v -&gt; durationUnit.convert(v, TimeUnit.NANOSECONDS));</span>
<span class="fc" id="L136">        }</span>
        else
        {
            // Use more buckets if timer is created with nanos resolution.
<span class="nc" id="L140">            reservoir = new DecayingEstimatedHistogramReservoir();</span>
        }
<span class="fc" id="L142">        return reservoir;</span>
    }

    public &lt;T extends Metric&gt; T register(MetricName name, T metric)
    {
        try
        {
<span class="fc" id="L149">            register(name.getMetricName(), metric);</span>
<span class="fc" id="L150">            registerMBean(metric, name.getMBeanName());</span>
<span class="fc" id="L151">            return metric;</span>
        }
<span class="fc" id="L153">        catch (IllegalArgumentException e)</span>
        {
<span class="fc" id="L155">            Metric existing = Metrics.getMetrics().get(name.getMetricName());</span>
<span class="fc" id="L156">            return (T)existing;</span>
        }
    }

    public Collection&lt;ThreadPoolMetrics&gt; allThreadPoolMetrics()
    {
<span class="fc" id="L162">        return Collections.unmodifiableCollection(threadPoolMetrics.values());</span>
    }

    public Optional&lt;ThreadPoolMetrics&gt; getThreadPoolMetrics(String poolName)
    {
<span class="nc" id="L167">        return Optional.ofNullable(threadPoolMetrics.get(poolName));</span>
    }

    ThreadPoolMetrics register(ThreadPoolMetrics metrics)
    {
<span class="fc" id="L172">        threadPoolMetrics.put(metrics.poolName, metrics);</span>
<span class="fc" id="L173">        return metrics;</span>
    }

    void remove(ThreadPoolMetrics metrics)
    {
<span class="fc" id="L178">        threadPoolMetrics.remove(metrics.poolName, metrics);</span>
<span class="fc" id="L179">    }</span>

    public &lt;T extends Metric&gt; T register(MetricName name, MetricName aliasName, T metric)
    {
<span class="fc" id="L183">        T ret = register(name, metric);</span>
<span class="fc" id="L184">        registerAlias(name, aliasName);</span>
<span class="fc" id="L185">        return ret;</span>
    }

    public &lt;T extends Metric&gt; T register(MetricName name, T metric, MetricName... aliases)
    {
<span class="fc" id="L190">        T ret = register(name, metric);</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">        for (MetricName aliasName : aliases)</span>
        {
<span class="fc" id="L193">            registerAlias(name, aliasName);</span>
        }
<span class="fc" id="L195">        return ret;</span>
    }

    public boolean remove(MetricName name)
    {
<span class="fc" id="L200">        boolean removed = remove(name.getMetricName());</span>

<span class="fc" id="L202">        mBeanServer.unregisterMBean(name.getMBeanName(), MBeanWrapper.OnException.IGNORE);</span>
<span class="fc" id="L203">        return removed;</span>
    }

    public boolean remove(MetricName name, MetricName... aliases)
    {
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">        if (remove(name))</span>
        {
<span class="fc bfc" id="L210" title="All 2 branches covered.">            for (MetricName alias : aliases)</span>
            {
<span class="fc" id="L212">                removeAlias(alias);</span>
            }
<span class="fc" id="L214">            return true;</span>
        }
<span class="nc" id="L216">        return false;</span>
    }

    public void registerMBean(Metric metric, ObjectName name)
    {
        AbstractBean mbean;

<span class="fc bfc" id="L223" title="All 2 branches covered.">        if (metric instanceof Gauge)</span>
<span class="fc" id="L224">            mbean = new JmxGauge((Gauge&lt;?&gt;) metric, name);</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">        else if (metric instanceof Counter)</span>
<span class="fc" id="L226">            mbean = new JmxCounter((Counter) metric, name);</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">        else if (metric instanceof Histogram)</span>
<span class="fc" id="L228">            mbean = new JmxHistogram((Histogram) metric, name);</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">        else if (metric instanceof Timer)</span>
<span class="fc" id="L230">            mbean = new JmxTimer((Timer) metric, name, TimeUnit.SECONDS, DEFAULT_TIMER_UNIT);</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">        else if (metric instanceof Metered)</span>
<span class="fc" id="L232">            mbean = new JmxMeter((Metered) metric, name, TimeUnit.SECONDS);</span>
        else
<span class="nc" id="L234">            throw new IllegalArgumentException(&quot;Unknown metric type: &quot; + metric.getClass());</span>

<span class="fc bfc" id="L236" title="All 2 branches covered.">        if (!mBeanServer.isRegistered(name))</span>
<span class="fc" id="L237">            mBeanServer.registerMBean(mbean, name, MBeanWrapper.OnException.LOG);</span>
<span class="fc" id="L238">    }</span>

    private void registerAlias(MetricName existingName, MetricName aliasName)
    {
<span class="fc" id="L242">        Metric existing = Metrics.getMetrics().get(existingName.getMetricName());</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">        assert existing != null : existingName + &quot; not registered&quot;;</span>

<span class="fc" id="L245">        registerMBean(existing, aliasName.getMBeanName());</span>
<span class="fc" id="L246">    }</span>

    private void removeAlias(MetricName name)
    {
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        if (mBeanServer.isRegistered(name.getMBeanName()))</span>
<span class="fc" id="L251">            MBeanWrapper.instance.unregisterMBean(name.getMBeanName(), MBeanWrapper.OnException.IGNORE);</span>
<span class="fc" id="L252">    }</span>
    
    /**
     * Strips a single final '$' from input
     * 
     * @param s String to strip
     * @return a string with one less '$' at end
     */
    private static String withoutFinalDollar(String s)
    {
<span class="nc" id="L262">        int l = s.length();</span>
<span class="nc bnc" id="L263" title="All 4 branches missed.">        return (l!=0 &amp;&amp; '$' == s.charAt(l-1))?s.substring(0,l-1):s;</span>
    }

    public interface MetricMBean
    {
        ObjectName objectName();
    }

    private abstract static class AbstractBean implements MetricMBean
    {
        private final ObjectName objectName;

        AbstractBean(ObjectName objectName)
<span class="fc" id="L276">        {</span>
<span class="fc" id="L277">            this.objectName = objectName;</span>
<span class="fc" id="L278">        }</span>

        @Override
        public ObjectName objectName()
        {
<span class="nc" id="L283">            return objectName;</span>
        }
    }


    public interface JmxGaugeMBean extends MetricMBean
    {
        Object getValue();
    }

    private static class JmxGauge extends AbstractBean implements JmxGaugeMBean
    {
        private final Gauge&lt;?&gt; metric;

        private JmxGauge(Gauge&lt;?&gt; metric, ObjectName objectName)
        {
<span class="fc" id="L299">            super(objectName);</span>
<span class="fc" id="L300">            this.metric = metric;</span>
<span class="fc" id="L301">        }</span>

        @Override
        public Object getValue()
        {
<span class="nc" id="L306">            return metric.getValue();</span>
        }
    }

    public interface JmxHistogramMBean extends MetricMBean
    {
        long getCount();

        long getMin();

        long getMax();

        double getMean();

        double getStdDev();

        double get50thPercentile();

        double get75thPercentile();

        double get95thPercentile();

        double get98thPercentile();

        double get99thPercentile();

        double get999thPercentile();

        long[] values();

        long[] getRecentValues();
    }

    private static class JmxHistogram extends AbstractBean implements JmxHistogramMBean
    {
        private final Histogram metric;
<span class="fc" id="L342">        private long[] last = null;</span>

        private JmxHistogram(Histogram metric, ObjectName objectName)
        {
<span class="fc" id="L346">            super(objectName);</span>
<span class="fc" id="L347">            this.metric = metric;</span>
<span class="fc" id="L348">        }</span>

        @Override
        public double get50thPercentile()
        {
<span class="nc" id="L353">            return metric.getSnapshot().getMedian();</span>
        }

        @Override
        public long getCount()
        {
<span class="nc" id="L359">            return metric.getCount();</span>
        }

        @Override
        public long getMin()
        {
<span class="nc" id="L365">            return metric.getSnapshot().getMin();</span>
        }

        @Override
        public long getMax()
        {
<span class="nc" id="L371">            return metric.getSnapshot().getMax();</span>
        }

        @Override
        public double getMean()
        {
<span class="nc" id="L377">            return metric.getSnapshot().getMean();</span>
        }

        @Override
        public double getStdDev()
        {
<span class="nc" id="L383">            return metric.getSnapshot().getStdDev();</span>
        }

        @Override
        public double get75thPercentile()
        {
<span class="nc" id="L389">            return metric.getSnapshot().get75thPercentile();</span>
        }

        @Override
        public double get95thPercentile()
        {
<span class="nc" id="L395">            return metric.getSnapshot().get95thPercentile();</span>
        }

        @Override
        public double get98thPercentile()
        {
<span class="nc" id="L401">            return metric.getSnapshot().get98thPercentile();</span>
        }

        @Override
        public double get99thPercentile()
        {
<span class="nc" id="L407">            return metric.getSnapshot().get99thPercentile();</span>
        }

        @Override
        public double get999thPercentile()
        {
<span class="nc" id="L413">            return metric.getSnapshot().get999thPercentile();</span>
        }

        @Override
        public long[] values()
        {
<span class="nc" id="L419">            return metric.getSnapshot().getValues();</span>
        }

        /**
         * Returns a histogram describing the values recorded since the last time this method was called.
         *
         * ex. If the counts are [0, 1, 2, 1] at the time the first caller arrives, but change to [1, 2, 3, 2] by the 
         * time a second caller arrives, the second caller will receive [1, 1, 1, 1].
         *
         * @return a histogram whose bucket offsets are assumed to be in nanoseconds
         */
        @Override
        public synchronized long[] getRecentValues()
        {
<span class="nc" id="L433">            long[] now = metric.getSnapshot().getValues();</span>
<span class="nc" id="L434">            long[] delta = delta(now, last);</span>
<span class="nc" id="L435">            last = now;</span>
<span class="nc" id="L436">            return delta;</span>
        }
    }

    public interface JmxCounterMBean extends MetricMBean
    {
        long getCount();
    }

    private static class JmxCounter extends AbstractBean implements JmxCounterMBean
    {
        private final Counter metric;

        private JmxCounter(Counter metric, ObjectName objectName)
        {
<span class="fc" id="L451">            super(objectName);</span>
<span class="fc" id="L452">            this.metric = metric;</span>
<span class="fc" id="L453">        }</span>

        @Override
        public long getCount()
        {
<span class="nc" id="L458">            return metric.getCount();</span>
        }
    }

    public interface JmxMeterMBean extends MetricMBean
    {
        long getCount();

        double getMeanRate();

        double getOneMinuteRate();

        double getFiveMinuteRate();

        double getFifteenMinuteRate();

        String getRateUnit();
    }

    private static class JmxMeter extends AbstractBean implements JmxMeterMBean
    {
        private final Metered metric;
        private final double rateFactor;
        private final String rateUnit;

        private JmxMeter(Metered metric, ObjectName objectName, TimeUnit rateUnit)
        {
<span class="fc" id="L485">            super(objectName);</span>
<span class="fc" id="L486">            this.metric = metric;</span>
<span class="fc" id="L487">            this.rateFactor = rateUnit.toSeconds(1);</span>
<span class="fc" id="L488">            this.rateUnit = &quot;events/&quot; + calculateRateUnit(rateUnit);</span>
<span class="fc" id="L489">        }</span>

        @Override
        public long getCount()
        {
<span class="nc" id="L494">            return metric.getCount();</span>
        }

        @Override
        public double getMeanRate()
        {
<span class="nc" id="L500">            return metric.getMeanRate() * rateFactor;</span>
        }

        @Override
        public double getOneMinuteRate()
        {
<span class="nc" id="L506">            return metric.getOneMinuteRate() * rateFactor;</span>
        }

        @Override
        public double getFiveMinuteRate()
        {
<span class="nc" id="L512">            return metric.getFiveMinuteRate() * rateFactor;</span>
        }

        @Override
        public double getFifteenMinuteRate()
        {
<span class="nc" id="L518">            return metric.getFifteenMinuteRate() * rateFactor;</span>
        }

        @Override
        public String getRateUnit()
        {
<span class="nc" id="L524">            return rateUnit;</span>
        }

        private String calculateRateUnit(TimeUnit unit)
        {
<span class="fc" id="L529">            final String s = unit.toString().toLowerCase(Locale.US);</span>
<span class="fc" id="L530">            return s.substring(0, s.length() - 1);</span>
        }
    }

    public interface JmxTimerMBean extends JmxMeterMBean
    {
        double getMin();

        double getMax();

        double getMean();

        double getStdDev();

        double get50thPercentile();

        double get75thPercentile();

        double get95thPercentile();

        double get98thPercentile();

        double get99thPercentile();

        double get999thPercentile();

        long[] values();

        long[] getRecentValues();

        String getDurationUnit();
    }

    static class JmxTimer extends JmxMeter implements JmxTimerMBean
    {
        private final Timer metric;
        private final String durationUnit;
<span class="fc" id="L567">        private long[] last = null;</span>

        private JmxTimer(Timer metric,
                         ObjectName objectName,
                         TimeUnit rateUnit,
                         TimeUnit durationUnit)
        {
<span class="fc" id="L574">            super(metric, objectName, rateUnit);</span>
<span class="fc" id="L575">            this.metric = metric;</span>
<span class="fc" id="L576">            this.durationUnit = durationUnit.toString().toLowerCase(Locale.US);</span>
<span class="fc" id="L577">        }</span>

        @Override
        public double get50thPercentile()
        {
<span class="nc" id="L582">            return metric.getSnapshot().getMedian();</span>
        }

        @Override
        public double getMin()
        {
<span class="nc" id="L588">            return metric.getSnapshot().getMin();</span>
        }

        @Override
        public double getMax()
        {
<span class="nc" id="L594">            return metric.getSnapshot().getMax();</span>
        }

        @Override
        public double getMean()
        {
<span class="nc" id="L600">            return metric.getSnapshot().getMean();</span>
        }

        @Override
        public double getStdDev()
        {
<span class="nc" id="L606">            return metric.getSnapshot().getStdDev();</span>
        }

        @Override
        public double get75thPercentile()
        {
<span class="nc" id="L612">            return metric.getSnapshot().get75thPercentile();</span>
        }

        @Override
        public double get95thPercentile()
        {
<span class="nc" id="L618">            return metric.getSnapshot().get95thPercentile();</span>
        }

        @Override
        public double get98thPercentile()
        {
<span class="nc" id="L624">            return metric.getSnapshot().get98thPercentile();</span>
        }

        @Override
        public double get99thPercentile()
        {
<span class="nc" id="L630">            return metric.getSnapshot().get99thPercentile();</span>
        }

        @Override
        public double get999thPercentile()
        {
<span class="nc" id="L636">            return metric.getSnapshot().get999thPercentile();</span>
        }

        @Override
        public long[] values()
        {
<span class="nc" id="L642">            return metric.getSnapshot().getValues();</span>
        }

        /**
         * Returns a histogram describing the values recorded since the last time this method was called.
         * 
         * ex. If the counts are [0, 1, 2, 1] at the time the first caller arrives, but change to [1, 2, 3, 2] by the 
         * time a second caller arrives, the second caller will receive [1, 1, 1, 1].
         * 
         * @return a histogram whose bucket offsets are assumed to be in nanoseconds
         */
        @Override
        public synchronized long[] getRecentValues()
        {
<span class="nc" id="L656">            long[] now = metric.getSnapshot().getValues();</span>
<span class="nc" id="L657">            long[] delta = delta(now, last);</span>
<span class="nc" id="L658">            last = now;</span>
<span class="nc" id="L659">            return delta;</span>
        }

        @Override
        public String getDurationUnit()
        {
<span class="nc" id="L665">            return durationUnit;</span>
        }
    }

    /**
     * Used to determine the changes in a histogram since the last time checked.
     *
     * @param now The current histogram
     * @param last The previous value of the histogram
     * @return the difference between &lt;i&gt;now&lt;/&gt; and &lt;i&gt;last&lt;/i&gt;
     */
    @VisibleForTesting
    static long[] delta(long[] now, long[] last)
    {
<span class="nc" id="L679">        long[] delta = new long[now.length];</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">        if (last == null)</span>
        {
<span class="nc" id="L682">            last = new long[now.length];</span>
        }
<span class="nc bnc" id="L684" title="All 2 branches missed.">        for(int i = 0; i&lt; now.length; i++)</span>
        {
<span class="nc bnc" id="L686" title="All 2 branches missed.">            delta[i] = now[i] - (i &lt; last.length? last[i] : 0);</span>
        }
<span class="nc" id="L688">        return delta;</span>
    }

    /**
     * A value class encapsulating a metric's owning class and name.
     */
    public static class MetricName implements Comparable&lt;MetricName&gt;
    {
        private final String group;
        private final String type;
        private final String name;
        private final String scope;
        private final String mBeanName;

        /**
         * Creates a new {@link MetricName} without a scope.
         *
         * @param klass the {@link Class} to which the {@link Metric} belongs
         * @param name  the name of the {@link Metric}
         */
        public MetricName(Class&lt;?&gt; klass, String name)
        {
<span class="nc" id="L710">            this(klass, name, null);</span>
<span class="nc" id="L711">        }</span>

        /**
         * Creates a new {@link MetricName} without a scope.
         *
         * @param group the group to which the {@link Metric} belongs
         * @param type  the type to which the {@link Metric} belongs
         * @param name  the name of the {@link Metric}
         */
        public MetricName(String group, String type, String name)
        {
<span class="nc" id="L722">            this(group, type, name, null);</span>
<span class="nc" id="L723">        }</span>

        /**
         * Creates a new {@link MetricName} without a scope.
         *
         * @param klass the {@link Class} to which the {@link Metric} belongs
         * @param name  the name of the {@link Metric}
         * @param scope the scope of the {@link Metric}
         */
        public MetricName(Class&lt;?&gt; klass, String name, String scope)
        {
<span class="nc bnc" id="L734" title="All 2 branches missed.">            this(klass.getPackage() == null ? &quot;&quot; : klass.getPackage().getName(),</span>
<span class="nc" id="L735">                    withoutFinalDollar(klass.getSimpleName()),</span>
                    name,
                    scope);
<span class="nc" id="L738">        }</span>

        /**
         * Creates a new {@link MetricName} without a scope.
         *
         * @param group the group to which the {@link Metric} belongs
         * @param type  the type to which the {@link Metric} belongs
         * @param name  the name of the {@link Metric}
         * @param scope the scope of the {@link Metric}
         */
        public MetricName(String group, String type, String name, String scope)
        {
<span class="nc" id="L750">            this(group, type, name, scope, createMBeanName(group, type, name, scope));</span>
<span class="nc" id="L751">        }</span>

        /**
         * Creates a new {@link MetricName} without a scope.
         *
         * @param group     the group to which the {@link Metric} belongs
         * @param type      the type to which the {@link Metric} belongs
         * @param name      the name of the {@link Metric}
         * @param scope     the scope of the {@link Metric}
         * @param mBeanName the 'ObjectName', represented as a string, to use when registering the
         *                  MBean.
         */
        public MetricName(String group, String type, String name, String scope, String mBeanName)
<span class="fc" id="L764">        {</span>
<span class="pc bpc" id="L765" title="2 of 4 branches missed.">            if (group == null || type == null)</span>
            {
<span class="nc" id="L767">                throw new IllegalArgumentException(&quot;Both group and type need to be specified&quot;);</span>
            }
<span class="pc bpc" id="L769" title="1 of 2 branches missed.">            if (name == null)</span>
            {
<span class="nc" id="L771">                throw new IllegalArgumentException(&quot;Name needs to be specified&quot;);</span>
            }
<span class="fc" id="L773">            this.group = group;</span>
<span class="fc" id="L774">            this.type = type;</span>
<span class="fc" id="L775">            this.name = name;</span>
<span class="fc" id="L776">            this.scope = scope;</span>
<span class="fc" id="L777">            this.mBeanName = mBeanName;</span>
<span class="fc" id="L778">        }</span>

        /**
         * Returns the group to which the {@link Metric} belongs. For class-based metrics, this will be
         * the package name of the {@link Class} to which the {@link Metric} belongs.
         *
         * @return the group to which the {@link Metric} belongs
         */
        public String getGroup()
        {
<span class="nc" id="L788">            return group;</span>
        }

        /**
         * Returns the type to which the {@link Metric} belongs. For class-based metrics, this will be
         * the simple class name of the {@link Class} to which the {@link Metric} belongs.
         *
         * @return the type to which the {@link Metric} belongs
         */
        public String getType()
        {
<span class="nc" id="L799">            return type;</span>
        }

        /**
         * Returns the name of the {@link Metric}.
         *
         * @return the name of the {@link Metric}
         */
        public String getName()
        {
<span class="nc" id="L809">            return name;</span>
        }

        public String getMetricName()
        {
<span class="fc" id="L814">            return MetricRegistry.name(group, type, name, scope);</span>
        }

        /**
         * Returns the scope of the {@link Metric}.
         *
         * @return the scope of the {@link Metric}
         */
        public String getScope()
        {
<span class="nc" id="L824">            return scope;</span>
        }

        /**
         * Returns {@code true} if the {@link Metric} has a scope, {@code false} otherwise.
         *
         * @return {@code true} if the {@link Metric} has a scope
         */
        public boolean hasScope()
        {
<span class="nc bnc" id="L834" title="All 2 branches missed.">            return scope != null;</span>
        }

        /**
         * Returns the MBean name for the {@link Metric} identified by this metric name.
         *
         * @return the MBean name
         */
        public ObjectName getMBeanName()
        {

<span class="fc" id="L845">            String mname = mBeanName;</span>

<span class="pc bpc" id="L847" title="1 of 2 branches missed.">            if (mname == null)</span>
<span class="nc" id="L848">                mname = getMetricName();</span>

            try
            {

<span class="fc" id="L853">                return new ObjectName(mname);</span>
<span class="nc" id="L854">            } catch (MalformedObjectNameException e)</span>
            {
                try
                {
<span class="nc" id="L858">                    return new ObjectName(ObjectName.quote(mname));</span>
<span class="nc" id="L859">                } catch (MalformedObjectNameException e1)</span>
                {
<span class="nc" id="L861">                    throw new RuntimeException(e1);</span>
                }
            }
        }

        @Override
        public boolean equals(Object o)
        {
<span class="nc bnc" id="L869" title="All 2 branches missed.">            if (this == o)</span>
            {
<span class="nc" id="L871">                return true;</span>
            }
<span class="nc bnc" id="L873" title="All 4 branches missed.">            if (o == null || getClass() != o.getClass())</span>
            {
<span class="nc" id="L875">                return false;</span>
            }
<span class="nc" id="L877">            final MetricName that = (MetricName) o;</span>
<span class="nc" id="L878">            return mBeanName.equals(that.mBeanName);</span>
        }

        @Override
        public int hashCode()
        {
<span class="nc" id="L884">            return mBeanName.hashCode();</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L890">            return mBeanName;</span>
        }

        @Override
        public int compareTo(MetricName o)
        {
<span class="nc" id="L896">            return mBeanName.compareTo(o.mBeanName);</span>
        }

        private static String createMBeanName(String group, String type, String name, String scope)
        {
<span class="nc" id="L901">            final StringBuilder nameBuilder = new StringBuilder();</span>
<span class="nc" id="L902">            nameBuilder.append(ObjectName.quote(group));</span>
<span class="nc" id="L903">            nameBuilder.append(&quot;:type=&quot;);</span>
<span class="nc" id="L904">            nameBuilder.append(ObjectName.quote(type));</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">            if (scope != null)</span>
            {
<span class="nc" id="L907">                nameBuilder.append(&quot;,scope=&quot;);</span>
<span class="nc" id="L908">                nameBuilder.append(ObjectName.quote(scope));</span>
            }
<span class="nc bnc" id="L910" title="All 2 branches missed.">            if (name.length() &gt; 0)</span>
            {
<span class="nc" id="L912">                nameBuilder.append(&quot;,name=&quot;);</span>
<span class="nc" id="L913">                nameBuilder.append(ObjectName.quote(name));</span>
            }
<span class="nc" id="L915">            return nameBuilder.toString();</span>
        }

        /**
         * If the group is empty, use the package name of the given class. Otherwise use group
         *
         * @param group The group to use by default
         * @param klass The class being tracked
         * @return a group for the metric
         */
        public static String chooseGroup(String group, Class&lt;?&gt; klass)
        {
<span class="nc bnc" id="L927" title="All 4 branches missed.">            if (group == null || group.isEmpty())</span>
            {
<span class="nc bnc" id="L929" title="All 2 branches missed.">                group = klass.getPackage() == null ? &quot;&quot; : klass.getPackage().getName();</span>
            }
<span class="nc" id="L931">            return group;</span>
        }

        /**
         * If the type is empty, use the simple name of the given class. Otherwise use type
         *
         * @param type  The type to use by default
         * @param klass The class being tracked
         * @return a type for the metric
         */
        public static String chooseType(String type, Class&lt;?&gt; klass)
        {
<span class="nc bnc" id="L943" title="All 4 branches missed.">            if (type == null || type.isEmpty())</span>
            {
<span class="nc" id="L945">                type = withoutFinalDollar(klass.getSimpleName());</span>
            }
<span class="nc" id="L947">            return type;</span>
        }

        /**
         * If name is empty, use the name of the given method. Otherwise use name
         *
         * @param name   The name to use by default
         * @param method The method being tracked
         * @return a name for the metric
         */
        public static String chooseName(String name, Method method)
        {
<span class="nc bnc" id="L959" title="All 4 branches missed.">            if (name == null || name.isEmpty())</span>
            {
<span class="nc" id="L961">                name = method.getName();</span>
            }
<span class="nc" id="L963">            return name;</span>
        }
    }
}


</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>