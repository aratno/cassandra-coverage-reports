<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TableMetrics.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.metrics</a> &gt; <span class="el_source">TableMetrics.java</span></div><h1>TableMetrics.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.metrics;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.EnumMap;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;
import java.util.function.Predicate;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Iterables;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import org.apache.commons.lang3.ArrayUtils;

import com.codahale.metrics.Counter;
import com.codahale.metrics.Gauge;
import com.codahale.metrics.Histogram;
import com.codahale.metrics.Meter;
import com.codahale.metrics.Metric;
import com.codahale.metrics.Timer;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.Keyspace;
import org.apache.cassandra.db.lifecycle.SSTableSet;
import org.apache.cassandra.db.lifecycle.View;
import org.apache.cassandra.db.memtable.Memtable;
import org.apache.cassandra.index.SecondaryIndexManager;
import org.apache.cassandra.io.compress.CompressionMetadata;
import org.apache.cassandra.io.sstable.GaugeProvider;
import org.apache.cassandra.io.sstable.format.SSTableFormat;
import org.apache.cassandra.io.sstable.format.SSTableReader;
import org.apache.cassandra.io.sstable.metadata.MetadataCollector;
import org.apache.cassandra.metrics.Sampler.SamplerType;
import org.apache.cassandra.schema.Schema;
import org.apache.cassandra.schema.SchemaConstants;
import org.apache.cassandra.utils.EstimatedHistogram;
import org.apache.cassandra.utils.ExpMovingAverage;
import org.apache.cassandra.utils.MovingAverage;
import org.apache.cassandra.utils.Pair;

import static java.util.concurrent.TimeUnit.MICROSECONDS;
import static org.apache.cassandra.metrics.CassandraMetricsRegistry.Metrics;
import static org.apache.cassandra.utils.Clock.Global.nanoTime;

/**
 * Metrics for {@link ColumnFamilyStore}.
 */
public class TableMetrics
{
    /**
     * stores metrics that will be rolled into a single global metric
     */
<span class="fc" id="L77">    private static final ConcurrentMap&lt;String, Set&lt;Metric&gt;&gt; ALL_TABLE_METRICS = Maps.newConcurrentMap();</span>
<span class="fc" id="L78">    public static final long[] EMPTY = new long[0];</span>
<span class="fc" id="L79">    private static final MetricNameFactory GLOBAL_FACTORY = new AllTableMetricNameFactory(&quot;Table&quot;);</span>
<span class="fc" id="L80">    private static final MetricNameFactory GLOBAL_ALIAS_FACTORY = new AllTableMetricNameFactory(&quot;ColumnFamily&quot;);</span>

<span class="fc" id="L82">    public final static LatencyMetrics GLOBAL_READ_LATENCY = new LatencyMetrics(GLOBAL_FACTORY, GLOBAL_ALIAS_FACTORY, &quot;Read&quot;);</span>
<span class="fc" id="L83">    public final static LatencyMetrics GLOBAL_WRITE_LATENCY = new LatencyMetrics(GLOBAL_FACTORY, GLOBAL_ALIAS_FACTORY, &quot;Write&quot;);</span>
<span class="fc" id="L84">    public final static LatencyMetrics GLOBAL_RANGE_LATENCY = new LatencyMetrics(GLOBAL_FACTORY, GLOBAL_ALIAS_FACTORY, &quot;Range&quot;);</span>

    /** Total amount of data stored in the memtable that resides on-heap, including column related overhead and partitions overwritten. */
    public final Gauge&lt;Long&gt; memtableOnHeapDataSize;
    /** Total amount of data stored in the memtable that resides off-heap, including column related overhead and partitions overwritten. */
    public final Gauge&lt;Long&gt; memtableOffHeapDataSize;
    /** Total amount of live data stored in the memtable, excluding any data structure overhead */
    public final Gauge&lt;Long&gt; memtableLiveDataSize;
    /** Total amount of data stored in the memtables (2i and pending flush memtables included) that resides on-heap. */
    public final Gauge&lt;Long&gt; allMemtablesOnHeapDataSize;
    /** Total amount of data stored in the memtables (2i and pending flush memtables included) that resides off-heap. */
    public final Gauge&lt;Long&gt; allMemtablesOffHeapDataSize;
    /** Total amount of live data stored in the memtables (2i and pending flush memtables included) that resides off-heap, excluding any data structure overhead */
    public final Gauge&lt;Long&gt; allMemtablesLiveDataSize;
    /** Total number of columns present in the memtable. */
    public final Gauge&lt;Long&gt; memtableColumnsCount;
    /** Number of times flush has resulted in the memtable being switched out. */
    public final Counter memtableSwitchCount;
    /** Current compression ratio for all SSTables */
    public final Gauge&lt;Double&gt; compressionRatio;
    /** Histogram of estimated partition size (in bytes). */
    public final Gauge&lt;long[]&gt; estimatedPartitionSizeHistogram;
    /** Approximate number of keys in table. */
    public final Gauge&lt;Long&gt; estimatedPartitionCount;
    /** Histogram of estimated number of columns. */
    public final Gauge&lt;long[]&gt; estimatedColumnCountHistogram;
    /** Histogram of the number of sstable data files accessed per single partition read */
    public final TableHistogram sstablesPerReadHistogram;
    /** Histogram of the number of sstable data files accessed per partition range read */
    public final TableHistogram sstablesPerRangeReadHistogram;
    /** (Local) read metrics */
    public final LatencyMetrics readLatency;
    /** (Local) range slice metrics */
    public final LatencyMetrics rangeLatency;
    /** (Local) write metrics */
    public final LatencyMetrics writeLatency;
    /** Estimated number of tasks pending for this table */
    public final Counter pendingFlushes;
    /** Total number of bytes flushed since server [re]start */
    public final Counter bytesFlushed;
    /** The average on-disk flushed size for sstables. */
    public final MovingAverage flushSizeOnDisk;
    /** Total number of bytes written by compaction since server [re]start */
    public final Counter compactionBytesWritten;
    /** Estimate of number of pending compactios for this table */
    public final Gauge&lt;Integer&gt; pendingCompactions;
    /** Number of SSTables on disk for this CF */
    public final Gauge&lt;Integer&gt; liveSSTableCount;
    /** Number of SSTables with old version on disk for this CF */
    public final Gauge&lt;Integer&gt; oldVersionSSTableCount;
    /** Maximum duration of an SSTable for this table, computed as maxTimestamp - minTimestamp*/
    public final Gauge&lt;Long&gt; maxSSTableDuration;
    /** Maximum size of SSTable of this table - the physical size on disk of all components for such SSTable in bytes*/
    public final Gauge&lt;Long&gt; maxSSTableSize;
    /** Disk space used by SSTables belonging to this table */
    public final Counter liveDiskSpaceUsed;
    /** Uncompressed/logical disk space used by SSTables belonging to this table */
    public final Counter uncompressedLiveDiskSpaceUsed;
    /** Total disk space used by SSTables belonging to this table, including obsolete ones waiting to be GC'd */
    public final Counter totalDiskSpaceUsed;
    /** Size of the smallest compacted partition */
    public final Gauge&lt;Long&gt; minPartitionSize;
    /** Size of the largest compacted partition */
    public final Gauge&lt;Long&gt; maxPartitionSize;
    /** Size of the smallest compacted partition */
    public final Gauge&lt;Long&gt; meanPartitionSize;
    /** Off heap memory used by compression meta data*/
    public final Gauge&lt;Long&gt; compressionMetadataOffHeapMemoryUsed;
    /** Tombstones scanned in queries on this CF */
    public final TableHistogram tombstoneScannedHistogram;
    /** Live rows scanned in queries on this CF */
    public final TableHistogram liveScannedHistogram;
    /** Column update time delta on this CF */
    public final TableHistogram colUpdateTimeDeltaHistogram;
    /** time taken acquiring the partition lock for materialized view updates for this table */
    public final TableTimer viewLockAcquireTime;
    /** time taken during the local read of a materialized view update */
    public final TableTimer viewReadTime;
    /** Disk space used by snapshot files which */
    public final Gauge&lt;Long&gt; trueSnapshotsSize;
    /** Row cache hits, but result out of range */
    public final Counter rowCacheHitOutOfRange;
    /** Number of row cache hits */
    public final Counter rowCacheHit;
    /** Number of row cache misses */
    public final Counter rowCacheMiss;
    /**
     * Number of tombstone read failures
     */
    public final Counter tombstoneFailures;
    /**
     * Number of tombstone read warnings
     */
    public final Counter tombstoneWarnings;
    /** CAS Prepare metrics */
    public final LatencyMetrics casPrepare;
    /** CAS Propose metrics */
    public final LatencyMetrics casPropose;
    /** CAS Commit metrics */
    public final LatencyMetrics casCommit;
    /** percent of the data that is repaired */
    public final Gauge&lt;Double&gt; percentRepaired;
    /** Reports the size of sstables in repaired, unrepaired, and any ongoing repair buckets */
    public final Gauge&lt;Long&gt; bytesRepaired;
    public final Gauge&lt;Long&gt; bytesUnrepaired;
    public final Gauge&lt;Long&gt; bytesPendingRepair;
    /** Number of started repairs as coordinator on this table */
    public final Counter repairsStarted;
    /** Number of completed repairs as coordinator on this table */
    public final Counter repairsCompleted;
    /** time spent anticompacting data before participating in a consistent repair */
    public final TableTimer anticompactionTime;
    /** time spent creating merkle trees */
    public final TableTimer validationTime;
    /** time spent syncing data in a repair */
    public final TableTimer repairSyncTime;
    /** approximate number of bytes read while creating merkle trees */
    public final TableHistogram bytesValidated;
    /** number of partitions read creating merkle trees */
    public final TableHistogram partitionsValidated;
    /** number of bytes read while doing anticompaction */
    public final Counter bytesAnticompacted;
    /** number of bytes where the whole sstable was contained in a repairing range so that we only mutated the repair status */
    public final Counter bytesMutatedAnticompaction;
    /** ratio of how much we anticompact vs how much we could mutate the repair status*/
    public final Gauge&lt;Double&gt; mutatedAnticompactionGauge;

    public final SnapshottingTimer coordinatorReadLatency;
    public final Timer coordinatorScanLatency;
    public final SnapshottingTimer coordinatorWriteLatency;

    private final MetricNameFactory factory;
    private final MetricNameFactory aliasFactory;

    public final Counter speculativeRetries;
    public final Counter speculativeFailedRetries;
    public final Counter speculativeInsufficientReplicas;
    public final Gauge&lt;Long&gt; speculativeSampleLatencyNanos;

    public final Counter additionalWrites;
    public final Gauge&lt;Long&gt; additionalWriteLatencyNanos;

    public final Gauge&lt;Integer&gt; unleveledSSTables;

    /**
     * Metrics for inconsistencies detected between repaired data sets across replicas. These
     * are tracked on the coordinator.
     */
    // Incremented where an inconsistency is detected and there are no pending repair sessions affecting
    // the data being read, indicating a genuine mismatch between replicas' repaired data sets.
    public final TableMeter confirmedRepairedInconsistencies;
    // Incremented where an inconsistency is detected, but there are pending &amp; uncommitted repair sessions
    // in play on at least one replica. This may indicate a false positive as the inconsistency could be due to
    // replicas marking the repair session as committed at slightly different times and so some consider it to
    // be part of the repaired set whilst others do not.
    public final TableMeter unconfirmedRepairedInconsistencies;

    // Tracks the amount overreading of repaired data replicas perform in order to produce digests
    // at query time. For each query, on a full data read following an initial digest mismatch, the replicas
    // may read extra repaired data, up to the DataLimit of the command, so that the coordinator can compare
    // the repaired data on each replica. These are tracked on each replica.
    public final TableHistogram repairedDataTrackingOverreadRows;
    public final TableTimer repairedDataTrackingOverreadTime;

    /** When sampler activated, will track the most frequently read partitions **/
    public final Sampler&lt;ByteBuffer&gt; topReadPartitionFrequency;
    /** When sampler activated, will track the most frequently written to partitions **/
    public final Sampler&lt;ByteBuffer&gt; topWritePartitionFrequency;
    /** When sampler activated, will track the largest mutations **/
    public final Sampler&lt;ByteBuffer&gt; topWritePartitionSize;
    /** When sampler activated, will track the most frequent partitions with cas contention **/
    public final Sampler&lt;ByteBuffer&gt; topCasPartitionContention;
    /** When sampler activated, will track the slowest local reads **/
    public final Sampler&lt;String&gt; topLocalReadQueryTime;
    /** When sampler activated, will track partitions read with the most rows **/
    public final Sampler&lt;ByteBuffer&gt; topReadPartitionRowCount;
    /** When sampler activated, will track partitions read with the most tombstones **/
    public final Sampler&lt;ByteBuffer&gt; topReadPartitionTombstoneCount;
    /** When sample activated, will track partitions read with the most merged sstables **/
    public final Sampler&lt;ByteBuffer&gt; topReadPartitionSSTableCount;

    public final TableMeter clientTombstoneWarnings;
    public final TableMeter clientTombstoneAborts;

    public final TableMeter coordinatorReadSizeWarnings;
    public final TableMeter coordinatorReadSizeAborts;
    public final TableHistogram coordinatorReadSize;

    public final TableMeter localReadSizeWarnings;
    public final TableMeter localReadSizeAborts;
    public final TableHistogram localReadSize;

    public final TableMeter rowIndexSizeWarnings;
    public final TableMeter rowIndexSizeAborts;
    public final TableHistogram rowIndexSize;

    public final ImmutableMap&lt;SSTableFormat&lt;?, ?&gt;, ImmutableMap&lt;String, Gauge&lt;? extends Number&gt;&gt;&gt; formatSpecificGauges;

    private static Pair&lt;Long, Long&gt; totalNonSystemTablesSize(Predicate&lt;SSTableReader&gt; predicate)
    {
<span class="nc" id="L284">        long total = 0;</span>
<span class="nc" id="L285">        long filtered = 0;</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">        for (String keyspace : Schema.instance.getNonSystemKeyspaces().names())</span>
        {

<span class="nc" id="L289">            Keyspace k = Schema.instance.getKeyspaceInstance(keyspace);</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">            if (SchemaConstants.DISTRIBUTED_KEYSPACE_NAME.equals(k.getName()))</span>
<span class="nc" id="L291">                continue;</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">            if (k.getReplicationStrategy().getReplicationFactor().allReplicas &lt; 2)</span>
<span class="nc" id="L293">                continue;</span>

<span class="nc bnc" id="L295" title="All 2 branches missed.">            for (ColumnFamilyStore cf : k.getColumnFamilyStores())</span>
            {
<span class="nc bnc" id="L297" title="All 2 branches missed.">                if (!SecondaryIndexManager.isIndexColumnFamily(cf.name))</span>
                {
<span class="nc bnc" id="L299" title="All 2 branches missed.">                    for (SSTableReader sstable : cf.getSSTables(SSTableSet.CANONICAL))</span>
                    {
<span class="nc bnc" id="L301" title="All 2 branches missed.">                        if (predicate.test(sstable))</span>
                        {
<span class="nc" id="L303">                            filtered += sstable.uncompressedLength();</span>
                        }
<span class="nc" id="L305">                        total += sstable.uncompressedLength();</span>
<span class="nc" id="L306">                    }</span>
                }
<span class="nc" id="L308">            }</span>
<span class="nc" id="L309">        }</span>
<span class="nc" id="L310">        return Pair.create(filtered, total);</span>
    }

<span class="fc" id="L313">    public static final Gauge&lt;Double&gt; globalPercentRepaired = Metrics.register(GLOBAL_FACTORY.createMetricName(&quot;PercentRepaired&quot;),</span>
                                                                               new Gauge&lt;Double&gt;()
<span class="fc" id="L315">    {</span>
        public Double getValue()
        {
<span class="nc" id="L318">            Pair&lt;Long, Long&gt; result = totalNonSystemTablesSize(SSTableReader::isRepaired);</span>
<span class="nc" id="L319">            double repaired = result.left;</span>
<span class="nc" id="L320">            double total = result.right;</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">            return total &gt; 0 ? (repaired / total) * 100 : 100.0;</span>
        }
    });

<span class="fc" id="L325">    public static final Gauge&lt;Long&gt; globalBytesRepaired = Metrics.register(GLOBAL_FACTORY.createMetricName(&quot;BytesRepaired&quot;),</span>
<span class="nc" id="L326">                                                                           () -&gt; totalNonSystemTablesSize(SSTableReader::isRepaired).left);</span>

<span class="fc" id="L328">    public static final Gauge&lt;Long&gt; globalBytesUnrepaired = </span>
<span class="fc" id="L329">        Metrics.register(GLOBAL_FACTORY.createMetricName(&quot;BytesUnrepaired&quot;),</span>
<span class="nc bnc" id="L330" title="All 4 branches missed.">                         () -&gt; totalNonSystemTablesSize(s -&gt; !s.isRepaired() &amp;&amp; !s.isPendingRepair()).left);</span>

<span class="fc" id="L332">    public static final Gauge&lt;Long&gt; globalBytesPendingRepair = </span>
<span class="fc" id="L333">        Metrics.register(GLOBAL_FACTORY.createMetricName(&quot;BytesPendingRepair&quot;),</span>
<span class="nc" id="L334">                         () -&gt; totalNonSystemTablesSize(SSTableReader::isPendingRepair).left);</span>

    public final Meter readRepairRequests;
    public final Meter shortReadProtectionRequests;
    
    public final Meter replicaFilteringProtectionRequests;
    
    /**
     * This histogram records the maximum number of rows {@link org.apache.cassandra.service.reads.ReplicaFilteringProtection}
     * caches at a point in time per query. With no replica divergence, this is equivalent to the maximum number of
     * cached rows in a single partition during a query. It can be helpful when choosing appropriate values for the
     * replica_filtering_protection thresholds in cassandra.yaml.
     */
    public final Histogram rfpRowsCachedPerQuery;

    public final EnumMap&lt;SamplerType, Sampler&lt;?&gt;&gt; samplers;

    /**
     * Stores all metrics created that can be used when unregistering
     */
<span class="fc" id="L354">    private final Set&lt;ReleasableMetric&gt; all = Sets.newHashSet();</span>

    private interface GetHistogram
    {
        EstimatedHistogram getHistogram(SSTableReader reader);
    }

    private static long[] combineHistograms(Iterable&lt;SSTableReader&gt; sstables, GetHistogram getHistogram)
    {
<span class="nc" id="L363">        Iterator&lt;SSTableReader&gt; iterator = sstables.iterator();</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">        if (!iterator.hasNext())</span>
        {
<span class="nc" id="L366">            return ArrayUtils.EMPTY_LONG_ARRAY;</span>
        }
<span class="nc" id="L368">        long[] firstBucket = getHistogram.getHistogram(iterator.next()).getBuckets(false);</span>
<span class="nc" id="L369">        long[] values = Arrays.copyOf(firstBucket, firstBucket.length);</span>

<span class="nc bnc" id="L371" title="All 2 branches missed.">        while (iterator.hasNext())</span>
        {
<span class="nc" id="L373">            long[] nextBucket = getHistogram.getHistogram(iterator.next()).getBuckets(false);</span>
<span class="nc" id="L374">            values = addHistogram(values, nextBucket);</span>
<span class="nc" id="L375">        }</span>
<span class="nc" id="L376">        return values;</span>
    }

    @VisibleForTesting
    public static long[] addHistogram(long[] sums, long[] buckets)
    {
<span class="nc bnc" id="L382" title="All 2 branches missed.">        if (buckets.length &gt; sums.length)</span>
        {
<span class="nc" id="L384">            sums = Arrays.copyOf(sums, buckets.length);</span>
        }

<span class="nc bnc" id="L387" title="All 2 branches missed.">        for (int i = 0; i &lt; buckets.length; i++)</span>
        {
<span class="nc" id="L389">            sums[i] += buckets[i];</span>
        }
<span class="nc" id="L391">        return sums;</span>
    }

    /**
     * Creates metrics for given {@link ColumnFamilyStore}.
     *
     * @param cfs ColumnFamilyStore to measure metrics
     */
    public TableMetrics(final ColumnFamilyStore cfs, ReleasableMetric memtableMetrics)
<span class="fc" id="L400">    {</span>
<span class="fc" id="L401">        factory = new TableMetricNameFactory(cfs, &quot;Table&quot;);</span>
<span class="fc" id="L402">        aliasFactory = new TableMetricNameFactory(cfs, &quot;ColumnFamily&quot;);</span>

<span class="pc bpc" id="L404" title="1 of 2 branches missed.">        if (memtableMetrics != null)</span>
        {
<span class="nc" id="L406">            all.add(memtableMetrics);</span>
        }

<span class="fc" id="L409">        samplers = new EnumMap&lt;&gt;(SamplerType.class);</span>
<span class="fc" id="L410">        topReadPartitionFrequency = new FrequencySampler&lt;ByteBuffer&gt;()</span>
<span class="fc" id="L411">        {</span>
            public String toString(ByteBuffer value)
            {
<span class="nc" id="L414">                return cfs.metadata().partitionKeyType.getString(value);</span>
            }
        };
<span class="fc" id="L417">        topWritePartitionFrequency = new FrequencySampler&lt;ByteBuffer&gt;()</span>
<span class="fc" id="L418">        {</span>
            public String toString(ByteBuffer value)
            {
<span class="nc" id="L421">                return cfs.metadata().partitionKeyType.getString(value);</span>
            }
        };
<span class="fc" id="L424">        topWritePartitionSize = new MaxSampler&lt;ByteBuffer&gt;()</span>
<span class="fc" id="L425">        {</span>
            public String toString(ByteBuffer value)
            {
<span class="nc" id="L428">                return cfs.metadata().partitionKeyType.getString(value);</span>
            }
        };
<span class="fc" id="L431">        topCasPartitionContention = new FrequencySampler&lt;ByteBuffer&gt;()</span>
<span class="fc" id="L432">        {</span>
            public String toString(ByteBuffer value)
            {
<span class="nc" id="L435">                return cfs.metadata().partitionKeyType.getString(value);</span>
            }
        };
<span class="fc" id="L438">        topLocalReadQueryTime = new MaxSampler&lt;String&gt;()</span>
<span class="fc" id="L439">        {</span>
            public String toString(String value)
            {
<span class="nc" id="L442">                return value;</span>
            }
        };

<span class="fc" id="L446">        topReadPartitionRowCount = new MaxSampler&lt;ByteBuffer&gt;()</span>
<span class="fc" id="L447">        {</span>
            public String toString(ByteBuffer value)
            {
<span class="nc" id="L450">                return cfs.metadata().partitionKeyType.getString(value);</span>
            }
        };

<span class="fc" id="L454">        topReadPartitionTombstoneCount = new MaxSampler&lt;ByteBuffer&gt;()</span>
<span class="fc" id="L455">        {</span>
            public String toString(ByteBuffer value)
            {
<span class="nc" id="L458">                return cfs.metadata().partitionKeyType.getString(value);</span>
            }
        };

<span class="fc" id="L462">        topReadPartitionSSTableCount = new MaxSampler&lt;ByteBuffer&gt;()</span>
<span class="fc" id="L463">        {</span>
            @Override
            public String toString(ByteBuffer value)
            {
<span class="nc" id="L467">                return cfs.metadata().partitionKeyType.getString(value);</span>
            }
        };

<span class="fc" id="L471">        samplers.put(SamplerType.READS, topReadPartitionFrequency);</span>
<span class="fc" id="L472">        samplers.put(SamplerType.WRITES, topWritePartitionFrequency);</span>
<span class="fc" id="L473">        samplers.put(SamplerType.WRITE_SIZE, topWritePartitionSize);</span>
<span class="fc" id="L474">        samplers.put(SamplerType.CAS_CONTENTIONS, topCasPartitionContention);</span>
<span class="fc" id="L475">        samplers.put(SamplerType.LOCAL_READ_TIME, topLocalReadQueryTime);</span>
<span class="fc" id="L476">        samplers.put(SamplerType.READ_ROW_COUNT, topReadPartitionRowCount);</span>
<span class="fc" id="L477">        samplers.put(SamplerType.READ_TOMBSTONE_COUNT, topReadPartitionTombstoneCount);</span>
<span class="fc" id="L478">        samplers.put(SamplerType.READ_SSTABLE_COUNT, topReadPartitionSSTableCount);</span>

<span class="fc" id="L480">        memtableColumnsCount = createTableGauge(&quot;MemtableColumnsCount&quot;, </span>
<span class="fc" id="L481">                                                () -&gt; cfs.getTracker().getView().getCurrentMemtable().operationCount());</span>

        // MemtableOnHeapSize naming deprecated in 4.0
<span class="fc" id="L484">        memtableOnHeapDataSize = createTableGaugeWithDeprecation(&quot;MemtableOnHeapDataSize&quot;, &quot;MemtableOnHeapSize&quot;, </span>
<span class="nc" id="L485">                                                                 () -&gt; Memtable.getMemoryUsage(cfs.getTracker().getView().getCurrentMemtable()).ownsOnHeap,</span>
                                                                 new GlobalTableGauge(&quot;MemtableOnHeapDataSize&quot;));

        // MemtableOffHeapSize naming deprecated in 4.0
<span class="fc" id="L489">        memtableOffHeapDataSize = createTableGaugeWithDeprecation(&quot;MemtableOffHeapDataSize&quot;, &quot;MemtableOffHeapSize&quot;, </span>
<span class="nc" id="L490">                                                                  () -&gt; Memtable.getMemoryUsage(cfs.getTracker().getView().getCurrentMemtable()).ownsOffHeap,</span>
                                                                  new GlobalTableGauge(&quot;MemtableOnHeapDataSize&quot;));
        
<span class="fc" id="L493">        memtableLiveDataSize = createTableGauge(&quot;MemtableLiveDataSize&quot;, </span>
<span class="fc" id="L494">                                                () -&gt; cfs.getTracker().getView().getCurrentMemtable().getLiveDataSize());</span>

        // AllMemtablesHeapSize naming deprecated in 4.0
<span class="fc" id="L497">        allMemtablesOnHeapDataSize = createTableGaugeWithDeprecation(&quot;AllMemtablesOnHeapDataSize&quot;, &quot;AllMemtablesHeapSize&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L498">        {</span>
            public Long getValue()
            {
<span class="nc" id="L501">                return getMemoryUsageWithIndexes(cfs).ownsOnHeap;</span>
            }
        }, new GlobalTableGauge(&quot;AllMemtablesOnHeapDataSize&quot;));

        // AllMemtablesOffHeapSize naming deprecated in 4.0
<span class="fc" id="L506">        allMemtablesOffHeapDataSize = createTableGaugeWithDeprecation(&quot;AllMemtablesOffHeapDataSize&quot;, &quot;AllMemtablesOffHeapSize&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L507">        {</span>
            public Long getValue()
            {
<span class="nc" id="L510">                return getMemoryUsageWithIndexes(cfs).ownsOffHeap;</span>
            }
        }, new GlobalTableGauge(&quot;AllMemtablesOffHeapDataSize&quot;));
<span class="fc" id="L513">        allMemtablesLiveDataSize = createTableGauge(&quot;AllMemtablesLiveDataSize&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L514">        {</span>
            public Long getValue()
            {
<span class="nc" id="L517">                long size = 0;</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">                for (ColumnFamilyStore cfs2 : cfs.concatWithIndexes())</span>
<span class="nc" id="L519">                    size += cfs2.getTracker().getView().getCurrentMemtable().getLiveDataSize();</span>
<span class="nc" id="L520">                return size;</span>
            }
        });
<span class="fc" id="L523">        memtableSwitchCount = createTableCounter(&quot;MemtableSwitchCount&quot;);</span>
<span class="fc" id="L524">        estimatedPartitionSizeHistogram = createTableGauge(&quot;EstimatedPartitionSizeHistogram&quot;, &quot;EstimatedRowSizeHistogram&quot;,</span>
<span class="nc" id="L525">                                                           () -&gt; combineHistograms(cfs.getSSTables(SSTableSet.CANONICAL),</span>
                                                                                   SSTableReader::getEstimatedPartitionSize), null);
        
<span class="fc" id="L528">        estimatedPartitionCount = createTableGauge(&quot;EstimatedPartitionCount&quot;, &quot;EstimatedRowCount&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L529">        {</span>
            public Long getValue()
            {
<span class="nc" id="L532">                long memtablePartitions = 0;</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">                for (Memtable memtable : cfs.getTracker().getView().getAllMemtables())</span>
<span class="nc" id="L534">                   memtablePartitions += memtable.partitionCount();</span>
<span class="nc" id="L535">                try(ColumnFamilyStore.RefViewFragment refViewFragment = cfs.selectAndReference(View.selectFunction(SSTableSet.CANONICAL)))</span>
                {
<span class="nc" id="L537">                    return SSTableReader.getApproximateKeyCount(refViewFragment.sstables) + memtablePartitions;</span>
                }
            }
        }, null);
<span class="fc" id="L541">        estimatedColumnCountHistogram = createTableGauge(&quot;EstimatedColumnCountHistogram&quot;, &quot;EstimatedColumnCountHistogram&quot;,</span>
<span class="nc" id="L542">                                                         () -&gt; combineHistograms(cfs.getSSTables(SSTableSet.CANONICAL), </span>
                                                                                 SSTableReader::getEstimatedCellPerPartitionCount), null);
        
<span class="fc" id="L545">        sstablesPerReadHistogram = createTableHistogram(&quot;SSTablesPerReadHistogram&quot;, cfs.keyspace.metric.sstablesPerReadHistogram, true);</span>
<span class="fc" id="L546">        sstablesPerRangeReadHistogram = createTableHistogram(&quot;SSTablesPerRangeReadHistogram&quot;, cfs.keyspace.metric.sstablesPerRangeReadHistogram, true);</span>
<span class="fc" id="L547">        compressionRatio = createTableGauge(&quot;CompressionRatio&quot;, new Gauge&lt;Double&gt;()</span>
<span class="fc" id="L548">        {</span>
            public Double getValue()
            {
<span class="nc" id="L551">                return computeCompressionRatio(cfs.getSSTables(SSTableSet.CANONICAL));</span>
            }
        }, new Gauge&lt;Double&gt;() // global gauge
<span class="fc" id="L554">        {</span>
            public Double getValue()
            {
<span class="nc" id="L557">                List&lt;SSTableReader&gt; sstables = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L558">                Keyspace.all().forEach(ks -&gt; sstables.addAll(ks.getAllSSTables(SSTableSet.CANONICAL)));</span>
<span class="nc" id="L559">                return computeCompressionRatio(sstables);</span>
            }
        });
<span class="fc" id="L562">        percentRepaired = createTableGauge(&quot;PercentRepaired&quot;, new Gauge&lt;Double&gt;()</span>
<span class="fc" id="L563">        {</span>
            public Double getValue()
            {
<span class="nc" id="L566">                double repaired = 0;</span>
<span class="nc" id="L567">                double total = 0;</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">                for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))</span>
                {
<span class="nc bnc" id="L570" title="All 2 branches missed.">                    if (sstable.isRepaired())</span>
                    {
<span class="nc" id="L572">                        repaired += sstable.uncompressedLength();</span>
                    }
<span class="nc" id="L574">                    total += sstable.uncompressedLength();</span>
<span class="nc" id="L575">                }</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">                return total &gt; 0 ? (repaired / total) * 100 : 100.0;</span>
            }
        });

<span class="fc" id="L580">        bytesRepaired = createTableGauge(&quot;BytesRepaired&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L581">        {</span>
            public Long getValue()
            {
<span class="nc" id="L584">                long size = 0;</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">                for (SSTableReader sstable: Iterables.filter(cfs.getSSTables(SSTableSet.CANONICAL), SSTableReader::isRepaired))</span>
                {
<span class="nc" id="L587">                    size += sstable.uncompressedLength();</span>
<span class="nc" id="L588">                }</span>
<span class="nc" id="L589">                return size;</span>
            }
        });

<span class="fc" id="L593">        bytesUnrepaired = createTableGauge(&quot;BytesUnrepaired&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L594">        {</span>
            public Long getValue()
            {
<span class="nc" id="L597">                long size = 0;</span>
<span class="nc bnc" id="L598" title="All 6 branches missed.">                for (SSTableReader sstable: Iterables.filter(cfs.getSSTables(SSTableSet.CANONICAL), s -&gt; !s.isRepaired() &amp;&amp; !s.isPendingRepair()))</span>
                {
<span class="nc" id="L600">                    size += sstable.uncompressedLength();</span>
<span class="nc" id="L601">                }</span>
<span class="nc" id="L602">                return size;</span>
            }
        });

<span class="fc" id="L606">        bytesPendingRepair = createTableGauge(&quot;BytesPendingRepair&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L607">        {</span>
            public Long getValue()
            {
<span class="nc" id="L610">                long size = 0;</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">                for (SSTableReader sstable: Iterables.filter(cfs.getSSTables(SSTableSet.CANONICAL), SSTableReader::isPendingRepair))</span>
                {
<span class="nc" id="L613">                    size += sstable.uncompressedLength();</span>
<span class="nc" id="L614">                }</span>
<span class="nc" id="L615">                return size;</span>
            }
        });

<span class="fc" id="L619">        readLatency = createLatencyMetrics(&quot;Read&quot;, cfs.keyspace.metric.readLatency, GLOBAL_READ_LATENCY);</span>
<span class="fc" id="L620">        writeLatency = createLatencyMetrics(&quot;Write&quot;, cfs.keyspace.metric.writeLatency, GLOBAL_WRITE_LATENCY);</span>
<span class="fc" id="L621">        rangeLatency = createLatencyMetrics(&quot;Range&quot;, cfs.keyspace.metric.rangeLatency, GLOBAL_RANGE_LATENCY);</span>
<span class="fc" id="L622">        pendingFlushes = createTableCounter(&quot;PendingFlushes&quot;);</span>
<span class="fc" id="L623">        bytesFlushed = createTableCounter(&quot;BytesFlushed&quot;);</span>
<span class="fc" id="L624">        flushSizeOnDisk = ExpMovingAverage.decayBy1000();</span>

<span class="fc" id="L626">        compactionBytesWritten = createTableCounter(&quot;CompactionBytesWritten&quot;);</span>
<span class="pc" id="L627">        pendingCompactions = createTableGauge(&quot;PendingCompactions&quot;, () -&gt; cfs.getCompactionStrategyManager().getEstimatedRemainingTasks());</span>
<span class="pc" id="L628">        liveSSTableCount = createTableGauge(&quot;LiveSSTableCount&quot;, () -&gt; cfs.getTracker().getView().liveSSTables().size());</span>
<span class="fc" id="L629">        oldVersionSSTableCount = createTableGauge(&quot;OldVersionSSTableCount&quot;, new Gauge&lt;Integer&gt;()</span>
<span class="fc" id="L630">        {</span>
            public Integer getValue()
            {
<span class="nc" id="L633">                int count = 0;</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">                for (SSTableReader sstable : cfs.getLiveSSTables())</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">                    if (!sstable.descriptor.version.isLatestVersion())</span>
<span class="nc" id="L636">                        count++;</span>
<span class="nc" id="L637">                return count;</span>
            }
        });
<span class="fc" id="L640">        maxSSTableDuration = createTableGauge(&quot;MaxSSTableDuration&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L641">        {</span>
            @Override
            public Long getValue()
            {
<span class="nc" id="L645">                return cfs.getTracker()</span>
<span class="nc" id="L646">                          .getView()</span>
<span class="nc" id="L647">                          .liveSSTables()</span>
<span class="nc" id="L648">                          .stream()</span>
<span class="nc bnc" id="L649" title="All 4 branches missed.">                          .filter(sstable -&gt; sstable.getMinTimestamp() != Long.MAX_VALUE &amp;&amp; sstable.getMaxTimestamp() != Long.MAX_VALUE)</span>
<span class="nc" id="L650">                          .map(ssTableReader -&gt; ssTableReader.getMaxTimestamp() - ssTableReader.getMinTimestamp())</span>
<span class="nc" id="L651">                          .max(Long::compare)</span>
<span class="nc" id="L652">                          .orElse(0L) / 1000;</span>
            }
        });
<span class="fc" id="L655">        maxSSTableSize = createTableGauge(&quot;MaxSSTableSize&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L656">        {</span>
            @Override
            public Long getValue()
            {
<span class="nc" id="L660">                return cfs.getTracker()</span>
<span class="nc" id="L661">                          .getView()</span>
<span class="nc" id="L662">                          .liveSSTables()</span>
<span class="nc" id="L663">                          .stream()</span>
<span class="nc" id="L664">                          .map(SSTableReader::bytesOnDisk)</span>
<span class="nc" id="L665">                          .max(Long::compare)</span>
<span class="nc" id="L666">                          .orElse(0L);</span>
            }
        });
<span class="fc" id="L669">        liveDiskSpaceUsed = createTableCounter(&quot;LiveDiskSpaceUsed&quot;);</span>
<span class="fc" id="L670">        uncompressedLiveDiskSpaceUsed = createTableCounter(&quot;UncompressedLiveDiskSpaceUsed&quot;);</span>
<span class="fc" id="L671">        totalDiskSpaceUsed = createTableCounter(&quot;TotalDiskSpaceUsed&quot;);</span>
<span class="fc" id="L672">        minPartitionSize = createTableGauge(&quot;MinPartitionSize&quot;, &quot;MinRowSize&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L673">        {</span>
            public Long getValue()
            {
<span class="nc" id="L676">                long min = 0;</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">                for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))</span>
                {
<span class="nc bnc" id="L679" title="All 4 branches missed.">                    if (min == 0 || sstable.getEstimatedPartitionSize().min() &lt; min)</span>
<span class="nc" id="L680">                        min = sstable.getEstimatedPartitionSize().min();</span>
<span class="nc" id="L681">                }</span>
<span class="nc" id="L682">                return min;</span>
            }
        }, new Gauge&lt;Long&gt;() // global gauge
<span class="fc" id="L685">        {</span>
            public Long getValue()
            {
<span class="nc" id="L688">                long min = Long.MAX_VALUE;</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">                for (Metric cfGauge : ALL_TABLE_METRICS.get(&quot;MinPartitionSize&quot;))</span>
                {
<span class="nc" id="L691">                    min = Math.min(min, ((Gauge&lt;? extends Number&gt;) cfGauge).getValue().longValue());</span>
<span class="nc" id="L692">                }</span>
<span class="nc" id="L693">                return min;</span>
            }
        });
<span class="fc" id="L696">        maxPartitionSize = createTableGauge(&quot;MaxPartitionSize&quot;, &quot;MaxRowSize&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L697">        {</span>
            public Long getValue()
            {
<span class="nc" id="L700">                long max = 0;</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">                for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))</span>
                {
<span class="nc bnc" id="L703" title="All 2 branches missed.">                    if (sstable.getEstimatedPartitionSize().max() &gt; max)</span>
<span class="nc" id="L704">                        max = sstable.getEstimatedPartitionSize().max();</span>
<span class="nc" id="L705">                }</span>
<span class="nc" id="L706">                return max;</span>
            }
        }, new Gauge&lt;Long&gt;() // global gauge
<span class="fc" id="L709">        {</span>
            public Long getValue()
            {
<span class="nc" id="L712">                long max = 0;</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">                for (Metric cfGauge : ALL_TABLE_METRICS.get(&quot;MaxPartitionSize&quot;))</span>
                {
<span class="nc" id="L715">                    max = Math.max(max, ((Gauge&lt;? extends Number&gt;) cfGauge).getValue().longValue());</span>
<span class="nc" id="L716">                }</span>
<span class="nc" id="L717">                return max;</span>
            }
        });
<span class="fc" id="L720">        meanPartitionSize = createTableGauge(&quot;MeanPartitionSize&quot;, &quot;MeanRowSize&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L721">        {</span>
            public Long getValue()
            {
<span class="nc" id="L724">                long sum = 0;</span>
<span class="nc" id="L725">                long count = 0;</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">                for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))</span>
                {
<span class="nc" id="L728">                    long n = sstable.getEstimatedPartitionSize().count();</span>
<span class="nc" id="L729">                    sum += sstable.getEstimatedPartitionSize().mean() * n;</span>
<span class="nc" id="L730">                    count += n;</span>
<span class="nc" id="L731">                }</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">                return count &gt; 0 ? sum / count : 0;</span>
            }
        }, new Gauge&lt;Long&gt;() // global gauge
<span class="fc" id="L735">        {</span>
            public Long getValue()
            {
<span class="nc" id="L738">                long sum = 0;</span>
<span class="nc" id="L739">                long count = 0;</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">                for (Keyspace keyspace : Keyspace.all())</span>
                {
<span class="nc bnc" id="L742" title="All 2 branches missed.">                    for (SSTableReader sstable : keyspace.getAllSSTables(SSTableSet.CANONICAL))</span>
                    {
<span class="nc" id="L744">                        long n = sstable.getEstimatedPartitionSize().count();</span>
<span class="nc" id="L745">                        sum += sstable.getEstimatedPartitionSize().mean() * n;</span>
<span class="nc" id="L746">                        count += n;</span>
<span class="nc" id="L747">                    }</span>
<span class="nc" id="L748">                }</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">                return count &gt; 0 ? sum / count : 0;</span>
            }
        });
<span class="fc" id="L752">        compressionMetadataOffHeapMemoryUsed = createTableGauge(&quot;CompressionMetadataOffHeapMemoryUsed&quot;, new Gauge&lt;Long&gt;()</span>
<span class="fc" id="L753">        {</span>
            public Long getValue()
            {
<span class="nc" id="L756">                long total = 0;</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">                for (SSTableReader sst : cfs.getSSTables(SSTableSet.LIVE))</span>
<span class="nc" id="L758">                    total += sst.getCompressionMetadataOffHeapSize();</span>
<span class="nc" id="L759">                return total;</span>
            }
        });
<span class="fc" id="L762">        speculativeRetries = createTableCounter(&quot;SpeculativeRetries&quot;);</span>
<span class="fc" id="L763">        speculativeFailedRetries = createTableCounter(&quot;SpeculativeFailedRetries&quot;);</span>
<span class="fc" id="L764">        speculativeInsufficientReplicas = createTableCounter(&quot;SpeculativeInsufficientReplicas&quot;);</span>
<span class="pc" id="L765">        speculativeSampleLatencyNanos = createTableGauge(&quot;SpeculativeSampleLatencyNanos&quot;, () -&gt; MICROSECONDS.toNanos(cfs.sampleReadLatencyMicros));</span>

<span class="fc" id="L767">        additionalWrites = createTableCounter(&quot;AdditionalWrites&quot;);</span>
<span class="pc" id="L768">        additionalWriteLatencyNanos = createTableGauge(&quot;AdditionalWriteLatencyNanos&quot;, () -&gt; MICROSECONDS.toNanos(cfs.additionalWriteLatencyMicros));</span>

<span class="fc" id="L770">        tombstoneScannedHistogram = createTableHistogram(&quot;TombstoneScannedHistogram&quot;, cfs.keyspace.metric.tombstoneScannedHistogram, false);</span>
<span class="fc" id="L771">        liveScannedHistogram = createTableHistogram(&quot;LiveScannedHistogram&quot;, cfs.keyspace.metric.liveScannedHistogram, false);</span>
<span class="fc" id="L772">        colUpdateTimeDeltaHistogram = createTableHistogram(&quot;ColUpdateTimeDeltaHistogram&quot;, cfs.keyspace.metric.colUpdateTimeDeltaHistogram, false);</span>
<span class="fc" id="L773">        coordinatorReadLatency = createTableTimer(&quot;CoordinatorReadLatency&quot;);</span>
<span class="fc" id="L774">        coordinatorScanLatency = createTableTimer(&quot;CoordinatorScanLatency&quot;);</span>
<span class="fc" id="L775">        coordinatorWriteLatency = createTableTimer(&quot;CoordinatorWriteLatency&quot;);</span>

        // We do not want to capture view mutation specific metrics for a view
        // They only makes sense to capture on the base table
<span class="fc bfc" id="L779" title="All 2 branches covered.">        if (cfs.metadata().isView())</span>
        {
<span class="fc" id="L781">            viewLockAcquireTime = null;</span>
<span class="fc" id="L782">            viewReadTime = null;</span>
        }
        else
        {
<span class="fc" id="L786">            viewLockAcquireTime = createTableTimer(&quot;ViewLockAcquireTime&quot;, cfs.keyspace.metric.viewLockAcquireTime);</span>
<span class="fc" id="L787">            viewReadTime = createTableTimer(&quot;ViewReadTime&quot;, cfs.keyspace.metric.viewReadTime);</span>
        }

<span class="fc" id="L790">        trueSnapshotsSize = createTableGauge(&quot;SnapshotsSize&quot;, cfs::trueSnapshotsSize);</span>
<span class="fc" id="L791">        rowCacheHitOutOfRange = createTableCounter(&quot;RowCacheHitOutOfRange&quot;);</span>
<span class="fc" id="L792">        rowCacheHit = createTableCounter(&quot;RowCacheHit&quot;);</span>
<span class="fc" id="L793">        rowCacheMiss = createTableCounter(&quot;RowCacheMiss&quot;);</span>

<span class="fc" id="L795">        tombstoneFailures = createTableCounter(&quot;TombstoneFailures&quot;);</span>
<span class="fc" id="L796">        tombstoneWarnings = createTableCounter(&quot;TombstoneWarnings&quot;);</span>

<span class="fc" id="L798">        casPrepare = createLatencyMetrics(&quot;CasPrepare&quot;, cfs.keyspace.metric.casPrepare);</span>
<span class="fc" id="L799">        casPropose = createLatencyMetrics(&quot;CasPropose&quot;, cfs.keyspace.metric.casPropose);</span>
<span class="fc" id="L800">        casCommit = createLatencyMetrics(&quot;CasCommit&quot;, cfs.keyspace.metric.casCommit);</span>

<span class="fc" id="L802">        repairsStarted = createTableCounter(&quot;RepairJobsStarted&quot;);</span>
<span class="fc" id="L803">        repairsCompleted = createTableCounter(&quot;RepairJobsCompleted&quot;);</span>

<span class="fc" id="L805">        anticompactionTime = createTableTimer(&quot;AnticompactionTime&quot;, cfs.keyspace.metric.anticompactionTime);</span>
<span class="fc" id="L806">        validationTime = createTableTimer(&quot;ValidationTime&quot;, cfs.keyspace.metric.validationTime);</span>
<span class="fc" id="L807">        repairSyncTime = createTableTimer(&quot;RepairSyncTime&quot;, cfs.keyspace.metric.repairSyncTime);</span>

<span class="fc" id="L809">        bytesValidated = createTableHistogram(&quot;BytesValidated&quot;, cfs.keyspace.metric.bytesValidated, false);</span>
<span class="fc" id="L810">        partitionsValidated = createTableHistogram(&quot;PartitionsValidated&quot;, cfs.keyspace.metric.partitionsValidated, false);</span>
<span class="fc" id="L811">        bytesAnticompacted = createTableCounter(&quot;BytesAnticompacted&quot;);</span>
<span class="fc" id="L812">        bytesMutatedAnticompaction = createTableCounter(&quot;BytesMutatedAnticompaction&quot;);</span>
<span class="fc" id="L813">        mutatedAnticompactionGauge = createTableGauge(&quot;MutatedAnticompactionGauge&quot;, () -&gt;</span>
        {
<span class="nc" id="L815">            double bytesMutated = bytesMutatedAnticompaction.getCount();</span>
<span class="nc" id="L816">            double bytesAnticomp = bytesAnticompacted.getCount();</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">            if (bytesAnticomp + bytesMutated &gt; 0)</span>
<span class="nc" id="L818">                return bytesMutated / (bytesAnticomp + bytesMutated);</span>
<span class="nc" id="L819">            return 0.0;</span>
        });

<span class="fc" id="L822">        readRepairRequests = createTableMeter(&quot;ReadRepairRequests&quot;);</span>
<span class="fc" id="L823">        shortReadProtectionRequests = createTableMeter(&quot;ShortReadProtectionRequests&quot;);</span>
<span class="fc" id="L824">        replicaFilteringProtectionRequests = createTableMeter(&quot;ReplicaFilteringProtectionRequests&quot;);</span>
<span class="fc" id="L825">        rfpRowsCachedPerQuery = createHistogram(&quot;ReplicaFilteringProtectionRowsCachedPerQuery&quot;, true);</span>

<span class="fc" id="L827">        confirmedRepairedInconsistencies = createTableMeter(&quot;RepairedDataInconsistenciesConfirmed&quot;, cfs.keyspace.metric.confirmedRepairedInconsistencies);</span>
<span class="fc" id="L828">        unconfirmedRepairedInconsistencies = createTableMeter(&quot;RepairedDataInconsistenciesUnconfirmed&quot;, cfs.keyspace.metric.unconfirmedRepairedInconsistencies);</span>

<span class="fc" id="L830">        repairedDataTrackingOverreadRows = createTableHistogram(&quot;RepairedDataTrackingOverreadRows&quot;, cfs.keyspace.metric.repairedDataTrackingOverreadRows, false);</span>
<span class="fc" id="L831">        repairedDataTrackingOverreadTime = createTableTimer(&quot;RepairedDataTrackingOverreadTime&quot;, cfs.keyspace.metric.repairedDataTrackingOverreadTime);</span>

<span class="fc" id="L833">        unleveledSSTables = createTableGauge(&quot;UnleveledSSTables&quot;, cfs::getUnleveledSSTables, () -&gt; {</span>
            // global gauge
<span class="nc" id="L835">            int cnt = 0;</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">            for (Metric cfGauge : ALL_TABLE_METRICS.get(&quot;UnleveledSSTables&quot;))</span>
            {
<span class="nc" id="L838">                cnt += ((Gauge&lt;? extends Number&gt;) cfGauge).getValue().intValue();</span>
<span class="nc" id="L839">            }</span>
<span class="nc" id="L840">            return cnt;</span>
        });

<span class="fc" id="L843">        clientTombstoneWarnings = createTableMeter(&quot;ClientTombstoneWarnings&quot;, cfs.keyspace.metric.clientTombstoneWarnings);</span>
<span class="fc" id="L844">        clientTombstoneAborts = createTableMeter(&quot;ClientTombstoneAborts&quot;, cfs.keyspace.metric.clientTombstoneAborts);</span>

<span class="fc" id="L846">        coordinatorReadSizeWarnings = createTableMeter(&quot;CoordinatorReadSizeWarnings&quot;, cfs.keyspace.metric.coordinatorReadSizeWarnings);</span>
<span class="fc" id="L847">        coordinatorReadSizeAborts = createTableMeter(&quot;CoordinatorReadSizeAborts&quot;, cfs.keyspace.metric.coordinatorReadSizeAborts);</span>
<span class="fc" id="L848">        coordinatorReadSize = createTableHistogram(&quot;CoordinatorReadSize&quot;, cfs.keyspace.metric.coordinatorReadSize, false);</span>

<span class="fc" id="L850">        localReadSizeWarnings = createTableMeter(&quot;LocalReadSizeWarnings&quot;, cfs.keyspace.metric.localReadSizeWarnings);</span>
<span class="fc" id="L851">        localReadSizeAborts = createTableMeter(&quot;LocalReadSizeAborts&quot;, cfs.keyspace.metric.localReadSizeAborts);</span>
<span class="fc" id="L852">        localReadSize = createTableHistogram(&quot;LocalReadSize&quot;, cfs.keyspace.metric.localReadSize, false);</span>

<span class="fc" id="L854">        rowIndexSizeWarnings = createTableMeter(&quot;RowIndexSizeWarnings&quot;, cfs.keyspace.metric.rowIndexSizeWarnings);</span>
<span class="fc" id="L855">        rowIndexSizeAborts = createTableMeter(&quot;RowIndexSizeAborts&quot;, cfs.keyspace.metric.rowIndexSizeAborts);</span>
<span class="fc" id="L856">        rowIndexSize = createTableHistogram(&quot;RowIndexSize&quot;, cfs.keyspace.metric.rowIndexSize, false);</span>

<span class="fc" id="L858">        formatSpecificGauges = createFormatSpecificGauges(cfs);</span>
<span class="fc" id="L859">    }</span>

    private Memtable.MemoryUsage getMemoryUsageWithIndexes(ColumnFamilyStore cfs)
    {
<span class="nc" id="L863">        Memtable.MemoryUsage usage = Memtable.newMemoryUsage();</span>
<span class="nc" id="L864">        cfs.getTracker().getView().getCurrentMemtable().addMemoryUsageTo(usage);</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">        for (ColumnFamilyStore indexCfs : cfs.indexManager.getAllIndexColumnFamilyStores())</span>
<span class="nc" id="L866">            indexCfs.getTracker().getView().getCurrentMemtable().addMemoryUsageTo(usage);</span>
<span class="nc" id="L867">        return usage;</span>
    }

    public void updateSSTableIterated(int count)
    {
<span class="fc" id="L872">        sstablesPerReadHistogram.update(count);</span>
<span class="fc" id="L873">    }</span>

    public void updateSSTableIteratedInRangeRead(int count)
    {
<span class="fc" id="L877">        sstablesPerRangeReadHistogram.update(count);</span>
<span class="fc" id="L878">    }</span>

    /**
     * Release all associated metrics.
     */
    public void release()
    {
<span class="fc bfc" id="L885" title="All 2 branches covered.">        for (ReleasableMetric entry : all)</span>
        {
<span class="fc" id="L887">            entry.release();</span>
<span class="fc" id="L888">        }</span>
<span class="fc" id="L889">    }</span>

    private ImmutableMap&lt;SSTableFormat&lt;?, ?&gt;, ImmutableMap&lt;String, Gauge&lt;? extends Number&gt;&gt;&gt; createFormatSpecificGauges(ColumnFamilyStore cfs)
    {
<span class="fc" id="L893">        ImmutableMap.Builder&lt;SSTableFormat&lt;?, ?&gt;, ImmutableMap&lt;String, Gauge&lt;? extends Number&gt;&gt;&gt; builder = ImmutableMap.builder();</span>
<span class="fc bfc" id="L894" title="All 2 branches covered.">        for (SSTableFormat&lt;?, ?&gt; format : DatabaseDescriptor.getSSTableFormats().values())</span>
        {
<span class="fc" id="L896">            ImmutableMap.Builder&lt;String, Gauge&lt;? extends Number&gt;&gt; gauges = ImmutableMap.builder();</span>
<span class="fc bfc" id="L897" title="All 2 branches covered.">            for (GaugeProvider&lt;?&gt; gaugeProvider : format.getFormatSpecificMetricsProviders().getGaugeProviders())</span>
            {
<span class="fc" id="L899">                Gauge&lt;? extends Number&gt; gauge = createTableGauge(gaugeProvider.name, gaugeProvider.getTableGauge(cfs), gaugeProvider.getGlobalGauge());</span>
<span class="fc" id="L900">                gauges.put(gaugeProvider.name, gauge);</span>
<span class="fc" id="L901">            }</span>
<span class="fc" id="L902">            builder.put(format, gauges.build());</span>
<span class="fc" id="L903">        }</span>
<span class="fc" id="L904">        return builder.build();</span>
    }

    /**
     * Create a gauge that will be part of a merged version of all column families.  The global gauge
     * will merge each CF gauge by adding their values
     */
    protected &lt;T extends Number&gt; Gauge&lt;T&gt; createTableGauge(final String name, Gauge&lt;T&gt; gauge)
    {
<span class="fc" id="L913">        return createTableGauge(name, gauge, new GlobalTableGauge(name));</span>
    }

    /**
     * Create a gauge that will be part of a merged version of all column families.  The global gauge
     * is defined as the globalGauge parameter
     */
    protected &lt;G,T&gt; Gauge&lt;T&gt; createTableGauge(String name, Gauge&lt;T&gt; gauge, Gauge&lt;G&gt; globalGauge)
    {
<span class="fc" id="L922">        return createTableGauge(name, name, gauge, globalGauge);</span>
    }

    protected &lt;G,T&gt; Gauge&lt;T&gt; createTableGauge(String name, String alias, Gauge&lt;T&gt; gauge, Gauge&lt;G&gt; globalGauge)
    {
<span class="fc" id="L927">        Gauge&lt;T&gt; cfGauge = Metrics.register(factory.createMetricName(name), aliasFactory.createMetricName(alias), gauge);</span>
<span class="fc bfc" id="L928" title="All 4 branches covered.">        if (register(name, alias, cfGauge) &amp;&amp; globalGauge != null)</span>
        {
<span class="fc" id="L930">            Metrics.register(GLOBAL_FACTORY.createMetricName(name), GLOBAL_ALIAS_FACTORY.createMetricName(alias), globalGauge);</span>
        }
<span class="fc" id="L932">        return cfGauge;</span>
    }

    /**
     * Same as {@link #createTableGauge(String, Gauge, Gauge)} but accepts a deprecated
     * name for a table {@code Gauge}. Prefer that method when deprecation is not necessary.
     *
     * @param name the name of the metric registered with the &quot;Table&quot; type
     * @param deprecated the deprecated name for the metric registered with the &quot;Table&quot; type
     */
    protected &lt;G,T&gt; Gauge&lt;T&gt; createTableGaugeWithDeprecation(String name, String deprecated, Gauge&lt;T&gt; gauge, Gauge&lt;G&gt; globalGauge)
    {
<span class="pc bpc" id="L944" title="1 of 2 branches missed.">        assert deprecated != null : &quot;no deprecated metric name provided&quot;;</span>
<span class="pc bpc" id="L945" title="1 of 2 branches missed.">        assert globalGauge != null : &quot;no global Gauge metric provided&quot;;</span>
        
<span class="fc" id="L947">        Gauge&lt;T&gt; cfGauge = Metrics.register(factory.createMetricName(name), </span>
                                            gauge,
<span class="fc" id="L949">                                            aliasFactory.createMetricName(name),</span>
<span class="fc" id="L950">                                            factory.createMetricName(deprecated),</span>
<span class="fc" id="L951">                                            aliasFactory.createMetricName(deprecated));</span>
        
<span class="fc bfc" id="L953" title="All 2 branches covered.">        if (register(name, name, deprecated, cfGauge))</span>
        {
<span class="fc" id="L955">            Metrics.register(GLOBAL_FACTORY.createMetricName(name),</span>
                             globalGauge,
<span class="fc" id="L957">                             GLOBAL_ALIAS_FACTORY.createMetricName(name),</span>
<span class="fc" id="L958">                             GLOBAL_FACTORY.createMetricName(deprecated),</span>
<span class="fc" id="L959">                             GLOBAL_ALIAS_FACTORY.createMetricName(deprecated));</span>
        }
<span class="fc" id="L961">        return cfGauge;</span>
    }

    /**
     * Creates a counter that will also have a global counter thats the sum of all counters across
     * different column families
     */
    protected Counter createTableCounter(final String name)
    {
<span class="fc" id="L970">        return createTableCounter(name, name);</span>
    }

    protected Counter createTableCounter(final String name, final String alias)
    {
<span class="fc" id="L975">        Counter cfCounter = Metrics.counter(factory.createMetricName(name), aliasFactory.createMetricName(alias));</span>
<span class="fc bfc" id="L976" title="All 2 branches covered.">        if (register(name, alias, cfCounter))</span>
        {
<span class="fc" id="L978">            Metrics.register(GLOBAL_FACTORY.createMetricName(name),</span>
<span class="fc" id="L979">                             GLOBAL_ALIAS_FACTORY.createMetricName(alias),</span>
                             new Gauge&lt;Long&gt;()
<span class="fc" id="L981">            {</span>
                public Long getValue()
                {
<span class="nc" id="L984">                    long total = 0;</span>
<span class="nc bnc" id="L985" title="All 2 branches missed.">                    for (Metric cfGauge : ALL_TABLE_METRICS.get(name))</span>
                    {
<span class="nc" id="L987">                        total += ((Counter) cfGauge).getCount();</span>
<span class="nc" id="L988">                    }</span>
<span class="nc" id="L989">                    return total;</span>
                }
            });
        }
<span class="fc" id="L993">        return cfCounter;</span>
    }

    private Meter createTableMeter(final String name)
    {
<span class="fc" id="L998">        return createTableMeter(name, name);</span>
    }

    private Meter createTableMeter(final String name, final String alias)
    {
<span class="fc" id="L1003">        Meter tableMeter = Metrics.meter(factory.createMetricName(name), aliasFactory.createMetricName(alias));</span>
<span class="fc" id="L1004">        register(name, alias, tableMeter);</span>
<span class="fc" id="L1005">        return tableMeter;</span>
    }
    
    private Histogram createHistogram(String name, boolean considerZeroes)
    {
<span class="fc" id="L1010">        Histogram histogram = Metrics.histogram(factory.createMetricName(name), aliasFactory.createMetricName(name), considerZeroes);</span>
<span class="fc" id="L1011">        register(name, name, histogram);</span>
<span class="fc" id="L1012">        return histogram;</span>
    }

    /**
     * Computes the compression ratio for the specified SSTables
     *
     * @param sstables the SSTables
     * @return the compression ratio for the specified SSTables
     */
    private static Double computeCompressionRatio(Iterable&lt;SSTableReader&gt; sstables)
    {
<span class="nc" id="L1023">        double compressedLengthSum = 0;</span>
<span class="nc" id="L1024">        double dataLengthSum = 0;</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">        for (SSTableReader sstable : sstables)</span>
        {
<span class="nc bnc" id="L1027" title="All 2 branches missed.">            if (sstable.compression)</span>
            {
                // We should not have any sstable which are in an open early mode as the sstable were selected
                // using SSTableSet.CANONICAL.
<span class="nc bnc" id="L1031" title="All 2 branches missed.">                assert sstable.openReason != SSTableReader.OpenReason.EARLY;</span>

                @SuppressWarnings(&quot;resource&quot;)
<span class="nc" id="L1034">                CompressionMetadata compressionMetadata = sstable.getCompressionMetadata();</span>
<span class="nc" id="L1035">                compressedLengthSum += compressionMetadata.compressedFileLength;</span>
<span class="nc" id="L1036">                dataLengthSum += compressionMetadata.dataLength;</span>
            }
<span class="nc" id="L1038">        }</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">        return dataLengthSum != 0 ? compressedLengthSum / dataLengthSum : MetadataCollector.NO_COMPRESSION_RATIO;</span>
    }

    /**
     * Create a histogram-like interface that will register both a CF, keyspace and global level
     * histogram and forward any updates to both
     */
    protected TableHistogram createTableHistogram(String name, Histogram keyspaceHistogram, boolean considerZeroes)
    {
<span class="fc" id="L1048">        return createTableHistogram(name, name, keyspaceHistogram, considerZeroes);</span>
    }

    protected TableHistogram createTableHistogram(String name, String alias, Histogram keyspaceHistogram, boolean considerZeroes)
    {
<span class="fc" id="L1053">        Histogram cfHistogram = Metrics.histogram(factory.createMetricName(name), aliasFactory.createMetricName(alias), considerZeroes);</span>
<span class="fc" id="L1054">        register(name, alias, cfHistogram);</span>
<span class="fc" id="L1055">        return new TableHistogram(cfHistogram,</span>
                                  keyspaceHistogram,
<span class="fc" id="L1057">                                  Metrics.histogram(GLOBAL_FACTORY.createMetricName(name),</span>
<span class="fc" id="L1058">                                                    GLOBAL_ALIAS_FACTORY.createMetricName(alias),</span>
                                                    considerZeroes));
    }

    protected Histogram createTableHistogram(String name, boolean considerZeroes)
    {
<span class="nc" id="L1064">        return createTableHistogram(name, name, considerZeroes);</span>
    }

    protected Histogram createTableHistogram(String name, String alias, boolean considerZeroes)
    {
<span class="nc" id="L1069">        Histogram tableHistogram = Metrics.histogram(factory.createMetricName(name), aliasFactory.createMetricName(alias), considerZeroes);</span>
<span class="nc" id="L1070">        register(name, alias, tableHistogram);</span>
<span class="nc" id="L1071">        return tableHistogram;</span>
    }

    protected TableTimer createTableTimer(String name, Timer keyspaceTimer)
    {
<span class="fc" id="L1076">        Timer cfTimer = Metrics.timer(factory.createMetricName(name), aliasFactory.createMetricName(name));</span>
<span class="fc" id="L1077">        register(name, name, keyspaceTimer);</span>
<span class="fc" id="L1078">        Timer global = Metrics.timer(GLOBAL_FACTORY.createMetricName(name), GLOBAL_ALIAS_FACTORY.createMetricName(name));</span>

<span class="fc" id="L1080">        return new TableTimer(cfTimer, keyspaceTimer, global);</span>
    }

    protected SnapshottingTimer createTableTimer(String name)
    {
<span class="fc" id="L1085">        SnapshottingTimer tableTimer = Metrics.timer(factory.createMetricName(name), aliasFactory.createMetricName(name));</span>
<span class="fc" id="L1086">        register(name, name, tableTimer);</span>
<span class="fc" id="L1087">        return tableTimer;</span>
    }

    protected TableMeter createTableMeter(String name, Meter keyspaceMeter)
    {
<span class="fc" id="L1092">        return createTableMeter(name, name, keyspaceMeter);</span>
    }

    protected TableMeter createTableMeter(String name, String alias, Meter keyspaceMeter)
    {
<span class="fc" id="L1097">        Meter meter = Metrics.meter(factory.createMetricName(name), aliasFactory.createMetricName(alias));</span>
<span class="fc" id="L1098">        register(name, alias, meter);</span>
<span class="fc" id="L1099">        return new TableMeter(meter,</span>
                              keyspaceMeter,
<span class="fc" id="L1101">                              Metrics.meter(GLOBAL_FACTORY.createMetricName(name),</span>
<span class="fc" id="L1102">                                            GLOBAL_ALIAS_FACTORY.createMetricName(alias)));</span>
    }

    private LatencyMetrics createLatencyMetrics(String namePrefix, LatencyMetrics ... parents)
    {
<span class="fc" id="L1107">        LatencyMetrics metric = new LatencyMetrics(factory, namePrefix, parents);</span>
<span class="fc" id="L1108">        all.add(metric::release);</span>
<span class="fc" id="L1109">        return metric;</span>
    }

    /**
     * Registers a metric to be removed when unloading CF.
     * @return true if first time metric with that name has been registered
     */
    private boolean register(String name, String alias, Metric metric)
    {
<span class="fc" id="L1118">        return register(name, alias, null, metric);</span>
    }

    /**
     * Registers a metric to be removed when unloading CF.
     * 
     * @param name the name of the metric registered with the &quot;Table&quot; type
     * @param alias the name of the metric registered with the legacy &quot;ColumnFamily&quot; type
     * @param deprecated an optionally null deprecated name for the metric registered with the &quot;Table&quot;
     * 
     * @return true if first time metric with that name has been registered
     */
    private boolean register(String name, String alias, String deprecated, Metric metric)
    {
<span class="fc bfc" id="L1132" title="All 2 branches covered.">        boolean ret = ALL_TABLE_METRICS.putIfAbsent(name, ConcurrentHashMap.newKeySet()) == null;</span>
<span class="fc" id="L1133">        ALL_TABLE_METRICS.get(name).add(metric);</span>
<span class="fc" id="L1134">        all.add(() -&gt; releaseMetric(name, alias, deprecated));</span>
<span class="fc" id="L1135">        return ret;</span>
    }

    private void releaseMetric(String tableMetricName, String cfMetricName, String tableMetricAlias)
    {
<span class="fc" id="L1140">        CassandraMetricsRegistry.MetricName name = factory.createMetricName(tableMetricName);</span>

<span class="fc" id="L1142">        final Metric metric = Metrics.getMetrics().get(name.getMetricName());</span>
<span class="fc bfc" id="L1143" title="All 2 branches covered.">        if (metric != null)</span>
        {
            // Metric will be null if we are releasing a view metric.  Views have null for ViewLockAcquireTime and ViewLockReadTime
<span class="fc" id="L1146">            ALL_TABLE_METRICS.get(tableMetricName).remove(metric);</span>
<span class="fc" id="L1147">            CassandraMetricsRegistry.MetricName cfAlias = aliasFactory.createMetricName(cfMetricName);</span>
            
<span class="fc bfc" id="L1149" title="All 2 branches covered.">            if (tableMetricAlias != null)</span>
            {
<span class="fc" id="L1151">                Metrics.remove(name, cfAlias, factory.createMetricName(tableMetricAlias), aliasFactory.createMetricName(tableMetricAlias));</span>
            }
            else
            {
<span class="fc" id="L1155">                Metrics.remove(name, cfAlias);</span>
            }
        }
<span class="fc" id="L1158">    }</span>

    public static class TableMeter
    {
        public final Meter[] all;
        public final Meter table;
        public final Meter global;

        private TableMeter(Meter table, Meter keyspace, Meter global)
<span class="fc" id="L1167">        {</span>
<span class="fc" id="L1168">            this.table = table;</span>
<span class="fc" id="L1169">            this.global = global;</span>
<span class="fc" id="L1170">            this.all = new Meter[]{table, keyspace, global};</span>
<span class="fc" id="L1171">        }</span>

        public void mark()
        {
<span class="nc bnc" id="L1175" title="All 2 branches missed.">            for (Meter meter : all)</span>
            {
<span class="nc" id="L1177">                meter.mark();</span>
            }
<span class="nc" id="L1179">        }</span>
    }

    public static class TableHistogram
    {
        public final Histogram[] all;
        public final Histogram cf;
        public final Histogram global;

        private TableHistogram(Histogram cf, Histogram keyspace, Histogram global)
<span class="fc" id="L1189">        {</span>
<span class="fc" id="L1190">            this.cf = cf;</span>
<span class="fc" id="L1191">            this.global = global;</span>
<span class="fc" id="L1192">            this.all = new Histogram[]{cf, keyspace, global};</span>
<span class="fc" id="L1193">        }</span>

        public void update(long i)
        {
<span class="fc bfc" id="L1197" title="All 2 branches covered.">            for(Histogram histo : all)</span>
            {
<span class="fc" id="L1199">                histo.update(i);</span>
            }
<span class="fc" id="L1201">        }</span>
    }

    public static class TableTimer
    {
        public final Timer[] all;
        public final Timer cf;
        public final Timer global;

        private TableTimer(Timer cf, Timer keyspace, Timer global)
<span class="fc" id="L1211">        {</span>
<span class="fc" id="L1212">            this.cf = cf;</span>
<span class="fc" id="L1213">            this.global = global;</span>
<span class="fc" id="L1214">            this.all = new Timer[]{cf, keyspace, global};</span>
<span class="fc" id="L1215">        }</span>

        public void update(long i, TimeUnit unit)
        {
<span class="fc bfc" id="L1219" title="All 2 branches covered.">            for(Timer timer : all)</span>
            {
<span class="fc" id="L1221">                timer.update(i, unit);</span>
            }
<span class="fc" id="L1223">        }</span>

        public Context time()
        {
<span class="nc" id="L1227">            return new Context(all);</span>
        }

        public static class Context implements AutoCloseable
        {
            private final long start;
            private final Timer [] all;

            private Context(Timer [] all)
            {
                this.all = all;
                start = nanoTime();
            }

            public void close()
            {
                long duration = nanoTime() - start;
                for (Timer t : all)
                    t.update(duration, TimeUnit.NANOSECONDS);
            }
        }
    }

    static class TableMetricNameFactory implements MetricNameFactory
    {
        private final String keyspaceName;
        private final String tableName;
        private final boolean isIndex;
        private final String type;

        TableMetricNameFactory(ColumnFamilyStore cfs, String type)
<span class="fc" id="L1258">        {</span>
<span class="fc" id="L1259">            this.keyspaceName = cfs.getKeyspaceName();</span>
<span class="fc" id="L1260">            this.tableName = cfs.name;</span>
<span class="fc" id="L1261">            this.isIndex = cfs.isIndex();</span>
<span class="fc" id="L1262">            this.type = type;</span>
<span class="fc" id="L1263">        }</span>

        public CassandraMetricsRegistry.MetricName createMetricName(String metricName)
        {
<span class="fc" id="L1267">            String groupName = TableMetrics.class.getPackage().getName();</span>
<span class="fc bfc" id="L1268" title="All 2 branches covered.">            String type = isIndex ? &quot;Index&quot; + this.type : this.type;</span>

<span class="fc" id="L1270">            StringBuilder mbeanName = new StringBuilder();</span>
<span class="fc" id="L1271">            mbeanName.append(groupName).append(&quot;:&quot;);</span>
<span class="fc" id="L1272">            mbeanName.append(&quot;type=&quot;).append(type);</span>
<span class="fc" id="L1273">            mbeanName.append(&quot;,keyspace=&quot;).append(keyspaceName);</span>
<span class="fc" id="L1274">            mbeanName.append(&quot;,scope=&quot;).append(tableName);</span>
<span class="fc" id="L1275">            mbeanName.append(&quot;,name=&quot;).append(metricName);</span>

<span class="fc" id="L1277">            return new CassandraMetricsRegistry.MetricName(groupName, type, metricName, keyspaceName + &quot;.&quot; + tableName, mbeanName.toString());</span>
        }
    }

    static class AllTableMetricNameFactory implements MetricNameFactory
    {
        private final String type;
        public AllTableMetricNameFactory(String type)
<span class="fc" id="L1285">        {</span>
<span class="fc" id="L1286">            this.type = type;</span>
<span class="fc" id="L1287">        }</span>

        public CassandraMetricsRegistry.MetricName createMetricName(String metricName)
        {
<span class="fc" id="L1291">            String groupName = TableMetrics.class.getPackage().getName();</span>
<span class="fc" id="L1292">            StringBuilder mbeanName = new StringBuilder();</span>
<span class="fc" id="L1293">            mbeanName.append(groupName).append(&quot;:&quot;);</span>
<span class="fc" id="L1294">            mbeanName.append(&quot;type=&quot;).append(type);</span>
<span class="fc" id="L1295">            mbeanName.append(&quot;,name=&quot;).append(metricName);</span>
<span class="fc" id="L1296">            return new CassandraMetricsRegistry.MetricName(groupName, type, metricName, &quot;all&quot;, mbeanName.toString());</span>
        }
    }

    @FunctionalInterface
    public interface ReleasableMetric
    {
        void release();
    }

    private static class GlobalTableGauge implements Gauge&lt;Long&gt;
    {
        private final String name;

        public GlobalTableGauge(String name)
<span class="fc" id="L1311">        {</span>
<span class="fc" id="L1312">            this.name = name;</span>
<span class="fc" id="L1313">        }</span>

        public Long getValue()
        {
<span class="nc" id="L1317">            long total = 0;</span>
<span class="nc bnc" id="L1318" title="All 2 branches missed.">            for (Metric cfGauge : ALL_TABLE_METRICS.get(name))</span>
            {
<span class="nc" id="L1320">                total = total + ((Gauge&lt;? extends Number&gt;) cfGauge).getValue().longValue();</span>
<span class="nc" id="L1321">            }</span>
<span class="nc" id="L1322">            return total;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>