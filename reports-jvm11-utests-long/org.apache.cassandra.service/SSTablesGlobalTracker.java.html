<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SSTablesGlobalTracker.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.service</a> &gt; <span class="el_source">SSTablesGlobalTracker.java</span></div><h1>SSTablesGlobalTracker.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.service;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.concurrent.TimeUnit;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.lifecycle.Tracker;
import org.apache.cassandra.io.sstable.Descriptor;
import org.apache.cassandra.io.sstable.format.SSTableFormat;
import org.apache.cassandra.io.sstable.format.Version;
import org.apache.cassandra.notifications.INotification;
import org.apache.cassandra.notifications.INotificationConsumer;
import org.apache.cassandra.notifications.InitialSSTableAddedNotification;
import org.apache.cassandra.notifications.SSTableAddedNotification;
import org.apache.cassandra.notifications.SSTableDeletingNotification;
import org.apache.cassandra.notifications.SSTableListChangedNotification;
import org.apache.cassandra.utils.NoSpamLogger;

/**
 * Tracks all sstables in use on the local node.
 *
 * &lt;p&gt;Each table tracks its own SSTables in {@link ColumnFamilyStore} (through {@link Tracker}) for most purposes, but
 * this class groups information we need on all the sstables the node has.
 */
public class SSTablesGlobalTracker implements INotificationConsumer
{
<span class="fc" id="L56">    private static final Logger logger = LoggerFactory.getLogger(SSTablesGlobalTracker.class);</span>
<span class="fc" id="L57">    private static final NoSpamLogger noSpamLogger = NoSpamLogger.getLogger(logger, 5L, TimeUnit.MINUTES);</span>

    /*
     * As of CASSANDRA-15897, the only thing we track here is the set of sstable versions in use.
     *
     * That set is maintained in `versionsInUse`, an immutable set replaced when changed (so that it can be read safely
     * and cheaply). To track when that set changes and needs to be re-computed, we essentially maintain a map of
     * sstables versions in use to the number of sstables for that version. But as we know that sstables will
     * overwhelmingly be on the &quot;current&quot; version, we special case said current version (makes things cheaper without
     * too much complexity here). Those are `sstablesForCurrentVersion` and `sstablesForOtherVersions`.
     *
     * This would be sufficient if we could guarantee that for any sstable, we only ever have 1 addition notification
     * and 1 corresponding remove notification. But sstables can have complex lifecycles and relying on this property
     * could be fragile. As a matter of fact, at the time of this writing, the removal notification is sometimes fired
     * twice for the same sstable. To keep this component more resilient, we also maintain the set of all sstables for
     * which we've received an addition, which allows us to ignore removals for sstables we don't know.
     *
     * Concurrency handling: the 'allSSTables' set handles concurrency directly as it is updated in all cases. The rest
     * of the data structures of this class are only updated together within a synchronized block when handling new
     * sstables additions/removals.
     */

<span class="fc" id="L79">    private final Set&lt;Descriptor&gt; allSSTables = ConcurrentHashMap.newKeySet();</span>

    private final Version currentVersion;
    private int sstablesForCurrentVersion;
<span class="fc" id="L83">    private final Map&lt;Version, Integer&gt; sstablesForOtherVersions = new HashMap&lt;&gt;();</span>

<span class="fc" id="L85">    private volatile ImmutableSet&lt;Version&gt; versionsInUse = ImmutableSet.of();</span>

<span class="fc" id="L87">    private final Set&lt;INotificationConsumer&gt; subscribers = new CopyOnWriteArraySet&lt;&gt;();</span>

    public SSTablesGlobalTracker(SSTableFormat&lt;?, ?&gt; currentSSTableFormat)
<span class="fc" id="L90">    {</span>
<span class="fc" id="L91">        this.currentVersion = currentSSTableFormat.getLatestVersion();</span>
<span class="fc" id="L92">    }</span>

    /**
     * The set of all sstable versions currently in use on this node.
     */
    public Set&lt;Version&gt; versionsInUse()
    {
<span class="fc" id="L99">        return versionsInUse;</span>
    }

    /**
     * Register a new subscriber to this tracker.
     *
     * Registered subscribers are currently notified when the set of sstable versions in use changes, using a
     * {@link SSTablesVersionsInUseChangeNotification}.
     *
     * @param subscriber the new subscriber to register. If this subscriber is already registered, this method does
     * nothing (meaning that even if a subscriber is registered multiple times, it will only be notified once on every
     * change).
     * @return whether the subscriber was register (so whether it was not already registered).
     */
    public boolean register(INotificationConsumer subscriber)
    {
<span class="fc" id="L115">        return subscribers.add(subscriber);</span>
    }

    /**
     * Unregister a subscriber from this tracker.
     *
     * @param subscriber the subscriber to unregister. If this subscriber is not registered, this method does nothing.
     * @return whether the subscriber was unregistered (so whether it was registered subscriber of this tracker).
     */
    public boolean unregister(INotificationConsumer subscriber)
    {
<span class="nc" id="L126">        return subscribers.remove(subscriber);</span>
    }

    @Override
    public void handleNotification(INotification notification, Object sender)
    {
<span class="fc" id="L132">        Iterable&lt;Descriptor&gt; removed = removedSSTables(notification);</span>
<span class="fc" id="L133">        Iterable&lt;Descriptor&gt; added = addedSSTables(notification);</span>
<span class="fc bfc" id="L134" title="All 4 branches covered.">        if (Iterables.isEmpty(removed) &amp;&amp; Iterables.isEmpty(added))</span>
<span class="fc" id="L135">            return;</span>

<span class="fc" id="L137">        boolean triggerUpdate = handleSSTablesChange(removed, added);</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (triggerUpdate)</span>
        {
<span class="fc" id="L140">            SSTablesVersionsInUseChangeNotification changeNotification = new SSTablesVersionsInUseChangeNotification(versionsInUse);</span>
<span class="fc" id="L141">            subscribers.forEach(s -&gt; s.handleNotification(changeNotification, this));</span>
        }
<span class="fc" id="L143">    }</span>

    @VisibleForTesting
    boolean handleSSTablesChange(Iterable&lt;Descriptor&gt; removed, Iterable&lt;Descriptor&gt; added)
    {
        /*
         We collect changes to 'sstablesForCurrentVersion' and 'sstablesForOtherVersions' as delta first, and then
         apply those delta within a synchronized block below. The goal being to reduce the work done in that
         synchronized block.
        */
<span class="fc" id="L153">        int currentDelta = 0;</span>
<span class="fc" id="L154">        Map&lt;Version, Integer&gt; othersDelta = null;</span>
        /*
         Note: we deal with removes first as if a notification both removes and adds, it's a compaction and while
         it should never remove and add the same descriptor in practice, doing the remove first is more logical.
        */
<span class="fc bfc" id="L159" title="All 2 branches covered.">        for (Descriptor desc  : removed)</span>
        {
<span class="fc bfc" id="L161" title="All 2 branches covered.">            if (!allSSTables.remove(desc))</span>
<span class="fc" id="L162">                continue;</span>

<span class="fc" id="L164">            Version version = desc.version;</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">            if (currentVersion.equals(version))</span>
<span class="fc" id="L166">                --currentDelta;</span>
            else
<span class="nc" id="L168">                othersDelta = update(othersDelta, version, -1);</span>
<span class="fc" id="L169">        }</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">        for (Descriptor desc : added)</span>
        {
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">            if (!allSSTables.add(desc))</span>
<span class="nc" id="L173">                continue;</span>

<span class="fc" id="L175">            Version version = desc.version;</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">            if (currentVersion.equals(version))</span>
<span class="fc" id="L177">                ++currentDelta;</span>
            else
<span class="nc" id="L179">                othersDelta = update(othersDelta, version, +1);</span>
<span class="fc" id="L180">        }</span>

<span class="pc bpc" id="L182" title="1 of 4 branches missed.">        if (currentDelta == 0 &amp;&amp; (othersDelta == null))</span>
<span class="fc" id="L183">            return false;</span>

        /*
         Set to true if the set of versions in use is changed by this update. That is, if a version having no
         version prior now has some, or if the count for some version reaches 0.
        */
        boolean triggerUpdate;
<span class="fc" id="L190">        synchronized (this)</span>
        {
<span class="fc bfc" id="L192" title="All 8 branches covered.">            triggerUpdate = (currentDelta &gt; 0 &amp;&amp; sstablesForCurrentVersion == 0)</span>
                            || (currentDelta &lt; 0 &amp;&amp; sstablesForCurrentVersion &lt;= -currentDelta);
<span class="fc" id="L194">            sstablesForCurrentVersion += currentDelta;</span>
<span class="fc" id="L195">            sstablesForCurrentVersion = sanitizeSSTablesCount(sstablesForCurrentVersion, currentVersion);</span>

<span class="pc bpc" id="L197" title="1 of 2 branches missed.">            if (othersDelta != null)</span>
            {
<span class="nc bnc" id="L199" title="All 2 branches missed.">                for (Map.Entry&lt;Version, Integer&gt; entry : othersDelta.entrySet())</span>
                {
<span class="nc" id="L201">                    Version version = entry.getKey();</span>
<span class="nc" id="L202">                    int delta = entry.getValue();</span>
                    /*
                     Updates the count, removing the version if it reaches 0 (note: we could use Map#compute for this,
                     but we wouldn't be able to modify `triggerUpdate` without making it an Object, so we don't bother).
                    */
<span class="nc" id="L207">                    Integer oldValue = sstablesForOtherVersions.get(version);</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">                    int newValue = oldValue == null ? delta : oldValue + delta;</span>
<span class="nc" id="L209">                    newValue = sanitizeSSTablesCount(newValue, version);</span>
<span class="nc bnc" id="L210" title="All 4 branches missed.">                    triggerUpdate |= oldValue == null || newValue == 0;</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">                    if (newValue == 0)</span>
<span class="nc" id="L212">                        sstablesForOtherVersions.remove(version);</span>
                    else
<span class="nc" id="L214">                        sstablesForOtherVersions.put(version, newValue);</span>
<span class="nc" id="L215">                }</span>
            }

<span class="fc bfc" id="L218" title="All 2 branches covered.">            if (triggerUpdate)</span>
<span class="fc" id="L219">                versionsInUse = computeVersionsInUse(sstablesForCurrentVersion, currentVersion, sstablesForOtherVersions);</span>
<span class="fc" id="L220">        }</span>
<span class="fc" id="L221">        return triggerUpdate;</span>
    }

    private static ImmutableSet&lt;Version&gt; computeVersionsInUse(int sstablesForCurrentVersion, Version currentVersion, Map&lt;Version, Integer&gt; sstablesForOtherVersions)
    {
<span class="fc" id="L226">        ImmutableSet.Builder&lt;Version&gt; builder = ImmutableSet.builder();</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">        if (sstablesForCurrentVersion &gt; 0)</span>
<span class="fc" id="L228">            builder.add(currentVersion);</span>
<span class="fc" id="L229">        builder.addAll(sstablesForOtherVersions.keySet());</span>
<span class="fc" id="L230">        return builder.build();</span>
    }

    private static int sanitizeSSTablesCount(int sstableCount, Version version)
    {
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">        if (sstableCount &gt;= 0)</span>
<span class="fc" id="L236">            return sstableCount;</span>

        /*
         This shouldn't happen and indicate a bug either in the tracking of this class, or on the passed notification.
         That said, it's not worth bringing the node down, so we log the problem but otherwise &quot;correct&quot; it.
        */
<span class="nc" id="L242">        noSpamLogger.error(&quot;Invalid state while handling sstables change notification: the number of sstables for &quot; +</span>
                           &quot;version {} was computed to {}. This indicate a bug and please report it, but it should &quot; +
<span class="nc" id="L244">                           &quot;not have adverse consequences.&quot;, version.toFormatAndVersionString(), sstableCount, new RuntimeException());</span>
<span class="nc" id="L245">        return 0;</span>
    }

    private static Iterable&lt;Descriptor&gt; addedSSTables(INotification notification)
    {
<span class="fc bfc" id="L250" title="All 2 branches covered.">        if (notification instanceof SSTableAddedNotification)</span>
<span class="fc" id="L251">            return Iterables.transform(((SSTableAddedNotification)notification).added, s -&gt; s.descriptor);</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">        if (notification instanceof SSTableListChangedNotification)</span>
<span class="fc" id="L253">            return Iterables.transform(((SSTableListChangedNotification)notification).added, s -&gt; s.descriptor);</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">        if (notification instanceof InitialSSTableAddedNotification)</span>
<span class="pc" id="L255">            return Iterables.transform(((InitialSSTableAddedNotification)notification).added, s -&gt; s.descriptor);</span>
        else
<span class="fc" id="L257">            return Collections.emptyList();</span>
    }

    private static Iterable&lt;Descriptor&gt; removedSSTables(INotification notification)
    {
<span class="fc bfc" id="L262" title="All 2 branches covered.">        if (notification instanceof SSTableDeletingNotification)</span>
<span class="fc" id="L263">            return Collections.singletonList(((SSTableDeletingNotification)notification).deleting.descriptor);</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">        if (notification instanceof SSTableListChangedNotification)</span>
<span class="fc" id="L265">            return Iterables.transform(((SSTableListChangedNotification)notification).removed, s -&gt; s.descriptor);</span>
        else
<span class="fc" id="L267">            return Collections.emptyList();</span>
    }

    private static Map&lt;Version, Integer&gt; update(Map&lt;Version, Integer&gt; counts,
                                                       Version toUpdate,
                                                       int delta)
    {
<span class="nc bnc" id="L274" title="All 2 branches missed.">        Map&lt;Version, Integer&gt; m = counts == null ? new HashMap&lt;&gt;() : counts;</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">        m.merge(toUpdate, delta, (a, b) -&gt; (a + b == 0) ? null : (a + b));</span>
<span class="nc" id="L276">        return m;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>