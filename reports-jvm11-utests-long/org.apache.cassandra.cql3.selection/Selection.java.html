<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Selection.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.selection</a> &gt; <span class="el_source">Selection.java</span></div><h1>Selection.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3.selection;

import java.nio.ByteBuffer;
import java.util.*;

import com.google.common.base.MoreObjects;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import com.google.common.collect.Lists;

import org.apache.cassandra.cql3.*;
import org.apache.cassandra.cql3.functions.Function;
import org.apache.cassandra.cql3.selection.Selector.InputRow;
import org.apache.cassandra.db.filter.ColumnFilter;
import org.apache.cassandra.db.marshal.UTF8Type;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.transport.ProtocolVersion;
import org.apache.cassandra.utils.JsonUtils;

public abstract class Selection
{
    /**
     * A predicate that returns &lt;code&gt;true&lt;/code&gt; for static columns.
     */
<span class="pc" id="L45">    private static final Predicate&lt;ColumnMetadata&gt; STATIC_COLUMN_FILTER = (column) -&gt; column.isStatic();</span>

    private final TableMetadata table;
    private final List&lt;ColumnMetadata&gt; columns;
    private final SelectionColumnMapping columnMapping;
    protected final ResultSet.ResultMetadata metadata;
    protected final ColumnFilterFactory columnFilterFactory;
    protected final boolean isJson;

    // Columns used to order the result set for JSON queries with post ordering.
    protected final List&lt;ColumnMetadata&gt; orderingColumns;

    protected Selection(TableMetadata table,
                        List&lt;ColumnMetadata&gt; selectedColumns,
                        Set&lt;ColumnMetadata&gt; orderingColumns,
                        SelectionColumnMapping columnMapping,
                        ColumnFilterFactory columnFilterFactory,
                        boolean isJson)
<span class="fc" id="L63">    {</span>
<span class="fc" id="L64">        this.table = table;</span>
<span class="fc" id="L65">        this.columns = selectedColumns;</span>
<span class="fc" id="L66">        this.columnMapping = columnMapping;</span>
<span class="fc" id="L67">        this.metadata = new ResultSet.ResultMetadata(columnMapping.getColumnSpecifications());</span>
<span class="fc" id="L68">        this.columnFilterFactory = columnFilterFactory;</span>
<span class="fc" id="L69">        this.isJson = isJson;</span>

        // If we order post-query, the sorted column needs to be in the ResultSet for sorting,
        // even if we don't ultimately ship them to the client (CASSANDRA-4911).
<span class="fc" id="L73">        this.columns.addAll(orderingColumns);</span>
<span class="fc" id="L74">        this.metadata.addNonSerializedColumns(orderingColumns);</span>

<span class="pc bpc" id="L76" title="1 of 2 branches missed.">        this.orderingColumns = orderingColumns.isEmpty() ? Collections.emptyList() : new ArrayList&lt;&gt;(orderingColumns);</span>
<span class="fc" id="L77">    }</span>

    // Overriden by SimpleSelection when appropriate.
    public boolean isWildcard()
    {
<span class="nc" id="L82">        return false;</span>
    }

    /**
     * Checks if this selection contains static columns.
     * @return &lt;code&gt;true&lt;/code&gt; if this selection contains static columns, &lt;code&gt;false&lt;/code&gt; otherwise;
     */
    public boolean containsStaticColumns()
    {
<span class="nc bnc" id="L91" title="All 4 branches missed.">        if (table.isStaticCompactTable() || !table.hasStaticColumns())</span>
<span class="nc" id="L92">            return false;</span>

<span class="nc bnc" id="L94" title="All 2 branches missed.">        if (isWildcard())</span>
<span class="nc" id="L95">            return true;</span>

<span class="nc bnc" id="L97" title="All 2 branches missed.">        return !Iterables.isEmpty(Iterables.filter(columns, STATIC_COLUMN_FILTER));</span>
    }

    /**
     * Returns the corresponding column index used for post query ordering
     * @param c ordering column
     * @return
     */
    public Integer getOrderingIndex(ColumnMetadata c)
    {
        // If we order post-query in json, the first and only column that we ship to the client is the json column.
        // In that case, we should keep ordering columns around to perform the ordering, then these columns will
        // be placed after the json column. As a consequence of where the colums are placed, we should give the
        // ordering index a value based on their position in the json encoding and discard the original index.
        // (CASSANDRA-14286)
<span class="nc bnc" id="L112" title="All 2 branches missed.">        if (isJson)</span>
<span class="nc" id="L113">            return orderingColumns.indexOf(c) + 1;</span>

        // If the column is masked it might appear twice, once masked in the selected column and once unmasked in
        // the ordering columns. For ordering we are interested in that second unmasked value.
<span class="nc bnc" id="L117" title="All 2 branches missed.">        if (c.isMasked())</span>
<span class="nc" id="L118">            return columns.lastIndexOf(c);</span>

<span class="nc" id="L120">        return getResultSetIndex(c);</span>
    }

    public ResultSet.ResultMetadata getResultMetadata()
    {
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        if (!isJson)</span>
<span class="fc" id="L126">            return metadata;</span>

<span class="nc" id="L128">        ColumnSpecification firstColumn = metadata.names.get(0);</span>
<span class="nc" id="L129">        ColumnSpecification jsonSpec = new ColumnSpecification(firstColumn.ksName, firstColumn.cfName, Json.JSON_COLUMN_ID, UTF8Type.instance);</span>
<span class="nc" id="L130">        ResultSet.ResultMetadata resultMetadata = new ResultSet.ResultMetadata(Lists.newArrayList(jsonSpec));</span>
<span class="nc" id="L131">        resultMetadata.addNonSerializedColumns(orderingColumns);</span>
<span class="nc" id="L132">        return resultMetadata;</span>
    }

    public static Selection wildcard(TableMetadata table, boolean isJson, boolean returnStaticContentOnPartitionWithNoRows)
    {
<span class="fc" id="L137">        List&lt;ColumnMetadata&gt; all = new ArrayList&lt;&gt;(table.columns().size());</span>
<span class="fc" id="L138">        Iterators.addAll(all, table.allColumnsInSelectOrder());</span>
<span class="fc" id="L139">        return new SimpleSelection(table, all, Collections.emptySet(), true, isJson, returnStaticContentOnPartitionWithNoRows);</span>
    }

    public static Selection wildcardWithGroupByOrMaskedColumns(TableMetadata table,
                                                               VariableSpecifications boundNames,
                                                               Set&lt;ColumnMetadata&gt; orderingColumns,
                                                               boolean isJson,
                                                               boolean returnStaticContentOnPartitionWithNoRows)
    {
<span class="nc" id="L148">        return fromSelectors(table,</span>
<span class="nc" id="L149">                             Lists.newArrayList(table.allColumnsInSelectOrder()),</span>
                             boundNames,
                             orderingColumns,
<span class="nc" id="L152">                             Collections.emptySet(),</span>
                             true,
                             isJson,
                             returnStaticContentOnPartitionWithNoRows);
    }

    public static Selection forColumns(TableMetadata table, List&lt;ColumnMetadata&gt; columns, boolean returnStaticContentOnPartitionWithNoRows)
    {
<span class="nc" id="L160">        return new SimpleSelection(table, columns, Collections.emptySet(), false, false, returnStaticContentOnPartitionWithNoRows);</span>
    }

    public void addFunctionsTo(List&lt;Function&gt; functions)
    {
<span class="fc" id="L165">    }</span>

    private static boolean processesSelection(List&lt;Selectable&gt; selectables)
    {
<span class="fc bfc" id="L169" title="All 2 branches covered.">        for (Selectable selectable : selectables)</span>
        {
<span class="fc bfc" id="L171" title="All 2 branches covered.">            if (selectable.processesSelection())</span>
<span class="fc" id="L172">                return true;</span>
<span class="fc" id="L173">        }</span>
<span class="fc" id="L174">        return false;</span>
    }

    public static Selection fromSelectors(TableMetadata table,
                                          List&lt;Selectable&gt; selectables,
                                          VariableSpecifications boundNames,
                                          Set&lt;ColumnMetadata&gt; orderingColumns,
                                          Set&lt;ColumnMetadata&gt; nonPKRestrictedColumns,
                                          boolean hasGroupBy,
                                          boolean isJson,
                                          boolean returnStaticContentOnPartitionWithNoRows)
    {
<span class="fc" id="L186">        List&lt;ColumnMetadata&gt; selectedColumns = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L188">        SelectorFactories factories =</span>
<span class="fc" id="L189">                SelectorFactories.createFactoriesAndCollectColumnDefinitions(selectables, null, table, selectedColumns, boundNames);</span>
<span class="fc" id="L190">        SelectionColumnMapping mapping = collectColumnMappings(table, factories);</span>

<span class="fc" id="L192">        Set&lt;ColumnMetadata&gt; filteredOrderingColumns = filterOrderingColumns(orderingColumns,</span>
                                                                            selectedColumns,
                                                                            factories,
                                                                            isJson);

<span class="pc bpc" id="L197" title="2 of 6 branches missed.">        return (processesSelection(selectables) || selectables.size() != selectedColumns.size() || hasGroupBy)</span>
<span class="fc" id="L198">            ? new SelectionWithProcessing(table,</span>
                                          selectedColumns,
                                          filteredOrderingColumns,
                                          nonPKRestrictedColumns,
                                          mapping,
                                          factories,
                                          isJson,
                                          returnStaticContentOnPartitionWithNoRows)
<span class="fc" id="L206">            : new SimpleSelection(table,</span>
                                  selectedColumns,
                                  filteredOrderingColumns,
                                  nonPKRestrictedColumns,
                                  mapping,
                                  isJson,
                                  returnStaticContentOnPartitionWithNoRows);
    }

    /**
     * Removes the ordering columns that are already selected.
     *
     * @param orderingColumns the columns used to order the results
     * @param selectedColumns the selected columns
     * @param factories the factory used to create the selectors
     * @return the ordering columns that are not part of the selection
     */
    private static Set&lt;ColumnMetadata&gt; filterOrderingColumns(Set&lt;ColumnMetadata&gt; orderingColumns,
                                                             List&lt;ColumnMetadata&gt; selectedColumns,
                                                             SelectorFactories factories,
                                                             boolean isJson)
    {
        // CASSANDRA-14286
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        if (isJson)</span>
<span class="nc" id="L230">            return orderingColumns;</span>
<span class="fc" id="L231">        Set&lt;ColumnMetadata&gt; filteredOrderingColumns = new LinkedHashSet&lt;&gt;(orderingColumns.size());</span>
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">        for (ColumnMetadata orderingColumn : orderingColumns)</span>
        {
<span class="nc" id="L234">            int index = selectedColumns.indexOf(orderingColumn);</span>
<span class="nc bnc" id="L235" title="All 6 branches missed.">            if (index &gt;= 0 &amp;&amp; factories.indexOfSimpleSelectorFactory(index) &gt;= 0 &amp;&amp; !orderingColumn.isMasked())</span>
<span class="nc" id="L236">                continue;</span>

<span class="nc" id="L238">            filteredOrderingColumns.add(orderingColumn);</span>
<span class="nc" id="L239">        }</span>
<span class="fc" id="L240">        return filteredOrderingColumns;</span>
    }

    /**
     * Returns the index of the specified column within the resultset
     * @param c the column
     * @return the index of the specified column within the resultset or -1
     */
    public int getResultSetIndex(ColumnMetadata c)
    {
<span class="nc" id="L250">        return getColumnIndex(c);</span>
    }

    /**
     * Returns the index of the specified column
     * @param c the column
     * @return the index of the specified column or -1
     */
    protected final int getColumnIndex(ColumnMetadata c)
    {
<span class="nc" id="L260">        return columns.indexOf(c);</span>
    }

    private static SelectionColumnMapping collectColumnMappings(TableMetadata table,
                                                                SelectorFactories factories)
    {
<span class="fc" id="L266">        SelectionColumnMapping selectionColumns = SelectionColumnMapping.newMapping();</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">        for (Selector.Factory factory : factories)</span>
        {
<span class="fc" id="L269">            ColumnSpecification colSpec = factory.getColumnSpecification(table);</span>
<span class="fc" id="L270">            factory.addColumnMapping(selectionColumns, colSpec);</span>
<span class="fc" id="L271">        }</span>
<span class="fc" id="L272">        return selectionColumns;</span>
    }

    public abstract Selectors newSelectors(QueryOptions options);

    /**
     * @return the list of CQL3 columns value this SelectionClause needs.
     */
    public List&lt;ColumnMetadata&gt; getColumns()
    {
<span class="fc" id="L282">        return columns;</span>
    }

    /**
     * @return the mappings between resultset columns and the underlying columns
     */
    public SelectionColumns getColumnMapping()
    {
<span class="nc" id="L290">        return columnMapping;</span>
    }

    public abstract boolean isAggregate();

    @Override
    public String toString()
    {
<span class="nc" id="L298">        return MoreObjects.toStringHelper(this)</span>
<span class="nc" id="L299">                          .add(&quot;columns&quot;, columns)</span>
<span class="nc" id="L300">                          .add(&quot;columnMapping&quot;, columnMapping)</span>
<span class="nc" id="L301">                          .add(&quot;metadata&quot;, metadata)</span>
<span class="nc" id="L302">                          .toString();</span>
    }

    private static List&lt;ByteBuffer&gt; rowToJson(List&lt;ByteBuffer&gt; row,
                                              ProtocolVersion protocolVersion,
                                              ResultSet.ResultMetadata metadata,
                                              List&lt;ColumnMetadata&gt; orderingColumns)
    {
<span class="nc" id="L310">        ByteBuffer[] jsonRow = new ByteBuffer[orderingColumns.size() + 1];</span>
<span class="nc" id="L311">        StringBuilder sb = new StringBuilder(&quot;{&quot;);</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">        for (int i = 0; i &lt; metadata.names.size(); i++)</span>
        {
<span class="nc" id="L314">            ColumnSpecification spec = metadata.names.get(i);</span>
<span class="nc" id="L315">            ByteBuffer buffer = row.get(i);</span>

            // If it is an ordering column we need to keep it in case we need it for post ordering
<span class="nc" id="L318">            int index = orderingColumns.indexOf(spec);</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">            if (index &gt;= 0)</span>
<span class="nc" id="L320">                jsonRow[index + 1] = buffer;</span>

            // If the column is only used for ordering we can stop here.
<span class="nc bnc" id="L323" title="All 2 branches missed.">            if (i &gt;= metadata.getColumnCount())</span>
<span class="nc" id="L324">                continue;</span>

<span class="nc bnc" id="L326" title="All 2 branches missed.">            if (i &gt; 0)</span>
<span class="nc" id="L327">                sb.append(&quot;, &quot;);</span>

<span class="nc" id="L329">            String columnName = spec.name.toString();</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">            if (!columnName.equals(columnName.toLowerCase(Locale.US)))</span>
<span class="nc" id="L331">                columnName = &quot;\&quot;&quot; + columnName + &quot;\&quot;&quot;;</span>

<span class="nc" id="L333">            sb.append('&quot;');</span>
<span class="nc" id="L334">            sb.append(JsonUtils.quoteAsJsonString(columnName));</span>
<span class="nc" id="L335">            sb.append(&quot;\&quot;: &quot;);</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">            if (buffer == null)</span>
<span class="nc" id="L337">                sb.append(&quot;null&quot;);</span>
            else
<span class="nc" id="L339">                sb.append(spec.type.toJSONString(buffer, protocolVersion));</span>
        }
<span class="nc" id="L341">        sb.append(&quot;}&quot;);</span>

<span class="nc" id="L343">        jsonRow[0] = UTF8Type.instance.getSerializer().serialize(sb.toString());</span>
<span class="nc" id="L344">        return Arrays.asList(jsonRow);</span>
    }

    public static interface Selectors
    {
        /**
         * Returns the {@code ColumnFilter} corresponding to those selectors
         *
         * @return the {@code ColumnFilter} corresponding to those selectors
         */
        public ColumnFilter getColumnFilter();

        /**
         * Checks if this Selectors perform some processing
         * @return {@code true} if this Selectors perform some processing, {@code false} otherwise.
         */
        public boolean hasProcessing();

        /**
         * Checks if one of the selectors perform some aggregations.
         * @return {@code true} if one of the selectors perform some aggregations, {@code false} otherwise.
         */
        public boolean isAggregate();

        /**
         * Returns the number of fetched columns
         * @return the number of fetched columns
         */
        public int numberOfFetchedColumns();

        /**
         * Checks if one of the selectors collect TTLs.
         * @return {@code true} if one of the selectors collect TTLs, {@code false} otherwise.
         */
        public boolean collectTTLs();

        /**
         * Checks if one of the selectors collects write timestamps.
         * @return {@code true} if one of the selectors collects write timestamps, {@code false} otherwise.
         */
        public boolean collectWritetimes();

        /**
         * Adds the current row of the specified &lt;code&gt;ResultSetBuilder&lt;/code&gt;.
         *
         * @param input the input row
         */
        public void addInputRow(InputRow input);

        public List&lt;ByteBuffer&gt; getOutputRow();

        public void reset();
    }

    // Special cased selection for when only columns are selected.
    private static class SimpleSelection extends Selection
    {
        private final boolean isWildcard;

        public SimpleSelection(TableMetadata table,
                               List&lt;ColumnMetadata&gt; selectedColumns,
                               Set&lt;ColumnMetadata&gt; orderingColumns,
                               boolean isWildcard,
                               boolean isJson,
                               boolean returnStaticContentOnPartitionWithNoRows)
        {
<span class="fc" id="L410">            this(table,</span>
                 selectedColumns,
                 orderingColumns,
<span class="fc" id="L413">                 SelectionColumnMapping.simpleMapping(selectedColumns),</span>
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">                 isWildcard ? ColumnFilterFactory.wildcard(table)</span>
<span class="pc" id="L415">                            : ColumnFilterFactory.fromColumns(table, selectedColumns, orderingColumns, Collections.emptySet(), returnStaticContentOnPartitionWithNoRows),</span>
                 isWildcard,
                 isJson);
<span class="fc" id="L418">        }</span>

        public SimpleSelection(TableMetadata table,
                               List&lt;ColumnMetadata&gt; selectedColumns,
                               Set&lt;ColumnMetadata&gt; orderingColumns,
                               Set&lt;ColumnMetadata&gt; nonPKRestrictedColumns,
                               SelectionColumnMapping mapping,
                               boolean isJson,
                               boolean returnStaticContentOnPartitionWithNoRows)
        {
<span class="fc" id="L428">            this(table,</span>
                 selectedColumns,
                 orderingColumns,
                 mapping,
<span class="fc" id="L432">                 ColumnFilterFactory.fromColumns(table, selectedColumns, orderingColumns, nonPKRestrictedColumns, returnStaticContentOnPartitionWithNoRows),</span>
                 false,
                 isJson);
<span class="fc" id="L435">        }</span>

        private SimpleSelection(TableMetadata table,
                                List&lt;ColumnMetadata&gt; selectedColumns,
                                Set&lt;ColumnMetadata&gt; orderingColumns,
                                SelectionColumnMapping mapping,
                                ColumnFilterFactory columnFilterFactory,
                                boolean isWildcard,
                                boolean isJson)
        {
            /*
             * In theory, even a simple selection could have multiple time the same column, so we
             * could filter those duplicate out of columns. But since we're very unlikely to
             * get much duplicate in practice, it's more efficient not to bother.
             */
<span class="fc" id="L450">            super(table, selectedColumns, orderingColumns, mapping, columnFilterFactory, isJson);</span>
<span class="fc" id="L451">            this.isWildcard = isWildcard;</span>
<span class="fc" id="L452">        }</span>

        @Override
        public boolean isWildcard()
        {
<span class="nc" id="L457">            return isWildcard;</span>
        }

        public boolean isAggregate()
        {
<span class="fc" id="L462">            return false;</span>
        }

        public Selectors newSelectors(QueryOptions options)
        {
<span class="fc" id="L467">            return new Selectors()</span>
<span class="fc" id="L468">            {</span>
                private List&lt;ByteBuffer&gt; current;

                public void reset()
                {
<span class="fc" id="L473">                    current = null;</span>
<span class="fc" id="L474">                }</span>

                public List&lt;ByteBuffer&gt; getOutputRow()
                {
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">                    if (isJson)</span>
<span class="nc" id="L479">                        return rowToJson(current, options.getProtocolVersion(), metadata, orderingColumns);</span>
<span class="fc" id="L480">                    return current;</span>
                }

                public void addInputRow(InputRow input)
                {
<span class="fc" id="L485">                    current = input.getValues();</span>
<span class="fc" id="L486">                }</span>

                public boolean isAggregate()
                {
<span class="nc" id="L490">                    return false;</span>
                }

                public boolean hasProcessing()
                {
<span class="fc" id="L495">                    return false;</span>
                }

                @Override
                public int numberOfFetchedColumns()
                {
<span class="nc" id="L501">                    return getColumns().size();</span>
                }

                @Override
                public boolean collectTTLs()
                {
<span class="fc" id="L507">                    return false;</span>
                }

                @Override
                public boolean collectWritetimes()
                {
<span class="fc" id="L513">                    return false;</span>
                }

                @Override
                public ColumnFilter getColumnFilter()
                {
                    // In the case of simple selection we know that the ColumnFilter has already been computed and
                    // that by consequence the selectors argument has not impact on the output.
<span class="fc" id="L521">                    return columnFilterFactory.newInstance(null);</span>
                }
            };
        }
    }

    private static class SelectionWithProcessing extends Selection
    {
        private final SelectorFactories factories;
        private final boolean collectWritetimes;
        private final boolean collectMaxWritetimes;
        private final boolean collectTTLs;

        public SelectionWithProcessing(TableMetadata table,
                                       List&lt;ColumnMetadata&gt; columns,
                                       Set&lt;ColumnMetadata&gt; orderingColumns,
                                       Set&lt;ColumnMetadata&gt; nonPKRestrictedColumns,
                                       SelectionColumnMapping metadata,
                                       SelectorFactories factories,
                                       boolean isJson,
                                       boolean returnStaticContentOnPartitionWithNoRows)
        {
<span class="fc" id="L543">            super(table,</span>
                  columns,
                  orderingColumns,
                  metadata,
<span class="fc" id="L547">                  ColumnFilterFactory.fromSelectorFactories(table, factories, orderingColumns, nonPKRestrictedColumns, returnStaticContentOnPartitionWithNoRows),</span>
                  isJson);

<span class="fc" id="L550">            this.factories = factories;</span>
<span class="fc" id="L551">            this.collectWritetimes = factories.containsWritetimeSelectorFactory();</span>
<span class="fc" id="L552">            this.collectMaxWritetimes = factories.containsMaxWritetimeSelectorFactory();</span>
<span class="fc" id="L553">            this.collectTTLs = factories.containsTTLSelectorFactory();</span>

<span class="pc bpc" id="L555" title="1 of 2 branches missed.">            for (ColumnMetadata orderingColumn : orderingColumns)</span>
            {
<span class="nc" id="L557">                factories.addSelectorForOrdering(orderingColumn, getColumnIndex(orderingColumn));</span>
<span class="nc" id="L558">            }</span>
<span class="fc" id="L559">        }</span>

        @Override
        public void addFunctionsTo(List&lt;Function&gt; functions)
        {
<span class="fc" id="L564">            factories.addFunctionsTo(functions);</span>
<span class="fc" id="L565">        }</span>

        @Override
        public int getResultSetIndex(ColumnMetadata c)
        {
<span class="nc" id="L570">            return factories.indexOfSimpleSelectorFactory(super.getResultSetIndex(c));</span>
        }

        public boolean isAggregate()
        {
<span class="fc" id="L575">            return factories.doesAggregation();</span>
        }

        public Selectors newSelectors(final QueryOptions options) throws InvalidRequestException
        {
<span class="fc" id="L580">            return new Selectors()</span>
<span class="fc" id="L581">            {</span>
<span class="fc" id="L582">                private final List&lt;Selector&gt; selectors = factories.newInstances(options);</span>

                public void reset()
                {
<span class="fc bfc" id="L586" title="All 2 branches covered.">                    for (Selector selector : selectors)</span>
<span class="fc" id="L587">                        selector.reset();</span>
<span class="fc" id="L588">                }</span>

                public boolean isAggregate()
                {
<span class="nc" id="L592">                    return factories.doesAggregation();</span>
                }

                public boolean hasProcessing()
                {
<span class="fc" id="L597">                    return true;</span>
                }

                public List&lt;ByteBuffer&gt; getOutputRow()
                {
<span class="fc" id="L602">                    List&lt;ByteBuffer&gt; outputRow = new ArrayList&lt;&gt;(selectors.size());</span>

<span class="fc bfc" id="L604" title="All 2 branches covered.">                    for (Selector selector: selectors)</span>
<span class="fc" id="L605">                        outputRow.add(selector.getOutput(options.getProtocolVersion()));</span>

<span class="pc bpc" id="L607" title="1 of 2 branches missed.">                    return isJson ? rowToJson(outputRow, options.getProtocolVersion(), metadata, orderingColumns) : outputRow;</span>
                }

                public void addInputRow(InputRow input)
                {
<span class="fc bfc" id="L612" title="All 2 branches covered.">                    for (Selector selector : selectors)</span>
<span class="fc" id="L613">                        selector.addInput(input);</span>
<span class="fc" id="L614">                }</span>

                @Override
                public int numberOfFetchedColumns()
                {
<span class="nc" id="L619">                    return getColumns().size();</span>
                }

                @Override
                public boolean collectTTLs()
                {
<span class="fc" id="L625">                    return collectTTLs;</span>
                }

                @Override
                public boolean collectWritetimes()
                {
<span class="pc bpc" id="L631" title="2 of 4 branches missed.">                    return collectWritetimes || collectMaxWritetimes;</span>
                }

                @Override
                public ColumnFilter getColumnFilter()
                {
<span class="fc" id="L637">                    return columnFilterFactory.newInstance(selectors);</span>
                }
            };
        }

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>