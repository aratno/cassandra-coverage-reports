<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HandshakeProtocol.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.net</a> &gt; <span class="el_source">HandshakeProtocol.java</span></div><h1>HandshakeProtocol.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.net;

import java.io.EOFException;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Objects;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.io.compress.BufferType;
import org.apache.cassandra.io.util.DataInputBuffer;
import org.apache.cassandra.io.util.DataOutputBufferFixed;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.utils.memory.BufferPools;

import static java.util.concurrent.TimeUnit.MILLISECONDS;
import static org.apache.cassandra.locator.InetAddressAndPort.Serializer.inetAddressAndPortSerializer;
import static org.apache.cassandra.net.MessagingService.VERSION_40;
import static org.apache.cassandra.net.Message.validateLegacyProtocolMagic;
import static org.apache.cassandra.net.Crc.*;
import static org.apache.cassandra.net.OutboundConnectionSettings.*;

/**
 * Messages for the handshake phase of the internode protocol.
 *
 * The modern handshake is composed of 2 messages: Initiate and Accept
 * &lt;p&gt;
 * The legacy handshake is composed of 3 messages, the first being sent by the initiator of the connection. The other
 * side then answer with the 2nd message. At that point, if a version mismatch is detected by the connection initiator,
 * it will simply disconnect and reconnect with a more appropriate version. But if the version is acceptable, the connection
 * initiator sends the third message of the protocol, after which it considers the connection ready.
 */
<span class="nc" id="L51">class HandshakeProtocol</span>
{
<span class="fc" id="L53">    static final long TIMEOUT_MILLIS = 3 * DatabaseDescriptor.getRpcTimeout(MILLISECONDS);</span>

    /**
     * The initial message sent when a node creates a new connection to a remote peer. This message contains:
     *   1) the {@link Message#PROTOCOL_MAGIC} number (4 bytes).
     *   2) the connection flags (4 bytes), which encodes:
     *      - the version the initiator thinks should be used for the connection (in practice, either the initiator
     *        version if it's the first time we connect to that remote since startup, or the last version known for that
     *        peer otherwise).
     *      - the &quot;mode&quot; of the connection: whether it is for streaming or for messaging.
     *      - whether compression should be used or not (if it is, compression is enabled _after_ the last message of the
     *        handshake has been sent).
     *   3) the connection initiator's broadcast address
     *   4) a CRC protecting the message from corruption
     * &lt;p&gt;
     * More precisely, connection flags:
     * &lt;pre&gt;
     * {@code
     *                      1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
     *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     * |C C C M C      |    REQUEST    |      MIN      |      MAX      |
     * |A A M O R      |    VERSION    |   SUPPORTED   |   SUPPORTED   |
     * |T T P D C      |  (DEPRECATED) |    VERSION    |    VERSION    |
     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     * }
     * &lt;/pre&gt;
     * CAT - QOS category, 2 bits: SMALL, LARGE, URGENT, or LEGACY (unset)
     * CMP - compression enabled bit
     * MOD - connection mode; if the bit is on, the connection is for streaming; if the bit is off, it is for inter-node messaging.
     * CRC - crc enabled bit
     * VERSION - {@link org.apache.cassandra.net.MessagingService#current_version}
     */
    static class Initiate
    {
        /** Contains the PROTOCOL_MAGIC (int) and the flags (int). */
        private static final int MIN_LENGTH = 8;
        private static final int MAX_LENGTH = 12 + InetAddressAndPort.Serializer.MAXIMUM_SIZE;

        // the messagingVersion bounds the sender will accept to initiate a connection;
        // if the remote peer supports any, the newest supported version will be selected; otherwise the nearest supported version
        final AcceptVersions acceptVersions;
        final ConnectionType type;
        final Framing framing;
        final InetAddressAndPort from;

        Initiate(AcceptVersions acceptVersions, ConnectionType type, Framing framing, InetAddressAndPort from)
<span class="fc" id="L100">        {</span>
<span class="fc" id="L101">            this.acceptVersions = acceptVersions;</span>
<span class="fc" id="L102">            this.type = type;</span>
<span class="fc" id="L103">            this.framing = framing;</span>
<span class="fc" id="L104">            this.from = from;</span>
<span class="fc" id="L105">        }</span>

        private int encodeFlags()
        {
<span class="fc" id="L109">            int flags = 0;</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">            if (type.isMessaging())</span>
<span class="nc" id="L111">                flags |= type.twoBitID();</span>
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">            if (type.isStreaming())</span>
<span class="fc" id="L113">                flags |= 1 &lt;&lt; 3;</span>

            // framing id is split over 2nd and 4th bits, for backwards compatibility
<span class="fc" id="L116">            flags |= ((framing.id &amp; 1) &lt;&lt; 2) | ((framing.id &amp; 2) &lt;&lt; 3);</span>
<span class="fc" id="L117">            flags |= (acceptVersions.min &lt;&lt; 8); // legacy (pre40)</span>
<span class="fc" id="L118">            flags |= (acceptVersions.min &lt;&lt; 16);</span>
<span class="fc" id="L119">            flags |= (acceptVersions.max &lt;&lt; 24);</span>
<span class="fc" id="L120">            return flags;</span>
        }

        ByteBuf encode()
        {
<span class="fc" id="L125">            ByteBuffer buffer = BufferPools.forNetworking().get(MAX_LENGTH, BufferType.OFF_HEAP);</span>
<span class="fc" id="L126">            try (DataOutputBufferFixed out = new DataOutputBufferFixed(buffer))</span>
            {
<span class="fc" id="L128">                out.writeInt(Message.PROTOCOL_MAGIC);</span>
<span class="fc" id="L129">                out.writeInt(encodeFlags());</span>
<span class="fc" id="L130">                inetAddressAndPortSerializer.serialize(from, out, acceptVersions.min);</span>
<span class="fc" id="L131">                out.writeInt(computeCrc32(buffer, 0, buffer.position()));</span>
<span class="fc" id="L132">                buffer.flip();</span>
<span class="fc" id="L133">                return GlobalBufferPoolAllocator.wrap(buffer);</span>
            }
<span class="nc" id="L135">            catch (IOException e)</span>
            {
<span class="nc" id="L137">                throw new IllegalStateException(e);</span>
            }
        }

        static Initiate maybeDecode(ByteBuf buf) throws IOException
        {
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">            if (buf.readableBytes() &lt; MIN_LENGTH)</span>
<span class="nc" id="L144">                return null;</span>

<span class="fc" id="L146">            ByteBuffer nio = buf.nioBuffer();</span>
<span class="fc" id="L147">            int start = nio.position();</span>
<span class="fc" id="L148">            try (DataInputBuffer in = new DataInputBuffer(nio, false))</span>
            {
<span class="fc" id="L150">                validateLegacyProtocolMagic(in.readInt());</span>
<span class="fc" id="L151">                int flags = in.readInt();</span>

                // legacy pre40 messagingVersion flag
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">                if (getBits(flags, 8, 8) &lt; VERSION_40)</span>
<span class="nc" id="L155">                    return null;</span>

<span class="fc" id="L157">                int minMessagingVersion = getBits(flags, 16, 8);</span>
<span class="fc" id="L158">                int maxMessagingVersion = getBits(flags, 24, 8);</span>

                // 5.0+ does not support pre40
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">                if (maxMessagingVersion &lt; MessagingService.VERSION_40)</span>
<span class="nc" id="L162">                    return null;</span>

<span class="fc" id="L164">                int framingBits = getBits(flags, 2, 1) | (getBits(flags, 4, 1) &lt;&lt; 1);</span>
<span class="fc" id="L165">                Framing framing = Framing.forId(framingBits);</span>

<span class="pc bpc" id="L167" title="1 of 2 branches missed.">                boolean isStream = getBits(flags, 3, 1) == 1;</span>

<span class="pc bpc" id="L169" title="1 of 2 branches missed.">                ConnectionType type = isStream</span>
<span class="fc" id="L170">                                    ? ConnectionType.STREAMING</span>
<span class="pc" id="L171">                                    : ConnectionType.fromId(getBits(flags, 0, 2));</span>

<span class="fc" id="L173">                InetAddressAndPort from = inetAddressAndPortSerializer.deserialize(in, minMessagingVersion);</span>

<span class="fc" id="L175">                int computed = computeCrc32(nio, start, nio.position());</span>
<span class="fc" id="L176">                int read = in.readInt();</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">                if (read != computed)</span>
<span class="nc" id="L178">                    throw new InvalidCrc(read, computed);</span>

<span class="fc" id="L180">                buf.skipBytes(nio.position() - start);</span>
<span class="fc" id="L181">                return new Initiate(new AcceptVersions(minMessagingVersion, maxMessagingVersion), type, framing, from);</span>

<span class="nc" id="L183">            }</span>
<span class="nc" id="L184">            catch (EOFException e)</span>
            {
<span class="nc" id="L186">                return null;</span>
            }
        }

        @Override
        public boolean equals(Object other)
        {
<span class="nc bnc" id="L193" title="All 2 branches missed.">            if (!(other instanceof Initiate))</span>
<span class="nc" id="L194">                return false;</span>

<span class="nc" id="L196">            Initiate that = (Initiate)other;</span>
<span class="nc bnc" id="L197" title="All 4 branches missed.">            return    this.type == that.type</span>
                   &amp;&amp; this.framing == that.framing
<span class="nc bnc" id="L199" title="All 2 branches missed.">                   &amp;&amp; Objects.equals(this.acceptVersions, that.acceptVersions);</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L205">            return String.format(&quot;Initiate(min: %d, max: %d, type: %s, framing: %b, from: %s)&quot;,</span>
<span class="nc" id="L206">                                 acceptVersions.min,</span>
<span class="nc" id="L207">                                 acceptVersions.max,</span>
                                 type, framing, from);
        }
    }


    /**
     * The second message of the handshake, sent by the node receiving the {@link Initiate} back to the
     * connection initiator.
     *
     * This message contains
     *   1) the messaging version of the peer sending this message
     *   2) the negotiated messaging version if one could be accepted by both peers,
     *      or if not the closest version that this peer could support to the ones requested
     *   3) a CRC protecting the integrity of the message
     *
     */
    static class Accept
    {
        /** The messaging version sent by the receiving peer (int). */
        private static final int MAX_LENGTH = 12;

        final int useMessagingVersion;
        final int maxMessagingVersion;

        Accept(int useMessagingVersion, int maxMessagingVersion)
<span class="fc" id="L233">        {</span>
<span class="fc" id="L234">            this.useMessagingVersion = useMessagingVersion;</span>
<span class="fc" id="L235">            this.maxMessagingVersion = maxMessagingVersion;</span>
<span class="fc" id="L236">        }</span>

        ByteBuf encode(ByteBufAllocator allocator)
        {
<span class="fc" id="L240">            ByteBuf buffer = allocator.directBuffer(MAX_LENGTH);</span>
<span class="fc" id="L241">            buffer.clear();</span>
<span class="fc" id="L242">            buffer.writeInt(maxMessagingVersion);</span>
<span class="fc" id="L243">            buffer.writeInt(useMessagingVersion);</span>
<span class="fc" id="L244">            buffer.writeInt(computeCrc32(buffer, 0, 8));</span>
<span class="fc" id="L245">            return buffer;</span>
        }

        static Accept maybeDecode(ByteBuf in) throws InvalidCrc
        {
<span class="fc" id="L250">            int readerIndex = in.readerIndex();</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">            if (in.readableBytes() &lt; 4)</span>
<span class="nc" id="L252">                return null;</span>
<span class="fc" id="L253">            int maxMessagingVersion = in.readInt();</span>
<span class="fc" id="L254">            int useMessagingVersion = 0;</span>

            // pre-4.0 not supported, close the connection
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">            if (maxMessagingVersion &lt; VERSION_40)</span>
<span class="nc" id="L258">                return null;</span>

<span class="pc bpc" id="L260" title="1 of 2 branches missed.">            if (in.readableBytes() &lt; 8)</span>
            {
<span class="nc" id="L262">                in.readerIndex(readerIndex);</span>
<span class="nc" id="L263">                return null;</span>
            }
<span class="fc" id="L265">            useMessagingVersion = in.readInt();</span>

            // verify crc
<span class="fc" id="L268">            int computed = computeCrc32(in, readerIndex, readerIndex + 8);</span>
<span class="fc" id="L269">            int read = in.readInt();</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">            if (read != computed)</span>
<span class="nc" id="L271">                throw new InvalidCrc(read, computed);</span>

<span class="fc" id="L273">            return new Accept(useMessagingVersion, maxMessagingVersion);</span>
        }

        @Override
        public boolean equals(Object other)
        {
<span class="nc bnc" id="L279" title="All 6 branches missed.">            return other instanceof Accept</span>
                   &amp;&amp; this.useMessagingVersion == ((Accept) other).useMessagingVersion
                   &amp;&amp; this.maxMessagingVersion == ((Accept) other).maxMessagingVersion;
        }

        @Override
        public String toString()
        {
<span class="nc" id="L287">            return String.format(&quot;Accept(use: %d, max: %d)&quot;, useMessagingVersion, maxMessagingVersion);</span>
        }
    }

    private static int getBits(int packed, int start, int count)
    {
<span class="fc" id="L293">        return (packed &gt;&gt;&gt; start) &amp; ~(-1 &lt;&lt; count);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>