<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReplicationAwareTokenAllocator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.dht.tokenallocator</a> &gt; <span class="el_source">ReplicationAwareTokenAllocator.java</span></div><h1>ReplicationAwareTokenAllocator.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.dht.tokenallocator;

import java.util.*;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;

import org.apache.cassandra.dht.IPartitioner;
import org.apache.cassandra.dht.Token;

/**
 * A Replication Aware allocator for tokens, that attempts to ensure an even distribution of ownership across
 * the known cluster for the provided replication strategy.
 *
 * A unit is shorthand for a &quot;unit of ownership&quot; which translates roughly to a node, or a disk on the node,
 * a CPU on the node, or some other relevant unit of ownership. These units should be the lowest rung over which
 * ownership needs to be evenly distributed. At the moment only nodes as a whole are treated as units, but that
 * will change with the introduction of token ranges per disk.
 */
<span class="fc" id="L39">class ReplicationAwareTokenAllocator&lt;Unit&gt; extends TokenAllocatorBase&lt;Unit&gt;</span>
{
    final Multimap&lt;Unit, Token&gt; unitToTokens;
    final int replicas;

    ReplicationAwareTokenAllocator(NavigableMap&lt;Token, Unit&gt; sortedTokens, ReplicationStrategy&lt;Unit&gt; strategy, IPartitioner partitioner)
    {
<span class="fc" id="L46">        super(sortedTokens, strategy, partitioner);</span>
<span class="fc" id="L47">        unitToTokens = HashMultimap.create();</span>
<span class="fc bfc" id="L48" title="All 2 branches covered.">        for (Map.Entry&lt;Token, Unit&gt; en : sortedTokens.entrySet())</span>
<span class="fc" id="L49">            unitToTokens.put(en.getValue(), en.getKey());</span>
<span class="fc" id="L50">        this.replicas = strategy.replicas();</span>
<span class="fc" id="L51">    }</span>

    public int getReplicas()
    {
<span class="nc" id="L55">        return replicas;</span>
    }

    public Collection&lt;Token&gt; addUnit(Unit newUnit, int numTokens)
    {
<span class="pc bpc" id="L60" title="1 of 2 branches missed.">        assert !unitToTokens.containsKey(newUnit);</span>

<span class="fc bfc" id="L62" title="All 2 branches covered.">        if (unitCount() &lt; replicas)</span>
            // Allocation does not matter for now; everything replicates everywhere. However, at this point it is
            // important to start the cluster/datacenter with suitably varied token range sizes so that the algorithm
            // can maintain good balance for any number of nodes.
<span class="fc" id="L66">            return generateSplits(newUnit, numTokens);</span>
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">        if (numTokens &gt; sortedTokens.size())</span>
            // Some of the heuristics below can't deal with this very unlikely case. Use splits for now,
            // later allocations can fix any problems this may cause.
<span class="nc" id="L70">            return generateSplits(newUnit, numTokens);</span>

        // ============= construct our initial token ring state =============

<span class="fc" id="L74">        double optTokenOwnership = optimalTokenOwnership(numTokens);</span>
<span class="fc" id="L75">        Map&lt;Object, GroupInfo&gt; groups = Maps.newHashMap();</span>
<span class="fc" id="L76">        Map&lt;Unit, UnitInfo&lt;Unit&gt;&gt; unitInfos = createUnitInfos(groups);</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">        if (groups.size() &lt; replicas)</span>
        {
            // We need at least replicas groups to do allocation correctly. If there aren't enough,
            // use splits as above.
            // This part of the code should only be reached via the RATATest. StrategyAdapter should disallow
            // token allocation in this case as the algorithm is not able to cover the behavior of NetworkTopologyStrategy.
<span class="fc" id="L83">            return generateSplits(newUnit, numTokens);</span>
        }

        // initialise our new unit's state (with an idealised ownership)
        // strategy must already know about this unit
<span class="fc" id="L88">        UnitInfo&lt;Unit&gt; newUnitInfo = new UnitInfo&lt;&gt;(newUnit, numTokens * optTokenOwnership, groups, strategy);</span>

        // build the current token ring state
<span class="fc" id="L91">        TokenInfo&lt;Unit&gt; tokens = createTokenInfos(unitInfos, newUnitInfo.group);</span>
<span class="fc" id="L92">        newUnitInfo.tokenCount = numTokens;</span>

        // ============= construct and rank our candidate token allocations =============

        // walk the token ring, constructing the set of candidates in ring order
        // as the midpoints between all existing tokens
<span class="fc" id="L98">        CandidateInfo&lt;Unit&gt; candidates = createCandidates(tokens, newUnitInfo, optTokenOwnership);</span>

        // Evaluate the expected improvements from all candidates and form a priority queue.
<span class="fc" id="L101">        PriorityQueue&lt;Weighted&lt;CandidateInfo&lt;Unit&gt;&gt;&gt; improvements = new PriorityQueue&lt;&gt;(sortedTokens.size());</span>
<span class="fc" id="L102">        CandidateInfo&lt;Unit&gt; candidate = candidates;</span>
        do
        {
<span class="fc" id="L105">            double impr = evaluateImprovement(candidate, optTokenOwnership, 1.0 / numTokens);</span>
<span class="fc" id="L106">            improvements.add(new Weighted&lt;&gt;(impr, candidate));</span>
<span class="fc" id="L107">            candidate = candidate.next;</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">        } while (candidate != candidates);</span>

        // ============= iteratively take the best candidate, and re-rank =============

<span class="fc" id="L112">        CandidateInfo&lt;Unit&gt; bestToken = improvements.remove().value;</span>
<span class="fc" id="L113">        for (int vn = 1; ; ++vn)</span>
        {
<span class="fc" id="L115">            candidates = bestToken.removeFrom(candidates);</span>
<span class="fc" id="L116">            confirmCandidate(bestToken);</span>

<span class="fc bfc" id="L118" title="All 2 branches covered.">            if (vn == numTokens)</span>
<span class="fc" id="L119">                break;</span>

            while (true)
            {
                // Get the next candidate in the queue. Its improvement may have changed (esp. if multiple tokens
                // were good suggestions because they could improve the same problem)-- evaluate it again to check
                // if it is still a good candidate.
<span class="fc" id="L126">                bestToken = improvements.remove().value;</span>
<span class="fc" id="L127">                double impr = evaluateImprovement(bestToken, optTokenOwnership, (vn + 1.0) / numTokens);</span>
<span class="fc" id="L128">                Weighted&lt;CandidateInfo&lt;Unit&gt;&gt; next = improvements.peek();</span>

                // If it is better than the next in the queue, it is good enough. This is a heuristic that doesn't
                // get the best results, but works well enough and on average cuts search time by a factor of O(vnodes).
<span class="pc bpc" id="L132" title="1 of 4 branches missed.">                if (next == null || impr &gt;= next.weight)</span>
<span class="fc" id="L133">                    break;</span>
<span class="fc" id="L134">                improvements.add(new Weighted&lt;&gt;(impr, bestToken));</span>
<span class="fc" id="L135">            }</span>
        }

<span class="fc" id="L138">        ImmutableList&lt;Token&gt; newTokens = ImmutableList.copyOf(unitToTokens.get(newUnit));</span>
<span class="fc" id="L139">        TokenAllocatorDiagnostics.unitedAdded(this, numTokens, unitToTokens, sortedTokens, newTokens, newUnit);</span>
<span class="fc" id="L140">        return newTokens;</span>
    }

    /**
     * Selects tokens by repeatedly splitting the largest range in the ring at the given ratio.
     * This is used to choose tokens for the first nodes in the ring where the algorithm cannot be applied (e.g. when
     * number of nodes &lt; RF). It generates a reasonably chaotic initial token split, after which the algorithm behaves
     * well for an unbounded number of nodes.
     */

    @Override
    Collection&lt;Token&gt; generateSplits(Unit newUnit, int numTokens)
    {
<span class="fc" id="L153">        Collection&lt;Token&gt; tokens = super.generateSplits(newUnit, numTokens);</span>
<span class="fc" id="L154">        unitToTokens.putAll(newUnit, tokens);</span>
<span class="fc" id="L155">        TokenAllocatorDiagnostics.splitsGenerated(this, numTokens, unitToTokens, sortedTokens, newUnit, tokens);</span>
<span class="fc" id="L156">        return tokens;</span>
    }

    /**
     * Construct the token ring as a CircularList of TokenInfo,
     * and populate the ownership of the UnitInfo's provided
     */
    private TokenInfo&lt;Unit&gt; createTokenInfos(Map&lt;Unit, UnitInfo&lt;Unit&gt;&gt; units, GroupInfo newUnitGroup)
    {
        // build the circular list
<span class="fc" id="L166">        TokenInfo&lt;Unit&gt; prev = null;</span>
<span class="fc" id="L167">        TokenInfo&lt;Unit&gt; first = null;</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">        for (Map.Entry&lt;Token, Unit&gt; en : sortedTokens.entrySet())</span>
        {
<span class="fc" id="L170">            Token t = en.getKey();</span>
<span class="fc" id="L171">            UnitInfo&lt;Unit&gt; ni = units.get(en.getValue());</span>
<span class="fc" id="L172">            TokenInfo&lt;Unit&gt; ti = new TokenInfo&lt;&gt;(t, ni);</span>
<span class="fc" id="L173">            first = ti.insertAfter(first, prev);</span>
<span class="fc" id="L174">            prev = ti;</span>
<span class="fc" id="L175">        }</span>

<span class="fc" id="L177">        TokenInfo&lt;Unit&gt; curr = first;</span>
        do
        {
<span class="fc" id="L180">            populateTokenInfoAndAdjustUnit(curr, newUnitGroup);</span>
<span class="fc" id="L181">            curr = curr.next;</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">        } while (curr != first);</span>

<span class="fc" id="L184">        TokenAllocatorDiagnostics.tokenInfosCreated(this, unitToTokens, first);</span>
<span class="fc" id="L185">        return first;</span>
    }

    private CandidateInfo&lt;Unit&gt; createCandidates(TokenInfo&lt;Unit&gt; tokens, UnitInfo&lt;Unit&gt; newUnitInfo, double initialTokenOwnership)
    {
<span class="fc" id="L190">        TokenInfo&lt;Unit&gt; curr = tokens;</span>
<span class="fc" id="L191">        CandidateInfo&lt;Unit&gt; first = null;</span>
<span class="fc" id="L192">        CandidateInfo&lt;Unit&gt; prev = null;</span>
        do
        {
<span class="fc" id="L195">            CandidateInfo&lt;Unit&gt; candidate = new CandidateInfo&lt;Unit&gt;(partitioner.midpoint(curr.prev.token, curr.token), curr, newUnitInfo);</span>
<span class="fc" id="L196">            first = candidate.insertAfter(first, prev);</span>

<span class="fc" id="L198">            candidate.replicatedOwnership = initialTokenOwnership;</span>
<span class="fc" id="L199">            populateCandidate(candidate);</span>

<span class="fc" id="L201">            prev = candidate;</span>
<span class="fc" id="L202">            curr = curr.next;</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">        } while (curr != tokens);</span>
<span class="fc" id="L204">        prev.next = first;</span>
<span class="fc" id="L205">        return first;</span>
    }

    private void populateCandidate(CandidateInfo&lt;Unit&gt; candidate)
    {
        // Only finding replication start would do.
<span class="fc" id="L211">        populateTokenInfo(candidate, candidate.owningUnit.group);</span>
<span class="fc" id="L212">    }</span>

    /**
     * Incorporates the selected candidate into the ring, adjusting ownership information and calculated token
     * information.
     */
    private void confirmCandidate(CandidateInfo&lt;Unit&gt; candidate)
    {
        // This process is less efficient than it could be (loops through each vnode's replication span instead
        // of recalculating replicationStart, replicationThreshold from existing data + new token data in an O(1)
        // case analysis similar to evaluateImprovement). This is fine as the method does not dominate processing
        // time.

        // Put the accepted candidate in the token list.
<span class="fc" id="L226">        UnitInfo&lt;Unit&gt; newUnit = candidate.owningUnit;</span>
<span class="fc" id="L227">        Token newToken = candidate.token;</span>
<span class="fc" id="L228">        sortedTokens.put(newToken, newUnit.unit);</span>
<span class="fc" id="L229">        unitToTokens.put(newUnit.unit, newToken);</span>

<span class="fc" id="L231">        TokenInfo&lt;Unit&gt; prev = candidate.prevInRing();</span>
<span class="fc" id="L232">        TokenInfo&lt;Unit&gt; newTokenInfo = new TokenInfo&lt;&gt;(newToken, newUnit);</span>
<span class="fc" id="L233">        newTokenInfo.replicatedOwnership = candidate.replicatedOwnership;</span>
<span class="fc" id="L234">        newTokenInfo.insertAfter(prev, prev);   // List is not empty so this won't need to change head of list.</span>

        // Update data for candidate.
<span class="fc" id="L237">        populateTokenInfoAndAdjustUnit(newTokenInfo, newUnit.group);</span>

<span class="fc" id="L239">        ReplicationVisitor replicationVisitor = new ReplicationVisitor();</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        assert newTokenInfo.next == candidate.split;</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">        for (TokenInfo&lt;Unit&gt; curr = newTokenInfo.next; !replicationVisitor.visitedAll(); curr = curr.next)</span>
        {
            // update the candidate between curr and next
<span class="fc" id="L244">            candidate = candidate.next;</span>
<span class="fc" id="L245">            populateCandidate(candidate);</span>

<span class="fc bfc" id="L247" title="All 2 branches covered.">            if (!replicationVisitor.add(curr.owningUnit.group))</span>
<span class="fc" id="L248">                continue;    // If we've already seen this group, the token cannot be affected.</span>

<span class="fc" id="L250">            populateTokenInfoAndAdjustUnit(curr, newUnit.group);</span>
        }

<span class="fc" id="L253">        replicationVisitor.clean();</span>
<span class="fc" id="L254">    }</span>

    /**
     * Calculates the {@code replicationStart} of a token, as well as {@code replicationThreshold} which is chosen in a way
     * that permits {@code findUpdatedReplicationStart} to quickly identify changes in ownership.
     */
    private Token populateTokenInfo(BaseTokenInfo&lt;Unit, ?&gt; token, GroupInfo newUnitGroup)
    {
<span class="fc" id="L262">        GroupInfo tokenGroup = token.owningUnit.group;</span>
<span class="fc" id="L263">        PopulateVisitor visitor = new PopulateVisitor();</span>

        // Replication start = the end of a token from the RF'th different group seen before the token.
        Token replicationStart;
        // The end of a token from the RF-1'th different group seen before the token.
<span class="fc" id="L268">        Token replicationThreshold = token.token;</span>
        GroupInfo currGroup;
<span class="fc" id="L270">        for (TokenInfo&lt;Unit&gt; curr = token.prevInRing(); ; curr = curr.prev)</span>
        {
<span class="fc" id="L272">            replicationStart = curr.token;</span>
<span class="fc" id="L273">            currGroup = curr.owningUnit.group;</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">            if (!visitor.add(currGroup))</span>
<span class="fc" id="L275">                continue; // Group is already seen.</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">            if (visitor.visitedAll())</span>
<span class="fc" id="L277">                break;</span>

<span class="fc" id="L279">            replicationThreshold = replicationStart;</span>
            // Another instance of the same group precedes us in the replication range of the ring,
            // so this is where our replication range begins
<span class="fc bfc" id="L282" title="All 2 branches covered.">            if (currGroup == tokenGroup)</span>
<span class="fc" id="L283">                break;</span>
        }
<span class="fc bfc" id="L285" title="All 2 branches covered.">        if (newUnitGroup == tokenGroup)</span>
            // new token is always a boundary (as long as it's closer than replicationStart)
<span class="fc" id="L287">            replicationThreshold = token.token;</span>
<span class="fc bfc" id="L288" title="All 4 branches covered.">        else if (newUnitGroup != currGroup &amp;&amp; visitor.seen(newUnitGroup))</span>
            // already has new group in replication span before last seen. cannot be affected
<span class="fc" id="L290">            replicationThreshold = replicationStart;</span>
<span class="fc" id="L291">        visitor.clean();</span>

<span class="fc" id="L293">        token.replicationThreshold = replicationThreshold;</span>
<span class="fc" id="L294">        token.replicationStart = replicationStart;</span>
<span class="fc" id="L295">        return replicationStart;</span>
    }

    private void populateTokenInfoAndAdjustUnit(TokenInfo&lt;Unit&gt; populate, GroupInfo newUnitGroup)
    {
<span class="fc" id="L300">        Token replicationStart = populateTokenInfo(populate, newUnitGroup);</span>
<span class="fc" id="L301">        double newOwnership = replicationStart.size(populate.token);</span>
<span class="fc" id="L302">        double oldOwnership = populate.replicatedOwnership;</span>
<span class="fc" id="L303">        populate.replicatedOwnership = newOwnership;</span>
<span class="fc" id="L304">        populate.owningUnit.ownership += newOwnership - oldOwnership;</span>
<span class="fc" id="L305">    }</span>

    /**
     * Evaluates the improvement in variance for both units and individual tokens when candidate is inserted into the
     * ring.
     */
    private double evaluateImprovement(CandidateInfo&lt;Unit&gt; candidate, double optTokenOwnership, double newUnitMult)
    {
<span class="fc" id="L313">        double tokenChange = 0;</span>

<span class="fc" id="L315">        UnitInfo&lt;Unit&gt; candidateUnit = candidate.owningUnit;</span>
<span class="fc" id="L316">        Token candidateEnd = candidate.token;</span>

        // Form a chain of units affected by the insertion to be able to qualify change of unit ownership.
        // A unit may be affected more than once.
<span class="fc" id="L320">        UnitAdjustmentTracker&lt;Unit&gt; unitTracker = new UnitAdjustmentTracker&lt;&gt;(candidateUnit);</span>

        // Reflect change in ownership of the splitting token (candidate).
<span class="fc" id="L323">        tokenChange += applyOwnershipAdjustment(candidate, candidateUnit, candidate.replicationStart, candidateEnd, optTokenOwnership, unitTracker);</span>

        // Loop through all vnodes that replicate candidate or split and update their ownership.
<span class="fc" id="L326">        ReplicationVisitor replicationVisitor = new ReplicationVisitor();</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">        for (TokenInfo&lt;Unit&gt; curr = candidate.split; !replicationVisitor.visitedAll(); curr = curr.next)</span>
        {
<span class="fc" id="L329">            UnitInfo&lt;Unit&gt; currUnit = curr.owningUnit;</span>

<span class="fc bfc" id="L331" title="All 2 branches covered.">            if (!replicationVisitor.add(currUnit.group))</span>
<span class="fc" id="L332">                continue;    // If this group is already seen, the token cannot be affected.</span>

<span class="fc" id="L334">            Token replicationEnd = curr.token;</span>
<span class="fc" id="L335">            Token replicationStart = findUpdatedReplicationStart(curr, candidate);</span>
<span class="fc" id="L336">            tokenChange += applyOwnershipAdjustment(curr, currUnit, replicationStart, replicationEnd, optTokenOwnership, unitTracker);</span>
        }
<span class="fc" id="L338">        replicationVisitor.clean();</span>

<span class="fc" id="L340">        double nodeChange = unitTracker.calculateUnitChange(newUnitMult, optTokenOwnership);</span>
<span class="fc" id="L341">        return -(tokenChange + nodeChange);</span>
    }

    /**
     * Returns the start of the replication span for the token {@code curr} when {@code candidate} is inserted into the
     * ring.
     */
    private Token findUpdatedReplicationStart(TokenInfo&lt;Unit&gt; curr, CandidateInfo&lt;Unit&gt; candidate)
    {
<span class="fc" id="L350">        return furtherStartToken(curr.replicationThreshold, candidate.token, curr.token);</span>
    }

    /**
     * Applies the ownership adjustment for the given element, updating tracked unit ownership and returning the change
     * of variance.
     */
    private double applyOwnershipAdjustment(BaseTokenInfo&lt;Unit, ?&gt; curr, UnitInfo&lt;Unit&gt; currUnit,
            Token replicationStart, Token replicationEnd,
            double optTokenOwnership, UnitAdjustmentTracker&lt;Unit&gt; unitTracker)
    {
<span class="fc" id="L361">        double oldOwnership = curr.replicatedOwnership;</span>
<span class="fc" id="L362">        double newOwnership = replicationStart.size(replicationEnd);</span>
<span class="fc" id="L363">        double tokenCount = currUnit.tokenCount;</span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">        assert tokenCount &gt; 0;</span>
<span class="fc" id="L365">        unitTracker.add(currUnit, newOwnership - oldOwnership);</span>
<span class="fc" id="L366">        return (sq(newOwnership - optTokenOwnership) - sq(oldOwnership - optTokenOwnership)) / sq(tokenCount);</span>
    }

    /**
     * Tracker for unit ownership changes. The changes are tracked by a chain of UnitInfos where the adjustedOwnership
     * field is being updated as we see changes in token ownership.
     *
     * The chain ends with an element that points to itself; this element must be specified as argument to the
     * constructor as well as be the first unit with which 'add' is called; when calculating the variance change
     * a separate multiplier is applied to it (used to permit more freedom in choosing the first tokens of a unit).
     */
<span class="fc" id="L377">    private static class UnitAdjustmentTracker&lt;Unit&gt;</span>
    {
        UnitInfo&lt;Unit&gt; unitsChain;

        UnitAdjustmentTracker(UnitInfo&lt;Unit&gt; newUnit)
<span class="fc" id="L382">        {</span>
<span class="fc" id="L383">            unitsChain = newUnit;</span>
<span class="fc" id="L384">        }</span>

        void add(UnitInfo&lt;Unit&gt; currUnit, double diff)
        {
<span class="fc bfc" id="L388" title="All 2 branches covered.">            if (currUnit.prevUsed == null)</span>
            {
<span class="pc bpc" id="L390" title="1 of 4 branches missed.">                assert unitsChain.prevUsed != null || currUnit == unitsChain;</span>

<span class="fc" id="L392">                currUnit.adjustedOwnership = currUnit.ownership + diff;</span>
<span class="fc" id="L393">                currUnit.prevUsed = unitsChain;</span>
<span class="fc" id="L394">                unitsChain = currUnit;</span>
            }
            else
            {
<span class="fc" id="L398">                currUnit.adjustedOwnership += diff;</span>
            }
<span class="fc" id="L400">        }</span>

        double calculateUnitChange(double newUnitMult, double optTokenOwnership)
        {
<span class="fc" id="L404">            double unitChange = 0;</span>
<span class="fc" id="L405">            UnitInfo&lt;Unit&gt; unitsChain = this.unitsChain;</span>
            // Now loop through the units chain and add the unit-level changes. Also clear the groups' seen marks.
            while (true)
            {
<span class="fc" id="L409">                double newOwnership = unitsChain.adjustedOwnership;</span>
<span class="fc" id="L410">                double oldOwnership = unitsChain.ownership;</span>
<span class="fc" id="L411">                double tokenCount = unitsChain.tokenCount;</span>
<span class="fc" id="L412">                double diff = (sq(newOwnership / tokenCount - optTokenOwnership) - sq(oldOwnership / tokenCount - optTokenOwnership));</span>
<span class="fc" id="L413">                UnitInfo&lt;Unit&gt; prev = unitsChain.prevUsed;</span>
<span class="fc" id="L414">                unitsChain.prevUsed = null;</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">                if (unitsChain != prev)</span>
<span class="fc" id="L416">                    unitChange += diff;</span>
                else
                {
<span class="fc" id="L419">                    unitChange += diff * newUnitMult;</span>
<span class="fc" id="L420">                    break;</span>
                }
<span class="fc" id="L422">                unitsChain = prev;</span>
<span class="fc" id="L423">            }</span>
<span class="fc" id="L424">            this.unitsChain = unitsChain;</span>
<span class="fc" id="L425">            return unitChange;</span>
        }
    }


    /**
     * Helper class for marking/unmarking visited a chain of groups
     */
<span class="fc" id="L433">    private abstract class GroupVisitor</span>
    {
<span class="fc" id="L435">        GroupInfo groupChain = GroupInfo.TERMINATOR;</span>
<span class="fc" id="L436">        int seen = 0;</span>

        abstract GroupInfo prevSeen(GroupInfo group);
        abstract void setPrevSeen(GroupInfo group, GroupInfo prevSeen);

        // true iff this is the first time we've visited this group
        boolean add(GroupInfo group)
        {
<span class="fc bfc" id="L444" title="All 2 branches covered.">            if (prevSeen(group) != null)</span>
<span class="fc" id="L445">                return false;</span>
<span class="fc" id="L446">            ++seen;</span>
<span class="fc" id="L447">            setPrevSeen(group, groupChain);</span>
<span class="fc" id="L448">            groupChain = group;</span>
<span class="fc" id="L449">            return true;</span>
        }

        boolean visitedAll()
        {
<span class="fc bfc" id="L454" title="All 2 branches covered.">            return seen &gt;= replicas;</span>
        }

        boolean seen(GroupInfo group)
        {
<span class="fc bfc" id="L459" title="All 2 branches covered.">            return prevSeen(group) != null;</span>
        }

        // Clean group seen markers.
        void clean()
        {
<span class="fc" id="L465">            GroupInfo groupChain = this.groupChain;</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">            while (groupChain != GroupInfo.TERMINATOR)</span>
            {
<span class="fc" id="L468">                GroupInfo prev = prevSeen(groupChain);</span>
<span class="fc" id="L469">                setPrevSeen(groupChain, null);</span>
<span class="fc" id="L470">                groupChain = prev;</span>
<span class="fc" id="L471">            }</span>
<span class="fc" id="L472">            this.groupChain = GroupInfo.TERMINATOR;</span>
<span class="fc" id="L473">        }</span>
    }

<span class="fc" id="L476">    private class ReplicationVisitor extends GroupVisitor</span>
    {
        GroupInfo prevSeen(GroupInfo group)
        {
<span class="fc" id="L480">            return group.prevSeen;</span>
        }

        void setPrevSeen(GroupInfo group, GroupInfo prevSeen)
        {
<span class="fc" id="L485">            group.prevSeen = prevSeen;</span>
<span class="fc" id="L486">        }</span>
    }

<span class="fc" id="L489">    private class PopulateVisitor extends GroupVisitor</span>
    {
        GroupInfo prevSeen(GroupInfo group)
        {
<span class="fc" id="L493">            return group.prevPopulate;</span>
        }

        void setPrevSeen(GroupInfo group, GroupInfo prevSeen)
        {
<span class="fc" id="L498">            group.prevPopulate = prevSeen;</span>
<span class="fc" id="L499">        }</span>
    }

    private double optimalTokenOwnership(int tokensToAdd)
    {
<span class="fc" id="L504">        return 1.0 * replicas / (sortedTokens.size() + tokensToAdd);</span>
    }

    /**
     * Selects from {@code t1}, {@code t2} the token that forms a bigger range with {@code towards} as the upper bound,
     * taking into account wrapping.
     * Unlike Token.size(), equality is taken to mean &quot;same as&quot; rather than covering the whole range.
     */
    private static Token furtherStartToken(Token t1, Token t2, Token towards)
    {
<span class="fc bfc" id="L514" title="All 2 branches covered.">        if (t1.equals(towards))</span>
<span class="fc" id="L515">            return t2;</span>
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">        if (t2.equals(towards))</span>
<span class="nc" id="L517">            return t1;</span>

<span class="fc bfc" id="L519" title="All 2 branches covered.">        return t1.size(towards) &gt; t2.size(towards) ? t1 : t2;</span>
    }

    private static double sq(double d)
    {
<span class="fc" id="L524">        return d * d;</span>
    }


    /**
     * For testing, remove the given unit preserving correct state of the allocator.
     */
    void removeUnit(Unit n)
    {
<span class="fc" id="L533">        Collection&lt;Token&gt; tokens = unitToTokens.removeAll(n);</span>
<span class="fc" id="L534">        sortedTokens.keySet().removeAll(tokens);</span>
<span class="fc" id="L535">        TokenAllocatorDiagnostics.unitRemoved(this, n, unitToTokens, sortedTokens);</span>
<span class="fc" id="L536">    }</span>

    public int unitCount()
    {
<span class="fc" id="L540">        return unitToTokens.asMap().size();</span>
    }

    public String toString()
    {
<span class="fc" id="L545">        return getClass().getSimpleName();</span>
    }

    /**
     * TokenInfo about candidate new tokens/vnodes.
     */
    private static class CandidateInfo&lt;Unit&gt; extends BaseTokenInfo&lt;Unit, CandidateInfo&lt;Unit&gt;&gt;
    {
        // directly preceding token in the current token ring
        final TokenInfo&lt;Unit&gt; split;

        public CandidateInfo(Token token, TokenInfo&lt;Unit&gt; split, UnitInfo&lt;Unit&gt; owningUnit)
        {
<span class="fc" id="L558">            super(token, owningUnit);</span>
<span class="fc" id="L559">            this.split = split;</span>
<span class="fc" id="L560">        }</span>

        TokenInfo&lt;Unit&gt; prevInRing()
        {
<span class="fc" id="L564">            return split.prev;</span>
        }
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>