<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MurmurHash.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.utils</a> &gt; <span class="el_source">MurmurHash.java</span></div><h1>MurmurHash.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.utils;

import java.nio.ByteBuffer;
import java.util.BitSet;

import com.google.common.primitives.Longs;

/**
 * This is a very fast, non-cryptographic hash suitable for general hash-based
 * lookup. See http://murmurhash.googlepages.com/ for more details.
 *
 * hash32() and hash64() are MurmurHash 2.0.
 *
 * hash3_x64_128() is *almost* MurmurHash 3.0.  It was supposed to match, but we didn't catch a sign bug with
 * the result that it doesn't.  Unfortunately, we can't change it now without breaking Murmur3Partitioner. *
 * 
 * &lt;p&gt;
 * The C version of MurmurHash 2.0 found at that site was ported to Java by
 * Andrzej Bialecki (ab at getopt org).
 * &lt;/p&gt;
 */
<span class="nc" id="L39">public class MurmurHash</span>
{
    public static int hash32(ByteBuffer data, int offset, int length, int seed)
    {
<span class="nc" id="L43">        int m = 0x5bd1e995;</span>
<span class="nc" id="L44">        int r = 24;</span>

<span class="nc" id="L46">        int h = seed ^ length;</span>

<span class="nc" id="L48">        int len_4 = length &gt;&gt; 2;</span>

<span class="nc bnc" id="L50" title="All 2 branches missed.">        for (int i = 0; i &lt; len_4; i++)</span>
        {
<span class="nc" id="L52">            int i_4 = i &lt;&lt; 2;</span>
<span class="nc" id="L53">            int k = data.get(offset + i_4 + 3);</span>
<span class="nc" id="L54">            k = k &lt;&lt; 8;</span>
<span class="nc" id="L55">            k = k | (data.get(offset + i_4 + 2) &amp; 0xff);</span>
<span class="nc" id="L56">            k = k &lt;&lt; 8;</span>
<span class="nc" id="L57">            k = k | (data.get(offset + i_4 + 1) &amp; 0xff);</span>
<span class="nc" id="L58">            k = k &lt;&lt; 8;</span>
<span class="nc" id="L59">            k = k | (data.get(offset + i_4 + 0) &amp; 0xff);</span>
<span class="nc" id="L60">            k *= m;</span>
<span class="nc" id="L61">            k ^= k &gt;&gt;&gt; r;</span>
<span class="nc" id="L62">            k *= m;</span>
<span class="nc" id="L63">            h *= m;</span>
<span class="nc" id="L64">            h ^= k;</span>
        }

        // avoid calculating modulo
<span class="nc" id="L68">        int len_m = len_4 &lt;&lt; 2;</span>
<span class="nc" id="L69">        int left = length - len_m;</span>

<span class="nc bnc" id="L71" title="All 2 branches missed.">        if (left != 0)</span>
        {
<span class="nc bnc" id="L73" title="All 2 branches missed.">            if (left &gt;= 3)</span>
            {
<span class="nc" id="L75">                h ^= (int) data.get(offset + length - 3) &lt;&lt; 16;</span>
            }
<span class="nc bnc" id="L77" title="All 2 branches missed.">            if (left &gt;= 2)</span>
            {
<span class="nc" id="L79">                h ^= (int) data.get(offset + length - 2) &lt;&lt; 8;</span>
            }
<span class="nc bnc" id="L81" title="All 2 branches missed.">            if (left &gt;= 1)</span>
            {
<span class="nc" id="L83">                h ^= (int) data.get(offset + length - 1);</span>
            }

<span class="nc" id="L86">            h *= m;</span>
        }

<span class="nc" id="L89">        h ^= h &gt;&gt;&gt; 13;</span>
<span class="nc" id="L90">        h *= m;</span>
<span class="nc" id="L91">        h ^= h &gt;&gt;&gt; 15;</span>

<span class="nc" id="L93">        return h;</span>
    }

    public static long hash2_64(ByteBuffer key, int offset, int length, long seed)
    {
<span class="fc" id="L98">        long m64 = 0xc6a4a7935bd1e995L;</span>
<span class="fc" id="L99">        int r64 = 47;</span>

<span class="fc" id="L101">        long h64 = (seed &amp; 0xffffffffL) ^ (m64 * length);</span>

<span class="fc" id="L103">        int lenLongs = length &gt;&gt; 3;</span>

<span class="fc bfc" id="L105" title="All 2 branches covered.">        for (int i = 0; i &lt; lenLongs; ++i)</span>
        {
<span class="fc" id="L107">            int i_8 = i &lt;&lt; 3;</span>

<span class="fc" id="L109">            long k64 =  ((long)  key.get(offset+i_8+0) &amp; 0xff)      + (((long) key.get(offset+i_8+1) &amp; 0xff)&lt;&lt;8)  +</span>
<span class="fc" id="L110">                        (((long) key.get(offset+i_8+2) &amp; 0xff)&lt;&lt;16) + (((long) key.get(offset+i_8+3) &amp; 0xff)&lt;&lt;24) +</span>
<span class="fc" id="L111">                        (((long) key.get(offset+i_8+4) &amp; 0xff)&lt;&lt;32) + (((long) key.get(offset+i_8+5) &amp; 0xff)&lt;&lt;40) +</span>
<span class="fc" id="L112">                        (((long) key.get(offset+i_8+6) &amp; 0xff)&lt;&lt;48) + (((long) key.get(offset+i_8+7) &amp; 0xff)&lt;&lt;56);</span>

<span class="fc" id="L114">            k64 *= m64;</span>
<span class="fc" id="L115">            k64 ^= k64 &gt;&gt;&gt; r64;</span>
<span class="fc" id="L116">            k64 *= m64;</span>

<span class="fc" id="L118">            h64 ^= k64;</span>
<span class="fc" id="L119">            h64 *= m64;</span>
        }

<span class="fc" id="L122">        int rem = length &amp; 0x7;</span>

<span class="pc bpc" id="L124" title="1 of 9 branches missed.">        switch (rem)</span>
        {
        case 0:
<span class="fc" id="L127">            break;</span>
        case 7:
<span class="fc" id="L129">            h64 ^= (long) key.get(offset + length - rem + 6) &lt;&lt; 48;</span>
        case 6:
<span class="fc" id="L131">            h64 ^= (long) key.get(offset + length - rem + 5) &lt;&lt; 40;</span>
        case 5:
<span class="fc" id="L133">            h64 ^= (long) key.get(offset + length - rem + 4) &lt;&lt; 32;</span>
        case 4:
<span class="fc" id="L135">            h64 ^= (long) key.get(offset + length - rem + 3) &lt;&lt; 24;</span>
        case 3:
<span class="fc" id="L137">            h64 ^= (long) key.get(offset + length - rem + 2) &lt;&lt; 16;</span>
        case 2:
<span class="fc" id="L139">            h64 ^= (long) key.get(offset + length - rem + 1) &lt;&lt; 8;</span>
        case 1:
<span class="fc" id="L141">            h64 ^= (long) key.get(offset + length - rem);</span>
<span class="fc" id="L142">            h64 *= m64;</span>
        }

<span class="fc" id="L145">        h64 ^= h64 &gt;&gt;&gt; r64;</span>
<span class="fc" id="L146">        h64 *= m64;</span>
<span class="fc" id="L147">        h64 ^= h64 &gt;&gt;&gt; r64;</span>

<span class="fc" id="L149">        return h64;</span>
    }

    protected static long getBlock(ByteBuffer key, int offset, int index)
    {
<span class="fc" id="L154">        int i_8 = index &lt;&lt; 3;</span>
<span class="fc" id="L155">        int blockOffset = offset + i_8;</span>
<span class="fc" id="L156">        return ((long) key.get(blockOffset + 0) &amp; 0xff) + (((long) key.get(blockOffset + 1) &amp; 0xff) &lt;&lt; 8) +</span>
<span class="fc" id="L157">               (((long) key.get(blockOffset + 2) &amp; 0xff) &lt;&lt; 16) + (((long) key.get(blockOffset + 3) &amp; 0xff) &lt;&lt; 24) +</span>
<span class="fc" id="L158">               (((long) key.get(blockOffset + 4) &amp; 0xff) &lt;&lt; 32) + (((long) key.get(blockOffset + 5) &amp; 0xff) &lt;&lt; 40) +</span>
<span class="fc" id="L159">               (((long) key.get(blockOffset + 6) &amp; 0xff) &lt;&lt; 48) + (((long) key.get(blockOffset + 7) &amp; 0xff) &lt;&lt; 56);</span>
    }

    protected static long rotl64(long v, int n)
    {
<span class="fc" id="L164">        return ((v &lt;&lt; n) | (v &gt;&gt;&gt; (64 - n)));</span>
    }

    protected static long fmix(long k)
    {
<span class="fc" id="L169">        k ^= k &gt;&gt;&gt; 33;</span>
<span class="fc" id="L170">        k *= 0xff51afd7ed558ccdL;</span>
<span class="fc" id="L171">        k ^= k &gt;&gt;&gt; 33;</span>
<span class="fc" id="L172">        k *= 0xc4ceb9fe1a85ec53L;</span>
<span class="fc" id="L173">        k ^= k &gt;&gt;&gt; 33;</span>

<span class="fc" id="L175">        return k;</span>
    }

    public static void hash3_x64_128(ByteBuffer key, int offset, int length, long seed, long[] result)
    {
<span class="fc" id="L180">        final int nblocks = length &gt;&gt; 4; // Process as 128-bit blocks.</span>

<span class="fc" id="L182">        long h1 = seed;</span>
<span class="fc" id="L183">        long h2 = seed;</span>

<span class="fc" id="L185">        long c1 = 0x87c37b91114253d5L;</span>
<span class="fc" id="L186">        long c2 = 0x4cf5ad432745937fL;</span>

        //----------
        // body

<span class="fc bfc" id="L191" title="All 2 branches covered.">        for(int i = 0; i &lt; nblocks; i++)</span>
        {
<span class="fc" id="L193">            long k1 = getBlock(key, offset, i * 2 + 0);</span>
<span class="fc" id="L194">            long k2 = getBlock(key, offset, i * 2 + 1);</span>

<span class="fc" id="L196">            k1 *= c1; k1 = rotl64(k1,31); k1 *= c2; h1 ^= k1;</span>

<span class="fc" id="L198">            h1 = rotl64(h1,27); h1 += h2; h1 = h1*5+0x52dce729;</span>

<span class="fc" id="L200">            k2 *= c2; k2  = rotl64(k2,33); k2 *= c1; h2 ^= k2;</span>

<span class="fc" id="L202">            h2 = rotl64(h2,31); h2 += h1; h2 = h2*5+0x38495ab5;</span>
        }

        //----------
        // tail

        // Advance offset to the unprocessed tail of the data.
<span class="fc" id="L209">        offset += nblocks * 16;</span>

<span class="fc" id="L211">        long k1 = 0;</span>
<span class="fc" id="L212">        long k2 = 0;</span>

<span class="fc bfc" id="L214" title="All 16 branches covered.">        switch(length &amp; 15)</span>
        {
<span class="fc" id="L216">            case 15: k2 ^= ((long) key.get(offset+14)) &lt;&lt; 48;</span>
<span class="fc" id="L217">            case 14: k2 ^= ((long) key.get(offset+13)) &lt;&lt; 40;</span>
<span class="fc" id="L218">            case 13: k2 ^= ((long) key.get(offset+12)) &lt;&lt; 32;</span>
<span class="fc" id="L219">            case 12: k2 ^= ((long) key.get(offset+11)) &lt;&lt; 24;</span>
<span class="fc" id="L220">            case 11: k2 ^= ((long) key.get(offset+10)) &lt;&lt; 16;</span>
<span class="fc" id="L221">            case 10: k2 ^= ((long) key.get(offset+9)) &lt;&lt; 8;</span>
<span class="fc" id="L222">            case  9: k2 ^= ((long) key.get(offset+8)) &lt;&lt; 0;</span>
<span class="fc" id="L223">                k2 *= c2; k2  = rotl64(k2,33); k2 *= c1; h2 ^= k2;</span>

<span class="fc" id="L225">            case  8: k1 ^= ((long) key.get(offset+7)) &lt;&lt; 56;</span>
<span class="fc" id="L226">            case  7: k1 ^= ((long) key.get(offset+6)) &lt;&lt; 48;</span>
<span class="fc" id="L227">            case  6: k1 ^= ((long) key.get(offset+5)) &lt;&lt; 40;</span>
<span class="fc" id="L228">            case  5: k1 ^= ((long) key.get(offset+4)) &lt;&lt; 32;</span>
<span class="fc" id="L229">            case  4: k1 ^= ((long) key.get(offset+3)) &lt;&lt; 24;</span>
<span class="fc" id="L230">            case  3: k1 ^= ((long) key.get(offset+2)) &lt;&lt; 16;</span>
<span class="fc" id="L231">            case  2: k1 ^= ((long) key.get(offset+1)) &lt;&lt; 8;</span>
<span class="fc" id="L232">            case  1: k1 ^= ((long) key.get(offset));</span>
<span class="fc" id="L233">                k1 *= c1; k1  = rotl64(k1,31); k1 *= c2; h1 ^= k1;</span>
        };

        //----------
        // finalization

<span class="fc" id="L239">        h1 ^= length; h2 ^= length;</span>

<span class="fc" id="L241">        h1 += h2;</span>
<span class="fc" id="L242">        h2 += h1;</span>

<span class="fc" id="L244">        h1 = fmix(h1);</span>
<span class="fc" id="L245">        h2 = fmix(h2);</span>

<span class="fc" id="L247">        h1 += h2;</span>
<span class="fc" id="L248">        h2 += h1;</span>

<span class="fc" id="L250">        result[0] = h1;</span>
<span class="fc" id="L251">        result[1] = h2;</span>
<span class="fc" id="L252">    }</span>

    protected static long invRotl64(long v, int n)
    {
<span class="nc" id="L256">        return ((v &gt;&gt;&gt; n) | (v &lt;&lt; (64 - n)));</span>
    }

    protected static long invRShiftXor(long value, int shift)
    {
<span class="nc" id="L261">        long output = 0;</span>
<span class="nc" id="L262">        long i = 0;</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">        while (i * shift &lt; 64)</span>
        {
<span class="nc" id="L265">            long c = (0xffffffffffffffffL &lt;&lt; (64 - shift)) &gt;&gt;&gt; (shift * i);</span>
<span class="nc" id="L266">            long partOutput = value &amp; c;</span>
<span class="nc" id="L267">            value ^= partOutput &gt;&gt;&gt; shift;</span>
<span class="nc" id="L268">            output |= partOutput;</span>
<span class="nc" id="L269">            i += 1;</span>
<span class="nc" id="L270">        }</span>
<span class="nc" id="L271">        return output;</span>
    }

    protected static long invFmix(long k)
    {
<span class="nc" id="L276">        k = invRShiftXor(k, 33);</span>
<span class="nc" id="L277">        k *= 0x9cb4b2f8129337dbL;</span>
<span class="nc" id="L278">        k = invRShiftXor(k, 33);</span>
<span class="nc" id="L279">        k *= 0x4f74430c22a54005L;</span>
<span class="nc" id="L280">        k = invRShiftXor(k, 33);</span>
<span class="nc" id="L281">        return k;</span>
    }

    /**
     * This gives a correct reversal of the tail byte flip which is needed if want a non mod16==0 byte hash inv or to
     * target a hash for a given schema.
     */
    public static long invTailReverse(long num)
    {
<span class="nc" id="L290">        byte[] v = Longs.toByteArray(Long.reverseBytes(num));</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">        for (int i = 0; i &lt; 8; i++)</span>
        {
<span class="nc bnc" id="L293" title="All 4 branches missed.">            if (v[i] &lt; 0 &amp;&amp; i &lt; 7)</span>
            {
<span class="nc" id="L295">                BitSet bits = BitSet.valueOf(v);</span>
<span class="nc" id="L296">                bits.flip(8 * (i + 1), 64);</span>
<span class="nc" id="L297">                v = bits.toByteArray();</span>
            }
        }
<span class="nc" id="L300">        return Longs.fromByteArray(v);</span>
    }

    public static long[] inv_hash3_x64_128(long[] result)
    {
<span class="nc" id="L305">        long c1 = 0xa98409e882ce4d7dL;</span>
<span class="nc" id="L306">        long c2 = 0xa81e14edd9de2c7fL;</span>

<span class="nc" id="L308">        long k1 = 0;</span>
<span class="nc" id="L309">        long k2 = 0;</span>
<span class="nc" id="L310">        long h1 = result[0];</span>
<span class="nc" id="L311">        long h2 = result[1];</span>

        //----------
        // reverse finalization
<span class="nc" id="L315">        h2 -= h1;</span>
<span class="nc" id="L316">        h1 -= h2;</span>

<span class="nc" id="L318">        h1 = invFmix(h1);</span>
<span class="nc" id="L319">        h2 = invFmix(h2);</span>

<span class="nc" id="L321">        h2 -= h1;</span>
<span class="nc" id="L322">        h1 -= h2;</span>

<span class="nc" id="L324">        h1 ^= 16;</span>
<span class="nc" id="L325">        h2 ^= 16;</span>

        //----------
        // reverse body
<span class="nc" id="L329">        h2 -= 0x38495ab5;</span>
<span class="nc" id="L330">        h2 *= 0xcccccccccccccccdL;</span>
<span class="nc" id="L331">        h2 -= h1;</span>
<span class="nc" id="L332">        h2 = invRotl64(h2, 31);</span>
<span class="nc" id="L333">        k2 = h2;</span>
<span class="nc" id="L334">        h2 = 0;</span>

<span class="nc" id="L336">        k2 *= c1;</span>
<span class="nc" id="L337">        k2 = invRotl64(k2, 33);</span>
<span class="nc" id="L338">        k2 *= c2;</span>

<span class="nc" id="L340">        h1 -= 0x52dce729;</span>
<span class="nc" id="L341">        h1 *= 0xcccccccccccccccdL;</span>
        //h1 -= h2;
<span class="nc" id="L343">        h1 = invRotl64(h1, 27);</span>

<span class="nc" id="L345">        k1 = h1;</span>

<span class="nc" id="L347">        k1 *= c2;</span>
<span class="nc" id="L348">        k1 = invRotl64(k1, 31);</span>
<span class="nc" id="L349">        k1 *= c1;</span>

        // note that while this works for body block reversing the tail reverse requires `invTailReverse`
<span class="nc" id="L352">        k1 = Long.reverseBytes(k1);</span>
<span class="nc" id="L353">        k2 = Long.reverseBytes(k2);</span>

<span class="nc" id="L355">        return new long[] {k1, k2};</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>