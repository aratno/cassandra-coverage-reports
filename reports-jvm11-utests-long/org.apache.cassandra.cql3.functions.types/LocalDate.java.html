<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LocalDate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.functions.types</a> &gt; <span class="el_source">LocalDate.java</span></div><h1>LocalDate.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3.functions.types;

import java.util.*;
import java.util.concurrent.TimeUnit;

import static com.google.common.base.Preconditions.checkArgument;

/**
 * A date with no time components, no time zone, in the ISO 8601 calendar.
 *
 * &lt;p&gt;Note that ISO 8601 has a number of differences with the default gregorian calendar used in
 * Java:
 *
 * &lt;ul&gt;
 * &lt;li&gt;it uses a proleptic gregorian calendar, meaning that it's gregorian indefinitely back in
 * the past (there is no gregorian change);
 * &lt;li&gt;there is a year 0.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;This class implements these differences, so that year/month/day fields match exactly the ones
 * in CQL string literals.
 *
 * @since 2.2
 */
public final class LocalDate
{

<span class="nc" id="L45">    private static final TimeZone UTC = TimeZone.getTimeZone(&quot;UTC&quot;);</span>

    private final long millisSinceEpoch;
    private final int daysSinceEpoch;

    // This gets initialized lazily if we ever need it. Once set, it is effectively immutable.
    private volatile GregorianCalendar calendar;

    private LocalDate(int daysSinceEpoch)
<span class="nc" id="L54">    {</span>
<span class="nc" id="L55">        this.daysSinceEpoch = daysSinceEpoch;</span>
<span class="nc" id="L56">        this.millisSinceEpoch = TimeUnit.DAYS.toMillis(daysSinceEpoch);</span>
<span class="nc" id="L57">    }</span>

    /**
     * Builds a new instance from a number of days since January 1st, 1970 GMT.
     *
     * @param daysSinceEpoch the number of days.
     * @return the new instance.
     */
    public static LocalDate fromDaysSinceEpoch(int daysSinceEpoch)
    {
<span class="nc" id="L67">        return new LocalDate(daysSinceEpoch);</span>
    }

    /**
     * Builds a new instance from a number of milliseconds since January 1st, 1970 GMT. Note that if
     * the given number does not correspond to a whole number of days, it will be rounded towards 0.
     *
     * @param millisSinceEpoch the number of milliseconds since January 1st, 1970 GMT.
     * @return the new instance.
     * @throws IllegalArgumentException if the date is not in the range [-5877641-06-23;
     *                                  5881580-07-11].
     */
    public static LocalDate fromMillisSinceEpoch(long millisSinceEpoch)
    throws IllegalArgumentException
    {
<span class="nc" id="L82">        long daysSinceEpoch = TimeUnit.MILLISECONDS.toDays(millisSinceEpoch);</span>
<span class="nc bnc" id="L83" title="All 4 branches missed.">        checkArgument(</span>
        daysSinceEpoch &gt;= Integer.MIN_VALUE &amp;&amp; daysSinceEpoch &lt;= Integer.MAX_VALUE,
        &quot;Date should be in the range [-5877641-06-23; 5881580-07-11]&quot;);

<span class="nc" id="L87">        return new LocalDate((int) daysSinceEpoch);</span>
    }

    /**
     * Returns the number of days since January 1st, 1970 GMT.
     *
     * @return the number of days.
     */
    public int getDaysSinceEpoch()
    {
<span class="nc" id="L97">        return daysSinceEpoch;</span>
    }

    /**
     * Returns the year.
     *
     * @return the year.
     */
    public int getYear()
    {
<span class="nc" id="L107">        GregorianCalendar c = getCalendar();</span>
<span class="nc" id="L108">        int year = c.get(Calendar.YEAR);</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">        if (c.get(Calendar.ERA) == GregorianCalendar.BC) year = -year + 1;</span>
<span class="nc" id="L110">        return year;</span>
    }

    /**
     * Returns the month.
     *
     * @return the month. It is 1-based, e.g. 1 for January.
     */
    public int getMonth()
    {
<span class="nc" id="L120">        return getCalendar().get(Calendar.MONTH) + 1;</span>
    }

    /**
     * Returns the day in the month.
     *
     * @return the day in the month.
     */
    public int getDay()
    {
<span class="nc" id="L130">        return getCalendar().get(Calendar.DAY_OF_MONTH);</span>
    }

    /**
     * Return a new {@link LocalDate} with the specified (signed) amount of time added to (or
     * subtracted from) the given {@link Calendar} field, based on the calendar's rules.
     *
     * &lt;p&gt;Note that adding any amount to a field smaller than {@link Calendar#DAY_OF_MONTH} will
     * remain without effect, as this class does not keep time components.
     *
     * &lt;p&gt;See {@link Calendar} javadocs for more information.
     *
     * @param field  a {@link Calendar} field to modify.
     * @param amount the amount of date or time to be added to the field.
     * @return a new {@link LocalDate} with the specified (signed) amount of time added to (or
     * subtracted from) the given {@link Calendar} field.
     * @throws IllegalArgumentException if the new date is not in the range [-5877641-06-23;
     *                                  5881580-07-11].
     */
    public LocalDate add(int field, int amount)
    {
<span class="nc" id="L151">        GregorianCalendar newCalendar = isoCalendar();</span>
<span class="nc" id="L152">        newCalendar.setTimeInMillis(millisSinceEpoch);</span>
<span class="nc" id="L153">        newCalendar.add(field, amount);</span>
<span class="nc" id="L154">        LocalDate newDate = fromMillisSinceEpoch(newCalendar.getTimeInMillis());</span>
<span class="nc" id="L155">        newDate.calendar = newCalendar;</span>
<span class="nc" id="L156">        return newDate;</span>
    }

    @Override
    public boolean equals(Object o)
    {
<span class="nc bnc" id="L162" title="All 2 branches missed.">        if (this == o) return true;</span>

<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (o instanceof LocalDate)</span>
        {
<span class="nc" id="L166">            LocalDate that = (LocalDate) o;</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">            return this.daysSinceEpoch == that.daysSinceEpoch;</span>
        }
<span class="nc" id="L169">        return false;</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L175">        return daysSinceEpoch;</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L181">        return String.format(&quot;%d-%s-%s&quot;, getYear(), pad2(getMonth()), pad2(getDay()));</span>
    }

    private static String pad2(int i)
    {
<span class="nc" id="L186">        String s = Integer.toString(i);</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">        return s.length() == 2 ? s : '0' + s;</span>
    }

    private GregorianCalendar getCalendar()
    {
        // Two threads can race and both create a calendar. This is not a problem.
<span class="nc bnc" id="L193" title="All 2 branches missed.">        if (calendar == null)</span>
        {

            // Use a local variable to only expose after we're done mutating it.
<span class="nc" id="L197">            GregorianCalendar tmp = isoCalendar();</span>
<span class="nc" id="L198">            tmp.setTimeInMillis(millisSinceEpoch);</span>

<span class="nc" id="L200">            calendar = tmp;</span>
        }
<span class="nc" id="L202">        return calendar;</span>
    }

    // This matches what Cassandra uses server side (from Joda Time's LocalDate)
    private static GregorianCalendar isoCalendar()
    {
<span class="nc" id="L208">        GregorianCalendar calendar = new GregorianCalendar(UTC);</span>
<span class="nc" id="L209">        calendar.setGregorianChange(new Date(Long.MIN_VALUE));</span>
<span class="nc" id="L210">        return calendar;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>