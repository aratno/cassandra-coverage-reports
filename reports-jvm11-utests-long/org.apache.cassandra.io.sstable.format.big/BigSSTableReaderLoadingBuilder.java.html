<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BigSSTableReaderLoadingBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.io.sstable.format.big</a> &gt; <span class="el_source">BigSSTableReaderLoadingBuilder.java</span></div><h1>BigSSTableReaderLoadingBuilder.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.io.sstable.format.big;

import java.io.IOException;
import java.util.OptionalInt;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.SerializationHeader;
import org.apache.cassandra.io.compress.CompressionMetadata;
import org.apache.cassandra.io.sstable.Downsampling;
import org.apache.cassandra.io.sstable.KeyReader;
import org.apache.cassandra.io.sstable.SSTable;
import org.apache.cassandra.io.sstable.format.CompressionInfoComponent;
import org.apache.cassandra.io.sstable.format.FilterComponent;
import org.apache.cassandra.io.sstable.format.IndexComponent;
import org.apache.cassandra.io.sstable.format.SortedTableReaderLoadingBuilder;
import org.apache.cassandra.io.sstable.format.StatsComponent;
import org.apache.cassandra.io.sstable.format.big.BigFormat.Components;
import org.apache.cassandra.io.sstable.indexsummary.IndexSummary;
import org.apache.cassandra.io.sstable.indexsummary.IndexSummaryBuilder;
import org.apache.cassandra.io.sstable.keycache.KeyCache;
import org.apache.cassandra.io.sstable.metadata.MetadataType;
import org.apache.cassandra.io.sstable.metadata.ValidationMetadata;
import org.apache.cassandra.io.util.DiskOptimizationStrategy;
import org.apache.cassandra.io.util.FileHandle;
import org.apache.cassandra.io.util.RandomAccessReader;
import org.apache.cassandra.metrics.TableMetrics;
import org.apache.cassandra.service.CacheService;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.FilterFactory;
import org.apache.cassandra.utils.IFilter;
import org.apache.cassandra.utils.Pair;
import org.apache.cassandra.utils.Throwables;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;

public class BigSSTableReaderLoadingBuilder extends SortedTableReaderLoadingBuilder&lt;BigTableReader, BigTableReader.Builder&gt;
{
<span class="fc" id="L60">    private final static Logger logger = LoggerFactory.getLogger(BigSSTableReaderLoadingBuilder.class);</span>

    private FileHandle.Builder indexFileBuilder;

    public BigSSTableReaderLoadingBuilder(SSTable.Builder&lt;?, ?&gt; descriptor)
    {
<span class="fc" id="L66">        super(descriptor);</span>
<span class="fc" id="L67">    }</span>

    @Override
    protected void openComponents(BigTableReader.Builder builder, SSTable.Owner owner, boolean validate, boolean online) throws IOException
    {
        try
        {
<span class="pc bpc" id="L74" title="1 of 4 branches missed.">            if (online &amp;&amp; builder.getTableMetadataRef().getLocal().params.caching.cacheKeys())</span>
<span class="fc" id="L75">                builder.setKeyCache(new KeyCache(CacheService.instance.keyCache));</span>

<span class="fc" id="L77">            StatsComponent statsComponent = StatsComponent.load(descriptor, MetadataType.STATS, MetadataType.HEADER, MetadataType.VALIDATION);</span>
<span class="fc" id="L78">            builder.setSerializationHeader(statsComponent.serializationHeader(builder.getTableMetadataRef().getLocal()));</span>
<span class="pc bpc" id="L79" title="1 of 4 branches missed.">            checkArgument(!online || builder.getSerializationHeader() != null);</span>

<span class="fc" id="L81">            builder.setStatsMetadata(statsComponent.statsMetadata());</span>
<span class="pc bpc" id="L82" title="2 of 4 branches missed.">            if (descriptor.version.hasKeyRange() &amp;&amp; statsComponent.statsMetadata() != null)</span>
            {
<span class="fc" id="L84">                builder.setFirst(tableMetadataRef.getLocal().partitioner.decorateKey(statsComponent.statsMetadata().firstKey));</span>
<span class="fc" id="L85">                builder.setLast(tableMetadataRef.getLocal().partitioner.decorateKey(statsComponent.statsMetadata().lastKey));</span>
            }

<span class="fc" id="L88">            ValidationMetadata validationMetadata = statsComponent.validationMetadata();</span>
<span class="fc" id="L89">            validatePartitioner(builder.getTableMetadataRef().getLocal(), validationMetadata);</span>

<span class="fc" id="L91">            boolean filterNeeded = online;</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">            if (filterNeeded)</span>
<span class="fc" id="L93">                builder.setFilter(loadFilter(validationMetadata));</span>
<span class="pc bpc" id="L94" title="1 of 4 branches missed.">            boolean rebuildFilter = filterNeeded &amp;&amp; builder.getFilter() == null;</span>

<span class="fc" id="L96">            boolean summaryNeeded = true;</span>
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">            if (summaryNeeded)</span>
            {
<span class="fc" id="L99">                IndexSummaryComponent summaryComponent = loadSummary();</span>
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">                if (summaryComponent != null)</span>
                {
<span class="pc bpc" id="L102" title="2 of 4 branches missed.">                    if (builder.getFirst() == null || builder.getLast() == null)</span>
                    {
<span class="nc" id="L104">                        builder.setFirst(summaryComponent.first);</span>
<span class="nc" id="L105">                        builder.setLast(summaryComponent.last);</span>
                    }
<span class="fc" id="L107">                    builder.setIndexSummary(summaryComponent.indexSummary);</span>
                }
            }
<span class="pc bpc" id="L110" title="2 of 4 branches missed.">            boolean rebuildSummary = summaryNeeded &amp;&amp; builder.getIndexSummary() == null;</span>

<span class="pc bpc" id="L112" title="2 of 6 branches missed.">            if (builder.getComponents().contains(Components.PRIMARY_INDEX) &amp;&amp; (rebuildFilter || rebuildSummary))</span>
            {
<span class="fc" id="L114">                try (FileHandle indexFile = indexFileBuilder(builder.getIndexSummary()).complete())</span>
                {
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">                    Pair&lt;IFilter, IndexSummaryComponent&gt; filterAndSummary = buildSummaryAndBloomFilter(indexFile, builder.getSerializationHeader(), rebuildFilter, rebuildSummary, owner != null ? owner.getMetrics() : null);</span>
<span class="fc" id="L117">                    IFilter filter = filterAndSummary.left;</span>
<span class="fc" id="L118">                    IndexSummaryComponent summaryComponent = filterAndSummary.right;</span>

<span class="pc bpc" id="L120" title="1 of 2 branches missed.">                    if (summaryComponent != null)</span>
                    {
<span class="nc" id="L122">                        builder.setFirst(summaryComponent.first);</span>
<span class="nc" id="L123">                        builder.setLast(summaryComponent.last);</span>
<span class="nc" id="L124">                        builder.setIndexSummary(summaryComponent.indexSummary);</span>

<span class="nc bnc" id="L126" title="All 2 branches missed.">                        if (online)</span>
<span class="nc" id="L127">                            summaryComponent.save(descriptor.fileFor(Components.SUMMARY), false);</span>
                    }

<span class="pc bpc" id="L130" title="1 of 2 branches missed.">                    if (filter != null)</span>
                    {
<span class="fc" id="L132">                        builder.setFilter(filter);</span>

<span class="pc bpc" id="L134" title="1 of 2 branches missed.">                        if (online)</span>
<span class="fc" id="L135">                            FilterComponent.save(filter, descriptor, false);</span>
                    }
                }
            }

<span class="fc" id="L140">            try (CompressionMetadata compressionMetadata = CompressionInfoComponent.maybeLoad(descriptor, components))</span>
            {
<span class="fc" id="L142">                builder.setDataFile(dataFileBuilder(builder.getStatsMetadata()).withCompressionMetadata(compressionMetadata).complete());</span>
            }

<span class="fc bfc" id="L145" title="All 2 branches covered.">            if (builder.getFilter() == null)</span>
<span class="fc" id="L146">                builder.setFilter(FilterFactory.AlwaysPresent);</span>

<span class="pc bpc" id="L148" title="1 of 2 branches missed.">            if (builder.getComponents().contains(Components.PRIMARY_INDEX))</span>
<span class="fc" id="L149">                builder.setIndexFile(indexFileBuilder(builder.getIndexSummary()).complete());</span>
        }
<span class="nc" id="L151">        catch (IOException | RuntimeException | Error ex)</span>
        {
<span class="nc" id="L153">            Throwables.closeNonNullAndAddSuppressed(ex, builder.getDataFile(), builder.getIndexFile(), builder.getFilter(), builder.getIndexSummary());</span>
<span class="nc" id="L154">            throw ex;</span>
<span class="fc" id="L155">        }</span>
<span class="fc" id="L156">    }</span>

    @Override
    public KeyReader buildKeyReader(TableMetrics tableMetrics) throws IOException
    {
<span class="nc" id="L161">        StatsComponent statsComponent = StatsComponent.load(descriptor, MetadataType.STATS, MetadataType.HEADER, MetadataType.VALIDATION);</span>
<span class="nc" id="L162">        SerializationHeader header = statsComponent.serializationHeader(tableMetadataRef.getLocal());</span>
<span class="nc" id="L163">        try (FileHandle indexFile = indexFileBuilder(null).complete())</span>
        {
<span class="nc" id="L165">            return createKeyReader(indexFile, header, tableMetrics);</span>
        }
    }

    private KeyReader createKeyReader(FileHandle indexFile, SerializationHeader serializationHeader, TableMetrics tableMetrics) throws IOException
    {
<span class="fc" id="L171">        checkNotNull(indexFile);</span>
<span class="fc" id="L172">        checkNotNull(serializationHeader);</span>

<span class="fc" id="L174">        RowIndexEntry.IndexSerializer serializer = new RowIndexEntry.Serializer(descriptor.version, serializationHeader, tableMetrics);</span>
<span class="fc" id="L175">        return BigTableKeyReader.create(indexFile, serializer);</span>
    }

    /**
     * Go through the index and optionally rebuild the index summary and Bloom filter.
     *
     * @param rebuildFilter  true if Bloom filter should be rebuilt
     * @param rebuildSummary true if index summary, first and last keys should be rebuilt
     * @return a pair of created filter and index summary component (or nulls if some of them were not created)
     */
    @SuppressWarnings(&quot;resource&quot;)
    private Pair&lt;IFilter, IndexSummaryComponent&gt; buildSummaryAndBloomFilter(FileHandle indexFile,
                                                                            SerializationHeader serializationHeader,
                                                                            boolean rebuildFilter,
                                                                            boolean rebuildSummary,
                                                                            TableMetrics tableMetrics) throws IOException
    {
<span class="fc" id="L192">        checkNotNull(indexFile);</span>
<span class="fc" id="L193">        checkNotNull(serializationHeader);</span>

<span class="fc" id="L195">        DecoratedKey first = null, key = null;</span>
<span class="fc" id="L196">        IFilter bf = null;</span>
<span class="fc" id="L197">        IndexSummary indexSummary = null;</span>

        // we read the positions in a BRAF, so we don't have to worry about an entry spanning a mmap boundary.
<span class="fc" id="L200">        try (KeyReader keyReader = createKeyReader(indexFile, serializationHeader, tableMetrics))</span>
        {
<span class="pc bpc" id="L202" title="3 of 4 branches missed.">            long estimatedRowsNumber = rebuildFilter || rebuildSummary ? estimateRowsFromIndex(indexFile) : 0;</span>

<span class="pc bpc" id="L204" title="1 of 2 branches missed.">            if (rebuildFilter)</span>
<span class="fc" id="L205">                bf = FilterFactory.getFilter(estimatedRowsNumber, tableMetadataRef.getLocal().params.bloomFilterFpChance);</span>

<span class="pc bpc" id="L207" title="1 of 2 branches missed.">            try (IndexSummaryBuilder summaryBuilder = !rebuildSummary ? null : new IndexSummaryBuilder(estimatedRowsNumber,</span>
<span class="pc" id="L208">                                                                                                       tableMetadataRef.getLocal().params.minIndexInterval,</span>
                                                                                                       Downsampling.BASE_SAMPLING_LEVEL))
            {
<span class="fc bfc" id="L211" title="All 2 branches covered.">                while (!keyReader.isExhausted())</span>
                {
<span class="fc" id="L213">                    key = tableMetadataRef.getLocal().partitioner.decorateKey(keyReader.key());</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">                    if (rebuildSummary)</span>
                    {
<span class="nc bnc" id="L216" title="All 2 branches missed.">                        if (first == null)</span>
<span class="nc" id="L217">                            first = key;</span>
<span class="nc" id="L218">                        summaryBuilder.maybeAddEntry(key, keyReader.keyPositionForSecondaryIndex());</span>
                    }

<span class="pc bpc" id="L221" title="1 of 2 branches missed.">                    if (rebuildFilter)</span>
<span class="fc" id="L222">                        bf.add(key);</span>

<span class="fc" id="L224">                    keyReader.advance();</span>
                }

<span class="pc bpc" id="L227" title="1 of 2 branches missed.">                if (rebuildSummary)</span>
<span class="nc" id="L228">                    indexSummary = summaryBuilder.build(tableMetadataRef.getLocal().partitioner);</span>
            }
        }
<span class="nc" id="L231">        catch (IOException | RuntimeException | Error ex)</span>
        {
<span class="nc" id="L233">            Throwables.closeNonNullAndAddSuppressed(ex, indexSummary, bf);</span>
<span class="nc" id="L234">            throw ex;</span>
<span class="fc" id="L235">        }</span>

<span class="pc bpc" id="L237" title="2 of 4 branches missed.">        assert rebuildSummary || indexSummary == null;</span>
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">        return Pair.create(bf, rebuildSummary ? new IndexSummaryComponent(indexSummary, first, key) : null);</span>
    }

    /**
     * Load index summary, first key and last key from Summary.db file if it exists.
     * &lt;p&gt;
     * if loaded index summary has different index interval from current value stored in schema,
     * then Summary.db file will be deleted and need to be rebuilt.
     */
    private IndexSummaryComponent loadSummary()
    {
<span class="fc" id="L249">        IndexSummaryComponent summaryComponent = null;</span>
        try
        {
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">            if (components.contains(Components.SUMMARY))</span>
<span class="fc" id="L253">                summaryComponent = IndexSummaryComponent.loadOrDeleteCorrupted(descriptor.fileFor(Components.SUMMARY), tableMetadataRef.get());</span>

<span class="pc bpc" id="L255" title="1 of 2 branches missed.">            if (summaryComponent == null)</span>
<span class="nc" id="L256">                logger.debug(&quot;Index summary file is missing: {}&quot;, descriptor.fileFor(Components.SUMMARY));</span>
        }
<span class="nc" id="L258">        catch (IOException ex)</span>
        {
<span class="nc" id="L260">            logger.debug(&quot;Index summary file is corrupted: &quot; + descriptor.fileFor(Components.SUMMARY), ex);</span>
<span class="fc" id="L261">        }</span>

<span class="fc" id="L263">        return summaryComponent;</span>
    }

    /**
     * @return An estimate of the number of keys contained in the given index file.
     */
    public long estimateRowsFromIndex(FileHandle indexFile) throws IOException
    {
<span class="fc" id="L271">        checkNotNull(indexFile);</span>

<span class="fc" id="L273">        try (RandomAccessReader indexReader = indexFile.createReader())</span>
        {
            // collect sizes for the first 10000 keys, or first 10 mebibytes of data
<span class="fc" id="L276">            final int samplesCap = 10000;</span>
<span class="fc" id="L277">            final int bytesCap = (int) Math.min(10000000, indexReader.length());</span>
<span class="fc" id="L278">            int keys = 0;</span>
<span class="pc bpc" id="L279" title="1 of 4 branches missed.">            while (indexReader.getFilePointer() &lt; bytesCap &amp;&amp; keys &lt; samplesCap)</span>
            {
<span class="fc" id="L281">                ByteBufferUtil.skipShortLength(indexReader);</span>
<span class="fc" id="L282">                RowIndexEntry.Serializer.skip(indexReader, descriptor.version);</span>
<span class="fc" id="L283">                keys++;</span>
            }
<span class="pc bpc" id="L285" title="3 of 6 branches missed.">            assert keys &gt; 0 &amp;&amp; indexReader.getFilePointer() &gt; 0 &amp;&amp; indexReader.length() &gt; 0 : &quot;Unexpected empty index file: &quot; + indexReader;</span>
<span class="fc" id="L286">            long estimatedRows = indexReader.length() / (indexReader.getFilePointer() / keys);</span>
<span class="fc" id="L287">            indexReader.seek(0);</span>
<span class="fc" id="L288">            return estimatedRows;</span>
        }
    }

    private FileHandle.Builder indexFileBuilder(IndexSummary indexSummary)
    {
<span class="pc bpc" id="L294" title="1 of 4 branches missed.">        assert this.indexFileBuilder == null || this.indexFileBuilder.file.equals(descriptor.fileFor(Components.PRIMARY_INDEX));</span>

<span class="fc" id="L296">        long indexFileLength = descriptor.fileFor(Components.PRIMARY_INDEX).length();</span>
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">        OptionalInt indexBufferSize = indexSummary != null ? OptionalInt.of(ioOptions.diskOptimizationStrategy.bufferSize(indexFileLength / indexSummary.size()))</span>
<span class="pc" id="L298">                                                           : OptionalInt.empty();</span>

<span class="fc bfc" id="L300" title="All 2 branches covered.">        if (indexFileBuilder == null)</span>
<span class="fc" id="L301">            indexFileBuilder = IndexComponent.fileBuilder(descriptor.fileFor(Components.PRIMARY_INDEX), ioOptions, chunkCache)</span>
<span class="fc" id="L302">                                             .bufferSize(indexBufferSize.orElse(DiskOptimizationStrategy.MAX_BUFFER_SIZE));</span>

<span class="fc" id="L304">        indexBufferSize.ifPresent(indexFileBuilder::bufferSize);</span>

<span class="fc" id="L306">        return indexFileBuilder;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>