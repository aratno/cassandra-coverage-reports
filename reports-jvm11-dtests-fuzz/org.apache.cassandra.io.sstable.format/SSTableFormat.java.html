<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SSTableFormat.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.io.sstable.format</a> &gt; <span class="el_source">SSTableFormat.java</span></div><h1>SSTableFormat.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.io.sstable.format;

import java.io.IOException;
import java.util.Map;
import java.util.Set;
import javax.annotation.Nonnull;

import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.lifecycle.LifecycleNewTracker;
import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
import org.apache.cassandra.dht.IPartitioner;
import org.apache.cassandra.io.sstable.AbstractRowIndexEntry;
import org.apache.cassandra.io.sstable.Component;
import org.apache.cassandra.io.sstable.Descriptor;
import org.apache.cassandra.io.sstable.IScrubber;
import org.apache.cassandra.io.sstable.MetricsProviders;
import org.apache.cassandra.io.sstable.SSTable;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.schema.TableMetadataRef;
import org.apache.cassandra.utils.OutputHandler;
import org.apache.cassandra.utils.Pair;

/**
 * Provides the accessors to data on disk.
 */
public interface SSTableFormat&lt;R extends SSTableReader, W extends SSTableWriter&gt;
{
    String name();

    Version getLatestVersion();
    Version getVersion(String version);

    SSTableWriterFactory&lt;W, ?&gt; getWriterFactory();

    SSTableReaderFactory&lt;R, ?&gt; getReaderFactory();

    /**
     * All the components that the writter can produce when saving an sstable, as well as all the components
     * that the reader can read.
     */
    Set&lt;Component&gt; allComponents();


    Set&lt;Component&gt; primaryComponents();

    /**
     * Returns components required by offline compaction tasks - like splitting sstables.
     */
    Set&lt;Component&gt; batchComponents();

    /**
     * Returns the components which should be selected for upload by the sstable loader.
     */
    Set&lt;Component&gt; uploadComponents();

    /**
     * Returns a set of the components that can be changed after an sstable was written.
     */
    Set&lt;Component&gt; mutableComponents();

    /**
     * Returns a set of components that can be automatically generated when loading sstable and thus are not mandatory.
     */
    Set&lt;Component&gt; generatedOnLoadComponents();

    KeyCacheValueSerializer&lt;R, ?&gt; getKeyCacheValueSerializer();

    /**
     * Returns a new scrubber for an sstable. Note that the transaction must contain only one reader
     * and the reader must match the provided cfs.
     */
    IScrubber getScrubber(ColumnFamilyStore cfs,
                          LifecycleTransaction transaction,
                          OutputHandler outputHandler,
                          IScrubber.Options options);

    MetricsProviders getFormatSpecificMetricsProviders();

    void deleteOrphanedComponents(Descriptor descriptor, Set&lt;Component&gt; components);

    /**
     * Deletes the existing components of the sstables represented by the provided descriptor.
     * The method is also responsible for cleaning up the in-memory resources occupied by the stuff related to that
     * sstables, such as row key cache entries.
     */
    void delete(Descriptor descriptor);

    interface SSTableReaderFactory&lt;R extends SSTableReader, B extends SSTableReader.Builder&lt;R, B&gt;&gt;
    {
        /**
         * A simple builder which creates an instnace of {@link SSTableReader} with the provided parameters.
         * It expects that all the required resources to be opened/loaded externally by the caller.
         * &lt;p&gt;
         * The builder is expected to perform basic validation of the provided parameters.
         */
        SSTableReader.Builder&lt;R, B&gt; builder(Descriptor descriptor);

        /**
         * A builder which opens/loads all the required resources upon execution of
         * {@link SSTableReaderLoadingBuilder#build(SSTable.Owner, boolean, boolean)} and passed them to the created
         * reader instance. If the creation of {@link SSTableReader} fails, no resources should be left opened.
         * &lt;p&gt;
         * The builder is expected to perform basic validation of the provided parameters.
         */
        SSTableReaderLoadingBuilder&lt;R, B&gt; loadingBuilder(Descriptor descriptor, TableMetadataRef tableMetadataRef, Set&lt;Component&gt; components);

        /**
         * Retrieves a key range for the given sstable at the lowest cost - that is, without opening all sstables files
         * if possible.
         */
        Pair&lt;DecoratedKey, DecoratedKey&gt; readKeyRange(Descriptor descriptor, IPartitioner partitioner) throws IOException;

        Class&lt;R&gt; getReaderClass();
    }

    interface SSTableWriterFactory&lt;W extends SSTableWriter, B extends SSTableWriter.Builder&lt;W, B&gt;&gt;
    {
        /**
         * Returns a new builder which can create instance of {@link SSTableWriter} with the provided parameters.
         * Similarly to the loading builder, it should open the required resources when
         * the {@link SSTableWriter.Builder#build(LifecycleNewTracker, SSTable.Owner)} method is called.
         * It should not let the caller passing any closeable resources directly, that is, via setters.
         * If building fails, all the opened resources should be released.
         */
        B builder(Descriptor descriptor);

        /**
         * Tries to estimate the size of all the sstable files from the provided parameters.
         */
        long estimateSize(SSTableWriter.SSTableSizeParameters parameters);
    }

<span class="nc" id="L152">    class Components</span>
    {
<span class="nc" id="L154">        public static class Types</span>
        {
            // the base data for an sstable: the remaining components can be regenerated
            // based on the data component
<span class="fc" id="L158">            public static final Component.Type DATA = Component.Type.createSingleton(&quot;DATA&quot;, &quot;Data.db&quot;, true, null);</span>
            // file to hold information about uncompressed data length, chunk offsets etc.
<span class="fc" id="L160">            public static final Component.Type COMPRESSION_INFO = Component.Type.createSingleton(&quot;COMPRESSION_INFO&quot;, &quot;CompressionInfo.db&quot;, true, null);</span>
            // statistical metadata about the content of the sstable
<span class="fc" id="L162">            public static final Component.Type STATS = Component.Type.createSingleton(&quot;STATS&quot;, &quot;Statistics.db&quot;, true, null);</span>
            // serialized bloom filter for the row keys in the sstable
<span class="fc" id="L164">            public static final Component.Type FILTER = Component.Type.createSingleton(&quot;FILTER&quot;, &quot;Filter.db&quot;, true, null);</span>
            // holds CRC32 checksum of the data file
<span class="fc" id="L166">            public static final Component.Type DIGEST = Component.Type.createSingleton(&quot;DIGEST&quot;, &quot;Digest.crc32&quot;, true, null);</span>
            // holds the CRC32 for chunks in an uncompressed file.
<span class="fc" id="L168">            public static final Component.Type CRC = Component.Type.createSingleton(&quot;CRC&quot;, &quot;CRC.db&quot;, true, null);</span>
            // table of contents, stores the list of all components for the sstable
<span class="fc" id="L170">            public static final Component.Type TOC = Component.Type.createSingleton(&quot;TOC&quot;, &quot;TOC.txt&quot;, false, null);</span>
            // built-in secondary index (may exist multiple per sstable)
<span class="fc" id="L172">            public static final Component.Type SECONDARY_INDEX = Component.Type.create(&quot;SECONDARY_INDEX&quot;, &quot;SI_.*.db&quot;, false, null);</span>
            // custom component, used by e.g. custom compaction strategy
<span class="fc" id="L174">            public static final Component.Type CUSTOM = Component.Type.create(&quot;CUSTOM&quot;, null, true, null);</span>
        }

        // singleton components for types that don't need ids
<span class="fc" id="L178">        public final static Component DATA = Types.DATA.getSingleton();</span>
<span class="fc" id="L179">        public final static Component COMPRESSION_INFO = Types.COMPRESSION_INFO.getSingleton();</span>
<span class="fc" id="L180">        public final static Component STATS = Types.STATS.getSingleton();</span>
<span class="fc" id="L181">        public final static Component FILTER = Types.FILTER.getSingleton();</span>
<span class="fc" id="L182">        public final static Component DIGEST = Types.DIGEST.getSingleton();</span>
<span class="fc" id="L183">        public final static Component CRC = Types.CRC.getSingleton();</span>
<span class="fc" id="L184">        public final static Component TOC = Types.TOC.getSingleton();</span>
    }

    interface KeyCacheValueSerializer&lt;R extends SSTableReader, T extends AbstractRowIndexEntry&gt;
    {
        void skip(DataInputPlus input) throws IOException;

        T deserialize(R reader, DataInputPlus input) throws IOException;

        void serialize(T entry, DataOutputPlus output) throws IOException;
    }

    interface Factory
    {
        /**
         * Returns a name of the format. Format name must not be empty, must be unique and must consist only of lowercase letters.
         */
        String name();

        /**
         * Returns an instance of the sstable format configured with the provided options.
         * &lt;p/&gt;
         * The method is expected to validate the options, and throw
         * {@link org.apache.cassandra.exceptions.ConfigurationException} if the validation fails.
         *
         * @param options    overrides for the default options, can be empty, cannot be null
         */
        SSTableFormat&lt;?, ?&gt; getInstance(@Nonnull Map&lt;String, String&gt; options);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>