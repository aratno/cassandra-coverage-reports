<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UnfilteredRowIteratorSerializer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.rows</a> &gt; <span class="el_source">UnfilteredRowIteratorSerializer.java</span></div><h1>UnfilteredRowIteratorSerializer.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.rows;

import java.io.IOError;
import java.io.IOException;
import java.nio.BufferOverflowException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.DeletionTime;
import org.apache.cassandra.db.EmptyIterators;
import org.apache.cassandra.db.RegularAndStaticColumns;
import org.apache.cassandra.db.SerializationHeader;
import org.apache.cassandra.db.TypeSizes;
import org.apache.cassandra.db.filter.ColumnFilter;
import org.apache.cassandra.io.sstable.format.big.BigFormatPartitionWriter;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.utils.ByteBufferUtil;

/**
 * Serialize/Deserialize an unfiltered row iterator.
 *
 * The serialization is composed of a header, follows by the rows and range tombstones of the iterator serialized
 * until we read the end of the partition (see UnfilteredSerializer for details). The header itself
 * is:
 * {@code
 *     &lt;cfid&gt;&lt;key&gt;&lt;flags&gt;&lt;s_header&gt;[&lt;partition_deletion&gt;][&lt;static_row&gt;][&lt;row_estimate&gt;]
 * where:
 *     &lt;cfid&gt; is the table cfid.
 *     &lt;key&gt; is the partition key.
 *     &lt;flags&gt; contains bit flags. Each flag is set if it's corresponding bit is set. From rightmost
 *         bit to leftmost one, the flags are:
 *         - is empty: whether the iterator is empty. If so, nothing follows the &lt;flags&gt;
 *         - is reversed: whether the iterator is in reversed clustering order
 *         - has partition deletion: whether or not there is a &lt;partition_deletion&gt; following
 *         - has static row: whether or not there is a &lt;static_row&gt; following
 *         - has row estimate: whether or not there is a &lt;row_estimate&gt; following
 *     &lt;s_header&gt; is the {@code SerializationHeader}. It contains in particular the columns contains in the serialized
 *         iterator as well as other information necessary to decoding the serialized rows
 *         (see {@code SerializationHeader.Serializer for details}).
 *     &lt;partition_deletion&gt; is the deletion time for the partition (delta-encoded)
 *     &lt;static_row&gt; is the static row for this partition as serialized by UnfilteredSerializer.
 *     &lt;row_estimate&gt; is the (potentially estimated) number of rows serialized. This is only used for
 *         the purpose of sizing on the receiving end and should not be relied upon too strongly.
 * }
 *
 * Please note that the format described above is the on-wire format. On-disk, the format is basically the
 * same, but the header is written once per sstable, not once per-partition. Further, the actual row and
 * range tombstones are not written using this class, but rather by {@link BigFormatPartitionWriter}.
 */
<span class="fc" id="L71">public class UnfilteredRowIteratorSerializer</span>
{
<span class="fc" id="L73">    protected static final Logger logger = LoggerFactory.getLogger(UnfilteredRowIteratorSerializer.class);</span>

    public  static final int IS_EMPTY               = 0x01;
    private static final int IS_REVERSED            = 0x02;
    private static final int HAS_PARTITION_DELETION = 0x04;
    private static final int HAS_STATIC_ROW         = 0x08;
    private static final int HAS_ROW_ESTIMATE       = 0x10;

<span class="fc" id="L81">    public static final UnfilteredRowIteratorSerializer serializer = new UnfilteredRowIteratorSerializer();</span>

    // Should only be used for the on-wire format.
    public void serialize(UnfilteredRowIterator iterator, ColumnFilter selection, DataOutputPlus out, int version) throws IOException
    {
<span class="nc" id="L86">        serialize(iterator, selection, out, version, -1);</span>
<span class="nc" id="L87">    }</span>

    // Should only be used for the on-wire format.

    public void serialize(UnfilteredRowIterator iterator, ColumnFilter selection, DataOutputPlus out, int version, int rowEstimate) throws IOException
    {

<span class="fc" id="L94">        SerializationHeader header = new SerializationHeader(false,</span>
<span class="fc" id="L95">                                                             iterator.metadata(),</span>
<span class="fc" id="L96">                                                             iterator.columns(),</span>
<span class="fc" id="L97">                                                             iterator.stats());</span>

        try
        {
<span class="fc" id="L101">            serialize(iterator, header, selection, out, version, rowEstimate);</span>
        }
<span class="nc" id="L103">        catch (BufferOverflowException boe)</span>
        {
<span class="nc" id="L105">            throw new PartitionSerializationException(iterator, boe);</span>
<span class="fc" id="L106">        }</span>
<span class="fc" id="L107">    }</span>

    // Should only be used for the on-wire format.
    private void serialize(UnfilteredRowIterator iterator, SerializationHeader header, ColumnFilter selection, DataOutputPlus out, int version, int rowEstimate) throws IOException
    {
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">        assert !header.isForSSTable();</span>

<span class="fc" id="L114">        ByteBufferUtil.writeWithVIntLength(iterator.partitionKey().getKey(), out);</span>

<span class="fc" id="L116">        int flags = 0;</span>
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">        if (iterator.isReverseOrder())</span>
<span class="nc" id="L118">            flags |= IS_REVERSED;</span>

<span class="pc bpc" id="L120" title="1 of 2 branches missed.">        if (iterator.isEmpty())</span>
        {
<span class="nc" id="L122">            out.writeByte((byte)(flags | IS_EMPTY));</span>
<span class="nc" id="L123">            return;</span>
        }

<span class="fc" id="L126">        DeletionTime partitionDeletion = iterator.partitionLevelDeletion();</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">        if (!partitionDeletion.isLive())</span>
<span class="fc" id="L128">            flags |= HAS_PARTITION_DELETION;</span>
<span class="fc" id="L129">        Row staticRow = iterator.staticRow();</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">        boolean hasStatic = staticRow != Rows.EMPTY_STATIC_ROW;</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">        if (hasStatic)</span>
<span class="nc" id="L132">            flags |= HAS_STATIC_ROW;</span>

<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (rowEstimate &gt;= 0)</span>
<span class="fc" id="L135">            flags |= HAS_ROW_ESTIMATE;</span>

<span class="fc" id="L137">        out.writeByte((byte)flags);</span>

<span class="fc" id="L139">        SerializationHeader.serializer.serializeForMessaging(header, selection, out, hasStatic);</span>
<span class="fc" id="L140">        SerializationHelper helper = new SerializationHelper(header);</span>

<span class="fc bfc" id="L142" title="All 2 branches covered.">        if (!partitionDeletion.isLive())</span>
<span class="fc" id="L143">            header.writeDeletionTime(partitionDeletion, out);</span>

<span class="pc bpc" id="L145" title="1 of 2 branches missed.">        if (hasStatic)</span>
<span class="nc" id="L146">            UnfilteredSerializer.serializer.serialize(staticRow, helper, out, version);</span>

<span class="pc bpc" id="L148" title="1 of 2 branches missed.">        if (rowEstimate &gt;= 0)</span>
<span class="fc" id="L149">            out.writeUnsignedVInt32(rowEstimate);</span>

<span class="fc bfc" id="L151" title="All 2 branches covered.">        while (iterator.hasNext())</span>
<span class="fc" id="L152">            UnfilteredSerializer.serializer.serialize(iterator.next(), helper, out, version);</span>
<span class="fc" id="L153">        UnfilteredSerializer.serializer.writeEndOfPartition(out);</span>
<span class="fc" id="L154">    }</span>

    // Please note that this consume the iterator, and as such should not be called unless we have a simple way to
    // recreate an iterator for both serialize and serializedSize, which is mostly only PartitionUpdate/ArrayBackedCachedPartition.
    public long serializedSize(UnfilteredRowIterator iterator, ColumnFilter selection, int version, int rowEstimate)
    {
<span class="fc" id="L160">        SerializationHeader header = new SerializationHeader(false,</span>
<span class="fc" id="L161">                                                             iterator.metadata(),</span>
<span class="fc" id="L162">                                                             iterator.columns(),</span>
<span class="fc" id="L163">                                                             iterator.stats());</span>

<span class="fc" id="L165">        SerializationHelper helper = new SerializationHelper(header);</span>

<span class="pc bpc" id="L167" title="1 of 2 branches missed.">        assert rowEstimate &gt;= 0;</span>

<span class="fc" id="L169">        long size = ByteBufferUtil.serializedSizeWithVIntLength(iterator.partitionKey().getKey())</span>
                  + 1; // flags

<span class="pc bpc" id="L172" title="1 of 2 branches missed.">        if (iterator.isEmpty())</span>
<span class="nc" id="L173">            return size;</span>

<span class="fc" id="L175">        DeletionTime partitionDeletion = iterator.partitionLevelDeletion();</span>
<span class="fc" id="L176">        Row staticRow = iterator.staticRow();</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        boolean hasStatic = staticRow != Rows.EMPTY_STATIC_ROW;</span>

<span class="fc" id="L179">        size += SerializationHeader.serializer.serializedSizeForMessaging(header, selection, hasStatic);</span>

<span class="fc bfc" id="L181" title="All 2 branches covered.">        if (!partitionDeletion.isLive())</span>
<span class="fc" id="L182">            size += header.deletionTimeSerializedSize(partitionDeletion);</span>

<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if (hasStatic)</span>
<span class="nc" id="L185">            size += UnfilteredSerializer.serializer.serializedSize(staticRow, helper, version);</span>

<span class="pc bpc" id="L187" title="1 of 2 branches missed.">        if (rowEstimate &gt;= 0)</span>
<span class="fc" id="L188">            size += TypeSizes.sizeofUnsignedVInt(rowEstimate);</span>

<span class="fc bfc" id="L190" title="All 2 branches covered.">        while (iterator.hasNext())</span>
<span class="fc" id="L191">            size += UnfilteredSerializer.serializer.serializedSize(iterator.next(), helper, version);</span>
<span class="fc" id="L192">        size += UnfilteredSerializer.serializer.serializedSizeEndOfPartition();</span>

<span class="fc" id="L194">        return size;</span>
    }

    public Header deserializeHeader(TableMetadata metadata, ColumnFilter selection, DataInputPlus in, int version, DeserializationHelper.Flag flag) throws IOException
    {
<span class="nc" id="L199">        DecoratedKey key = metadata.partitioner.decorateKey(ByteBufferUtil.readWithVIntLength(in));</span>
<span class="nc" id="L200">        int flags = in.readUnsignedByte();</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">        boolean isReversed = (flags &amp; IS_REVERSED) != 0;</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if ((flags &amp; IS_EMPTY) != 0)</span>
        {
<span class="nc" id="L204">            SerializationHeader sh = new SerializationHeader(false, metadata, RegularAndStaticColumns.NONE, EncodingStats.NO_STATS);</span>
<span class="nc" id="L205">            return new Header(sh, key, isReversed, true, null, null, 0);</span>
        }

<span class="nc bnc" id="L208" title="All 2 branches missed.">        boolean hasPartitionDeletion = (flags &amp; HAS_PARTITION_DELETION) != 0;</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">        boolean hasStatic = (flags &amp; HAS_STATIC_ROW) != 0;</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">        boolean hasRowEstimate = (flags &amp; HAS_ROW_ESTIMATE) != 0;</span>

<span class="nc" id="L212">        SerializationHeader header = SerializationHeader.serializer.deserializeForMessaging(in, metadata, selection, hasStatic);</span>

<span class="nc bnc" id="L214" title="All 2 branches missed.">        DeletionTime partitionDeletion = hasPartitionDeletion ? header.readDeletionTime(in) : DeletionTime.LIVE;</span>

<span class="nc" id="L216">        Row staticRow = Rows.EMPTY_STATIC_ROW;</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">        if (hasStatic)</span>
<span class="nc" id="L218">            staticRow = UnfilteredSerializer.serializer.deserializeStaticRow(in, header, new DeserializationHelper(metadata, version, flag));</span>

<span class="nc bnc" id="L220" title="All 2 branches missed.">        int rowEstimate = hasRowEstimate ? in.readUnsignedVInt32() : -1;</span>
<span class="nc" id="L221">        return new Header(header, key, isReversed, false, partitionDeletion, staticRow, rowEstimate);</span>
    }

    public UnfilteredRowIterator deserialize(DataInputPlus in, int version, TableMetadata metadata, DeserializationHelper.Flag flag, Header header) throws IOException
    {
<span class="nc bnc" id="L226" title="All 2 branches missed.">        if (header.isEmpty)</span>
<span class="nc" id="L227">            return EmptyIterators.unfilteredRow(metadata, header.key, header.isReversed);</span>

<span class="nc" id="L229">        final DeserializationHelper helper = new DeserializationHelper(metadata, version, flag);</span>
<span class="nc" id="L230">        final SerializationHeader sHeader = header.sHeader;</span>
<span class="nc" id="L231">        return new AbstractUnfilteredRowIterator(metadata, header.key, header.partitionDeletion, sHeader.columns(), header.staticRow, header.isReversed, sHeader.stats())</span>
        {
            private final Row.Builder builder = BTreeRow.sortedBuilder();

            protected Unfiltered computeNext()
            {
                try
                {
                    Unfiltered unfiltered = UnfilteredSerializer.serializer.deserialize(in, sHeader, helper, builder);
                    return unfiltered == null ? endOfData() : unfiltered;
                }
                catch (IOException e)
                {
                    throw new IOError(e);
                }
            }
        };
    }

    public UnfilteredRowIterator deserialize(DataInputPlus in, int version, TableMetadata metadata, ColumnFilter selection, DeserializationHelper.Flag flag) throws IOException
    {
<span class="nc" id="L252">        return deserialize(in, version, metadata, flag, deserializeHeader(metadata, selection, in, version, flag));</span>
    }

    public static class Header
    {
        public final SerializationHeader sHeader;
        public final DecoratedKey key;
        public final boolean isReversed;
        public final boolean isEmpty;
        public final DeletionTime partitionDeletion;
        public final Row staticRow;
        public final int rowEstimate; // -1 if no estimate

        private Header(SerializationHeader sHeader,
                       DecoratedKey key,
                       boolean isReversed,
                       boolean isEmpty,
                       DeletionTime partitionDeletion,
                       Row staticRow,
                       int rowEstimate)
        {
            this.sHeader = sHeader;
            this.key = key;
            this.isReversed = isReversed;
            this.isEmpty = isEmpty;
            this.partitionDeletion = partitionDeletion;
            this.staticRow = staticRow;
            this.rowEstimate = rowEstimate;
        }

        @Override
        public String toString()
        {
            return String.format(&quot;{header=%s, key=%s, isReversed=%b, isEmpty=%b, del=%s, staticRow=%s, rowEstimate=%d}&quot;,
                                 sHeader, key, isReversed, isEmpty, partitionDeletion, staticRow, rowEstimate);
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>