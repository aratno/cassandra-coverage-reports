<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StatementRestrictions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.restrictions</a> &gt; <span class="el_source">StatementRestrictions.java</span></div><h1>StatementRestrictions.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3.restrictions;

import java.nio.ByteBuffer;
import java.util.*;

import com.google.common.base.Joiner;

import org.apache.cassandra.cql3.*;
import org.apache.cassandra.cql3.functions.Function;
import org.apache.cassandra.cql3.statements.Bound;
import org.apache.cassandra.cql3.statements.StatementType;
import org.apache.cassandra.db.*;
import org.apache.cassandra.db.filter.RowFilter;
import org.apache.cassandra.db.guardrails.Guardrails;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.virtual.VirtualKeyspaceRegistry;
import org.apache.cassandra.db.virtual.VirtualTable;
import org.apache.cassandra.dht.*;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.index.Index;
import org.apache.cassandra.index.IndexRegistry;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.service.ClientState;
import org.apache.cassandra.utils.btree.BTreeSet;

import org.apache.commons.lang3.builder.ToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;

import static org.apache.cassandra.cql3.statements.RequestValidations.checkFalse;
import static org.apache.cassandra.cql3.statements.RequestValidations.checkNotNull;
import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;

/**
 * The restrictions corresponding to the relations specified on the where-clause of CQL query.
 */
<span class="fc" id="L54">public final class StatementRestrictions</span>
{
    private static final String ALLOW_FILTERING_MESSAGE =
            &quot;Cannot execute this query as it might involve data filtering and thus may have unpredictable performance. &quot;;

    public static final String REQUIRES_ALLOW_FILTERING_MESSAGE = ALLOW_FILTERING_MESSAGE +
            &quot;If you want to execute this query despite the performance unpredictability, use ALLOW FILTERING&quot;;

    public static final String CANNOT_USE_ALLOW_FILTERING_MESSAGE = ALLOW_FILTERING_MESSAGE +
            &quot;Executing this query despite the performance unpredictability with ALLOW FILTERING has been disabled &quot; +
            &quot;by the allow_filtering_enabled property in cassandra.yaml&quot;;

    /**
     * The type of statement
     */
    private final StatementType type;

    /**
     * The Column Family meta data
     */
    public final TableMetadata table;

    /**
     * Restrictions on partitioning columns
     */
    private PartitionKeyRestrictions partitionKeyRestrictions;

    /**
     * Restrictions on clustering columns
     */
    private ClusteringColumnRestrictions clusteringColumnsRestrictions;

    /**
     * Restriction on non-primary key columns (i.e. secondary index restrictions)
     */
    private RestrictionSet nonPrimaryKeyRestrictions;

    private Set&lt;ColumnMetadata&gt; notNullColumns;

    /**
     * The restrictions used to build the row filter
     */
<span class="fc" id="L96">    private final IndexRestrictions filterRestrictions = new IndexRestrictions();</span>

    /**
     * &lt;code&gt;true&lt;/code&gt; if the secondary index need to be queried, &lt;code&gt;false&lt;/code&gt; otherwise
     */
    private boolean usesSecondaryIndexing;

    /**
     * Specify if the query will return a range of partition keys.
     */
    private boolean isKeyRange;

    /**
     * &lt;code&gt;true&lt;/code&gt; if nonPrimaryKeyRestrictions contains restriction on a regular column,
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    private boolean hasRegularColumnsRestrictions;

    /**
     * Creates a new empty &lt;code&gt;StatementRestrictions&lt;/code&gt;.
     *
     * @param type the type of statement
     * @param table the column family meta data
     * @return a new empty &lt;code&gt;StatementRestrictions&lt;/code&gt;.
     */
    public static StatementRestrictions empty(StatementType type, TableMetadata table)
    {
<span class="nc" id="L123">        return new StatementRestrictions(type, table, false);</span>
    }

    private StatementRestrictions(StatementType type, TableMetadata table, boolean allowFiltering)
<span class="fc" id="L127">    {</span>
<span class="fc" id="L128">        this.type = type;</span>
<span class="fc" id="L129">        this.table = table;</span>
<span class="fc" id="L130">        this.partitionKeyRestrictions = new PartitionKeySingleRestrictionSet(table.partitionKeyAsClusteringComparator());</span>
<span class="fc" id="L131">        this.clusteringColumnsRestrictions = new ClusteringColumnRestrictions(table, allowFiltering);</span>
<span class="fc" id="L132">        this.nonPrimaryKeyRestrictions = new RestrictionSet();</span>
<span class="fc" id="L133">        this.notNullColumns = new HashSet&lt;&gt;();</span>
<span class="fc" id="L134">    }</span>

    public StatementRestrictions(ClientState state,
                                 StatementType type,
                                 TableMetadata table,
                                 WhereClause whereClause,
                                 VariableSpecifications boundNames,
                                 boolean selectsOnlyStaticColumns,
                                 boolean allowFiltering,
                                 boolean forView)
    {
<span class="fc" id="L145">        this(state, type, table, whereClause, boundNames, selectsOnlyStaticColumns, type.allowUseOfSecondaryIndices(), allowFiltering, forView);</span>
<span class="fc" id="L146">    }</span>

    /*
     * We want to override allowUseOfSecondaryIndices flag from the StatementType for MV statements
     * to avoid initing the Keyspace and SecondaryIndexManager.
     */
    public StatementRestrictions(ClientState state,
                                 StatementType type,
                                 TableMetadata table,
                                 WhereClause whereClause,
                                 VariableSpecifications boundNames,
                                 boolean selectsOnlyStaticColumns,
                                 boolean allowUseOfSecondaryIndices,
                                 boolean allowFiltering,
                                 boolean forView)
    {
<span class="fc" id="L162">        this(type, table, allowFiltering);</span>

<span class="fc" id="L164">        IndexRegistry indexRegistry = null;</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">        if (type.allowUseOfSecondaryIndices())</span>
<span class="fc" id="L166">            indexRegistry = IndexRegistry.obtain(table);</span>

        /*
         * WHERE clause. For a given entity, rules are:
         *   - EQ relation conflicts with anything else (including a 2nd EQ)
         *   - Can't have more than one LT(E) relation (resp. GT(E) relation)
         *   - IN relation are restricted to row keys (for now) and conflicts with anything else (we could
         *     allow two IN for the same entity but that doesn't seem very useful)
         *   - The value_alias cannot be restricted in any way (we don't support wide rows with indexed value
         *     in CQL so far)
         *   - CONTAINS and CONTAINS_KEY cannot be used with UPDATE or DELETE
         */
<span class="fc bfc" id="L178" title="All 2 branches covered.">        for (Relation relation : whereClause.relations)</span>
        {
<span class="pc bpc" id="L180" title="6 of 8 branches missed.">            if ((relation.isContains() || relation.isContainsKey()) &amp;&amp; (type.isUpdate() || type.isDelete()))</span>
            {
<span class="nc" id="L182">                throw invalidRequest(&quot;Cannot use %s with %s&quot;, type, relation.operator());</span>
            }

<span class="pc bpc" id="L185" title="1 of 2 branches missed.">            if (relation.operator() == Operator.IS_NOT)</span>
            {
<span class="nc bnc" id="L187" title="All 2 branches missed.">                if (!forView)</span>
<span class="nc" id="L188">                    throw new InvalidRequestException(&quot;Unsupported restriction: &quot; + relation);</span>

<span class="nc" id="L190">                this.notNullColumns.addAll(relation.toRestriction(table, boundNames).getColumnDefs());</span>
            }
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">            else if (relation.isLIKE())</span>
            {
<span class="nc" id="L194">                Restriction restriction = relation.toRestriction(table, boundNames);</span>

<span class="nc bnc" id="L196" title="All 4 branches missed.">                if (!type.allowUseOfSecondaryIndices() || !restriction.hasSupportingIndex(indexRegistry))</span>
<span class="nc" id="L197">                    throw new InvalidRequestException(String.format(&quot;LIKE restriction is only supported on properly &quot; +</span>
                                                                    &quot;indexed columns. %s is not valid.&quot;,
                                                                    relation));

<span class="nc" id="L201">                addRestriction(restriction, indexRegistry);</span>
<span class="nc" id="L202">            }</span>
            else
            {
<span class="fc" id="L205">                addRestriction(relation.toRestriction(table, boundNames), indexRegistry);</span>
            }
<span class="fc" id="L207">        }</span>

<span class="fc" id="L209">        hasRegularColumnsRestrictions = nonPrimaryKeyRestrictions.hasRestrictionFor(ColumnMetadata.Kind.REGULAR);</span>

<span class="fc" id="L211">        boolean hasQueriableClusteringColumnIndex = false;</span>
<span class="fc" id="L212">        boolean hasQueriableIndex = false;</span>

<span class="fc bfc" id="L214" title="All 2 branches covered.">        if (allowUseOfSecondaryIndices)</span>
        {
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">            if (whereClause.containsCustomExpressions())</span>
<span class="nc" id="L217">                processCustomIndexExpressions(whereClause.expressions, boundNames, indexRegistry);</span>

<span class="fc" id="L219">            hasQueriableClusteringColumnIndex = clusteringColumnsRestrictions.hasSupportingIndex(indexRegistry);</span>
<span class="pc bpc" id="L220" title="2 of 4 branches missed.">            hasQueriableIndex = !filterRestrictions.getCustomIndexExpressions().isEmpty()</span>
                    || hasQueriableClusteringColumnIndex
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">                    || partitionKeyRestrictions.hasSupportingIndex(indexRegistry)</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">                    || nonPrimaryKeyRestrictions.hasSupportingIndex(indexRegistry);</span>
        }

        // At this point, the select statement if fully constructed, but we still have a few things to validate
<span class="fc" id="L227">        processPartitionKeyRestrictions(state, hasQueriableIndex, allowFiltering, forView);</span>

        // Some but not all of the partition key columns have been specified;
        // hence we need turn these restrictions into a row filter.
<span class="pc bpc" id="L231" title="2 of 4 branches missed.">        if (usesSecondaryIndexing || partitionKeyRestrictions.needFiltering(table))</span>
<span class="nc" id="L232">            filterRestrictions.add(partitionKeyRestrictions);</span>

<span class="pc bpc" id="L234" title="3 of 4 branches missed.">        if (selectsOnlyStaticColumns &amp;&amp; hasClusteringColumnsRestrictions())</span>
        {
            // If the only updated/deleted columns are static, then we don't need clustering columns.
            // And in fact, unless it is an INSERT, we reject if clustering colums are provided as that
            // suggest something unintended. For instance, given:
            //   CREATE TABLE t (k int, v int, s int static, PRIMARY KEY (k, v))
            // it can make sense to do:
            //   INSERT INTO t(k, v, s) VALUES (0, 1, 2)
            // but both
            //   UPDATE t SET s = 3 WHERE k = 0 AND v = 1
            //   DELETE v FROM t WHERE k = 0 AND v = 1
            // sounds like you don't really understand what your are doing.
<span class="nc bnc" id="L246" title="All 4 branches missed.">            if (type.isDelete() || type.isUpdate())</span>
<span class="nc" id="L247">                throw invalidRequest(&quot;Invalid restrictions on clustering columns since the %s statement modifies only static columns&quot;,</span>
                                     type);
<span class="nc bnc" id="L249" title="All 2 branches missed.">            if (type.isSelect())</span>
<span class="nc" id="L250">                throw invalidRequest(&quot;Cannot restrict clustering columns when selecting only static columns&quot;);</span>
        }

<span class="fc" id="L253">        processClusteringColumnsRestrictions(hasQueriableIndex,</span>
                                             selectsOnlyStaticColumns,
                                             forView,
                                             allowFiltering);

        // Covers indexes on the first clustering column (among others).
<span class="pc bpc" id="L259" title="3 of 4 branches missed.">        if (isKeyRange &amp;&amp; hasQueriableClusteringColumnIndex)</span>
<span class="nc" id="L260">            usesSecondaryIndexing = true;</span>

<span class="pc bpc" id="L262" title="2 of 4 branches missed.">        if (usesSecondaryIndexing || clusteringColumnsRestrictions.needFiltering())</span>
<span class="nc" id="L263">            filterRestrictions.add(clusteringColumnsRestrictions);</span>

        // Even if usesSecondaryIndexing is false at this point, we'll still have to use one if
        // there is restrictions not covered by the PK.
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">        if (!nonPrimaryKeyRestrictions.isEmpty())</span>
        {
<span class="nc bnc" id="L269" title="All 2 branches missed.">            if (!type.allowNonPrimaryKeyInWhereClause())</span>
            {
<span class="nc" id="L271">                Collection&lt;ColumnIdentifier&gt; nonPrimaryKeyColumns =</span>
<span class="nc" id="L272">                        ColumnMetadata.toIdentifiers(nonPrimaryKeyRestrictions.getColumnDefs());</span>

<span class="nc" id="L274">                throw invalidRequest(&quot;Non PRIMARY KEY columns found in where clause: %s &quot;,</span>
<span class="nc" id="L275">                                     Joiner.on(&quot;, &quot;).join(nonPrimaryKeyColumns));</span>
            }
<span class="nc bnc" id="L277" title="All 2 branches missed.">            if (hasQueriableIndex)</span>
<span class="nc" id="L278">                usesSecondaryIndexing = true;</span>
<span class="nc bnc" id="L279" title="All 4 branches missed.">            else if (!allowFiltering &amp;&amp; requiresAllowFilteringIfNotSpecified())</span>
<span class="nc" id="L280">                throw invalidRequest(allowFilteringMessage(state));</span>

<span class="nc" id="L282">            filterRestrictions.add(nonPrimaryKeyRestrictions);</span>
        }

<span class="pc bpc" id="L285" title="1 of 2 branches missed.">        if (usesSecondaryIndexing)</span>
<span class="nc" id="L286">            validateSecondaryIndexSelections();</span>
<span class="fc" id="L287">    }</span>

    public boolean requiresAllowFilteringIfNotSpecified()
    {
<span class="nc bnc" id="L291" title="All 2 branches missed.">        if (!table.isVirtual())</span>
<span class="nc" id="L292">            return true;</span>

<span class="nc" id="L294">        VirtualTable tableNullable = VirtualKeyspaceRegistry.instance.getTableNullable(table.id);</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">        assert tableNullable != null;</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">        return !tableNullable.allowFilteringImplicitly();</span>
    }

    private void addRestriction(Restriction restriction, IndexRegistry indexRegistry)
    {
<span class="fc" id="L301">        ColumnMetadata def = restriction.getFirstColumn();</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">        if (def.isPartitionKey())</span>
<span class="fc" id="L303">            partitionKeyRestrictions = partitionKeyRestrictions.mergeWith(restriction);</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">        else if (def.isClusteringColumn())</span>
<span class="fc" id="L305">            clusteringColumnsRestrictions = clusteringColumnsRestrictions.mergeWith(restriction, indexRegistry);</span>
        else
<span class="nc" id="L307">            nonPrimaryKeyRestrictions = nonPrimaryKeyRestrictions.addRestriction((SingleRestriction) restriction);</span>
<span class="fc" id="L308">    }</span>

    public void addFunctionsTo(List&lt;Function&gt; functions)
    {
<span class="nc" id="L312">        partitionKeyRestrictions.addFunctionsTo(functions);</span>
<span class="nc" id="L313">        clusteringColumnsRestrictions.addFunctionsTo(functions);</span>
<span class="nc" id="L314">        nonPrimaryKeyRestrictions.addFunctionsTo(functions);</span>
<span class="nc" id="L315">    }</span>

    // may be used by QueryHandler implementations
    public IndexRestrictions getIndexRestrictions()
    {
<span class="nc" id="L320">        return filterRestrictions;</span>
    }

    /**
     * Returns the non-PK column that are restricted.  If includeNotNullRestrictions is true, columns that are restricted
     * by an IS NOT NULL restriction will be included, otherwise they will not be included (unless another restriction
     * applies to them).
     */
    public Set&lt;ColumnMetadata&gt; nonPKRestrictedColumns(boolean includeNotNullRestrictions)
    {
<span class="fc" id="L330">        Set&lt;ColumnMetadata&gt; columns = new HashSet&lt;&gt;();</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">        for (Restrictions r : filterRestrictions.getRestrictions())</span>
        {
<span class="nc bnc" id="L333" title="All 2 branches missed.">            for (ColumnMetadata def : r.getColumnDefs())</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">                if (!def.isPrimaryKeyColumn())</span>
<span class="nc" id="L335">                    columns.add(def);</span>
<span class="nc" id="L336">        }</span>

<span class="pc bpc" id="L338" title="1 of 2 branches missed.">        if (includeNotNullRestrictions)</span>
        {
<span class="nc bnc" id="L340" title="All 2 branches missed.">            for (ColumnMetadata def : notNullColumns)</span>
            {
<span class="nc bnc" id="L342" title="All 2 branches missed.">                if (!def.isPrimaryKeyColumn())</span>
<span class="nc" id="L343">                    columns.add(def);</span>
<span class="nc" id="L344">            }</span>
        }

<span class="fc" id="L347">        return columns;</span>
    }

    /**
     * @return the set of columns that have an IS NOT NULL restriction on them
     */
    public Set&lt;ColumnMetadata&gt; notNullColumns()
    {
<span class="nc" id="L355">        return notNullColumns;</span>
    }

    /**
     * @return true if column is restricted by some restriction, false otherwise
     */
    public boolean isRestricted(ColumnMetadata column)
    {
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (notNullColumns.contains(column))</span>
<span class="nc" id="L364">            return true;</span>

<span class="nc" id="L366">        return getRestrictions(column.kind).getColumnDefs().contains(column);</span>
    }

    /**
     * Checks if the restrictions on the partition key has IN restrictions.
     *
     * @return &lt;code&gt;true&lt;/code&gt; the restrictions on the partition key has an IN restriction, &lt;code&gt;false&lt;/code&gt;
     * otherwise.
     */
    public boolean keyIsInRelation()
    {
<span class="fc" id="L377">        return partitionKeyRestrictions.hasIN();</span>
    }

    /**
     * Checks if the query request a range of partition keys.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the query request a range of partition keys, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean isKeyRange()
    {
<span class="fc" id="L387">        return this.isKeyRange;</span>
    }

    /**
     * Checks if the specified column is restricted by an EQ restriction.
     *
     * @param columnDef the column definition
     * @return &lt;code&gt;true&lt;/code&gt; if the specified column is restricted by an EQ restiction, &lt;code&gt;false&lt;/code&gt;
     * otherwise.
     */
    public boolean isColumnRestrictedByEq(ColumnMetadata columnDef)
    {
<span class="nc" id="L399">        Set&lt;Restriction&gt; restrictions = getRestrictions(columnDef.kind).getRestrictions(columnDef);</span>
<span class="nc" id="L400">        return restrictions.stream()</span>
<span class="nc" id="L401">                           .filter(SingleRestriction.class::isInstance)</span>
<span class="nc" id="L402">                           .anyMatch(p -&gt; ((SingleRestriction) p).isEQ());</span>
    }

    /**
     * This method determines whether a specified column is restricted on equality or something equivalent, like IN.
     * It can be used in conjunction with the columns selected by a query to determine which of those columns is 
     * already bound by the client (and from its perspective, not retrieved by the database).
     *
     * @param column a column from the same table these restrictions are against
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the given column is restricted on equality
     */
    public boolean isEqualityRestricted(ColumnMetadata column)
    {
<span class="nc bnc" id="L416" title="All 2 branches missed.">        if (column.kind == ColumnMetadata.Kind.PARTITION_KEY)</span>
        {
<span class="nc bnc" id="L418" title="All 2 branches missed.">            if (partitionKeyRestrictions.hasOnlyEqualityRestrictions())</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">                for (ColumnMetadata restricted : partitionKeyRestrictions.getColumnDefinitions())</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">                    if (restricted.name.equals(column.name))</span>
<span class="nc" id="L421">                        return true;</span>
        }
<span class="nc bnc" id="L423" title="All 2 branches missed.">        else if (column.kind == ColumnMetadata.Kind.CLUSTERING)</span>
        {
<span class="nc bnc" id="L425" title="All 2 branches missed.">            if (hasClusteringColumnsRestrictions())</span>
            {
<span class="nc bnc" id="L427" title="All 2 branches missed.">                for (SingleRestriction restriction : clusteringColumnsRestrictions.getRestrictionSet())</span>
                {
<span class="nc bnc" id="L429" title="All 2 branches missed.">                    if (restriction.isEqualityBased())</span>
                    {
<span class="nc bnc" id="L431" title="All 2 branches missed.">                        if (restriction.isMultiColumn())</span>
                        {
<span class="nc bnc" id="L433" title="All 2 branches missed.">                            for (ColumnMetadata restricted : restriction.getColumnDefs())</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">                                if (restricted.name.equals(column.name))</span>
<span class="nc" id="L435">                                    return true;</span>
                        }
<span class="nc bnc" id="L437" title="All 2 branches missed.">                        else if (restriction.getFirstColumn().name.equals(column.name))</span>
<span class="nc" id="L438">                            return true;</span>
                    }
<span class="nc" id="L440">                }</span>
            }
        }
<span class="nc bnc" id="L443" title="All 2 branches missed.">        else if (hasNonPrimaryKeyRestrictions())</span>
        {
<span class="nc bnc" id="L445" title="All 2 branches missed.">            for (SingleRestriction restriction : nonPrimaryKeyRestrictions)</span>
<span class="nc bnc" id="L446" title="All 4 branches missed.">                if (restriction.getFirstColumn().name.equals(column.name) &amp;&amp; restriction.isEqualityBased())</span>
<span class="nc" id="L447">                    return true;</span>
        }

<span class="nc" id="L450">        return false;</span>
    }

    /**
     * Returns the &lt;code&gt;Restrictions&lt;/code&gt; for the specified type of columns.
     *
     * @param kind the column type
     * @return the &lt;code&gt;Restrictions&lt;/code&gt; for the specified type of columns
     */
    private Restrictions getRestrictions(ColumnMetadata.Kind kind)
    {
<span class="nc bnc" id="L461" title="All 3 branches missed.">        switch (kind)</span>
        {
<span class="nc" id="L463">            case PARTITION_KEY: return partitionKeyRestrictions;</span>
<span class="nc" id="L464">            case CLUSTERING: return clusteringColumnsRestrictions;</span>
<span class="nc" id="L465">            default: return nonPrimaryKeyRestrictions;</span>
        }
    }

    /**
     * Checks if the secondary index need to be queried.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the secondary index need to be queried, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean usesSecondaryIndexing()
    {
<span class="fc" id="L476">        return this.usesSecondaryIndexing;</span>
    }

    private void processPartitionKeyRestrictions(ClientState state, boolean hasQueriableIndex, boolean allowFiltering, boolean forView)
    {
<span class="fc bfc" id="L481" title="All 2 branches covered.">        if (!type.allowPartitionKeyRanges())</span>
        {
<span class="fc" id="L483">            checkFalse(partitionKeyRestrictions.isOnToken(),</span>
                       &quot;The token function cannot be used in WHERE clauses for %s statements&quot;, type);

<span class="pc bpc" id="L486" title="1 of 2 branches missed.">            if (partitionKeyRestrictions.hasUnrestrictedPartitionKeyComponents(table))</span>
<span class="nc" id="L487">                throw invalidRequest(&quot;Some partition key parts are missing: %s&quot;,</span>
<span class="nc" id="L488">                                     Joiner.on(&quot;, &quot;).join(getPartitionKeyUnrestrictedComponents()));</span>

            // slice query
<span class="fc" id="L491">            checkFalse(partitionKeyRestrictions.hasSlice(),</span>
                    &quot;Only EQ and IN relation are supported on the partition key (unless you use the token() function)&quot;
                            + &quot; for %s statements&quot;, type);
        }
        else
        {
            // If there are no partition restrictions or there's only token restriction, we have to set a key range
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">            if (partitionKeyRestrictions.isOnToken())</span>
<span class="nc" id="L499">                isKeyRange = true;</span>

<span class="pc bpc" id="L501" title="3 of 4 branches missed.">            if (partitionKeyRestrictions.isEmpty() &amp;&amp; partitionKeyRestrictions.hasUnrestrictedPartitionKeyComponents(table))</span>
            {
<span class="nc" id="L503">                isKeyRange = true;</span>
<span class="nc" id="L504">                usesSecondaryIndexing = hasQueriableIndex;</span>
            }

            // If there is a queriable index, no special condition is required on the other restrictions.
            // But we still need to know 2 things:
            // - If we don't have a queriable index, is the query ok
            // - Is it queriable without 2ndary index, which is always more efficient
            // If a component of the partition key is restricted by a relation, all preceding
            // components must have a EQ. Only the last partition key component can be in IN relation.
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">            if (partitionKeyRestrictions.needFiltering(table))</span>
            {
<span class="nc bnc" id="L515" title="All 8 branches missed.">                if (!allowFiltering &amp;&amp; !forView &amp;&amp; !hasQueriableIndex &amp;&amp; requiresAllowFilteringIfNotSpecified())</span>
<span class="nc" id="L516">                    throw new InvalidRequestException(allowFilteringMessage(state));</span>

<span class="nc" id="L518">                isKeyRange = true;</span>
<span class="nc" id="L519">                usesSecondaryIndexing = hasQueriableIndex;</span>
            }
        }
<span class="fc" id="L522">    }</span>

    public boolean hasPartitionKeyRestrictions()
    {
<span class="nc bnc" id="L526" title="All 2 branches missed.">        return !partitionKeyRestrictions.isEmpty();</span>
    }

    /**
     * Checks if the restrictions contain any non-primary key restrictions
     * @return &lt;code&gt;true&lt;/code&gt; if the restrictions contain any non-primary key restrictions, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean hasNonPrimaryKeyRestrictions()
    {
<span class="nc bnc" id="L535" title="All 2 branches missed.">        return !nonPrimaryKeyRestrictions.isEmpty();</span>
    }

    /**
     * Returns the partition key components that are not restricted.
     * @return the partition key components that are not restricted.
     */
    private Collection&lt;ColumnIdentifier&gt; getPartitionKeyUnrestrictedComponents()
    {
<span class="nc" id="L544">        List&lt;ColumnMetadata&gt; list = new ArrayList&lt;&gt;(table.partitionKeyColumns());</span>
<span class="nc" id="L545">        list.removeAll(partitionKeyRestrictions.getColumnDefs());</span>
<span class="nc" id="L546">        return ColumnMetadata.toIdentifiers(list);</span>
    }

    /**
     * Checks if the restrictions on the partition key are token restrictions.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the restrictions on the partition key are token restrictions,
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean isPartitionKeyRestrictionsOnToken()
    {
<span class="nc" id="L557">        return partitionKeyRestrictions.isOnToken();</span>
    }

    /**
     * Checks if restrictions on the clustering key have IN restrictions.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the restrictions on the clustering key have IN restrictions,
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean clusteringKeyRestrictionsHasIN()
    {
<span class="fc" id="L568">        return clusteringColumnsRestrictions.hasIN();</span>
    }

    /**
     * Processes the clustering column restrictions.
     *
     * @param hasQueriableIndex &lt;code&gt;true&lt;/code&gt; if some of the queried data are indexed, &lt;code&gt;false&lt;/code&gt; otherwise
     * @param selectsOnlyStaticColumns &lt;code&gt;true&lt;/code&gt; if the selected or modified columns are all statics,
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    private void processClusteringColumnsRestrictions(boolean hasQueriableIndex,
                                                      boolean selectsOnlyStaticColumns,
                                                      boolean forView,
                                                      boolean allowFiltering)
    {
<span class="pc bpc" id="L583" title="1 of 4 branches missed.">        checkFalse(!type.allowClusteringColumnSlices() &amp;&amp; clusteringColumnsRestrictions.hasSlice(),</span>
                   &quot;Slice restrictions are not supported on the clustering columns in %s statements&quot;, type);

<span class="fc bfc" id="L586" title="All 2 branches covered.">        if (!type.allowClusteringColumnSlices()</span>
<span class="pc bpc" id="L587" title="5 of 6 branches missed.">            &amp;&amp; (!table.isCompactTable() || (table.isCompactTable() &amp;&amp; !hasClusteringColumnsRestrictions())))</span>
        {
<span class="pc bpc" id="L589" title="2 of 4 branches missed.">            if (!selectsOnlyStaticColumns &amp;&amp; hasUnrestrictedClusteringColumns())</span>
<span class="nc" id="L590">                throw invalidRequest(&quot;Some clustering keys are missing: %s&quot;,</span>
<span class="nc" id="L591">                                     Joiner.on(&quot;, &quot;).join(getUnrestrictedClusteringColumns()));</span>
        }
        else
        {
<span class="pc bpc" id="L595" title="5 of 6 branches missed.">            checkFalse(clusteringColumnsRestrictions.hasContains() &amp;&amp; !hasQueriableIndex &amp;&amp; !allowFiltering,</span>
                       &quot;Clustering columns can only be restricted with CONTAINS with a secondary index or filtering&quot;);

<span class="pc bpc" id="L598" title="1 of 4 branches missed.">            if (hasClusteringColumnsRestrictions() &amp;&amp; clusteringColumnsRestrictions.needFiltering())</span>
            {
<span class="nc bnc" id="L600" title="All 4 branches missed.">                if (hasQueriableIndex || forView)</span>
                {
<span class="nc" id="L602">                    usesSecondaryIndexing = true;</span>
                }
<span class="nc bnc" id="L604" title="All 2 branches missed.">                else if (!allowFiltering)</span>
                {
<span class="nc" id="L606">                    List&lt;ColumnMetadata&gt; clusteringColumns = table.clusteringColumns();</span>
<span class="nc" id="L607">                    List&lt;ColumnMetadata&gt; restrictedColumns = new LinkedList&lt;&gt;(clusteringColumnsRestrictions.getColumnDefs());</span>

<span class="nc bnc" id="L609" title="All 2 branches missed.">                    for (int i = 0, m = restrictedColumns.size(); i &lt; m; i++)</span>
                    {
<span class="nc" id="L611">                        ColumnMetadata clusteringColumn = clusteringColumns.get(i);</span>
<span class="nc" id="L612">                        ColumnMetadata restrictedColumn = restrictedColumns.get(i);</span>

<span class="nc bnc" id="L614" title="All 2 branches missed.">                        if (!clusteringColumn.equals(restrictedColumn))</span>
                        {
<span class="nc" id="L616">                            throw invalidRequest(&quot;PRIMARY KEY column \&quot;%s\&quot; cannot be restricted as preceding column \&quot;%s\&quot; is not restricted&quot;,</span>
                                                 restrictedColumn.name,
                                                 clusteringColumn.name);
                        }
                    }
                }
            }

        }

<span class="fc" id="L626">    }</span>

    /**
     * Returns the clustering columns that are not restricted.
     * @return the clustering columns that are not restricted.
     */
    private Collection&lt;ColumnIdentifier&gt; getUnrestrictedClusteringColumns()
    {
<span class="nc" id="L634">        List&lt;ColumnMetadata&gt; missingClusteringColumns = new ArrayList&lt;&gt;(table.clusteringColumns());</span>
<span class="nc" id="L635">        missingClusteringColumns.removeAll(new LinkedList&lt;&gt;(clusteringColumnsRestrictions.getColumnDefs()));</span>
<span class="nc" id="L636">        return ColumnMetadata.toIdentifiers(missingClusteringColumns);</span>
    }

    /**
     * Checks if some clustering columns are not restricted.
     * @return &lt;code&gt;true&lt;/code&gt; if some clustering columns are not restricted, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    private boolean hasUnrestrictedClusteringColumns()
    {
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">        return table.clusteringColumns().size() != clusteringColumnsRestrictions.size();</span>
    }

    private void processCustomIndexExpressions(List&lt;CustomIndexExpression&gt; expressions,
                                               VariableSpecifications boundNames,
                                               IndexRegistry indexRegistry)
    {
<span class="nc bnc" id="L652" title="All 2 branches missed.">        if (expressions.size() &gt; 1)</span>
<span class="nc" id="L653">            throw new InvalidRequestException(IndexRestrictions.MULTIPLE_EXPRESSIONS);</span>

<span class="nc" id="L655">        CustomIndexExpression expression = expressions.get(0);</span>

<span class="nc" id="L657">        QualifiedName name = expression.targetIndex;</span>

<span class="nc bnc" id="L659" title="All 4 branches missed.">        if (name.hasKeyspace() &amp;&amp; !name.getKeyspace().equals(table.keyspace))</span>
<span class="nc" id="L660">            throw IndexRestrictions.invalidIndex(expression.targetIndex, table);</span>

<span class="nc bnc" id="L662" title="All 2 branches missed.">        if (!table.indexes.has(expression.targetIndex.getName()))</span>
<span class="nc" id="L663">            throw IndexRestrictions.indexNotFound(expression.targetIndex, table);</span>

<span class="nc" id="L665">        Index index = indexRegistry.getIndex(table.indexes.get(expression.targetIndex.getName()).get());</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">        if (!index.getIndexMetadata().isCustom())</span>
<span class="nc" id="L667">            throw IndexRestrictions.nonCustomIndexInExpression(expression.targetIndex);</span>

<span class="nc" id="L669">        AbstractType&lt;?&gt; expressionType = index.customExpressionValueType();</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">        if (expressionType == null)</span>
<span class="nc" id="L671">            throw IndexRestrictions.customExpressionNotSupported(expression.targetIndex);</span>

<span class="nc" id="L673">        expression.prepareValue(table, expressionType, boundNames);</span>

<span class="nc" id="L675">        filterRestrictions.add(expression);</span>
<span class="nc" id="L676">    }</span>

    public RowFilter getRowFilter(IndexRegistry indexRegistry, QueryOptions options)
    {
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">        if (filterRestrictions.isEmpty())</span>
<span class="fc" id="L681">            return RowFilter.none();</span>

<span class="nc" id="L683">        RowFilter filter = RowFilter.create();</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">        for (Restrictions restrictions : filterRestrictions.getRestrictions())</span>
<span class="nc" id="L685">            restrictions.addToRowFilter(filter, indexRegistry, options);</span>

<span class="nc bnc" id="L687" title="All 2 branches missed.">        for (CustomIndexExpression expression : filterRestrictions.getCustomIndexExpressions())</span>
<span class="nc" id="L688">            expression.addToRowFilter(filter, table, options);</span>

<span class="nc" id="L690">        return filter;</span>
    }

    /**
     * Returns the partition keys for which the data is requested.
     *
     * @param options the query options
     * @param state the client state
     * @return the partition keys for which the data is requested.
     */
    public List&lt;ByteBuffer&gt; getPartitionKeys(final QueryOptions options, ClientState state)
    {
<span class="fc" id="L702">        return partitionKeyRestrictions.values(options, state);</span>
    }

    /**
     * Returns the specified bound of the partition key.
     *
     * @param b the boundary type
     * @param options the query options
     * @return the specified bound of the partition key
     */
    private ByteBuffer getPartitionKeyBound(Bound b, QueryOptions options)
    {
        // We deal with IN queries for keys in other places, so we know buildBound will return only one result
<span class="nc" id="L715">        return partitionKeyRestrictions.bounds(b, options).get(0);</span>
    }

    /**
     * Returns the partition key bounds.
     *
     * @param options the query options
     * @return the partition key bounds
     */
    public AbstractBounds&lt;PartitionPosition&gt; getPartitionKeyBounds(QueryOptions options)
    {
<span class="nc" id="L726">        IPartitioner p = table.partitioner;</span>

<span class="nc bnc" id="L728" title="All 2 branches missed.">        if (partitionKeyRestrictions.isOnToken())</span>
        {
<span class="nc" id="L730">            return getPartitionKeyBoundsForTokenRestrictions(p, options);</span>
        }

<span class="nc" id="L733">        return getPartitionKeyBounds(p, options);</span>
    }

    private AbstractBounds&lt;PartitionPosition&gt; getPartitionKeyBounds(IPartitioner p,
                                                                    QueryOptions options)
    {
        // Deal with unrestricted partition key components (special-casing is required to deal with 2i queries on the
        // first component of a composite partition key) queries that filter on the partition key.
<span class="nc bnc" id="L741" title="All 2 branches missed.">        if (partitionKeyRestrictions.needFiltering(table))</span>
<span class="nc" id="L742">            return new Range&lt;&gt;(p.getMinimumToken().minKeyBound(), p.getMinimumToken().maxKeyBound());</span>

<span class="nc" id="L744">        ByteBuffer startKeyBytes = getPartitionKeyBound(Bound.START, options);</span>
<span class="nc" id="L745">        ByteBuffer finishKeyBytes = getPartitionKeyBound(Bound.END, options);</span>

<span class="nc" id="L747">        PartitionPosition startKey = PartitionPosition.ForKey.get(startKeyBytes, p);</span>
<span class="nc" id="L748">        PartitionPosition finishKey = PartitionPosition.ForKey.get(finishKeyBytes, p);</span>

<span class="nc bnc" id="L750" title="All 4 branches missed.">        if (startKey.compareTo(finishKey) &gt; 0 &amp;&amp; !finishKey.isMinimum())</span>
<span class="nc" id="L751">            return null;</span>

<span class="nc bnc" id="L753" title="All 2 branches missed.">        if (partitionKeyRestrictions.isInclusive(Bound.START))</span>
        {
<span class="nc bnc" id="L755" title="All 2 branches missed.">            return partitionKeyRestrictions.isInclusive(Bound.END)</span>
<span class="nc" id="L756">                    ? new Bounds&lt;&gt;(startKey, finishKey)</span>
<span class="nc" id="L757">                    : new IncludingExcludingBounds&lt;&gt;(startKey, finishKey);</span>
        }

<span class="nc bnc" id="L760" title="All 2 branches missed.">        return partitionKeyRestrictions.isInclusive(Bound.END)</span>
<span class="nc" id="L761">                ? new Range&lt;&gt;(startKey, finishKey)</span>
<span class="nc" id="L762">                : new ExcludingBounds&lt;&gt;(startKey, finishKey);</span>
    }

    private AbstractBounds&lt;PartitionPosition&gt; getPartitionKeyBoundsForTokenRestrictions(IPartitioner p,
                                                                                        QueryOptions options)
    {
<span class="nc" id="L768">        Token startToken = getTokenBound(Bound.START, options, p);</span>
<span class="nc" id="L769">        Token endToken = getTokenBound(Bound.END, options, p);</span>

<span class="nc" id="L771">        boolean includeStart = partitionKeyRestrictions.isInclusive(Bound.START);</span>
<span class="nc" id="L772">        boolean includeEnd = partitionKeyRestrictions.isInclusive(Bound.END);</span>

        /*
         * If we ask SP.getRangeSlice() for (token(200), token(200)], it will happily return the whole ring.
         * However, wrapping range doesn't really make sense for CQL, and we want to return an empty result in that
         * case (CASSANDRA-5573). So special case to create a range that is guaranteed to be empty.
         *
         * In practice, we want to return an empty result set if either startToken &gt; endToken, or both are equal but
         * one of the bound is excluded (since [a, a] can contains something, but not (a, a], [a, a) or (a, a)).
         * Note though that in the case where startToken or endToken is the minimum token, then this special case
         * rule should not apply.
         */
<span class="nc" id="L784">        int cmp = startToken.compareTo(endToken);</span>
<span class="nc bnc" id="L785" title="All 12 branches missed.">        if (!startToken.isMinimum() &amp;&amp; !endToken.isMinimum()</span>
                &amp;&amp; (cmp &gt; 0 || (cmp == 0 &amp;&amp; (!includeStart || !includeEnd))))
<span class="nc" id="L787">            return null;</span>

<span class="nc bnc" id="L789" title="All 2 branches missed.">        PartitionPosition start = includeStart ? startToken.minKeyBound() : startToken.maxKeyBound();</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">        PartitionPosition end = includeEnd ? endToken.maxKeyBound() : endToken.minKeyBound();</span>

<span class="nc" id="L792">        return new Range&lt;&gt;(start, end);</span>
    }

    private Token getTokenBound(Bound b, QueryOptions options, IPartitioner p)
    {
<span class="nc bnc" id="L797" title="All 2 branches missed.">        if (!partitionKeyRestrictions.hasBound(b))</span>
<span class="nc" id="L798">            return p.getMinimumToken();</span>

<span class="nc" id="L800">        ByteBuffer value = partitionKeyRestrictions.bounds(b, options).get(0);</span>
<span class="nc" id="L801">        checkNotNull(value, &quot;Invalid null token value&quot;);</span>
<span class="nc" id="L802">        return p.getTokenFactory().fromByteArray(value);</span>
    }

    /**
     * Checks if the query has some restrictions on the clustering columns.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the query has some restrictions on the clustering columns,
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean hasClusteringColumnsRestrictions()
    {
<span class="fc bfc" id="L813" title="All 2 branches covered.">        return !clusteringColumnsRestrictions.isEmpty();</span>
    }

    /**
     * Returns the requested clustering columns.
     *
     * @param options the query options
     * @param state the client state
     * @return the requested clustering columns
     */
    public NavigableSet&lt;Clustering&lt;?&gt;&gt; getClusteringColumns(QueryOptions options, ClientState state)
    {
        // If this is a names command and the table is a static compact one, then as far as CQL is concerned we have
        // only a single row which internally correspond to the static parts. In which case we want to return an empty
        // set (since that's what ClusteringIndexNamesFilter expects).
<span class="pc bpc" id="L828" title="1 of 2 branches missed.">        if (table.isStaticCompactTable())</span>
<span class="nc" id="L829">            return BTreeSet.empty(table.comparator);</span>

<span class="fc" id="L831">        return clusteringColumnsRestrictions.valuesAsClustering(options, state);</span>
    }

    /**
     * Returns the bounds (start or end) of the clustering columns.
     *
     * @param b the bound type
     * @param options the query options
     * @return the bounds (start or end) of the clustering columns
     */
    public NavigableSet&lt;ClusteringBound&lt;?&gt;&gt; getClusteringColumnsBounds(Bound b, QueryOptions options)
    {
<span class="fc" id="L843">        return clusteringColumnsRestrictions.boundsAsClustering(b, options);</span>
    }

    /**
     * Checks if the query returns a range of columns.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the query returns a range of columns, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean isColumnRange()
    {
<span class="fc" id="L853">        int numberOfClusteringColumns = table.clusteringColumns().size();</span>
<span class="pc bpc" id="L854" title="1 of 2 branches missed.">        if (table.isStaticCompactTable())</span>
        {
            // For static compact tables we want to ignore the fake clustering column (note that if we weren't special casing,
            // this would mean a 'SELECT *' on a static compact table would query whole partitions, even though we'll only return
            // the static part as far as CQL is concerned. This is thus mostly an optimization to use the query-by-name path).
<span class="nc" id="L859">            numberOfClusteringColumns = 0;</span>
        }

        // it is a range query if it has at least one the column alias for which no relation is defined or is not EQ or IN.
<span class="pc bpc" id="L863" title="1 of 2 branches missed.">        return clusteringColumnsRestrictions.size() &lt; numberOfClusteringColumns</span>
<span class="pc bpc" id="L864" title="1 of 2 branches missed.">            || !clusteringColumnsRestrictions.hasOnlyEqualityRestrictions();</span>
    }

    /**
     * Checks if the query need to use filtering.
     * @return &lt;code&gt;true&lt;/code&gt; if the query need to use filtering, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean needFiltering(TableMetadata table)
    {
<span class="nc" id="L873">        IndexRegistry indexRegistry = IndexRegistry.obtain(table);</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">        if (filterRestrictions.needsFiltering(indexRegistry))</span>
<span class="nc" id="L875">            return true;</span>

<span class="nc" id="L877">        int numberOfRestrictions = filterRestrictions.getCustomIndexExpressions().size();</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">        for (Restrictions restrictions : filterRestrictions.getRestrictions())</span>
<span class="nc" id="L879">            numberOfRestrictions += restrictions.size();</span>

<span class="nc bnc" id="L881" title="All 4 branches missed.">        return numberOfRestrictions == 0 &amp;&amp; !clusteringColumnsRestrictions.isEmpty();</span>
    }

    private void validateSecondaryIndexSelections()
    {
<span class="nc" id="L886">        checkFalse(keyIsInRelation(),</span>
                   &quot;Select on indexed columns and with IN clause for the PRIMARY KEY are not supported&quot;);
<span class="nc" id="L888">    }</span>

    /**
     * Checks that all the primary key columns (partition key and clustering columns) are restricted by an equality
     * relation ('=' or 'IN').
     *
     * @return &lt;code&gt;true&lt;/code&gt; if all the primary key columns are restricted by an equality relation.
     */
    public boolean hasAllPKColumnsRestrictedByEqualities()
    {
<span class="nc bnc" id="L898" title="All 2 branches missed.">        return !isPartitionKeyRestrictionsOnToken()</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">                &amp;&amp; !partitionKeyRestrictions.hasUnrestrictedPartitionKeyComponents(table)</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">                &amp;&amp; (partitionKeyRestrictions.hasOnlyEqualityRestrictions())</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">                &amp;&amp; !hasUnrestrictedClusteringColumns()</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">                &amp;&amp; (clusteringColumnsRestrictions.hasOnlyEqualityRestrictions());</span>
    }

    /**
     * Checks if one of the restrictions applies to a regular column.
     * @return {@code true} if one of the restrictions applies to a regular column, {@code false} otherwise.
     */
    public boolean hasRegularColumnsRestrictions()
    {
<span class="fc" id="L911">        return hasRegularColumnsRestrictions;</span>
    }

    /**
     * Checks if the query is a full partitions selection.
     * @return {@code true} if the query is a full partitions selection, {@code false} otherwise.
     */
    private boolean queriesFullPartitions()
    {
<span class="pc bpc" id="L920" title="1 of 4 branches missed.">        return !hasClusteringColumnsRestrictions() &amp;&amp; !hasRegularColumnsRestrictions();</span>
    }

    /**
     * Determines if the query should return the static content when a partition without rows is returned (as a
     * result set row with null for all other regular columns.)
     *
     * @return {@code true} if the query should return the static content when a partition without rows is returned,
     * {@code false} otherwise.
     */
    public boolean returnStaticContentOnPartitionWithNoRows()
    {
<span class="pc bpc" id="L932" title="1 of 2 branches missed.">        if (table.isStaticCompactTable())</span>
<span class="nc" id="L933">            return true;</span>

        // The general rationale is that if some rows are specifically selected by the query (have clustering or
        // regular columns restrictions), we ignore partitions that are empty outside of static content, but if it's
        // a full partition query, then we include that content.
<span class="fc" id="L938">        return queriesFullPartitions();</span>
    }
    
    @Override
    public String toString()
    {
<span class="nc" id="L944">        return ToStringBuilder.reflectionToString(this, ToStringStyle.SHORT_PREFIX_STYLE);</span>
    }

    private static String allowFilteringMessage(ClientState state)
    {
<span class="nc bnc" id="L949" title="All 2 branches missed.">        return Guardrails.allowFilteringEnabled.isEnabled(state)</span>
<span class="nc" id="L950">               ? REQUIRES_ALLOW_FILTERING_MESSAGE</span>
<span class="nc" id="L951">               : CANNOT_USE_ALLOW_FILTERING_MESSAGE;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>