<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Keyspace.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db</a> &gt; <span class="el_source">Keyspace.java</span></div><h1>Keyspace.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db;

import java.io.IOException;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.locks.Lock;
import java.util.stream.Stream;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Iterables;
import com.google.common.util.concurrent.RateLimiter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.concurrent.Stage;
import org.apache.cassandra.config.CassandraRelevantProperties;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.config.DurationSpec;
import org.apache.cassandra.db.lifecycle.SSTableSet;
import org.apache.cassandra.db.partitions.PartitionUpdate;
import org.apache.cassandra.db.repair.CassandraKeyspaceRepairManager;
import org.apache.cassandra.db.view.ViewManager;
import org.apache.cassandra.exceptions.WriteTimeoutException;
import org.apache.cassandra.index.Index;
import org.apache.cassandra.index.SecondaryIndexManager;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.io.sstable.format.SSTableReader;
import org.apache.cassandra.locator.AbstractReplicationStrategy;
import org.apache.cassandra.metrics.KeyspaceMetrics;
import org.apache.cassandra.repair.KeyspaceRepairManager;
import org.apache.cassandra.schema.KeyspaceMetadata;
import org.apache.cassandra.schema.ReplicationParams;
import org.apache.cassandra.schema.Schema;
import org.apache.cassandra.schema.SchemaConstants;
import org.apache.cassandra.schema.SchemaProvider;
import org.apache.cassandra.schema.TableId;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.schema.TableMetadataRef;
import org.apache.cassandra.service.snapshot.TableSnapshot;
import org.apache.cassandra.tracing.Tracing;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.JVMStabilityInspector;
import org.apache.cassandra.utils.concurrent.AsyncPromise;
import org.apache.cassandra.utils.concurrent.Future;
import org.apache.cassandra.utils.concurrent.OpOrder;
import org.apache.cassandra.utils.concurrent.UncheckedInterruptedException;
import org.apache.cassandra.utils.concurrent.Promise;

import static java.util.concurrent.TimeUnit.MILLISECONDS;
import static java.util.concurrent.TimeUnit.NANOSECONDS;
import static org.apache.cassandra.utils.Clock.Global.currentTimeMillis;
import static org.apache.cassandra.utils.FBUtilities.now;
import static org.apache.cassandra.utils.MonotonicClock.Global.approxTime;

/**
 * It represents a Keyspace.
 */
public class Keyspace
{
<span class="fc" id="L87">    private static final Logger logger = LoggerFactory.getLogger(Keyspace.class);</span>

<span class="fc" id="L89">    private static final String TEST_FAIL_WRITES_KS = CassandraRelevantProperties.TEST_FAIL_WRITES_KS.getString();</span>
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">    private static final boolean TEST_FAIL_WRITES = !TEST_FAIL_WRITES_KS.isEmpty();</span>
<span class="fc" id="L91">    private static int TEST_FAIL_MV_LOCKS_COUNT = CassandraRelevantProperties.TEST_FAIL_MV_LOCKS_COUNT.getInt();</span>

    public final KeyspaceMetrics metric;

    // It is possible to call Keyspace.open without a running daemon, so it makes sense to ensure
    // proper directories here as well as in CassandraDaemon.
    static
    {
<span class="pc bpc" id="L99" title="3 of 4 branches missed.">        if (DatabaseDescriptor.isDaemonInitialized() || DatabaseDescriptor.isToolInitialized())</span>
<span class="fc" id="L100">            DatabaseDescriptor.createAllDirectories();</span>
    }

    private volatile KeyspaceMetadata metadata;

    //OpOrder is defined globally since we need to order writes across
    //Keyspaces in the case of Views (batchlog of view mutations)
<span class="fc" id="L107">    public static final OpOrder writeOrder = new OpOrder();</span>

    /* ColumnFamilyStore per column family */
<span class="pc" id="L110">    private final ConcurrentMap&lt;TableId, ColumnFamilyStore&gt; columnFamilyStores = new ConcurrentHashMap&lt;&gt;();</span>

    private volatile AbstractReplicationStrategy replicationStrategy;
    public final ViewManager viewManager;
    private final KeyspaceWriteHandler writeHandler;
    private volatile ReplicationParams replicationParams;
    private final KeyspaceRepairManager repairManager;
    private final SchemaProvider schema;

<span class="fc" id="L119">    private static volatile boolean initialized = false;</span>

    public static boolean isInitialized()
    {
<span class="fc" id="L123">        return initialized;</span>
    }

    public static void setInitialized()
    {
<span class="fc" id="L128">        synchronized (Schema.instance)</span>
        {
<span class="fc" id="L130">            initialized = true;</span>
<span class="fc" id="L131">        }</span>
<span class="fc" id="L132">    }</span>

    /**
     * Never use it in production code.
     *
     * Useful when creating a fake Schema so that it does not manage Keyspace instances (and CFS)
     */
    @VisibleForTesting
    public static void unsetInitialized()
    {
<span class="nc" id="L142">        synchronized (Schema.instance)</span>
        {
<span class="nc" id="L144">            initialized = false;</span>
<span class="nc" id="L145">        }</span>
<span class="nc" id="L146">    }</span>

    public static Keyspace open(String keyspaceName)
    {
<span class="pc bpc" id="L150" title="3 of 4 branches missed.">        assert initialized || SchemaConstants.isLocalSystemKeyspace(keyspaceName) : &quot;Initialized: &quot; + initialized;</span>
<span class="fc" id="L151">        return open(keyspaceName, Schema.instance, true);</span>
    }

    // to only be used by org.apache.cassandra.tools.Standalone* classes
    public static Keyspace openWithoutSSTables(String keyspaceName)
    {
<span class="nc" id="L157">        return open(keyspaceName, Schema.instance, false);</span>
    }

    public static Keyspace open(String keyspaceName, SchemaProvider schema, boolean loadSSTables)
    {
<span class="fc" id="L162">        return schema.maybeAddKeyspaceInstance(keyspaceName, () -&gt; new Keyspace(keyspaceName, schema, loadSSTables));</span>
    }

    public static ColumnFamilyStore openAndGetStore(TableMetadataRef tableRef)
    {
<span class="nc" id="L167">        return open(tableRef.keyspace).getColumnFamilyStore(tableRef.id);</span>
    }

    public static ColumnFamilyStore openAndGetStore(TableMetadata table)
    {
<span class="fc" id="L172">        return open(table.keyspace).getColumnFamilyStore(table.id);</span>
    }

    /**
     * Removes every SSTable in the directory from the appropriate Tracker's view.
     * @param directory the unreadable directory, possibly with SSTables in it, but not necessarily.
     */
    public static void removeUnreadableSSTables(File directory)
    {
<span class="nc bnc" id="L181" title="All 2 branches missed.">        for (Keyspace keyspace : Keyspace.all())</span>
        {
<span class="nc bnc" id="L183" title="All 2 branches missed.">            for (ColumnFamilyStore baseCfs : keyspace.getColumnFamilyStores())</span>
            {
<span class="nc bnc" id="L185" title="All 2 branches missed.">                for (ColumnFamilyStore cfs : baseCfs.concatWithIndexes())</span>
<span class="nc" id="L186">                    cfs.maybeRemoveUnreadableSSTables(directory);</span>
<span class="nc" id="L187">            }</span>
<span class="nc" id="L188">        }</span>
<span class="nc" id="L189">    }</span>

    public void setMetadata(KeyspaceMetadata metadata)
    {
<span class="fc" id="L193">        this.metadata = metadata;</span>
<span class="fc" id="L194">        createReplicationStrategy(metadata);</span>
<span class="fc" id="L195">    }</span>

    public KeyspaceMetadata getMetadata()
    {
<span class="fc" id="L199">        return metadata;</span>
    }

    public Collection&lt;ColumnFamilyStore&gt; getColumnFamilyStores()
    {
<span class="fc" id="L204">        return Collections.unmodifiableCollection(columnFamilyStores.values());</span>
    }

    public ColumnFamilyStore getColumnFamilyStore(String cfName)
    {
<span class="fc" id="L209">        TableMetadata table = schema.getTableMetadata(getName(), cfName);</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">        if (table == null)</span>
<span class="nc" id="L211">            throw new IllegalArgumentException(String.format(&quot;Unknown keyspace/cf pair (%s.%s)&quot;, getName(), cfName));</span>
<span class="fc" id="L212">        return getColumnFamilyStore(table.id);</span>
    }

    public ColumnFamilyStore getColumnFamilyStore(TableId id)
    {
<span class="fc" id="L217">        ColumnFamilyStore cfs = columnFamilyStores.get(id);</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">        if (cfs == null)</span>
<span class="nc" id="L219">            throw new IllegalArgumentException(&quot;Unknown CF &quot; + id);</span>
<span class="fc" id="L220">        return cfs;</span>
    }

    public boolean hasColumnFamilyStore(TableId id)
    {
<span class="fc" id="L225">        return columnFamilyStores.containsKey(id);</span>
    }

    /**
     * Take a snapshot of the specific column family, or the entire set of column families
     * if columnFamily is null with a given timestamp
     *
     * @param snapshotName     the tag associated with the name of the snapshot.  This value may not be null
     * @param columnFamilyName the column family to snapshot or all on null
     * @param skipFlush Skip blocking flush of memtable
     * @param rateLimiter Rate limiter for hardlinks-per-second
     * @throws IOException if the column family doesn't exist
     */
    public void snapshot(String snapshotName, String columnFamilyName, boolean skipFlush, DurationSpec.IntSecondsBound ttl, RateLimiter rateLimiter, Instant creationTime) throws IOException
    {
<span class="nc bnc" id="L240" title="All 2 branches missed.">        assert snapshotName != null;</span>
<span class="nc" id="L241">        boolean tookSnapShot = false;</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">        for (ColumnFamilyStore cfStore : columnFamilyStores.values())</span>
        {
<span class="nc bnc" id="L244" title="All 4 branches missed.">            if (columnFamilyName == null || cfStore.name.equals(columnFamilyName))</span>
            {
<span class="nc" id="L246">                tookSnapShot = true;</span>
<span class="nc" id="L247">                cfStore.snapshot(snapshotName, skipFlush, ttl, rateLimiter, creationTime);</span>
            }
<span class="nc" id="L249">        }</span>

<span class="nc bnc" id="L251" title="All 4 branches missed.">        if ((columnFamilyName != null) &amp;&amp; !tookSnapShot)</span>
<span class="nc" id="L252">            throw new IOException(&quot;Failed taking snapshot. Table &quot; + columnFamilyName + &quot; does not exist.&quot;);</span>
<span class="nc" id="L253">    }</span>

    /**
     * Take a snapshot of the specific column family, or the entire set of column families
     * if columnFamily is null with a given timestamp
     *
     * @param snapshotName     the tag associated with the name of the snapshot.  This value may not be null
     * @param columnFamilyName the column family to snapshot or all on null
     * @throws IOException if the column family doesn't exist
     */
    public void snapshot(String snapshotName, String columnFamilyName) throws IOException
    {
<span class="nc" id="L265">        snapshot(snapshotName, columnFamilyName, false, null, null, now());</span>
<span class="nc" id="L266">    }</span>

    /**
     * @param clientSuppliedName may be null.
     * @return the name of the snapshot
     */
    public static String getTimestampedSnapshotName(String clientSuppliedName)
    {
<span class="nc" id="L274">        String snapshotName = Long.toString(currentTimeMillis());</span>
<span class="nc bnc" id="L275" title="All 4 branches missed.">        if (clientSuppliedName != null &amp;&amp; !clientSuppliedName.equals(&quot;&quot;))</span>
        {
<span class="nc" id="L277">            snapshotName = snapshotName + &quot;-&quot; + clientSuppliedName;</span>
        }
<span class="nc" id="L279">        return snapshotName;</span>
    }

    public static String getTimestampedSnapshotNameWithPrefix(String clientSuppliedName, String prefix)
    {
<span class="nc" id="L284">        return prefix + &quot;-&quot; + getTimestampedSnapshotName(clientSuppliedName);</span>
    }

    /**
     * Check whether snapshots already exists for a given name.
     *
     * @param snapshotName the user supplied snapshot name
     * @return true if the snapshot exists
     */
    public boolean snapshotExists(String snapshotName)
    {
<span class="nc bnc" id="L295" title="All 2 branches missed.">        assert snapshotName != null;</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">        for (ColumnFamilyStore cfStore : columnFamilyStores.values())</span>
        {
<span class="nc bnc" id="L298" title="All 2 branches missed.">            if (cfStore.snapshotExists(snapshotName))</span>
<span class="nc" id="L299">                return true;</span>
<span class="nc" id="L300">        }</span>
<span class="nc" id="L301">        return false;</span>
    }

    /**
     * @return A list of open SSTableReaders
     */
    public List&lt;SSTableReader&gt; getAllSSTables(SSTableSet sstableSet)
    {
<span class="nc" id="L309">        List&lt;SSTableReader&gt; list = new ArrayList&lt;&gt;(columnFamilyStores.size());</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">        for (ColumnFamilyStore cfStore : columnFamilyStores.values())</span>
<span class="nc" id="L311">            Iterables.addAll(list, cfStore.getSSTables(sstableSet));</span>
<span class="nc" id="L312">        return list;</span>
    }

    public Stream&lt;TableSnapshot&gt; getAllSnapshots()
    {
<span class="nc" id="L317">        return getColumnFamilyStores().stream().flatMap(cfs -&gt; cfs.listSnapshots().values().stream());</span>
    }

    private Keyspace(String keyspaceName, SchemaProvider schema, boolean loadSSTables)
<span class="fc" id="L321">    {</span>
<span class="fc" id="L322">        this.schema = schema;</span>
<span class="fc" id="L323">        metadata = schema.getKeyspaceMetadata(keyspaceName);</span>
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">        assert metadata != null : &quot;Unknown keyspace &quot; + keyspaceName;</span>
        
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">        if (metadata.isVirtual())</span>
<span class="nc" id="L327">            throw new IllegalStateException(&quot;Cannot initialize Keyspace with virtual metadata &quot; + keyspaceName);</span>
<span class="fc" id="L328">        createReplicationStrategy(metadata);</span>

<span class="fc" id="L330">        this.metric = new KeyspaceMetrics(this);</span>
<span class="fc" id="L331">        this.viewManager = new ViewManager(this);</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">        for (TableMetadata cfm : metadata.tablesAndViews())</span>
        {
<span class="fc" id="L334">            logger.trace(&quot;Initializing {}.{}&quot;, getName(), cfm.name);</span>
<span class="fc" id="L335">            initCf(schema.getTableMetadataRef(cfm.id), loadSSTables);</span>
<span class="fc" id="L336">        }</span>
<span class="fc" id="L337">        this.viewManager.reload(false);</span>

<span class="fc" id="L339">        this.repairManager = new CassandraKeyspaceRepairManager(this);</span>
<span class="fc" id="L340">        this.writeHandler = new CassandraKeyspaceWriteHandler(this);</span>
<span class="fc" id="L341">    }</span>

    private Keyspace(KeyspaceMetadata metadata)
<span class="nc" id="L344">    {</span>
<span class="nc" id="L345">        this.schema = Schema.instance;</span>
<span class="nc" id="L346">        this.metadata = metadata;</span>
<span class="nc" id="L347">        createReplicationStrategy(metadata);</span>
<span class="nc" id="L348">        this.metric = new KeyspaceMetrics(this);</span>
<span class="nc" id="L349">        this.viewManager = new ViewManager(this);</span>
<span class="nc" id="L350">        this.repairManager = new CassandraKeyspaceRepairManager(this);</span>
<span class="nc" id="L351">        this.writeHandler = new CassandraKeyspaceWriteHandler(this);</span>
<span class="nc" id="L352">    }</span>

    public KeyspaceRepairManager getRepairManager()
    {
<span class="nc" id="L356">        return repairManager;</span>
    }

    public static Keyspace mockKS(KeyspaceMetadata metadata)
    {
<span class="nc" id="L361">        return new Keyspace(metadata);</span>
    }

    private void createReplicationStrategy(KeyspaceMetadata ksm)
    {
<span class="fc" id="L366">        logger.info(&quot;Creating replication strategy &quot; + ksm.name + &quot; params &quot; + ksm.params);</span>
<span class="fc" id="L367">        replicationStrategy = ksm.createReplicationStrategy();</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">        if (!ksm.params.replication.equals(replicationParams))</span>
        {
<span class="fc" id="L370">            logger.debug(&quot;New replication settings for keyspace {} - invalidating disk boundary caches&quot;, ksm.name);</span>
<span class="fc" id="L371">            columnFamilyStores.values().forEach(ColumnFamilyStore::invalidateLocalRanges);</span>
        }
<span class="fc" id="L373">        replicationParams = ksm.params.replication;</span>
<span class="fc" id="L374">    }</span>

    // best invoked on the compaction manager.
    public void dropCf(TableId tableId, boolean dropData)
    {
<span class="nc" id="L379">        ColumnFamilyStore cfs = columnFamilyStores.remove(tableId);</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">        if (cfs == null)</span>
<span class="nc" id="L381">            return;</span>

<span class="nc" id="L383">        cfs.onTableDropped();</span>
<span class="nc" id="L384">        unloadCf(cfs, dropData);</span>
<span class="nc" id="L385">    }</span>

    /**
     * Unloads all column family stores and releases metrics.
     */
    public void unload(boolean dropData)
    {
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">        for (ColumnFamilyStore cfs : getColumnFamilyStores())</span>
<span class="nc" id="L393">            unloadCf(cfs, dropData);</span>
<span class="fc" id="L394">        metric.release();</span>
<span class="fc" id="L395">    }</span>

    // disassociate a cfs from this keyspace instance.
    private void unloadCf(ColumnFamilyStore cfs, boolean dropData)
    {
<span class="nc" id="L400">        cfs.unloadCf();</span>
<span class="nc" id="L401">        cfs.invalidate(true, dropData);</span>
<span class="nc" id="L402">    }</span>

    /**
     * Registers a custom cf instance with this keyspace.
     * This is required for offline tools what use non-standard directories.
     */
    public void initCfCustom(ColumnFamilyStore newCfs)
    {
<span class="nc" id="L410">        ColumnFamilyStore cfs = columnFamilyStores.get(newCfs.metadata.id);</span>

<span class="nc bnc" id="L412" title="All 2 branches missed.">        if (cfs == null)</span>
        {
            // CFS being created for the first time, either on server startup or new CF being added.
            // We don't worry about races here; startup is safe, and adding multiple idential CFs
            // simultaneously is a &quot;don't do that&quot; scenario.
<span class="nc" id="L417">            ColumnFamilyStore oldCfs = columnFamilyStores.putIfAbsent(newCfs.metadata.id, newCfs);</span>
            // CFS mbean instantiation will error out before we hit this, but in case that changes...
<span class="nc bnc" id="L419" title="All 2 branches missed.">            if (oldCfs != null)</span>
<span class="nc" id="L420">                throw new IllegalStateException(&quot;added multiple mappings for cf id &quot; + newCfs.metadata.id);</span>
<span class="nc" id="L421">        }</span>
        else
        {
<span class="nc" id="L424">            throw new IllegalStateException(&quot;CFS is already initialized: &quot; + cfs.name);</span>
        }
<span class="nc" id="L426">    }</span>

    public KeyspaceWriteHandler getWriteHandler()
    {
<span class="fc" id="L430">        return writeHandler;</span>
    }

    /**
     * adds a cf to internal structures, ends up creating disk files).
     */
    public void initCf(TableMetadataRef metadata, boolean loadSSTables)
    {
<span class="fc" id="L438">        ColumnFamilyStore cfs = columnFamilyStores.get(metadata.id);</span>

<span class="pc bpc" id="L440" title="1 of 2 branches missed.">        if (cfs == null)</span>
        {
            // CFS being created for the first time, either on server startup or new CF being added.
            // We don't worry about races here; startup is safe, and adding multiple idential CFs
            // simultaneously is a &quot;don't do that&quot; scenario.
<span class="fc" id="L445">            ColumnFamilyStore oldCfs = columnFamilyStores.putIfAbsent(metadata.id, ColumnFamilyStore.createColumnFamilyStore(this, metadata, loadSSTables));</span>
            // CFS mbean instantiation will error out before we hit this, but in case that changes...
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">            if (oldCfs != null)</span>
<span class="nc" id="L448">                throw new IllegalStateException(&quot;added multiple mappings for cf id &quot; + metadata.id);</span>
<span class="fc" id="L449">        }</span>
        else
        {
            // re-initializing an existing CF.  This will happen if you cleared the schema
            // on this node and it's getting repopulated from the rest of the cluster.
<span class="nc bnc" id="L454" title="All 2 branches missed.">            assert cfs.name.equals(metadata.name);</span>
<span class="nc" id="L455">            cfs.reload();</span>
        }
<span class="fc" id="L457">    }</span>

    public Future&lt;?&gt; applyFuture(Mutation mutation, boolean writeCommitLog, boolean updateIndexes)
    {
<span class="nc" id="L461">        return applyInternal(mutation, writeCommitLog, updateIndexes, true, true, new AsyncPromise&lt;&gt;());</span>
    }

    public Future&lt;?&gt; applyFuture(Mutation mutation, boolean writeCommitLog, boolean updateIndexes, boolean isDroppable,
                                            boolean isDeferrable)
    {
<span class="nc" id="L467">        return applyInternal(mutation, writeCommitLog, updateIndexes, isDroppable, isDeferrable, new AsyncPromise&lt;&gt;());</span>
    }

    public void apply(Mutation mutation, boolean writeCommitLog, boolean updateIndexes)
    {
<span class="nc" id="L472">        apply(mutation, writeCommitLog, updateIndexes, true);</span>
<span class="nc" id="L473">    }</span>

    public void apply(final Mutation mutation,
                      final boolean writeCommitLog)
    {
<span class="nc" id="L478">        apply(mutation, writeCommitLog, true, true);</span>
<span class="nc" id="L479">    }</span>

    /**
     * If apply is blocking, apply must not be deferred
     * Otherwise there is a race condition where ALL mutation workers are beeing blocked ending
     * in a complete deadlock of the mutation stage. See CASSANDRA-12689.
     *
     * @param mutation       the row to write.  Must not be modified after calling apply, since commitlog append
     *                       may happen concurrently, depending on the CL Executor type.
     * @param makeDurable    if true, don't return unless write has been made durable
     * @param updateIndexes  false to disable index updates (used by CollationController &quot;defragmenting&quot;)
     * @param isDroppable    true if this should throw WriteTimeoutException if it does not acquire lock within write_request_timeout
     */
    public void apply(final Mutation mutation,
                      final boolean makeDurable,
                      boolean updateIndexes,
                      boolean isDroppable)
    {
<span class="fc" id="L497">        applyInternal(mutation, makeDurable, updateIndexes, isDroppable, false, null);</span>
<span class="fc" id="L498">    }</span>

    /**
     * This method appends a row to the global CommitLog, then updates memtables and indexes.
     *
     * @param mutation       the row to write.  Must not be modified after calling apply, since commitlog append
     *                       may happen concurrently, depending on the CL Executor type.
     * @param makeDurable    if true, don't return unless write has been made durable
     * @param updateIndexes  false to disable index updates (used by CollationController &quot;defragmenting&quot;)
     * @param isDroppable    true if this should throw WriteTimeoutException if it does not acquire lock within write_request_timeout
     * @param isDeferrable   true if caller is not waiting for future to complete, so that future may be deferred
     */
    private Future&lt;?&gt; applyInternal(final Mutation mutation,
                                               final boolean makeDurable,
                                               boolean updateIndexes,
                                               boolean isDroppable,
                                               boolean isDeferrable,
                                               Promise&lt;?&gt; future)
    {
<span class="pc bpc" id="L517" title="3 of 4 branches missed.">        if (TEST_FAIL_WRITES &amp;&amp; metadata.name.equals(TEST_FAIL_WRITES_KS))</span>
<span class="nc" id="L518">            throw new RuntimeException(&quot;Testing write failures&quot;);</span>

<span class="fc" id="L520">        Lock[] locks = null;</span>

<span class="pc bpc" id="L522" title="2 of 4 branches missed.">        boolean requiresViewUpdate = updateIndexes &amp;&amp; viewManager.updatesAffectView(Collections.singleton(mutation), false);</span>

<span class="pc bpc" id="L524" title="1 of 2 branches missed.">        if (requiresViewUpdate)</span>
        {
<span class="nc" id="L526">            mutation.viewLockAcquireStart.compareAndSet(0L, currentTimeMillis());</span>

            // the order of lock acquisition doesn't matter (from a deadlock perspective) because we only use tryLock()
<span class="nc" id="L529">            Collection&lt;TableId&gt; tableIds = mutation.getTableIds();</span>
<span class="nc" id="L530">            Iterator&lt;TableId&gt; idIterator = tableIds.iterator();</span>

<span class="nc" id="L532">            locks = new Lock[tableIds.size()];</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">            for (int i = 0; i &lt; tableIds.size(); i++)</span>
            {
<span class="nc" id="L535">                TableId tableId = idIterator.next();</span>
<span class="nc" id="L536">                int lockKey = Objects.hash(mutation.key().getKey(), tableId);</span>
                while (true)
                {
<span class="nc" id="L539">                    Lock lock = null;</span>

<span class="nc bnc" id="L541" title="All 2 branches missed.">                    if (TEST_FAIL_MV_LOCKS_COUNT == 0)</span>
<span class="nc" id="L542">                        lock = ViewManager.acquireLockFor(lockKey);</span>
                    else
<span class="nc" id="L544">                        TEST_FAIL_MV_LOCKS_COUNT--;</span>

<span class="nc bnc" id="L546" title="All 2 branches missed.">                    if (lock == null)</span>
                    {
                        //throw WTE only if request is droppable
<span class="nc bnc" id="L549" title="All 4 branches missed.">                        if (isDroppable &amp;&amp; (approxTime.isAfter(mutation.approxCreatedAtNanos + DatabaseDescriptor.getWriteRpcTimeout(NANOSECONDS))))</span>
                        {
<span class="nc bnc" id="L551" title="All 2 branches missed.">                            for (int j = 0; j &lt; i; j++)</span>
<span class="nc" id="L552">                                locks[j].unlock();</span>

<span class="nc bnc" id="L554" title="All 2 branches missed.">                            if (logger.isTraceEnabled())</span>
<span class="nc" id="L555">                                logger.trace(&quot;Could not acquire lock for {} and table {}&quot;, ByteBufferUtil.bytesToHex(mutation.key().getKey()), columnFamilyStores.get(tableId).name);</span>
<span class="nc" id="L556">                            Tracing.trace(&quot;Could not acquire MV lock&quot;);</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">                            if (future != null)</span>
                            {
<span class="nc" id="L559">                                future.tryFailure(new WriteTimeoutException(WriteType.VIEW, ConsistencyLevel.LOCAL_ONE, 0, 1));</span>
<span class="nc" id="L560">                                return future;</span>
                            }
                            else
<span class="nc" id="L563">                                throw new WriteTimeoutException(WriteType.VIEW, ConsistencyLevel.LOCAL_ONE, 0, 1);</span>
                        }
<span class="nc bnc" id="L565" title="All 2 branches missed.">                        else if (isDeferrable)</span>
                        {
<span class="nc bnc" id="L567" title="All 2 branches missed.">                            for (int j = 0; j &lt; i; j++)</span>
<span class="nc" id="L568">                                locks[j].unlock();</span>

                            // This view update can't happen right now. so rather than keep this thread busy
                            // we will re-apply ourself to the queue and try again later
<span class="nc" id="L572">                            Stage.MUTATION.execute(() -&gt;</span>
<span class="nc" id="L573">                                                   applyInternal(mutation, makeDurable, true, isDroppable, true, future)</span>
                            );
<span class="nc" id="L575">                            return future;</span>
                        }
                        else
                        {
                            // Retry lock on same thread, if mutation is not deferrable.
                            // Mutation is not deferrable, if applied from MutationStage and caller is waiting for future to finish
                            // If blocking caller defers future, this may lead to deadlock situation with all MutationStage workers
                            // being blocked by waiting for futures which will never be processed as all workers are blocked
                            try
                            {
                                // Wait a little bit before retrying to lock
<span class="nc" id="L586">                                Thread.sleep(10);</span>
                            }
<span class="nc" id="L588">                            catch (InterruptedException e)</span>
                            {
<span class="nc" id="L590">                                throw new UncheckedInterruptedException(e);</span>
<span class="nc" id="L591">                            }</span>
                            continue;
                        }
                    }
                    else
                    {
<span class="nc" id="L597">                        locks[i] = lock;</span>
                    }
<span class="nc" id="L599">                    break;</span>
                }
            }

<span class="nc" id="L603">            long acquireTime = currentTimeMillis() - mutation.viewLockAcquireStart.get();</span>
            // Metrics are only collected for droppable write operations
            // Bulk non-droppable operations (e.g. commitlog replay, hint delivery) are not measured
<span class="nc bnc" id="L606" title="All 2 branches missed.">            if (isDroppable)</span>
            {
<span class="nc bnc" id="L608" title="All 2 branches missed.">                for(TableId tableId : tableIds)</span>
<span class="nc" id="L609">                    columnFamilyStores.get(tableId).metric.viewLockAcquireTime.update(acquireTime, MILLISECONDS);</span>
            }
        }
<span class="fc" id="L612">        try (WriteContext ctx = getWriteHandler().beginWrite(mutation, makeDurable))</span>
        {
<span class="fc bfc" id="L614" title="All 2 branches covered.">            for (PartitionUpdate upd : mutation.getPartitionUpdates())</span>
            {
<span class="fc" id="L616">                ColumnFamilyStore cfs = columnFamilyStores.get(upd.metadata().id);</span>
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">                if (cfs == null)</span>
                {
<span class="nc" id="L619">                    logger.error(&quot;Attempting to mutate non-existant table {} ({}.{})&quot;, upd.metadata().id, upd.metadata().keyspace, upd.metadata().name);</span>
<span class="nc" id="L620">                    continue;</span>
                }
<span class="fc" id="L622">                AtomicLong baseComplete = new AtomicLong(Long.MAX_VALUE);</span>

<span class="pc bpc" id="L624" title="1 of 2 branches missed.">                if (requiresViewUpdate)</span>
                {
                    try
                    {
<span class="nc" id="L628">                        Tracing.trace(&quot;Creating materialized view mutations from base table replica&quot;);</span>
<span class="nc" id="L629">                        viewManager.forTable(upd.metadata().id).pushViewReplicaUpdates(upd, makeDurable, baseComplete);</span>
                    }
<span class="nc" id="L631">                    catch (Throwable t)</span>
                    {
<span class="nc" id="L633">                        JVMStabilityInspector.inspectThrowable(t);</span>
<span class="nc" id="L634">                        logger.error(String.format(&quot;Unknown exception caught while attempting to update MaterializedView! %s&quot;,</span>
<span class="nc" id="L635">                                                   upd.metadata().toString()), t);</span>
<span class="nc" id="L636">                        throw t;</span>
<span class="nc" id="L637">                    }</span>
                }

<span class="fc" id="L640">                cfs.getWriteHandler().write(upd, ctx, updateIndexes);</span>

<span class="pc bpc" id="L642" title="1 of 2 branches missed.">                if (requiresViewUpdate)</span>
<span class="nc" id="L643">                    baseComplete.set(currentTimeMillis());</span>
<span class="fc" id="L644">            }</span>

<span class="pc bpc" id="L646" title="1 of 2 branches missed.">            if (future != null) {</span>
<span class="nc" id="L647">                future.trySuccess(null);</span>
            }
<span class="fc" id="L649">            return future;</span>
        }
        finally
        {
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">            if (locks != null)</span>
            {
<span class="nc bnc" id="L655" title="All 2 branches missed.">                for (Lock lock : locks)</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">                    if (lock != null)</span>
<span class="nc" id="L657">                        lock.unlock();</span>
            }
        }
    }

    public AbstractReplicationStrategy getReplicationStrategy()
    {
<span class="fc" id="L664">        return replicationStrategy;</span>
    }

    public List&lt;Future&lt;?&gt;&gt; flush(ColumnFamilyStore.FlushReason reason)
    {
<span class="nc" id="L669">        List&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;(columnFamilyStores.size());</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">        for (ColumnFamilyStore cfs : columnFamilyStores.values())</span>
<span class="nc" id="L671">            futures.add(cfs.forceFlush(reason));</span>
<span class="nc" id="L672">        return futures;</span>
    }

    public Iterable&lt;ColumnFamilyStore&gt; getValidColumnFamilies(boolean allowIndexes,
                                                              boolean autoAddIndexes,
                                                              String... cfNames)
    {
<span class="nc" id="L679">        Set&lt;ColumnFamilyStore&gt; valid = new HashSet&lt;&gt;();</span>

<span class="nc bnc" id="L681" title="All 2 branches missed.">        if (cfNames.length == 0)</span>
        {
            // all stores are interesting
<span class="nc bnc" id="L684" title="All 2 branches missed.">            for (ColumnFamilyStore cfStore : getColumnFamilyStores())</span>
            {
<span class="nc" id="L686">                valid.add(cfStore);</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">                if (autoAddIndexes)</span>
<span class="nc" id="L688">                    valid.addAll(getIndexColumnFamilyStores(cfStore));</span>
<span class="nc" id="L689">            }</span>
<span class="nc" id="L690">            return valid;</span>
        }

        // include the specified stores and possibly the stores of any of their indexes
<span class="nc bnc" id="L694" title="All 2 branches missed.">        for (String cfName : cfNames)</span>
        {
<span class="nc bnc" id="L696" title="All 2 branches missed.">            if (SecondaryIndexManager.isIndexColumnFamily(cfName))</span>
            {
<span class="nc bnc" id="L698" title="All 2 branches missed.">                if (!allowIndexes)</span>
                {
<span class="nc" id="L700">                    logger.warn(&quot;Operation not allowed on secondary Index table ({})&quot;, cfName);</span>
<span class="nc" id="L701">                    continue;</span>
                }
<span class="nc" id="L703">                String baseName = SecondaryIndexManager.getParentCfsName(cfName);</span>
<span class="nc" id="L704">                String indexName = SecondaryIndexManager.getIndexName(cfName);</span>

<span class="nc" id="L706">                ColumnFamilyStore baseCfs = getColumnFamilyStore(baseName);</span>
<span class="nc" id="L707">                Index index = baseCfs.indexManager.getIndexByName(indexName);</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">                if (index == null)</span>
<span class="nc" id="L709">                    throw new IllegalArgumentException(String.format(&quot;Invalid index specified: %s/%s.&quot;,</span>
                                                                     baseCfs.metadata.name,
                                                                     indexName));

<span class="nc bnc" id="L713" title="All 2 branches missed.">                if (index.getBackingTable().isPresent())</span>
<span class="nc" id="L714">                    valid.add(index.getBackingTable().get());</span>
<span class="nc" id="L715">            }</span>
            else
            {
<span class="nc" id="L718">                ColumnFamilyStore cfStore = getColumnFamilyStore(cfName);</span>
<span class="nc" id="L719">                valid.add(cfStore);</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">                if (autoAddIndexes)</span>
<span class="nc" id="L721">                    valid.addAll(getIndexColumnFamilyStores(cfStore));</span>
            }
        }

<span class="nc" id="L725">        return valid;</span>
    }

    private Set&lt;ColumnFamilyStore&gt; getIndexColumnFamilyStores(ColumnFamilyStore baseCfs)
    {
<span class="nc" id="L730">        Set&lt;ColumnFamilyStore&gt; stores = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">        for (ColumnFamilyStore indexCfs : baseCfs.indexManager.getAllIndexColumnFamilyStores())</span>
        {
<span class="nc" id="L733">            logger.info(&quot;adding secondary index table {} to operation&quot;, indexCfs.metadata.name);</span>
<span class="nc" id="L734">            stores.add(indexCfs);</span>
<span class="nc" id="L735">        }</span>
<span class="nc" id="L736">        return stores;</span>
    }

    public static Iterable&lt;Keyspace&gt; all()
    {
<span class="nc" id="L741">        return Iterables.transform(Schema.instance.getKeyspaces(), Keyspace::open);</span>
    }

    /**
     * @return a {@link Stream} of all existing/open {@link Keyspace} instances
     */
    public static Stream&lt;Keyspace&gt; allExisting()
    {
<span class="nc" id="L749">        return Schema.instance.getKeyspaces().stream().map(Schema.instance::getKeyspaceInstance).filter(Objects::nonNull);</span>
    }

    public static Iterable&lt;Keyspace&gt; nonSystem()
    {
<span class="nc" id="L754">        return Iterables.transform(Schema.instance.getNonSystemKeyspaces().names(), Keyspace::open);</span>
    }

    public static Iterable&lt;Keyspace&gt; nonLocalStrategy()
    {
<span class="nc" id="L759">        return Iterables.transform(Schema.instance.getNonLocalStrategyKeyspaces().names(), Keyspace::open);</span>
    }

    public static Iterable&lt;Keyspace&gt; system()
    {
<span class="nc" id="L764">        return Iterables.transform(SchemaConstants.LOCAL_SYSTEM_KEYSPACE_NAMES, Keyspace::open);</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L770">        return getClass().getSimpleName() + &quot;(name='&quot; + getName() + &quot;')&quot;;</span>
    }

    public String getName()
    {
<span class="fc" id="L775">        return metadata.name;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>