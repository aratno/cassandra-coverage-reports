<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractCompositeType.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.marshal</a> &gt; <span class="el_source">AbstractCompositeType.java</span></div><h1>AbstractCompositeType.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.marshal;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.regex.Pattern;

import org.apache.cassandra.cql3.Term;
import org.apache.cassandra.serializers.MarshalException;
import org.apache.cassandra.transport.ProtocolVersion;
import org.apache.cassandra.utils.ByteBufferUtil;

/**
 * A class avoiding class duplication between CompositeType and
 * DynamicCompositeType.
 * Those two differs only in that for DynamicCompositeType, the comparators
 * are in the encoded column name at the front of each component.
 */
public abstract class AbstractCompositeType extends AbstractType&lt;ByteBuffer&gt;
{
    protected AbstractCompositeType()
    {
<span class="fc" id="L41">        super(ComparisonType.CUSTOM);</span>
<span class="fc" id="L42">    }</span>

    public &lt;VL, VR&gt; int compareCustom(VL left, ValueAccessor&lt;VL&gt; accessorL, VR right, ValueAccessor&lt;VR&gt; accessorR)
    {
<span class="nc bnc" id="L46" title="All 4 branches missed.">        if (accessorL.isEmpty(left) || accessorR.isEmpty(right))</span>
<span class="nc" id="L47">            return Boolean.compare(accessorR.isEmpty(right), accessorL.isEmpty(left));</span>

<span class="nc" id="L49">        boolean isStaticL = readIsStatic(left, accessorL);</span>
<span class="nc" id="L50">        boolean isStaticR = readIsStatic(right, accessorR);</span>
<span class="nc bnc" id="L51" title="All 2 branches missed.">        if (isStaticL != isStaticR)</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">            return isStaticL ? -1 : 1;</span>

<span class="nc" id="L54">        int i = 0;</span>

<span class="nc" id="L56">        VL previous = null;</span>
<span class="nc" id="L57">        int offsetL = startingOffset(isStaticL);</span>
<span class="nc" id="L58">        int offsetR = startingOffset(isStaticR);</span>

<span class="nc bnc" id="L60" title="All 4 branches missed.">        while (!accessorL.isEmptyFromOffset(left, offsetL) &amp;&amp; !accessorR.isEmptyFromOffset(right, offsetL))</span>
        {
<span class="nc" id="L62">            AbstractType&lt;?&gt; comparator = getComparator(i, left, accessorL, right, accessorR, offsetL, offsetR);</span>
<span class="nc" id="L63">            offsetL += getComparatorSize(i, left, accessorL, offsetL);</span>
<span class="nc" id="L64">            offsetR += getComparatorSize(i, right, accessorR, offsetR);</span>

<span class="nc" id="L66">            VL value1 = accessorL.sliceWithShortLength(left, offsetL);</span>
<span class="nc" id="L67">            offsetL += accessorL.sizeWithShortLength(value1);</span>
<span class="nc" id="L68">            VR value2 = accessorR.sliceWithShortLength(right, offsetR);</span>
<span class="nc" id="L69">            offsetR += accessorR.sizeWithShortLength(value2);</span>

<span class="nc" id="L71">            int cmp = comparator.compareCollectionMembers(value1, accessorL, value2, accessorR, previous);</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">            if (cmp != 0)</span>
<span class="nc" id="L73">                return cmp;</span>

<span class="nc" id="L75">            previous = value1;</span>

<span class="nc" id="L77">            byte bL = accessorL.getByte(left, offsetL++);</span>
<span class="nc" id="L78">            byte bR = accessorR.getByte(right, offsetR++);</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">            if (bL != bR)</span>
<span class="nc" id="L80">                return bL - bR;</span>

<span class="nc" id="L82">            ++i;</span>
<span class="nc" id="L83">        }</span>

<span class="nc bnc" id="L85" title="All 2 branches missed.">        if (accessorL.isEmptyFromOffset(left, offsetL))</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">            return accessorR.sizeFromOffset(right, offsetR) == 0 ? 0 : -1;</span>

        // left.remaining() &gt; 0 &amp;&amp; right.remaining() == 0
<span class="nc" id="L89">        return 1;</span>
    }

    // Check if the provided BB represents a static name and advance the
    // buffer to the real beginning if so.
    protected abstract &lt;V&gt; boolean readIsStatic(V value, ValueAccessor&lt;V&gt; accessor);

    protected abstract int startingOffset(boolean isStatic);

    /**
     * Split a composite column names into it's components.
     */
    public ByteBuffer[] split(ByteBuffer bb)
    {
<span class="nc" id="L103">        List&lt;ByteBuffer&gt; l = new ArrayList&lt;ByteBuffer&gt;();</span>
<span class="nc" id="L104">        boolean isStatic = readIsStatic(bb, ByteBufferAccessor.instance);</span>
<span class="nc" id="L105">        int offset = startingOffset(isStatic);</span>

<span class="nc" id="L107">        int i = 0;</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">        while (!ByteBufferAccessor.instance.isEmptyFromOffset(bb, offset))</span>
        {
<span class="nc" id="L110">            offset += getComparatorSize(i++, bb, ByteBufferAccessor.instance, offset);</span>
<span class="nc" id="L111">            ByteBuffer value = ByteBufferAccessor.instance.sliceWithShortLength(bb, offset);</span>
<span class="nc" id="L112">            offset += ByteBufferAccessor.instance.sizeWithShortLength(value);</span>
<span class="nc" id="L113">            l.add(value);</span>
<span class="nc" id="L114">            offset++; // skip end-of-component</span>
<span class="nc" id="L115">        }</span>
<span class="nc" id="L116">        return l.toArray(new ByteBuffer[l.size()]);</span>
    }

    private static final String COLON = &quot;:&quot;;
<span class="fc" id="L120">    private static final Pattern COLON_PAT = Pattern.compile(COLON);</span>
    private static final String ESCAPED_COLON = &quot;\\\\:&quot;;
<span class="fc" id="L122">    private static final Pattern ESCAPED_COLON_PAT = Pattern.compile(ESCAPED_COLON);</span>


    /*
     * Escapes all occurences of the ':' character from the input, replacing them by &quot;\:&quot;.
     * Furthermore, if the last character is '\' or '!', a '!' is appended.
     */
    public static String escape(String input)
    {
<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (input.isEmpty())</span>
<span class="nc" id="L132">            return input;</span>

<span class="nc" id="L134">        String res = COLON_PAT.matcher(input).replaceAll(ESCAPED_COLON);</span>
<span class="nc" id="L135">        char last = res.charAt(res.length() - 1);</span>
<span class="nc bnc" id="L136" title="All 4 branches missed.">        return last == '\\' || last == '!' ? res + '!' : res;</span>
    }

    /*
     * Reverses the effect of espace().
     * Replaces all occurences of &quot;\:&quot; by &quot;:&quot; and remove last character if it is '!'.
     */
    static String unescape(String input)
    {
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (input.isEmpty())</span>
<span class="nc" id="L146">            return input;</span>

<span class="nc" id="L148">        String res = ESCAPED_COLON_PAT.matcher(input).replaceAll(COLON);</span>
<span class="nc" id="L149">        char last = res.charAt(res.length() - 1);</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        return last == '!' ? res.substring(0, res.length() - 1) : res;</span>
    }

    /*
     * Split the input on character ':', unless the previous character is '\'.
     */
    static List&lt;String&gt; split(String input)
    {
<span class="nc bnc" id="L158" title="All 2 branches missed.">        if (input.isEmpty())</span>
<span class="nc" id="L159">            return Collections.&lt;String&gt;emptyList();</span>

<span class="nc" id="L161">        List&lt;String&gt; res = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L162">        int prev = 0;</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">        for (int i = 0; i &lt; input.length(); i++)</span>
        {
<span class="nc bnc" id="L165" title="All 6 branches missed.">            if (input.charAt(i) != ':' || (i &gt; 0 &amp;&amp; input.charAt(i-1) == '\\'))</span>
<span class="nc" id="L166">                continue;</span>

<span class="nc" id="L168">            res.add(input.substring(prev, i));</span>
<span class="nc" id="L169">            prev = i + 1;</span>
        }
<span class="nc" id="L171">        res.add(input.substring(prev, input.length()));</span>
<span class="nc" id="L172">        return res;</span>
    }

    public &lt;V&gt; String getString(V input, ValueAccessor&lt;V&gt; accessor)
    {
<span class="nc" id="L177">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L178">        boolean isStatic  = readIsStatic(input, accessor);</span>
<span class="nc" id="L179">        int offset = startingOffset(isStatic);</span>
<span class="nc" id="L180">        int startOffset = offset;</span>

<span class="nc" id="L182">        int i = 0;</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">        while (!accessor.isEmptyFromOffset(input, offset))</span>
        {
<span class="nc bnc" id="L185" title="All 2 branches missed.">            if (offset != startOffset)</span>
<span class="nc" id="L186">                sb.append(&quot;:&quot;);</span>

<span class="nc" id="L188">            AbstractType&lt;?&gt; comparator = getAndAppendComparator(i, input, accessor, sb, offset);</span>
<span class="nc" id="L189">            offset += getComparatorSize(i, input, accessor, offset);</span>
<span class="nc" id="L190">            V value = accessor.sliceWithShortLength(input, offset);</span>
<span class="nc" id="L191">            offset += accessor.sizeWithShortLength(value);</span>

<span class="nc" id="L193">            sb.append(escape(comparator.getString(value, accessor)));</span>

<span class="nc" id="L195">            byte b = accessor.getByte(input, offset++);</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">            if (b != 0)</span>
            {
<span class="nc bnc" id="L198" title="All 2 branches missed.">                sb.append(b &lt; 0 ? &quot;:_&quot; : &quot;:!&quot;);</span>
<span class="nc" id="L199">                break;</span>
            }
<span class="nc" id="L201">            ++i;</span>
<span class="nc" id="L202">        }</span>
<span class="nc" id="L203">        return sb.toString();</span>
    }

    public ByteBuffer fromString(String source)
    {
<span class="nc" id="L208">        List&lt;String&gt; parts = split(source);</span>
<span class="nc" id="L209">        List&lt;ByteBuffer&gt; components = new ArrayList&lt;&gt;(parts.size());</span>
<span class="nc" id="L210">        List&lt;ParsedComparator&gt; comparators = new ArrayList&lt;&gt;(parts.size());</span>
<span class="nc" id="L211">        int totalLength = 0, i = 0;</span>
<span class="nc" id="L212">        boolean lastByteIsOne = false;</span>
<span class="nc" id="L213">        boolean lastByteIsMinusOne = false;</span>

<span class="nc bnc" id="L215" title="All 2 branches missed.">        for (String part : parts)</span>
        {
<span class="nc bnc" id="L217" title="All 2 branches missed.">            if (part.equals(&quot;!&quot;))</span>
            {
<span class="nc" id="L219">                lastByteIsOne = true;</span>
<span class="nc" id="L220">                break;</span>
            }
<span class="nc bnc" id="L222" title="All 2 branches missed.">            else if (part.equals(&quot;_&quot;))</span>
            {
<span class="nc" id="L224">                lastByteIsMinusOne = true;</span>
<span class="nc" id="L225">                break;</span>
            }

<span class="nc" id="L228">            ParsedComparator p = parseComparator(i, part);</span>
<span class="nc" id="L229">            AbstractType&lt;?&gt; type = p.getAbstractType();</span>
<span class="nc" id="L230">            part = p.getRemainingPart();</span>

<span class="nc" id="L232">            ByteBuffer component = type.fromString(unescape(part));</span>
<span class="nc" id="L233">            type.validate(component);</span>
<span class="nc" id="L234">            totalLength += p.getComparatorSerializedSize() + 2 + component.remaining() + 1;</span>
<span class="nc" id="L235">            components.add(component);</span>
<span class="nc" id="L236">            comparators.add(p);</span>
<span class="nc" id="L237">            ++i;</span>
<span class="nc" id="L238">        }</span>

<span class="nc" id="L240">        ByteBuffer bb = ByteBuffer.allocate(totalLength);</span>
<span class="nc" id="L241">        i = 0;</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">        for (ByteBuffer component : components)</span>
        {
<span class="nc" id="L244">            comparators.get(i).serializeComparator(bb);</span>
<span class="nc" id="L245">            ByteBufferUtil.writeShortLength(bb, component.remaining());</span>
<span class="nc" id="L246">            bb.put(component.duplicate()); // it's not ok to consume component as we did not create it (CASSANDRA-14752)</span>
<span class="nc" id="L247">            bb.put((byte)0);</span>
<span class="nc" id="L248">            ++i;</span>
<span class="nc" id="L249">        }</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">        if (lastByteIsOne)</span>
<span class="nc" id="L251">            bb.put(bb.limit() - 1, (byte)1);</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">        else if (lastByteIsMinusOne)</span>
<span class="nc" id="L253">            bb.put(bb.limit() - 1, (byte)-1);</span>

<span class="nc" id="L255">        bb.rewind();</span>
<span class="nc" id="L256">        return bb;</span>
    }

    @Override
    public Term fromJSONObject(Object parsed)
    {
<span class="nc" id="L262">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public String toJSONString(ByteBuffer buffer, ProtocolVersion protocolVersion)
    {
        // TODO: suport toJSONString (CASSANDRA-18177)
<span class="nc" id="L269">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public void validate(ByteBuffer bb) throws MarshalException
    {
<span class="nc" id="L275">        validate(bb, ByteBufferAccessor.instance);</span>
<span class="nc" id="L276">    }</span>

    public  &lt;V&gt; void validate(V input, ValueAccessor&lt;V&gt; accessor)
    {
<span class="nc" id="L280">        boolean isStatic = readIsStatic(input, accessor);</span>
<span class="nc" id="L281">        int offset = startingOffset(isStatic);</span>

<span class="nc" id="L283">        int i = 0;</span>
<span class="nc" id="L284">        V previous = null;</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">        while (!accessor.isEmptyFromOffset(input, offset))</span>
        {
<span class="nc" id="L287">            AbstractType&lt;?&gt; comparator = validateComparator(i, input, accessor, offset);</span>
<span class="nc" id="L288">            offset += getComparatorSize(i, input, accessor, offset);</span>

<span class="nc bnc" id="L290" title="All 2 branches missed.">            if (accessor.sizeFromOffset(input, offset) &lt; 2)</span>
<span class="nc" id="L291">                throw new MarshalException(&quot;Not enough bytes to read value size of component &quot; + i);</span>
<span class="nc" id="L292">            int length = accessor.getUnsignedShort(input, offset);</span>
<span class="nc" id="L293">            offset += 2;</span>

<span class="nc bnc" id="L295" title="All 2 branches missed.">            if (accessor.sizeFromOffset(input, offset) &lt; length)</span>
<span class="nc" id="L296">                throw new MarshalException(&quot;Not enough bytes to read value of component &quot; + i);</span>
<span class="nc" id="L297">            V value = accessor.slice(input, offset, length);</span>
<span class="nc" id="L298">            offset += length;</span>

<span class="nc" id="L300">            comparator.validateCollectionMember(value, previous, accessor);</span>

<span class="nc bnc" id="L302" title="All 2 branches missed.">            if (accessor.isEmptyFromOffset(input, offset))</span>
<span class="nc" id="L303">                throw new MarshalException(&quot;Not enough bytes to read the end-of-component byte of component&quot; + i);</span>
<span class="nc" id="L304">            byte b = accessor.getByte(input, offset++);</span>
<span class="nc bnc" id="L305" title="All 4 branches missed.">            if (b != 0 &amp;&amp; !accessor.isEmptyFromOffset(input, offset))</span>
<span class="nc" id="L306">                throw new MarshalException(&quot;Invalid bytes remaining after an end-of-component at component&quot; + i);</span>

<span class="nc" id="L308">            previous = value;</span>
<span class="nc" id="L309">            ++i;</span>
<span class="nc" id="L310">        }</span>
<span class="nc" id="L311">    }</span>

    public abstract ByteBuffer decompose(Object... objects);

    abstract protected &lt;V&gt; int getComparatorSize(int i, V value, ValueAccessor&lt;V&gt; accessor, int offset);
    /**
     * @return the comparator for the given component. static CompositeType will consult
     * @param i DynamicCompositeType will read the type information from @param bb
     * @param value name of type definition
     */
    abstract protected &lt;V&gt; AbstractType&lt;?&gt; getComparator(int i, V value, ValueAccessor&lt;V&gt; accessor, int offset);

    /**
     * Adds DynamicCompositeType type information from @param bb1 to @param bb2.
     * @param i is ignored.
     */
    abstract protected &lt;VL, VR&gt; AbstractType&lt;?&gt; getComparator(int i, VL left, ValueAccessor&lt;VL&gt; accessorL, VR right, ValueAccessor&lt;VR&gt; accessorR, int offsetL, int offsetR);

    /**
     * Adds type information from @param bb to @param sb.  @param i is ignored.
     */
    abstract protected &lt;V&gt; AbstractType&lt;?&gt; getAndAppendComparator(int i, V value, ValueAccessor&lt;V&gt; accessor, StringBuilder sb, int offset);

    /**
     * Like getComparator, but validates that @param i does not exceed the defined range
     */
    abstract protected &lt;V&gt; AbstractType&lt;?&gt; validateComparator(int i, V value, ValueAccessor&lt;V&gt; accessor, int offset) throws MarshalException;

    /**
     * Used by fromString
     */
    abstract protected ParsedComparator parseComparator(int i, String part);

    protected static interface ParsedComparator
    {
        AbstractType&lt;?&gt; getAbstractType();
        String getRemainingPart();
        int getComparatorSerializedSize();
        void serializeComparator(ByteBuffer bb);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>