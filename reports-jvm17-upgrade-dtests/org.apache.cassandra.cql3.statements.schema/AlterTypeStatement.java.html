<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AlterTypeStatement.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.statements.schema</a> &gt; <span class="el_source">AlterTypeStatement.java</span></div><h1>AlterTypeStatement.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3.statements.schema;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.cassandra.audit.AuditLogContext;
import org.apache.cassandra.audit.AuditLogEntryType;
import org.apache.cassandra.auth.Permission;
import org.apache.cassandra.cql3.*;
import org.apache.cassandra.db.guardrails.Guardrails;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.marshal.UserType;
import org.apache.cassandra.schema.KeyspaceMetadata;
import org.apache.cassandra.schema.Keyspaces;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.service.ClientState;
import org.apache.cassandra.transport.Event.SchemaChange;
import org.apache.cassandra.transport.Event.SchemaChange.Change;
import org.apache.cassandra.transport.Event.SchemaChange.Target;

import static com.google.common.collect.Iterables.any;
import static com.google.common.collect.Iterables.filter;
import static com.google.common.collect.Iterables.transform;
import static java.lang.String.join;
import static java.util.function.Predicate.isEqual;
import static java.util.stream.Collectors.toList;

import static org.apache.cassandra.utils.ByteBufferUtil.bytes;

public abstract class AlterTypeStatement extends AlterSchemaStatement
{
    protected final String typeName;
    protected final boolean ifExists;

    public AlterTypeStatement(String keyspaceName, String typeName, boolean ifExists)
    {
        super(keyspaceName);
        this.ifExists = ifExists;
        this.typeName = typeName;
    }

    public void authorize(ClientState client)
    {
        client.ensureAllTablesPermission(keyspaceName, Permission.ALTER);
    }

    SchemaChange schemaChangeEvent(Keyspaces.KeyspacesDiff diff)
    {
        return new SchemaChange(Change.UPDATED, Target.TYPE, keyspaceName, typeName);
    }

    public Keyspaces apply(Keyspaces schema)
    {
        KeyspaceMetadata keyspace = schema.getNullable(keyspaceName);

        UserType type = null == keyspace
                      ? null
                      : keyspace.types.getNullable(bytes(typeName));

        if (null == type)
        {
            if (!ifExists)
                throw ire(&quot;Type %s.%s doesn't exist&quot;, keyspaceName, typeName);
            return schema;
        }

        return schema.withAddedOrUpdated(keyspace.withUpdatedUserType(apply(keyspace, type)));
    }

    abstract UserType apply(KeyspaceMetadata keyspace, UserType type);

    @Override
    public AuditLogContext getAuditLogContext()
    {
        return new AuditLogContext(AuditLogEntryType.ALTER_TYPE, keyspaceName, typeName);
    }

    public String toString()
    {
        return String.format(&quot;%s (%s, %s)&quot;, getClass().getSimpleName(), keyspaceName, typeName);
    }

    private static final class AddField extends AlterTypeStatement
    {
        private final FieldIdentifier fieldName;
        private final CQL3Type.Raw type;
        private final boolean ifFieldNotExists;

        private ClientState state;

        private AddField(String keyspaceName, String typeName, FieldIdentifier fieldName, CQL3Type.Raw type, boolean ifExists, boolean ifFieldNotExists)
        {
            super(keyspaceName, typeName, ifExists);
            this.fieldName = fieldName;
            this.ifFieldNotExists = ifFieldNotExists;
            this.type = type;
        }

        @Override
        public void validate(ClientState state)
        {
            super.validate(state);

            // save the query state to use it for guardrails validation in #apply
            this.state = state;
        }

        UserType apply(KeyspaceMetadata keyspace, UserType userType)
        {
            if (type.isCounter())
                throw ire(&quot;A user type cannot contain counters&quot;);

            if (type.isUDT() &amp;&amp; !type.isFrozen())
                throw ire(&quot;A user type cannot contain non-frozen UDTs&quot;);

            if (userType.fieldPosition(fieldName) &gt;= 0)
            {
                if (!ifFieldNotExists)
                    throw ire(&quot;Cannot add field %s to type %s: a field with name %s already exists&quot;, fieldName, userType.getCqlTypeName(), fieldName);
                return userType;
            }

            AbstractType&lt;?&gt; fieldType = type.prepare(keyspaceName, keyspace.types).getType();
            if (fieldType.referencesUserType(userType.name))
                throw ire(&quot;Cannot add new field %s of type %s to user type %s as it would create a circular reference&quot;, fieldName, type, userType.getCqlTypeName());

            Collection&lt;TableMetadata&gt; tablesWithTypeInPartitionKey = findTablesReferencingTypeInPartitionKey(keyspace, userType);
            if (!tablesWithTypeInPartitionKey.isEmpty())
            {
                throw ire(&quot;Cannot add new field %s of type %s to user type %s as the type is being used in partition key by the following tables: %s&quot;,
                          fieldName, type, userType.getCqlTypeName(),
                          String.join(&quot;, &quot;, transform(tablesWithTypeInPartitionKey, TableMetadata::toString)));
            }

            Guardrails.fieldsPerUDT.guard(userType.size() + 1, userType.getNameAsString(), false, state);
            type.validate(state, &quot;Field &quot; + fieldName);

            List&lt;FieldIdentifier&gt; fieldNames = new ArrayList&lt;&gt;(userType.fieldNames()); fieldNames.add(fieldName);
            List&lt;AbstractType&lt;?&gt;&gt; fieldTypes = new ArrayList&lt;&gt;(userType.fieldTypes()); fieldTypes.add(fieldType);

            return new UserType(keyspaceName, userType.name, fieldNames, fieldTypes, true);
        }

        private static Collection&lt;TableMetadata&gt; findTablesReferencingTypeInPartitionKey(KeyspaceMetadata keyspace, UserType userType)
        {
            Collection&lt;TableMetadata&gt; tables = new ArrayList&lt;&gt;();
            filter(keyspace.tablesAndViews(),
                   table -&gt; any(table.partitionKeyColumns(), column -&gt; column.type.referencesUserType(userType.name)))
                  .forEach(tables::add);
            return tables;
        }
    }

    private static final class RenameFields extends AlterTypeStatement
    {
        private final Map&lt;FieldIdentifier, FieldIdentifier&gt; renamedFields;
        private final boolean ifFieldExists;

        private RenameFields(String keyspaceName, String typeName, Map&lt;FieldIdentifier, FieldIdentifier&gt; renamedFields, boolean ifExists, boolean ifFieldExists)
        {
            super(keyspaceName, typeName, ifExists);
            this.ifFieldExists = ifFieldExists;
            this.renamedFields = renamedFields;
        }

        UserType apply(KeyspaceMetadata keyspace, UserType userType)
        {
            List&lt;String&gt; dependentAggregates =
                keyspace.userFunctions
                        .udas()
                        .filter(uda -&gt; null != uda.initialCondition() &amp;&amp; uda.stateType().referencesUserType(userType.name))
                        .map(uda -&gt; uda.name().toString())
                        .collect(toList());

            if (!dependentAggregates.isEmpty())
            {
                throw ire(&quot;Cannot alter user type %s as it is still used in INITCOND by aggregates %s&quot;,
                          userType.getCqlTypeName(),
                          join(&quot;, &quot;, dependentAggregates));
            }

            List&lt;FieldIdentifier&gt; fieldNames = new ArrayList&lt;&gt;(userType.fieldNames());

            renamedFields.forEach((oldName, newName) -&gt;
            {
                int idx = userType.fieldPosition(oldName);
                if (idx &lt; 0)
                {
                    if (!ifFieldExists)
                        throw ire(&quot;Unkown field %s in user type %s&quot;, oldName, userType.getCqlTypeName());
                    return;
                }
                fieldNames.set(idx, newName);
            });

            fieldNames.forEach(name -&gt;
            {
                if (fieldNames.stream().filter(isEqual(name)).count() &gt; 1)
                    throw ire(&quot;Duplicate field name %s in type %s&quot;, name, keyspaceName, userType.getCqlTypeName());
            });

            return new UserType(keyspaceName, userType.name, fieldNames, userType.fieldTypes(), true);
        }
    }

    private static final class AlterField extends AlterTypeStatement
    {
        private AlterField(String keyspaceName, String typeName, boolean ifExists)
        {
            super(keyspaceName, typeName, ifExists);
        }

        UserType apply(KeyspaceMetadata keyspace, UserType userType)
        {
            throw ire(&quot;Altering field types is no longer supported&quot;);
        }
    }

    public static final class Raw extends CQLStatement.Raw
    {
        private enum Kind
        {
            ADD_FIELD, RENAME_FIELDS, ALTER_FIELD
        }

        private final UTName name;
        private final boolean ifExists;
        private boolean ifFieldExists;
        private boolean ifFieldNotExists;

        private Kind kind;

        // ADD
        private FieldIdentifier newFieldName;
        private CQL3Type.Raw newFieldType;

        // RENAME
<span class="nc" id="L258">        private final Map&lt;FieldIdentifier, FieldIdentifier&gt; renamedFields = new HashMap&lt;&gt;();</span>

        public Raw(UTName name, boolean ifExists)
<span class="nc" id="L261">        {</span>
<span class="nc" id="L262">            this.ifExists = ifExists;</span>
<span class="nc" id="L263">            this.name = name;</span>
<span class="nc" id="L264">        }</span>

        public AlterTypeStatement prepare(ClientState state)
        {
<span class="nc bnc" id="L268" title="All 2 branches missed.">            String keyspaceName = name.hasKeyspace() ? name.getKeyspace() : state.getKeyspace();</span>
<span class="nc" id="L269">            String typeName = name.getStringTypeName();</span>

<span class="nc bnc" id="L271" title="All 4 branches missed.">            switch (kind)</span>
            {
<span class="nc" id="L273">                case     ADD_FIELD: return new AddField(keyspaceName, typeName, newFieldName, newFieldType, ifExists, ifFieldNotExists);</span>
<span class="nc" id="L274">                case RENAME_FIELDS: return new RenameFields(keyspaceName, typeName, renamedFields, ifExists, ifFieldExists);</span>
<span class="nc" id="L275">                case   ALTER_FIELD: return new AlterField(keyspaceName, typeName, ifExists);</span>
            }

<span class="nc" id="L278">            throw new AssertionError();</span>
        }

        public void add(FieldIdentifier name, CQL3Type.Raw type)
        {
<span class="nc" id="L283">            kind = Kind.ADD_FIELD;</span>
<span class="nc" id="L284">            newFieldName = name;</span>
<span class="nc" id="L285">            newFieldType = type;</span>
<span class="nc" id="L286">        }</span>

        public void ifFieldNotExists(boolean ifNotExists)
        {
<span class="nc" id="L290">            this.ifFieldNotExists = ifNotExists;</span>
<span class="nc" id="L291">        }</span>

        public void rename(FieldIdentifier from, FieldIdentifier to)
        {
<span class="nc" id="L295">            kind = Kind.RENAME_FIELDS;</span>
<span class="nc" id="L296">            renamedFields.put(from, to);</span>
<span class="nc" id="L297">        }</span>

        public void ifFieldExists(boolean ifExists)
        {
<span class="nc" id="L301">            this.ifFieldExists = ifExists;</span>
<span class="nc" id="L302">        }</span>

        public void alter(FieldIdentifier name, CQL3Type.Raw type)
        {
<span class="nc" id="L306">            kind = Kind.ALTER_FIELD;</span>
<span class="nc" id="L307">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>