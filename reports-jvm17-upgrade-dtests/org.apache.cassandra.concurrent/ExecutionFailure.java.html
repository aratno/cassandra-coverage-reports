<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExecutionFailure.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.concurrent</a> &gt; <span class="el_source">ExecutionFailure.java</span></div><h1>ExecutionFailure.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.concurrent;

import java.util.concurrent.Callable;
import java.util.concurrent.Future;

import org.apache.cassandra.concurrent.DebuggableTask.RunnableDebuggableTask;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.db.compaction.CompactionInterruptedException;
import org.apache.cassandra.utils.Closeable;
import org.apache.cassandra.utils.JVMStabilityInspector;
import org.apache.cassandra.utils.WithResources;

/**
 * Standardised handling of failures during execution - mostly this involves invoking a thread's
 * {@link java.lang.Thread.UncaughtExceptionHandler} or
 * {@link JVMStabilityInspector#uncaughtException(Thread, Throwable)},
 * with special handling for {@link CompactionInterruptedException}.
 * This class also provides wrappers for {@link WithResources} with {@link Runnable} and {@link Callable}.
 */
<span class="nc" id="L40">public class ExecutionFailure</span>
{
<span class="fc" id="L42">    private static final Logger logger = LoggerFactory.getLogger(ExecutionFailure.class);</span>

    /**
     * Invoke the relevant {@link java.lang.Thread.UncaughtExceptionHandler},
     * ignoring (except for logging) any {@link CompactionInterruptedException}
     */
    public static void handle(Throwable t)
    {
        try
        {
<span class="pc bpc" id="L52" title="1 of 2 branches missed.">            if (t instanceof CompactionInterruptedException)</span>
            {
                // TODO: should we check to see there aren't nested CompactionInterruptedException?
<span class="nc" id="L55">                logger.info(t.getMessage());</span>
<span class="nc bnc" id="L56" title="All 4 branches missed.">                if (t.getSuppressed() != null &amp;&amp; t.getSuppressed().length &gt; 0)</span>
<span class="nc" id="L57">                    logger.warn(&quot;Interruption of compaction encountered exceptions:&quot;, t);</span>
                else
<span class="nc" id="L59">                    logger.trace(&quot;Full interruption stack trace:&quot;, t);</span>
            }
            else
            {
<span class="fc" id="L63">                Thread thread = Thread.currentThread();</span>
<span class="fc" id="L64">                Thread.UncaughtExceptionHandler handler = thread.getUncaughtExceptionHandler();</span>
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">                if (handler == null)</span>
<span class="nc" id="L66">                    handler = JVMStabilityInspector::uncaughtException;</span>
<span class="fc" id="L67">                handler.uncaughtException(thread, t);</span>
            }
        }
<span class="nc" id="L70">        catch (Throwable shouldNeverHappen)</span>
        {
<span class="nc" id="L72">            logger.error(&quot;Unexpected error while handling unexpected error&quot;, shouldNeverHappen);</span>
<span class="fc" id="L73">        }</span>
<span class="fc" id="L74">    }</span>

    /**
     * See {@link #propagating(WithResources, Runnable)}
     */
    static Runnable propagating(Runnable wrap)
    {
<span class="fc bfc" id="L81" title="All 2 branches covered.">        return wrap instanceof FutureTask&lt;?&gt; ? wrap : propagating(WithResources.none(), wrap);</span>
    }

    /**
     * In the case of plain executions, we want to handle exceptions without the full {@link FutureTask} machinery
     * while still propagating the exception to the encapsulating Future
     */
    static Runnable propagating(WithResources withResources, Runnable wrap)
    {
<span class="fc" id="L90">        return enforceOptions(withResources, wrap, true);</span>
    }

    /**
     * See {@link #suppressing(WithResources, Runnable)}
     */
    static Runnable suppressing(Runnable wrap)
    {
<span class="fc bfc" id="L98" title="All 2 branches covered.">        return wrap instanceof FutureTask&lt;?&gt; ? wrap : suppressing(WithResources.none(), wrap);</span>
    }

    /**
     * In the case of scheduled periodic tasks, we don't want exceptions propagating to cancel the recurring execution.
     */
    static Runnable suppressing(WithResources withResources, Runnable wrap)
    {
<span class="fc" id="L106">        return enforceOptions(withResources, wrap, false);</span>
    }

    /**
     * @see #suppressing(WithResources, Runnable)
     */
    static RunnableDebuggableTask suppressingDebuggable(WithResources withResources, RunnableDebuggableTask debuggable)
    {
<span class="fc" id="L114">        return enforceOptionsDebuggable(withResources, debuggable, false);</span>
    }

    /**
     * Encapsulate the execution, propagating or suppressing any exceptions as requested.
     *
     * note that if {@code wrap} is a {@link java.util.concurrent.Future} its exceptions may not be captured,
     * however the codebase should be using our internal {@link Future} variants which handle exceptions in the
     * desired way.
     */
    private static Runnable enforceOptions(WithResources withResources, Runnable wrap, boolean propagate)
    {
<span class="fc" id="L126">        return new Runnable()</span>
<span class="fc" id="L127">        {</span>
            @Override
            public void run()
            {
<span class="fc" id="L131">                try (@SuppressWarnings(&quot;unused&quot;) Closeable close = withResources.get())</span>
                {
<span class="fc" id="L133">                    wrap.run();</span>
                }
<span class="fc" id="L135">                catch (Throwable t)</span>
                {
<span class="fc" id="L137">                    handle(t);</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">                    if (propagate)</span>
<span class="fc" id="L139">                        throw t;</span>
<span class="fc" id="L140">                }</span>
<span class="fc" id="L141">            }</span>

            @Override
            public String toString()
            {
<span class="nc" id="L146">                return wrap.toString();</span>
            }
        };
    }

    /**
     * @see #enforceOptions(WithResources, Runnable, boolean)
     */
    private static RunnableDebuggableTask enforceOptionsDebuggable(WithResources withResources, RunnableDebuggableTask debuggable, boolean propagate)
    {
<span class="fc" id="L156">        return new RunnableDebuggableTask()</span>
<span class="fc" id="L157">        {</span>
            @Override
            public void run()
            {
<span class="fc" id="L161">                try (@SuppressWarnings(&quot;unused&quot;) Closeable close = withResources.get())</span>
                {
<span class="fc" id="L163">                    debuggable.run();</span>
                }
<span class="nc" id="L165">                catch (Throwable t)</span>
                {
<span class="nc" id="L167">                    handle(t);</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">                    if (propagate)</span>
<span class="nc" id="L169">                        throw t;</span>
<span class="fc" id="L170">                }</span>
<span class="fc" id="L171">            }</span>

            @Override
            public String toString()
            {
<span class="nc" id="L176">                return debuggable.toString();</span>
            }

            @Override
            public long creationTimeNanos()
            {
<span class="nc" id="L182">                return debuggable.creationTimeNanos();</span>
            }

            @Override
            public long startTimeNanos()
            {
<span class="nc" id="L188">                return debuggable.startTimeNanos();</span>
            }

            @Override
            public String description()
            {
<span class="nc" id="L194">                return debuggable.description();</span>
            }
        };
    }

    /**
     * See {@link #enforceOptions(WithResources, Callable)}
     */
    static &lt;V&gt; Callable&lt;V&gt; propagating(Callable&lt;V&gt; wrap)
    {
<span class="fc" id="L204">        return enforceOptions(WithResources.none(), wrap);</span>
    }

    /**
     * In the case of non-recurring scheduled tasks, we want to handle exceptions without the full {@link FutureTask}
     * machinery, while still propagating the exception to the encapsulating Future
     */
    static &lt;V&gt; Callable&lt;V&gt; enforceOptions(WithResources withResources, Callable&lt;V&gt; wrap)
    {
<span class="fc" id="L213">        return new Callable&lt;V&gt;()</span>
<span class="fc" id="L214">        {</span>
            @Override
            public V call() throws Exception
            {
<span class="fc" id="L218">                try (@SuppressWarnings(&quot;unused&quot;) Closeable close = withResources.get())</span>
                {
<span class="fc" id="L220">                    return wrap.call();</span>
                }
<span class="nc" id="L222">                catch (Throwable t)</span>
                {
<span class="nc" id="L224">                    handle(t);</span>
<span class="nc" id="L225">                    throw t;</span>
                }
            }

            @Override
            public String toString()
            {
<span class="nc" id="L232">                return wrap.toString();</span>
            }
        };
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>