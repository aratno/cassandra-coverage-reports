<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Types.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.schema</a> &gt; <span class="el_source">Types.java</span></div><h1>Types.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.schema;

import java.nio.ByteBuffer;
import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import javax.annotation.Nullable;

import com.google.common.collect.*;

import org.apache.cassandra.cql3.FieldIdentifier;
import org.apache.cassandra.cql3.CQL3Type;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.marshal.UserType;
import org.apache.cassandra.exceptions.ConfigurationException;

import static java.lang.String.format;
import static java.util.stream.Collectors.toList;

import static com.google.common.collect.Iterables.any;
import static com.google.common.collect.Iterables.transform;

import static org.apache.cassandra.utils.ByteBufferUtil.bytes;

/**
 * An immutable container for a keyspace's UDTs.
 */
public final class Types implements Iterable&lt;UserType&gt;
{
<span class="fc" id="L49">    private static final Types NONE = new Types(ImmutableMap.of());</span>

    private final Map&lt;ByteBuffer, UserType&gt; types;

    private Types(Builder builder)
<span class="nc" id="L54">    {</span>
<span class="nc" id="L55">        types = builder.types.build();</span>
<span class="nc" id="L56">    }</span>

    /*
     * For use in RawBuilder::build only.
     */
    private Types(Map&lt;ByteBuffer, UserType&gt; types)
<span class="fc" id="L62">    {</span>
<span class="fc" id="L63">        this.types = types;</span>
<span class="fc" id="L64">    }</span>

    public static Builder builder()
    {
<span class="nc" id="L68">        return new Builder();</span>
    }

    public static RawBuilder rawBuilder(String keyspace)
    {
<span class="fc" id="L73">        return new RawBuilder(keyspace);</span>
    }

    public static Types none()
    {
<span class="fc" id="L78">        return NONE;</span>
    }

    public static Types of(UserType... types)
    {
<span class="nc" id="L83">        return builder().add(types).build();</span>
    }

    public Iterator&lt;UserType&gt; iterator()
    {
<span class="fc" id="L88">        return types.values().iterator();</span>
    }

    public Stream&lt;UserType&gt; stream()
    {
<span class="nc" id="L93">        return StreamSupport.stream(spliterator(), false);</span>
    }

    /**
     * Returns a stream of user types sorted by dependencies
     * @return a stream of user types sorted by dependencies
     */
    public Stream&lt;UserType&gt; sortedStream()
    {
<span class="nc" id="L102">        Set&lt;ByteBuffer&gt; sorted = new LinkedHashSet&lt;&gt;();</span>
<span class="nc" id="L103">        types.values().forEach(t -&gt; addUserTypes(t, sorted));</span>
<span class="nc" id="L104">        return sorted.stream().map(n -&gt; types.get(n));</span>
    }

    public Iterable&lt;UserType&gt; referencingUserType(ByteBuffer name)
    {
<span class="nc bnc" id="L109" title="All 4 branches missed.">        return Iterables.filter(types.values(), t -&gt; t.referencesUserType(name) &amp;&amp; !t.name.equals(name));</span>
    }

    public boolean isEmpty()
    {
<span class="nc" id="L114">        return types.isEmpty();</span>
    }

    /**
     * Get the type with the specified name
     *
     * @param name a non-qualified type name
     * @return an empty {@link Optional} if the type name is not found; a non-empty optional of {@link UserType} otherwise
     */
    public Optional&lt;UserType&gt; get(ByteBuffer name)
    {
<span class="nc" id="L125">        return Optional.ofNullable(types.get(name));</span>
    }

    /**
     * Get the type with the specified name
     *
     * @param name a non-qualified type name
     * @return null if the type name is not found; the found {@link UserType} otherwise
     */
    @Nullable
    public UserType getNullable(ByteBuffer name)
    {
<span class="fc" id="L137">        return types.get(name);</span>
    }

    boolean containsType(ByteBuffer name)
    {
<span class="nc" id="L142">        return types.containsKey(name);</span>
    }

    Types filter(Predicate&lt;UserType&gt; predicate)
    {
<span class="nc" id="L147">        Builder builder = builder();</span>
<span class="nc" id="L148">        types.values().stream().filter(predicate).forEach(builder::add);</span>
<span class="nc" id="L149">        return builder.build();</span>
    }

    /**
     * Create a Types instance with the provided type added
     */
    public Types with(UserType type)
    {
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (get(type.name).isPresent())</span>
<span class="nc" id="L158">            throw new IllegalStateException(format(&quot;Type %s already exists&quot;, type.name));</span>

<span class="nc" id="L160">        return builder().add(this).add(type).build();</span>
    }

    /**
     * Creates a Types instance with the type with the provided name removed
     */
    public Types without(ByteBuffer name)
    {
<span class="nc" id="L168">        UserType type =</span>
<span class="nc" id="L169">            get(name).orElseThrow(() -&gt; new IllegalStateException(format(&quot;Type %s doesn't exists&quot;, name)));</span>

<span class="nc" id="L171">        return without(type);</span>
    }

    public Types without(UserType type)
    {
<span class="nc bnc" id="L176" title="All 2 branches missed.">        return filter(t -&gt; t != type);</span>
    }

    public Types withUpdatedUserType(UserType udt)
    {
<span class="nc bnc" id="L181" title="All 2 branches missed.">        return any(this, t -&gt; t.referencesUserType(udt.name))</span>
<span class="nc" id="L182">             ? builder().add(transform(this, t -&gt; t.withUpdatedUserType(udt))).build()</span>
<span class="nc" id="L183">             : this;</span>
    }

    @Override
    public boolean equals(Object o)
    {
<span class="nc bnc" id="L189" title="All 2 branches missed.">        if (this == o)</span>
<span class="nc" id="L190">            return true;</span>

<span class="nc bnc" id="L192" title="All 2 branches missed.">        if (!(o instanceof Types))</span>
<span class="nc" id="L193">            return false;</span>

<span class="nc" id="L195">        Types other = (Types) o;</span>

<span class="nc bnc" id="L197" title="All 2 branches missed.">        if (types.size() != other.types.size())</span>
<span class="nc" id="L198">            return false;</span>

<span class="nc" id="L200">        Iterator&lt;Map.Entry&lt;ByteBuffer, UserType&gt;&gt; thisIter = this.types.entrySet().iterator();</span>
<span class="nc" id="L201">        Iterator&lt;Map.Entry&lt;ByteBuffer, UserType&gt;&gt; otherIter = other.types.entrySet().iterator();</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">        while (thisIter.hasNext())</span>
        {
<span class="nc" id="L204">            Map.Entry&lt;ByteBuffer, UserType&gt; thisNext = thisIter.next();</span>
<span class="nc" id="L205">            Map.Entry&lt;ByteBuffer, UserType&gt; otherNext = otherIter.next();</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">            if (!thisNext.getKey().equals(otherNext.getKey()))</span>
<span class="nc" id="L207">                return false;</span>

<span class="nc bnc" id="L209" title="All 2 branches missed.">            if (!thisNext.getValue().equals(otherNext.getValue()))</span>
<span class="nc" id="L210">                return false;</span>
<span class="nc" id="L211">        }</span>
<span class="nc" id="L212">        return true;</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L218">        return types.hashCode();</span>
    }

    @Override
    public String toString()
    {
<span class="fc" id="L224">        return types.values().toString();</span>
    }

    /**
     * Sorts the types by dependencies.
     *
     * @param types the types to sort
     * @return the types sorted by dependencies and names
     */
    private static Set&lt;ByteBuffer&gt; sortByDependencies(Collection&lt;UserType&gt; types)
    {
<span class="nc" id="L235">        Set&lt;ByteBuffer&gt; sorted = new LinkedHashSet&lt;&gt;();</span>
<span class="nc" id="L236">        types.stream().forEach(t -&gt; addUserTypes(t, sorted));</span>
<span class="nc" id="L237">        return sorted;</span>
    }

    /**
     * Find all user types used by the specified type and add them to the set.
     *
     * @param type the type to check for user types.
     * @param types the set of UDT names to which to add new user types found in {@code type}. Note that the
     * insertion ordering is important and ensures that if a user type A uses another user type B, then B will appear
     * before A in iteration order.
     */
    private static void addUserTypes(AbstractType&lt;?&gt; type, Set&lt;ByteBuffer&gt; types)
    {
        // Reach into subtypes first, so that if the type is a UDT, it's dependencies are recreated first.
<span class="nc" id="L251">        type.subTypes().forEach(t -&gt; addUserTypes(t, types));</span>

<span class="nc bnc" id="L253" title="All 2 branches missed.">        if (type.isUDT())</span>
<span class="nc" id="L254">            types.add(((UserType) type).name);</span>
<span class="nc" id="L255">    }</span>

    public static final class Builder
    {
        final ImmutableSortedMap.Builder&lt;ByteBuffer, UserType&gt; types = ImmutableSortedMap.naturalOrder();

        private Builder()
        {
        }

        public Types build()
        {
            return new Types(this);
        }

        public Builder add(UserType type)
        {
            assert type.isMultiCell();
            types.put(type.name, type);
            return this;
        }

        public Builder add(UserType... types)
        {
            for (UserType type : types)
                add(type);
            return this;
        }

        public Builder add(Iterable&lt;UserType&gt; types)
        {
            types.forEach(this::add);
            return this;
        }
    }

    public static final class RawBuilder
    {
        final String keyspace;
        final List&lt;RawUDT&gt; definitions;

        private RawBuilder(String keyspace)
<span class="fc" id="L297">        {</span>
<span class="fc" id="L298">            this.keyspace = keyspace;</span>
<span class="fc" id="L299">            this.definitions = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L300">        }</span>

        /**
         * Build a Types instance from Raw definitions.
         *
         * Constructs a DAG of graph dependencies and resolves them 1 by 1 in topological order.
         */
        public Types build()
        {
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">            if (definitions.isEmpty())</span>
<span class="fc" id="L310">                return Types.none();</span>

            /*
             * build a DAG of UDT dependencies
             */
<span class="nc" id="L315">            Map&lt;RawUDT, Integer&gt; vertices = Maps.newHashMapWithExpectedSize(definitions.size()); // map values are numbers of referenced types</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">            for (RawUDT udt : definitions)</span>
<span class="nc" id="L317">                vertices.put(udt, 0);</span>

<span class="nc" id="L319">            Multimap&lt;RawUDT, RawUDT&gt; adjacencyList = HashMultimap.create();</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">            for (RawUDT udt1 : definitions)</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">                for (RawUDT udt2 : definitions)</span>
<span class="nc bnc" id="L322" title="All 4 branches missed.">                    if (udt1 != udt2 &amp;&amp; udt1.referencesUserType(udt2))</span>
<span class="nc" id="L323">                        adjacencyList.put(udt2, udt1);</span>

            /*
             * resolve dependencies in topological order, using Kahn's algorithm
             */
<span class="nc" id="L328">            adjacencyList.values().forEach(vertex -&gt; vertices.put(vertex, vertices.get(vertex) + 1));</span>

<span class="nc" id="L330">            Queue&lt;RawUDT&gt; resolvableTypes = new LinkedList&lt;&gt;(); // UDTs with 0 dependencies</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">            for (Map.Entry&lt;RawUDT, Integer&gt; entry : vertices.entrySet())</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">                if (entry.getValue() == 0)</span>
<span class="nc" id="L333">                    resolvableTypes.add(entry.getKey());</span>

<span class="nc" id="L335">            Types types = new Types(new HashMap&lt;&gt;());</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">            while (!resolvableTypes.isEmpty())</span>
            {
<span class="nc" id="L338">                RawUDT vertex = resolvableTypes.remove();</span>

<span class="nc bnc" id="L340" title="All 2 branches missed.">                for (RawUDT dependentType : adjacencyList.get(vertex))</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">                    if (vertices.replace(dependentType, vertices.get(dependentType) - 1) == 1)</span>
<span class="nc" id="L342">                        resolvableTypes.add(dependentType);</span>

<span class="nc" id="L344">                UserType udt = vertex.prepare(keyspace, types);</span>
<span class="nc" id="L345">                types.types.put(udt.name, udt);</span>
<span class="nc" id="L346">            }</span>

<span class="nc bnc" id="L348" title="All 2 branches missed.">            if (types.types.size() != definitions.size())</span>
<span class="nc" id="L349">                throw new ConfigurationException(format(&quot;Cannot resolve UDTs for keyspace %s: some types are missing&quot;, keyspace));</span>

            /*
             * return an immutable copy
             */
<span class="nc" id="L354">            return Types.builder().add(types).build();</span>
        }

        public void add(String name, List&lt;String&gt; fieldNames, List&lt;String&gt; fieldTypes)
        {
<span class="nc" id="L359">            List&lt;CQL3Type.Raw&gt; rawFieldTypes =</span>
<span class="nc" id="L360">                fieldTypes.stream()</span>
<span class="nc" id="L361">                          .map(CQLTypeParser::parseRaw)</span>
<span class="nc" id="L362">                          .collect(toList());</span>

<span class="nc" id="L364">            definitions.add(new RawUDT(name, fieldNames, rawFieldTypes));</span>
<span class="nc" id="L365">        }</span>

        private static final class RawUDT
        {
            final String name;
            final List&lt;String&gt; fieldNames;
            final List&lt;CQL3Type.Raw&gt; fieldTypes;

            RawUDT(String name, List&lt;String&gt; fieldNames, List&lt;CQL3Type.Raw&gt; fieldTypes)
            {
                this.name = name;
                this.fieldNames = fieldNames;
                this.fieldTypes = fieldTypes;
            }

            boolean referencesUserType(RawUDT other)
            {
                return fieldTypes.stream().anyMatch(t -&gt; t.referencesUserType(other.name));
            }

            UserType prepare(String keyspace, Types types)
            {
                List&lt;FieldIdentifier&gt; preparedFieldNames =
                    fieldNames.stream()
                              .map(FieldIdentifier::forInternalString)
                              .collect(toList());

                List&lt;AbstractType&lt;?&gt;&gt; preparedFieldTypes =
                    fieldTypes.stream()
                              .map(t -&gt; t.prepareInternal(keyspace, types).getType())
                              .collect(toList());

                return new UserType(keyspace, bytes(name), preparedFieldNames, preparedFieldTypes, true);
            }

            @Override
            public int hashCode()
            {
                return name.hashCode();
            }

            @Override
            public boolean equals(Object other)
            {
                return name.equals(((RawUDT) other).name);
            }
        }
    }

    static TypesDiff diff(Types before, Types after)
    {
<span class="fc" id="L416">        return TypesDiff.diff(before, after);</span>
    }

    static final class TypesDiff extends Diff&lt;Types, UserType&gt;
    {
<span class="fc" id="L421">        private static final TypesDiff NONE = new TypesDiff(Types.none(), Types.none(), ImmutableList.of());</span>

        private TypesDiff(Types created, Types dropped, ImmutableCollection&lt;Altered&lt;UserType&gt;&gt; altered)
        {
<span class="fc" id="L425">            super(created, dropped, altered);</span>
<span class="fc" id="L426">        }</span>

        private static TypesDiff diff(Types before, Types after)
        {
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">            if (before == after)</span>
<span class="fc" id="L431">                return NONE;</span>

<span class="nc bnc" id="L433" title="All 2 branches missed.">            Types created = after.filter(t -&gt; !before.containsType(t.name));</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">            Types dropped = before.filter(t -&gt; !after.containsType(t.name));</span>

<span class="nc" id="L436">            ImmutableList.Builder&lt;Altered&lt;UserType&gt;&gt; altered = ImmutableList.builder();</span>
<span class="nc" id="L437">            before.forEach(typeBefore -&gt;</span>
            {
<span class="nc" id="L439">                UserType typeAfter = after.getNullable(typeBefore.name);</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">                if (null != typeAfter)</span>
<span class="nc" id="L441">                    typeBefore.compare(typeAfter).ifPresent(kind -&gt; altered.add(new Altered&lt;&gt;(typeBefore, typeAfter, kind)));</span>
<span class="nc" id="L442">            });</span>

<span class="nc" id="L444">            return new TypesDiff(created, dropped, altered.build());</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>