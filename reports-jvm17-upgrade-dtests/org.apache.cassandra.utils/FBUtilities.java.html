<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FBUtilities.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.utils</a> &gt; <span class="el_source">FBUtilities.java</span></div><h1>FBUtilities.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.utils;

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.lang.reflect.Field;
import java.math.BigInteger;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.net.URL;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NavigableSet;
import java.util.Optional;
import java.util.Properties;
import java.util.TreeSet;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.CRC32;
import java.util.zip.Checksum;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableList;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.audit.IAuditLogger;
import org.apache.cassandra.auth.AllowAllNetworkAuthorizer;
import org.apache.cassandra.auth.IAuthenticator;
import org.apache.cassandra.auth.IAuthorizer;
import org.apache.cassandra.auth.INetworkAuthorizer;
import org.apache.cassandra.auth.IRoleManager;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.dht.IPartitioner;
import org.apache.cassandra.dht.LocalPartitioner;
import org.apache.cassandra.dht.Range;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.io.IVersionedSerializer;
import org.apache.cassandra.io.sstable.Descriptor;
import org.apache.cassandra.io.sstable.format.StatsComponent;
import org.apache.cassandra.io.sstable.metadata.MetadataType;
import org.apache.cassandra.io.util.DataOutputBuffer;
import org.apache.cassandra.io.util.DataOutputBufferFixed;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.security.AbstractCryptoProvider;
import org.apache.cassandra.security.ISslContextFactory;
import org.apache.cassandra.utils.concurrent.FutureCombiner;
import org.apache.cassandra.utils.concurrent.UncheckedInterruptedException;
import org.objectweb.asm.Opcodes;

import static org.apache.cassandra.config.CassandraRelevantProperties.CASSANDRA_AVAILABLE_PROCESSORS;
import static org.apache.cassandra.config.CassandraRelevantProperties.GIT_SHA;
import static org.apache.cassandra.config.CassandraRelevantProperties.LINE_SEPARATOR;
import static org.apache.cassandra.config.CassandraRelevantProperties.OS_NAME;
import static org.apache.cassandra.config.CassandraRelevantProperties.RELEASE_VERSION;
import static org.apache.cassandra.config.CassandraRelevantProperties.TRIGGERS_DIR;
import static org.apache.cassandra.config.CassandraRelevantProperties.USER_HOME;
import static org.apache.cassandra.utils.Clock.Global.currentTimeMillis;
import static org.apache.cassandra.utils.Clock.Global.nanoTime;

<span class="nc" id="L106">public class FBUtilities</span>
{
    static
    {
<span class="fc" id="L110">        preventIllegalAccessWarnings();</span>
    }

<span class="fc" id="L113">    private static final Logger logger = LoggerFactory.getLogger(FBUtilities.class);</span>
    public static final String UNKNOWN_RELEASE_VERSION = &quot;Unknown&quot;;
    public static final String UNKNOWN_GIT_SHA = &quot;Unknown&quot;;

<span class="fc" id="L117">    public static final BigInteger TWO = new BigInteger(&quot;2&quot;);</span>
    private static final String DEFAULT_TRIGGER_DIR = &quot;triggers&quot;;

<span class="fc" id="L120">    private static final String OPERATING_SYSTEM = OS_NAME.getString().toLowerCase();</span>
<span class="fc" id="L121">    public static final boolean isLinux = OPERATING_SYSTEM.contains(&quot;linux&quot;);</span>

    private static volatile InetAddress localInetAddress;
    private static volatile InetAddress broadcastInetAddress;
    private static volatile InetAddress broadcastNativeAddress;
    private static volatile InetAddressAndPort broadcastNativeAddressAndPort;
    private static volatile InetAddressAndPort broadcastInetAddressAndPort;
    private static volatile InetAddressAndPort localInetAddressAndPort;

    private static volatile String previousReleaseVersionString;

<span class="fc" id="L132">    private static int availableProcessors = CASSANDRA_AVAILABLE_PROCESSORS.getInt(DatabaseDescriptor.getAvailableProcessors());</span>

    public static void setAvailableProcessors(int value)
    {
<span class="nc" id="L136">        availableProcessors = value;</span>
<span class="nc" id="L137">    }</span>

    public static int getAvailableProcessors()
    {
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">        if (availableProcessors &gt; 0)</span>
<span class="nc" id="L142">            return availableProcessors;</span>
        else
<span class="fc" id="L144">            return Runtime.getRuntime().availableProcessors();</span>
    }

    public static final int MAX_UNSIGNED_SHORT = 0xFFFF;

    public static final int ASM_BYTECODE_VERSION = Opcodes.ASM9;

    public static MessageDigest newMessageDigest(String algorithm)
    {
        try
        {
<span class="fc" id="L155">            return MessageDigest.getInstance(algorithm);</span>
        }
<span class="nc" id="L157">        catch (NoSuchAlgorithmException nsae)</span>
        {
<span class="nc" id="L159">            throw new RuntimeException(&quot;the requested digest algorithm (&quot; + algorithm + &quot;) is not available&quot;, nsae);</span>
        }
    }

    /**
     * Please use getJustBroadcastAddress instead. You need this only when you have to listen/connect. It's also missing
     * the port you should be using. 99% of code doesn't want this.
     */
    public static InetAddress getJustLocalAddress()
    {
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (localInetAddress == null)</span>
        {
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">            if (DatabaseDescriptor.getListenAddress() == null)</span>
            {
                try
                {
<span class="nc" id="L175">                    localInetAddress = InetAddress.getLocalHost();</span>
<span class="nc" id="L176">                    logger.info(&quot;InetAddress.getLocalHost() was used to resolve listen_address to {}, double check this is &quot;</span>
                                + &quot;correct. Please check your node's config and set the listen_address in cassandra.yaml accordingly if applicable.&quot;,
                                localInetAddress);
                }
<span class="nc" id="L180">                catch(UnknownHostException e)</span>
                {
<span class="nc" id="L182">                    logger.info(&quot;InetAddress.getLocalHost() could not resolve the address for the hostname ({}), please &quot;</span>
                                + &quot;check your node's config and set the listen_address in cassandra.yaml. Falling back to {}&quot;,
                                e,
<span class="nc" id="L185">                                InetAddress.getLoopbackAddress());</span>
                    // CASSANDRA-15901 fallback for misconfigured nodes
<span class="nc" id="L187">                    localInetAddress = InetAddress.getLoopbackAddress();</span>
<span class="nc" id="L188">                }</span>
            }
            else
<span class="fc" id="L191">                localInetAddress = DatabaseDescriptor.getListenAddress();</span>
        }
<span class="fc" id="L193">        return localInetAddress;</span>
    }

    /**
     * The address and port to listen on for intra-cluster storage traffic (not client). Use this to get the correct
     * stuff to listen on for intra-cluster communication.
     */
    public static InetAddressAndPort getLocalAddressAndPort()
    {
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (localInetAddressAndPort == null)</span>
        {
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">            if(DatabaseDescriptor.getRawConfig() == null)</span>
            {
<span class="nc" id="L206">                localInetAddressAndPort = InetAddressAndPort.getByAddress(getJustLocalAddress());</span>
            }
            else
            {
<span class="fc" id="L210">                localInetAddressAndPort = InetAddressAndPort.getByAddressOverrideDefaults(getJustLocalAddress(),</span>
<span class="fc" id="L211">                                                                                          DatabaseDescriptor.getStoragePort());</span>
            }
        }
<span class="fc" id="L214">        return localInetAddressAndPort;</span>
    }

    /**
     * Retrieve just the broadcast address but not the port. This is almost always the wrong thing to be using because
     * it's ambiguous since you need the address and port to identify a node. You want getBroadcastAddressAndPort
     */
    public static InetAddress getJustBroadcastAddress()
    {
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">        if (broadcastInetAddress == null)</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">            broadcastInetAddress = DatabaseDescriptor.getBroadcastAddress() == null</span>
<span class="nc" id="L225">                                 ? getJustLocalAddress()</span>
<span class="nc" id="L226">                                 : DatabaseDescriptor.getBroadcastAddress();</span>
<span class="fc" id="L227">        return broadcastInetAddress;</span>
    }

    /**
     * Get the broadcast address and port for intra-cluster storage traffic. This the address to advertise that uniquely
     * identifies the node and is reachable from everywhere. This is the one you want unless you are trying to connect
     * to the local address specifically.
     */
    public static InetAddressAndPort getBroadcastAddressAndPort()
    {
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">        if (broadcastInetAddressAndPort == null)</span>
        {
<span class="nc bnc" id="L239" title="All 2 branches missed.">            if(DatabaseDescriptor.getRawConfig() == null)</span>
            {
<span class="nc" id="L241">                broadcastInetAddressAndPort = InetAddressAndPort.getByAddress(getJustBroadcastAddress());</span>
            }
            else
            {
<span class="nc" id="L245">                broadcastInetAddressAndPort = InetAddressAndPort.getByAddressOverrideDefaults(getJustBroadcastAddress(),</span>
<span class="nc" id="L246">                                                                                              DatabaseDescriptor.getStoragePort());</span>
            }
        }
<span class="fc" id="L249">        return broadcastInetAddressAndPort;</span>
    }

    /**
     * &lt;b&gt;THIS IS FOR TESTING ONLY!!&lt;/b&gt;
     */
    public static void setBroadcastInetAddress(InetAddress addr)
    {
<span class="nc" id="L257">        broadcastInetAddress = addr;</span>
<span class="nc" id="L258">        broadcastInetAddressAndPort = InetAddressAndPort.getByAddress(broadcastInetAddress);</span>
<span class="nc" id="L259">    }</span>

    /**
     * &lt;b&gt;THIS IS FOR TESTING ONLY!!&lt;/b&gt;
     */
    public static void setBroadcastInetAddressAndPort(InetAddressAndPort addr)
    {
<span class="fc" id="L266">        broadcastInetAddress = addr.getAddress();</span>
<span class="fc" id="L267">        broadcastInetAddressAndPort = addr;</span>
<span class="fc" id="L268">    }</span>

    /**
     * This returns the address that is bound to for the native protocol for communicating with clients. This is ambiguous
     * because it doesn't include the port and it's almost always the wrong thing to be using you want getBroadcastNativeAddressAndPort
     */
    public static InetAddress getJustBroadcastNativeAddress()
    {
<span class="fc bfc" id="L276" title="All 2 branches covered.">        if (broadcastNativeAddress == null)</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">            broadcastNativeAddress = DatabaseDescriptor.getBroadcastRpcAddress() == null</span>
<span class="nc" id="L278">                                   ? DatabaseDescriptor.getRpcAddress()</span>
<span class="fc" id="L279">                                   : DatabaseDescriptor.getBroadcastRpcAddress();</span>
<span class="fc" id="L280">        return broadcastNativeAddress;</span>
    }

    /**
     * This returns the address that is bound to for the native protocol for communicating with clients. This is almost
     * always what you need to identify a node and how to connect to it as a client.
     */
    public static InetAddressAndPort getBroadcastNativeAddressAndPort()
    {
<span class="fc bfc" id="L289" title="All 2 branches covered.">        if (broadcastNativeAddressAndPort == null)</span>
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">            if(DatabaseDescriptor.getRawConfig() == null)</span>
            {
<span class="nc" id="L292">                broadcastNativeAddressAndPort = InetAddressAndPort.getByAddress(getJustBroadcastNativeAddress());</span>
            }
            else
            {
<span class="fc" id="L296">                broadcastNativeAddressAndPort = InetAddressAndPort.getByAddressOverrideDefaults(getJustBroadcastNativeAddress(),</span>
<span class="fc" id="L297">                                                                                                DatabaseDescriptor.getNativeTransportPort());</span>
            }
<span class="fc" id="L299">        return broadcastNativeAddressAndPort;</span>
    }

    public static String getNetworkInterface(InetAddress localAddress)
    {
        try
        {
<span class="fc bfc" id="L306" title="All 2 branches covered.">            for(NetworkInterface ifc : Collections.list(NetworkInterface.getNetworkInterfaces()))</span>
            {
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">                if(ifc.isUp())</span>
                {
<span class="fc bfc" id="L310" title="All 2 branches covered.">                    for(InetAddress addr : Collections.list(ifc.getInetAddresses()))</span>
                    {
<span class="fc bfc" id="L312" title="All 2 branches covered.">                        if (addr.equals(localAddress))</span>
<span class="fc" id="L313">                            return ifc.getDisplayName();</span>
<span class="fc" id="L314">                    }</span>
                }
<span class="fc" id="L316">            }</span>
        }
<span class="pc" id="L318">        catch (SocketException e) {}</span>
<span class="fc" id="L319">        return null;</span>
    }

    /**
     * Given two bit arrays represented as BigIntegers, containing the given
     * number of significant bits, calculate a midpoint.
     *
     * @param left The left point.
     * @param right The right point.
     * @param sigbits The number of bits in the points that are significant.
     * @return A midpoint that will compare bitwise halfway between the params, and
     * a boolean representing whether a non-zero lsbit remainder was generated.
     */
    public static Pair&lt;BigInteger,Boolean&gt; midpoint(BigInteger left, BigInteger right, int sigbits)
    {
        BigInteger midpoint;
        boolean remainder;
<span class="nc bnc" id="L336" title="All 2 branches missed.">        if (left.compareTo(right) &lt; 0)</span>
        {
<span class="nc" id="L338">            BigInteger sum = left.add(right);</span>
<span class="nc" id="L339">            remainder = sum.testBit(0);</span>
<span class="nc" id="L340">            midpoint = sum.shiftRight(1);</span>
<span class="nc" id="L341">        }</span>
        else
        {
<span class="nc" id="L344">            BigInteger max = TWO.pow(sigbits);</span>
            // wrapping case
<span class="nc" id="L346">            BigInteger distance = max.add(right).subtract(left);</span>
<span class="nc" id="L347">            remainder = distance.testBit(0);</span>
<span class="nc" id="L348">            midpoint = distance.shiftRight(1).add(left).mod(max);</span>
        }
<span class="nc" id="L350">        return Pair.create(midpoint, remainder);</span>
    }

    public static int compareUnsigned(byte[] bytes1, byte[] bytes2, int offset1, int offset2, int len1, int len2)
    {
<span class="nc" id="L355">        return FastByteOperations.compareUnsigned(bytes1, offset1, len1, bytes2, offset2, len2);</span>
    }

    public static int compareUnsigned(byte[] bytes1, byte[] bytes2)
    {
<span class="nc" id="L360">        return compareUnsigned(bytes1, bytes2, 0, 0, bytes1.length, bytes2.length);</span>
    }

    public static void sortSampledKeys(List&lt;DecoratedKey&gt; keys, Range&lt;Token&gt; range)
    {
<span class="nc bnc" id="L365" title="All 2 branches missed.">        if (range.left.compareTo(range.right) &gt;= 0)</span>
        {
            // range wraps.  have to be careful that we sort in the same order as the range to find the right midpoint.
<span class="nc" id="L368">            final Token right = range.right;</span>
<span class="nc" id="L369">            Comparator&lt;DecoratedKey&gt; comparator = new Comparator&lt;DecoratedKey&gt;()</span>
            {
                public int compare(DecoratedKey o1, DecoratedKey o2)
                {
                    if ((right.compareTo(o1.getToken()) &lt; 0 &amp;&amp; right.compareTo(o2.getToken()) &lt; 0)
                        || (right.compareTo(o1.getToken()) &gt; 0 &amp;&amp; right.compareTo(o2.getToken()) &gt; 0))
                    {
                        // both tokens are on the same side of the wrap point
                        return o1.compareTo(o2);
                    }
                    return o2.compareTo(o1);
                }
            };
<span class="nc" id="L382">            Collections.sort(keys, comparator);</span>
<span class="nc" id="L383">        }</span>
        else
        {
            // unwrapped range (left &lt; right).  standard sort is all we need.
<span class="nc" id="L387">            Collections.sort(keys);</span>
        }
<span class="nc" id="L389">    }</span>

    public static String resourceToFile(String filename) throws ConfigurationException
    {
<span class="nc" id="L393">        ClassLoader loader = FBUtilities.class.getClassLoader();</span>
<span class="nc" id="L394">        URL scpurl = loader.getResource(filename);</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">        if (scpurl == null)</span>
<span class="nc" id="L396">            throw new ConfigurationException(&quot;unable to locate &quot; + filename);</span>

<span class="nc" id="L398">        return new File(scpurl.getFile()).absolutePath();</span>
    }

    public static File cassandraTriggerDir()
    {
<span class="fc" id="L403">        File triggerDir = null;</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">        if (TRIGGERS_DIR.getString() != null)</span>
        {
<span class="nc" id="L406">            triggerDir = new File(TRIGGERS_DIR.getString());</span>
        }
        else
        {
<span class="fc" id="L410">            URL confDir = FBUtilities.class.getClassLoader().getResource(DEFAULT_TRIGGER_DIR);</span>
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">            if (confDir != null)</span>
<span class="fc" id="L412">                triggerDir = new File(confDir.getFile());</span>
        }
<span class="pc bpc" id="L414" title="2 of 4 branches missed.">        if (triggerDir == null || !triggerDir.exists())</span>
        {
<span class="fc" id="L416">            logger.warn(&quot;Trigger directory doesn't exist, please create it and try again.&quot;);</span>
<span class="fc" id="L417">            return null;</span>
        }
<span class="nc" id="L419">        return triggerDir;</span>
    }

    public static void setPreviousReleaseVersionString(String previousReleaseVersionString)
    {
<span class="nc" id="L424">        FBUtilities.previousReleaseVersionString = previousReleaseVersionString;</span>
<span class="nc" id="L425">    }</span>

    public static String getPreviousReleaseVersionString()
    {
<span class="fc" id="L429">        return previousReleaseVersionString;</span>
    }

    private static Properties getVersionProperties()
    {
<span class="fc" id="L434">        try (InputStream in = FBUtilities.class.getClassLoader().getResourceAsStream(&quot;org/apache/cassandra/config/version.properties&quot;))</span>
        {
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">            if (in == null)</span>
            {
<span class="nc" id="L438">                return null;</span>
            }
<span class="fc" id="L440">            Properties props = new Properties();</span>
<span class="fc" id="L441">            props.load(in);</span>
<span class="fc" id="L442">            return props;</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">        }</span>
<span class="nc" id="L444">        catch (Exception e)</span>
        {
<span class="nc" id="L446">            JVMStabilityInspector.inspectThrowable(e);</span>
<span class="nc" id="L447">            logger.warn(&quot;Unable to load version.properties&quot;, e);</span>
<span class="nc" id="L448">            return null;</span>
        }
    }

    public static String getReleaseVersionString()
    {
<span class="fc" id="L454">        Properties props = getVersionProperties();</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">        if (props == null)</span>
<span class="nc" id="L456">            return RELEASE_VERSION.getString(UNKNOWN_RELEASE_VERSION);</span>
<span class="fc" id="L457">        return props.getProperty(&quot;CassandraVersion&quot;);</span>
    }

    public static String getGitSHA()
    {
<span class="fc" id="L462">        Properties props = getVersionProperties();</span>
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">        if (props == null)</span>
<span class="nc" id="L464">            return GIT_SHA.getString(UNKNOWN_GIT_SHA);</span>
<span class="fc" id="L465">        return props.getProperty(&quot;GitSHA&quot;, UNKNOWN_GIT_SHA);</span>
    }

    public static String getReleaseVersionMajor()
    {
<span class="fc" id="L470">        String releaseVersion = FBUtilities.getReleaseVersionString();</span>
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">        if (FBUtilities.UNKNOWN_RELEASE_VERSION.equals(releaseVersion))</span>
        {
<span class="nc" id="L473">            throw new AssertionError(&quot;Release version is unknown&quot;);</span>
        }
<span class="fc" id="L475">        return releaseVersion.substring(0, releaseVersion.indexOf('.'));</span>
    }

    public static long timestampMicros()
    {
        // we use microsecond resolution for compatibility with other client libraries, even though
        // we can't actually get microsecond precision.
<span class="fc" id="L482">        return currentTimeMillis() * 1000;</span>
    }

    public static long nowInSeconds()
    {
<span class="fc" id="L487">        return currentTimeMillis() / 1000l;</span>
    }

    public static Instant now()
    {
<span class="fc" id="L492">        long epochMilli = currentTimeMillis();</span>
<span class="fc" id="L493">        return Instant.ofEpochMilli(epochMilli);</span>
    }

    public static &lt;T&gt; List&lt;T&gt; waitOnFutures(Iterable&lt;? extends Future&lt;? extends T&gt;&gt; futures)
    {
<span class="fc" id="L498">        return waitOnFutures(futures, -1, null);</span>
    }

    /**
     * Block for a collection of futures, with optional timeout.
     *
     * @param futures
     * @param timeout The number of units to wait in total. If this value is less than or equal to zero,
     *           no tiemout value will be passed to {@link Future#get()}.
     * @param units The units of timeout.
     */
    public static &lt;T&gt; List&lt;T&gt; waitOnFutures(Iterable&lt;? extends Future&lt;? extends T&gt;&gt; futures, long timeout, TimeUnit units)
    {
<span class="fc" id="L511">        long endNanos = 0;</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">        if (timeout &gt; 0)</span>
<span class="fc" id="L513">            endNanos = nanoTime() + units.toNanos(timeout);</span>
<span class="fc" id="L514">        List&lt;T&gt; results = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L515">        Throwable fail = null;</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">        for (Future&lt;? extends T&gt; f : futures)</span>
        {
            try
            {
<span class="fc bfc" id="L520" title="All 2 branches covered.">                if (endNanos == 0)</span>
                {
<span class="fc" id="L522">                    results.add(f.get());</span>
                }
                else
                {
<span class="fc" id="L526">                    long waitFor = Math.max(1, endNanos - nanoTime());</span>
<span class="fc" id="L527">                    results.add(f.get(waitFor, TimeUnit.NANOSECONDS));</span>
                }
            }
<span class="nc" id="L530">            catch (Throwable t)</span>
            {
<span class="nc" id="L532">                fail = Throwables.merge(fail, t);</span>
<span class="fc" id="L533">            }</span>
<span class="fc" id="L534">        }</span>
<span class="fc" id="L535">        Throwables.maybeFail(fail);</span>
<span class="fc" id="L536">        return results;</span>
    }

    public static &lt;T&gt; T waitOnFuture(Future&lt;T&gt; future)
    {
        try
        {
<span class="fc" id="L543">            return future.get();</span>
        }
<span class="nc" id="L545">        catch (ExecutionException ee)</span>
        {
<span class="nc" id="L547">            throw Throwables.cleaned(ee);</span>
        }
<span class="nc" id="L549">        catch (InterruptedException ie)</span>
        {
<span class="nc" id="L551">            throw new UncheckedInterruptedException(ie);</span>
        }
    }

    public static &lt;T, F extends Future&lt;? extends T&gt;&gt; F waitOnFirstFuture(Iterable&lt;? extends F&gt; futures)
    {
<span class="nc" id="L557">        return waitOnFirstFuture(futures, 100);</span>
    }
    /**
     * Only wait for the first future to finish from a list of futures. Will block until at least 1 future finishes.
     * @param futures The futures to wait on
     * @return future that completed.
     */
    public static &lt;T, F extends Future&lt;? extends T&gt;&gt; F waitOnFirstFuture(Iterable&lt;? extends F&gt; futures, long delay)
    {
        while (true)
        {
<span class="nc" id="L568">            Iterator&lt;? extends F&gt; iter = futures.iterator();</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">            if (!iter.hasNext())</span>
<span class="nc" id="L570">                throw new IllegalArgumentException();</span>

            while (true)
            {
<span class="nc" id="L574">                F f = iter.next();</span>
                boolean isDone;
<span class="nc bnc" id="L576" title="All 4 branches missed.">                if ((isDone = f.isDone()) || !iter.hasNext())</span>
                {
                    try
                    {
<span class="nc" id="L580">                        f.get(delay, TimeUnit.MILLISECONDS);</span>
                    }
<span class="nc" id="L582">                    catch (InterruptedException e)</span>
                    {
<span class="nc" id="L584">                        throw new UncheckedInterruptedException(e);</span>
                    }
<span class="nc" id="L586">                    catch (ExecutionException e)</span>
                    {
<span class="nc" id="L588">                        throw new RuntimeException(e);</span>
                    }
<span class="nc" id="L590">                    catch (TimeoutException e)</span>
                    {
<span class="nc bnc" id="L592" title="All 2 branches missed.">                        if (!isDone) // prevent infinite loops on bad implementations (not encountered)</span>
<span class="nc" id="L593">                            break;</span>
<span class="nc" id="L594">                    }</span>
<span class="nc" id="L595">                    return f;</span>
                }
<span class="nc" id="L597">            }</span>
<span class="nc" id="L598">        }</span>
    }

    /**
     * Returns a new {@link Future} wrapping the given list of futures and returning a list of their results.
     */
    public static &lt;T&gt; org.apache.cassandra.utils.concurrent.Future&lt;List&lt;T&gt;&gt; allOf(Collection&lt;? extends org.apache.cassandra.utils.concurrent.Future&lt;? extends T&gt;&gt; futures)
    {
<span class="fc" id="L606">        return FutureCombiner.allOf(futures);</span>
    }

    /**
     * Create a new instance of a partitioner defined in an SSTable Descriptor
     * @param desc Descriptor of an sstable
     * @return a new IPartitioner instance
     * @throws IOException
     */
    public static IPartitioner newPartitioner(Descriptor desc) throws IOException
    {
<span class="nc" id="L617">        StatsComponent statsComponent = StatsComponent.load(desc, MetadataType.VALIDATION, MetadataType.HEADER);</span>
<span class="nc" id="L618">        return newPartitioner(statsComponent.validationMetadata().partitioner, Optional.of(statsComponent.serializationHeader().getKeyType()));</span>
    }

    public static IPartitioner newPartitioner(String partitionerClassName) throws ConfigurationException
    {
<span class="fc" id="L623">        return newPartitioner(partitionerClassName, Optional.empty());</span>
    }

    @VisibleForTesting
    static IPartitioner newPartitioner(String partitionerClassName, Optional&lt;AbstractType&lt;?&gt;&gt; comparator) throws ConfigurationException
    {
<span class="pc bpc" id="L629" title="1 of 2 branches missed.">        if (!partitionerClassName.contains(&quot;.&quot;))</span>
<span class="nc" id="L630">            partitionerClassName = &quot;org.apache.cassandra.dht.&quot; + partitionerClassName;</span>

<span class="pc bpc" id="L632" title="1 of 2 branches missed.">        if (partitionerClassName.equals(&quot;org.apache.cassandra.dht.LocalPartitioner&quot;))</span>
        {
<span class="nc bnc" id="L634" title="All 2 branches missed.">            assert comparator.isPresent() : &quot;Expected a comparator for local partitioner&quot;;</span>
<span class="nc" id="L635">            return new LocalPartitioner(comparator.get());</span>
        }
<span class="fc" id="L637">        return FBUtilities.instanceOrConstruct(partitionerClassName, &quot;partitioner&quot;);</span>
    }

    public static IAuthorizer newAuthorizer(String className) throws ConfigurationException
    {
<span class="nc bnc" id="L642" title="All 2 branches missed.">        if (!className.contains(&quot;.&quot;))</span>
<span class="nc" id="L643">            className = &quot;org.apache.cassandra.auth.&quot; + className;</span>
<span class="nc" id="L644">        return FBUtilities.construct(className, &quot;authorizer&quot;);</span>
    }

    public static IAuthenticator newAuthenticator(String className) throws ConfigurationException
    {
<span class="nc bnc" id="L649" title="All 2 branches missed.">        if (!className.contains(&quot;.&quot;))</span>
<span class="nc" id="L650">            className = &quot;org.apache.cassandra.auth.&quot; + className;</span>
<span class="nc" id="L651">        return FBUtilities.construct(className, &quot;authenticator&quot;);</span>
    }

    public static IRoleManager newRoleManager(String className) throws ConfigurationException
    {
<span class="nc bnc" id="L656" title="All 2 branches missed.">        if (!className.contains(&quot;.&quot;))</span>
<span class="nc" id="L657">            className = &quot;org.apache.cassandra.auth.&quot; + className;</span>
<span class="nc" id="L658">        return FBUtilities.construct(className, &quot;role manager&quot;);</span>
    }

    public static INetworkAuthorizer newNetworkAuthorizer(String className)
    {
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">        if (className == null)</span>
        {
<span class="fc" id="L665">            return new AllowAllNetworkAuthorizer();</span>
        }
<span class="nc bnc" id="L667" title="All 2 branches missed.">        if (!className.contains(&quot;.&quot;))</span>
        {
<span class="nc" id="L669">            className = &quot;org.apache.cassandra.auth.&quot; + className;</span>
        }
<span class="nc" id="L671">        return FBUtilities.construct(className, &quot;network authorizer&quot;);</span>
    }

    public static IAuditLogger newAuditLogger(String className, Map&lt;String, String&gt; parameters) throws ConfigurationException
    {
<span class="nc bnc" id="L676" title="All 2 branches missed.">        if (!className.contains(&quot;.&quot;))</span>
<span class="nc" id="L677">            className = &quot;org.apache.cassandra.audit.&quot; + className;</span>

        try
        {
<span class="nc" id="L681">            Class&lt;?&gt; auditLoggerClass = FBUtilities.classForName(className, &quot;Audit logger&quot;);</span>
<span class="nc" id="L682">            return (IAuditLogger) auditLoggerClass.getConstructor(Map.class).newInstance(parameters);</span>
        }
<span class="nc" id="L684">        catch (Exception ex)</span>
        {
<span class="nc" id="L686">            throw new ConfigurationException(&quot;Unable to create instance of IAuditLogger.&quot;, ex);</span>
        }
    }

    public static ISslContextFactory newSslContextFactory(String className, Map&lt;String,Object&gt; parameters) throws ConfigurationException
    {
<span class="pc bpc" id="L692" title="1 of 2 branches missed.">        if (!className.contains(&quot;.&quot;))</span>
<span class="nc" id="L693">            className = &quot;org.apache.cassandra.security.&quot; + className;</span>

        try
        {
<span class="fc" id="L697">            Class&lt;?&gt; sslContextFactoryClass = Class.forName(className);</span>
<span class="fc" id="L698">            return (ISslContextFactory) sslContextFactoryClass.getConstructor(Map.class).newInstance(parameters);</span>
        }
<span class="nc" id="L700">        catch (Exception ex)</span>
        {
<span class="nc" id="L702">            throw new ConfigurationException(&quot;Unable to create instance of ISslContextFactory for &quot; + className, ex);</span>
        }
    }

    public static AbstractCryptoProvider newCryptoProvider(String className, Map&lt;String, String&gt; parameters) throws ConfigurationException
    {
        try
        {
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">            if (!className.contains(&quot;.&quot;))</span>
<span class="nc" id="L711">                className = &quot;org.apache.cassandra.security.&quot; + className;</span>

<span class="fc" id="L713">            Class&lt;?&gt; cryptoProviderClass = FBUtilities.classForName(className, &quot;crypto provider class&quot;);</span>
<span class="fc" id="L714">            return (AbstractCryptoProvider) cryptoProviderClass.getConstructor(Map.class).newInstance(Collections.unmodifiableMap(parameters));</span>
        }
<span class="nc" id="L716">        catch (Exception e)</span>
        {
            // no need to wrap it in another ConfgurationException if FBUtilities.classForName might throw it
<span class="nc bnc" id="L719" title="All 2 branches missed.">            if (e instanceof ConfigurationException)</span>
<span class="nc" id="L720">                throw (ConfigurationException) e;</span>
            else
<span class="nc" id="L722">                throw new ConfigurationException(String.format(&quot;Unable to create an instance of crypto provider for %s&quot;, className), e);</span>
        }
    }

    /**
     * @return The Class for the given name.
     * @param classname Fully qualified classname.
     * @param readable Descriptive noun for the role the class plays.
     * @throws ConfigurationException If the class cannot be found.
     */
    public static &lt;T&gt; Class&lt;T&gt; classForName(String classname, String readable) throws ConfigurationException
    {
        try
        {
<span class="fc" id="L736">            return (Class&lt;T&gt;)Class.forName(classname);</span>
        }
<span class="nc" id="L738">        catch (ClassNotFoundException | NoClassDefFoundError e)</span>
        {
<span class="nc" id="L740">            throw new ConfigurationException(String.format(&quot;Unable to find %s class '%s'&quot;, readable, classname), e);</span>
        }
    }

    /**
     * Constructs an instance of the given class, which must have a no-arg or default constructor.
     * @param classname Fully qualified classname.
     * @param readable Descriptive noun for the role the class plays.
     * @throws ConfigurationException If the class cannot be found.
     */
    public static &lt;T&gt; T instanceOrConstruct(String classname, String readable) throws ConfigurationException
    {
<span class="fc" id="L752">        Class&lt;T&gt; cls = FBUtilities.classForName(classname, readable);</span>
        try
        {
<span class="fc" id="L755">            Field instance = cls.getField(&quot;instance&quot;);</span>
<span class="fc" id="L756">            return cls.cast(instance.get(null));</span>
        }
<span class="fc" id="L758">        catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e)</span>
        {
            // Could not get instance field. Try instantiating.
<span class="fc" id="L761">            return construct(cls, classname, readable);</span>
        }
    }

    /**
     * Constructs an instance of the given class, which must have a no-arg or default constructor.
     * @param classname Fully qualified classname.
     * @param readable Descriptive noun for the role the class plays.
     * @throws ConfigurationException If the class cannot be found.
     */
    public static &lt;T&gt; T construct(String classname, String readable) throws ConfigurationException
    {
<span class="fc" id="L773">        Class&lt;T&gt; cls = FBUtilities.classForName(classname, readable);</span>
<span class="fc" id="L774">        return construct(cls, classname, readable);</span>
    }

    private static &lt;T&gt; T construct(Class&lt;T&gt; cls, String classname, String readable) throws ConfigurationException
    {
        try
        {
<span class="fc" id="L781">            return cls.newInstance();</span>
        }
<span class="nc" id="L783">        catch (IllegalAccessException e)</span>
        {
<span class="nc" id="L785">            throw new ConfigurationException(String.format(&quot;Default constructor for %s class '%s' is inaccessible.&quot;, readable, classname));</span>
        }
<span class="nc" id="L787">        catch (InstantiationException e)</span>
        {
<span class="nc" id="L789">            throw new ConfigurationException(String.format(&quot;Cannot use abstract class '%s' as %s.&quot;, classname, readable));</span>
        }
<span class="nc" id="L791">        catch (Exception e)</span>
        {
            // Catch-all because Class.newInstance() &quot;propagates any exception thrown by the nullary constructor, including a checked exception&quot;.
<span class="nc bnc" id="L794" title="All 2 branches missed.">            if (e.getCause() instanceof ConfigurationException)</span>
<span class="nc" id="L795">                throw (ConfigurationException)e.getCause();</span>
<span class="nc" id="L796">            throw new ConfigurationException(String.format(&quot;Error instantiating %s class '%s'.&quot;, readable, classname), e);</span>
        }
    }

    public static &lt;T&gt; NavigableSet&lt;T&gt; singleton(T column, Comparator&lt;? super T&gt; comparator)
    {
<span class="fc" id="L802">        NavigableSet&lt;T&gt; s = new TreeSet&lt;T&gt;(comparator);</span>
<span class="fc" id="L803">        s.add(column);</span>
<span class="fc" id="L804">        return s;</span>
    }

    public static &lt;T&gt; NavigableSet&lt;T&gt; emptySortedSet(Comparator&lt;? super T&gt; comparator)
    {
<span class="nc" id="L809">        return new TreeSet&lt;T&gt;(comparator);</span>
    }

    /**
     * Make straing out of the given {@code Map}.
     *
     * @param map Map to make string.
     * @return String representation of all entries in the map,
     *         where key and value pair is concatenated with ':'.
     */
    @Nonnull
    public static String toString(@Nullable Map&lt;?, ?&gt; map)
    {
<span class="fc bfc" id="L822" title="All 2 branches covered.">        if (map == null)</span>
<span class="fc" id="L823">            return &quot;&quot;;</span>
<span class="fc" id="L824">        Joiner.MapJoiner joiner = Joiner.on(&quot;, &quot;).withKeyValueSeparator(&quot;:&quot;);</span>
<span class="fc" id="L825">        return joiner.join(map);</span>
    }

    /**
     * Used to get access to protected/private field of the specified class
     * @param klass - name of the class
     * @param fieldName - name of the field
     * @return Field or null on error
     */
    public static Field getProtectedField(Class klass, String fieldName)
    {
        try
        {
<span class="fc" id="L838">            Field field = klass.getDeclaredField(fieldName);</span>
<span class="fc" id="L839">            field.setAccessible(true);</span>
<span class="fc" id="L840">            return field;</span>
        }
<span class="nc" id="L842">        catch (Exception e)</span>
        {
<span class="nc" id="L844">            throw new AssertionError(e);</span>
        }
    }

    public static &lt;T&gt; CloseableIterator&lt;T&gt; closeableIterator(Iterator&lt;T&gt; iterator)
    {
<span class="nc" id="L850">        return new WrappedCloseableIterator&lt;T&gt;(iterator);</span>
    }

    final static String UNIT_PREFIXES = &quot;qryzafpnum KMGTPEZYRQ&quot;;
<span class="fc" id="L854">    final static int UNIT_PREFIXES_BASE = UNIT_PREFIXES.indexOf(' ');</span>
<span class="fc" id="L855">    final static Pattern BASE_NUMBER_PATTERN = Pattern.compile(&quot;NaN|[+-]?Infinity|[+-]?\\d+(\\.\\d+)?([eE]([+-]?)\\d+)?&quot;);</span>
<span class="fc" id="L856">    final static Pattern BINARY_EXPONENT = Pattern.compile(&quot;\\*2\\^([+-]?\\d+)&quot;);</span>

    /**
     * Convert the given size in bytes to a human-readable value using binary (i.e. 2^10-based) modifiers.
     * For example, 1.000KiB, 2.100GiB etc., up to 8.000 EiB.
     * @param size      Number to convert.
     */
    public static String prettyPrintMemory(long size)
    {
<span class="fc" id="L865">        return prettyPrintMemory(size, &quot;&quot;);</span>
    }

    /**
     * Convert the given size in bytes to a human-readable value using binary (i.e. 2^10-based) modifiers.
     * For example, 1.000KiB, 2.100GiB etc., up to 8.000 EiB.
     * @param size      Number to convert.
     * @param separator Separator between the number and the (modified) unit.
     */
    public static String prettyPrintMemory(long size, String separator)
    {
<span class="fc" id="L876">        int prefixIndex = (63 - Long.numberOfLeadingZeros(Math.abs(size))) / 10;</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">        if (prefixIndex == 0)</span>
<span class="fc" id="L878">            return String.format(&quot;%d%sB&quot;, size, separator);</span>
        else
<span class="fc" id="L880">            return String.format(&quot;%.3f%s%ciB&quot;,</span>
<span class="fc" id="L881">                                 Math.scalb(size, -prefixIndex * 10),</span>
                                 separator,
<span class="fc" id="L883">                                 UNIT_PREFIXES.charAt(UNIT_PREFIXES_BASE + prefixIndex));</span>
    }

    /**
     * Convert the given value to a human-readable string using binary (i.e. 2^10-based) modifiers.
     * If the number is outside the modifier range (i.e. &lt; 1 qi or &gt; 1 Qi), it will be printed as v*2^e where e is a
     * multiple of 10 with sign.
     * For example, 1.000KiB, 2.100 miB/s, 7.006*2^+150, -Infinity.
     * @param value     Number to convert.
     * @param separator Separator between the number and the (modified) unit.
     */
    public static String prettyPrintBinary(double value, String unit, String separator)
    {
<span class="fc" id="L896">        int prefixIndex = Math.floorDiv(Math.getExponent(value), 10);</span>
<span class="pc bpc" id="L897" title="1 of 6 branches missed.">        if (prefixIndex == 0 || !Double.isFinite(value) || value == 0)</span>
<span class="fc" id="L898">            return String.format(&quot;%.3f%s%s&quot;, value, separator, unit);</span>
<span class="pc bpc" id="L899" title="2 of 4 branches missed.">        else if (prefixIndex &gt; UNIT_PREFIXES_BASE || prefixIndex &lt; -UNIT_PREFIXES_BASE)</span>
<span class="nc" id="L900">            return String.format(&quot;%.3f*2^%+d%s%s&quot;,</span>
<span class="nc" id="L901">                                 Math.scalb(value, -prefixIndex * 10),</span>
<span class="nc" id="L902">                                 prefixIndex * 10,</span>
                                 separator,
                                 unit);
        else
<span class="fc" id="L906">            return String.format(&quot;%.3f%s%ci%s&quot;,</span>
<span class="fc" id="L907">                                 Math.scalb(value, -prefixIndex * 10),</span>
                                 separator,
<span class="fc" id="L909">                                 UNIT_PREFIXES.charAt(UNIT_PREFIXES_BASE + prefixIndex),</span>
                                 unit);
    }

    /**
     * Convert the given value to a human-readable string using decimal (i.e. 10^3-based) modifiers.
     * If the number is outside the modifier range (i.e. &lt; 1 qi or &gt; 1 Qi), it will be printed as vEe where e is a
     * multiple of 3 with sign.
     * For example, 1.000km, 2.100 ms, 10E+45, NaN.
     * @param value     Number to convert.
     * @param separator Separator between the number and the (modified) unit.
     */
    public static String prettyPrintDecimal(double value, String unit, String separator)
    {
<span class="nc" id="L923">        int prefixIndex = (int) Math.floor(Math.log10(Math.abs(value)) / 3);</span>
<span class="nc" id="L924">        double base = value * Math.pow(1000.0, -prefixIndex);</span>
<span class="nc bnc" id="L925" title="All 8 branches missed.">        if (prefixIndex == 0 || !Double.isFinite(value) || !Double.isFinite(base) || value == 0)</span>
<span class="nc" id="L926">            return String.format(&quot;%.3f%s%s&quot;, value, separator, unit);</span>
<span class="nc bnc" id="L927" title="All 4 branches missed.">        else if (prefixIndex &gt; UNIT_PREFIXES_BASE || prefixIndex &lt; -UNIT_PREFIXES_BASE)</span>
<span class="nc" id="L928">            return String.format(&quot;%.3fe%+d%s%s&quot;,</span>
<span class="nc" id="L929">                                 base,</span>
<span class="nc" id="L930">                                 prefixIndex * 3,</span>
                                 separator,
                                 unit);
        else
<span class="nc" id="L934">            return String.format(&quot;%.3f%s%c%s&quot;,</span>
<span class="nc" id="L935">                                 base,</span>
                                 separator,
<span class="nc" id="L937">                                 UNIT_PREFIXES.charAt(UNIT_PREFIXES_BASE + prefixIndex),</span>
                                 unit);
    }

    public static String prettyPrintMemoryPerSecond(long rate)
    {
<span class="nc" id="L943">        return prettyPrintMemory(rate) + &quot;/s&quot;;</span>
    }

    public static String prettyPrintMemoryPerSecond(long bytes, long timeInNano)
    {
<span class="fc" id="L948">        return prettyPrintBinary(bytes * 1.0e9 / timeInNano, &quot;B/s&quot;, &quot;&quot;);</span>
    }

    /**
     * Parse a human-readable value printed using one of the methods above. Understands both binary and decimal
     * modifiers, as well as decimal exponents using the E notation and binary exponents using *2^e.
     *
     * @param datum     The human-readable number.
     * @param separator Expected separator, null to accept any amount of whitespace.
     * @param unit      Expected unit. If null, the method will accept any string as unit, i.e. it will parse the number
     *                  at the start of the supplied string and ignore any remainder.
     * @return The parsed value.
     */
    public static double parseHumanReadable(String datum, String separator, String unit)
    {
<span class="nc" id="L963">        int end = datum.length();</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">        if (unit != null)</span>
        {
<span class="nc bnc" id="L966" title="All 2 branches missed.">            if (!datum.endsWith(unit))</span>
<span class="nc" id="L967">                throw new NumberFormatException(datum + &quot; does not end in unit &quot; + unit);</span>
<span class="nc" id="L968">            end -= unit.length();</span>
        }

<span class="nc" id="L971">        Matcher m = BASE_NUMBER_PATTERN.matcher(datum);</span>
<span class="nc" id="L972">        m.region(0, end);</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">        if (!m.lookingAt())</span>
<span class="nc" id="L974">            throw new NumberFormatException();</span>
<span class="nc" id="L975">        double v = Double.parseDouble(m.group(0));</span>

<span class="nc" id="L977">        int pos = m.end();</span>
<span class="nc bnc" id="L978" title="All 2 branches missed.">        if (m.group(2) == null) // possible binary exponent, parse</span>
        {
<span class="nc" id="L980">            m = BINARY_EXPONENT.matcher(datum);</span>
<span class="nc" id="L981">            m.region(pos, end);</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">            if (m.lookingAt())</span>
            {
<span class="nc" id="L984">                int power = Integer.parseInt(m.group(1));</span>
<span class="nc" id="L985">                v = Math.scalb(v, power);</span>
<span class="nc" id="L986">                pos = m.end();</span>
            }
        }

<span class="nc bnc" id="L990" title="All 2 branches missed.">        if (separator != null)</span>
        {
<span class="nc bnc" id="L992" title="All 2 branches missed.">            if (!datum.startsWith(separator, pos))</span>
<span class="nc" id="L993">                throw new NumberFormatException(&quot;Missing separator &quot; + separator + &quot; in &quot; + datum);</span>
<span class="nc" id="L994">            pos += separator.length();</span>
        }
        else
        {
<span class="nc bnc" id="L998" title="All 4 branches missed.">            while (pos &lt; end &amp;&amp; Character.isWhitespace(datum.charAt(pos)))</span>
<span class="nc" id="L999">                ++pos;</span>
        }

<span class="nc bnc" id="L1002" title="All 2 branches missed.">        if (pos &lt; end)</span>
        {
<span class="nc" id="L1004">            char prefixChar = datum.charAt(pos);</span>
<span class="nc" id="L1005">            int prefixIndex = UNIT_PREFIXES.indexOf(prefixChar);</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">            if (prefixIndex &gt;= 0)</span>
            {
<span class="nc" id="L1008">                prefixIndex -= UNIT_PREFIXES_BASE;</span>
<span class="nc" id="L1009">                ++pos;</span>
<span class="nc bnc" id="L1010" title="All 4 branches missed.">                if (pos &lt; end &amp;&amp; datum.charAt(pos) == 'i')</span>
                {
<span class="nc" id="L1012">                    ++pos;</span>
<span class="nc" id="L1013">                    v = Math.scalb(v, prefixIndex * 10);</span>
                }
                else
                {
<span class="nc" id="L1017">                    v *= Math.exp(Math.log(1000.0) * prefixIndex);</span>
                }
            }
        }

<span class="nc bnc" id="L1022" title="All 4 branches missed.">        if (pos != end &amp;&amp; unit != null)</span>
<span class="nc" id="L1023">            throw new NumberFormatException(&quot;Unexpected characters between pos &quot; + pos + &quot; and &quot; + end + &quot; in &quot; + datum);</span>

<span class="nc" id="L1025">        return v;</span>
    }

    public static long parseHumanReadableBytes(String value)
    {
<span class="nc" id="L1030">        return (long) parseHumanReadable(value, null, &quot;B&quot;);</span>
    }

    /**
     * Starts and waits for the given @param pb to finish.
     * @throws java.io.IOException on non-zero exit code
     */
    public static void exec(ProcessBuilder pb) throws IOException
    {
<span class="nc" id="L1039">        Process p = pb.start();</span>
        try
        {
<span class="nc" id="L1042">            int errCode = p.waitFor();</span>
<span class="nc bnc" id="L1043" title="All 2 branches missed.">            if (errCode != 0)</span>
            {
<span class="nc" id="L1045">                try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()));</span>
<span class="nc" id="L1046">                     BufferedReader err = new BufferedReader(new InputStreamReader(p.getErrorStream())))</span>
                {
<span class="nc" id="L1048">                    String lineSep = LINE_SEPARATOR.getString();</span>
<span class="nc" id="L1049">                    StringBuilder sb = new StringBuilder();</span>
                    String str;
<span class="nc bnc" id="L1051" title="All 2 branches missed.">                    while ((str = in.readLine()) != null)</span>
<span class="nc" id="L1052">                        sb.append(str).append(lineSep);</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">                    while ((str = err.readLine()) != null)</span>
<span class="nc" id="L1054">                        sb.append(str).append(lineSep);</span>
<span class="nc" id="L1055">                    throw new IOException(&quot;Exception while executing the command: &quot;+ StringUtils.join(pb.command(), &quot; &quot;) +</span>
                                          &quot;, command error Code: &quot; + errCode +
<span class="nc" id="L1057">                                          &quot;, command output: &quot;+ sb.toString());</span>
                }
            }
        }
<span class="nc" id="L1061">        catch (InterruptedException e)</span>
        {
<span class="nc" id="L1063">            throw new UncheckedInterruptedException(e);</span>
<span class="nc" id="L1064">        }</span>
<span class="nc" id="L1065">    }</span>

    public static void updateChecksumInt(Checksum checksum, int v)
    {
<span class="fc" id="L1069">        checksum.update((v &gt;&gt;&gt; 24) &amp; 0xFF);</span>
<span class="fc" id="L1070">        checksum.update((v &gt;&gt;&gt; 16) &amp; 0xFF);</span>
<span class="fc" id="L1071">        checksum.update((v &gt;&gt;&gt; 8) &amp; 0xFF);</span>
<span class="fc" id="L1072">        checksum.update((v &gt;&gt;&gt; 0) &amp; 0xFF);</span>
<span class="fc" id="L1073">    }</span>

    /**
      * Updates checksum with the provided ByteBuffer at the given offset + length.
      * Resets position and limit back to their original values on return.
      * This method is *NOT* thread-safe.
      */
    public static void updateChecksum(CRC32 checksum, ByteBuffer buffer, int offset, int length)
    {
<span class="fc" id="L1082">        int position = buffer.position();</span>
<span class="fc" id="L1083">        int limit = buffer.limit();</span>

<span class="fc" id="L1085">        buffer.position(offset).limit(offset + length);</span>
<span class="fc" id="L1086">        checksum.update(buffer);</span>

<span class="fc" id="L1088">        buffer.position(position).limit(limit);</span>
<span class="fc" id="L1089">    }</span>

    /**
     * Updates checksum with the provided ByteBuffer.
     * Resets position back to its original values on return.
     * This method is *NOT* thread-safe.
     */
    public static void updateChecksum(CRC32 checksum, ByteBuffer buffer)
    {
<span class="fc" id="L1098">        int position = buffer.position();</span>
<span class="fc" id="L1099">        checksum.update(buffer);</span>
<span class="fc" id="L1100">        buffer.position(position);</span>
<span class="fc" id="L1101">    }</span>

    public static long abs(long index)
    {
<span class="fc" id="L1105">        long negbit = index &gt;&gt; 63;</span>
<span class="fc" id="L1106">        return (index ^ negbit) - negbit;</span>
    }

    private static final class WrappedCloseableIterator&lt;T&gt;
        extends AbstractIterator&lt;T&gt; implements CloseableIterator&lt;T&gt;
    {
        private final Iterator&lt;T&gt; source;
        public WrappedCloseableIterator(Iterator&lt;T&gt; source)
        {
            this.source = source;
        }

        protected T computeNext()
        {
            if (!source.hasNext())
                return endOfData();
            return source.next();
        }

        public void close() {}
    }

    public static &lt;T&gt; byte[] serialize(T object, IVersionedSerializer&lt;T&gt; serializer, int version)
    {
<span class="nc" id="L1130">        int size = (int) serializer.serializedSize(object, version);</span>

<span class="nc" id="L1132">        try (DataOutputBuffer buffer = new DataOutputBufferFixed(size))</span>
        {
<span class="nc" id="L1134">            serializer.serialize(object, buffer, version);</span>
<span class="nc bnc" id="L1135" title="All 4 branches missed.">            assert buffer.getLength() == size &amp;&amp; buffer.getData().length == size</span>
<span class="nc" id="L1136">                : String.format(&quot;Final buffer length %s to accommodate data size of %s (predicted %s) for %s&quot;,</span>
<span class="nc" id="L1137">                        buffer.getData().length, buffer.getLength(), size, object);</span>
<span class="nc" id="L1138">            return buffer.getData();</span>
        }
<span class="nc" id="L1140">        catch (IOException e)</span>
        {
            // We're doing in-memory serialization...
<span class="nc" id="L1143">            throw new AssertionError(e);</span>
        }
    }

    public static long copy(InputStream from, OutputStream to, long limit) throws IOException
    {
<span class="fc" id="L1149">        byte[] buffer = new byte[64]; // 64 byte buffer</span>
<span class="fc" id="L1150">        long copied = 0;</span>
<span class="fc" id="L1151">        int toCopy = buffer.length;</span>
        while (true)
        {
<span class="pc bpc" id="L1154" title="1 of 2 branches missed.">            if (limit &lt; buffer.length + copied)</span>
<span class="fc" id="L1155">                toCopy = (int) (limit - copied);</span>
<span class="fc" id="L1156">            int sofar = from.read(buffer, 0, toCopy);</span>
<span class="pc bpc" id="L1157" title="1 of 2 branches missed.">            if (sofar == -1)</span>
<span class="nc" id="L1158">                break;</span>
<span class="fc" id="L1159">            to.write(buffer, 0, sofar);</span>
<span class="fc" id="L1160">            copied += sofar;</span>
<span class="pc bpc" id="L1161" title="1 of 2 branches missed.">            if (limit == copied)</span>
<span class="fc" id="L1162">                break;</span>
<span class="nc" id="L1163">        }</span>
<span class="fc" id="L1164">        return copied;</span>
    }

    public static File getToolsOutputDirectory()
    {
<span class="fc" id="L1169">        File historyDir = new File(USER_HOME.getString(), &quot;.cassandra&quot;);</span>
<span class="fc" id="L1170">        FileUtils.createDirectory(historyDir);</span>
<span class="fc" id="L1171">        return historyDir;</span>
    }

    public static void closeAll(Collection&lt;? extends AutoCloseable&gt; l) throws Exception
    {
<span class="nc" id="L1176">        Exception toThrow = null;</span>
<span class="nc bnc" id="L1177" title="All 2 branches missed.">        for (AutoCloseable c : l)</span>
        {
            try
            {
<span class="nc" id="L1181">                c.close();</span>
            }
<span class="nc" id="L1183">            catch (Exception e)</span>
            {
<span class="nc bnc" id="L1185" title="All 2 branches missed.">                if (toThrow == null)</span>
<span class="nc" id="L1186">                    toThrow = e;</span>
                else
<span class="nc" id="L1188">                    toThrow.addSuppressed(e);</span>
<span class="nc" id="L1189">            }</span>
<span class="nc" id="L1190">        }</span>
<span class="nc bnc" id="L1191" title="All 2 branches missed.">        if (toThrow != null)</span>
<span class="nc" id="L1192">            throw toThrow;</span>
<span class="nc" id="L1193">    }</span>

    public static byte[] toWriteUTFBytes(String s)
    {
        try
        {
<span class="nc" id="L1199">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L1200">            DataOutputStream dos = new DataOutputStream(baos);</span>
<span class="nc" id="L1201">            dos.writeUTF(s);</span>
<span class="nc" id="L1202">            dos.flush();</span>
<span class="nc" id="L1203">            return baos.toByteArray();</span>
        }
<span class="nc" id="L1205">        catch (IOException e)</span>
        {
<span class="nc" id="L1207">            throw new RuntimeException(e);</span>
        }
    }

	public static void sleepQuietly(long millis)
    {
        try
        {
<span class="nc" id="L1215">            Thread.sleep(millis);</span>
        }
<span class="nc" id="L1217">        catch (InterruptedException e)</span>
        {
<span class="nc" id="L1219">            throw new UncheckedInterruptedException(e);</span>
<span class="nc" id="L1220">        }</span>
<span class="nc" id="L1221">    }</span>

    public static long align(long val, int boundary)
    {
<span class="nc" id="L1225">        return (val + boundary) &amp; ~(boundary - 1);</span>
    }

    @VisibleForTesting
    public static void reset()
    {
<span class="nc" id="L1231">        localInetAddress = null;</span>
<span class="nc" id="L1232">        localInetAddressAndPort = null;</span>
<span class="nc" id="L1233">        broadcastInetAddress = null;</span>
<span class="nc" id="L1234">        broadcastInetAddressAndPort = null;</span>
<span class="nc" id="L1235">        broadcastNativeAddress = null;</span>
<span class="nc" id="L1236">    }</span>

    /**
     * Hack to prevent the ugly &quot;illegal access&quot; warnings in Java 11+ like the following.
     */
    public static void preventIllegalAccessWarnings()
    {
        // Example &quot;annoying&quot; trace:
        //        WARNING: An illegal reflective access operation has occurred
        //        WARNING: Illegal reflective access by io.netty.util.internal.ReflectionUtil (file:...)
        //        WARNING: Please consider reporting this to the maintainers of io.netty.util.internal.ReflectionUtil
        //        WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
        //        WARNING: All illegal access operations will be denied in a future release
        try
        {
<span class="fc" id="L1251">            Class&lt;?&gt; c = Class.forName(&quot;jdk.internal.module.IllegalAccessLogger&quot;);</span>
<span class="fc" id="L1252">            Field f = c.getDeclaredField(&quot;logger&quot;);</span>
<span class="fc" id="L1253">            f.setAccessible(true);</span>
<span class="fc" id="L1254">            f.set(null, null);</span>
        }
<span class="nc" id="L1256">        catch (Exception e)</span>
        {
            // ignore
<span class="fc" id="L1259">        }</span>
<span class="fc" id="L1260">    }</span>

    public static String camelToSnake(String camel)
    {
<span class="fc" id="L1264">        StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L1265" title="All 2 branches covered.">        for (char c : camel.toCharArray())</span>
        {
<span class="fc bfc" id="L1267" title="All 2 branches covered.">            if (Character.isUpperCase(c))</span>
            {
                // if first char is uppercase, then avoid adding the _ prefix
<span class="fc bfc" id="L1270" title="All 2 branches covered.">                if (sb.length() &gt; 0)</span>
<span class="fc" id="L1271">                    sb.append('_');</span>
<span class="fc" id="L1272">                sb.append(Character.toLowerCase(c));</span>
            }
            else
            {
<span class="fc" id="L1276">                sb.append(c);</span>
            }
        }
<span class="fc" id="L1279">        return sb.toString();</span>
    }

    @SafeVarargs
    public static &lt;T&gt; ImmutableList&lt;T&gt; immutableListWithFilteredNulls(T... values)
    {
<span class="fc" id="L1285">        ImmutableList.Builder&lt;T&gt; builder = ImmutableList.builderWithExpectedSize(values.length);</span>
<span class="fc bfc" id="L1286" title="All 2 branches covered.">        for (int i = 0; i &lt; values.length; i++)</span>
        {
<span class="pc bpc" id="L1288" title="1 of 2 branches missed.">            if (values[i] != null)</span>
<span class="fc" id="L1289">                builder.add(values[i]);</span>
        }
<span class="fc" id="L1291">        return builder.build();</span>
    }

    public static void closeQuietly(Object o)
    {
<span class="pc bpc" id="L1296" title="1 of 2 branches missed.">        if (!(o instanceof AutoCloseable))</span>
<span class="fc" id="L1297">            return;</span>
        try
        {
<span class="nc" id="L1300">            ((AutoCloseable) o).close();</span>
        }
<span class="nc" id="L1302">        catch (Exception e)</span>
        {
<span class="nc" id="L1304">            logger.warn(&quot;Closing {} had an unexpected exception&quot;, o, e);</span>
<span class="nc" id="L1305">        }</span>
<span class="nc" id="L1306">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>