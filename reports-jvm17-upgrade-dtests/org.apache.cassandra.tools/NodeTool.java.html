<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NodeTool.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.tools</a> &gt; <span class="el_source">NodeTool.java</span></div><h1>NodeTool.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.tools;

import static com.google.common.base.Throwables.getStackTraceAsString;
import static com.google.common.collect.Iterables.toArray;
import static com.google.common.collect.Lists.newArrayList;
import static java.lang.Integer.parseInt;
import static java.lang.String.format;
import static org.apache.cassandra.io.util.File.WriteMode.APPEND;
import static org.apache.commons.lang3.ArrayUtils.EMPTY_STRING_ARRAY;
import static org.apache.commons.lang3.StringUtils.EMPTY;
import static org.apache.commons.lang3.StringUtils.isEmpty;
import static org.apache.commons.lang3.StringUtils.isNotEmpty;

import java.io.Console;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.io.util.FileWriter;
import java.io.FileNotFoundException;
import java.io.IOError;
import java.io.IOException;
import java.net.UnknownHostException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Scanner;
import java.util.SortedMap;

import javax.management.InstanceNotFoundException;

import com.google.common.base.Joiner;
import com.google.common.base.Throwables;

import org.apache.cassandra.locator.EndpointSnitchInfoMBean;
import org.apache.cassandra.tools.nodetool.*;
import org.apache.cassandra.utils.FBUtilities;

import com.google.common.collect.Maps;

import io.airlift.airline.Cli;
import io.airlift.airline.Help;
import io.airlift.airline.Option;
import io.airlift.airline.OptionType;
import io.airlift.airline.ParseArgumentsMissingException;
import io.airlift.airline.ParseArgumentsUnexpectedException;
import io.airlift.airline.ParseCommandMissingException;
import io.airlift.airline.ParseCommandUnrecognizedException;
import io.airlift.airline.ParseOptionConversionException;
import io.airlift.airline.ParseOptionMissingException;
import io.airlift.airline.ParseOptionMissingValueException;

public class NodeTool
{
    static
    {
<span class="fc" id="L75">        FBUtilities.preventIllegalAccessWarnings();</span>
<span class="fc" id="L76">    }</span>

    private static final String HISTORYFILE = &quot;nodetool.history&quot;;

    private final INodeProbeFactory nodeProbeFactory;
    private final Output output;

    public static void main(String... args)
    {
<span class="nc" id="L85">        System.exit(new NodeTool(new NodeProbeFactory(), Output.CONSOLE).execute(args));</span>
<span class="nc" id="L86">    }</span>

    public NodeTool(INodeProbeFactory nodeProbeFactory, Output output)
<span class="fc" id="L89">    {</span>
<span class="fc" id="L90">        this.nodeProbeFactory = nodeProbeFactory;</span>
<span class="fc" id="L91">        this.output = output;</span>
<span class="fc" id="L92">    }</span>

    public int execute(String... args)
    {
<span class="fc" id="L96">        List&lt;Class&lt;? extends NodeToolCmdRunnable&gt;&gt; commands = newArrayList(</span>
                Assassinate.class,
                CassHelp.class,
                CfHistograms.class,
                CfStats.class,
                CIDRFilteringStats.class,
                Cleanup.class,
                ClearSnapshot.class,
                ClientStats.class,
                Compact.class,
                CompactionHistory.class,
                CompactionStats.class,
                DataPaths.class,
                Decommission.class,
                DescribeCluster.class,
                DescribeRing.class,
                DisableAuditLog.class,
                DisableAutoCompaction.class,
                DisableBackup.class,
                DisableBinary.class,
                DisableFullQueryLog.class,
                DisableGossip.class,
                DisableHandoff.class,
                DisableHintsForDC.class,
                DisableOldProtocolVersions.class,
                Drain.class,
                DropCIDRGroup.class,
                EnableAuditLog.class,
                EnableAutoCompaction.class,
                EnableBackup.class,
                EnableBinary.class,
                EnableFullQueryLog.class,
                EnableGossip.class,
                EnableHandoff.class,
                EnableHintsForDC.class,
                EnableOldProtocolVersions.class,
                FailureDetectorInfo.class,
                Flush.class,
                GarbageCollect.class,
                GcStats.class,
                GetAuditLog.class,
                GetAuthCacheConfig.class,
                GetBatchlogReplayTrottle.class,
                GetCIDRGroupsOfIP.class,
                GetColumnIndexSize.class,
                GetCompactionThreshold.class,
                GetCompactionThroughput.class,
                GetConcurrency.class,
                GetConcurrentCompactors.class,
                GetConcurrentViewBuilders.class,
                GetDefaultKeyspaceRF.class,
                GetEndpoints.class,
                GetFullQueryLog.class,
                GetInterDCStreamThroughput.class,
                GetLoggingLevels.class,
                GetMaxHintWindow.class,
                GetSSTables.class,
                GetSeeds.class,
                GetSnapshotThrottle.class,
                GetStreamThroughput.class,
                GetTimeout.class,
                GetTraceProbability.class,
                GossipInfo.class,
                Import.class,
                Info.class,
                InvalidateCIDRPermissionsCache.class,
                InvalidateCounterCache.class,
                InvalidateCredentialsCache.class,
                InvalidateJmxPermissionsCache.class,
                ReloadCIDRGroupsCache.class,
                InvalidateKeyCache.class,
                InvalidateNetworkPermissionsCache.class,
                InvalidatePermissionsCache.class,
                InvalidateRolesCache.class,
                InvalidateRowCache.class,
                Join.class,
                ListCIDRGroups.class,
                ListPendingHints.class,
                ListSnapshots.class,
                Move.class,
                NetStats.class,
                PauseHandoff.class,
                ProfileLoad.class,
                ProxyHistograms.class,
                RangeKeySample.class,
                Rebuild.class,
                RebuildIndex.class,
                RecompressSSTables.class,
                Refresh.class,
                RefreshSizeEstimates.class,
                ReloadLocalSchema.class,
                ReloadSeeds.class,
                ReloadSslCertificates.class,
                ReloadTriggers.class,
                RelocateSSTables.class,
                RemoveNode.class,
                Repair.class,
                ReplayBatchlog.class,
                ResetFullQueryLog.class,
                ResetLocalSchema.class,
                ResumeHandoff.class,
                Ring.class,
                Scrub.class,
                SetAuthCacheConfig.class,
                SetBatchlogReplayThrottle.class,
                SetCacheCapacity.class,
                SetCacheKeysToSave.class,
                SetColumnIndexSize.class,
                SetCompactionThreshold.class,
                SetCompactionThroughput.class,
                SetConcurrency.class,
                SetConcurrentCompactors.class,
                SetConcurrentViewBuilders.class,
                SetDefaultKeyspaceRF.class,
                SetHintedHandoffThrottleInKB.class,
                SetInterDCStreamThroughput.class,
                SetLoggingLevel.class,
                SetMaxHintWindow.class,
                SetSnapshotThrottle.class,
                SetStreamThroughput.class,
                SetTimeout.class,
                SetTraceProbability.class,
                Sjk.class,
                Snapshot.class,
                Status.class,
                StatusAutoCompaction.class,
                StatusBackup.class,
                StatusBinary.class,
                StatusGossip.class,
                StatusHandoff.class,
                Stop.class,
                StopDaemon.class,
                TableHistograms.class,
                TableStats.class,
                TopPartitions.class,
                TpStats.class,
                TruncateHints.class,
                UpdateCIDRGroup.class,
                UpgradeSSTable.class,
                Verify.class,
                Version.class,
                ViewBuildStatus.class,
                ForceCompact.class
        );

<span class="fc" id="L241">        Cli.CliBuilder&lt;NodeToolCmdRunnable&gt; builder = Cli.builder(&quot;nodetool&quot;);</span>

<span class="fc" id="L243">        builder.withDescription(&quot;Manage your Cassandra cluster&quot;)</span>
<span class="fc" id="L244">                 .withDefaultCommand(CassHelp.class)</span>
<span class="fc" id="L245">                 .withCommands(commands);</span>

        // bootstrap commands
<span class="fc" id="L248">        builder.withGroup(&quot;bootstrap&quot;)</span>
<span class="fc" id="L249">                .withDescription(&quot;Monitor/manage node's bootstrap process&quot;)</span>
<span class="fc" id="L250">                .withDefaultCommand(CassHelp.class)</span>
<span class="fc" id="L251">                .withCommand(BootstrapResume.class);</span>

<span class="fc" id="L253">        builder.withGroup(&quot;repair_admin&quot;)</span>
<span class="fc" id="L254">               .withDescription(&quot;list and fail incremental repair sessions&quot;)</span>
<span class="fc" id="L255">               .withDefaultCommand(RepairAdmin.ListCmd.class)</span>
<span class="fc" id="L256">               .withCommand(RepairAdmin.ListCmd.class)</span>
<span class="fc" id="L257">               .withCommand(RepairAdmin.CancelCmd.class)</span>
<span class="fc" id="L258">               .withCommand(RepairAdmin.CleanupDataCmd.class)</span>
<span class="fc" id="L259">               .withCommand(RepairAdmin.SummarizePendingCmd.class)</span>
<span class="fc" id="L260">               .withCommand(RepairAdmin.SummarizeRepairedCmd.class);</span>

<span class="fc" id="L262">        Cli&lt;NodeToolCmdRunnable&gt; parser = builder.build();</span>

<span class="fc" id="L264">        int status = 0;</span>
        try
        {
<span class="fc" id="L267">            NodeToolCmdRunnable parse = parser.parse(args);</span>
<span class="fc" id="L268">            printHistory(args);</span>
<span class="fc" id="L269">            parse.run(nodeProbeFactory, output);</span>
<span class="nc" id="L270">        } catch (IllegalArgumentException |</span>
                IllegalStateException |
                ParseArgumentsMissingException |
                ParseArgumentsUnexpectedException |
                ParseOptionConversionException |
                ParseOptionMissingException |
                ParseOptionMissingValueException |
                ParseCommandMissingException |
                ParseCommandUnrecognizedException e)
        {
<span class="nc" id="L280">            badUse(e);</span>
<span class="nc" id="L281">            status = 1;</span>
<span class="nc" id="L282">        } catch (Throwable throwable)</span>
        {
<span class="nc" id="L284">            err(Throwables.getRootCause(throwable));</span>
<span class="nc" id="L285">            status = 2;</span>
<span class="pc" id="L286">        }</span>

<span class="fc" id="L288">        return status;</span>
    }

    private static void printHistory(String... args)
    {
        //don't bother to print if no args passed (meaning, nodetool is just printing out the sub-commands list)
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">        if (args.length == 0)</span>
<span class="nc" id="L295">            return;</span>

<span class="fc" id="L297">        String cmdLine = Joiner.on(&quot; &quot;).skipNulls().join(args);</span>
<span class="fc" id="L298">        cmdLine = cmdLine.replaceFirst(&quot;(?&lt;=(-pw|--password))\\s+\\S+&quot;, &quot; &lt;hidden&gt;&quot;);</span>

<span class="fc" id="L300">        try (FileWriter writer = new File(FBUtilities.getToolsOutputDirectory(), HISTORYFILE).newWriter(APPEND))</span>
        {
<span class="fc" id="L302">            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss,SSS&quot;);</span>
<span class="fc" id="L303">            writer.append(sdf.format(new Date())).append(&quot;: &quot;).append(cmdLine).append(System.lineSeparator());</span>
        }
<span class="nc" id="L305">        catch (IOException | IOError ioe)</span>
        {
            //quietly ignore any errors about not being able to write out history
<span class="fc" id="L308">        }</span>
<span class="fc" id="L309">    }</span>

    protected void badUse(Exception e)
    {
<span class="nc" id="L313">        output.out.println(&quot;nodetool: &quot; + e.getMessage());</span>
<span class="nc" id="L314">        output.out.println(&quot;See 'nodetool help' or 'nodetool help &lt;command&gt;'.&quot;);</span>
<span class="nc" id="L315">    }</span>

    protected void err(Throwable e)
    {
        // CASSANDRA-11537: friendly error message when server is not ready
<span class="nc bnc" id="L320" title="All 2 branches missed.">        if (e instanceof InstanceNotFoundException)</span>
<span class="nc" id="L321">            throw new IllegalArgumentException(&quot;Server is not initialized yet, cannot run nodetool.&quot;);</span>

<span class="nc" id="L323">        output.err.println(&quot;error: &quot; + e.getMessage());</span>
<span class="nc" id="L324">        output.err.println(&quot;-- StackTrace --&quot;);</span>
<span class="nc" id="L325">        output.err.println(getStackTraceAsString(e));</span>
<span class="nc" id="L326">    }</span>

<span class="nc" id="L328">    public static class CassHelp extends Help implements NodeToolCmdRunnable</span>
    {
        public void run(INodeProbeFactory nodeProbeFactory, Output output)
        {
<span class="nc" id="L332">            run();</span>
<span class="nc" id="L333">        }</span>
    }

    interface NodeToolCmdRunnable
    {
        void run(INodeProbeFactory nodeProbeFactory, Output output);
    }

<span class="fc" id="L341">    public static abstract class NodeToolCmd implements NodeToolCmdRunnable</span>
    {

<span class="fc" id="L344">        @Option(type = OptionType.GLOBAL, name = {&quot;-h&quot;, &quot;--host&quot;}, description = &quot;Node hostname or ip address&quot;)</span>
        private String host = &quot;127.0.0.1&quot;;

<span class="fc" id="L347">        @Option(type = OptionType.GLOBAL, name = {&quot;-p&quot;, &quot;--port&quot;}, description = &quot;Remote jmx agent port number&quot;)</span>
        private String port = &quot;7199&quot;;

<span class="fc" id="L350">        @Option(type = OptionType.GLOBAL, name = {&quot;-u&quot;, &quot;--username&quot;}, description = &quot;Remote jmx agent username&quot;)</span>
        private String username = EMPTY;

<span class="fc" id="L353">        @Option(type = OptionType.GLOBAL, name = {&quot;-pw&quot;, &quot;--password&quot;}, description = &quot;Remote jmx agent password&quot;)</span>
        private String password = EMPTY;

<span class="fc" id="L356">        @Option(type = OptionType.GLOBAL, name = {&quot;-pwf&quot;, &quot;--password-file&quot;}, description = &quot;Path to the JMX password file&quot;)</span>
        private String passwordFilePath = EMPTY;

<span class="fc" id="L359">        @Option(type = OptionType.GLOBAL, name = { &quot;-pp&quot;, &quot;--print-port&quot;}, description = &quot;Operate in 4.0 mode with hosts disambiguated by port number&quot;, arity = 0)</span>
        protected boolean printPort = false;

        private INodeProbeFactory nodeProbeFactory;
        protected Output output;

        @Override
        public void run(INodeProbeFactory nodeProbeFactory, Output output)
        {
<span class="fc" id="L368">            this.nodeProbeFactory = nodeProbeFactory;</span>
<span class="fc" id="L369">            this.output = output;</span>
<span class="fc" id="L370">            runInternal();</span>
<span class="fc" id="L371">        }</span>

        public void runInternal()
        {
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">            if (isNotEmpty(username)) {</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">                if (isNotEmpty(passwordFilePath))</span>
<span class="nc" id="L377">                    password = readUserPasswordFromFile(username, passwordFilePath);</span>

<span class="nc bnc" id="L379" title="All 2 branches missed.">                if (isEmpty(password))</span>
<span class="nc" id="L380">                    password = promptAndReadPassword();</span>
            }

<span class="fc" id="L383">            try (NodeProbe probe = connect())</span>
            {
<span class="fc" id="L385">                execute(probe);</span>
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">                if (probe.isFailed())</span>
<span class="nc" id="L387">                    throw new RuntimeException(&quot;nodetool failed, check server logs&quot;);</span>
            }
<span class="nc" id="L389">            catch (IOException e)</span>
            {
<span class="nc" id="L391">                throw new RuntimeException(&quot;Error while closing JMX connection&quot;, e);</span>
<span class="fc" id="L392">            }</span>

<span class="fc" id="L394">        }</span>

        private String readUserPasswordFromFile(String username, String passwordFilePath) {
<span class="nc" id="L397">            String password = EMPTY;</span>

<span class="nc" id="L399">            File passwordFile = new File(passwordFilePath);</span>
<span class="nc" id="L400">            try (Scanner scanner = new Scanner(passwordFile.toJavaIOFile()).useDelimiter(&quot;\\s+&quot;))</span>
            {
<span class="nc bnc" id="L402" title="All 2 branches missed.">                while (scanner.hasNextLine())</span>
                {
<span class="nc bnc" id="L404" title="All 2 branches missed.">                    if (scanner.hasNext())</span>
                    {
<span class="nc" id="L406">                        String jmxRole = scanner.next();</span>
<span class="nc bnc" id="L407" title="All 4 branches missed.">                        if (jmxRole.equals(username) &amp;&amp; scanner.hasNext())</span>
                        {
<span class="nc" id="L409">                            password = scanner.next();</span>
<span class="nc" id="L410">                            break;</span>
                        }
                    }
<span class="nc" id="L413">                    scanner.nextLine();</span>
                }
            }
<span class="nc" id="L416">            catch (FileNotFoundException e)</span>
            {
<span class="nc" id="L418">                throw new RuntimeException(e);</span>
<span class="nc" id="L419">            }</span>

<span class="nc" id="L421">            return password;</span>
        }

        private String promptAndReadPassword()
        {
<span class="nc" id="L426">            String password = EMPTY;</span>

<span class="nc" id="L428">            Console console = System.console();</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">            if (console != null)</span>
<span class="nc" id="L430">                password = String.valueOf(console.readPassword(&quot;Password:&quot;));</span>

<span class="nc" id="L432">            return password;</span>
        }

        protected abstract void execute(NodeProbe probe);

        private NodeProbe connect()
        {
<span class="fc" id="L439">            NodeProbe nodeClient = null;</span>

            try
            {
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">                if (username.isEmpty())</span>
<span class="fc" id="L444">                    nodeClient = nodeProbeFactory.create(host, parseInt(port));</span>
                else
<span class="nc" id="L446">                    nodeClient = nodeProbeFactory.create(host, parseInt(port), username, password);</span>

<span class="fc" id="L448">                nodeClient.setOutput(output);</span>
<span class="nc" id="L449">            } catch (IOException | SecurityException e)</span>
            {
<span class="nc" id="L451">                Throwable rootCause = Throwables.getRootCause(e);</span>
<span class="nc" id="L452">                output.err.println(format(&quot;nodetool: Failed to connect to '%s:%s' - %s: '%s'.&quot;, host, port, rootCause.getClass().getSimpleName(), rootCause.getMessage()));</span>
<span class="nc" id="L453">                System.exit(1);</span>
<span class="fc" id="L454">            }</span>

<span class="fc" id="L456">            return nodeClient;</span>
        }

<span class="fc" id="L459">        protected enum KeyspaceSet</span>
        {
<span class="fc" id="L461">            ALL, NON_SYSTEM, NON_LOCAL_STRATEGY</span>
        }

        protected List&lt;String&gt; parseOptionalKeyspace(List&lt;String&gt; cmdArgs, NodeProbe nodeProbe)
        {
<span class="fc" id="L466">            return parseOptionalKeyspace(cmdArgs, nodeProbe, KeyspaceSet.ALL);</span>
        }

        protected List&lt;String&gt; parseOptionalKeyspace(List&lt;String&gt; cmdArgs, NodeProbe nodeProbe, KeyspaceSet defaultKeyspaceSet)
        {
<span class="fc" id="L471">            List&lt;String&gt; keyspaces = new ArrayList&lt;&gt;();</span>


<span class="pc bpc" id="L474" title="1 of 4 branches missed.">            if (cmdArgs == null || cmdArgs.isEmpty())</span>
            {
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">                if (defaultKeyspaceSet == KeyspaceSet.NON_LOCAL_STRATEGY)</span>
<span class="nc" id="L477">                    keyspaces.addAll(keyspaces = nodeProbe.getNonLocalStrategyKeyspaces());</span>
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">                else if (defaultKeyspaceSet == KeyspaceSet.NON_SYSTEM)</span>
<span class="nc" id="L479">                    keyspaces.addAll(keyspaces = nodeProbe.getNonSystemKeyspaces());</span>
                else
<span class="fc" id="L481">                    keyspaces.addAll(nodeProbe.getKeyspaces());</span>
            }
            else
            {
<span class="fc" id="L485">                keyspaces.add(cmdArgs.get(0));</span>
            }

<span class="fc bfc" id="L488" title="All 2 branches covered.">            for (String keyspace : keyspaces)</span>
            {
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">                if (!nodeProbe.getKeyspaces().contains(keyspace))</span>
<span class="nc" id="L491">                    throw new IllegalArgumentException(&quot;Keyspace [&quot; + keyspace + &quot;] does not exist.&quot;);</span>
<span class="fc" id="L492">            }</span>

<span class="fc" id="L494">            return Collections.unmodifiableList(keyspaces);</span>
        }

        protected String[] parseOptionalTables(List&lt;String&gt; cmdArgs)
        {
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">            return cmdArgs.size() &lt;= 1 ? EMPTY_STRING_ARRAY : toArray(cmdArgs.subList(1, cmdArgs.size()), String.class);</span>
        }

        protected String[] parsePartitionKeys(List&lt;String&gt; cmdArgs)
        {
<span class="nc bnc" id="L504" title="All 2 branches missed.">            return cmdArgs.size() &lt;= 2 ? EMPTY_STRING_ARRAY : toArray(cmdArgs.subList(2, cmdArgs.size()), String.class);</span>
        }
    }

    public static SortedMap&lt;String, SetHostStatWithPort&gt; getOwnershipByDcWithPort(NodeProbe probe, boolean resolveIp,
                                                                  Map&lt;String, String&gt; tokenToEndpoint,
                                                                  Map&lt;String, Float&gt; ownerships)
    {
<span class="nc" id="L512">        SortedMap&lt;String, SetHostStatWithPort&gt; ownershipByDc = Maps.newTreeMap();</span>
<span class="nc" id="L513">        EndpointSnitchInfoMBean epSnitchInfo = probe.getEndpointSnitchInfoProxy();</span>
        try
        {
<span class="nc bnc" id="L516" title="All 2 branches missed.">            for (Entry&lt;String, String&gt; tokenAndEndPoint : tokenToEndpoint.entrySet())</span>
            {
<span class="nc" id="L518">                String dc = epSnitchInfo.getDatacenter(tokenAndEndPoint.getValue());</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">                if (!ownershipByDc.containsKey(dc))</span>
<span class="nc" id="L520">                    ownershipByDc.put(dc, new SetHostStatWithPort(resolveIp));</span>
<span class="nc" id="L521">                ownershipByDc.get(dc).add(tokenAndEndPoint.getKey(), tokenAndEndPoint.getValue(), ownerships);</span>
<span class="nc" id="L522">            }</span>
        }
<span class="nc" id="L524">        catch (UnknownHostException e)</span>
        {
<span class="nc" id="L526">            throw new RuntimeException(e);</span>
<span class="nc" id="L527">        }</span>
<span class="nc" id="L528">        return ownershipByDc;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>