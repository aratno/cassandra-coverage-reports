<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExceptionHandlers.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.transport</a> &gt; <span class="el_source">ExceptionHandlers.java</span></div><h1>ExceptionHandlers.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.transport;

import java.io.IOException;
import java.net.SocketAddress;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import com.google.common.base.Predicate;
import com.google.common.collect.ImmutableSet;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.channel.ChannelPromise;
import io.netty.channel.unix.Errors;
import org.apache.cassandra.exceptions.OverloadedException;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.metrics.ClientMetrics;
import org.apache.cassandra.net.FrameEncoder;
import org.apache.cassandra.transport.messages.ErrorMessage;
import org.apache.cassandra.utils.JVMStabilityInspector;
import org.apache.cassandra.utils.NoSpamLogger;
import org.apache.cassandra.utils.Throwables;

<span class="nc" id="L46">public class ExceptionHandlers</span>
{
<span class="fc" id="L48">    private static final Logger logger = LoggerFactory.getLogger(ExceptionHandlers.class);</span>

    public static ChannelInboundHandlerAdapter postV5Handler(FrameEncoder.PayloadAllocator allocator,
                                                             ProtocolVersion version)
    {
<span class="fc" id="L53">        return new PostV5ExceptionHandler(allocator, version);</span>
    }

    private static final class PostV5ExceptionHandler extends ChannelInboundHandlerAdapter
    {
        private final FrameEncoder.PayloadAllocator allocator;
        private final ProtocolVersion version;

        public PostV5ExceptionHandler(FrameEncoder.PayloadAllocator allocator, ProtocolVersion version)
<span class="fc" id="L62">        {</span>
<span class="fc" id="L63">            this.allocator = allocator;</span>
<span class="fc" id="L64">            this.version = version;</span>
<span class="fc" id="L65">        }</span>

        @Override
        public void exceptionCaught(final ChannelHandlerContext ctx, Throwable cause)
        {
            // Provide error message to client in case channel is still open
<span class="nc bnc" id="L71" title="All 2 branches missed.">            if (ctx.channel().isOpen())</span>
            {
<span class="nc" id="L73">                Predicate&lt;Throwable&gt; handler = getUnexpectedExceptionHandler(ctx.channel(), false);</span>
<span class="nc" id="L74">                ErrorMessage errorMessage = ErrorMessage.fromException(cause, handler);</span>
<span class="nc" id="L75">                Envelope response = errorMessage.encode(version);</span>
<span class="nc" id="L76">                FrameEncoder.Payload payload = allocator.allocate(true, CQLMessageHandler.envelopeSize(response.header));</span>
                try
                {
<span class="nc" id="L79">                    response.encodeInto(payload.buffer);</span>
<span class="nc" id="L80">                    response.release();</span>
<span class="nc" id="L81">                    payload.finish();</span>
<span class="nc" id="L82">                    ChannelPromise promise = ctx.newPromise();</span>
                    // On protocol exception, close the channel as soon as the message has been sent
<span class="nc bnc" id="L84" title="All 2 branches missed.">                    if (isFatal(cause))</span>
<span class="nc" id="L85">                        promise.addListener(future -&gt; ctx.close());</span>
<span class="nc" id="L86">                    ctx.writeAndFlush(payload, promise);</span>
                }
                finally
                {
<span class="nc" id="L90">                    payload.release();</span>
<span class="nc" id="L91">                    JVMStabilityInspector.inspectThrowable(cause);</span>
                }
            }
            
<span class="nc bnc" id="L95" title="All 2 branches missed.">            if (DatabaseDescriptor.getClientErrorReportingExclusions().contains(ctx.channel().remoteAddress()))</span>
            {
                // Sometimes it is desirable to ignore exceptions from specific IPs; such as when security scans are
                // running.  To avoid polluting logs and metrics, metrics are not updated when the IP is in the exclude
                // list.
<span class="nc" id="L100">                logger.debug(&quot;Excluding client exception for {}; address contained in client_error_reporting_exclusions&quot;, ctx.channel().remoteAddress(), cause);</span>
<span class="nc" id="L101">                return;</span>
            }
<span class="nc" id="L103">            logClientNetworkingExceptions(cause);</span>
<span class="nc" id="L104">        }</span>

        private static boolean isFatal(Throwable cause)
        {
<span class="nc bnc" id="L108" title="All 2 branches missed.">            return Throwables.anyCauseMatches(cause, t -&gt; t instanceof ProtocolException</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">                                                          &amp;&amp; ((ProtocolException)t).isFatal());</span>
        }
    }

    static void logClientNetworkingExceptions(Throwable cause)
    {
<span class="nc bnc" id="L115" title="All 2 branches missed.">        if (Throwables.anyCauseMatches(cause, t -&gt; t instanceof ProtocolException))</span>
        {
            // if any ProtocolExceptions is not silent, then handle
<span class="nc bnc" id="L118" title="All 6 branches missed.">            if (Throwables.anyCauseMatches(cause, t -&gt; t instanceof ProtocolException &amp;&amp; !((ProtocolException) t).isSilent()))</span>
            {
<span class="nc" id="L120">                ClientMetrics.instance.markProtocolException();</span>
                // since protocol exceptions are expected to be client issues, not logging stack trace
                // to avoid spamming the logs once a bad client shows up
<span class="nc" id="L123">                NoSpamLogger.log(logger, NoSpamLogger.Level.WARN, 1, TimeUnit.MINUTES, &quot;Protocol exception with client networking: &quot; + cause.getMessage());</span>
            }
        }
<span class="nc bnc" id="L126" title="All 2 branches missed.">        else if (Throwables.anyCauseMatches(cause, t -&gt; t instanceof OverloadedException))</span>
        {
            // Once the threshold for overload is breached, it will very likely spam the logs...
<span class="nc" id="L129">            NoSpamLogger.log(logger, NoSpamLogger.Level.INFO, 1, TimeUnit.MINUTES, cause.getMessage());</span>
        }
<span class="nc bnc" id="L131" title="All 2 branches missed.">        else if (Throwables.anyCauseMatches(cause, t -&gt; t instanceof Errors.NativeIoException))</span>
        {
<span class="nc" id="L133">            ClientMetrics.instance.markUnknownException();</span>
<span class="nc" id="L134">            logger.trace(&quot;Native exception in client networking&quot;, cause);</span>
        }
        else
        {
<span class="nc" id="L138">            ClientMetrics.instance.markUnknownException();</span>
<span class="nc" id="L139">            logger.warn(&quot;Unknown exception in client networking&quot;, cause);</span>
        }
<span class="nc" id="L141">    }</span>

    static Predicate&lt;Throwable&gt; getUnexpectedExceptionHandler(Channel channel, boolean alwaysLogAtError)
    {
<span class="nc" id="L145">        SocketAddress address = channel.remoteAddress();</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (DatabaseDescriptor.getClientErrorReportingExclusions().contains(address))</span>
        {
<span class="nc" id="L148">            return cause -&gt; {</span>
<span class="nc" id="L149">                logger.debug(&quot;Excluding client exception for {}; address contained in client_error_reporting_exclusions&quot;, address, cause);</span>
<span class="nc" id="L150">                return true;</span>
            };
        }
<span class="nc" id="L153">        return new UnexpectedChannelExceptionHandler(channel, alwaysLogAtError);</span>
    }

    /**
     * Include the channel info in the logged information for unexpected errors, and (if {@link #alwaysLogAtError} is
     * false then choose the log level based on the type of exception (some are clearly client issues and shouldn't be
     * logged at server ERROR level)
     */
    static final class UnexpectedChannelExceptionHandler implements Predicate&lt;Throwable&gt;
    {

        /**
         * When we encounter an unexpected IOException we look for these {@link Throwable#getMessage() messages}
         * (because we have no better way to distinguish) and log them at DEBUG rather than INFO, since they
         * are generally caused by unclean client disconnects rather than an actual problem.
         */
        private static final Set&lt;String&gt; ioExceptionsAtDebugLevel = ImmutableSet.&lt;String&gt;builder().
            add(&quot;Connection reset by peer&quot;).
            add(&quot;Broken pipe&quot;).
            add(&quot;Connection timed out&quot;).
            build();

        private final Channel channel;
        private final boolean alwaysLogAtError;

        UnexpectedChannelExceptionHandler(Channel channel, boolean alwaysLogAtError)
        {
            this.channel = channel;
            this.alwaysLogAtError = alwaysLogAtError;
        }

        @Override
        public boolean apply(Throwable exception)
        {
            String message;
            try
            {
                message = &quot;Unexpected exception during request; channel = &quot; + channel;
            }
            catch (Exception ignore)
            {
                // We don't want to make things worse if String.valueOf() throws an exception
                message = &quot;Unexpected exception during request; channel = &lt;unprintable&gt;&quot;;
            }

            // netty wraps SSL errors in a CodecExcpetion
            if (!alwaysLogAtError &amp;&amp; (exception instanceof IOException || (exception.getCause() instanceof IOException)))
            {
                String errorMessage = exception.getMessage();
                boolean logAtTrace = false;

                for (String ioException : ioExceptionsAtDebugLevel)
                {
                    // exceptions thrown from the netty epoll transport add the name of the function that failed
                    // to the exception string (which is simply wrapping a JDK exception), so we can't do a simple/naive comparison
                    if (errorMessage.contains(ioException))
                    {
                        logAtTrace = true;
                        break;
                    }
                }

                if (logAtTrace)
                {
                    // Likely unclean client disconnects
                    logger.trace(message, exception);
                }
                else
                {
                    // Generally unhandled IO exceptions are network issues, not actual ERRORS
                    logger.info(message, exception);
                }
            }
            else
            {
                // Anything else is probably a bug in server of client binary protocol handling
                logger.error(message, exception);
            }

            // We handled the exception.
            return true;
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>