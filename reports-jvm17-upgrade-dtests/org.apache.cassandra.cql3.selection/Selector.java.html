<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Selector.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.selection</a> &gt; <span class="el_source">Selector.java</span></div><h1>Selector.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3.selection;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.List;

import org.apache.cassandra.cql3.ColumnIdentifier;
import org.apache.cassandra.cql3.ColumnSpecification;
import org.apache.cassandra.cql3.QueryOptions;
import org.apache.cassandra.cql3.functions.Function;
import org.apache.cassandra.cql3.selection.ColumnTimestamps.TimestampsType;
import org.apache.cassandra.db.TypeSizes;
import org.apache.cassandra.db.context.CounterContext;
import org.apache.cassandra.db.filter.ColumnFilter;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.marshal.CollectionType;
import org.apache.cassandra.db.marshal.UserType;
import org.apache.cassandra.db.rows.Cell;
import org.apache.cassandra.db.rows.ColumnData;
import org.apache.cassandra.db.rows.ComplexColumnData;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.schema.CQLTypeParser;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.KeyspaceMetadata;
import org.apache.cassandra.schema.Schema;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.transport.ProtocolVersion;
import org.apache.cassandra.utils.ByteBufferUtil;

import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;

/**
 * A &lt;code&gt;Selector&lt;/code&gt; is used to convert the data returned by the storage engine into the data requested by the
 * user. They correspond to the &amp;lt;selector&amp;gt; elements from the select clause.
 * &lt;p&gt;Since the introduction of aggregation, &lt;code&gt;Selector&lt;/code&gt;s cannot be called anymore by multiple threads
 * as they have an internal state.&lt;/p&gt;
 */
public abstract class Selector
{
<span class="fc" id="L60">    protected static abstract class SelectorDeserializer</span>
    {
        protected abstract Selector deserialize(DataInputPlus in, int version, TableMetadata metadata) throws IOException;

        protected final AbstractType&lt;?&gt; readType(TableMetadata metadata, DataInputPlus in) throws IOException
        {
<span class="nc" id="L66">            KeyspaceMetadata keyspace = Schema.instance.getKeyspaceMetadata(metadata.keyspace);</span>
<span class="nc" id="L67">            return readType(keyspace, in);</span>
        }

        protected final AbstractType&lt;?&gt; readType(KeyspaceMetadata keyspace, DataInputPlus in) throws IOException
        {
<span class="nc" id="L72">            String cqlType = in.readUTF();</span>
<span class="nc" id="L73">            return CQLTypeParser.parse(keyspace.name, cqlType, keyspace.types);</span>
        }
    }

    /**
     * The &lt;code&gt;Selector&lt;/code&gt; kinds.
     */
<span class="fc" id="L80">    public enum Kind</span>
    {
<span class="fc" id="L82">        SIMPLE_SELECTOR(SimpleSelector.deserializer),</span>
<span class="fc" id="L83">        TERM_SELECTOR(TermSelector.deserializer),</span>
<span class="fc" id="L84">        WRITETIME_OR_TTL_SELECTOR(WritetimeOrTTLSelector.deserializer),</span>
<span class="fc" id="L85">        LIST_SELECTOR(ListSelector.deserializer),</span>
<span class="fc" id="L86">        SET_SELECTOR(SetSelector.deserializer),</span>
<span class="fc" id="L87">        MAP_SELECTOR(MapSelector.deserializer),</span>
<span class="fc" id="L88">        TUPLE_SELECTOR(TupleSelector.deserializer),</span>
<span class="fc" id="L89">        USER_TYPE_SELECTOR(UserTypeSelector.deserializer),</span>
<span class="fc" id="L90">        FIELD_SELECTOR(FieldSelector.deserializer),</span>
<span class="fc" id="L91">        SCALAR_FUNCTION_SELECTOR(ScalarFunctionSelector.deserializer),</span>
<span class="fc" id="L92">        AGGREGATE_FUNCTION_SELECTOR(AggregateFunctionSelector.deserializer),</span>
<span class="fc" id="L93">        ELEMENT_SELECTOR(ElementsSelector.ElementSelector.deserializer),</span>
<span class="fc" id="L94">        SLICE_SELECTOR(ElementsSelector.SliceSelector.deserializer),</span>
<span class="fc" id="L95">        VECTOR_SELECTOR(VectorSelector.deserializer);</span>

        private final SelectorDeserializer deserializer;

        Kind(SelectorDeserializer deserializer)
<span class="fc" id="L100">        {</span>
<span class="fc" id="L101">            this.deserializer = deserializer;</span>
<span class="fc" id="L102">        }</span>
    }

    /**
     * A factory for &lt;code&gt;Selector&lt;/code&gt; instances.
     */
<span class="fc" id="L108">    public static abstract class Factory</span>
    {
        public void addFunctionsTo(List&lt;Function&gt; functions)
        {
<span class="nc" id="L112">        }</span>

        /**
         * Returns the column specification corresponding to the output value of the selector instances created by
         * this factory.
         *
         * @param table the table meta data
         * @return a column specification
         */
        public ColumnSpecification getColumnSpecification(TableMetadata table)
        {
<span class="fc" id="L123">            return new ColumnSpecification(table.keyspace,</span>
                                           table.name,
<span class="fc" id="L125">                                           new ColumnIdentifier(getColumnName(), true), // note that the name is not necessarily</span>
                                                                                        // a true column name so we shouldn't intern it
<span class="fc" id="L127">                                           getReturnType());</span>
        }

        /**
         * Creates a new &lt;code&gt;Selector&lt;/code&gt; instance.
         *
         * @param options the options of the query for which the instance is created (some selector
         * depends on the bound values in particular).
         * @return a new &lt;code&gt;Selector&lt;/code&gt; instance
         */
        public abstract Selector newInstance(QueryOptions options);

        /**
         * Checks if this factory creates selectors instances that creates aggregates.
         *
         * @return &lt;code&gt;true&lt;/code&gt; if this factory creates selectors instances that creates aggregates,
         * &lt;code&gt;false&lt;/code&gt; otherwise
         */
        public boolean isAggregateSelectorFactory()
        {
<span class="fc" id="L147">            return false;</span>
        }

        /**
         * Checks if this factory creates &lt;code&gt;writetime&lt;/code&gt; selectors instances.
         *
         * @return &lt;code&gt;true&lt;/code&gt; if this factory creates &lt;code&gt;writetime&lt;/code&gt; selectors instances,
         * &lt;code&gt;false&lt;/code&gt; otherwise
         */
        public boolean isWritetimeSelectorFactory()
        {
<span class="fc" id="L158">            return false;</span>
        }

        /**
         * Checks if this factory creates &lt;code&gt;maxwritetime&lt;/code&gt; selector instances.
         *
         * @return &lt;code&gt;true&lt;/code&gt; if this factory creates &lt;code&gt;maxwritetime&lt;/code&gt; selectors instances,
         * &lt;code&gt;false&lt;/code&gt; otherwise
         */
        public boolean isMaxWritetimeSelectorFactory()
        {
<span class="fc" id="L169">            return false;</span>
        }

        /**
         * Checks if this factory creates &lt;code&gt;TTL&lt;/code&gt; selectors instances.
         *
         * @return &lt;code&gt;true&lt;/code&gt; if this factory creates &lt;code&gt;TTL&lt;/code&gt; selectors instances,
         * &lt;code&gt;false&lt;/code&gt; otherwise
         */
        public boolean isTTLSelectorFactory()
        {
<span class="fc" id="L180">            return false;</span>
        }

        /**
         * Checks if this factory creates &lt;code&gt;Selector&lt;/code&gt;s that simply return a column value.
         *
         * @return &lt;code&gt;true&lt;/code&gt; if this factory creates &lt;code&gt;Selector&lt;/code&gt;s that simply return a column value,
         * &lt;code&gt;false&lt;/code&gt; otherwise.
         */
        public boolean isSimpleSelectorFactory()
        {
<span class="nc" id="L191">            return false;</span>
        }

        /**
         * Checks if this factory creates &lt;code&gt;Selector&lt;/code&gt;s that simply return the specified column.
         *
         * @param index the column index
         * @return &lt;code&gt;true&lt;/code&gt; if this factory creates &lt;code&gt;Selector&lt;/code&gt;s that simply return
         * the specified column, &lt;code&gt;false&lt;/code&gt; otherwise.
         */
        public boolean isSimpleSelectorFactoryFor(int index)
        {
<span class="nc" id="L203">            return false;</span>
        }

        /**
         * Returns the name of the column corresponding to the output value of the selector instances created by
         * this factory.
         *
         * @return a column name
         */
        protected abstract String getColumnName();

        /**
         * Returns the type of the values returned by the selector instances created by this factory.
         *
         * @return the selector output type
         */
        protected abstract AbstractType&lt;?&gt; getReturnType();

        /**
         * Record a mapping between the ColumnDefinitions that are used by the selector
         * instances created by this factory and a column in the ResultSet.Metadata
         * returned with a query. In most cases, this is likely to be a 1:1 mapping,
         * but some selector instances may utilise multiple columns (or none at all)
         * to produce a value (i.e. functions).
         *
         * @param mapping the instance of the column mapping belonging to the current query's Selection
         * @param resultsColumn the column in the ResultSet.Metadata to which the ColumnDefinitions used
         *                      by the Selector are to be mapped
         */
        protected abstract void addColumnMapping(SelectionColumnMapping mapping, ColumnSpecification resultsColumn);

        /**
         * Checks if all the columns fetched by the selector created by this factory are known
         * @return {@code true} if all the columns fetched by the selector created by this factory are known,
         * {@code false} otherwise.
         */
        abstract boolean areAllFetchedColumnsKnown();

        /**
         * Adds the columns fetched by the selector created by this factory to the provided builder, assuming the
         * factory is terminal (i.e. that {@code isTerminal() == true}).
         *
         * @param builder the column builder to add fetched columns (and potential subselection) to.
         * @throws AssertionError if the method is called on a factory where {@code isTerminal()} returns {@code false}.
         */
        abstract void addFetchedColumns(ColumnFilter.Builder builder);
    }

<span class="fc" id="L251">    public static class Serializer</span>
    {
        public void serialize(Selector selector, DataOutputPlus out, int version) throws IOException
        {
<span class="nc" id="L255">            out.writeByte(selector.kind().ordinal());</span>
<span class="nc" id="L256">            selector.serialize(out, version);</span>
<span class="nc" id="L257">        }</span>

        public Selector deserialize(DataInputPlus in, int version, TableMetadata metadata) throws IOException
        {
<span class="nc" id="L261">            Kind kind = Kind.values()[in.readUnsignedByte()];</span>
<span class="nc" id="L262">            return kind.deserializer.deserialize(in, version, metadata);</span>
        }

        public int serializedSize(Selector selector, int version)
        {
<span class="nc" id="L267">            return TypeSizes.sizeof((byte) selector.kind().ordinal()) + selector.serializedSize(version);</span>
        }
    }

    /**
     * The {@code Selector} serializer.
     */
<span class="fc" id="L274">    public static final Serializer serializer = new Serializer();</span>

    /**
     * The {@code Selector} kind.
     */
    private final Kind kind;

    /**
     * Returns the {@code Selector} kind.
     * @return the {@code Selector} kind
     */
    public final Kind kind()
    {
<span class="nc" id="L287">        return kind;</span>
    }

    protected Selector(Kind kind)
<span class="fc" id="L291">    {</span>
<span class="fc" id="L292">        this.kind = kind;</span>
<span class="fc" id="L293">    }</span>

    /**
     * Add to the provided builder the column (and potential subselections) to fetch for this
     * selection.
     *
     * @param builder the builder to add columns and subselections to.
     */
    public abstract void addFetchedColumns(ColumnFilter.Builder builder);

    /**
     * A row of data that need to be processed by a {@code Selector}
     */
    public static final class InputRow
    {
        private final ProtocolVersion protocolVersion;
        private final List&lt;ColumnMetadata&gt; columns;
        private final boolean unmask;
        private final boolean collectWritetimes;
        private final boolean collectTTLs;

        private ByteBuffer[] values;
        private RowTimestamps writetimes;
        private RowTimestamps ttls;
        private int index;

        public InputRow(ProtocolVersion protocolVersion, List&lt;ColumnMetadata&gt; columns, boolean unmask)
        {
<span class="nc" id="L321">            this(protocolVersion, columns, unmask, false, false);</span>
<span class="nc" id="L322">        }</span>

        public InputRow(ProtocolVersion protocolVersion,
                        List&lt;ColumnMetadata&gt; columns,
                        boolean unmask,
                        boolean collectWritetimes,
                        boolean collectTTLs)
<span class="fc" id="L329">        {</span>
<span class="fc" id="L330">            this.protocolVersion = protocolVersion;</span>
<span class="fc" id="L331">            this.columns = columns;</span>
<span class="fc" id="L332">            this.unmask = unmask;</span>
<span class="fc" id="L333">            this.collectWritetimes = collectWritetimes;</span>
<span class="fc" id="L334">            this.collectTTLs = collectTTLs;</span>

<span class="fc" id="L336">            values = new ByteBuffer[columns.size()];</span>
<span class="fc" id="L337">            writetimes = initTimestamps(TimestampsType.WRITETIMES, collectWritetimes, columns);</span>
<span class="fc" id="L338">            ttls = initTimestamps(TimestampsType.TTLS, collectTTLs, columns);</span>
<span class="fc" id="L339">        }</span>

        private RowTimestamps initTimestamps(TimestampsType type,
                                             boolean collectWritetimes,
                                             List&lt;ColumnMetadata&gt; columns)
        {
<span class="fc bfc" id="L345" title="All 2 branches covered.">            return collectWritetimes ? RowTimestamps.newInstance(type, columns)</span>
<span class="fc" id="L346">                                     : RowTimestamps.NOOP_ROW_TIMESTAMPS;</span>
        }

        public ProtocolVersion getProtocolVersion()
        {
<span class="fc" id="L351">            return protocolVersion;</span>
        }

        public boolean unmask()
        {
<span class="nc" id="L356">            return unmask;</span>
        }

        public void add(ByteBuffer v)
        {
<span class="fc" id="L361">            values[index] = v;</span>

<span class="fc bfc" id="L363" title="All 2 branches covered.">            if (v != null)</span>
            {
<span class="fc" id="L365">                writetimes.addNoTimestamp(index);</span>
<span class="fc" id="L366">                ttls.addNoTimestamp(index);</span>
            }
<span class="fc" id="L368">            index++;</span>
<span class="fc" id="L369">        }</span>

        public void add(ColumnData columnData, long nowInSec)
        {
<span class="fc" id="L373">            ColumnMetadata column = columns.get(index);</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">            if (columnData == null)</span>
            {
<span class="fc" id="L376">                add(null);</span>
            }
            else
            {
<span class="fc bfc" id="L380" title="All 2 branches covered.">                if (column.isComplex())</span>
                {
<span class="fc" id="L382">                    add((ComplexColumnData) columnData, nowInSec);</span>
                }
                else
                {
<span class="fc" id="L386">                    add((Cell&lt;?&gt;) columnData, nowInSec);</span>
                }
            }
<span class="fc" id="L389">        }</span>

        private void add(Cell&lt;?&gt; c, long nowInSec)
        {
<span class="fc" id="L393">            values[index] = value(c);</span>
<span class="fc" id="L394">            writetimes.addTimestamp(index, c, nowInSec);</span>
<span class="fc" id="L395">            ttls.addTimestamp(index, c, nowInSec);</span>
<span class="fc" id="L396">            index++;</span>
<span class="fc" id="L397">        }</span>

        private void add(ComplexColumnData ccd, long nowInSec)
        {
<span class="fc" id="L401">            AbstractType&lt;?&gt; type = columns.get(index).type;</span>
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">            if (type.isCollection())</span>
            {
<span class="fc" id="L404">                values[index] = ((CollectionType&lt;?&gt;) type).serializeForNativeProtocol(ccd.iterator());</span>

<span class="fc bfc" id="L406" title="All 2 branches covered.">                for (Cell&lt;?&gt; cell : ccd)</span>
                {
<span class="fc" id="L408">                    writetimes.addTimestamp(index, cell, nowInSec);</span>
<span class="fc" id="L409">                    ttls.addTimestamp(index, cell, nowInSec);</span>
<span class="fc" id="L410">                }</span>
            }
            else
            {
<span class="nc" id="L414">                UserType udt = (UserType) type;</span>
<span class="nc" id="L415">                int size = udt.size();</span>

<span class="nc" id="L417">                values[index] = udt.serializeForNativeProtocol(ccd.iterator(), protocolVersion);</span>

<span class="nc" id="L419">                short fieldPosition = 0;</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">                for (Cell&lt;?&gt; cell : ccd)</span>
                {
                    // handle null fields that aren't at the end
<span class="nc" id="L423">                    short fieldPositionOfCell = ByteBufferUtil.toShort(cell.path().get(0));</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">                    while (fieldPosition &lt; fieldPositionOfCell)</span>
                    {
<span class="nc" id="L426">                        fieldPosition++;</span>
<span class="nc" id="L427">                        writetimes.addNoTimestamp(index);</span>
<span class="nc" id="L428">                        ttls.addNoTimestamp(index);</span>
                    }

<span class="nc" id="L431">                    fieldPosition++;</span>
<span class="nc" id="L432">                    writetimes.addTimestamp(index, cell, nowInSec);</span>
<span class="nc" id="L433">                    ttls.addTimestamp(index, cell, nowInSec);</span>
<span class="nc" id="L434">                }</span>

                // append nulls for missing cells
<span class="nc bnc" id="L437" title="All 2 branches missed.">                while (fieldPosition &lt; size)</span>
                {
<span class="nc" id="L439">                    fieldPosition++;</span>
<span class="nc" id="L440">                    writetimes.addNoTimestamp(index);</span>
<span class="nc" id="L441">                    ttls.addNoTimestamp(index);</span>
                }
            }
<span class="fc" id="L444">            index++;</span>
<span class="fc" id="L445">        }</span>

        private &lt;V&gt; ByteBuffer value(Cell&lt;V&gt; c)
        {
<span class="pc bpc" id="L449" title="1 of 2 branches missed.">            return c.isCounterCell()</span>
<span class="nc" id="L450">                 ? ByteBufferUtil.bytes(CounterContext.instance().total(c.value(), c.accessor()))</span>
<span class="fc" id="L451">                 : c.buffer();</span>
        }

        /**
         * Return the value of the column with the specified index.
         *
         * @param index the column index
         * @return the value of the column with the specified index
         */
        public ByteBuffer getValue(int index)
        {
<span class="fc" id="L462">            return values[index];</span>
        }

        /**
         * Reset the row internal state.
         * &lt;p&gt;If the reset is not a deep one only the index will be reset. If the reset is a deep one a new
         * array will be created to store the column values. This allow to reduce object creation when it is not
         * necessary.&lt;/p&gt;
         *
         * @param deep {@code true} if the reset must be a deep one.
         */
        public void reset(boolean deep)
        {
<span class="fc" id="L475">            index = 0;</span>
<span class="fc" id="L476">            this.writetimes = initTimestamps(TimestampsType.WRITETIMES, collectWritetimes, columns);</span>
<span class="fc" id="L477">            this.ttls = initTimestamps(TimestampsType.TTLS, collectTTLs, columns);</span>

<span class="fc bfc" id="L479" title="All 2 branches covered.">            if (deep)</span>
<span class="fc" id="L480">                values = new ByteBuffer[values.length];</span>
<span class="fc" id="L481">        }</span>

        /**
         * Return the timestamp of the column component with the specified indexes.
         *
         * @return the timestamp of the cell with the specified indexes
         */
        ColumnTimestamps getWritetimes(int columnIndex)
        {
<span class="fc" id="L490">            return writetimes.get(columnIndex);</span>
        }

        /**
         * Return the ttl of the column component with the specified column and cell indexes.
         *
         * @param columnIndex the column index
         * @return the ttl of the column with the specified indexes
         */
        ColumnTimestamps getTtls(int columnIndex)
        {
<span class="fc" id="L501">            return ttls.get(columnIndex);</span>
        }

        /**
         * Returns the column values as list.
         * &lt;p&gt;This content of the list will be shared with the {@code InputRow} unless a deep reset has been done.&lt;/p&gt;
         *
         * @return the column values as list.
         */
        public List&lt;ByteBuffer&gt; getValues()
        {
<span class="fc" id="L512">            return Arrays.asList(values);</span>
        }
    }

    /**
     * Add the current value from the specified &lt;code&gt;ResultSetBuilder&lt;/code&gt;.
     *
     * @param input the input row
     * @throws InvalidRequestException if a problem occurs while adding the input row
     */
    public abstract void addInput(InputRow input);

    /**
     * Returns the selector output.
     *
     * @param protocolVersion protocol version used for serialization
     * @return the selector output
     * @throws InvalidRequestException if a problem occurs while computing the output value
     */
    public abstract ByteBuffer getOutput(ProtocolVersion protocolVersion) throws InvalidRequestException;

    protected ColumnTimestamps getWritetimes(ProtocolVersion protocolVersion)
    {
<span class="nc" id="L535">        throw new UnsupportedOperationException();</span>
    }

    protected ColumnTimestamps getTTLs(ProtocolVersion protocolVersion)
    {
<span class="nc" id="L540">        throw new UnsupportedOperationException();</span>
    }

    /**
     * Returns the &lt;code&gt;Selector&lt;/code&gt; output type.
     *
     * @return the &lt;code&gt;Selector&lt;/code&gt; output type.
     */
    public abstract AbstractType&lt;?&gt; getType();

    /**
     * Reset the internal state of this &lt;code&gt;Selector&lt;/code&gt;.
     */
    public abstract void reset();

    /**
     * A selector is terminal if it doesn't require any input for it's output to be computed, i.e. if {@link #getOutput}
     * result doesn't depend of {@link #addInput}. This is typically the case of a constant value or functions on constant
     * values.
     */
    public boolean isTerminal()
    {
<span class="nc" id="L562">        return false;</span>
    }

    /**
     * Checks that this selector is valid for GROUP BY clause.
     */
    public void validateForGroupBy()
    {
<span class="nc" id="L570">        throw invalidRequest(&quot;Only column names and monotonic scalar functions are supported in the GROUP BY clause.&quot;);</span>
    }

    protected abstract int serializedSize(int version);

    protected abstract void serialize(DataOutputPlus out, int version) throws IOException;

    protected static void writeType(DataOutputPlus out, AbstractType&lt;?&gt; type) throws IOException
    {
<span class="nc" id="L579">        out.writeUTF(type.asCQL3Type().toString());</span>
<span class="nc" id="L580">    }</span>

    protected static int sizeOf(AbstractType&lt;?&gt; type)
    {
<span class="nc" id="L584">        return TypeSizes.sizeof(type.asCQL3Type().toString());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>