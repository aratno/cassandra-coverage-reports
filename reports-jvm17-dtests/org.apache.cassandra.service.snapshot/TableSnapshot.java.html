<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TableSnapshot.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.service.snapshot</a> &gt; <span class="el_source">TableSnapshot.java</span></div><h1>TableSnapshot.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.service.snapshot;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Instant;
import java.util.Collection;
import java.util.HashSet;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.function.Predicate;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.db.Directories;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.utils.DirectorySizeCalculator;

public class TableSnapshot
{
<span class="fc" id="L42">    private static final Logger logger = LoggerFactory.getLogger(TableSnapshot.class);</span>

    private final String keyspaceName;
    private final String tableName;
    private final UUID tableId;
    private final String tag;
    private final boolean ephemeral;

    private final Instant createdAt;
    private final Instant expiresAt;

    private final Set&lt;File&gt; snapshotDirs;

    public TableSnapshot(String keyspaceName, String tableName, UUID tableId,
                         String tag, Instant createdAt, Instant expiresAt,
                         Set&lt;File&gt; snapshotDirs, boolean ephemeral)
<span class="fc" id="L58">    {</span>
<span class="fc" id="L59">        this.keyspaceName = keyspaceName;</span>
<span class="fc" id="L60">        this.tableName = tableName;</span>
<span class="fc" id="L61">        this.tableId = tableId;</span>
<span class="fc" id="L62">        this.tag = tag;</span>
<span class="fc" id="L63">        this.createdAt = createdAt;</span>
<span class="fc" id="L64">        this.expiresAt = expiresAt;</span>
<span class="fc" id="L65">        this.snapshotDirs = snapshotDirs;</span>
<span class="fc" id="L66">        this.ephemeral = ephemeral;</span>
<span class="fc" id="L67">    }</span>

    /**
     * Unique identifier of a snapshot. Used
     * only to deduplicate snapshots internally,
     * not exposed externally.
     *
     * Format: &quot;$ks:$table_name:$table_id:$tag&quot;
     */
    public String getId()
    {
<span class="fc" id="L78">        return buildSnapshotId(keyspaceName, tableName, tableId, tag);</span>
    }

    public String getKeyspaceName()
    {
<span class="fc" id="L83">        return keyspaceName;</span>
    }

    public String getTableName()
    {
<span class="fc" id="L88">        return tableName;</span>
    }

    public String getTag()
    {
<span class="fc" id="L93">        return tag;</span>
    }

    public Instant getCreatedAt()
    {
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">        if (createdAt == null)</span>
        {
<span class="nc" id="L100">            long minCreation = snapshotDirs.stream().mapToLong(File::lastModified).min().orElse(0);</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">            if (minCreation != 0)</span>
            {
<span class="nc" id="L103">                return Instant.ofEpochMilli(minCreation);</span>
            }
        }
<span class="fc" id="L106">        return createdAt;</span>
    }

    public Instant getExpiresAt()
    {
<span class="fc" id="L111">        return expiresAt;</span>
    }

    public boolean isExpired(Instant now)
    {
<span class="pc bpc" id="L116" title="2 of 4 branches missed.">        if (createdAt == null || expiresAt == null)</span>
        {
<span class="nc" id="L118">            return false;</span>
        }

<span class="fc bfc" id="L121" title="All 2 branches covered.">        return expiresAt.compareTo(now) &lt; 0;</span>
    }

    public boolean exists()
    {
<span class="nc" id="L126">        return snapshotDirs.stream().anyMatch(File::exists);</span>
    }

    public boolean isEphemeral()
    {
<span class="fc" id="L131">        return ephemeral;</span>
    }

    public boolean isExpiring()
    {
<span class="fc bfc" id="L136" title="All 2 branches covered.">        return expiresAt != null;</span>
    }

    public long computeSizeOnDiskBytes()
    {
<span class="fc" id="L141">        return snapshotDirs.stream().mapToLong(FileUtils::folderSize).sum();</span>
    }

    public long computeTrueSizeBytes()
    {
<span class="fc" id="L146">        DirectorySizeCalculator visitor = new SnapshotTrueSizeCalculator();</span>

<span class="fc bfc" id="L148" title="All 2 branches covered.">        for (File snapshotDir : snapshotDirs)</span>
        {
            try
            {
<span class="fc" id="L152">                Files.walkFileTree(snapshotDir.toPath(), visitor);</span>
            }
<span class="nc" id="L154">            catch (IOException e)</span>
            {
<span class="nc" id="L156">                logger.error(&quot;Could not calculate the size of {}.&quot;, snapshotDir, e);</span>
<span class="fc" id="L157">            }</span>
<span class="fc" id="L158">        }</span>

<span class="fc" id="L160">        return visitor.getAllocatedSize();</span>
    }

    public Collection&lt;File&gt; getDirectories()
    {
<span class="fc" id="L165">        return snapshotDirs;</span>
    }

    public Optional&lt;File&gt; getManifestFile()
    {
<span class="nc bnc" id="L170" title="All 2 branches missed.">        for (File snapshotDir : snapshotDirs)</span>
        {
<span class="nc" id="L172">            File manifestFile = Directories.getSnapshotManifestFile(snapshotDir);</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">            if (manifestFile.exists())</span>
            {
<span class="nc" id="L175">                return Optional.of(manifestFile);</span>
            }
<span class="nc" id="L177">        }</span>
<span class="nc" id="L178">        return Optional.empty();</span>
    }

    public Optional&lt;File&gt; getSchemaFile()
    {
<span class="nc bnc" id="L183" title="All 2 branches missed.">        for (File snapshotDir : snapshotDirs)</span>
        {
<span class="nc" id="L185">            File schemaFile = Directories.getSnapshotSchemaFile(snapshotDir);</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">            if (schemaFile.exists())</span>
            {
<span class="nc" id="L188">                return Optional.of(schemaFile);</span>
            }
<span class="nc" id="L190">        }</span>
<span class="nc" id="L191">        return Optional.empty();</span>
    }

    @Override
    public boolean equals(Object o)
    {
<span class="fc bfc" id="L197" title="All 2 branches covered.">        if (this == o) return true;</span>
<span class="pc bpc" id="L198" title="2 of 4 branches missed.">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L199">        TableSnapshot snapshot = (TableSnapshot) o;</span>
<span class="fc bfc" id="L200" title="All 4 branches covered.">        return Objects.equals(keyspaceName, snapshot.keyspaceName) &amp;&amp; Objects.equals(tableName, snapshot.tableName) &amp;&amp;</span>
<span class="pc bpc" id="L201" title="1 of 4 branches missed.">               Objects.equals(tableId, snapshot.tableId) &amp;&amp; Objects.equals(tag, snapshot.tag) &amp;&amp;</span>
<span class="pc bpc" id="L202" title="2 of 4 branches missed.">               Objects.equals(createdAt, snapshot.createdAt) &amp;&amp; Objects.equals(expiresAt, snapshot.expiresAt) &amp;&amp;</span>
<span class="pc bpc" id="L203" title="2 of 4 branches missed.">               Objects.equals(snapshotDirs, snapshot.snapshotDirs) &amp;&amp; Objects.equals(ephemeral, snapshot.ephemeral);</span>
    }

    @Override
    public int hashCode()
    {
<span class="fc" id="L209">        return Objects.hash(keyspaceName, tableName, tableId, tag, createdAt, expiresAt, snapshotDirs, ephemeral);</span>
    }

    @Override
    public String toString()
    {
<span class="fc" id="L215">        return &quot;TableSnapshot{&quot; +</span>
               &quot;keyspaceName='&quot; + keyspaceName + '\'' +
               &quot;, tableName='&quot; + tableName + '\'' +
               &quot;, tableId=&quot; + tableId +
               &quot;, tag='&quot; + tag + '\'' +
               &quot;, createdAt=&quot; + createdAt +
               &quot;, expiresAt=&quot; + expiresAt +
               &quot;, snapshotDirs=&quot; + snapshotDirs +
               &quot;, ephemeral=&quot; + ephemeral +
               '}';
    }

    static class Builder {
        private final String keyspaceName;
        private final String tableName;
        private final UUID tableId;
        private final String tag;

<span class="fc" id="L233">        private Instant createdAt = null;</span>
<span class="fc" id="L234">        private Instant expiresAt = null;</span>
        private boolean ephemeral;

<span class="fc" id="L237">        private final Set&lt;File&gt; snapshotDirs = new HashSet&lt;&gt;();</span>

        Builder(String keyspaceName, String tableName, UUID tableId, String tag)
<span class="fc" id="L240">        {</span>
<span class="fc" id="L241">            this.keyspaceName = keyspaceName;</span>
<span class="fc" id="L242">            this.tableName = tableName;</span>
<span class="fc" id="L243">            this.tag = tag;</span>
<span class="fc" id="L244">            this.tableId = tableId;</span>
<span class="fc" id="L245">        }</span>

        void addSnapshotDir(File snapshotDir)
        {
<span class="fc" id="L249">            snapshotDirs.add(snapshotDir);</span>
<span class="fc" id="L250">            File manifestFile = new File(snapshotDir, &quot;manifest.json&quot;);</span>
<span class="pc bpc" id="L251" title="2 of 6 branches missed.">            if (manifestFile.exists() &amp;&amp; createdAt == null &amp;&amp; expiresAt == null)</span>
<span class="fc" id="L252">                loadMetadataFromManifest(manifestFile);</span>

            // check if an ephemeral marker file exists only in case it is not already ephemeral
            // by reading it from manifest
            // TODO remove this on Cassandra 4.3 release, see CASSANDRA-16911
<span class="fc bfc" id="L257" title="All 4 branches covered.">            if (!ephemeral &amp;&amp; new File(snapshotDir, &quot;ephemeral.snapshot&quot;).exists())</span>
<span class="fc" id="L258">                ephemeral = true;</span>
<span class="fc" id="L259">        }</span>

        private void loadMetadataFromManifest(File manifestFile)
        {
            try
            {
<span class="fc" id="L265">                logger.trace(&quot;Loading snapshot manifest from {}&quot;, manifestFile);</span>
<span class="fc" id="L266">                SnapshotManifest manifest = SnapshotManifest.deserializeFromJsonFile(manifestFile);</span>
<span class="fc" id="L267">                createdAt = manifest.createdAt;</span>
<span class="fc" id="L268">                expiresAt = manifest.expiresAt;</span>
                // a snapshot may be ephemeral when it has a marker file (old way) or flag in manifest (new way)
<span class="fc bfc" id="L270" title="All 2 branches covered.">                if (!ephemeral)</span>
<span class="fc" id="L271">                    ephemeral = manifest.ephemeral;</span>
            }
<span class="nc" id="L273">            catch (IOException e)</span>
            {
<span class="nc" id="L275">                logger.warn(&quot;Cannot read manifest file {} of snapshot {}.&quot;, manifestFile, tag, e);</span>
<span class="fc" id="L276">            }</span>
<span class="fc" id="L277">        }</span>

        TableSnapshot build()
        {
<span class="fc" id="L281">            return new TableSnapshot(keyspaceName, tableName, tableId, tag, createdAt, expiresAt, snapshotDirs, ephemeral);</span>
        }
    }

    protected static String buildSnapshotId(String keyspaceName, String tableName, UUID tableId, String tag)
    {
<span class="fc" id="L287">        return String.format(&quot;%s:%s:%s:%s&quot;, keyspaceName, tableName, tableId, tag);</span>
    }

<span class="fc" id="L290">    public static class SnapshotTrueSizeCalculator extends DirectorySizeCalculator</span>
    {
        /**
         * Snapshots are composed of hard-linked sstables. The true snapshot size should only include
         * snapshot files which do not contain a corresponding &quot;live&quot; sstable file.
         */
        @Override
        public boolean isAcceptable(Path snapshotFilePath)
        {
<span class="fc bfc" id="L299" title="All 2 branches covered.">            return !getLiveFileFromSnapshotFile(snapshotFilePath).exists();</span>
        }
    }

    /**
     * Returns the corresponding live file for a given snapshot file.
     *
     * Example:
     *  - Base table:
     *    - Snapshot file: ~/.ccm/test/node1/data0/test_ks/tbl-e03faca0813211eca100c705ea09b5ef/snapshots/1643481737850/me-1-big-Data.db
     *    - Live file: ~/.ccm/test/node1/data0/test_ks/tbl-e03faca0813211eca100c705ea09b5ef/me-1-big-Data.db
     *  - Secondary index:
     *    - Snapshot file: ~/.ccm/test/node1/data0/test_ks/tbl-e03faca0813211eca100c705ea09b5ef/snapshots/1643481737850/.tbl_val_idx/me-1-big-Summary.db
     *    - Live file: ~/.ccm/test/node1/data0/test_ks/tbl-e03faca0813211eca100c705ea09b5ef/.tbl_val_idx/me-1-big-Summary.db
     *
     */
    static File getLiveFileFromSnapshotFile(Path snapshotFilePath)
    {
        // Snapshot directory structure format is {data_dir}/snapshots/{snapshot_name}/{snapshot_file}
<span class="fc" id="L318">        Path liveDir = snapshotFilePath.getParent().getParent().getParent();</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">        if (Directories.isSecondaryIndexFolder(snapshotFilePath.getParent()))</span>
        {
            // Snapshot file structure format is {data_dir}/snapshots/{snapshot_name}/.{index}/{sstable-component}.db
<span class="fc" id="L322">            liveDir = File.getPath(liveDir.getParent().toString(), snapshotFilePath.getParent().getFileName().toString());</span>
        }
<span class="fc" id="L324">        return new File(liveDir.toString(), snapshotFilePath.getFileName().toString());</span>
    }

    public static Predicate&lt;TableSnapshot&gt; shouldClearSnapshot(String tag, long olderThanTimestamp)
    {
<span class="fc" id="L329">        return ts -&gt;</span>
        {
            // When no tag is supplied, all snapshots must be cleared
<span class="pc bpc" id="L332" title="1 of 4 branches missed.">            boolean clearAll = tag == null || tag.isEmpty();</span>
<span class="fc bfc" id="L333" title="All 4 branches covered.">            if (!clearAll &amp;&amp; ts.isEphemeral())</span>
<span class="fc" id="L334">                logger.info(&quot;Skipping deletion of ephemeral snapshot '{}' in keyspace {}. &quot; +</span>
                            &quot;Ephemeral snapshots are not removable by a user.&quot;,
                            tag, ts.keyspaceName);
<span class="fc bfc" id="L337" title="All 2 branches covered.">            boolean notEphemeral = !ts.isEphemeral();</span>
<span class="fc bfc" id="L338" title="All 4 branches covered.">            boolean shouldClearTag = clearAll || ts.tag.equals(tag);</span>
<span class="fc" id="L339">            boolean byTimestamp = true;</span>

<span class="pc bpc" id="L341" title="1 of 2 branches missed.">            if (olderThanTimestamp &gt; 0L)</span>
            {
<span class="nc" id="L343">                Instant createdAt = ts.getCreatedAt();</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">                if (createdAt != null)</span>
<span class="nc" id="L345">                    byTimestamp = createdAt.isBefore(Instant.ofEpochMilli(olderThanTimestamp));</span>
            }

<span class="pc bpc" id="L348" title="1 of 6 branches missed.">            return notEphemeral &amp;&amp; shouldClearTag &amp;&amp; byTimestamp;</span>
        };
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>