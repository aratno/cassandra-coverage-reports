<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StatsMetadata.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.io.sstable.metadata</a> &gt; <span class="el_source">StatsMetadata.java</span></div><h1>StatsMetadata.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.io.sstable.metadata;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.List;
import java.util.UUID;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.db.BufferClusteringBound;
import org.apache.cassandra.db.ClusteringBound;
import org.apache.cassandra.db.Slice;
import org.apache.cassandra.db.TypeSizes;
import org.apache.cassandra.db.commitlog.CommitLogPosition;
import org.apache.cassandra.db.commitlog.IntervalSet;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.rows.Cell;
import org.apache.cassandra.db.rows.EncodingStats;
import org.apache.cassandra.io.ISerializer;
import org.apache.cassandra.io.sstable.format.Version;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.serializers.AbstractTypeSerializer;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.EstimatedHistogram;
import org.apache.cassandra.utils.TimeUUID;
import org.apache.cassandra.utils.UUIDSerializer;
import org.apache.cassandra.utils.streamhist.TombstoneHistogram;

import static java.lang.Math.min;

/**
 * SSTable metadata that always stay on heap.
 */
public class StatsMetadata extends MetadataComponent
{
<span class="fc" id="L59">    public static final IMetadataComponentSerializer serializer = new StatsMetadataSerializer();</span>
<span class="fc" id="L60">    public static final ISerializer&lt;IntervalSet&lt;CommitLogPosition&gt;&gt; commitLogPositionSetSerializer = IntervalSet.serializer(CommitLogPosition.serializer);</span>

    public final EstimatedHistogram estimatedPartitionSize;
    public final EstimatedHistogram estimatedCellPerPartitionCount;
    public final IntervalSet&lt;CommitLogPosition&gt; commitLogIntervals;
    public final long minTimestamp;
    public final long maxTimestamp;
    public final long minLocalDeletionTime;
    public final long maxLocalDeletionTime;
    public final int minTTL;
    public final int maxTTL;
    public final double compressionRatio;
    public final TombstoneHistogram estimatedTombstoneDropTime;
    public final int sstableLevel;
    public final Slice coveredClustering;
    public final boolean hasLegacyCounterShards;
    public final double tokenSpaceCoverage;
    public final long repairedAt;
    public final long totalColumnsSet;
    public final long totalRows;
    public final UUID originatingHostId;
    public final TimeUUID pendingRepair;
    public final boolean isTransient;
    // just holds the current encoding stats to avoid allocating - it is not serialized
    public final EncodingStats encodingStats;

    // Used to serialize min/max clustering. Can be null if the metadata was deserialized from a legacy version
    private final List&lt;AbstractType&lt;?&gt;&gt; clusteringTypes;

    /**
     * This boolean is used as an approximation of whether a given key can be guaranteed not to have partition
     * deletions in this sstable. Obviously, this is pretty imprecise: a single partition deletion in the sstable
     * means we have to assume _any_ key may have a partition deletion. This is still likely useful as workloads that
     * does not use partition level deletions, or only very rarely, are probably not that rare.
     * TODO we could replace this by a small bloom-filter instead; the only downside being that we'd have to care about
     *  the size of this bloom filters not getting out of hands, and it's a tiny bit unclear if it's worth the added
     *  complexity.
     */
    public final boolean hasPartitionLevelDeletions;

    public final ByteBuffer firstKey;
    public final ByteBuffer lastKey;

    public StatsMetadata(EstimatedHistogram estimatedPartitionSize,
                         EstimatedHistogram estimatedCellPerPartitionCount,
                         IntervalSet&lt;CommitLogPosition&gt; commitLogIntervals,
                         long minTimestamp,
                         long maxTimestamp,
                         long minLocalDeletionTime,
                         long maxLocalDeletionTime,
                         int minTTL,
                         int maxTTL,
                         double compressionRatio,
                         TombstoneHistogram estimatedTombstoneDropTime,
                         int sstableLevel,
                         List&lt;AbstractType&lt;?&gt;&gt; clusteringTypes,
                         Slice coveredClustering,
                         boolean hasLegacyCounterShards,
                         long repairedAt,
                         long totalColumnsSet,
                         long totalRows,
                         double tokenSpaceCoverage,
                         UUID originatingHostId,
                         TimeUUID pendingRepair,
                         boolean isTransient,
                         boolean hasPartitionLevelDeletions,
                         ByteBuffer firstKey,
                         ByteBuffer lastKey)
<span class="fc" id="L128">    {</span>
<span class="fc" id="L129">        this.estimatedPartitionSize = estimatedPartitionSize;</span>
<span class="fc" id="L130">        this.estimatedCellPerPartitionCount = estimatedCellPerPartitionCount;</span>
<span class="fc" id="L131">        this.commitLogIntervals = commitLogIntervals;</span>
<span class="fc" id="L132">        this.minTimestamp = minTimestamp;</span>
<span class="fc" id="L133">        this.maxTimestamp = maxTimestamp;</span>
<span class="fc" id="L134">        this.minLocalDeletionTime = minLocalDeletionTime;</span>
<span class="fc" id="L135">        this.maxLocalDeletionTime = maxLocalDeletionTime;</span>
<span class="fc" id="L136">        this.minTTL = minTTL;</span>
<span class="fc" id="L137">        this.maxTTL = maxTTL;</span>
<span class="fc" id="L138">        this.compressionRatio = compressionRatio;</span>
<span class="fc" id="L139">        this.estimatedTombstoneDropTime = estimatedTombstoneDropTime;</span>
<span class="fc" id="L140">        this.sstableLevel = sstableLevel;</span>
<span class="fc" id="L141">        this.clusteringTypes = clusteringTypes;</span>
<span class="fc" id="L142">        this.coveredClustering = coveredClustering;</span>
<span class="fc" id="L143">        this.hasLegacyCounterShards = hasLegacyCounterShards;</span>
<span class="fc" id="L144">        this.repairedAt = repairedAt;</span>
<span class="fc" id="L145">        this.totalColumnsSet = totalColumnsSet;</span>
<span class="fc" id="L146">        this.totalRows = totalRows;</span>
<span class="fc" id="L147">        this.tokenSpaceCoverage = tokenSpaceCoverage;</span>
<span class="fc" id="L148">        this.originatingHostId = originatingHostId;</span>
<span class="fc" id="L149">        this.pendingRepair = pendingRepair;</span>
<span class="fc" id="L150">        this.isTransient = isTransient;</span>
<span class="fc" id="L151">        this.encodingStats = new EncodingStats(minTimestamp, minLocalDeletionTime, minTTL);</span>
<span class="fc" id="L152">        this.hasPartitionLevelDeletions = hasPartitionLevelDeletions;</span>
<span class="fc" id="L153">        this.firstKey = firstKey;</span>
<span class="fc" id="L154">        this.lastKey = lastKey;</span>
<span class="fc" id="L155">    }</span>

    public MetadataType getType()
    {
<span class="fc" id="L159">        return MetadataType.STATS;</span>
    }

    /**
     * @param gcBefore gc time in seconds
     * @return estimated droppable tombstone ratio at given gcBefore time.
     */
    public double getEstimatedDroppableTombstoneRatio(long gcBefore)
    {
<span class="fc" id="L168">        long estimatedColumnCount = this.estimatedCellPerPartitionCount.mean() * this.estimatedCellPerPartitionCount.count();</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">        if (estimatedColumnCount &gt; 0)</span>
        {
<span class="fc" id="L171">            double droppable = getDroppableTombstonesBefore(gcBefore);</span>
<span class="fc" id="L172">            return droppable / estimatedColumnCount;</span>
        }
<span class="nc" id="L174">        return 0.0f;</span>
    }

    /**
     * @param gcBefore gc time in seconds
     * @return amount of droppable tombstones
     */
    public double getDroppableTombstonesBefore(long gcBefore)
    {
<span class="fc" id="L183">        return estimatedTombstoneDropTime.sum(gcBefore);</span>
    }

    public StatsMetadata mutateLevel(int newLevel)
    {
<span class="fc" id="L188">        return new StatsMetadata(estimatedPartitionSize,</span>
                                 estimatedCellPerPartitionCount,
                                 commitLogIntervals,
                                 minTimestamp,
                                 maxTimestamp,
                                 minLocalDeletionTime,
                                 maxLocalDeletionTime,
                                 minTTL,
                                 maxTTL,
                                 compressionRatio,
                                 estimatedTombstoneDropTime,
                                 newLevel,
                                 clusteringTypes,
                                 coveredClustering,
                                 hasLegacyCounterShards,
                                 repairedAt,
                                 totalColumnsSet,
                                 totalRows,
                                 tokenSpaceCoverage,
                                 originatingHostId,
                                 pendingRepair,
                                 isTransient,
                                 hasPartitionLevelDeletions,
                                 firstKey,
                                 lastKey);
    }

    public StatsMetadata mutateRepairedMetadata(long newRepairedAt, TimeUUID newPendingRepair, boolean newIsTransient)
    {
<span class="fc" id="L217">        return new StatsMetadata(estimatedPartitionSize,</span>
                                 estimatedCellPerPartitionCount,
                                 commitLogIntervals,
                                 minTimestamp,
                                 maxTimestamp,
                                 minLocalDeletionTime,
                                 maxLocalDeletionTime,
                                 minTTL,
                                 maxTTL,
                                 compressionRatio,
                                 estimatedTombstoneDropTime,
                                 sstableLevel,
                                 clusteringTypes,
                                 coveredClustering,
                                 hasLegacyCounterShards,
                                 newRepairedAt,
                                 totalColumnsSet,
                                 totalRows,
                                 tokenSpaceCoverage,
                                 originatingHostId,
                                 newPendingRepair,
                                 newIsTransient,
                                 hasPartitionLevelDeletions,
                                 firstKey,
                                 lastKey);
    }

    @Override
    public boolean equals(Object o)
    {
<span class="nc bnc" id="L247" title="All 2 branches missed.">        if (this == o) return true;</span>
<span class="nc bnc" id="L248" title="All 4 branches missed.">        if (o == null || getClass() != o.getClass()) return false;</span>

<span class="nc" id="L250">        StatsMetadata that = (StatsMetadata) o;</span>
<span class="nc" id="L251">        return new EqualsBuilder()</span>
<span class="nc" id="L252">                       .append(estimatedPartitionSize, that.estimatedPartitionSize)</span>
<span class="nc" id="L253">                       .append(estimatedCellPerPartitionCount, that.estimatedCellPerPartitionCount)</span>
<span class="nc" id="L254">                       .append(commitLogIntervals, that.commitLogIntervals)</span>
<span class="nc" id="L255">                       .append(minTimestamp, that.minTimestamp)</span>
<span class="nc" id="L256">                       .append(maxTimestamp, that.maxTimestamp)</span>
<span class="nc" id="L257">                       .append(minLocalDeletionTime, that.minLocalDeletionTime)</span>
<span class="nc" id="L258">                       .append(maxLocalDeletionTime, that.maxLocalDeletionTime)</span>
<span class="nc" id="L259">                       .append(minTTL, that.minTTL)</span>
<span class="nc" id="L260">                       .append(maxTTL, that.maxTTL)</span>
<span class="nc" id="L261">                       .append(compressionRatio, that.compressionRatio)</span>
<span class="nc" id="L262">                       .append(estimatedTombstoneDropTime, that.estimatedTombstoneDropTime)</span>
<span class="nc" id="L263">                       .append(sstableLevel, that.sstableLevel)</span>
<span class="nc" id="L264">                       .append(repairedAt, that.repairedAt)</span>
<span class="nc" id="L265">                       .append(coveredClustering, that.coveredClustering)</span>
<span class="nc" id="L266">                       .append(hasLegacyCounterShards, that.hasLegacyCounterShards)</span>
<span class="nc" id="L267">                       .append(totalColumnsSet, that.totalColumnsSet)</span>
<span class="nc" id="L268">                       .append(totalRows, that.totalRows)</span>
<span class="nc" id="L269">                       .append(tokenSpaceCoverage, that.tokenSpaceCoverage)</span>
<span class="nc" id="L270">                       .append(originatingHostId, that.originatingHostId)</span>
<span class="nc" id="L271">                       .append(pendingRepair, that.pendingRepair)</span>
<span class="nc" id="L272">                       .append(hasPartitionLevelDeletions, that.hasPartitionLevelDeletions)</span>
<span class="nc" id="L273">                       .append(firstKey, that.firstKey)</span>
<span class="nc" id="L274">                       .append(lastKey, that.lastKey)</span>
<span class="nc" id="L275">                       .build();</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L281">        return new HashCodeBuilder()</span>
<span class="nc" id="L282">                       .append(estimatedPartitionSize)</span>
<span class="nc" id="L283">                       .append(estimatedCellPerPartitionCount)</span>
<span class="nc" id="L284">                       .append(commitLogIntervals)</span>
<span class="nc" id="L285">                       .append(minTimestamp)</span>
<span class="nc" id="L286">                       .append(maxTimestamp)</span>
<span class="nc" id="L287">                       .append(minLocalDeletionTime)</span>
<span class="nc" id="L288">                       .append(maxLocalDeletionTime)</span>
<span class="nc" id="L289">                       .append(minTTL)</span>
<span class="nc" id="L290">                       .append(maxTTL)</span>
<span class="nc" id="L291">                       .append(compressionRatio)</span>
<span class="nc" id="L292">                       .append(estimatedTombstoneDropTime)</span>
<span class="nc" id="L293">                       .append(sstableLevel)</span>
<span class="nc" id="L294">                       .append(repairedAt)</span>
<span class="nc" id="L295">                       .append(coveredClustering)</span>
<span class="nc" id="L296">                       .append(hasLegacyCounterShards)</span>
<span class="nc" id="L297">                       .append(totalColumnsSet)</span>
<span class="nc" id="L298">                       .append(totalRows)</span>
<span class="nc" id="L299">                       .append(tokenSpaceCoverage)</span>
<span class="nc" id="L300">                       .append(originatingHostId)</span>
<span class="nc" id="L301">                       .append(pendingRepair)</span>
<span class="nc" id="L302">                       .append(hasPartitionLevelDeletions)</span>
<span class="nc" id="L303">                       .append(firstKey)</span>
<span class="nc" id="L304">                       .append(lastKey)</span>
<span class="nc" id="L305">                       .build();</span>
    }

<span class="fc" id="L308">    public static class StatsMetadataSerializer implements IMetadataComponentSerializer&lt;StatsMetadata&gt;</span>
    {
<span class="fc" id="L310">        private static final Logger logger = LoggerFactory.getLogger(StatsMetadataSerializer.class);</span>

<span class="fc" id="L312">        private final AbstractTypeSerializer typeSerializer = new AbstractTypeSerializer();</span>

        public int serializedSize(Version version, StatsMetadata component) throws IOException
        {
<span class="fc" id="L316">            int size = 0;</span>
<span class="fc" id="L317">            size += EstimatedHistogram.serializer.serializedSize(component.estimatedPartitionSize);</span>
<span class="fc" id="L318">            size += EstimatedHistogram.serializer.serializedSize(component.estimatedCellPerPartitionCount);</span>
<span class="fc" id="L319">            size += CommitLogPosition.serializer.serializedSize(component.commitLogIntervals.upperBound().orElse(CommitLogPosition.NONE));</span>
<span class="fc" id="L320">            size += 8 + 8; // mix/max timestamp(long)</span>
<span class="fc" id="L321">            size += 4 + 4;   //min/maxLocalDeletionTime(either int or uint depending on the sstable version)</span>
<span class="fc" id="L322">            size +=  4 + 4 + 8 + 8;// min/max TTL, compressionRatio(double), repairedAt (long)</span>
<span class="fc" id="L323">            size += TombstoneHistogram.getSerializer(version).serializedSize(component.estimatedTombstoneDropTime);</span>

<span class="fc" id="L325">            size += TypeSizes.sizeof(component.sstableLevel);</span>

<span class="pc bpc" id="L327" title="1 of 2 branches missed.">            if (version.hasLegacyMinMax())</span>
            {
                // min column names
<span class="fc" id="L330">                size += 4;</span>
<span class="fc" id="L331">                ClusteringBound&lt;?&gt; minClusteringValues = component.coveredClustering.start();</span>
<span class="fc" id="L332">                size += minClusteringValues.size() * 2 /* short length */ + minClusteringValues.dataSize();</span>
                // max column names
<span class="fc" id="L334">                size += 4;</span>
<span class="fc" id="L335">                ClusteringBound&lt;?&gt; maxClusteringValues = component.coveredClustering.end();</span>
<span class="fc" id="L336">                size += maxClusteringValues.size() * 2 /* short length */ + maxClusteringValues.dataSize();</span>
<span class="fc" id="L337">            }</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">            else if (version.hasImprovedMinMax())</span>
            {
<span class="nc" id="L340">                size = improvedMinMaxSize(version, component, size);</span>
            }

<span class="fc" id="L343">            size += TypeSizes.sizeof(component.hasLegacyCounterShards);</span>
<span class="fc" id="L344">            size += 8 + 8; // totalColumnsSet, totalRows</span>
<span class="pc bpc" id="L345" title="1 of 2 branches missed.">            if (version.hasCommitLogLowerBound())</span>
<span class="fc" id="L346">                size += CommitLogPosition.serializer.serializedSize(component.commitLogIntervals.lowerBound().orElse(CommitLogPosition.NONE));</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">            if (version.hasCommitLogIntervals())</span>
<span class="fc" id="L348">                size += commitLogPositionSetSerializer.serializedSize(component.commitLogIntervals);</span>

<span class="pc bpc" id="L350" title="1 of 2 branches missed.">            if (version.hasPendingRepair())</span>
            {
<span class="fc" id="L352">                size += 1;</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">                if (component.pendingRepair != null)</span>
<span class="fc" id="L354">                    size += TimeUUID.sizeInBytes();</span>
            }

<span class="pc bpc" id="L357" title="1 of 2 branches missed.">            if (version.hasIsTransient())</span>
            {
<span class="fc" id="L359">                size += TypeSizes.sizeof(component.isTransient);</span>
            }

<span class="pc bpc" id="L362" title="1 of 2 branches missed.">            if (version.hasOriginatingHostId())</span>
            {
<span class="fc" id="L364">                size += 1; // boolean: is originatingHostId present</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">                if (component.originatingHostId != null)</span>
<span class="fc" id="L366">                    size += UUIDSerializer.serializer.serializedSize(component.originatingHostId, version.correspondingMessagingVersion());</span>
            }

<span class="pc bpc" id="L369" title="1 of 2 branches missed.">            if (version.hasPartitionLevelDeletionsPresenceMarker())</span>
            {
<span class="fc" id="L371">                size += TypeSizes.sizeof(component.hasPartitionLevelDeletions);</span>
            }

<span class="pc bpc" id="L374" title="2 of 4 branches missed.">            if (version.hasImprovedMinMax() &amp;&amp; version.hasLegacyMinMax())</span>
            {
<span class="fc" id="L376">                size = improvedMinMaxSize(version, component, size);</span>
            }

<span class="pc bpc" id="L379" title="1 of 2 branches missed.">            if (version.hasKeyRange())</span>
            {
<span class="fc" id="L381">                size += ByteBufferUtil.serializedSizeWithVIntLength(component.firstKey);</span>
<span class="fc" id="L382">                size += ByteBufferUtil.serializedSizeWithVIntLength(component.lastKey);</span>
            }

<span class="pc bpc" id="L385" title="1 of 2 branches missed.">            if (version.hasTokenSpaceCoverage())</span>
            {
<span class="nc" id="L387">                size += Double.BYTES;</span>
            }

<span class="fc" id="L390">            return size;</span>
        }

        private int improvedMinMaxSize(Version version, StatsMetadata component, int size)
        {
<span class="fc" id="L395">            size += typeSerializer.serializedListSize(component.clusteringTypes);</span>
<span class="fc" id="L396">            size += Slice.serializer.serializedSize(component.coveredClustering,</span>
<span class="fc" id="L397">                                                    version.correspondingMessagingVersion(),</span>
                                                    component.clusteringTypes);
<span class="fc" id="L399">            return size;</span>
        }

        public void serialize(Version version, StatsMetadata component, DataOutputPlus out) throws IOException
        {
<span class="fc" id="L404">            EstimatedHistogram.serializer.serialize(component.estimatedPartitionSize, out);</span>
<span class="fc" id="L405">            EstimatedHistogram.serializer.serialize(component.estimatedCellPerPartitionCount, out);</span>
<span class="fc" id="L406">            CommitLogPosition.serializer.serialize(component.commitLogIntervals.upperBound().orElse(CommitLogPosition.NONE), out);</span>
<span class="fc" id="L407">            out.writeLong(component.minTimestamp);</span>
<span class="fc" id="L408">            out.writeLong(component.maxTimestamp);</span>
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">            if (version.hasUIntDeletionTime())</span>
            {
<span class="nc" id="L411">                out.writeInt(Cell.deletionTimeLongToUnsignedInteger(component.minLocalDeletionTime));</span>
<span class="nc" id="L412">                out.writeInt(Cell.deletionTimeLongToUnsignedInteger(component.maxLocalDeletionTime));</span>
            }
            else
            {
<span class="fc bfc" id="L416" title="All 2 branches covered.">                int mld = component.minLocalDeletionTime == Long.MAX_VALUE ? Integer.MAX_VALUE : (int)min(component.minLocalDeletionTime, (long)Integer.MAX_VALUE - 1);</span>
<span class="fc" id="L417">                out.writeInt(mld);</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">                mld = component.maxLocalDeletionTime == Long.MAX_VALUE ? Integer.MAX_VALUE : (int)min(component.maxLocalDeletionTime, (long)Integer.MAX_VALUE - 1);</span>
<span class="fc" id="L419">                out.writeInt(mld);</span>
            }
<span class="fc" id="L421">            out.writeInt(component.minTTL);</span>
<span class="fc" id="L422">            out.writeInt(component.maxTTL);</span>
<span class="fc" id="L423">            out.writeDouble(component.compressionRatio);</span>
<span class="fc" id="L424">            TombstoneHistogram.getSerializer(version).serialize(component.estimatedTombstoneDropTime, out);</span>
<span class="fc" id="L425">            out.writeInt(component.sstableLevel);</span>
<span class="fc" id="L426">            out.writeLong(component.repairedAt);</span>

<span class="pc bpc" id="L428" title="1 of 2 branches missed.">            if (version.hasLegacyMinMax())</span>
            {
<span class="fc" id="L430">                ClusteringBound&lt;?&gt; minClusteringValues = component.coveredClustering.start();</span>
<span class="fc" id="L431">                out.writeInt(countUntilNull(minClusteringValues.getBufferArray()));</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">                for (ByteBuffer value : minClusteringValues.getBufferArray())</span>
                {
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">                    if (value == null)</span>
<span class="nc" id="L435">                        break;</span>
<span class="fc" id="L436">                    ByteBufferUtil.writeWithShortLength(value, out);</span>
                }
<span class="fc" id="L438">                ClusteringBound&lt;?&gt; maxClusteringValues = component.coveredClustering.end();</span>
<span class="fc" id="L439">                out.writeInt(countUntilNull(maxClusteringValues.getBufferArray()));</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">                for (ByteBuffer value : maxClusteringValues.getBufferArray())</span>
                {
<span class="pc bpc" id="L442" title="1 of 2 branches missed.">                    if (value == null)</span>
<span class="nc" id="L443">                        break;</span>
<span class="fc" id="L444">                    ByteBufferUtil.writeWithShortLength(value, out);</span>
                }
<span class="fc" id="L446">            }</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">            else if (version.hasImprovedMinMax())</span>
            {
<span class="nc" id="L449">                serializeImprovedMinMax(version, component, out);</span>
            }

<span class="fc" id="L452">            out.writeBoolean(component.hasLegacyCounterShards);</span>

<span class="fc" id="L454">            out.writeLong(component.totalColumnsSet);</span>
<span class="fc" id="L455">            out.writeLong(component.totalRows);</span>

<span class="pc bpc" id="L457" title="1 of 2 branches missed.">            if (version.hasCommitLogLowerBound())</span>
<span class="fc" id="L458">                CommitLogPosition.serializer.serialize(component.commitLogIntervals.lowerBound().orElse(CommitLogPosition.NONE), out);</span>
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">            if (version.hasCommitLogIntervals())</span>
<span class="fc" id="L460">                commitLogPositionSetSerializer.serialize(component.commitLogIntervals, out);</span>

<span class="pc bpc" id="L462" title="1 of 2 branches missed.">            if (version.hasPendingRepair())</span>
            {
<span class="fc bfc" id="L464" title="All 2 branches covered.">                if (component.pendingRepair != null)</span>
                {
<span class="fc" id="L466">                    out.writeByte(1);</span>
<span class="fc" id="L467">                    component.pendingRepair.serialize(out);</span>
                }
                else
                {
<span class="fc" id="L471">                    out.writeByte(0);</span>
                }
            }

<span class="pc bpc" id="L475" title="1 of 2 branches missed.">            if (version.hasIsTransient())</span>
            {
<span class="fc" id="L477">                out.writeBoolean(component.isTransient);</span>
            }

<span class="pc bpc" id="L480" title="1 of 2 branches missed.">            if (version.hasOriginatingHostId())</span>
            {
<span class="fc bfc" id="L482" title="All 2 branches covered.">                if (component.originatingHostId != null)</span>
                {
<span class="fc" id="L484">                    out.writeByte(1);</span>
<span class="fc" id="L485">                    UUIDSerializer.serializer.serialize(component.originatingHostId, out, 0);</span>
                }
                else
                {
<span class="fc" id="L489">                    out.writeByte(0);</span>
                }
            }

<span class="pc bpc" id="L493" title="1 of 2 branches missed.">            if (version.hasPartitionLevelDeletionsPresenceMarker())</span>
            {
<span class="fc" id="L495">                out.writeBoolean(component.hasPartitionLevelDeletions);</span>
            }

<span class="pc bpc" id="L498" title="2 of 4 branches missed.">            if (version.hasImprovedMinMax() &amp;&amp; version.hasLegacyMinMax())</span>
            {
<span class="fc" id="L500">                serializeImprovedMinMax(version, component, out);</span>
            }

<span class="pc bpc" id="L503" title="1 of 2 branches missed.">            if (version.hasKeyRange())</span>
            {
<span class="fc" id="L505">                ByteBufferUtil.writeWithVIntLength(component.firstKey, out);</span>
<span class="fc" id="L506">                ByteBufferUtil.writeWithVIntLength(component.lastKey, out);</span>
            }

<span class="pc bpc" id="L509" title="1 of 2 branches missed.">            if (version.hasTokenSpaceCoverage())</span>
            {
<span class="nc" id="L511">                out.writeDouble(component.tokenSpaceCoverage);</span>
            }
<span class="fc" id="L513">        }</span>

        private void serializeImprovedMinMax(Version version, StatsMetadata component, DataOutputPlus out) throws IOException
        {
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">            assert component.clusteringTypes != null;</span>
<span class="fc" id="L518">            typeSerializer.serializeList(component.clusteringTypes, out);</span>
<span class="fc" id="L519">            Slice.serializer.serialize(component.coveredClustering,</span>
                                       out,
<span class="fc" id="L521">                                       version.correspondingMessagingVersion(),</span>
                                       component.clusteringTypes);
<span class="fc" id="L523">        }</span>

        public StatsMetadata deserialize(Version version, DataInputPlus in) throws IOException
        {
<span class="fc" id="L527">            EstimatedHistogram partitionSizes = EstimatedHistogram.serializer.deserialize(in);</span>

<span class="pc bpc" id="L529" title="1 of 2 branches missed.">            if (partitionSizes.isOverflowed())</span>
            {
<span class="nc" id="L531">                logger.warn(&quot;Deserialized partition size histogram with {} values greater than the maximum of {}. &quot; +</span>
                            &quot;Clearing the overflow bucket to allow for degraded mean and percentile calculations...&quot;,
<span class="nc" id="L533">                            partitionSizes.overflowCount(), partitionSizes.getLargestBucketOffset());</span>

<span class="nc" id="L535">                partitionSizes.clearOverflow();</span>
            }

<span class="fc" id="L538">            EstimatedHistogram columnCounts = EstimatedHistogram.serializer.deserialize(in);</span>

<span class="pc bpc" id="L540" title="1 of 2 branches missed.">            if (columnCounts.isOverflowed())</span>
            {
<span class="nc" id="L542">                logger.warn(&quot;Deserialized partition cell count histogram with {} values greater than the maximum of {}. &quot; +</span>
                            &quot;Clearing the overflow bucket to allow for degraded mean and percentile calculations...&quot;,
<span class="nc" id="L544">                            columnCounts.overflowCount(), columnCounts.getLargestBucketOffset());</span>

<span class="nc" id="L546">                columnCounts.clearOverflow();</span>
            }

<span class="fc" id="L549">            CommitLogPosition commitLogLowerBound = CommitLogPosition.NONE, commitLogUpperBound;</span>
<span class="fc" id="L550">            commitLogUpperBound = CommitLogPosition.serializer.deserialize(in);</span>
<span class="fc" id="L551">            long minTimestamp = in.readLong();</span>
<span class="fc" id="L552">            long maxTimestamp = in.readLong();</span>
            long minLocalDeletionTime;
            long maxLocalDeletionTime;
<span class="pc bpc" id="L555" title="1 of 2 branches missed.">            if (version.hasUIntDeletionTime())</span>
            {
<span class="nc" id="L557">                minLocalDeletionTime = Cell.deletionTimeUnsignedIntegerToLong(in.readInt());</span>
<span class="nc" id="L558">                maxLocalDeletionTime = Cell.deletionTimeUnsignedIntegerToLong(in.readInt());</span>
            }
            else
            {
<span class="fc" id="L562">                minLocalDeletionTime = in.readInt();</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">                if (minLocalDeletionTime == Integer.MAX_VALUE)</span>
<span class="fc" id="L564">                    minLocalDeletionTime = Cell.NO_DELETION_TIME;</span>

<span class="fc" id="L566">                maxLocalDeletionTime = in.readInt();</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">                if (maxLocalDeletionTime == Integer.MAX_VALUE)</span>
<span class="fc" id="L568">                    maxLocalDeletionTime = Cell.NO_DELETION_TIME;</span>
            }
<span class="fc" id="L570">            int minTTL = in.readInt();</span>
<span class="fc" id="L571">            int maxTTL = in.readInt();</span>
<span class="fc" id="L572">            double compressionRatio = in.readDouble();</span>
<span class="fc" id="L573">            TombstoneHistogram tombstoneHistogram = TombstoneHistogram.getSerializer(version).deserialize(in);</span>
<span class="fc" id="L574">            int sstableLevel = in.readInt();</span>
<span class="fc" id="L575">            long repairedAt = in.readLong();</span>

<span class="fc" id="L577">            List&lt;AbstractType&lt;?&gt;&gt; clusteringTypes = null;</span>
<span class="fc" id="L578">            Slice coveredClustering = Slice.ALL;</span>
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">            if (version.hasLegacyMinMax())</span>
            {
                // We always deserialize the min/max clustering values if they are there, but we ignore them for
                // legacy sstables where !hasAccurateMinMax due to CASSANDRA-14861.
<span class="fc" id="L583">                int colCount = in.readInt();</span>
<span class="fc" id="L584">                ByteBuffer[] minClusteringValues = new ByteBuffer[colCount];</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">                for (int i = 0; i &lt; colCount; i++)</span>
<span class="fc" id="L586">                    minClusteringValues[i] = ByteBufferUtil.readWithShortLength(in);</span>

<span class="fc" id="L588">                colCount = in.readInt();</span>
<span class="fc" id="L589">                ByteBuffer[] maxClusteringValues = new ByteBuffer[colCount];</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">                for (int i = 0; i &lt; colCount; i++)</span>
<span class="fc" id="L591">                    maxClusteringValues[i] = ByteBufferUtil.readWithShortLength(in);</span>

<span class="pc bpc" id="L593" title="1 of 2 branches missed.">                if (version.hasAccurateMinMax())</span>
<span class="fc" id="L594">                    coveredClustering = Slice.make(BufferClusteringBound.inclusiveStartOf(minClusteringValues),</span>
<span class="fc" id="L595">                                                   BufferClusteringBound.inclusiveEndOf(maxClusteringValues));</span>
<span class="fc" id="L596">            }</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">            else if (version.hasImprovedMinMax())</span>
            {
                // improvedMinMax will be in this place when legacyMinMax is removed
<span class="nc" id="L600">                clusteringTypes = typeSerializer.deserializeList(in);</span>
<span class="nc" id="L601">                coveredClustering = Slice.serializer.deserialize(in, version.correspondingMessagingVersion(), clusteringTypes);</span>
            }

<span class="fc" id="L604">            boolean hasLegacyCounterShards = in.readBoolean();</span>

<span class="fc" id="L606">            long totalColumnsSet = in.readLong();</span>
<span class="fc" id="L607">            long totalRows = in.readLong();</span>

<span class="pc bpc" id="L609" title="1 of 2 branches missed.">            if (version.hasCommitLogLowerBound())</span>
<span class="fc" id="L610">                commitLogLowerBound = CommitLogPosition.serializer.deserialize(in);</span>
            IntervalSet&lt;CommitLogPosition&gt; commitLogIntervals;
<span class="pc bpc" id="L612" title="1 of 2 branches missed.">            if (version.hasCommitLogIntervals())</span>
<span class="fc" id="L613">                commitLogIntervals = commitLogPositionSetSerializer.deserialize(in);</span>
            else
<span class="nc" id="L615">                commitLogIntervals = new IntervalSet&lt;&gt;(commitLogLowerBound, commitLogUpperBound);</span>

<span class="fc" id="L617">            TimeUUID pendingRepair = null;</span>
<span class="pc bpc" id="L618" title="1 of 4 branches missed.">            if (version.hasPendingRepair() &amp;&amp; in.readByte() != 0)</span>
            {
<span class="fc" id="L620">                pendingRepair = TimeUUID.deserialize(in);</span>
            }

<span class="pc bpc" id="L623" title="2 of 4 branches missed.">            boolean isTransient = version.hasIsTransient() &amp;&amp; in.readBoolean();</span>

<span class="fc" id="L625">            UUID originatingHostId = null;</span>
<span class="pc bpc" id="L626" title="2 of 4 branches missed.">            if (version.hasOriginatingHostId() &amp;&amp; in.readByte() != 0)</span>
<span class="fc" id="L627">                originatingHostId = UUIDSerializer.serializer.deserialize(in, 0);</span>

            // If not recorded, the only time we can guarantee there is no partition level deletion is if there is no
            // deletion at all. Otherwise, we have to assume there may be some.
<span class="fc bfc" id="L631" title="All 2 branches covered.">            boolean hasPartitionLevelDeletions = minLocalDeletionTime != Cell.NO_DELETION_TIME;</span>
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">            if (version.hasPartitionLevelDeletionsPresenceMarker())</span>
            {
<span class="fc" id="L634">                hasPartitionLevelDeletions = in.readBoolean();</span>
            }

<span class="pc bpc" id="L637" title="2 of 4 branches missed.">            if (version.hasImprovedMinMax() &amp;&amp; version.hasLegacyMinMax())</span>
            {
                // improvedMinMax will be in this place until legacyMinMax is removed
<span class="fc" id="L640">                clusteringTypes = typeSerializer.deserializeList(in);</span>
<span class="fc" id="L641">                coveredClustering = Slice.serializer.deserialize(in, version.correspondingMessagingVersion(), clusteringTypes);</span>
            }

<span class="fc" id="L644">            ByteBuffer firstKey = null;</span>
<span class="fc" id="L645">            ByteBuffer lastKey = null;</span>
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">            if (version.hasKeyRange())</span>
            {
<span class="fc" id="L648">                firstKey = ByteBufferUtil.readWithVIntLength(in);</span>
<span class="fc" id="L649">                lastKey = ByteBufferUtil.readWithVIntLength(in);</span>
            }

<span class="fc" id="L652">            double tokenSpaceCoverage = Double.NaN;</span>
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">            if (version.hasTokenSpaceCoverage())</span>
            {
<span class="nc" id="L655">                tokenSpaceCoverage = in.readDouble();</span>
            }

<span class="fc" id="L658">            return new StatsMetadata(partitionSizes,</span>
                                     columnCounts,
                                     commitLogIntervals,
                                     minTimestamp,
                                     maxTimestamp,
                                     minLocalDeletionTime,
                                     maxLocalDeletionTime,
                                     minTTL,
                                     maxTTL,
                                     compressionRatio,
                                     tombstoneHistogram,
                                     sstableLevel,
                                     clusteringTypes,
                                     coveredClustering,
                                     hasLegacyCounterShards,
                                     repairedAt,
                                     totalColumnsSet,
                                     totalRows,
                                     tokenSpaceCoverage,
                                     originatingHostId,
                                     pendingRepair,
                                     isTransient,
                                     hasPartitionLevelDeletions,
                                     firstKey,
                                     lastKey);
        }

        private int countUntilNull(ByteBuffer[] bufferArray)
        {
<span class="fc" id="L687">            int i = ArrayUtils.indexOf(bufferArray, null);</span>
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">            return i &lt; 0 ? bufferArray.length : i;</span>
        }

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>