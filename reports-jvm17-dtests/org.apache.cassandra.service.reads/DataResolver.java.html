<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataResolver.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.service.reads</a> &gt; <span class="el_source">DataResolver.java</span></div><h1>DataResolver.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.service.reads;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.function.Supplier;
import java.util.function.UnaryOperator;

import javax.annotation.Nullable;

import com.google.common.base.Joiner;

import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.DeletionTime;
import org.apache.cassandra.db.ReadCommand;
import org.apache.cassandra.db.ReadResponse;
import org.apache.cassandra.db.filter.DataLimits;
import org.apache.cassandra.db.partitions.PartitionIterator;
import org.apache.cassandra.db.partitions.PartitionIterators;
import org.apache.cassandra.db.partitions.UnfilteredPartitionIterator;
import org.apache.cassandra.db.partitions.UnfilteredPartitionIterators;
import org.apache.cassandra.db.rows.RangeTombstoneMarker;
import org.apache.cassandra.db.rows.Row;
import org.apache.cassandra.db.rows.UnfilteredRowIterator;
import org.apache.cassandra.db.rows.UnfilteredRowIterators;
import org.apache.cassandra.db.transform.EmptyPartitionsDiscarder;
import org.apache.cassandra.db.transform.Filter;
import org.apache.cassandra.db.transform.FilteredPartitions;
import org.apache.cassandra.db.transform.Transformation;
import org.apache.cassandra.index.Index;
import org.apache.cassandra.locator.Endpoints;
import org.apache.cassandra.locator.ReplicaPlan;
import org.apache.cassandra.net.Message;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.service.reads.repair.NoopReadRepair;
import org.apache.cassandra.service.reads.repair.ReadRepair;
import org.apache.cassandra.service.reads.repair.RepairedDataTracker;
import org.apache.cassandra.service.reads.repair.RepairedDataVerifier;

import static com.google.common.collect.Iterables.*;

<span class="fc" id="L61">public class DataResolver&lt;E extends Endpoints&lt;E&gt;, P extends ReplicaPlan.ForRead&lt;E, P&gt;&gt; extends ResponseResolver&lt;E, P&gt;</span>
{
    private final boolean enforceStrictLiveness;
    private final ReadRepair&lt;E, P&gt; readRepair;
    private final boolean trackRepairedStatus;

    public DataResolver(ReadCommand command, Supplier&lt;? extends P&gt; replicaPlan, ReadRepair&lt;E, P&gt; readRepair, long queryStartNanoTime)
    {
<span class="fc" id="L69">        this(command, replicaPlan, readRepair, queryStartNanoTime, false);</span>
<span class="fc" id="L70">    }</span>

    public DataResolver(ReadCommand command, Supplier&lt;? extends P&gt; replicaPlan, ReadRepair&lt;E, P&gt; readRepair, long queryStartNanoTime, boolean trackRepairedStatus)
    {
<span class="fc" id="L74">        super(command, replicaPlan, queryStartNanoTime);</span>
<span class="fc" id="L75">        this.enforceStrictLiveness = command.metadata().enforceStrictLiveness();</span>
<span class="fc" id="L76">        this.readRepair = readRepair;</span>
<span class="fc" id="L77">        this.trackRepairedStatus = trackRepairedStatus;</span>
<span class="fc" id="L78">    }</span>

    public PartitionIterator getData()
    {
<span class="nc" id="L82">        ReadResponse response = responses.get(0).payload;</span>
<span class="nc" id="L83">        return UnfilteredPartitionIterators.filter(response.makeIterator(command), command.nowInSec());</span>
    }

    public boolean isDataPresent()
    {
<span class="fc bfc" id="L88" title="All 2 branches covered.">        return !responses.isEmpty();</span>
    }

    public PartitionIterator resolve()
    {
<span class="fc" id="L93">        return resolve(null);</span>
    }

    public PartitionIterator resolve(@Nullable Runnable runOnShortRead)
    {
        // We could get more responses while this method runs, which is ok (we're happy to ignore any response not here
        // at the beginning of this method), so grab the response count once and use that through the method.
<span class="fc" id="L100">        Collection&lt;Message&lt;ReadResponse&gt;&gt; messages = responses.snapshot();</span>
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">        assert !any(messages, msg -&gt; msg.payload.isDigestResponse());</span>

<span class="fc" id="L103">        E replicas = replicaPlan().readCandidates().select(transform(messages, Message::from), false);</span>

        // If requested, inspect each response for a digest of the replica's repaired data set
<span class="fc bfc" id="L106" title="All 2 branches covered.">        RepairedDataTracker repairedDataTracker = trackRepairedStatus</span>
<span class="fc" id="L107">                                                  ? new RepairedDataTracker(getRepairedDataVerifier(command))</span>
<span class="fc" id="L108">                                                  : null;</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">        if (repairedDataTracker != null)</span>
        {
<span class="fc" id="L111">            messages.forEach(msg -&gt; {</span>
<span class="pc bpc" id="L112" title="2 of 4 branches missed.">                if (msg.payload.mayIncludeRepairedDigest() &amp;&amp; replicas.byEndpoint().get(msg.from()).isFull())</span>
                {
<span class="fc" id="L114">                    repairedDataTracker.recordDigest(msg.from(),</span>
<span class="fc" id="L115">                                                     msg.payload.repairedDataDigest(),</span>
<span class="fc" id="L116">                                                     msg.payload.isRepairedDigestConclusive());</span>
                }
<span class="fc" id="L118">            });</span>
        }

<span class="fc bfc" id="L121" title="All 2 branches covered.">        if (!needsReplicaFilteringProtection())</span>
        {
<span class="fc" id="L123">            ResolveContext context = new ResolveContext(replicas);</span>
<span class="fc" id="L124">            return resolveWithReadRepair(context,</span>
<span class="fc" id="L125">                                         i -&gt; shortReadProtectedResponse(i, context, runOnShortRead),</span>
<span class="fc" id="L126">                                         UnaryOperator.identity(),</span>
                                         repairedDataTracker);
        }

<span class="fc" id="L130">        return resolveWithReplicaFilteringProtection(replicas, repairedDataTracker);</span>
    }

    private boolean needsReplicaFilteringProtection()
    {
<span class="fc bfc" id="L135" title="All 2 branches covered.">        if (command.rowFilter().isEmpty())</span>
<span class="fc" id="L136">            return false;</span>

<span class="fc" id="L138">        Index.QueryPlan queryPlan = command.indexQueryPlan();</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">        if (queryPlan == null )</span>
<span class="fc" id="L140">            return true;</span>

<span class="fc" id="L142">        return queryPlan.supportsReplicaFilteringProtection(command.rowFilter());</span>
    }

    private class ResolveContext
    {
        private final E replicas;
        private final DataLimits.Counter mergedResultCounter;

        private ResolveContext(E replicas)
<span class="fc" id="L151">        {</span>
<span class="fc" id="L152">            this.replicas = replicas;</span>
<span class="fc" id="L153">            this.mergedResultCounter = command.limits().newCounter(command.nowInSec(),</span>
                                                                   true,
<span class="fc" id="L155">                                                                   command.selectsFullPartition(),</span>
                                                                   enforceStrictLiveness);
<span class="fc" id="L157">        }</span>

        private boolean needsReadRepair()
        {
<span class="fc bfc" id="L161" title="All 2 branches covered.">            return replicas.size() &gt; 1;</span>
        }

        private boolean needShortReadProtection()
        {
            // If we have only one result, there is no read repair to do and we can't get short reads
            // Also, so-called &quot;short reads&quot; stems from nodes returning only a subset of the results they have for a
            // partition due to the limit, but that subset not being enough post-reconciliation. So if we don't have limit,
            // don't bother protecting against short reads.
<span class="fc bfc" id="L170" title="All 4 branches covered.">            return replicas.size() &gt; 1 &amp;&amp; !command.limits().isUnlimited();</span>
        }
    }

    @FunctionalInterface
    private interface ResponseProvider
    {
        UnfilteredPartitionIterator getResponse(int i);
    }

    private UnfilteredPartitionIterator shortReadProtectedResponse(int i, ResolveContext context, @Nullable Runnable onShortRead)
    {
<span class="fc" id="L182">        UnfilteredPartitionIterator originalResponse = responses.get(i).payload.makeIterator(command);</span>

<span class="fc bfc" id="L184" title="All 2 branches covered.">        return context.needShortReadProtection()</span>
<span class="fc" id="L185">               ? ShortReadProtection.extend(context.replicas.get(i),</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">                                            () -&gt; { responses.clearUnsafe(i); if (onShortRead != null) onShortRead.run(); },</span>
                                            originalResponse,
                                            command,
                                            context.mergedResultCounter,
                                            queryStartNanoTime,
                                            enforceStrictLiveness)
<span class="fc" id="L192">               : originalResponse;</span>
    }

    private PartitionIterator resolveWithReadRepair(ResolveContext context,
                                                    ResponseProvider responseProvider,
                                                    UnaryOperator&lt;PartitionIterator&gt; preCountFilter,
                                                    RepairedDataTracker repairedDataTracker)
    {
<span class="fc" id="L200">        UnfilteredPartitionIterators.MergeListener listener = null;</span>
<span class="fc bfc" id="L201" title="All 4 branches covered.">        if (context.needsReadRepair() &amp;&amp; readRepair != NoopReadRepair.instance)</span>
        {
<span class="fc" id="L203">            P sources = replicaPlan.get().withContacts(context.replicas);</span>
<span class="fc" id="L204">            listener = wrapMergeListener(readRepair.getMergeListener(sources), sources, repairedDataTracker);</span>
        }

<span class="fc" id="L207">        return resolveInternal(context, listener, responseProvider, preCountFilter);</span>
    }

    @SuppressWarnings(&quot;resource&quot;)
    private PartitionIterator resolveWithReplicaFilteringProtection(E replicas, RepairedDataTracker repairedDataTracker)
    {
        // Protecting against inconsistent replica filtering (some replica returning a row that is outdated but that
        // wouldn't be removed by normal reconciliation because up-to-date replica have filtered the up-to-date version
        // of that row) involves 3 main elements:
        //   1) We combine short-read protection and a merge listener that identifies potentially &quot;out-of-date&quot;
        //      rows to create an iterator that is guaranteed to produce enough valid row results to satisfy the query
        //      limit if enough actually exist. A row is considered out-of-date if its merged from is non-empty and we
        //      receive not response from at least one replica. In this case, it is possible that filtering at the
        //      &quot;silent&quot; replica has produced a more up-to-date result.
        //   2) This iterator is passed to the standard resolution process with read-repair, but is first wrapped in a
        //      response provider that lazily &quot;completes&quot; potentially out-of-date rows by directly querying them on the
        //      replicas that were previously silent. As this iterator is consumed, it caches valid data for potentially
        //      out-of-date rows, and this cached data is merged with the fetched data as rows are requested. If there
        //      is no replica divergence, only rows in the partition being evalutated will be cached (then released
        //      when the partition is consumed).
        //   3) After a &quot;complete&quot; row is materialized, it must pass the row filter supplied by the original query
        //      before it counts against the limit.

        // We need separate contexts, as each context has his own counter
<span class="fc" id="L231">        ResolveContext firstPhaseContext = new ResolveContext(replicas);</span>
<span class="fc" id="L232">        ResolveContext secondPhaseContext = new ResolveContext(replicas);</span>
<span class="fc" id="L233">        ReplicaFilteringProtection&lt;E&gt; rfp = new ReplicaFilteringProtection&lt;&gt;(replicaPlan().keyspace(),</span>
                                                                             command,
<span class="fc" id="L235">                                                                             replicaPlan().consistencyLevel(),</span>
                                                                             queryStartNanoTime,
                                                                             firstPhaseContext.replicas,
<span class="fc" id="L238">                                                                             DatabaseDescriptor.getCachedReplicaRowsWarnThreshold(),</span>
<span class="fc" id="L239">                                                                             DatabaseDescriptor.getCachedReplicaRowsFailThreshold());</span>

<span class="fc" id="L241">        PartitionIterator firstPhasePartitions = resolveInternal(firstPhaseContext,</span>
<span class="fc" id="L242">                                                                 rfp.mergeController(),</span>
<span class="fc" id="L243">                                                                 i -&gt; shortReadProtectedResponse(i, firstPhaseContext, null),</span>
<span class="fc" id="L244">                                                                 UnaryOperator.identity());</span>

<span class="fc" id="L246">        PartitionIterator completedPartitions = resolveWithReadRepair(secondPhaseContext,</span>
<span class="fc" id="L247">                                                                      i -&gt; rfp.queryProtectedPartitions(firstPhasePartitions, i),</span>
<span class="fc" id="L248">                                                                      preCountFilterForReplicaFilteringProtection(),</span>
                                                                      repairedDataTracker);

        // Ensure that the RFP instance has a chance to record metrics when the iterator closes.
<span class="fc" id="L252">        return PartitionIterators.doOnClose(completedPartitions, firstPhasePartitions::close);</span>
    }

    private  UnaryOperator&lt;PartitionIterator&gt; preCountFilterForReplicaFilteringProtection()
    {
<span class="fc" id="L257">        return results -&gt; {</span>
<span class="fc" id="L258">            Index.Searcher searcher = command.indexSearcher();</span>
            // in case of &quot;ALLOW FILTERING&quot; without index
<span class="fc bfc" id="L260" title="All 2 branches covered.">            if (searcher == null)</span>
<span class="fc" id="L261">                return command.rowFilter().filter(results, command.metadata(), command.nowInSec());</span>
<span class="fc" id="L262">            return searcher.filterReplicaFilteringProtection(results);</span>
        };
    }

    @SuppressWarnings(&quot;resource&quot;)
    private PartitionIterator resolveInternal(ResolveContext context,
                                              UnfilteredPartitionIterators.MergeListener mergeListener,
                                              ResponseProvider responseProvider,
                                              UnaryOperator&lt;PartitionIterator&gt; preCountFilter)
    {
<span class="fc" id="L272">        int count = context.replicas.size();</span>
<span class="fc" id="L273">        List&lt;UnfilteredPartitionIterator&gt; results = new ArrayList&lt;&gt;(count);</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">        for (int i = 0; i &lt; count; i++)</span>
<span class="fc" id="L275">            results.add(responseProvider.getResponse(i));</span>

        /*
         * Even though every response, individually, will honor the limit, it is possible that we will, after the merge,
         * have more rows than the client requested. To make sure that we still conform to the original limit,
         * we apply a top-level post-reconciliation counter to the merged partition iterator.
         *
         * Short read protection logic (ShortReadRowsProtection.moreContents()) relies on this counter to be applied
         * to the current partition to work. For this reason we have to apply the counter transformation before
         * empty partition discard logic kicks in - for it will eagerly consume the iterator.
         *
         * That's why the order here is: 1) merge; 2) filter rows; 3) count; 4) discard empty partitions
         *
         * See CASSANDRA-13747 for more details.
         */

<span class="fc" id="L291">        UnfilteredPartitionIterator merged = UnfilteredPartitionIterators.merge(results, mergeListener);</span>
<span class="fc" id="L292">        Filter filter = new Filter(command.nowInSec(), command.metadata().enforceStrictLiveness());</span>
<span class="fc" id="L293">        FilteredPartitions filtered = FilteredPartitions.filter(merged, filter);</span>
<span class="fc" id="L294">        PartitionIterator counted = Transformation.apply(preCountFilter.apply(filtered), context.mergedResultCounter);</span>

<span class="fc" id="L296">        return Transformation.apply(counted, new EmptyPartitionsDiscarder());</span>
    }

    protected RepairedDataVerifier getRepairedDataVerifier(ReadCommand command)
    {
<span class="fc" id="L301">        return RepairedDataVerifier.verifier(command);</span>
    }

    private String makeResponsesDebugString(DecoratedKey partitionKey)
    {
<span class="nc" id="L306">        return Joiner.on(&quot;,\n&quot;).join(transform(getMessages().snapshot(), m -&gt; m.from() + &quot; =&gt; &quot; + m.payload.toDebugString(command, partitionKey)));</span>
    }

    private UnfilteredPartitionIterators.MergeListener wrapMergeListener(UnfilteredPartitionIterators.MergeListener partitionListener,
                                                                         P sources,
                                                                         RepairedDataTracker repairedDataTracker)
    {
        // Avoid wrapping no-op listener as it doesn't throw, unless we're tracking repaired status
        // in which case we need to inject the tracker &amp; verify on close
<span class="fc bfc" id="L315" title="All 2 branches covered.">        if (partitionListener == UnfilteredPartitionIterators.MergeListener.NOOP)</span>
        {
<span class="fc bfc" id="L317" title="All 2 branches covered.">            if (repairedDataTracker == null)</span>
<span class="fc" id="L318">                return partitionListener;</span>

<span class="fc" id="L320">            return new UnfilteredPartitionIterators.MergeListener()</span>
<span class="fc" id="L321">            {</span>

                public UnfilteredRowIterators.MergeListener getRowMergeListener(DecoratedKey partitionKey, List&lt;UnfilteredRowIterator&gt; versions)
                {
<span class="fc" id="L325">                    return UnfilteredRowIterators.MergeListener.NOOP;</span>
                }

                public void close()
                {
<span class="fc" id="L330">                    repairedDataTracker.verify();</span>
<span class="fc" id="L331">                }</span>
            };
        }

<span class="fc" id="L335">        return new UnfilteredPartitionIterators.MergeListener()</span>
<span class="fc" id="L336">        {</span>
            public UnfilteredRowIterators.MergeListener getRowMergeListener(DecoratedKey partitionKey, List&lt;UnfilteredRowIterator&gt; versions)
            {
<span class="fc" id="L339">                UnfilteredRowIterators.MergeListener rowListener = partitionListener.getRowMergeListener(partitionKey, versions);</span>

<span class="fc" id="L341">                return new UnfilteredRowIterators.MergeListener()</span>
<span class="fc" id="L342">                {</span>
                    public void onMergedPartitionLevelDeletion(DeletionTime mergedDeletion, DeletionTime[] versions)
                    {
                        try
                        {
<span class="fc" id="L347">                            rowListener.onMergedPartitionLevelDeletion(mergedDeletion, versions);</span>
                        }
<span class="nc" id="L349">                        catch (AssertionError e)</span>
                        {
                            // The following can be pretty verbose, but it's really only triggered if a bug happen, so we'd
                            // rather get more info to debug than not.
<span class="nc" id="L353">                            TableMetadata table = command.metadata();</span>
<span class="nc" id="L354">                            String details = String.format(&quot;Error merging partition level deletion on %s: merged=%s, versions=%s, sources={%s}, debug info:%n %s&quot;,</span>
                                                           table,
<span class="nc bnc" id="L356" title="All 2 branches missed.">                                                           mergedDeletion == null ? &quot;null&quot; : mergedDeletion.toString(),</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">                                                           '[' + Joiner.on(&quot;, &quot;).join(transform(Arrays.asList(versions), rt -&gt; rt == null ? &quot;null&quot; : rt.toString())) + ']',</span>
<span class="nc" id="L358">                                                           sources.contacts(),</span>
<span class="nc" id="L359">                                                           makeResponsesDebugString(partitionKey));</span>
<span class="nc" id="L360">                            throw new AssertionError(details, e);</span>
<span class="fc" id="L361">                        }</span>
<span class="fc" id="L362">                    }</span>

                    public Row onMergedRows(Row merged, Row[] versions)
                    {
                        try
                        {
<span class="fc" id="L368">                            return rowListener.onMergedRows(merged, versions);</span>
                        }
<span class="nc" id="L370">                        catch (AssertionError e)</span>
                        {
                            // The following can be pretty verbose, but it's really only triggered if a bug happen, so we'd
                            // rather get more info to debug than not.
<span class="nc" id="L374">                            TableMetadata table = command.metadata();</span>
<span class="nc" id="L375">                            String details = String.format(&quot;Error merging rows on %s: merged=%s, versions=%s, sources={%s}, debug info:%n %s&quot;,</span>
                                                           table,
<span class="nc bnc" id="L377" title="All 2 branches missed.">                                                           merged == null ? &quot;null&quot; : merged.toString(table),</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">                                                           '[' + Joiner.on(&quot;, &quot;).join(transform(Arrays.asList(versions), rt -&gt; rt == null ? &quot;null&quot; : rt.toString(table))) + ']',</span>
<span class="nc" id="L379">                                                           sources.contacts(),</span>
<span class="nc" id="L380">                                                           makeResponsesDebugString(partitionKey));</span>
<span class="nc" id="L381">                            throw new AssertionError(details, e);</span>
                        }
                    }

                    public void onMergedRangeTombstoneMarkers(RangeTombstoneMarker merged, RangeTombstoneMarker[] versions)
                    {
                        try
                        {
                            // The code for merging range tombstones is a tad complex and we had the assertions there triggered
                            // unexpectedly in a few occasions (CASSANDRA-13237, CASSANDRA-13719). It's hard to get insights
                            // when that happen without more context that what the assertion errors give us however, hence the
                            // catch here that basically gather as much as context as reasonable.
<span class="fc" id="L393">                            rowListener.onMergedRangeTombstoneMarkers(merged, versions);</span>
                        }
<span class="nc" id="L395">                        catch (AssertionError e)</span>
                        {

                            // The following can be pretty verbose, but it's really only triggered if a bug happen, so we'd
                            // rather get more info to debug than not.
<span class="nc" id="L400">                            TableMetadata table = command.metadata();</span>
<span class="nc" id="L401">                            String details = String.format(&quot;Error merging RTs on %s: merged=%s, versions=%s, sources={%s}, debug info:%n %s&quot;,</span>
                                                           table,
<span class="nc bnc" id="L403" title="All 2 branches missed.">                                                           merged == null ? &quot;null&quot; : merged.toString(table),</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">                                                           '[' + Joiner.on(&quot;, &quot;).join(transform(Arrays.asList(versions), rt -&gt; rt == null ? &quot;null&quot; : rt.toString(table))) + ']',</span>
<span class="nc" id="L405">                                                           sources.contacts(),</span>
<span class="nc" id="L406">                                                           makeResponsesDebugString(partitionKey));</span>
<span class="nc" id="L407">                            throw new AssertionError(details, e);</span>
<span class="fc" id="L408">                        }</span>

<span class="fc" id="L410">                    }</span>

                    public void close()
                    {
<span class="fc" id="L414">                        rowListener.close();</span>
<span class="fc" id="L415">                    }</span>
                };
            }

            public void close()
            {
<span class="fc" id="L421">                partitionListener.close();</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">                if (repairedDataTracker != null)</span>
<span class="fc" id="L423">                    repairedDataTracker.verify();</span>
<span class="fc" id="L424">            }</span>
        };
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>