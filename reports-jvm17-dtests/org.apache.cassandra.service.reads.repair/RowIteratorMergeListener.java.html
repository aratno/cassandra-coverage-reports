<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RowIteratorMergeListener.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.service.reads.repair</a> &gt; <span class="el_source">RowIteratorMergeListener.java</span></div><h1>RowIteratorMergeListener.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.service.reads.repair;

import java.util.Arrays;
import java.util.BitSet;
import java.util.Map;
import java.util.function.Consumer;

import com.google.common.collect.Iterables;
import com.google.common.collect.Maps;

import com.carrotsearch.hppc.ObjectIntHashMap;
import net.nicoulaj.compilecommand.annotations.Inline;
import org.apache.cassandra.db.Clustering;
import org.apache.cassandra.db.ClusteringBound;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.DeletionTime;
import org.apache.cassandra.db.LivenessInfo;
import org.apache.cassandra.db.Mutation;
import org.apache.cassandra.db.RangeTombstone;
import org.apache.cassandra.db.ReadCommand;
import org.apache.cassandra.db.RegularAndStaticColumns;
import org.apache.cassandra.db.Slice;
import org.apache.cassandra.db.filter.ColumnFilter;
import org.apache.cassandra.db.partitions.PartitionUpdate;
import org.apache.cassandra.db.rows.BTreeRow;
import org.apache.cassandra.db.rows.Cell;
import org.apache.cassandra.db.rows.RangeTombstoneMarker;
import org.apache.cassandra.db.rows.Row;
import org.apache.cassandra.db.rows.RowDiffListener;
import org.apache.cassandra.db.rows.Rows;
import org.apache.cassandra.db.rows.UnfilteredRowIterators;
import org.apache.cassandra.locator.Endpoints;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.locator.Replica;
import org.apache.cassandra.locator.ReplicaPlan;
import org.apache.cassandra.locator.ReplicaPlans;
import org.apache.cassandra.schema.ColumnMetadata;

<span class="fc" id="L57">public class RowIteratorMergeListener&lt;E extends Endpoints&lt;E&gt;&gt;</span>
        implements UnfilteredRowIterators.MergeListener
{
    private final DecoratedKey partitionKey;
    private final RegularAndStaticColumns columns;
    private final boolean isReversed;
    private final ReadCommand command;

    private final BitSet writeBackTo;
    private final boolean buildFullDiff;
    /** the repairs we will send to each source, suffixed by a complete repair of all differences, if {@link #buildFullDiff} */
    private final PartitionUpdate.Builder[] repairs;
    private final Row.Builder[] currentRows;
    private final RowDiffListener diffListener;
    private final ReplicaPlan.ForRead&lt;E, ?&gt; readPlan;
    private final ReplicaPlan.ForWrite writePlan;

    // The partition level deletion for the merge row.
    private DeletionTime partitionLevelDeletion;
    // When merged has a currently open marker, its time. null otherwise.
    private DeletionTime mergedDeletionTime;
    // For each source, the time of the current deletion as known by the source.
    private final DeletionTime[] sourceDeletionTime;
    // For each source, record if there is an open range to send as repair, and from where.
    private final ClusteringBound&lt;?&gt;[] markerToRepair;

    private final ReadRepair readRepair;

    public RowIteratorMergeListener(DecoratedKey partitionKey, RegularAndStaticColumns columns, boolean isReversed, ReplicaPlan.ForRead&lt;E, ?&gt; readPlan, ReadCommand command, ReadRepair readRepair)
<span class="fc" id="L86">    {</span>
<span class="fc" id="L87">        this.partitionKey = partitionKey;</span>
<span class="fc" id="L88">        this.columns = columns;</span>
<span class="fc" id="L89">        this.isReversed = isReversed;</span>
<span class="fc" id="L90">        this.readPlan = readPlan;</span>
<span class="fc" id="L91">        this.writePlan = ReplicaPlans.forReadRepair(partitionKey.getToken(), readPlan);</span>

<span class="fc" id="L93">        int size = readPlan.contacts().size();</span>
<span class="fc" id="L94">        this.writeBackTo = new BitSet(size);</span>
        {
<span class="fc" id="L96">            int i = 0;</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">            for (Replica replica : readPlan.contacts())</span>
            {
<span class="fc bfc" id="L99" title="All 2 branches covered.">                if (writePlan.contacts().endpoints().contains(replica.endpoint()))</span>
<span class="fc" id="L100">                    writeBackTo.set(i);</span>
<span class="fc" id="L101">                ++i;</span>
<span class="fc" id="L102">            }</span>
        }
        // If we are contacting any nodes we didn't read from, we are likely handling a range movement.
        // In this case we need to send all differences to these nodes, as we do not (with present design) know which
        // node they bootstrapped from, and so which data we need to duplicate.
        // In reality, there will be situations where we are simply sending the same number of writes to different nodes
        // and in this case we could probably avoid building a full difference, and only ensure each write makes it to
        // some other node, but it is probably not worth special casing this scenario.
<span class="fc bfc" id="L110" title="All 2 branches covered.">        this.buildFullDiff = Iterables.any(writePlan.contacts().endpoints(), e -&gt; !readPlan.contacts().endpoints().contains(e));</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">        this.repairs = new PartitionUpdate.Builder[size + (buildFullDiff ? 1 : 0)];</span>
<span class="fc" id="L112">        this.currentRows = new Row.Builder[size];</span>
<span class="fc" id="L113">        this.sourceDeletionTime = new DeletionTime[size];</span>
<span class="fc" id="L114">        this.markerToRepair = new ClusteringBound&lt;?&gt;[size];</span>
<span class="fc" id="L115">        this.command = command;</span>
<span class="fc" id="L116">        this.readRepair = readRepair;</span>

<span class="fc" id="L118">        this.diffListener = new RowDiffListener()</span>
<span class="fc" id="L119">        {</span>
            public void onPrimaryKeyLivenessInfo(int i, Clustering&lt;?&gt; clustering, LivenessInfo merged, LivenessInfo original)
            {
<span class="fc bfc" id="L122" title="All 4 branches covered.">                if (merged != null &amp;&amp; !merged.equals(original))</span>
<span class="fc" id="L123">                    currentRow(i, clustering).addPrimaryKeyLivenessInfo(merged);</span>
<span class="fc" id="L124">            }</span>

            public void onDeletion(int i, Clustering&lt;?&gt; clustering, Row.Deletion merged, Row.Deletion original)
            {
<span class="pc bpc" id="L128" title="1 of 4 branches missed.">                if (merged != null &amp;&amp; !merged.equals(original))</span>
<span class="fc" id="L129">                    currentRow(i, clustering).addRowDeletion(merged);</span>
<span class="fc" id="L130">            }</span>

            public void onComplexDeletion(int i, Clustering&lt;?&gt; clustering, ColumnMetadata column, DeletionTime merged, DeletionTime original)
            {
<span class="pc bpc" id="L134" title="1 of 4 branches missed.">                if (merged != null &amp;&amp; !merged.equals(original))</span>
<span class="fc" id="L135">                    currentRow(i, clustering).addComplexDeletion(column, merged);</span>
<span class="fc" id="L136">            }</span>

            public void onCell(int i, Clustering&lt;?&gt; clustering, Cell&lt;?&gt; merged, Cell&lt;?&gt; original)
            {
<span class="fc bfc" id="L140" title="All 6 branches covered.">                if (merged != null &amp;&amp; !merged.equals(original) &amp;&amp; isQueried(merged))</span>
<span class="fc" id="L141">                    currentRow(i, clustering).addCell(merged);</span>
<span class="fc" id="L142">            }</span>

            private boolean isQueried(Cell&lt;?&gt; cell)
            {
                // When we read, we may have some cell that have been fetched but are not selected by the user. Those cells may
                // have empty values as optimization (see CASSANDRA-10655) and hence they should not be included in the read-repair.
                // This is fine since those columns are not actually requested by the user and are only present for the sake of CQL
                // semantic (making sure we can always distinguish between a row that doesn't exist from one that do exist but has
                /// no value for the column requested by the user) and so it won't be unexpected by the user that those columns are
                // not repaired.
<span class="fc" id="L152">                ColumnMetadata column = cell.column();</span>
<span class="fc" id="L153">                ColumnFilter filter = RowIteratorMergeListener.this.command.columnFilter();</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">                return column.isComplex() ? filter.fetchedCellIsQueried(column, cell.path()) : filter.fetchedColumnIsQueried(column);</span>
            }
        };
<span class="fc" id="L157">    }</span>

    /**
     * The partition level deletion with with which source {@code i} is currently repaired, or
     * {@code DeletionTime.LIVE} if the source is not repaired on the partition level deletion (meaning it was
     * up to date on it). The output* of this method is only valid after the call to
     * {@link #onMergedPartitionLevelDeletion}.
     */
    private DeletionTime partitionLevelRepairDeletion(int i)
    {
<span class="fc bfc" id="L167" title="All 2 branches covered.">        return repairs[i] == null ? DeletionTime.LIVE : repairs[i].partitionLevelDeletion();</span>
    }

    private Row.Builder currentRow(int i, Clustering&lt;?&gt; clustering)
    {
<span class="fc bfc" id="L172" title="All 2 branches covered.">        if (currentRows[i] == null)</span>
        {
<span class="fc" id="L174">            currentRows[i] = BTreeRow.sortedBuilder();</span>
<span class="fc" id="L175">            currentRows[i].newRow(clustering);</span>
        }
<span class="fc" id="L177">        return currentRows[i];</span>
    }

    @Inline
    private void applyToPartition(int i, Consumer&lt;PartitionUpdate.Builder&gt; f)
    {
<span class="fc bfc" id="L183" title="All 2 branches covered.">        if (writeBackTo.get(i))</span>
        {
<span class="fc bfc" id="L185" title="All 2 branches covered.">            if (repairs[i] == null)</span>
<span class="fc" id="L186">                repairs[i] = new PartitionUpdate.Builder(command.metadata(), partitionKey, columns, 1);</span>
<span class="fc" id="L187">            f.accept(repairs[i]);</span>
        }
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (buildFullDiff)</span>
        {
<span class="fc bfc" id="L191" title="All 2 branches covered.">            if (repairs[repairs.length - 1] == null)</span>
<span class="fc" id="L192">                repairs[repairs.length - 1] = new PartitionUpdate.Builder(command.metadata(), partitionKey, columns, 1);</span>
<span class="fc" id="L193">            f.accept(repairs[repairs.length - 1]);</span>
        }
<span class="fc" id="L195">    }</span>

    public void onMergedPartitionLevelDeletion(DeletionTime mergedDeletion, DeletionTime[] versions)
    {
<span class="fc" id="L199">        this.partitionLevelDeletion = mergedDeletion;</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">        for (int i = 0; i &lt; versions.length; i++)</span>
        {
<span class="fc bfc" id="L202" title="All 2 branches covered.">            if (mergedDeletion.supersedes(versions[i]))</span>
<span class="fc" id="L203">                applyToPartition(i, p -&gt; p.addPartitionDeletion(mergedDeletion));</span>
        }
<span class="fc" id="L205">    }</span>

    public Row onMergedRows(Row merged, Row[] versions)
    {
        // If a row was shadowed post merged, it must be by a partition level or range tombstone, and we handle
        // those case directly in their respective methods (in other words, it would be inefficient to send a row
        // deletion as repair when we know we've already send a partition level or range tombstone that covers it).
<span class="fc bfc" id="L212" title="All 2 branches covered.">        if (merged.isEmpty())</span>
<span class="fc" id="L213">            return merged;</span>

<span class="fc" id="L215">        Rows.diff(diffListener, merged, versions);</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">        for (int i = 0; i &lt; currentRows.length; i++)</span>
        {
<span class="fc bfc" id="L218" title="All 2 branches covered.">            if (currentRows[i] != null)</span>
            {
<span class="fc" id="L220">                Row row = currentRows[i].build();</span>
<span class="fc" id="L221">                applyToPartition(i, p -&gt; p.add(row));</span>
            }
        }
<span class="fc" id="L224">        Arrays.fill(currentRows, null);</span>

<span class="fc" id="L226">        return merged;</span>
    }

    private DeletionTime currentDeletion()
    {
<span class="fc bfc" id="L231" title="All 2 branches covered.">        return mergedDeletionTime == null ? partitionLevelDeletion : mergedDeletionTime;</span>
    }

    public void onMergedRangeTombstoneMarkers(RangeTombstoneMarker merged, RangeTombstoneMarker[] versions)
    {
        // The current deletion as of dealing with this marker.
<span class="fc" id="L237">        DeletionTime currentDeletion = currentDeletion();</span>

<span class="fc bfc" id="L239" title="All 2 branches covered.">        for (int i = 0; i &lt; versions.length; i++)</span>
        {
            // we are not collecting a mutation for this version/source, skip;
<span class="fc bfc" id="L242" title="All 2 branches covered.">            if (!writeBackTo.get(i))</span>
<span class="fc" id="L243">                continue;</span>
<span class="fc" id="L244">            RangeTombstoneMarker marker = versions[i];</span>

            // Update what the source now thinks is the current deletion
<span class="fc bfc" id="L247" title="All 2 branches covered.">            if (marker != null)</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">                sourceDeletionTime[i] = marker.isOpen(isReversed) ? marker.openDeletionTime(isReversed) : null;</span>

            // If merged == null, some of the source is opening or closing a marker
<span class="fc bfc" id="L251" title="All 2 branches covered.">            if (merged == null)</span>
            {
                // but if it's not this source, move to the next one
<span class="fc bfc" id="L254" title="All 2 branches covered.">                if (marker == null)</span>
<span class="fc" id="L255">                    continue;</span>

                // We have a close and/or open marker for a source, with nothing corresponding in merged.
                // Because merged is a superset, this implies that we have a current deletion (either due to an
                // early opening in merged or a partition level deletion) and that this deletion will still be
                // active after that point. Further whatever deletion was open or is open by this marker on the
                // source, that deletion cannot supersedes the current one.
                //
                // But while the marker deletion (before and/or after this point) cannot supersede the current
                // deletion, we want to know if it's equal to it (both before and after), because in that case
                // the source is up to date and we don't want to include it into repair.
                //
                // So in practice we have 2 possible cases:
                //  1) the source was up-to-date on deletion up to that point: then it won't be from that point
                //     on unless it's a boundary and the new opened deletion time is also equal to the current
                //     deletion (note that this implies the boundary has the same closing and opening deletion
                //     time, which should generally not happen, but can due to legacy reading code not avoiding
                //     this for a while, see CASSANDRA-13237).
                //  2) the source wasn't up-to-date on deletion up to that point and it may now be (if it isn't
                //     we just have nothing to do for that marker).
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">                assert !currentDeletion.isLive() : currentDeletion.toString();</span>

                // Is the source up to date on deletion? It's up to date if it doesn't have an open RT repair
                // nor an &quot;active&quot; partition level deletion (where &quot;active&quot; means that it's greater or equal
                // to the current deletion: if the source has a repaired partition deletion lower than the
                // current deletion, this means the current deletion is due to a previously open range tombstone,
                // and if the source isn't currently repaired for that RT, then it means it's up to date on it).
<span class="fc" id="L282">                DeletionTime partitionRepairDeletion = partitionLevelRepairDeletion(i);</span>

<span class="fc bfc" id="L284" title="All 4 branches covered.">                if (markerToRepair[i] == null &amp;&amp; currentDeletion.supersedes(partitionRepairDeletion))</span>
                {
                    /*
                     * Since there is an ongoing merged deletion, the only two ways we don't have an open repair for
                     * this source are that:
                     *
                     * 1) it had a range open with the same deletion as current marker, and the marker is coming from
                     *    a short read protection response - repeating the open RT bound, or
                     * 2) it had a range open with the same deletion as current marker, and the marker is closing it.
                     */
<span class="pc bpc" id="L294" title="2 of 4 branches missed.">                    if (!marker.isBoundary() &amp;&amp; marker.isOpen(isReversed)) // (1)</span>
                    {
<span class="nc bnc" id="L296" title="All 2 branches missed.">                        assert currentDeletion.equals(marker.openDeletionTime(isReversed))</span>
<span class="nc" id="L297">                        : String.format(&quot;currentDeletion=%s, marker=%s&quot;, currentDeletion, marker.toString(command.metadata()));</span>
                    }
                    else // (2)
                    {
<span class="pc bpc" id="L301" title="2 of 4 branches missed.">                        assert marker.isClose(isReversed) &amp;&amp; currentDeletion.equals(marker.closeDeletionTime(isReversed))</span>
<span class="nc" id="L302">                        : String.format(&quot;currentDeletion=%s, marker=%s&quot;, currentDeletion, marker.toString(command.metadata()));</span>
                    }

                    // and so unless it's a boundary whose opening deletion time is still equal to the current
                    // deletion (see comment above for why this can actually happen), we have to repair the source
                    // from that point on.
<span class="pc bpc" id="L308" title="3 of 4 branches missed.">                    if (!(marker.isOpen(isReversed) &amp;&amp; currentDeletion.equals(marker.openDeletionTime(isReversed))))</span>
<span class="fc" id="L309">                        markerToRepair[i] = marker.closeBound(isReversed).invert();</span>
                }
                // In case 2) above, we only have something to do if the source is up-to-date after that point
                // (which, since the source isn't up-to-date before that point, means we're opening a new deletion
                // that is equal to the current one).
                else
                {
<span class="fc bfc" id="L316" title="All 2 branches covered.">                    if (markerToRepair[i] == null)</span>
                    {
                        // Only way we can have no open RT repair is that partition deletion that has the same timestamp
                        // as the deletion and same local deletion time. In such case, since partition deletion covers
                        // an entire partition, we do not include it into repair.
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">                        assert currentDeletion.localDeletionTime() == partitionRepairDeletion.localDeletionTime();</span>
                    }
<span class="pc bpc" id="L323" title="2 of 4 branches missed.">                    else if (marker.isOpen(isReversed) &amp;&amp; currentDeletion.equals(marker.openDeletionTime(isReversed)))</span>
                    {
<span class="fc" id="L325">                        closeOpenMarker(i, marker.openBound(isReversed).invert());</span>
                    }
                }
<span class="fc" id="L328">            }</span>
            else
            {
                // We have a change of current deletion in merged (potentially to/from no deletion at all).

<span class="fc bfc" id="L333" title="All 2 branches covered.">                if (merged.isClose(isReversed))</span>
                {
                    // We're closing the merged range. If we're recorded that this should be repaird for the
                    // source, close and add said range to the repair to send.
<span class="fc bfc" id="L337" title="All 2 branches covered.">                    if (markerToRepair[i] != null)</span>
<span class="fc" id="L338">                        closeOpenMarker(i, merged.closeBound(isReversed));</span>

                }

<span class="fc bfc" id="L342" title="All 2 branches covered.">                if (merged.isOpen(isReversed))</span>
                {
                    // If we're opening a new merged range (or just switching deletion), then unless the source
                    // is up to date on that deletion (note that we've updated what the source deleteion is
                    // above), we'll have to sent the range to the source.
<span class="fc" id="L347">                    DeletionTime newDeletion = merged.openDeletionTime(isReversed);</span>
<span class="fc" id="L348">                    DeletionTime sourceDeletion = sourceDeletionTime[i];</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">                    if (!newDeletion.equals(sourceDeletion))</span>
<span class="fc" id="L350">                        markerToRepair[i] = merged.openBound(isReversed);</span>
                }
            }
        }

<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (merged != null)</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">            mergedDeletionTime = merged.isOpen(isReversed) ? merged.openDeletionTime(isReversed) : null;</span>
<span class="fc" id="L357">    }</span>

    private void closeOpenMarker(int i, ClusteringBound&lt;?&gt; close)
    {
<span class="fc" id="L361">        ClusteringBound&lt;?&gt; open = markerToRepair[i];</span>
<span class="pc bpc" id="L362" title="2 of 4 branches missed.">        RangeTombstone rt = new RangeTombstone(Slice.make(isReversed ? close : open, isReversed ? open : close), currentDeletion());</span>
<span class="fc" id="L363">        applyToPartition(i, p -&gt; p.add(rt));</span>
<span class="fc" id="L364">        markerToRepair[i] = null;</span>
<span class="fc" id="L365">    }</span>

    public void close()
    {
<span class="fc" id="L369">        boolean hasRepairs = false;</span>
<span class="fc bfc" id="L370" title="All 4 branches covered.">        for (int i = 0 ; !hasRepairs &amp;&amp; i &lt; repairs.length ; ++i)</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">            hasRepairs = repairs[i] != null;</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (!hasRepairs)</span>
<span class="fc" id="L373">            return;</span>

<span class="fc" id="L375">        PartitionUpdate fullDiffRepair = null;</span>
<span class="pc bpc" id="L376" title="1 of 4 branches missed.">        if (buildFullDiff &amp;&amp; repairs[repairs.length - 1] != null)</span>
<span class="fc" id="L377">            fullDiffRepair = repairs[repairs.length - 1].build();</span>

<span class="fc" id="L379">        Map&lt;Replica, Mutation&gt; mutations = Maps.newHashMapWithExpectedSize(writePlan.contacts().size());</span>
<span class="fc" id="L380">        ObjectIntHashMap&lt;InetAddressAndPort&gt; sourceIds = new ObjectIntHashMap&lt;&gt;(((repairs.length + 1) * 4) / 3);</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">        for (int i = 0 ; i &lt; readPlan.contacts().size() ; ++i)</span>
<span class="fc" id="L382">            sourceIds.put(readPlan.contacts().get(i).endpoint(), 1 + i);</span>

<span class="fc bfc" id="L384" title="All 2 branches covered.">        for (Replica replica : writePlan.contacts())</span>
        {
<span class="fc" id="L386">            PartitionUpdate update = null;</span>
<span class="fc" id="L387">            int i = -1 + sourceIds.get(replica.endpoint());</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">            if (i &lt; 0)</span>
<span class="fc" id="L389">                update = fullDiffRepair;</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">            else if (repairs[i] != null)</span>
<span class="fc" id="L391">                update = repairs[i].build();</span>

<span class="fc" id="L393">            Mutation mutation = BlockingReadRepairs.createRepairMutation(update, readPlan.consistencyLevel(), replica.endpoint(), false);</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">            if (mutation == null)</span>
<span class="fc" id="L395">                continue;</span>

<span class="fc" id="L397">            mutations.put(replica, mutation);</span>
<span class="fc" id="L398">        }</span>

<span class="fc" id="L400">        readRepair.repairPartition(partitionKey, mutations, writePlan);</span>
<span class="fc" id="L401">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>