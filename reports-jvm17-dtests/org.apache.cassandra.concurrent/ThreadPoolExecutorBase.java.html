<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ThreadPoolExecutorBase.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.concurrent</a> &gt; <span class="el_source">ThreadPoolExecutorBase.java</span></div><h1>ThreadPoolExecutorBase.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.concurrent;

import java.util.List;
import java.util.concurrent.*;

import org.apache.cassandra.utils.concurrent.UncheckedInterruptedException;

/**
 * This class incorporates some Executor best practices for Cassandra.  Most of the executors in the system
 * should use or extend {@link ThreadPoolExecutorPlus}, or in rare exceptions this class.
 *
 * This class provides some very basic improvements:
 * &lt;li&gt;We are configured by {@link ThreadPoolExecutorBuilder}
 * &lt;li&gt;Tasks rejected due to overflow of the queue block the submitting thread rather than throwing {@link RejectedExecutionException}
 * &lt;li&gt;{@link RunnableFuture} rejected due to executor shutdown will be cancelled
 * &lt;li&gt;{@link RunnableFuture} removed by {@link #shutdownNow()} will be cancelled
 *
 * We also provide a shutdown hook for JMX registration cleanup.
 */
public class ThreadPoolExecutorBase extends ThreadPoolExecutor implements ResizableThreadPool
{
<span class="fc" id="L39">    public static final RejectedExecutionHandler blockingExecutionHandler = (task, executor) -&gt;</span>
    {
<span class="fc" id="L41">        BlockingQueue&lt;Runnable&gt; queue = executor.getQueue();</span>
        try
        {
            while (true)
            {
                try
                {
<span class="pc bpc" id="L48" title="1 of 2 branches missed.">                    if (executor.isShutdown())</span>
<span class="fc" id="L49">                        throw new RejectedExecutionException(executor + &quot; has shut down&quot;);</span>

<span class="nc bnc" id="L51" title="All 2 branches missed.">                    if (queue.offer(task, 1, TimeUnit.SECONDS))</span>
<span class="nc" id="L52">                        break;</span>
                }
<span class="nc" id="L54">                catch (InterruptedException e)</span>
                {
<span class="nc" id="L56">                    throw new UncheckedInterruptedException(e);</span>
<span class="nc" id="L57">                }</span>
            }
        }
<span class="fc" id="L60">        catch (Throwable t)</span>
        {
            //Give some notification to the caller the task isn't going to run
<span class="fc bfc" id="L63" title="All 2 branches covered.">            if (task instanceof java.util.concurrent.Future)</span>
<span class="fc" id="L64">                ((java.util.concurrent.Future&lt;?&gt;) task).cancel(false);</span>
<span class="fc" id="L65">            throw t;</span>
<span class="nc" id="L66">        }</span>
<span class="nc" id="L67">    };</span>

    private Runnable onShutdown;

    // maximumPoolSize is only used when corePoolSize == 0
    // if keepAliveTime &lt; 0 and unit == null, we forbid core thread timeouts (e.g. single threaded executors by default)
    public ThreadPoolExecutorBase(ThreadPoolExecutorBuilder&lt;?&gt; builder)
    {
<span class="fc" id="L75">        super(builder.coreThreads(), builder.maxThreads(), builder.keepAlive(), builder.keepAliveUnits(), builder.newQueue(), builder.newThreadFactory());</span>
<span class="fc" id="L76">        allowCoreThreadTimeOut(builder.allowCoreThreadTimeouts());</span>

        // block task submissions until queue has room.
        // this is fighting TPE's design a bit because TPE rejects if queue.offer reports a full queue.
        // we'll just override this with a handler that retries until it gets in.  ugly, but effective.
        // (there is an extensive analysis of the options here at
        //  http://today.java.net/pub/a/today/2008/10/23/creating-a-notifying-blocking-thread-pool-executor.html)
<span class="fc" id="L83">        setRejectedExecutionHandler(builder.rejectedExecutionHandler(blockingExecutionHandler));</span>
<span class="fc" id="L84">    }</span>

    // no RejectedExecutionHandler
    public ThreadPoolExecutorBase(int threads, int keepAlive, TimeUnit keepAliveUnits, BlockingQueue&lt;Runnable&gt; queue, NamedThreadFactory threadFactory)
    {
<span class="fc" id="L89">        super(threads, threads, keepAlive, keepAliveUnits, queue, threadFactory);</span>
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">        assert queue.isEmpty() : &quot;Executor initialized with non-empty task queue&quot;;</span>
<span class="fc" id="L91">        allowCoreThreadTimeOut(true);</span>
<span class="fc" id="L92">    }</span>

    public void onShutdown(Runnable onShutdown)
    {
<span class="fc" id="L96">        this.onShutdown = onShutdown;</span>
<span class="fc" id="L97">    }</span>

    public Runnable onShutdown()
    {
<span class="nc" id="L101">        return onShutdown;</span>
    }

    @Override
    protected void terminated()
    {
<span class="fc" id="L107">        getThreadFactory().close();</span>
<span class="fc" id="L108">    }</span>

    @Override
    public void shutdown()
    {
        try
        {
<span class="fc" id="L115">            super.shutdown();</span>
        }
        finally
        {
<span class="fc bfc" id="L119" title="All 2 branches covered.">            if (onShutdown != null)</span>
<span class="fc" id="L120">                onShutdown.run();</span>
        }
<span class="fc" id="L122">    }</span>

    @Override
    public List&lt;Runnable&gt; shutdownNow()
    {
        try
        {
<span class="fc" id="L129">            List&lt;Runnable&gt; cancelled = super.shutdownNow();</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">            for (Runnable c : cancelled)</span>
            {
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">                if (c instanceof java.util.concurrent.Future&lt;?&gt;)</span>
<span class="fc" id="L133">                    ((java.util.concurrent.Future&lt;?&gt;) c).cancel(true);</span>
<span class="fc" id="L134">            }</span>
<span class="fc" id="L135">            return cancelled;</span>
        }
        finally
        {
<span class="fc bfc" id="L139" title="All 2 branches covered.">            if (onShutdown != null)</span>
<span class="fc" id="L140">                onShutdown.run();</span>
        }
    }
    
    @Override
    public int getActiveTaskCount()
    {
<span class="fc" id="L147">        return getActiveCount();</span>
    }

    @Override
    public int getPendingTaskCount()
    {
<span class="fc" id="L153">        return getQueue().size();</span>
    }

    public int getCoreThreads()
    {
<span class="fc" id="L158">        return getCorePoolSize();</span>
    }

    public void setCoreThreads(int number)
    {
<span class="nc" id="L163">        setCorePoolSize(number);</span>
<span class="nc" id="L164">    }</span>

    public int getMaximumThreads()
    {
<span class="fc" id="L168">        return getMaximumPoolSize();</span>
    }

    public void setMaximumThreads(int number)
    {
<span class="nc" id="L173">        setMaximumPoolSize(number);</span>
<span class="nc" id="L174">    }</span>

    @Override
    public NamedThreadFactory getThreadFactory()
    {
<span class="fc" id="L179">        return (NamedThreadFactory) super.getThreadFactory();</span>
    }

    public String toString()
    {
<span class="fc" id="L184">        return getThreadFactory().id;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>