<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Descriptor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.io.sstable</a> &gt; <span class="el_source">Descriptor.java</span></div><h1>Descriptor.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.io.sstable;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Objects;
import com.google.common.base.Splitter;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.Directories;
import org.apache.cassandra.io.sstable.format.SSTableFormat;
import org.apache.cassandra.io.sstable.format.Version;
import org.apache.cassandra.io.sstable.metadata.IMetadataSerializer;
import org.apache.cassandra.io.sstable.metadata.MetadataSerializer;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.utils.Pair;

import static com.google.common.base.Preconditions.checkNotNull;
import static org.apache.cassandra.io.sstable.Component.separator;
import static org.apache.cassandra.utils.TimeUUID.Generator.nextTimeUUID;

/**
 * A SSTable is described by the keyspace and column family it contains data
 * for, an id (generation - where higher generations contain more recent data) and
 * an alphabetic version string.
 *
 * A descriptor can be marked as temporary, which influences generated filenames.
 */
public class Descriptor
{
<span class="fc" id="L56">    private static final Logger logger = LoggerFactory.getLogger(Descriptor.class);</span>

    // Current SSTable directory format is {keyspace}/{tableName}-{tableId}[/backups|/snapshots/{tag}][/.{indexName}]/{component}.db
    // * {var} are mandatory components
    // * [var] are optional components
    //
    // Note: The component allows the '+' character in addition to the characters supported by other elements in order
    // to all custom components to have an ability to support structured naming of the component that is transparent
    // to the SSTable naming.
<span class="fc" id="L65">    static final Pattern SSTABLE_DIR_PATTERN = Pattern.compile(&quot;.*/(?&lt;keyspace&gt;\\w+)/&quot; +</span>
                                                               &quot;(?&lt;tableName&gt;\\w+)-(?&lt;tableId&gt;[0-9a-f]{32})/&quot; +
                                                               &quot;(backups/|snapshots/(?&lt;tag&gt;[\\w-]+)/)?&quot; +
                                                               &quot;(\\.(?&lt;indexName&gt;[\\w-]+)/)?&quot; +
                                                               &quot;(?&lt;component&gt;[\\w-\\+]+)\\.(?&lt;ext&gt;[\\w]+)$&quot;);

    // Pre 2.1 SSTable directory format is {keyspace}/{tableName}-{tableId}[/backups|/snapshots/{tag}][/.{indexName}]/{component}.db
<span class="fc" id="L72">    static final Pattern LEGACY_SSTABLE_DIR_PATTERN = Pattern.compile(&quot;.*/(?&lt;keyspace&gt;\\w+)/&quot; +</span>
                                                                      &quot;(?&lt;tableName&gt;\\w+)/&quot; +
                                                                      &quot;(backups/|snapshots/(?&lt;tag&gt;[\\w-]+)/)?&quot; +
                                                                      &quot;(\\.(?&lt;indexName&gt;[\\w-]+)/)?&quot; +
                                                                      &quot;(?&lt;component&gt;[\\w-]+)\\.(?&lt;ext&gt;[\\w]+)$&quot;);

    private final static String LEGACY_TMP_REGEX_STR = &quot;^((.*)\\-(.*)\\-)?tmp(link)?\\-((?:l|k).)\\-(\\d)*\\-(.*)$&quot;;
<span class="fc" id="L79">    private final static Pattern LEGACY_TMP_REGEX = Pattern.compile(LEGACY_TMP_REGEX_STR);</span>

    public static final String EXTENSION = &quot;.db&quot;;

<span class="fc" id="L83">    public static String TMP_EXT = &quot;.tmp&quot;;</span>

    public static final char FILENAME_SEPARATOR = '-';

<span class="fc" id="L87">    private static final Splitter filenameSplitter = Splitter.on(FILENAME_SEPARATOR);</span>

    /** canonicalized path to the directory where SSTable resides */
    public final File directory;
    /** version has the following format: &lt;code&gt;[a-z]+&lt;/code&gt; */
    public final Version version;
    public final String ksname;
    public final String cfname;
    public final SSTableId id;
    private final int hashCode;
    private final String prefix;
    private final File baseFile;

    /**
     * A descriptor that assumes CURRENT_VERSION.
     */
    @VisibleForTesting
    public Descriptor(File directory, String ksname, String cfname, SSTableId id)
    {
<span class="nc" id="L106">        this(DatabaseDescriptor.getSelectedSSTableFormat().getLatestVersion(), directory, ksname, cfname, id);</span>
<span class="nc" id="L107">    }</span>

    /**
     * Constructor for sstable writers only.
     */
    public Descriptor(File directory, String ksname, String cfname, SSTableId id, SSTableFormat&lt;?, ?&gt; format)
    {
<span class="nc" id="L114">        this(format.getLatestVersion(), directory, ksname, cfname, id);</span>
<span class="nc" id="L115">    }</span>

    @VisibleForTesting
    public Descriptor(String version, File directory, String ksname, String cfname, SSTableId id, SSTableFormat&lt;?, ?&gt; format)
    {
<span class="nc" id="L120">        this(format.getVersion(version), directory, ksname, cfname, id);</span>
<span class="nc" id="L121">    }</span>

    public Descriptor(Version version, File directory, String ksname, String cfname, SSTableId id)
<span class="fc" id="L124">    {</span>
<span class="fc" id="L125">        checkNotNull(version);</span>
<span class="fc" id="L126">        checkNotNull(directory);</span>
<span class="fc" id="L127">        checkNotNull(ksname);</span>
<span class="fc" id="L128">        checkNotNull(cfname);</span>

<span class="fc" id="L130">        this.version = version;</span>
<span class="fc" id="L131">        this.directory = directory.toCanonical();</span>
<span class="fc" id="L132">        this.ksname = ksname;</span>
<span class="fc" id="L133">        this.cfname = cfname;</span>
<span class="fc" id="L134">        this.id = id;</span>

<span class="fc" id="L136">        StringBuilder buf = new StringBuilder();</span>
<span class="fc" id="L137">        appendFileName(buf);</span>
<span class="fc" id="L138">        this.prefix = buf.toString();</span>
<span class="fc" id="L139">        this.baseFile = new File(directory.toPath().resolve(prefix));</span>

        // directory is unnecessary for hashCode, and for simulator consistency we do not include it
<span class="fc" id="L142">        hashCode = Objects.hashCode(version, id, ksname, cfname);</span>
<span class="fc" id="L143">    }</span>

    private String tmpFilenameFor(Component component)
    {
<span class="fc" id="L147">        return fileFor(component) + TMP_EXT;</span>
    }

    public File tmpFileFor(Component component)
    {
<span class="fc" id="L152">        return new File(directory.toPath().resolve(tmpFilenameFor(component)));</span>
    }

    private String tmpFilenameForStreaming(Component component)
    {
        // Use UUID to handle concurrent streamings on the same sstable.
        // TMP_EXT allows temp file to be removed by {@link ColumnFamilyStore#scrubDataDirectories}
<span class="fc" id="L159">        return String.format(&quot;%s.%s%s&quot;, filenameFor(component), nextTimeUUID(), TMP_EXT);</span>
    }

    /**
     * @return a unique temporary file name for given component during entire-sstable-streaming.
     */
    public File tmpFileForStreaming(Component component)
    {
<span class="fc" id="L167">        return new File(directory.toPath().resolve(tmpFilenameForStreaming(component)));</span>
    }

    private String filenameFor(Component component)
    {
<span class="fc" id="L172">        return prefix + separator + component.name();</span>
    }

    public File fileFor(Component component)
    {
<span class="fc" id="L177">        return new File(directory.toPath().resolve(filenameFor(component)));</span>
    }

    public File baseFile()
    {
<span class="fc" id="L182">        return baseFile;</span>
    }

    private void appendFileName(StringBuilder buff)
    {
<span class="fc" id="L187">        buff.append(version).append(separator);</span>
<span class="fc" id="L188">        buff.append(id.toString());</span>
<span class="fc" id="L189">        buff.append(separator).append(version.format.name());</span>
<span class="fc" id="L190">    }</span>

    public String relativeFilenameFor(Component component)
    {
<span class="fc" id="L194">        final StringBuilder buff = new StringBuilder();</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">        if (Directories.isSecondaryIndexFolder(directory))</span>
        {
<span class="fc" id="L197">            buff.append(directory.name()).append(File.pathSeparator());</span>
        }

<span class="fc" id="L200">        appendFileName(buff);</span>
<span class="fc" id="L201">        buff.append(separator).append(component.name());</span>
<span class="fc" id="L202">        return buff.toString();</span>
    }

    public SSTableFormat&lt;?, ?&gt; getFormat()
    {
<span class="fc" id="L207">        return version.format;</span>
    }

    /** Return any temporary files found in the directory */
    public List&lt;File&gt; getTemporaryFiles()
    {
<span class="fc" id="L213">        File[] tmpFiles = directory.tryList((dir, name) -&gt;</span>
<span class="fc" id="L214">                                              name.endsWith(Descriptor.TMP_EXT));</span>

<span class="fc" id="L216">        List&lt;File&gt; ret = new ArrayList&lt;&gt;(tmpFiles.length);</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">        for (File tmpFile : tmpFiles)</span>
<span class="nc" id="L218">            ret.add(tmpFile);</span>

<span class="fc" id="L220">        return ret;</span>
    }

    /**
     * Returns the set of components consisting of the provided mandatory components and those optional components
     * for which the corresponding file exists.
     */
    public Set&lt;Component&gt; getComponents(Set&lt;Component&gt; mandatory, Set&lt;Component&gt; optional)
    {
<span class="fc" id="L229">        ImmutableSet.Builder&lt;Component&gt; builder = ImmutableSet.builder();</span>
<span class="fc" id="L230">        builder.addAll(mandatory);</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">        for (Component component : optional)</span>
        {
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">            if (fileFor(component).exists())</span>
<span class="fc" id="L234">                builder.add(component);</span>
<span class="fc" id="L235">        }</span>
<span class="fc" id="L236">        return builder.build();</span>
    }

    public static boolean isValidFile(File file)
    {
<span class="fc" id="L241">        String filename = file.name();</span>
<span class="pc bpc" id="L242" title="1 of 4 branches missed.">        return filename.endsWith(EXTENSION) &amp;&amp; !LEGACY_TMP_REGEX.matcher(filename).matches();</span>
    }

    /**
     * Parse a sstable filename into a Descriptor.
     * &lt;p&gt;
     * SSTables files are all located within subdirectories of the form {@code &lt;keyspace&gt;/&lt;table&gt;/}. Normal sstables are
     * are directly within that subdirectory structure while 2ndary index, backups and snapshot are each inside an
     * additional subdirectory. The file themselves have the form:
     *   {@code &lt;version&gt;-&lt;gen&gt;-&lt;format&gt;-&lt;component&gt;}.
     * &lt;p&gt;
     * Note that this method will only sucessfully parse sstable files of supported versions.
     *
     * @param file the {@code File} object for the filename to parse.
     * @return the descriptor for the parsed file.
     *
     * @throws IllegalArgumentException if the provided {@code file} does point to a valid sstable filename. This could
     * mean either that the filename doesn't look like a sstable file, or that it is for an old and unsupported
     * versions.
     */
    public static Descriptor fromFile(File file)
    {
<span class="fc" id="L264">        return fromFileWithComponent(file).left;</span>
    }

    public static Component componentFromFile(File file)
    {
<span class="nc" id="L269">        String name = file.name();</span>
<span class="nc" id="L270">        List&lt;String&gt; tokens = filenameTokens(name);</span>

<span class="nc" id="L272">        return Component.parse(tokens.get(3), formatFromName(name, tokens));</span>
    }

    private static SSTableFormat&lt;?, ?&gt; formatFromName(String fileName, List&lt;String&gt; tokens)
    {
<span class="fc" id="L277">        String formatString = tokens.get(2);</span>
<span class="fc" id="L278">        SSTableFormat&lt;?, ?&gt; format = DatabaseDescriptor.getSSTableFormats().get(formatString);</span>
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">        if (format == null)</span>
<span class="nc" id="L280">            throw invalidSSTable(fileName, &quot;unknown 'format' part (%s)&quot;, formatString);</span>
<span class="fc" id="L281">        return format;</span>
    }

    /**
     * Parse a sstable filename, extracting both the {@code Descriptor} and {@code Component} part.
     * The keyspace/table name will be extracted from the directory path.
     *
     * @param file the {@code File} object for the filename to parse.
     * @return a pair of the descriptor and component corresponding to the provided {@code file}.
     *
     * @throws IllegalArgumentException if the provided {@code file} does point to a valid sstable filename. This could
     * mean either that the filename doesn't look like a sstable file, or that it is for an old and unsupported
     * versions.
     */
    public static Pair&lt;Descriptor, Component&gt; fromFileWithComponent(File file)
    {
<span class="fc" id="L297">        return fromFileWithComponent(file, true);</span>
    }

    public static Pair&lt;Descriptor, Component&gt; fromFileWithComponent(File file, boolean validateDirs)
    {
        // We need to extract the keyspace and table names from the parent directories, so make sure we deal with the
        // absolute path.
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">        if (!file.isAbsolute())</span>
<span class="nc" id="L305">            file = file.toAbsolute();</span>

<span class="fc" id="L307">        SSTableInfo info = validateAndExtractInfo(file);</span>
<span class="fc" id="L308">        String name = file.name();</span>

<span class="fc" id="L310">        String keyspaceName = &quot;&quot;;</span>
<span class="fc" id="L311">        String tableName = &quot;&quot;;</span>

<span class="fc" id="L313">        Matcher sstableDirMatcher = SSTABLE_DIR_PATTERN.matcher(file.toString());</span>

        // Use pre-2.1 SSTable format if current one does not match it
<span class="fc bfc" id="L316" title="All 2 branches covered.">        if (!sstableDirMatcher.find(0))</span>
        {
<span class="fc" id="L318">            sstableDirMatcher = LEGACY_SSTABLE_DIR_PATTERN.matcher(file.toString());</span>
        }

<span class="fc bfc" id="L321" title="All 2 branches covered.">        if (sstableDirMatcher.find(0))</span>
        {
<span class="fc" id="L323">            keyspaceName = sstableDirMatcher.group(&quot;keyspace&quot;);</span>
<span class="fc" id="L324">            tableName = sstableDirMatcher.group(&quot;tableName&quot;);</span>
<span class="fc" id="L325">            String indexName = sstableDirMatcher.group(&quot;indexName&quot;);</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">            if (indexName != null)</span>
            {
<span class="fc" id="L328">                tableName = String.format(&quot;%s.%s&quot;, tableName, indexName);</span>
            }
<span class="fc" id="L330">        }</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">        else if (validateDirs)</span>
        {
<span class="fc" id="L333">            logger.debug(&quot;Could not extract keyspace/table info from sstable directory {}&quot;, file.toString());</span>
<span class="nc" id="L334">            throw invalidSSTable(name, String.format(&quot;cannot extract keyspace and table name from %s; make sure the sstable is in the proper sub-directories&quot;, file));</span>
        }

<span class="fc" id="L337">        return Pair.create(new Descriptor(info.version, parentOf(name, file), keyspaceName, tableName, info.id), info.component);</span>
    }

    /**
     * Parse a sstable filename, extracting both the {@code Descriptor} and {@code Component} part.
     *
     * @param file     the {@code File} object for the filename to parse.
     * @param keyspace The keyspace name of the file. If &lt;code&gt;null&lt;/code&gt;, then the keyspace name will be extracted
     *                 from the directory path.
     * @param table    The table name of the file. If &lt;code&gt;null&lt;/code&gt;, then the table name will be extracted from the
     *                 directory path.
     * @return a pair of the descriptor and component corresponding to the provided {@code file}.
     * @throws IllegalArgumentException if the provided {@code file} does point to a valid sstable filename. This could
     *                                  mean either that the filename doesn't look like a sstable file, or that it is for an old and unsupported
     *                                  versions.
     */
    public static Pair&lt;Descriptor, Component&gt; fromFileWithComponent(File file, String keyspace, String table)
    {
<span class="nc bnc" id="L355" title="All 4 branches missed.">        if (null == keyspace || null == table)</span>
        {
<span class="nc" id="L357">            return fromFileWithComponent(file);</span>
        }

<span class="nc" id="L360">        SSTableInfo info = validateAndExtractInfo(file);</span>
<span class="nc" id="L361">        return Pair.create(new Descriptor(info.version, parentOf(file.name(), file), keyspace, table, info.id), info.component);</span>
    }

    private static List&lt;String&gt; filenameTokens(String name)
    {
<span class="fc" id="L366">        List&lt;String&gt; tokens = filenameSplitter.splitToList(name);</span>
<span class="fc" id="L367">        int size = tokens.size();</span>

<span class="fc bfc" id="L369" title="All 2 branches covered.">        if (size != 4)</span>
        {
            // This is an invalid sstable file for this version. But to provide a more helpful error message, we detect
            // old format sstable, which had the format:
            //   &lt;keyspace&gt;-&lt;table&gt;-(tmp-)?&lt;version&gt;-&lt;gen&gt;-&lt;component&gt;
            // Note that we assume it's an old format sstable if it has the right number of tokens: this is not perfect
            // but we're just trying to be helpful, not perfect.
<span class="pc bpc" id="L376" title="2 of 4 branches missed.">            if (size == 5 || size == 6)</span>
<span class="nc" id="L377">                throw new IllegalArgumentException(String.format(&quot;%s is of version %s which is now unsupported and cannot be read.&quot;, name, tokens.get(size - 3)));</span>
<span class="fc" id="L378">            throw new IllegalArgumentException(String.format(&quot;Invalid sstable file %s: the name doesn't look like a supported sstable file name&quot;, name));</span>
        }
<span class="fc" id="L380">        return tokens;</span>
    }

    private static SSTableInfo validateAndExtractInfo(File file)
    {
<span class="fc" id="L385">        String name = file.name();</span>
<span class="fc" id="L386">        List&lt;String&gt; tokens = filenameTokens(name);</span>

<span class="fc" id="L388">        String versionString = tokens.get(0);</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        if (!Version.validate(versionString))</span>
<span class="nc" id="L390">            throw invalidSSTable(name, &quot;invalid version %s&quot;, versionString);</span>

        SSTableId id;
        try
        {
<span class="fc" id="L395">            id = SSTableIdFactory.instance.fromString(tokens.get(1));</span>
        }
<span class="nc" id="L397">        catch (RuntimeException e)</span>
        {
<span class="nc" id="L399">            throw invalidSSTable(name, &quot;the 'id' part (%s) of the name doesn't parse as a valid unique identifier&quot;, tokens.get(1));</span>
<span class="fc" id="L400">        }</span>

<span class="fc" id="L402">        SSTableFormat&lt;?, ?&gt; format = formatFromName(name, tokens);</span>
<span class="fc" id="L403">        Component component = Component.parse(tokens.get(3), format);</span>

<span class="fc" id="L405">        Version version = format.getVersion(versionString);</span>
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">        if (!version.isCompatible())</span>
<span class="nc" id="L407">            throw invalidSSTable(name, &quot;incompatible sstable version (%s); you should have run upgradesstables before upgrading&quot;, versionString);</span>

<span class="fc" id="L409">        return new SSTableInfo(version, id, component);</span>
    }

    private static class SSTableInfo
    {
        final Version version;
        final SSTableId id;
        final Component component;

        SSTableInfo(Version version, SSTableId id, Component component)
<span class="fc" id="L419">        {</span>
<span class="fc" id="L420">            this.version = version;</span>
<span class="fc" id="L421">            this.id = id;</span>
<span class="fc" id="L422">            this.component = component;</span>
<span class="fc" id="L423">        }</span>
    }

    private static File parentOf(String name, File file)
    {
<span class="fc" id="L428">        File parent = file.parent();</span>
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">        if (parent == null)</span>
<span class="nc" id="L430">            throw invalidSSTable(name, &quot;cannot extract keyspace and table name; make sure the sstable is in the proper sub-directories&quot;);</span>
<span class="fc" id="L431">        return parent;</span>
    }

    private static IllegalArgumentException invalidSSTable(String name, String msgFormat, Object... parameters)
    {
<span class="fc" id="L436">        throw new IllegalArgumentException(String.format(&quot;Invalid sstable file &quot; + name + &quot;: &quot; + msgFormat, parameters));</span>
    }

    public IMetadataSerializer getMetadataSerializer()
    {
<span class="fc" id="L441">        return new MetadataSerializer();</span>
    }

    /**
     * @return true if the current Cassandra version can read the given sstable version
     */
    public boolean isCompatible()
    {
<span class="fc" id="L449">        return version.isCompatible();</span>
    }

    public Set&lt;Component&gt; discoverComponents()
    {
<span class="fc" id="L454">        Set&lt;Component&gt; components = Sets.newHashSetWithExpectedSize(Component.Type.all.size());</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">        for (Component component : Component.getSingletonsFor(version.format))</span>
        {
<span class="fc bfc" id="L457" title="All 2 branches covered.">            if (fileFor(component).exists())</span>
<span class="fc" id="L458">                components.add(component);</span>
<span class="fc" id="L459">        }</span>
<span class="fc" id="L460">        return components;</span>
    }

    @Override
    public String toString()
    {
<span class="fc" id="L466">        return baseFile().absolutePath();</span>
    }

    @Override
    public boolean equals(Object o)
    {
<span class="fc bfc" id="L472" title="All 2 branches covered.">        if (o == this)</span>
<span class="fc" id="L473">            return true;</span>
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">        if (!(o instanceof Descriptor))</span>
<span class="nc" id="L475">            return false;</span>
<span class="fc" id="L476">        Descriptor that = (Descriptor)o;</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">        if (this.hashCode != that.hashCode)</span>
<span class="fc" id="L478">            return false;</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">        return that.directory.equals(this.directory)</span>
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">                       &amp;&amp; that.id.equals(this.id)</span>
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">                       &amp;&amp; that.ksname.equals(this.ksname)</span>
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">                       &amp;&amp; that.cfname.equals(this.cfname)</span>
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">                       &amp;&amp; that.version.equals(this.version);</span>
    }

    @Override
    public int hashCode()
    {
<span class="fc" id="L489">        return hashCode;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>