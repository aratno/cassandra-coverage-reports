<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StreamingState.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.streaming</a> &gt; <span class="el_source">StreamingState.java</span></div><h1>StreamingState.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.streaming;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.net.InetSocketAddress;
import java.util.Collections;
import java.util.EnumMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

import javax.annotation.concurrent.GuardedBy;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Throwables;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.cache.IMeasurableMemory;
import org.apache.cassandra.db.virtual.SimpleDataSet;
import org.apache.cassandra.tools.nodetool.formatter.TableBuilder;
import org.apache.cassandra.utils.Clock;
import org.apache.cassandra.utils.ObjectSizes;
import org.apache.cassandra.utils.TimeUUID;
import org.checkerframework.checker.nullness.qual.Nullable;

import static org.apache.cassandra.utils.TimeUUID.Generator.nextTimeUUID;

public class StreamingState implements StreamEventHandler, IMeasurableMemory
{
<span class="fc" id="L49">    private static final Logger logger = LoggerFactory.getLogger(StreamingState.class);</span>

<span class="fc" id="L51">    public static final long EMPTY = ObjectSizes.measureDeep(new StreamingState(nextTimeUUID(), StreamOperation.OTHER, false));</span>

<span class="fc" id="L53">    public enum Status</span>
<span class="fc" id="L54">    {INIT, START, SUCCESS, FAILURE}</span>

<span class="fc" id="L56">    private final long createdAtMillis = Clock.Global.currentTimeMillis();</span>

    private final TimeUUID id;
    private final boolean follower;
    private final StreamOperation operation;
<span class="fc" id="L61">    private final Set&lt;InetSocketAddress&gt; peers = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;());</span>
<span class="fc" id="L62">    @GuardedBy(&quot;this&quot;)</span>
    private final Sessions sessions = new Sessions();

    private Status status;
<span class="fc" id="L66">    private String completeMessage = null;</span>

    private final long[] stateTimesNanos;
    private volatile long lastUpdatedAtNanos;

    // API for state changes
<span class="fc" id="L72">    public final Phase phase = new Phase();</span>

    @Override
    public long unsharedHeapSize()
    {
<span class="fc" id="L77">        long costOfPeers = peers().size() * (ObjectSizes.IPV6_SOCKET_ADDRESS_SIZE + 48); // 48 represents the datastructure cost computed by the JOL</span>
<span class="fc" id="L78">        long costOfCompleteMessage = ObjectSizes.sizeOf(completeMessage());</span>
<span class="fc" id="L79">        return costOfPeers + costOfCompleteMessage + EMPTY;</span>
    }

    public StreamingState(StreamResultFuture result)
    {
<span class="fc" id="L84">        this(result.planId, result.streamOperation, result.getCoordinator().isFollower());</span>
<span class="fc" id="L85">    }</span>

    private StreamingState(TimeUUID planId, StreamOperation streamOperation, boolean follower)
<span class="fc" id="L88">    {</span>
<span class="fc" id="L89">        this.id = planId;</span>
<span class="fc" id="L90">        this.operation = streamOperation;</span>
<span class="fc" id="L91">        this.follower = follower;</span>
<span class="fc" id="L92">        this.stateTimesNanos = new long[Status.values().length];</span>
<span class="fc" id="L93">        updateState(Status.INIT);</span>
<span class="fc" id="L94">    }</span>

    public TimeUUID id()
    {
<span class="fc" id="L98">        return id;</span>
    }

    public boolean follower()
    {
<span class="fc" id="L103">        return follower;</span>
    }

    public StreamOperation operation()
    {
<span class="fc" id="L108">        return operation;</span>
    }

    public Set&lt;InetSocketAddress&gt; peers()
    {
<span class="fc" id="L113">        return this.peers;</span>
    }

    public String completeMessage()
    {
<span class="fc" id="L118">        return this.completeMessage;</span>
    }

    public Status status()
    {
<span class="fc" id="L123">        return status;</span>
    }

    public Sessions sessions()
    {
<span class="fc" id="L128">        return sessions;</span>
    }

    public boolean isComplete()
    {
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">        switch (status)</span>
        {
            case SUCCESS:
            case FAILURE:
<span class="fc" id="L137">                return true;</span>
            default:
<span class="nc" id="L139">                return false;</span>
        }
    }

    @VisibleForTesting
    public StreamResultFuture future()
    {
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (follower)</span>
<span class="nc" id="L147">            return StreamManager.instance.getReceivingStream(id);</span>
        else
<span class="nc" id="L149">            return StreamManager.instance.getInitiatorStream(id);</span>
    }

    public float progress()
    {
<span class="pc bpc" id="L154" title="3 of 4 branches missed.">        switch (status)</span>
        {
            case INIT:
<span class="nc" id="L157">                return 0;</span>
            case START:
<span class="nc" id="L159">                return Math.min(0.99f, sessions().progress().floatValue());</span>
            case SUCCESS:
            case FAILURE:
<span class="fc" id="L162">                return 1;</span>
            default:
<span class="nc" id="L164">                throw new AssertionError(&quot;unknown state: &quot; + status);</span>
        }
    }

    public EnumMap&lt;Status, Long&gt; stateTimesMillis()
    {
<span class="fc" id="L170">        EnumMap&lt;Status, Long&gt; map = new EnumMap&lt;&gt;(Status.class);</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">        for (int i = 0; i &lt; stateTimesNanos.length; i++)</span>
        {
<span class="fc" id="L173">            long nanos = stateTimesNanos[i];</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">            if (nanos != 0)</span>
<span class="fc" id="L175">                map.put(Status.values()[i], nanosToMillis(nanos));</span>
        }
<span class="fc" id="L177">        return map;</span>
    }

    public long durationMillis()
    {
<span class="fc" id="L182">        long endNanos = lastUpdatedAtNanos;</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">        if (!isComplete())</span>
<span class="nc" id="L184">            endNanos = Clock.Global.nanoTime();</span>
<span class="fc" id="L185">        return TimeUnit.NANOSECONDS.toMillis(endNanos - stateTimesNanos[0]);</span>
    }

    public long lastUpdatedAtMillis()
    {
<span class="fc" id="L190">        return nanosToMillis(lastUpdatedAtNanos);</span>
    }

    public long lastUpdatedAtNanos()
    {
<span class="nc" id="L195">        return lastUpdatedAtNanos;</span>
    }

    public String failureCause()
    {
<span class="fc bfc" id="L200" title="All 2 branches covered.">        if (status == Status.FAILURE)</span>
<span class="fc" id="L201">            return completeMessage;</span>
<span class="fc" id="L202">        return null;</span>
    }

    public String successMessage()
    {
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if (status == Status.SUCCESS)</span>
<span class="fc" id="L208">            return completeMessage;</span>
<span class="fc" id="L209">        return null;</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L215">        TableBuilder table = new TableBuilder();</span>
<span class="nc" id="L216">        table.add(&quot;id&quot;, id.toString());</span>
<span class="nc" id="L217">        table.add(&quot;status&quot;, status().name().toLowerCase());</span>
<span class="nc" id="L218">        table.add(&quot;progress&quot;, (progress() * 100) + &quot;%&quot;);</span>
<span class="nc" id="L219">        table.add(&quot;duration_ms&quot;, Long.toString(durationMillis()));</span>
<span class="nc" id="L220">        table.add(&quot;last_updated_ms&quot;, Long.toString(lastUpdatedAtMillis()));</span>
<span class="nc" id="L221">        table.add(&quot;failure_cause&quot;, failureCause());</span>
<span class="nc" id="L222">        table.add(&quot;success_message&quot;, successMessage());</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">        for (Map.Entry&lt;Status, Long&gt; e : stateTimesMillis().entrySet())</span>
<span class="nc" id="L224">            table.add(&quot;status_&quot; + e.getKey().name().toLowerCase() + &quot;_ms&quot;, e.toString());</span>
<span class="nc" id="L225">        return table.toString();</span>
    }

    @Override
    public synchronized void handleStreamEvent(StreamEvent event)
    {
        try
        {
<span class="pc bpc" id="L233" title="1 of 4 branches missed.">            switch (event.eventType)</span>
            {
                case STREAM_PREPARED:
<span class="fc" id="L236">                    streamPrepared((StreamEvent.SessionPreparedEvent) event);</span>
<span class="fc" id="L237">                    break;</span>
                case STREAM_COMPLETE:
                    // currently not taking track of state, so ignore
<span class="fc" id="L240">                    break;</span>
                case FILE_PROGRESS:
<span class="fc" id="L242">                    streamProgress((StreamEvent.ProgressEvent) event);</span>
<span class="fc" id="L243">                    break;</span>
                default:
<span class="nc" id="L245">                    logger.warn(&quot;Unknown stream event type: {}&quot;, event.eventType);</span>
            }
        }
<span class="nc" id="L248">        catch (Throwable t)</span>
        {
<span class="nc" id="L250">            logger.warn(&quot;Unexpected exception handling stream event&quot;, t);</span>
<span class="fc" id="L251">        }</span>
<span class="fc" id="L252">        lastUpdatedAtNanos = Clock.Global.nanoTime();</span>
<span class="fc" id="L253">    }</span>

    private void streamPrepared(StreamEvent.SessionPreparedEvent event)
    {
<span class="fc" id="L257">        SessionInfo session = event.session;</span>
<span class="fc" id="L258">        peers.add(session.peer);</span>
        // only update stats on ACK to avoid duplication
<span class="fc bfc" id="L260" title="All 2 branches covered.">        if (event.prepareDirection != StreamSession.PrepareDirection.ACK)</span>
<span class="fc" id="L261">            return;</span>
<span class="fc" id="L262">        sessions.bytesToReceive += session.getTotalSizeToReceive();</span>
<span class="fc" id="L263">        sessions.bytesToSend += session.getTotalSizeToSend();</span>

<span class="fc" id="L265">        sessions.filesToReceive += session.getTotalFilesToReceive();</span>
<span class="fc" id="L266">        sessions.filesToSend += session.getTotalFilesToSend();</span>
<span class="fc" id="L267">    }</span>

    private void streamProgress(StreamEvent.ProgressEvent event)
    {
<span class="fc" id="L271">        ProgressInfo info = event.progress;</span>

<span class="fc bfc" id="L273" title="All 2 branches covered.">        if (info.direction == ProgressInfo.Direction.IN)</span>
        {
            // receiving
<span class="fc" id="L276">            sessions.bytesReceived += info.deltaBytes;</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">            if (info.isCompleted())</span>
<span class="fc" id="L278">                sessions.filesReceived++;</span>
        }
        else
        {
            // sending
<span class="fc" id="L283">            sessions.bytesSent += info.deltaBytes;</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">            if (info.isCompleted())</span>
<span class="fc" id="L285">                sessions.filesSent++;</span>
        }
<span class="fc" id="L287">    }</span>

    @Override
    public synchronized void onSuccess(@Nullable StreamState state)
    {
<span class="fc" id="L292">        updateState(Status.SUCCESS);</span>
<span class="fc" id="L293">    }</span>

    @Override
    public synchronized void onFailure(Throwable throwable)
    {
<span class="fc" id="L298">        completeMessage = Throwables.getStackTraceAsString(throwable);</span>
<span class="fc" id="L299">        updateState(Status.FAILURE);</span>
        //we know the size is now very different from the estimate so recompute by adding again
<span class="fc" id="L301">        StreamManager.instance.addStreamingStateAgain(this);</span>
<span class="fc" id="L302">    }</span>

    private synchronized void updateState(Status state)
    {
<span class="fc" id="L306">        this.status = state;</span>
<span class="fc" id="L307">        long now = Clock.Global.nanoTime();</span>
<span class="fc" id="L308">        stateTimesNanos[state.ordinal()] = now;</span>
<span class="fc" id="L309">        lastUpdatedAtNanos = now;</span>
<span class="fc" id="L310">    }</span>

    private long nanosToMillis(long nanos)
    {
        // nanos - creationTimeNanos = delta since init
<span class="fc" id="L315">        return createdAtMillis + TimeUnit.NANOSECONDS.toMillis(nanos - stateTimesNanos[0]);</span>
    }

<span class="fc" id="L318">    public class Phase</span>
    {
        public void start()
        {
<span class="fc" id="L322">            updateState(Status.START);</span>
<span class="fc" id="L323">        }</span>
    }

<span class="fc" id="L326">    public static class Sessions</span>
    {
        public long bytesToReceive, bytesReceived;
        public long bytesToSend, bytesSent;
        public long filesToReceive, filesReceived;
        public long filesToSend, filesSent;

        public static String columns()
        {
<span class="fc" id="L335">            return &quot;  bytes_to_receive bigint, \n&quot; +</span>
                   &quot;  bytes_received bigint, \n&quot; +
                   &quot;  bytes_to_send bigint, \n&quot; +
                   &quot;  bytes_sent bigint, \n&quot; +
                   &quot;  files_to_receive bigint, \n&quot; +
                   &quot;  files_received bigint, \n&quot; +
                   &quot;  files_to_send bigint, \n&quot; +
                   &quot;  files_sent bigint, \n&quot;;
        }

        public boolean isEmpty()
        {
<span class="pc bpc" id="L347" title="5 of 8 branches missed.">            return bytesToReceive == 0 &amp;&amp; bytesToSend == 0 &amp;&amp; filesToReceive == 0 &amp;&amp; filesToSend == 0;</span>
        }

        public BigDecimal progress()
        {
<span class="nc" id="L352">            return div(bytesSent + bytesReceived, bytesToSend + bytesToReceive);</span>
        }

        private static BigDecimal div(long a, long b)
        {
            // not &quot;correct&quot; but its what you would do if this happened...
<span class="nc bnc" id="L358" title="All 2 branches missed.">            if (b == 0)</span>
<span class="nc" id="L359">                return BigDecimal.ZERO;</span>
<span class="nc" id="L360">            return BigDecimal.valueOf(a).divide(BigDecimal.valueOf(b), 4, RoundingMode.HALF_UP);</span>
        }

        public void update(SimpleDataSet ds)
        {
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">            if (isEmpty())</span>
<span class="nc" id="L366">                return;</span>
<span class="fc" id="L367">            ds.column(&quot;bytes_to_receive&quot;, bytesToReceive)</span>
<span class="fc" id="L368">              .column(&quot;bytes_received&quot;, bytesReceived)</span>
<span class="fc" id="L369">              .column(&quot;bytes_to_send&quot;, bytesToSend)</span>
<span class="fc" id="L370">              .column(&quot;bytes_sent&quot;, bytesSent)</span>
<span class="fc" id="L371">              .column(&quot;files_to_receive&quot;, filesToReceive)</span>
<span class="fc" id="L372">              .column(&quot;files_received&quot;, filesReceived)</span>
<span class="fc" id="L373">              .column(&quot;files_to_send&quot;, filesToSend)</span>
<span class="fc" id="L374">              .column(&quot;files_sent&quot;, filesSent);</span>
<span class="fc" id="L375">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>