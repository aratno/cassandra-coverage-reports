<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataType.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.functions.types</a> &gt; <span class="el_source">DataType.java</span></div><h1>DataType.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3.functions.types;

import java.util.*;

import com.google.common.collect.ImmutableList;

import org.apache.cassandra.transport.ProtocolVersion;

/**
 * Data types supported by cassandra.
 */
public abstract class DataType
{

    /**
     * The CQL type name.
     */
<span class="fc" id="L35">    public enum Name</span>
    {
<span class="fc" id="L37">        CUSTOM(0),</span>
<span class="fc" id="L38">        ASCII(1),</span>
<span class="fc" id="L39">        BIGINT(2),</span>
<span class="fc" id="L40">        BLOB(3),</span>
<span class="fc" id="L41">        BOOLEAN(4),</span>
<span class="fc" id="L42">        COUNTER(5),</span>
<span class="fc" id="L43">        DECIMAL(6),</span>
<span class="fc" id="L44">        DOUBLE(7),</span>
<span class="fc" id="L45">        FLOAT(8),</span>
<span class="fc" id="L46">        INT(9),</span>
<span class="fc" id="L47">        TEXT(10)</span>
        {
            @Override
            public boolean isCompatibleWith(Name that)
            {
<span class="nc bnc" id="L52" title="All 4 branches missed.">                return this == that || that == VARCHAR;</span>
            }
        },
<span class="fc" id="L55">        TIMESTAMP(11),</span>
<span class="fc" id="L56">        UUID(12),</span>
<span class="fc" id="L57">        VARCHAR(13)</span>
        {
            @Override
            public boolean isCompatibleWith(Name that)
            {
<span class="nc bnc" id="L62" title="All 4 branches missed.">                return this == that || that == TEXT;</span>
            }
        },
<span class="fc" id="L65">        VARINT(14),</span>
<span class="fc" id="L66">        TIMEUUID(15),</span>
<span class="fc" id="L67">        INET(16),</span>
<span class="fc" id="L68">        DATE(17, ProtocolVersion.V4),</span>
<span class="fc" id="L69">        TIME(18, ProtocolVersion.V4),</span>
<span class="fc" id="L70">        SMALLINT(19, ProtocolVersion.V4),</span>
<span class="fc" id="L71">        TINYINT(20, ProtocolVersion.V4),</span>
<span class="fc" id="L72">        DURATION(21, ProtocolVersion.V5),</span>
<span class="fc" id="L73">        LIST(32),</span>
<span class="fc" id="L74">        MAP(33),</span>
<span class="fc" id="L75">        SET(34),</span>
<span class="fc" id="L76">        UDT(48, ProtocolVersion.V3),</span>
<span class="fc" id="L77">        TUPLE(49, ProtocolVersion.V3),</span>
<span class="fc" id="L78">        VECTOR(50, ProtocolVersion.V5);</span>

        final int protocolId;

        final ProtocolVersion minProtocolVersion;

        private static final Name[] nameToIds;

        static
        {
<span class="fc" id="L88">            int maxCode = -1;</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">            for (Name name : Name.values()) maxCode = Math.max(maxCode, name.protocolId);</span>
<span class="fc" id="L90">            nameToIds = new Name[maxCode + 1];</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">            for (Name name : Name.values())</span>
            {
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">                if (nameToIds[name.protocolId] != null) throw new IllegalStateException(&quot;Duplicate Id&quot;);</span>
<span class="fc" id="L94">                nameToIds[name.protocolId] = name;</span>
            }
<span class="fc" id="L96">        }</span>

        Name(int protocolId)
        {
<span class="fc" id="L100">            this(protocolId, ProtocolVersion.V1);</span>
<span class="fc" id="L101">        }</span>

        Name(int protocolId, ProtocolVersion minProtocolVersion)
<span class="fc" id="L104">        {</span>
<span class="fc" id="L105">            this.protocolId = protocolId;</span>
<span class="fc" id="L106">            this.minProtocolVersion = minProtocolVersion;</span>
<span class="fc" id="L107">        }</span>

        /**
         * Return {@code true} if the provided Name is equal to this one, or if they are aliases for
         * each other, and {@code false} otherwise.
         *
         * @param that the Name to compare with the current one.
         * @return {@code true} if the provided Name is equal to this one, or if they are aliases for
         * each other, and {@code false} otherwise.
         */
        public boolean isCompatibleWith(Name that)
        {
<span class="nc bnc" id="L119" title="All 2 branches missed.">            return this == that;</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L125">            return super.toString().toLowerCase();</span>
        }
    }

<span class="fc" id="L129">    private static final Map&lt;Name, DataType&gt; primitiveTypeMap =</span>
    new EnumMap&lt;&gt;(Name.class);

    static
    {
<span class="fc" id="L134">        primitiveTypeMap.put(Name.ASCII, new DataType.NativeType(Name.ASCII));</span>
<span class="fc" id="L135">        primitiveTypeMap.put(Name.BIGINT, new DataType.NativeType(Name.BIGINT));</span>
<span class="fc" id="L136">        primitiveTypeMap.put(Name.BLOB, new DataType.NativeType(Name.BLOB));</span>
<span class="fc" id="L137">        primitiveTypeMap.put(Name.BOOLEAN, new DataType.NativeType(Name.BOOLEAN));</span>
<span class="fc" id="L138">        primitiveTypeMap.put(Name.COUNTER, new DataType.NativeType(Name.COUNTER));</span>
<span class="fc" id="L139">        primitiveTypeMap.put(Name.DECIMAL, new DataType.NativeType(Name.DECIMAL));</span>
<span class="fc" id="L140">        primitiveTypeMap.put(Name.DOUBLE, new DataType.NativeType(Name.DOUBLE));</span>
<span class="fc" id="L141">        primitiveTypeMap.put(Name.FLOAT, new DataType.NativeType(Name.FLOAT));</span>
<span class="fc" id="L142">        primitiveTypeMap.put(Name.INET, new DataType.NativeType(Name.INET));</span>
<span class="fc" id="L143">        primitiveTypeMap.put(Name.INT, new DataType.NativeType(Name.INT));</span>
<span class="fc" id="L144">        primitiveTypeMap.put(Name.TEXT, new DataType.NativeType(Name.TEXT));</span>
<span class="fc" id="L145">        primitiveTypeMap.put(Name.TIMESTAMP, new DataType.NativeType(Name.TIMESTAMP));</span>
<span class="fc" id="L146">        primitiveTypeMap.put(Name.UUID, new DataType.NativeType(Name.UUID));</span>
<span class="fc" id="L147">        primitiveTypeMap.put(Name.VARCHAR, new DataType.NativeType(Name.VARCHAR));</span>
<span class="fc" id="L148">        primitiveTypeMap.put(Name.VARINT, new DataType.NativeType(Name.VARINT));</span>
<span class="fc" id="L149">        primitiveTypeMap.put(Name.TIMEUUID, new DataType.NativeType(Name.TIMEUUID));</span>
<span class="fc" id="L150">        primitiveTypeMap.put(Name.SMALLINT, new DataType.NativeType(Name.SMALLINT));</span>
<span class="fc" id="L151">        primitiveTypeMap.put(Name.TINYINT, new DataType.NativeType(Name.TINYINT));</span>
<span class="fc" id="L152">        primitiveTypeMap.put(Name.DATE, new DataType.NativeType(Name.DATE));</span>
<span class="fc" id="L153">        primitiveTypeMap.put(Name.TIME, new DataType.NativeType(Name.TIME));</span>
<span class="fc" id="L154">        primitiveTypeMap.put(Name.DURATION, new DataType.NativeType(Name.DURATION));</span>
<span class="fc" id="L155">    }</span>

    protected final DataType.Name name;

    protected DataType(DataType.Name name)
<span class="fc" id="L160">    {</span>
<span class="fc" id="L161">        this.name = name;</span>
<span class="fc" id="L162">    }</span>

    /**
     * Returns the ASCII type.
     *
     * @return The ASCII type.
     */
    public static DataType ascii()
    {
<span class="fc" id="L171">        return primitiveTypeMap.get(Name.ASCII);</span>
    }

    /**
     * Returns the BIGINT type.
     *
     * @return The BIGINT type.
     */
    public static DataType bigint()
    {
<span class="fc" id="L181">        return primitiveTypeMap.get(Name.BIGINT);</span>
    }

    /**
     * Returns the BLOB type.
     *
     * @return The BLOB type.
     */
    public static DataType blob()
    {
<span class="fc" id="L191">        return primitiveTypeMap.get(Name.BLOB);</span>
    }

    /**
     * Returns the BOOLEAN type.
     *
     * @return The BOOLEAN type.
     */
    public static DataType cboolean()
    {
<span class="fc" id="L201">        return primitiveTypeMap.get(Name.BOOLEAN);</span>
    }

    /**
     * Returns the COUNTER type.
     *
     * @return The COUNTER type.
     */
    public static DataType counter()
    {
<span class="fc" id="L211">        return primitiveTypeMap.get(Name.COUNTER);</span>
    }

    /**
     * Returns the DECIMAL type.
     *
     * @return The DECIMAL type.
     */
    public static DataType decimal()
    {
<span class="fc" id="L221">        return primitiveTypeMap.get(Name.DECIMAL);</span>
    }

    /**
     * Returns the DOUBLE type.
     *
     * @return The DOUBLE type.
     */
    public static DataType cdouble()
    {
<span class="fc" id="L231">        return primitiveTypeMap.get(Name.DOUBLE);</span>
    }

    /**
     * Returns the FLOAT type.
     *
     * @return The FLOAT type.
     */
    public static DataType cfloat()
    {
<span class="fc" id="L241">        return primitiveTypeMap.get(Name.FLOAT);</span>
    }

    /**
     * Returns the INET type.
     *
     * @return The INET type.
     */
    public static DataType inet()
    {
<span class="fc" id="L251">        return primitiveTypeMap.get(Name.INET);</span>
    }

    /**
     * Returns the TINYINT type.
     *
     * @return The TINYINT type.
     */
    public static DataType tinyint()
    {
<span class="fc" id="L261">        return primitiveTypeMap.get(Name.TINYINT);</span>
    }

    /**
     * Returns the SMALLINT type.
     *
     * @return The SMALLINT type.
     */
    public static DataType smallint()
    {
<span class="fc" id="L271">        return primitiveTypeMap.get(Name.SMALLINT);</span>
    }

    /**
     * Returns the INT type.
     *
     * @return The INT type.
     */
    public static DataType cint()
    {
<span class="fc" id="L281">        return primitiveTypeMap.get(Name.INT);</span>
    }

    /**
     * Returns the TEXT type.
     *
     * @return The TEXT type.
     */
    public static DataType text()
    {
<span class="fc" id="L291">        return primitiveTypeMap.get(Name.TEXT);</span>
    }

    /**
     * Returns the TIMESTAMP type.
     *
     * @return The TIMESTAMP type.
     */
    public static DataType timestamp()
    {
<span class="fc" id="L301">        return primitiveTypeMap.get(Name.TIMESTAMP);</span>
    }

    /**
     * Returns the DATE type.
     *
     * @return The DATE type.
     */
    public static DataType date()
    {
<span class="fc" id="L311">        return primitiveTypeMap.get(Name.DATE);</span>
    }

    /**
     * Returns the TIME type.
     *
     * @return The TIME type.
     */
    public static DataType time()
    {
<span class="fc" id="L321">        return primitiveTypeMap.get(Name.TIME);</span>
    }

    /**
     * Returns the UUID type.
     *
     * @return The UUID type.
     */
    public static DataType uuid()
    {
<span class="fc" id="L331">        return primitiveTypeMap.get(Name.UUID);</span>
    }

    /**
     * Returns the VARCHAR type.
     *
     * @return The VARCHAR type.
     */
    public static DataType varchar()
    {
<span class="fc" id="L341">        return primitiveTypeMap.get(Name.VARCHAR);</span>
    }

    /**
     * Returns the VARINT type.
     *
     * @return The VARINT type.
     */
    public static DataType varint()
    {
<span class="fc" id="L351">        return primitiveTypeMap.get(Name.VARINT);</span>
    }

    /**
     * Returns the TIMEUUID type.
     *
     * @return The TIMEUUID type.
     */
    public static DataType timeuuid()
    {
<span class="fc" id="L361">        return primitiveTypeMap.get(Name.TIMEUUID);</span>
    }

    /**
     * Returns the type of lists of {@code elementType} elements.
     *
     * @param elementType the type of the list elements.
     * @param frozen      whether the list is frozen.
     * @return the type of lists of {@code elementType} elements.
     */
    public static CollectionType list(DataType elementType, boolean frozen)
    {
<span class="nc" id="L373">        return new DataType.CollectionType(Name.LIST, ImmutableList.of(elementType), frozen);</span>
    }

    /**
     * Returns the type of &quot;not frozen&quot; lists of {@code elementType} elements.
     *
     * &lt;p&gt;This is a shorthand for {@code list(elementType, false);}.
     *
     * @param elementType the type of the list elements.
     * @return the type of &quot;not frozen&quot; lists of {@code elementType} elements.
     */
    public static CollectionType list(DataType elementType)
    {
<span class="nc" id="L386">        return list(elementType, false);</span>
    }

    /**
     * Returns the type of sets of {@code elementType} elements.
     *
     * @param elementType the type of the set elements.
     * @param frozen      whether the set is frozen.
     * @return the type of sets of {@code elementType} elements.
     */
    public static CollectionType set(DataType elementType, boolean frozen)
    {
<span class="nc" id="L398">        return new DataType.CollectionType(Name.SET, ImmutableList.of(elementType), frozen);</span>
    }

    /**
     * Returns the type of &quot;not frozen&quot; sets of {@code elementType} elements.
     *
     * &lt;p&gt;This is a shorthand for {@code set(elementType, false);}.
     *
     * @param elementType the type of the set elements.
     * @return the type of &quot;not frozen&quot; sets of {@code elementType} elements.
     */
    public static CollectionType set(DataType elementType)
    {
<span class="nc" id="L411">        return set(elementType, false);</span>
    }

    /**
     * Returns the type of maps of {@code keyType} to {@code valueType} elements.
     *
     * @param keyType   the type of the map keys.
     * @param valueType the type of the map values.
     * @param frozen    whether the map is frozen.
     * @return the type of maps of {@code keyType} to {@code valueType} elements.
     */
    public static CollectionType map(DataType keyType, DataType valueType, boolean frozen)
    {
<span class="nc" id="L424">        return new DataType.CollectionType(Name.MAP, ImmutableList.of(keyType, valueType), frozen);</span>
    }

    /**
     * Returns the type of &quot;not frozen&quot; maps of {@code keyType} to {@code valueType} elements.
     *
     * &lt;p&gt;This is a shorthand for {@code map(keyType, valueType, false);}.
     *
     * @param keyType   the type of the map keys.
     * @param valueType the type of the map values.
     * @return the type of &quot;not frozen&quot; maps of {@code keyType} to {@code valueType} elements.
     */
    public static CollectionType map(DataType keyType, DataType valueType)
    {
<span class="nc" id="L438">        return map(keyType, valueType, false);</span>
    }

    /**
     * Returns the type of vector of {@code elementType} elements with {@code dimensions} dimensions.
     *
     * @param elementType the type of the vector elements.
     * @param dimensions  the number of dimensions of the vector.
     * @return the type of vectors of {@code elementType} elements and {@code dimensions} dimensions.
     */
    public static VectorType vector(DataType elementType, int dimensions)
    {
<span class="nc" id="L450">        return new VectorType(elementType, dimensions);</span>
    }

    /**
     * Returns a Custom type.
     *
     * &lt;p&gt;A custom type is defined by the name of the class used on the Cassandra side to implement
     * it. Note that the support for custom types by the driver is limited.
     *
     * &lt;p&gt;The use of custom types is rarely useful and is thus not encouraged.
     *
     * @param typeClassName the server-side fully qualified class name for the type.
     * @return the custom type for {@code typeClassName}.
     */
    public static DataType.CustomType custom(String typeClassName)
    {
<span class="nc bnc" id="L466" title="All 2 branches missed.">        if (typeClassName == null) throw new NullPointerException();</span>
<span class="nc" id="L467">        return new DataType.CustomType(Name.CUSTOM, typeClassName);</span>
    }

    /**
     * Returns the Duration type, introduced in Cassandra 3.10.
     *
     * &lt;p&gt;Note that a Duration type does not have a native representation in CQL, and technically, is
     * merely a special {@link DataType#custom(String) custom type} from the driver's point of view.
     *
     * @return the Duration type. The returned instance is a singleton.
     */
    public static DataType duration()
    {
<span class="fc" id="L480">        return primitiveTypeMap.get(Name.DURATION);</span>
    }

    /**
     * Returns the name of that type.
     *
     * @return the name of that type.
     */
    public Name getName()
    {
<span class="fc" id="L490">        return name;</span>
    }

    /**
     * Returns whether this data type is frozen.
     *
     * &lt;p&gt;This applies to User Defined Types, tuples and nested collections. Frozen types are
     * serialized as a single value in Cassandra's storage engine, whereas non-frozen types are stored
     * in a form that allows updates to individual subfields.
     *
     * @return whether this data type is frozen.
     */
    public abstract boolean isFrozen();

    /**
     * Returns whether this data type represent a CQL {@link
     * DataType.CollectionType collection type}, that is, a list, set or map.
     *
     * @return whether this data type name represent the name of a collection type.
     */
    public boolean isCollection()
    {
<span class="nc" id="L512">        return this instanceof CollectionType;</span>
    }

    /**
     * Returns the type arguments of this type.
     *
     * &lt;p&gt;Note that only the collection types (LIST, MAP, SET) have type arguments. For the other
     * types, this will return an empty list.
     *
     * &lt;p&gt;For the collection types:
     *
     * &lt;ul&gt;
     * &lt;li&gt;For lists and sets, this method returns one argument, the type of the elements.
     * &lt;li&gt;For maps, this method returns two arguments, the first one is the type of the map keys,
     * the second one is the type of the map values.
     * &lt;/ul&gt;
     *
     * @return an immutable list containing the type arguments of this type.
     */
    public List&lt;DataType&gt; getTypeArguments()
    {
<span class="nc" id="L533">        return Collections.emptyList();</span>
    }

    /**
     * Returns a String representation of this data type suitable for inclusion as a parameter type in
     * a function or aggregate signature.
     *
     * &lt;p&gt;In such places, the String representation might vary from the canonical one as returned by
     * {@link #toString()}; e.g. the {@code frozen} keyword is not accepted.
     *
     * @return a String representation of this data type suitable for inclusion as a parameter type in
     * a function or aggregate signature.
     */
    public String asFunctionParameterString()
    {
<span class="nc" id="L548">        return toString();</span>
    }

    /**
     * Instances of this class represent CQL native types, also known as CQL primitive types.
     */
    public static class NativeType extends DataType
    {

        private NativeType(DataType.Name name)
        {
<span class="fc" id="L559">            super(name);</span>
<span class="fc" id="L560">        }</span>

        @Override
        public boolean isFrozen()
        {
<span class="nc" id="L565">            return false;</span>
        }

        @Override
        public final int hashCode()
        {
<span class="nc bnc" id="L571" title="All 2 branches missed.">            return (name == Name.TEXT) ? Name.VARCHAR.hashCode() : name.hashCode();</span>
        }

        @Override
        public final boolean equals(Object o)
        {
<span class="nc bnc" id="L577" title="All 2 branches missed.">            if (!(o instanceof DataType.NativeType)) return false;</span>

<span class="nc" id="L579">            NativeType that = (DataType.NativeType) o;</span>
<span class="nc" id="L580">            return this.name.isCompatibleWith(that.name);</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L586">            return name.toString();</span>
        }
    }

    /**
     * Instances of this class represent collection types, that is, lists, sets or maps.
     */
    public static class CollectionType extends DataType
    {

        private final List&lt;DataType&gt; typeArguments;
        private final boolean frozen;

        private CollectionType(DataType.Name name, List&lt;DataType&gt; typeArguments, boolean frozen)
        {
<span class="nc" id="L601">            super(name);</span>
<span class="nc" id="L602">            this.typeArguments = typeArguments;</span>
<span class="nc" id="L603">            this.frozen = frozen;</span>
<span class="nc" id="L604">        }</span>

        @Override
        public boolean isFrozen()
        {
<span class="nc" id="L609">            return frozen;</span>
        }

        @Override
        public List&lt;DataType&gt; getTypeArguments()
        {
<span class="nc" id="L615">            return typeArguments;</span>
        }

        @Override
        public final int hashCode()
        {
<span class="nc" id="L621">            return Objects.hash(name, typeArguments);</span>
        }

        @Override
        public final boolean equals(Object o)
        {
<span class="nc bnc" id="L627" title="All 2 branches missed.">            if (!(o instanceof DataType.CollectionType)) return false;</span>

<span class="nc" id="L629">            DataType.CollectionType d = (DataType.CollectionType) o;</span>
<span class="nc bnc" id="L630" title="All 4 branches missed.">            return name == d.name &amp;&amp; typeArguments.equals(d.typeArguments);</span>
        }

        @Override
        public String toString()
        {
<span class="nc bnc" id="L636" title="All 2 branches missed.">            if (name == Name.MAP)</span>
            {
<span class="nc bnc" id="L638" title="All 2 branches missed.">                String template = frozen ? &quot;frozen&lt;%s&lt;%s, %s&gt;&gt;&quot; : &quot;%s&lt;%s, %s&gt;&quot;;</span>
<span class="nc" id="L639">                return String.format(template, name, typeArguments.get(0), typeArguments.get(1));</span>
            }
            else
            {
<span class="nc bnc" id="L643" title="All 2 branches missed.">                String template = frozen ? &quot;frozen&lt;%s&lt;%s&gt;&gt;&quot; : &quot;%s&lt;%s&gt;&quot;;</span>
<span class="nc" id="L644">                return String.format(template, name, typeArguments.get(0));</span>
            }
        }

        @Override
        public String asFunctionParameterString()
        {
<span class="nc bnc" id="L651" title="All 2 branches missed.">            if (name == Name.MAP)</span>
            {
<span class="nc" id="L653">                String template = &quot;%s&lt;%s, %s&gt;&quot;;</span>
<span class="nc" id="L654">                return String.format(</span>
                template,
                name,
<span class="nc" id="L657">                typeArguments.get(0).asFunctionParameterString(),</span>
<span class="nc" id="L658">                typeArguments.get(1).asFunctionParameterString());</span>
            }
            else
            {
<span class="nc" id="L662">                String template = &quot;%s&lt;%s&gt;&quot;;</span>
<span class="nc" id="L663">                return String.format(template, name, typeArguments.get(0).asFunctionParameterString());</span>
            }
        }
    }

    /**
     * A &quot;custom&quot; type is a type that cannot be expressed as a CQL type.
     *
     * &lt;p&gt;Each custom type is merely identified by the fully qualified {@code
     * #getCustomTypeClassName() class name} that represents this type server-side.
     *
     * &lt;p&gt;The driver provides a minimal support for such types through instances of this class.
     *
     * &lt;p&gt;A codec for custom types can be obtained via {@link TypeCodec#custom(DataType.CustomType)}.
     */
    public static class CustomType extends DataType
    {

        private final String customClassName;

        private CustomType(DataType.Name name, String className)
        {
<span class="nc" id="L685">            super(name);</span>
<span class="nc" id="L686">            this.customClassName = className;</span>
<span class="nc" id="L687">        }</span>

        @Override
        public boolean isFrozen()
        {
<span class="nc" id="L692">            return false;</span>
        }

        @Override
        public final int hashCode()
        {
<span class="nc" id="L698">            return Objects.hash(name, customClassName);</span>
        }

        @Override
        public final boolean equals(Object o)
        {
<span class="nc bnc" id="L704" title="All 2 branches missed.">            if (!(o instanceof DataType.CustomType)) return false;</span>

<span class="nc" id="L706">            DataType.CustomType d = (DataType.CustomType) o;</span>
<span class="nc bnc" id="L707" title="All 4 branches missed.">            return name == d.name &amp;&amp; Objects.equals(customClassName, d.customClassName);</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L713">            return String.format(&quot;'%s'&quot;, customClassName);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>