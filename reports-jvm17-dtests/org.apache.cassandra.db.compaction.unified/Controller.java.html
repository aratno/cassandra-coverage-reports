<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Controller.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.compaction.unified</a> &gt; <span class="el_source">Controller.java</span></div><h1>Controller.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.db.compaction.unified;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;

import org.apache.cassandra.config.CassandraRelevantProperties;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.compaction.UnifiedCompactionStrategy;
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.schema.SchemaConstants;
import org.apache.cassandra.utils.Overlaps;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.MonotonicClock;

/**
* The controller provides compaction parameters to the unified compaction strategy
*/
public class Controller
{
<span class="fc" id="L46">    protected static final Logger logger = LoggerFactory.getLogger(Controller.class);</span>

    /**
     * The scaling parameters W, one per bucket index and separated by a comma.
     * Higher indexes will use the value of the last index with a W specified.
     */
    final static String SCALING_PARAMETERS_OPTION = &quot;scaling_parameters&quot;;
<span class="fc" id="L53">    private final static String DEFAULT_SCALING_PARAMETERS =</span>
<span class="fc" id="L54">        CassandraRelevantProperties.UCS_SCALING_PARAMETER.getString();</span>

    /**
     * Override for the flush size in MB. The database should be able to calculate this from executing flushes, this
     * should only be necessary in rare cases.
     */
    static final String FLUSH_SIZE_OVERRIDE_OPTION = &quot;flush_size_override&quot;;

    static final String BASE_SHARD_COUNT_OPTION = &quot;base_shard_count&quot;;
    /**
     * Default base shard count, used when a base count is not explicitly supplied. This value applies as long as the
     * table is not a system one, and directories are not defined.
     *
     * For others a base count of 1 is used as system tables are usually small and do not need as much compaction
     * parallelism, while having directories defined provides for parallelism in a different way.
     */
<span class="fc" id="L70">    public static final int DEFAULT_BASE_SHARD_COUNT =</span>
<span class="fc" id="L71">        CassandraRelevantProperties.UCS_BASE_SHARD_COUNT.getInt();</span>

    static final String TARGET_SSTABLE_SIZE_OPTION = &quot;target_sstable_size&quot;;
<span class="fc" id="L74">    public static final long DEFAULT_TARGET_SSTABLE_SIZE =</span>
<span class="fc" id="L75">        CassandraRelevantProperties.UCS_TARGET_SSTABLE_SIZE.getSizeInBytes();</span>
    static final long MIN_TARGET_SSTABLE_SIZE = 1L &lt;&lt; 20;

    /**
     * This parameter is intended to modify the shape of the LSM by taking into account the survival ratio of data, for now it is fixed to one.
     */
<span class="fc" id="L81">    static final double DEFAULT_SURVIVAL_FACTOR =</span>
<span class="fc" id="L82">        CassandraRelevantProperties.UCS_SURVIVAL_FACTOR.getDouble();</span>
<span class="fc" id="L83">    static final double[] DEFAULT_SURVIVAL_FACTORS = new double[] { DEFAULT_SURVIVAL_FACTOR };</span>

    /**
     * The maximum number of sstables to compact in one operation.
     *
     * The default is 32, which aims to keep the length of operations under control and prevent accummulation of
     * sstables while compactions are taking place.
     *
     * If the fanout factor is larger than the maximum number of sstables, the strategy will ignore the latter.
     */
    static final String MAX_SSTABLES_TO_COMPACT_OPTION = &quot;max_sstables_to_compact&quot;;

    static final String ALLOW_UNSAFE_AGGRESSIVE_SSTABLE_EXPIRATION_OPTION = &quot;unsafe_aggressive_sstable_expiration&quot;;
<span class="fc" id="L96">    static final boolean ALLOW_UNSAFE_AGGRESSIVE_SSTABLE_EXPIRATION =</span>
<span class="fc" id="L97">        CassandraRelevantProperties.ALLOW_UNSAFE_AGGRESSIVE_SSTABLE_EXPIRATION.getBoolean();</span>
    static final boolean DEFAULT_ALLOW_UNSAFE_AGGRESSIVE_SSTABLE_EXPIRATION = false;

    static final int DEFAULT_EXPIRED_SSTABLE_CHECK_FREQUENCY_SECONDS = 60 * 10;
    static final String EXPIRED_SSTABLE_CHECK_FREQUENCY_SECONDS_OPTION = &quot;expired_sstable_check_frequency_seconds&quot;;

    /** The maximum splitting factor for shards. The maximum number of shards is this number multiplied by the base count. */
    static final double MAX_SHARD_SPLIT = 1048576;

    /**
     * Overlap inclusion method. NONE for participating sstables only (not recommended), SINGLE to only include sstables
     * that overlap with participating (LCS-like, higher concurrency during upgrades but some double compaction),
     * TRANSITIVE to include overlaps of overlaps (likely to trigger whole level compactions, safest).
     */
    static final String OVERLAP_INCLUSION_METHOD_OPTION = &quot;overlap_inclusion_method&quot;;
<span class="fc" id="L112">    static final Overlaps.InclusionMethod DEFAULT_OVERLAP_INCLUSION_METHOD =</span>
<span class="fc" id="L113">        CassandraRelevantProperties.UCS_OVERLAP_INCLUSION_METHOD.getEnum(Overlaps.InclusionMethod.TRANSITIVE);</span>

    protected final ColumnFamilyStore cfs;
    protected final MonotonicClock clock;
    private final int[] scalingParameters;
    protected final double[] survivalFactors;
    protected final long flushSizeOverride;
    protected volatile long currentFlushSize;
    protected final int maxSSTablesToCompact;
    protected final long expiredSSTableCheckFrequency;
    protected final boolean ignoreOverlapsInExpirationCheck;

    protected final int baseShardCount;

    protected final double targetSSTableSize;

<span class="fc" id="L129">    static final double INVERSE_SQRT_2 = Math.sqrt(0.5);</span>

    protected final Overlaps.InclusionMethod overlapInclusionMethod;

    Controller(ColumnFamilyStore cfs,
               MonotonicClock clock,
               int[] scalingParameters,
               double[] survivalFactors,
               long flushSizeOverride,
               int maxSSTablesToCompact,
               long expiredSSTableCheckFrequency,
               boolean ignoreOverlapsInExpirationCheck,
               int baseShardCount,
               double targetSStableSize,
               Overlaps.InclusionMethod overlapInclusionMethod)
<span class="fc" id="L144">    {</span>
<span class="fc" id="L145">        this.cfs = cfs;</span>
<span class="fc" id="L146">        this.clock = clock;</span>
<span class="fc" id="L147">        this.scalingParameters = scalingParameters;</span>
<span class="fc" id="L148">        this.survivalFactors = survivalFactors;</span>
<span class="fc" id="L149">        this.flushSizeOverride = flushSizeOverride;</span>
<span class="fc" id="L150">        this.currentFlushSize = flushSizeOverride;</span>
<span class="fc" id="L151">        this.expiredSSTableCheckFrequency = TimeUnit.MILLISECONDS.convert(expiredSSTableCheckFrequency, TimeUnit.SECONDS);</span>
<span class="fc" id="L152">        this.baseShardCount = baseShardCount;</span>
<span class="fc" id="L153">        this.targetSSTableSize = targetSStableSize;</span>
<span class="fc" id="L154">        this.overlapInclusionMethod = overlapInclusionMethod;</span>

<span class="pc bpc" id="L156" title="1 of 2 branches missed.">        if (maxSSTablesToCompact &lt;= 0)</span>
<span class="fc" id="L157">            maxSSTablesToCompact = Integer.MAX_VALUE;</span>

<span class="fc" id="L159">        this.maxSSTablesToCompact = maxSSTablesToCompact;</span>

<span class="pc bpc" id="L161" title="3 of 4 branches missed.">        if (ignoreOverlapsInExpirationCheck &amp;&amp; !ALLOW_UNSAFE_AGGRESSIVE_SSTABLE_EXPIRATION)</span>
        {
<span class="nc" id="L163">            logger.warn(&quot;Not enabling aggressive SSTable expiration, as the system property '&quot; +</span>
<span class="nc" id="L164">                        CassandraRelevantProperties.ALLOW_UNSAFE_AGGRESSIVE_SSTABLE_EXPIRATION.name() +</span>
                        &quot;' is set to 'false'. &quot; +
                        &quot;Set it to 'true' to enable aggressive SSTable expiration.&quot;);
        }
<span class="pc bpc" id="L168" title="3 of 4 branches missed.">        this.ignoreOverlapsInExpirationCheck = ALLOW_UNSAFE_AGGRESSIVE_SSTABLE_EXPIRATION &amp;&amp; ignoreOverlapsInExpirationCheck;</span>
<span class="fc" id="L169">    }</span>

    /**
     * @return the scaling parameter W
     * @param index
     */
    public int getScalingParameter(int index)
    {
<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (index &lt; 0)</span>
<span class="nc" id="L178">            throw new IllegalArgumentException(&quot;Index should be &gt;= 0: &quot; + index);</span>

<span class="nc bnc" id="L180" title="All 2 branches missed.">        return index &lt; scalingParameters.length ? scalingParameters[index] : scalingParameters[scalingParameters.length - 1];</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L186">        return String.format(&quot;Controller, m: %s, o: %s, Ws: %s&quot;,</span>
<span class="nc" id="L187">                             FBUtilities.prettyPrintBinary(targetSSTableSize, &quot;B&quot;, &quot;&quot;),</span>
<span class="nc" id="L188">                             Arrays.toString(survivalFactors),</span>
<span class="nc" id="L189">                             printScalingParameters(scalingParameters));</span>
    }

    public int getFanout(int index) {
<span class="nc" id="L193">        int W = getScalingParameter(index);</span>
<span class="nc" id="L194">        return UnifiedCompactionStrategy.fanoutFromScalingParameter(W);</span>
    }

    public int getThreshold(int index) {
<span class="nc" id="L198">        int W = getScalingParameter(index);</span>
<span class="nc" id="L199">        return UnifiedCompactionStrategy.thresholdFromScalingParameter(W);</span>
    }

    /**
     * Calculate the number of shards to split the local token space in for the given sstable density.
     * This is calculated as a power-of-two multiple of baseShardCount, so that the expected size of resulting sstables
     * is between sqrt(0.5) * targetSSTableSize and sqrt(2) * targetSSTableSize, with a minimum of baseShardCount shards
     * for smaller sstables.
     *
     * Note that to get the sstables resulting from this splitting within the bounds, the density argument must be
     * normalized to the span that is being split. In other words, if no disks are defined, the density should be
     * scaled by the token coverage of the locally-owned ranges. If multiple data directories are defined, the density
     * should be scaled by the token coverage of the respective data directory. That is localDensity = size / span,
     * where the span is normalized so that span = 1 when the data covers the range that is being split.
     */
    public int getNumShards(double localDensity)
    {
        // How many we would have to aim for the target size. Divided by the base shard count, so that we can ensure
        // the result is a multiple of it by multiplying back below.
<span class="fc" id="L218">        double count = localDensity / (targetSSTableSize * INVERSE_SQRT_2 * baseShardCount);</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">        if (count &gt; MAX_SHARD_SPLIT)</span>
<span class="nc" id="L220">            count = MAX_SHARD_SPLIT;</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">        assert !(count &lt; 0);    // Must be positive, 0 or NaN, which should translate to baseShardCount</span>

        // Make it a power of two multiple of the base count so that split points for lower levels remain split points
        // for higher.
        // The conversion to int and highestOneBit round down, for which we compensate by using the sqrt(0.5) multiplier
        // applied above.
        // Setting the bottom bit to 1 ensures the result is at least baseShardCount.
<span class="fc" id="L228">        int shards = baseShardCount * Integer.highestOneBit((int) count | 1);</span>
<span class="fc" id="L229">        logger.debug(&quot;Shard count {} for density {}, {} times target {}&quot;,</span>
<span class="fc" id="L230">                     shards,</span>
<span class="fc" id="L231">                     FBUtilities.prettyPrintBinary(localDensity, &quot;B&quot;, &quot; &quot;),</span>
<span class="fc" id="L232">                     localDensity / targetSSTableSize,</span>
<span class="fc" id="L233">                     FBUtilities.prettyPrintBinary(targetSSTableSize, &quot;B&quot;, &quot; &quot;));</span>
<span class="fc" id="L234">        return shards;</span>
    }

    /**
     * @return the survival factor o
     * @param index
     */
    public double getSurvivalFactor(int index)
    {
<span class="nc bnc" id="L243" title="All 2 branches missed.">        if (index &lt; 0)</span>
<span class="nc" id="L244">            throw new IllegalArgumentException(&quot;Index should be &gt;= 0: &quot; + index);</span>

<span class="nc bnc" id="L246" title="All 2 branches missed.">        return index &lt; survivalFactors.length ? survivalFactors[index] : survivalFactors[survivalFactors.length - 1];</span>
    }

    /**
     * Return the flush sstable size in bytes.
     *
     * This is usually obtained from the observed sstable flush sizes, refreshed when it differs significantly
     * from the current values.
     * It can also be set by the user in the options.
     *
     * @return the flush size in bytes.
     */
    public long getFlushSizeBytes()
    {
<span class="nc bnc" id="L260" title="All 2 branches missed.">        if (flushSizeOverride &gt; 0)</span>
<span class="nc" id="L261">            return flushSizeOverride;</span>

<span class="nc" id="L263">        double envFlushSize = cfs.metric.flushSizeOnDisk.get();</span>
<span class="nc bnc" id="L264" title="All 4 branches missed.">        if (currentFlushSize == 0 || Math.abs(1 - (currentFlushSize / envFlushSize)) &gt; 0.5)</span>
        {
            // The current size is not initialized, or it differs by over 50% from the observed.
            // Use the observed size rounded up to a whole megabyte.
<span class="nc" id="L268">            currentFlushSize = ((long) (Math.ceil(Math.scalb(envFlushSize, -20)))) &lt;&lt; 20;</span>
        }
<span class="nc" id="L270">        return currentFlushSize;</span>
    }

    /**
     * @return whether is allowed to drop expired SSTables without checking if partition keys appear in other SSTables.
     * Same behavior as in TWCS.
     */
    public boolean getIgnoreOverlapsInExpirationCheck()
    {
<span class="fc" id="L279">        return ignoreOverlapsInExpirationCheck;</span>
    }

    public long getExpiredSSTableCheckFrequency()
    {
<span class="nc" id="L284">        return expiredSSTableCheckFrequency;</span>
    }

    public static Controller fromOptions(ColumnFamilyStore cfs, Map&lt;String, String&gt; options)
    {
<span class="fc" id="L289">        int[] Ws = parseScalingParameters(options.getOrDefault(SCALING_PARAMETERS_OPTION, DEFAULT_SCALING_PARAMETERS));</span>

<span class="fc" id="L291">        long flushSizeOverride = FBUtilities.parseHumanReadableBytes(options.getOrDefault(FLUSH_SIZE_OVERRIDE_OPTION,</span>
                                                                                          &quot;0MiB&quot;));
<span class="fc" id="L293">        int maxSSTablesToCompact = Integer.parseInt(options.getOrDefault(MAX_SSTABLES_TO_COMPACT_OPTION, &quot;0&quot;));</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">        long expiredSSTableCheckFrequency = options.containsKey(EXPIRED_SSTABLE_CHECK_FREQUENCY_SECONDS_OPTION)</span>
<span class="nc" id="L295">                ? Long.parseLong(options.get(EXPIRED_SSTABLE_CHECK_FREQUENCY_SECONDS_OPTION))</span>
<span class="fc" id="L296">                : DEFAULT_EXPIRED_SSTABLE_CHECK_FREQUENCY_SECONDS;</span>
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">        boolean ignoreOverlapsInExpirationCheck = options.containsKey(ALLOW_UNSAFE_AGGRESSIVE_SSTABLE_EXPIRATION_OPTION)</span>
<span class="nc" id="L298">                ? Boolean.parseBoolean(options.get(ALLOW_UNSAFE_AGGRESSIVE_SSTABLE_EXPIRATION_OPTION))</span>
<span class="fc" id="L299">                : DEFAULT_ALLOW_UNSAFE_AGGRESSIVE_SSTABLE_EXPIRATION;</span>

        int baseShardCount;
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">        if (options.containsKey(BASE_SHARD_COUNT_OPTION))</span>
        {
<span class="nc" id="L304">            baseShardCount = Integer.parseInt(options.get(BASE_SHARD_COUNT_OPTION));</span>
        }
        else
        {
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">            if (SchemaConstants.isSystemKeyspace(cfs.getKeyspaceName())</span>
<span class="pc bpc" id="L309" title="1 of 4 branches missed.">                || (cfs.getDiskBoundaries().positions != null &amp;&amp; cfs.getDiskBoundaries().positions.size() &gt; 1))</span>
<span class="fc" id="L310">                baseShardCount = 1;</span>
            else
<span class="fc" id="L312">                baseShardCount = DEFAULT_BASE_SHARD_COUNT;</span>
        }

<span class="pc bpc" id="L315" title="1 of 2 branches missed.">        long targetSStableSize = options.containsKey(TARGET_SSTABLE_SIZE_OPTION)</span>
<span class="fc" id="L316">                ? FBUtilities.parseHumanReadableBytes(options.get(TARGET_SSTABLE_SIZE_OPTION))</span>
<span class="pc" id="L317">                : DEFAULT_TARGET_SSTABLE_SIZE;</span>

<span class="pc bpc" id="L319" title="1 of 2 branches missed.">        Overlaps.InclusionMethod inclusionMethod = options.containsKey(OVERLAP_INCLUSION_METHOD_OPTION)</span>
<span class="nc" id="L320">                ? Overlaps.InclusionMethod.valueOf(options.get(OVERLAP_INCLUSION_METHOD_OPTION).toUpperCase())</span>
<span class="fc" id="L321">                : DEFAULT_OVERLAP_INCLUSION_METHOD;</span>

<span class="fc" id="L323">        return new Controller(cfs,</span>
                              MonotonicClock.Global.preciseTime,
                              Ws,
                              DEFAULT_SURVIVAL_FACTORS,
                              flushSizeOverride,
                              maxSSTablesToCompact,
                              expiredSSTableCheckFrequency,
                              ignoreOverlapsInExpirationCheck,
                              baseShardCount,
                              targetSStableSize,
                              inclusionMethod);
    }

    public static Map&lt;String, String&gt; validateOptions(Map&lt;String, String&gt; options) throws ConfigurationException
    {
<span class="fc" id="L338">        options = new HashMap&lt;&gt;(options);</span>
        String s;

<span class="fc" id="L341">        s = options.remove(SCALING_PARAMETERS_OPTION);</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">        if (s != null)</span>
<span class="nc" id="L343">            parseScalingParameters(s);</span>

<span class="fc" id="L345">        s = options.remove(BASE_SHARD_COUNT_OPTION);</span>
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">        if (s != null)</span>
        {
            try
            {
<span class="nc" id="L350">                int numShards = Integer.parseInt(s);</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                if (numShards &lt;= 0)</span>
<span class="nc" id="L352">                    throw new ConfigurationException(String.format(&quot;Invalid configuration, %s should be positive: %d&quot;,</span>
                                                                   BASE_SHARD_COUNT_OPTION,
<span class="nc" id="L354">                                                                   numShards));</span>
            }
<span class="nc" id="L356">            catch (NumberFormatException e)</span>
            {
<span class="nc" id="L358">                throw new ConfigurationException(String.format(&quot;%s is not a parsable int (base10) for %s&quot;,</span>
                                                               s,
                                                               BASE_SHARD_COUNT_OPTION), e);
<span class="nc" id="L361">            }</span>
        }

<span class="fc" id="L364">        s = options.remove(TARGET_SSTABLE_SIZE_OPTION);</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">        if (s != null)</span>
        {
            try
            {
<span class="fc" id="L369">                long targetSSTableSize = FBUtilities.parseHumanReadableBytes(s);</span>
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">                if (targetSSTableSize &lt; MIN_TARGET_SSTABLE_SIZE)</span>
                {
<span class="nc" id="L372">                    throw new ConfigurationException(String.format(&quot;%s %s is not acceptable, size must be at least %s&quot;,</span>
                                                                   TARGET_SSTABLE_SIZE_OPTION,
                                                                   s,
<span class="nc" id="L375">                                                                   FBUtilities.prettyPrintMemory(MIN_TARGET_SSTABLE_SIZE)));</span>
                }
            }
<span class="nc" id="L378">            catch (NumberFormatException e)</span>
            {
<span class="nc" id="L380">                throw new ConfigurationException(String.format(&quot;%s %s is not a valid size in bytes: %s&quot;,</span>
                                                               TARGET_SSTABLE_SIZE_OPTION,
                                                               s,
<span class="nc" id="L383">                                                               e.getMessage()),</span>
                                                 e);
<span class="fc" id="L385">            }</span>
        }

<span class="fc" id="L388">        s = options.remove(FLUSH_SIZE_OVERRIDE_OPTION);</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        if (s != null)</span>
        {
            try
            {
<span class="nc" id="L393">                long flushSize = FBUtilities.parseHumanReadableBytes(s);</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">                if (flushSize &lt; MIN_TARGET_SSTABLE_SIZE)</span>
<span class="nc" id="L395">                    throw new ConfigurationException(String.format(&quot;%s %s is not acceptable, size must be at least %s&quot;,</span>
                                                                   FLUSH_SIZE_OVERRIDE_OPTION,
                                                                   s,
<span class="nc" id="L398">                                                                   FBUtilities.prettyPrintMemory(MIN_TARGET_SSTABLE_SIZE)));</span>
            }
<span class="nc" id="L400">            catch (NumberFormatException e)</span>
            {
<span class="nc" id="L402">                throw new ConfigurationException(String.format(&quot;%s %s is not a valid size in bytes: %s&quot;,</span>
                                                               FLUSH_SIZE_OVERRIDE_OPTION,
                                                               s,
<span class="nc" id="L405">                                                               e.getMessage()),</span>
                                                 e);
<span class="nc" id="L407">            }</span>
        }

<span class="fc" id="L410">        s = options.remove(MAX_SSTABLES_TO_COMPACT_OPTION);</span>
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">        if (s != null)</span>
        {
             try
             {
<span class="nc" id="L415">                 Integer.parseInt(s); // values less than or equal to 0 enable the default</span>
             }
<span class="nc" id="L417">             catch (NumberFormatException e)</span>
             {
<span class="nc" id="L419">                 throw new ConfigurationException(String.format(&quot;%s is not a parsable int (base10) for %s&quot;,</span>
                                                                s,
                                                                MAX_SSTABLES_TO_COMPACT_OPTION),
                                                  e);
<span class="nc" id="L423">             }</span>
        }
<span class="fc" id="L425">        s = options.remove(EXPIRED_SSTABLE_CHECK_FREQUENCY_SECONDS_OPTION);</span>
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">        if (s != null)</span>
        {
            try
            {
<span class="nc" id="L430">                long expiredSSTableCheckFrequency = Long.parseLong(s);</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">                if (expiredSSTableCheckFrequency &lt;= 0)</span>
<span class="nc" id="L432">                    throw new ConfigurationException(String.format(&quot;Invalid configuration, %s should be positive: %d&quot;,</span>
                                                                   EXPIRED_SSTABLE_CHECK_FREQUENCY_SECONDS_OPTION,
<span class="nc" id="L434">                                                                   expiredSSTableCheckFrequency));</span>
            }
<span class="nc" id="L436">            catch (NumberFormatException e)</span>
            {
<span class="nc" id="L438">                throw new ConfigurationException(String.format(&quot;%s is not a parsable long (base10) for %s&quot;,</span>
                                                               s,
                                                               EXPIRED_SSTABLE_CHECK_FREQUENCY_SECONDS_OPTION),
                                                 e);
<span class="nc" id="L442">            }</span>
        }

<span class="fc" id="L445">        s = options.remove(ALLOW_UNSAFE_AGGRESSIVE_SSTABLE_EXPIRATION_OPTION);</span>
<span class="pc bpc" id="L446" title="5 of 6 branches missed.">        if (s != null &amp;&amp; !s.equalsIgnoreCase(&quot;true&quot;) &amp;&amp; !s.equalsIgnoreCase(&quot;false&quot;))</span>
        {
<span class="nc" id="L448">            throw new ConfigurationException(String.format(&quot;%s should either be 'true' or 'false', not %s&quot;,</span>
                                                           ALLOW_UNSAFE_AGGRESSIVE_SSTABLE_EXPIRATION_OPTION, s));
        }

<span class="fc" id="L452">        s = options.remove(OVERLAP_INCLUSION_METHOD_OPTION);</span>
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">        if (s != null)</span>
        {
            try
            {
<span class="nc" id="L457">                Overlaps.InclusionMethod.valueOf(s.toUpperCase());</span>
            }
<span class="nc" id="L459">            catch (IllegalArgumentException e)</span>
            {
<span class="nc" id="L461">                throw new ConfigurationException(String.format(&quot;Invalid overlap inclusion method %s. The valid options are %s.&quot;,</span>
                                                               s,
<span class="nc" id="L463">                                                               Arrays.toString(Overlaps.InclusionMethod.values())));</span>
<span class="nc" id="L464">            }</span>
        }

<span class="fc" id="L467">        return options;</span>
    }

    // The methods below are implemented here (rather than directly in UCS) to aid testability.

    public double getBaseSstableSize(int F)
    {
        // The compaction hierarchy should start at a minimum size which is close to the typical flush size, with
        // some leeway to make sure we don't overcompact when flushes end up a little smaller.
        // The leeway should be less than 1/F, though, to make sure we don't overshoot the boundary combining F-1
        // sources instead of F.
        // Note that while we have not had flushes, the size will be 0 and we will use 1MB as the flush size. With
        // fixed and positive W this should not hurt us, as the hierarchy will be in multiples of F and will still
        // result in the same buckets, but for negative W or hybrid strategies this may cause temporary overcompaction.
        // If this is a concern, the flush size override should be used to avoid it until DB-4401.
<span class="nc" id="L482">        return Math.max(1 &lt;&lt; 20, getFlushSizeBytes()) * (1.0 - 0.9 / F);</span>
    }

    public double getMaxLevelDensity(int index, double minSize)
    {
<span class="nc" id="L487">        return Math.floor(minSize * getFanout(index) * getSurvivalFactor(index));</span>
    }

    public double maxThroughput()
    {
<span class="nc" id="L492">        double compactionThroughputMbPerSec = DatabaseDescriptor.getCompactionThroughputMebibytesPerSec();</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">        if (compactionThroughputMbPerSec &lt;= 0)</span>
<span class="nc" id="L494">            return Double.MAX_VALUE;</span>
<span class="nc" id="L495">        return Math.scalb(compactionThroughputMbPerSec, 20);</span>
    }

    public int maxConcurrentCompactions()
    {
<span class="nc" id="L500">        return DatabaseDescriptor.getConcurrentCompactors();</span>
    }

    public int maxSSTablesToCompact()
    {
<span class="nc" id="L505">        return maxSSTablesToCompact;</span>
    }

    /**
     * Random number generator to be used for the selection of tasks.
     * Replaced by some tests.
     */
    public Random random()
    {
<span class="nc" id="L514">        return ThreadLocalRandom.current();</span>
    }

    /**
     * Return the overlap inclusion method to use when combining overlap sections into a bucket. For example, with
     * SSTables A(0, 5), B(2, 9), C(6, 12), D(10, 12) whose overlap sections calculation returns [AB, BC, CD],
     *   - NONE means no sections are to be merged. AB, BC and CD will be separate buckets, compactions AB, BC and CD
     *     will be added separately, thus some SSTables will be partially used / single-source compacted, likely
     *     to be recompacted again with the next selected bucket.
     *   - SINGLE means only overlaps of the sstables in the selected bucket will be added. AB+BC will be one bucket,
     *     and CD will be another (as BC is already used). A middle ground of sorts, should reduce overcompaction but
     *     still has some.
     *   - TRANSITIVE means a transitive closure of overlapping sstables will be selected. AB+BC+CD will be in the same
     *     bucket, selected compactions will apply to all overlapping sstables and no overcompaction will be done, at
     *     the cost of reduced compaction parallelism and increased length of the operation.
     * TRANSITIVE is the default and makes most sense. NONE is a closer approximation to operation of legacy UCS.
     * The option is exposed for experimentation.
     */
    public Overlaps.InclusionMethod overlapInclusionMethod()
    {
<span class="nc" id="L534">        return overlapInclusionMethod;</span>
    }

    public static int[] parseScalingParameters(String str)
    {
<span class="fc" id="L539">        String[] vals = str.split(&quot;,&quot;);</span>
<span class="fc" id="L540">        int[] ret = new int[vals.length];</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">        for (int i = 0; i &lt; vals.length; i++)</span>
        {
<span class="fc" id="L543">            String value = vals[i].trim();</span>
<span class="fc" id="L544">            int W = UnifiedCompactionStrategy.parseScalingParameter(value);</span>
<span class="fc" id="L545">            ret[i] = W;</span>
        }

<span class="fc" id="L548">        return ret;</span>
    }

    public static String printScalingParameters(int[] parameters)
    {
<span class="nc" id="L553">        StringBuilder builder = new StringBuilder();</span>
        int i;
<span class="nc bnc" id="L555" title="All 2 branches missed.">        for (i = 0; i &lt; parameters.length - 1; ++i)</span>
        {
<span class="nc" id="L557">            builder.append(UnifiedCompactionStrategy.printScalingParameter(parameters[i]));</span>
<span class="nc" id="L558">            builder.append(&quot;, &quot;);</span>
        }
<span class="nc" id="L560">        builder.append(UnifiedCompactionStrategy.printScalingParameter(parameters[i]));</span>
<span class="nc" id="L561">        return builder.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>