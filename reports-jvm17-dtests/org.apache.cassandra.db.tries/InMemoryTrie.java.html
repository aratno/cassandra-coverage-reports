<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InMemoryTrie.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.tries</a> &gt; <span class="el_source">InMemoryTrie.java</span></div><h1>InMemoryTrie.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.tries;

import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.google.common.annotations.VisibleForTesting;

import org.agrona.concurrent.UnsafeBuffer;
import org.apache.cassandra.config.CassandraRelevantProperties;
import org.apache.cassandra.io.compress.BufferType;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.utils.bytecomparable.ByteSource;
import org.apache.cassandra.utils.bytecomparable.ByteComparable;
import org.apache.cassandra.utils.ObjectSizes;

import org.github.jamm.MemoryMeterStrategy;

/**
 * In-memory trie built for fast modification and reads executing concurrently with writes from a single mutator thread.
 *
 * This class can currently only provide atomicity (i.e. reads seeing either the content before a write, or the
 * content after it; any read seeing the write enforcing any subsequent (i.e. started after it completed) reads to
 * also see it) for singleton writes (i.e. calls to {@link #putRecursive}, {@link #putSingleton} or {@link #apply}
 * with a singleton trie as argument).
 *
 * Because it uses 32-bit pointers in byte buffers, this trie has a fixed size limit of 2GB.
 */
public class InMemoryTrie&lt;T&gt; extends InMemoryReadTrie&lt;T&gt;
{
    // See the trie format description in InMemoryReadTrie.

    /**
     * Trie size limit. This is not enforced, but users must check from time to time that it is not exceeded (using
     * {@link #reachedAllocatedSizeThreshold()}) and start switching to a new trie if it is.
     * This must be done to avoid tries growing beyond their hard 2GB size limit (due to the 32-bit pointers).
     */
    @VisibleForTesting
    static final int ALLOCATED_SIZE_THRESHOLD;
    static
    {
        // Default threshold + 10% == 2 GB. This should give the owner enough time to react to the
        // {@link #reachedAllocatedSizeThreshold()} signal and switch this trie out before it fills up.
<span class="fc" id="L63">        int limitInMB = CassandraRelevantProperties.MEMTABLE_OVERHEAD_SIZE.getInt(2048 * 10 / 11);</span>
<span class="pc bpc" id="L64" title="2 of 4 branches missed.">        if (limitInMB &lt; 1 || limitInMB &gt; 2047)</span>
<span class="nc" id="L65">            throw new AssertionError(CassandraRelevantProperties.MEMTABLE_OVERHEAD_SIZE.getKey() +</span>
                                     &quot; must be within 1 and 2047&quot;);
<span class="fc" id="L67">        ALLOCATED_SIZE_THRESHOLD = 1024 * 1024 * limitInMB;</span>
    }

<span class="fc" id="L70">    private int allocatedPos = 0;</span>
<span class="fc" id="L71">    private int contentCount = 0;</span>

    private final BufferType bufferType;    // on or off heap

    // constants for space calculations
    private static final long EMPTY_SIZE_ON_HEAP;
    private static final long EMPTY_SIZE_OFF_HEAP;
<span class="fc" id="L78">    private static final long REFERENCE_ARRAY_ON_HEAP_SIZE = ObjectSizes.measureDeep(new AtomicReferenceArray&lt;&gt;(0));</span>

    static
    {
<span class="fc" id="L82">        InMemoryTrie&lt;Object&gt; empty = new InMemoryTrie&lt;&gt;(BufferType.ON_HEAP);</span>
<span class="fc" id="L83">        EMPTY_SIZE_ON_HEAP = ObjectSizes.measureDeep(empty);</span>
<span class="fc" id="L84">        empty = new InMemoryTrie&lt;&gt;(BufferType.OFF_HEAP);</span>
<span class="fc" id="L85">        EMPTY_SIZE_OFF_HEAP = ObjectSizes.measureDeep(empty);</span>
<span class="fc" id="L86">    }</span>

    public InMemoryTrie(BufferType bufferType)
    {
<span class="fc" id="L90">        super(new UnsafeBuffer[31 - BUF_START_SHIFT],  // last one is 1G for a total of ~2G bytes</span>
              new AtomicReferenceArray[29 - CONTENTS_START_SHIFT],  // takes at least 4 bytes to write pointer to one content -&gt; 4 times smaller than buffers
              NONE);
<span class="fc" id="L93">        this.bufferType = bufferType;</span>
<span class="fc" id="L94">    }</span>

    // Buffer, content list and block management

    /**
     * Because we use buffers and 32-bit pointers, the trie cannot grow over 2GB of size. This exception is thrown if
     * a trie operation needs it to grow over that limit.
     *
     * To avoid this problem, users should query {@link #reachedAllocatedSizeThreshold} from time to time. If the call
     * returns true, they should switch to a new trie (e.g. by flushing a memtable) as soon as possible. The threshold
     * is configurable, and is set by default to 10% under the 2GB limit to give ample time for the switch to happen.
     */
    public static class SpaceExhaustedException extends Exception
    {
        public SpaceExhaustedException()
        {
<span class="nc" id="L110">            super(&quot;The hard 2GB limit on trie size has been exceeded&quot;);</span>
<span class="nc" id="L111">        }</span>
    }

    final void putInt(int pos, int value)
    {
<span class="fc" id="L116">        getChunk(pos).putInt(inChunkPointer(pos), value);</span>
<span class="fc" id="L117">    }</span>

    final void putIntVolatile(int pos, int value)
    {
<span class="fc" id="L121">        getChunk(pos).putIntVolatile(inChunkPointer(pos), value);</span>
<span class="fc" id="L122">    }</span>

    final void putShort(int pos, short value)
    {
<span class="fc" id="L126">        getChunk(pos).putShort(inChunkPointer(pos), value);</span>
<span class="fc" id="L127">    }</span>

    final void putShortVolatile(int pos, short value)
    {
<span class="fc" id="L131">        getChunk(pos).putShort(inChunkPointer(pos), value);</span>
<span class="fc" id="L132">    }</span>

    final void putByte(int pos, byte value)
    {
<span class="fc" id="L136">        getChunk(pos).putByte(inChunkPointer(pos), value);</span>
<span class="fc" id="L137">    }</span>


    private int allocateBlock() throws SpaceExhaustedException
    {
        // Note: If this method is modified, please run InMemoryTrieTest.testOver1GSize to verify it acts correctly
        // close to the 2G limit.
<span class="fc" id="L144">        int v = allocatedPos;</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">        if (inChunkPointer(v) == 0)</span>
        {
<span class="fc" id="L147">            int leadBit = getChunkIdx(v, BUF_START_SHIFT, BUF_START_SIZE);</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">            if (leadBit + BUF_START_SHIFT == 31)</span>
<span class="nc" id="L149">                throw new SpaceExhaustedException();</span>

<span class="fc" id="L151">            ByteBuffer newBuffer = bufferType.allocate(BUF_START_SIZE &lt;&lt; leadBit);</span>
<span class="fc" id="L152">            buffers[leadBit] = new UnsafeBuffer(newBuffer);</span>
            // Note: Since we are not moving existing data to a new buffer, we are okay with no happens-before enforcing
            // writes. Any reader that sees a pointer in the new buffer may only do so after reading the volatile write
            // that attached the new path.
        }

<span class="fc" id="L158">        allocatedPos += BLOCK_SIZE;</span>
<span class="fc" id="L159">        return v;</span>
    }

    private int addContent(T value)
    {
<span class="fc" id="L164">        int index = contentCount++;</span>
<span class="fc" id="L165">        int leadBit = getChunkIdx(index, CONTENTS_START_SHIFT, CONTENTS_START_SIZE);</span>
<span class="fc" id="L166">        int ofs = inChunkPointer(index, leadBit, CONTENTS_START_SIZE);</span>
<span class="fc" id="L167">        AtomicReferenceArray&lt;T&gt; array = contentArrays[leadBit];</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">        if (array == null)</span>
        {
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">            assert ofs == 0 : &quot;Error in content arrays configuration.&quot;;</span>
<span class="fc" id="L171">            contentArrays[leadBit] = array = new AtomicReferenceArray&lt;&gt;(CONTENTS_START_SIZE &lt;&lt; leadBit);</span>
        }
<span class="fc" id="L173">        array.lazySet(ofs, value); // no need for a volatile set here; at this point the item is not referenced</span>
                                   // by any node in the trie, and a volatile set will be made to reference it.
<span class="fc" id="L175">        return index;</span>
    }

    private void setContent(int index, T value)
    {
<span class="nc" id="L180">        int leadBit = getChunkIdx(index, CONTENTS_START_SHIFT, CONTENTS_START_SIZE);</span>
<span class="nc" id="L181">        int ofs = inChunkPointer(index, leadBit, CONTENTS_START_SIZE);</span>
<span class="nc" id="L182">        AtomicReferenceArray&lt;T&gt; array = contentArrays[leadBit];</span>
<span class="nc" id="L183">        array.set(ofs, value);</span>
<span class="nc" id="L184">    }</span>

    public void discardBuffers()
    {
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (bufferType == BufferType.ON_HEAP)</span>
<span class="nc" id="L189">            return; // no cleaning needed</span>

<span class="nc bnc" id="L191" title="All 2 branches missed.">        for (UnsafeBuffer b : buffers)</span>
        {
<span class="nc bnc" id="L193" title="All 2 branches missed.">            if (b != null)</span>
<span class="nc" id="L194">                FileUtils.clean(b.byteBuffer());</span>
        }
<span class="nc" id="L196">    }</span>

    // Write methods

    // Write visibility model: writes are not volatile, with the exception of the final write before a call returns
    // the same value that was present before (e.g. content was updated in-place / existing node got a new child or had
    // a child pointer updated); if the whole path including the root node changed, the root itself gets a volatile
    // write.
    // This final write is the point where any new cells created during the write become visible for readers for the
    // first time, and such readers must pass through reading that pointer, which forces a happens-before relationship
    // that extends to all values written by this thread before it.

    /**
     * Attach a child to the given non-content node. This may be an update for an existing branch, or a new child for
     * the node. An update _is_ required (i.e. this is only called when the newChild pointer is not the same as the
     * existing value).
     */
    private int attachChild(int node, int trans, int newChild) throws SpaceExhaustedException
    {
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">        assert !isLeaf(node) : &quot;attachChild cannot be used on content nodes.&quot;;</span>

<span class="pc bpc" id="L217" title="2 of 5 branches missed.">        switch (offset(node))</span>
        {
            case PREFIX_OFFSET:
<span class="nc" id="L220">                assert false : &quot;attachChild cannot be used on content nodes.&quot;;</span>
            case SPARSE_OFFSET:
<span class="fc" id="L222">                return attachChildToSparse(node, trans, newChild);</span>
            case SPLIT_OFFSET:
<span class="nc" id="L224">                attachChildToSplit(node, trans, newChild);</span>
<span class="nc" id="L225">                return node;</span>
            case LAST_POINTER_OFFSET - 1:
                // If this is the last character in a Chain block, we can modify the child in-place
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">                if (trans == getUnsignedByte(node))</span>
                {
<span class="nc" id="L230">                    putIntVolatile(node + 1, newChild);</span>
<span class="nc" id="L231">                    return node;</span>
                }
                // else pass through
            default:
<span class="fc" id="L235">                return attachChildToChain(node, trans, newChild);</span>
        }
    }

    /**
     * Attach a child to the given split node. This may be an update for an existing branch, or a new child for the node.
     */
    private void attachChildToSplit(int node, int trans, int newChild) throws SpaceExhaustedException
    {
<span class="nc" id="L244">        int midPos = splitBlockPointerAddress(node, splitNodeMidIndex(trans), SPLIT_START_LEVEL_LIMIT);</span>
<span class="nc" id="L245">        int mid = getInt(midPos);</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">        if (isNull(mid))</span>
        {
<span class="nc" id="L248">            mid = createEmptySplitNode();</span>
<span class="nc" id="L249">            int tailPos = splitBlockPointerAddress(mid, splitNodeTailIndex(trans), SPLIT_OTHER_LEVEL_LIMIT);</span>
<span class="nc" id="L250">            int tail = createEmptySplitNode();</span>
<span class="nc" id="L251">            int childPos = splitBlockPointerAddress(tail, splitNodeChildIndex(trans), SPLIT_OTHER_LEVEL_LIMIT);</span>
<span class="nc" id="L252">            putInt(childPos, newChild);</span>
<span class="nc" id="L253">            putInt(tailPos, tail);</span>
<span class="nc" id="L254">            putIntVolatile(midPos, mid);</span>
<span class="nc" id="L255">            return;</span>
        }

<span class="nc" id="L258">        int tailPos = splitBlockPointerAddress(mid, splitNodeTailIndex(trans), SPLIT_OTHER_LEVEL_LIMIT);</span>
<span class="nc" id="L259">        int tail = getInt(tailPos);</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">        if (isNull(tail))</span>
        {
<span class="nc" id="L262">            tail = createEmptySplitNode();</span>
<span class="nc" id="L263">            int childPos = splitBlockPointerAddress(tail, splitNodeChildIndex(trans), SPLIT_OTHER_LEVEL_LIMIT);</span>
<span class="nc" id="L264">            putInt(childPos, newChild);</span>
<span class="nc" id="L265">            putIntVolatile(tailPos, tail);</span>
<span class="nc" id="L266">            return;</span>
        }

<span class="nc" id="L269">        int childPos = splitBlockPointerAddress(tail, splitNodeChildIndex(trans), SPLIT_OTHER_LEVEL_LIMIT);</span>
<span class="nc" id="L270">        putIntVolatile(childPos, newChild);</span>
<span class="nc" id="L271">    }</span>

    /**
     * Attach a child to the given sparse node. This may be an update for an existing branch, or a new child for the node.
     */
    private int attachChildToSparse(int node, int trans, int newChild) throws SpaceExhaustedException
    {
        int index;
<span class="fc" id="L279">        int smallerCount = 0;</span>
        // first check if this is an update and modify in-place if so
<span class="fc bfc" id="L281" title="All 2 branches covered.">        for (index = 0; index &lt; SPARSE_CHILD_COUNT; ++index)</span>
        {
<span class="fc bfc" id="L283" title="All 2 branches covered.">            if (isNull(getInt(node + SPARSE_CHILDREN_OFFSET + index * 4)))</span>
<span class="fc" id="L284">                break;</span>
<span class="fc" id="L285">            final int existing = getUnsignedByte(node + SPARSE_BYTES_OFFSET + index);</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">            if (existing == trans)</span>
            {
<span class="fc" id="L288">                putIntVolatile(node + SPARSE_CHILDREN_OFFSET + index * 4, newChild);</span>
<span class="fc" id="L289">                return node;</span>
            }
<span class="fc bfc" id="L291" title="All 2 branches covered.">            else if (existing &lt; trans)</span>
<span class="fc" id="L292">                ++smallerCount;</span>
        }
<span class="fc" id="L294">        int childCount = index;</span>

<span class="fc bfc" id="L296" title="All 2 branches covered.">        if (childCount == SPARSE_CHILD_COUNT)</span>
        {
            // Node is full. Switch to split
<span class="fc" id="L299">            int split = createEmptySplitNode();</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">            for (int i = 0; i &lt; SPARSE_CHILD_COUNT; ++i)</span>
            {
<span class="fc" id="L302">                int t = getUnsignedByte(node + SPARSE_BYTES_OFFSET + i);</span>
<span class="fc" id="L303">                int p = getInt(node + SPARSE_CHILDREN_OFFSET + i * 4);</span>
<span class="fc" id="L304">                attachChildToSplitNonVolatile(split, t, p);</span>
            }
<span class="fc" id="L306">            attachChildToSplitNonVolatile(split, trans, newChild);</span>
<span class="fc" id="L307">            return split;</span>
        }

        // Add a new transition. They are not kept in order, so append it at the first free position.
<span class="fc" id="L311">        putByte(node + SPARSE_BYTES_OFFSET + childCount, (byte) trans);</span>

        // Update order word.
<span class="fc" id="L314">        int order = getUnsignedShort(node + SPARSE_ORDER_OFFSET);</span>
<span class="fc" id="L315">        int newOrder = insertInOrderWord(order, childCount, smallerCount);</span>

        // Sparse nodes have two access modes: via the order word, when listing transitions, or directly to characters
        // and addresses.
        // To support the former, we volatile write to the order word last, and everything is correctly set up.
        // The latter does not touch the order word. To support that too, we volatile write the address, as the reader
        // can't determine if the position is in use based on the character byte alone (00 is also a valid transition).
        // Note that this means that reader must check the transition byte AFTER the address, to ensure they get the
        // correct value (see getSparseChild).

        // setting child enables reads to start seeing the new branch
<span class="fc" id="L326">        putIntVolatile(node + SPARSE_CHILDREN_OFFSET + childCount * 4, newChild);</span>

        // some readers will decide whether to check the pointer based on the order word
        // write that volatile to make sure they see the new change too
<span class="fc" id="L330">        putShortVolatile(node + SPARSE_ORDER_OFFSET,  (short) newOrder);</span>
<span class="fc" id="L331">        return node;</span>
    }

    /**
     * Insert the given newIndex in the base-6 encoded order word in the correct position with respect to the ordering.
     *
     * E.g.
     *   - insertOrderWord(120, 3, 0) must return 1203 (decimal 48*6 + 3)
     *   - insertOrderWord(120, 3, 1, ptr) must return 1230 (decimal 8*36 + 3*6 + 0)
     *   - insertOrderWord(120, 3, 2, ptr) must return 1320 (decimal 1*216 + 3*36 + 12)
     *   - insertOrderWord(120, 3, 3, ptr) must return 3120 (decimal 3*216 + 48)
     */
    private static int insertInOrderWord(int order, int newIndex, int smallerCount)
    {
<span class="fc" id="L345">        int r = 1;</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">        for (int i = 0; i &lt; smallerCount; ++i)</span>
<span class="fc" id="L347">            r *= 6;</span>
<span class="fc" id="L348">        int head = order / r;</span>
<span class="fc" id="L349">        int tail = order % r;</span>
        // insert newIndex after the ones we have passed (order % r) and before the remaining (order / r)
<span class="fc" id="L351">        return tail + (head * 6 + newIndex) * r;</span>
    }

    /**
     * Non-volatile version of attachChildToSplit. Used when the split node is not reachable yet (during the conversion
     * from sparse).
     */
    private void attachChildToSplitNonVolatile(int node, int trans, int newChild) throws SpaceExhaustedException
    {
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">        assert offset(node) == SPLIT_OFFSET : &quot;Invalid split node in trie&quot;;</span>
<span class="fc" id="L361">        int midPos = splitBlockPointerAddress(node, splitNodeMidIndex(trans), SPLIT_START_LEVEL_LIMIT);</span>
<span class="fc" id="L362">        int mid = getInt(midPos);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">        if (isNull(mid))</span>
        {
<span class="fc" id="L365">            mid = createEmptySplitNode();</span>
<span class="fc" id="L366">            putInt(midPos, mid);</span>
        }

<span class="pc bpc" id="L369" title="1 of 2 branches missed.">        assert offset(mid) == SPLIT_OFFSET : &quot;Invalid split node in trie&quot;;</span>
<span class="fc" id="L370">        int tailPos = splitBlockPointerAddress(mid, splitNodeTailIndex(trans), SPLIT_OTHER_LEVEL_LIMIT);</span>
<span class="fc" id="L371">        int tail = getInt(tailPos);</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (isNull(tail))</span>
        {
<span class="fc" id="L374">            tail = createEmptySplitNode();</span>
<span class="fc" id="L375">            putInt(tailPos, tail);</span>
        }

<span class="pc bpc" id="L378" title="1 of 2 branches missed.">        assert offset(tail) == SPLIT_OFFSET : &quot;Invalid split node in trie&quot;;</span>
<span class="fc" id="L379">        int childPos = splitBlockPointerAddress(tail, splitNodeChildIndex(trans), SPLIT_OTHER_LEVEL_LIMIT);</span>
<span class="fc" id="L380">        putInt(childPos, newChild);</span>
<span class="fc" id="L381">    }</span>

    /**
     * Attach a child to the given chain node. This may be an update for an existing branch with different target
     * address, or a second child for the node.
     * This method always copies the node -- with the exception of updates that change the child of the last node in a
     * chain block with matching transition byte (which this method is not used for, see attachChild), modifications to
     * chain nodes cannot be done in place, either because we introduce a new transition byte and have to convert from
     * the single-transition chain type to sparse, or because we have to remap the child from the implicit node + 1 to
     * something else.
     */
    private int attachChildToChain(int node, int transitionByte, int newChild) throws SpaceExhaustedException
    {
<span class="fc" id="L394">        int existingByte = getUnsignedByte(node);</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">        if (transitionByte == existingByte)</span>
        {
            // This will only be called if new child is different from old, and the update is not on the final child
            // where we can change it in place (see attachChild). We must always create something new.
            // If the child is a chain, we can expand it (since it's a different value, its branch must be new and
            // nothing can already reside in the rest of the block).
<span class="fc" id="L401">            return expandOrCreateChainNode(transitionByte, newChild);</span>
        }

        // The new transition is different, so we no longer have only one transition. Change type.
<span class="fc" id="L405">        int existingChild = node + 1;</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">        if (offset(existingChild) == LAST_POINTER_OFFSET)</span>
        {
<span class="fc" id="L408">            existingChild = getInt(existingChild);</span>
        }
<span class="fc" id="L410">        return createSparseNode(existingByte, existingChild, transitionByte, newChild);</span>
    }

    private boolean isExpandableChain(int newChild)
    {
<span class="fc" id="L415">        int newOffset = offset(newChild);</span>
<span class="pc bpc" id="L416" title="2 of 8 branches missed.">        return newChild &gt; 0 &amp;&amp; newChild - 1 &gt; NONE &amp;&amp; newOffset &gt; CHAIN_MIN_OFFSET &amp;&amp; newOffset &lt;= CHAIN_MAX_OFFSET;</span>
    }

    /**
     * Create a sparse node with two children.
     */
    private int createSparseNode(int byte1, int child1, int byte2, int child2) throws SpaceExhaustedException
    {
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">        assert byte1 != byte2 : &quot;Attempted to create a sparse node with two of the same transition&quot;;</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">        if (byte1 &gt; byte2)</span>
        {
            // swap them so the smaller is byte1, i.e. there's always something bigger than child 0 so 0 never is
            // at the end of the order
<span class="fc" id="L429">            int t = byte1; byte1 = byte2; byte2 = t;</span>
<span class="fc" id="L430">            t = child1; child1 = child2; child2 = t;</span>
        }

<span class="fc" id="L433">        int node = allocateBlock() + SPARSE_OFFSET;</span>
<span class="fc" id="L434">        putByte(node + SPARSE_BYTES_OFFSET + 0,  (byte) byte1);</span>
<span class="fc" id="L435">        putByte(node + SPARSE_BYTES_OFFSET + 1,  (byte) byte2);</span>
<span class="fc" id="L436">        putInt(node + SPARSE_CHILDREN_OFFSET + 0 * 4, child1);</span>
<span class="fc" id="L437">        putInt(node + SPARSE_CHILDREN_OFFSET + 1 * 4, child2);</span>
<span class="fc" id="L438">        putShort(node + SPARSE_ORDER_OFFSET,  (short) (1 * 6 + 0));</span>
        // Note: this does not need a volatile write as it is a new node, returning a new pointer, which needs to be
        // put in an existing node or the root. That action ends in a happens-before enforcing write.
<span class="fc" id="L441">        return node;</span>
    }

    /**
     * Creates a chain node with the single provided transition (pointing to the provided child).
     * Note that to avoid creating inefficient tries with under-utilized chain nodes, this should only be called from
     * {@link #expandOrCreateChainNode} and other call-sites should call {@link #expandOrCreateChainNode}.
     */
    private int createNewChainNode(int transitionByte, int newChild) throws SpaceExhaustedException
    {
<span class="fc" id="L451">        int newNode = allocateBlock() + LAST_POINTER_OFFSET - 1;</span>
<span class="fc" id="L452">        putByte(newNode, (byte) transitionByte);</span>
<span class="fc" id="L453">        putInt(newNode + 1, newChild);</span>
        // Note: this does not need a volatile write as it is a new node, returning a new pointer, which needs to be
        // put in an existing node or the root. That action ends in a happens-before enforcing write.
<span class="fc" id="L456">        return newNode;</span>
    }

    /** Like {@link #createNewChainNode}, but if the new child is already a chain node and has room, expand
     * it instead of creating a brand new node. */
    private int expandOrCreateChainNode(int transitionByte, int newChild) throws SpaceExhaustedException
    {
<span class="fc bfc" id="L463" title="All 2 branches covered.">        if (isExpandableChain(newChild))</span>
        {
            // attach as a new character in child node
<span class="fc" id="L466">            int newNode = newChild - 1;</span>
<span class="fc" id="L467">            putByte(newNode, (byte) transitionByte);</span>
<span class="fc" id="L468">            return newNode;</span>
        }

<span class="fc" id="L471">        return createNewChainNode(transitionByte, newChild);</span>
    }

    private int createEmptySplitNode() throws SpaceExhaustedException
    {
<span class="fc" id="L476">        return allocateBlock() + SPLIT_OFFSET;</span>
    }

    private int createPrefixNode(int contentIndex, int child, boolean isSafeChain) throws SpaceExhaustedException
    {
<span class="nc bnc" id="L481" title="All 2 branches missed.">        assert !isNullOrLeaf(child) : &quot;Prefix node cannot reference a childless node.&quot;;</span>

<span class="nc" id="L483">        int offset = offset(child);</span>
        int node;
<span class="nc bnc" id="L485" title="All 8 branches missed.">        if (offset == SPLIT_OFFSET || isSafeChain &amp;&amp; offset &gt; (PREFIX_FLAGS_OFFSET + PREFIX_OFFSET) &amp;&amp; offset &lt;= CHAIN_MAX_OFFSET)</span>
        {
            // We can do an embedded prefix node
            // Note: for chain nodes we have a risk that the node continues beyond the current point, in which case
            // creating the embedded node may overwrite information that is still needed by concurrent readers or the
            // mutation process itself.
<span class="nc" id="L491">            node = (child &amp; -BLOCK_SIZE) | PREFIX_OFFSET;</span>
<span class="nc" id="L492">            putByte(node + PREFIX_FLAGS_OFFSET, (byte) offset);</span>
        }
        else
        {
            // Full prefix node
<span class="nc" id="L497">            node = allocateBlock() + PREFIX_OFFSET;</span>
<span class="nc" id="L498">            putByte(node + PREFIX_FLAGS_OFFSET, (byte) 0xFF);</span>
<span class="nc" id="L499">            putInt(node + PREFIX_POINTER_OFFSET, child);</span>
        }

<span class="nc" id="L502">        putInt(node + PREFIX_CONTENT_OFFSET, contentIndex);</span>
<span class="nc" id="L503">        return node;</span>
    }

    private int updatePrefixNodeChild(int node, int child) throws SpaceExhaustedException
    {
<span class="nc bnc" id="L508" title="All 2 branches missed.">        assert offset(node) == PREFIX_OFFSET : &quot;updatePrefix called on non-prefix node&quot;;</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">        assert !isNullOrLeaf(child) : &quot;Prefix node cannot reference a childless node.&quot;;</span>

        // We can only update in-place if we have a full prefix node
<span class="nc bnc" id="L512" title="All 2 branches missed.">        if (!isEmbeddedPrefixNode(node))</span>
        {
            // This attaches the child branch and makes it reachable -- the write must be volatile.
<span class="nc" id="L515">            putIntVolatile(node + PREFIX_POINTER_OFFSET, child);</span>
<span class="nc" id="L516">            return node;</span>
        }
        else
        {
<span class="nc" id="L520">            int contentIndex = getInt(node + PREFIX_CONTENT_OFFSET);</span>
<span class="nc" id="L521">            return createPrefixNode(contentIndex, child, true);</span>
        }
    }

    private boolean isEmbeddedPrefixNode(int node)
    {
<span class="nc bnc" id="L527" title="All 2 branches missed.">        return getUnsignedByte(node + PREFIX_FLAGS_OFFSET) &lt; BLOCK_SIZE;</span>
    }

    /**
     * Copy the content from an existing node, if it has any, to a newly-prepared update for its child.
     *
     * @param existingPreContentNode pointer to the existing node before skipping over content nodes, i.e. this is
     *                               either the same as existingPostContentNode or a pointer to a prefix or leaf node
     *                               whose child is existingPostContentNode
     * @param existingPostContentNode pointer to the existing node being updated, after any content nodes have been
     *                                skipped and before any modification have been applied; always a non-content node
     * @param updatedPostContentNode is the updated node, i.e. the node to which all relevant modifications have been
     *                               applied; if the modifications were applied in-place, this will be the same as
     *                               existingPostContentNode, otherwise a completely different pointer; always a non-
     *                               content node
     * @return a node which has the children of updatedPostContentNode combined with the content of
     *         existingPreContentNode
     */
    private int preserveContent(int existingPreContentNode,
                                int existingPostContentNode,
                                int updatedPostContentNode) throws SpaceExhaustedException
    {
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">        if (existingPreContentNode == existingPostContentNode)</span>
<span class="fc" id="L550">            return updatedPostContentNode;     // no content to preserve</span>

<span class="nc bnc" id="L552" title="All 2 branches missed.">        if (existingPostContentNode == updatedPostContentNode)</span>
<span class="nc" id="L553">            return existingPreContentNode;     // child didn't change, no update necessary</span>

        // else we have existing prefix node, and we need to reference a new child
<span class="nc bnc" id="L556" title="All 2 branches missed.">        if (isLeaf(existingPreContentNode))</span>
        {
<span class="nc" id="L558">            return createPrefixNode(~existingPreContentNode, updatedPostContentNode, true);</span>
        }

<span class="nc bnc" id="L561" title="All 2 branches missed.">        assert offset(existingPreContentNode) == PREFIX_OFFSET : &quot;Unexpected content in non-prefix and non-leaf node.&quot;;</span>
<span class="nc" id="L562">        return updatePrefixNodeChild(existingPreContentNode, updatedPostContentNode);</span>
    }

<span class="fc" id="L565">    final ApplyState applyState = new ApplyState();</span>

    /**
     * Represents the state for an {@link #apply} operation. Contains a stack of all nodes we descended through
     * and used to update the nodes with any new data during ascent.
     *
     * To make this as efficient and GC-friendly as possible, we use an integer array (instead of is an object stack)
     * and we reuse the same object. The latter is safe because memtable tries cannot be mutated in parallel by multiple
     * writers.
     */
<span class="fc" id="L575">    class ApplyState</span>
    {
<span class="fc" id="L577">        int[] data = new int[16 * 5];</span>
<span class="fc" id="L578">        int currentDepth = -1;</span>

        void reset()
        {
<span class="fc" id="L582">            currentDepth = -1;</span>
<span class="fc" id="L583">        }</span>

        /**
         * Pointer to the existing node before skipping over content nodes, i.e. this is either the same as
         * existingPostContentNode or a pointer to a prefix or leaf node whose child is existingPostContentNode.
         */
        int existingPreContentNode()
        {
<span class="fc" id="L591">            return data[currentDepth * 5 + 0];</span>
        }
        void setExistingPreContentNode(int value)
        {
<span class="fc" id="L595">            data[currentDepth * 5 + 0] = value;</span>
<span class="fc" id="L596">        }</span>

        /**
         * Pointer to the existing node being updated, after any content nodes have been skipped and before any
         * modification have been applied. Always a non-content node.
         */
        int existingPostContentNode()
        {
<span class="fc" id="L604">            return data[currentDepth * 5 + 1];</span>
        }
        void setExistingPostContentNode(int value)
        {
<span class="fc" id="L608">            data[currentDepth * 5 + 1] = value;</span>
<span class="fc" id="L609">        }</span>

        /**
         * The updated node, i.e. the node to which the relevant modifications are being applied. This will change as
         * children are processed and attached to the node. After all children have been processed, this will contain
         * the fully updated node (i.e. the union of existingPostContentNode and mutationNode) without any content,
         * which will be processed separately and, if necessary, attached ahead of this. If the modifications were
         * applied in-place, this will be the same as existingPostContentNode, otherwise a completely different
         * pointer. Always a non-content node.
         */
        int updatedPostContentNode()
        {
<span class="fc" id="L621">            return data[currentDepth * 5 + 2];</span>
        }
        void setUpdatedPostContentNode(int value)
        {
<span class="fc" id="L625">            data[currentDepth * 5 + 2] = value;</span>
<span class="fc" id="L626">        }</span>

        /**
         * The transition we took on the way down.
         */
        int transition()
        {
<span class="fc" id="L633">            return data[currentDepth * 5 + 3];</span>
        }
        void setTransition(int transition)
        {
<span class="fc" id="L637">            data[currentDepth * 5 + 3] = transition;</span>
<span class="fc" id="L638">        }</span>

        /**
         * The compiled content index. Needed because we can only access a cursor's content on the way down but we can't
         * attach it until we ascend from the node.
         */
        int contentIndex()
        {
<span class="fc" id="L646">            return data[currentDepth * 5 + 4];</span>
        }
        void setContentIndex(int value)
        {
<span class="fc" id="L650">            data[currentDepth * 5 + 4] = value;</span>
<span class="fc" id="L651">        }</span>

        /**
         * Descend to a child node. Prepares a new entry in the stack for the node.
         */
        &lt;U&gt; void descend(int transition, U mutationContent, final UpsertTransformer&lt;T, U&gt; transformer)
        {
            int existingPreContentNode;
<span class="fc bfc" id="L659" title="All 2 branches covered.">            if (currentDepth &lt; 0)</span>
<span class="fc" id="L660">                existingPreContentNode = root;</span>
            else
            {
<span class="fc" id="L663">                setTransition(transition);</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">                existingPreContentNode = isNull(existingPostContentNode())</span>
<span class="fc" id="L665">                                         ? NONE</span>
<span class="fc" id="L666">                                         : getChild(existingPostContentNode(), transition);</span>
            }

<span class="fc" id="L669">            ++currentDepth;</span>
<span class="pc bpc" id="L670" title="1 of 2 branches missed.">            if (currentDepth * 5 &gt;= data.length)</span>
<span class="nc" id="L671">                data = Arrays.copyOf(data, currentDepth * 5 * 2);</span>
<span class="fc" id="L672">            setExistingPreContentNode(existingPreContentNode);</span>

<span class="fc" id="L674">            int existingContentIndex = -1;</span>
            int existingPostContentNode;
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">            if (isLeaf(existingPreContentNode))</span>
            {
<span class="nc" id="L678">                existingContentIndex = ~existingPreContentNode;</span>
<span class="nc" id="L679">                existingPostContentNode = NONE;</span>
            }
<span class="pc bpc" id="L681" title="1 of 2 branches missed.">            else if (offset(existingPreContentNode) == PREFIX_OFFSET)</span>
            {
<span class="nc" id="L683">                existingContentIndex = getInt(existingPreContentNode + PREFIX_CONTENT_OFFSET);</span>
<span class="nc" id="L684">                existingPostContentNode = followContentTransition(existingPreContentNode);</span>
            }
            else
<span class="fc" id="L687">                existingPostContentNode = existingPreContentNode;</span>
<span class="fc" id="L688">            setExistingPostContentNode(existingPostContentNode);</span>
<span class="fc" id="L689">            setUpdatedPostContentNode(existingPostContentNode);</span>

<span class="fc" id="L691">            int contentIndex = updateContentIndex(mutationContent, existingContentIndex, transformer);</span>
<span class="fc" id="L692">            setContentIndex(contentIndex);</span>
<span class="fc" id="L693">        }</span>

        /**
         * Combine existing and new content.
         */
        private &lt;U&gt; int updateContentIndex(U mutationContent, int existingContentIndex, final UpsertTransformer&lt;T, U&gt; transformer)
        {
<span class="fc bfc" id="L700" title="All 2 branches covered.">            if (mutationContent != null)</span>
            {
<span class="pc bpc" id="L702" title="1 of 2 branches missed.">                if (existingContentIndex != -1)</span>
                {
<span class="nc" id="L704">                    final T existingContent = getContent(existingContentIndex);</span>
<span class="nc" id="L705">                    T combinedContent = transformer.apply(existingContent, mutationContent);</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">                    assert (combinedContent != null) : &quot;Transformer cannot be used to remove content.&quot;;</span>
<span class="nc" id="L707">                    setContent(existingContentIndex, combinedContent);</span>
<span class="nc" id="L708">                    return existingContentIndex;</span>
                }
                else
                {
<span class="fc" id="L712">                    T combinedContent = transformer.apply(null, mutationContent);</span>
<span class="pc bpc" id="L713" title="1 of 2 branches missed.">                    assert (combinedContent != null) : &quot;Transformer cannot be used to remove content.&quot;;</span>
<span class="fc" id="L714">                    return addContent(combinedContent);</span>
                }
            }
            else
<span class="fc" id="L718">                return existingContentIndex;</span>
        }

        /**
         * Attach a child to the current node.
         */
        private void attachChild(int transition, int child) throws SpaceExhaustedException
        {
<span class="fc" id="L726">            int updatedPostContentNode = updatedPostContentNode();</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">            if (isNull(updatedPostContentNode))</span>
<span class="fc" id="L728">                setUpdatedPostContentNode(expandOrCreateChainNode(transition, child));</span>
            else
<span class="fc" id="L730">                setUpdatedPostContentNode(InMemoryTrie.this.attachChild(updatedPostContentNode,</span>
                                                                        transition,
                                                                        child));
<span class="fc" id="L733">        }</span>

        /**
         * Apply the collected content to a node. Converts NONE to a leaf node, and adds or updates a prefix for all
         * others.
         */
        private int applyContent() throws SpaceExhaustedException
        {
<span class="fc" id="L741">            int contentIndex = contentIndex();</span>
<span class="fc" id="L742">            int updatedPostContentNode = updatedPostContentNode();</span>
<span class="fc bfc" id="L743" title="All 2 branches covered.">            if (contentIndex == -1)</span>
<span class="fc" id="L744">                return updatedPostContentNode;</span>

<span class="pc bpc" id="L746" title="1 of 2 branches missed.">            if (isNull(updatedPostContentNode))</span>
<span class="fc" id="L747">                return ~contentIndex;</span>

<span class="nc" id="L749">            int existingPreContentNode = existingPreContentNode();</span>
<span class="nc" id="L750">            int existingPostContentNode = existingPostContentNode();</span>

            // We can't update in-place if there was no preexisting prefix, or if the prefix was embedded and the target
            // node must change.
<span class="nc bnc" id="L754" title="All 2 branches missed.">            if (existingPreContentNode == existingPostContentNode ||</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">                isNull(existingPostContentNode) ||</span>
<span class="nc bnc" id="L756" title="All 4 branches missed.">                isEmbeddedPrefixNode(existingPreContentNode) &amp;&amp; updatedPostContentNode != existingPostContentNode)</span>
<span class="nc" id="L757">                return createPrefixNode(contentIndex, updatedPostContentNode, isNull(existingPostContentNode));</span>

            // Otherwise modify in place
<span class="nc bnc" id="L760" title="All 2 branches missed.">            if (updatedPostContentNode != existingPostContentNode) // to use volatile write but also ensure we don't corrupt embedded nodes</span>
<span class="nc" id="L761">                putIntVolatile(existingPreContentNode + PREFIX_POINTER_OFFSET, updatedPostContentNode);</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">            assert contentIndex == getInt(existingPreContentNode + PREFIX_CONTENT_OFFSET) : &quot;Unexpected change of content index.&quot;;</span>
<span class="nc" id="L763">            return existingPreContentNode;</span>
        }

        /**
         * After a node's children are processed, this is called to ascend from it. This means applying the collected
         * content to the compiled updatedPostContentNode and creating a mapping in the parent to it (or updating if
         * one already exists).
         * Returns true if still have work to do, false if the operation is completed.
         */
        private boolean attachAndMoveToParentState() throws SpaceExhaustedException
        {
<span class="fc" id="L774">            int updatedPreContentNode = applyContent();</span>
<span class="fc" id="L775">            int existingPreContentNode = existingPreContentNode();</span>
<span class="fc" id="L776">            --currentDepth;</span>
<span class="fc bfc" id="L777" title="All 2 branches covered.">            if (currentDepth == -1)</span>
            {
<span class="pc bpc" id="L779" title="1 of 2 branches missed.">                assert root == existingPreContentNode : &quot;Unexpected change to root. Concurrent trie modification?&quot;;</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">                if (updatedPreContentNode != existingPreContentNode)</span>
                {
                    // Only write to root if they are different (value doesn't change, but
                    // we don't want to invalidate the value in other cores' caches unnecessarily).
<span class="fc" id="L784">                    root = updatedPreContentNode;</span>
                }
<span class="fc" id="L786">                return false;</span>
            }
<span class="fc bfc" id="L788" title="All 2 branches covered.">            if (updatedPreContentNode != existingPreContentNode)</span>
<span class="fc" id="L789">                attachChild(transition(), updatedPreContentNode);</span>
<span class="fc" id="L790">            return true;</span>
        }
    }

    /**
     * Somewhat similar to {@link MergeResolver}, this encapsulates logic to be applied whenever new content is being
     * upserted into a {@link InMemoryTrie}. Unlike {@link MergeResolver}, {@link UpsertTransformer} will be applied no
     * matter if there's pre-existing content for that trie key/path or not.
     *
     * @param &lt;T&gt; The content type for this {@link InMemoryTrie}.
     * @param &lt;U&gt; The type of the new content being applied to this {@link InMemoryTrie}.
     */
    public interface UpsertTransformer&lt;T, U&gt;
    {
        /**
         * Called when there's content in the updating trie.
         *
         * @param existing Existing content for this key, or null if there isn't any.
         * @param update   The update, always non-null.
         * @return The combined value to use. Cannot be null.
         */
        T apply(T existing, U update);
    }

    /**
     * Modify this trie to apply the mutation given in the form of a trie. Any content in the mutation will be resolved
     * with the given function before being placed in this trie (even if there's no pre-existing content in this trie).
     * @param mutation the mutation to be applied, given in the form of a trie. Note that its content can be of type
     * different than the element type for this memtable trie.
     * @param transformer a function applied to the potentially pre-existing value for the given key, and the new
     * value. Applied even if there's no pre-existing value in the memtable trie.
     */
    public &lt;U&gt; void apply(Trie&lt;U&gt; mutation, final UpsertTransformer&lt;T, U&gt; transformer) throws SpaceExhaustedException
    {
<span class="fc" id="L824">        Cursor&lt;U&gt; mutationCursor = mutation.cursor();</span>
<span class="pc bpc" id="L825" title="1 of 2 branches missed.">        assert mutationCursor.depth() == 0 : &quot;Unexpected non-fresh cursor.&quot;;</span>
<span class="fc" id="L826">        ApplyState state = applyState;</span>
<span class="fc" id="L827">        state.reset();</span>
<span class="fc" id="L828">        state.descend(-1, mutationCursor.content(), transformer);</span>
<span class="pc bpc" id="L829" title="1 of 2 branches missed.">        assert state.currentDepth == 0 : &quot;Unexpected change to applyState. Concurrent trie modification?&quot;;</span>

        while (true)
        {
<span class="fc" id="L833">            int depth = mutationCursor.advance();</span>
<span class="fc bfc" id="L834" title="All 2 branches covered.">            while (state.currentDepth &gt;= depth)</span>
            {
                // There are no more children. Ascend to the parent state to continue walk.
<span class="fc bfc" id="L837" title="All 2 branches covered.">                if (!state.attachAndMoveToParentState())</span>
                {
<span class="pc bpc" id="L839" title="1 of 2 branches missed.">                    assert depth == -1 : &quot;Unexpected change to applyState. Concurrent trie modification?&quot;;</span>
<span class="fc" id="L840">                    return;</span>
                }
            }

            // We have a transition, get child to descend into
<span class="fc" id="L845">            state.descend(mutationCursor.incomingTransition(), mutationCursor.content(), transformer);</span>
<span class="pc bpc" id="L846" title="1 of 2 branches missed.">            assert state.currentDepth == depth : &quot;Unexpected change to applyState. Concurrent trie modification?&quot;;</span>
<span class="fc" id="L847">        }</span>
    }

    /**
     * Map-like put method, using the apply machinery above which cannot run into stack overflow. When the correct
     * position in the trie has been reached, the value will be resolved with the given function before being placed in
     * the trie (even if there's no pre-existing content in this trie).
     * @param key the trie path/key for the given value.
     * @param value the value being put in the memtable trie. Note that it can be of type different than the element
     * type for this memtable trie. It's up to the {@code transformer} to return the final value that will stay in
     * the memtable trie.
     * @param transformer a function applied to the potentially pre-existing value for the given key, and the new
     * value (of a potentially different type), returning the final value that will stay in the memtable trie. Applied
     * even if there's no pre-existing value in the memtable trie.
     */
    public &lt;R&gt; void putSingleton(ByteComparable key,
                                 R value,
                                 UpsertTransformer&lt;T, ? super R&gt; transformer) throws SpaceExhaustedException
    {
<span class="fc" id="L866">        apply(Trie.singleton(key, value), transformer);</span>
<span class="fc" id="L867">    }</span>

    /**
     * A version of putSingleton which uses recursive put if the last argument is true.
     */
    public &lt;R&gt; void putSingleton(ByteComparable key,
                                 R value,
                                 UpsertTransformer&lt;T, ? super R&gt; transformer,
                                 boolean useRecursive) throws SpaceExhaustedException
    {
<span class="nc bnc" id="L877" title="All 2 branches missed.">        if (useRecursive)</span>
<span class="nc" id="L878">            putRecursive(key, value, transformer);</span>
        else
<span class="nc" id="L880">            putSingleton(key, value, transformer);</span>
<span class="nc" id="L881">    }</span>

    /**
     * Map-like put method, using a fast recursive implementation through the key bytes. May run into stack overflow if
     * the trie becomes too deep. When the correct position in the trie has been reached, the value will be resolved
     * with the given function before being placed in the trie (even if there's no pre-existing content in this trie).
     * @param key the trie path/key for the given value.
     * @param value the value being put in the memtable trie. Note that it can be of type different than the element
     * type for this memtable trie. It's up to the {@code transformer} to return the final value that will stay in
     * the memtable trie.
     * @param transformer a function applied to the potentially pre-existing value for the given key, and the new
     * value (of a potentially different type), returning the final value that will stay in the memtable trie. Applied
     * even if there's no pre-existing value in the memtable trie.
     */
    public &lt;R&gt; void putRecursive(ByteComparable key, R value, final UpsertTransformer&lt;T, R&gt; transformer) throws SpaceExhaustedException
    {
<span class="fc" id="L897">        int newRoot = putRecursive(root, key.asComparableBytes(BYTE_COMPARABLE_VERSION), value, transformer);</span>
<span class="fc bfc" id="L898" title="All 2 branches covered.">        if (newRoot != root)</span>
<span class="fc" id="L899">            root = newRoot;</span>
<span class="fc" id="L900">    }</span>

    private &lt;R&gt; int putRecursive(int node, ByteSource key, R value, final UpsertTransformer&lt;T, R&gt; transformer) throws SpaceExhaustedException
    {
<span class="fc" id="L904">        int transition = key.next();</span>
<span class="fc bfc" id="L905" title="All 2 branches covered.">        if (transition == ByteSource.END_OF_STREAM)</span>
<span class="fc" id="L906">            return applyContent(node, value, transformer);</span>

<span class="fc" id="L908">        int child = getChild(node, transition);</span>

<span class="fc" id="L910">        int newChild = putRecursive(child, key, value, transformer);</span>
<span class="fc bfc" id="L911" title="All 2 branches covered.">        if (newChild == child)</span>
<span class="fc" id="L912">            return node;</span>

<span class="fc" id="L914">        int skippedContent = followContentTransition(node);</span>
<span class="fc bfc" id="L915" title="All 2 branches covered.">        int attachedChild = !isNull(skippedContent)</span>
<span class="fc" id="L916">                            ? attachChild(skippedContent, transition, newChild)  // Single path, no copying required</span>
<span class="fc" id="L917">                            : expandOrCreateChainNode(transition, newChild);</span>

<span class="fc" id="L919">        return preserveContent(node, skippedContent, attachedChild);</span>
    }

    private &lt;R&gt; int applyContent(int node, R value, UpsertTransformer&lt;T, R&gt; transformer) throws SpaceExhaustedException
    {
<span class="pc bpc" id="L924" title="1 of 2 branches missed.">        if (isNull(node))</span>
<span class="fc" id="L925">            return ~addContent(transformer.apply(null, value));</span>

<span class="nc bnc" id="L927" title="All 2 branches missed.">        if (isLeaf(node))</span>
        {
<span class="nc" id="L929">            int contentIndex = ~node;</span>
<span class="nc" id="L930">            setContent(contentIndex, transformer.apply(getContent(contentIndex), value));</span>
<span class="nc" id="L931">            return node;</span>
        }

<span class="nc bnc" id="L934" title="All 2 branches missed.">        if (offset(node) == PREFIX_OFFSET)</span>
        {
<span class="nc" id="L936">            int contentIndex = getInt(node + PREFIX_CONTENT_OFFSET);</span>
<span class="nc" id="L937">            setContent(contentIndex, transformer.apply(getContent(contentIndex), value));</span>
<span class="nc" id="L938">            return node;</span>
        }
        else
<span class="nc" id="L941">            return createPrefixNode(addContent(transformer.apply(null, value)), node, false);</span>
    }

    /**
     * Returns true if the allocation threshold has been reached. To be called by the the writing thread (ideally, just
     * after the write completes). When this returns true, the user should switch to a new trie as soon as feasible.
     *
     * The trie expects up to 10% growth above this threshold. Any growth beyond that may be done inefficiently, and
     * the trie will fail altogether when the size grows beyond 2G - 256 bytes.
     */
    public boolean reachedAllocatedSizeThreshold()
    {
<span class="nc bnc" id="L953" title="All 2 branches missed.">        return allocatedPos &gt;= ALLOCATED_SIZE_THRESHOLD;</span>
    }

    /**
     * For tests only! Advance the allocation pointer (and allocate space) by this much to test behaviour close to
     * full.
     */
    @VisibleForTesting
    int advanceAllocatedPos(int wantedPos) throws SpaceExhaustedException
    {
<span class="nc bnc" id="L963" title="All 2 branches missed.">        while (allocatedPos &lt; wantedPos)</span>
<span class="nc" id="L964">            allocateBlock();</span>
<span class="nc" id="L965">        return allocatedPos;</span>
    }

    /** Returns the off heap size of the memtable trie itself, not counting any space taken by referenced content. */
    public long sizeOffHeap()
    {
<span class="pc bpc" id="L971" title="1 of 2 branches missed.">        return bufferType == BufferType.ON_HEAP ? 0 : allocatedPos;</span>
    }

    /** Returns the on heap size of the memtable trie itself, not counting any space taken by referenced content. */
    public long sizeOnHeap()
    {
<span class="fc" id="L977">        return contentCount * MemoryMeterStrategy.MEMORY_LAYOUT.getReferenceSize() +</span>
<span class="fc" id="L978">               REFERENCE_ARRAY_ON_HEAP_SIZE * getChunkIdx(contentCount, CONTENTS_START_SHIFT, CONTENTS_START_SIZE) +</span>
<span class="pc bpc" id="L979" title="1 of 2 branches missed.">               (bufferType == BufferType.ON_HEAP ? allocatedPos + EMPTY_SIZE_ON_HEAP : EMPTY_SIZE_OFF_HEAP) +</span>
<span class="fc" id="L980">               REFERENCE_ARRAY_ON_HEAP_SIZE * getChunkIdx(allocatedPos, BUF_START_SHIFT, BUF_START_SIZE);</span>
    }

    @Override
    public Iterable&lt;T&gt; valuesUnordered()
    {
<span class="nc" id="L986">        return () -&gt; new Iterator&lt;T&gt;()</span>
        {
            int idx = 0;

            public boolean hasNext()
            {
                return idx &lt; contentCount;
            }

            public T next()
            {
                if (!hasNext())
                    throw new NoSuchElementException();

                return getContent(idx++);
            }
        };
    }

    public int valuesCount()
    {
<span class="nc" id="L1007">        return contentCount;</span>
    }

    public long unusedReservedMemory()
    {
<span class="nc" id="L1012">        int bufferOverhead = 0;</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">        if (bufferType == BufferType.ON_HEAP)</span>
        {
<span class="nc" id="L1015">            int pos = this.allocatedPos;</span>
<span class="nc" id="L1016">            UnsafeBuffer buffer = getChunk(pos);</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">            if (buffer != null)</span>
<span class="nc" id="L1018">                bufferOverhead = buffer.capacity() - inChunkPointer(pos);</span>
        }

<span class="nc" id="L1021">        int index = contentCount;</span>
<span class="nc" id="L1022">        int leadBit = getChunkIdx(index, CONTENTS_START_SHIFT, CONTENTS_START_SIZE);</span>
<span class="nc" id="L1023">        int ofs = inChunkPointer(index, leadBit, CONTENTS_START_SIZE);</span>
<span class="nc" id="L1024">        AtomicReferenceArray&lt;T&gt; contentArray = contentArrays[leadBit];</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">        int contentOverhead = ((contentArray != null ? contentArray.length() : 0) - ofs) * MemoryMeterStrategy.MEMORY_LAYOUT.getReferenceSize();</span>

<span class="nc" id="L1027">        return bufferOverhead + contentOverhead;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>