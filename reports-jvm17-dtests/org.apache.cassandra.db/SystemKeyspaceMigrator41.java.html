<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SystemKeyspaceMigrator41.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db</a> &gt; <span class="el_source">SystemKeyspaceMigrator41.java</span></div><h1>SystemKeyspaceMigrator41.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.db;

import java.util.Collection;
import java.util.Collections;
import java.util.Optional;
import java.util.function.Function;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableMap;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.cql3.QueryProcessor;
import org.apache.cassandra.cql3.UntypedResultSet;
import org.apache.cassandra.db.marshal.BytesType;
import org.apache.cassandra.db.marshal.Int32Type;
import org.apache.cassandra.db.marshal.LongType;
import org.apache.cassandra.db.marshal.TimeUUIDType;
import org.apache.cassandra.db.marshal.UTF8Type;
import org.apache.cassandra.io.sstable.SequenceBasedSSTableId;
import org.apache.cassandra.schema.SchemaConstants;
import org.apache.cassandra.utils.CassandraVersion;
import org.apache.cassandra.utils.FBUtilities;

/**
 * Migrate 3.0 versions of some tables to 4.1. In this case it's just extra columns and some keys
 * that are changed.
 * &lt;p&gt;
 * Can't just add the additional columns because they are primary key columns and C* doesn't support changing
 * key columns even if it's just clustering columns.
 */
public class SystemKeyspaceMigrator41
{
<span class="fc" id="L54">    private static final Logger logger = LoggerFactory.getLogger(SystemKeyspaceMigrator41.class);</span>

    private SystemKeyspaceMigrator41()
    {
    }

    public static void migrate()
    {
<span class="fc" id="L62">        migratePeers();</span>
<span class="fc" id="L63">        migratePeerEvents();</span>
<span class="fc" id="L64">        migrateTransferredRanges();</span>
<span class="fc" id="L65">        migrateAvailableRanges();</span>
<span class="fc" id="L66">        migrateSSTableActivity();</span>
<span class="fc" id="L67">        migrateCompactionHistory();</span>
<span class="fc" id="L68">    }</span>

    @VisibleForTesting
    static void migratePeers()
    {
<span class="fc" id="L73">        migrateTable(false,</span>
                     SystemKeyspace.LEGACY_PEERS,
                     SystemKeyspace.PEERS_V2,
                     new String[]{ &quot;peer&quot;,
                                   &quot;peer_port&quot;,
                                   &quot;data_center&quot;,
                                   &quot;host_id&quot;,
                                   &quot;preferred_ip&quot;,
                                   &quot;preferred_port&quot;,
                                   &quot;rack&quot;,
                                   &quot;release_version&quot;,
                                   &quot;native_address&quot;,
                                   &quot;native_port&quot;,
                                   &quot;schema_version&quot;,
                                   &quot;tokens&quot; },
<span class="nc bnc" id="L88" title="All 2 branches missed.">                     row -&gt; Collections.singletonList(new Object[]{ row.has(&quot;peer&quot;) ? row.getInetAddress(&quot;peer&quot;) : null,</span>
<span class="nc" id="L89">                                                                    DatabaseDescriptor.getStoragePort(),</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">                                                                    row.has(&quot;data_center&quot;) ? row.getString(&quot;data_center&quot;) : null,</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">                                                                    row.has(&quot;host_id&quot;) ? row.getUUID(&quot;host_id&quot;) : null,</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">                                                                    row.has(&quot;preferred_ip&quot;) ? row.getInetAddress(&quot;preferred_ip&quot;) : null,</span>
<span class="nc" id="L93">                                                                    DatabaseDescriptor.getStoragePort(),</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">                                                                    row.has(&quot;rack&quot;) ? row.getString(&quot;rack&quot;) : null,</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">                                                                    row.has(&quot;release_version&quot;) ? row.getString(&quot;release_version&quot;) : null,</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">                                                                    row.has(&quot;rpc_address&quot;) ? row.getInetAddress(&quot;rpc_address&quot;) : null,</span>
<span class="nc" id="L97">                                                                    DatabaseDescriptor.getNativeTransportPort(),</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">                                                                    row.has(&quot;schema_version&quot;) ? row.getUUID(&quot;schema_version&quot;) : null,</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">                                                                    row.has(&quot;tokens&quot;) ? row.getSet(&quot;tokens&quot;, UTF8Type.instance) : null }));</span>
<span class="fc" id="L100">    }</span>

    @VisibleForTesting
    static void migratePeerEvents()
    {
<span class="fc" id="L105">        migrateTable(false,</span>
                     SystemKeyspace.LEGACY_PEER_EVENTS,
                     SystemKeyspace.PEER_EVENTS_V2,
                     new String[]{ &quot;peer&quot;,
                                   &quot;peer_port&quot;,
                                   &quot;hints_dropped&quot; },
<span class="nc" id="L111">                     row -&gt; Collections.singletonList(</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">                     new Object[]{ row.has(&quot;peer&quot;) ? row.getInetAddress(&quot;peer&quot;) : null,</span>
<span class="nc" id="L113">                                   DatabaseDescriptor.getStoragePort(),</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">                                   row.has(&quot;hints_dropped&quot;) ? row.getMap(&quot;hints_dropped&quot;, TimeUUIDType.instance, Int32Type.instance) : null }</span>
                     ));
<span class="fc" id="L116">    }</span>

    @VisibleForTesting
    static void migrateTransferredRanges()
    {
<span class="fc" id="L121">        migrateTable(false,</span>
                     SystemKeyspace.LEGACY_TRANSFERRED_RANGES,
                     SystemKeyspace.TRANSFERRED_RANGES_V2,
                     new String[]{ &quot;operation&quot;, &quot;peer&quot;, &quot;peer_port&quot;, &quot;keyspace_name&quot;, &quot;ranges&quot; },
<span class="nc bnc" id="L125" title="All 2 branches missed.">                     row -&gt; Collections.singletonList(new Object[]{ row.has(&quot;operation&quot;) ? row.getString(&quot;operation&quot;) : null,</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">                                                                    row.has(&quot;peer&quot;) ? row.getInetAddress(&quot;peer&quot;) : null,</span>
<span class="nc" id="L127">                                                                    DatabaseDescriptor.getStoragePort(),</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">                                                                    row.has(&quot;keyspace_name&quot;) ? row.getString(&quot;keyspace_name&quot;) : null,</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">                                                                    row.has(&quot;ranges&quot;) ? row.getSet(&quot;ranges&quot;, BytesType.instance) : null }));</span>
<span class="fc" id="L130">    }</span>

    @VisibleForTesting
    static void migrateAvailableRanges()
    {
<span class="fc" id="L135">        migrateTable(false,</span>
                     SystemKeyspace.LEGACY_AVAILABLE_RANGES,
                     SystemKeyspace.AVAILABLE_RANGES_V2,
                     new String[]{ &quot;keyspace_name&quot;, &quot;full_ranges&quot;, &quot;transient_ranges&quot; },
<span class="nc" id="L139">                     row -&gt; Collections.singletonList(new Object[]{ row.getString(&quot;keyspace_name&quot;),</span>
<span class="nc" id="L140">                                                                    Optional.ofNullable(row.getSet(&quot;ranges&quot;, BytesType.instance)).orElse(Collections.emptySet()),</span>
<span class="nc" id="L141">                                                                    Collections.emptySet() }));</span>
<span class="fc" id="L142">    }</span>

    @VisibleForTesting
    static void migrateSSTableActivity()
    {
<span class="fc" id="L147">        String prevVersionString = FBUtilities.getPreviousReleaseVersionString();</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">        CassandraVersion prevVersion = prevVersionString != null ? new CassandraVersion(prevVersionString) : CassandraVersion.NULL_VERSION;</span>

        // if we are upgrading from pre 4.1, we want to force repopulate the table; this is for the case when we
        // upgraded from pre 4.1, then downgraded to pre 4.1 and then upgraded again
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">        migrateTable(CassandraVersion.CASSANDRA_4_1.compareTo(prevVersion) &gt; 0,</span>
                     SystemKeyspace.LEGACY_SSTABLE_ACTIVITY,
                     SystemKeyspace.SSTABLE_ACTIVITY_V2,
                     new String[]{ &quot;keyspace_name&quot;, &quot;table_name&quot;, &quot;id&quot;, &quot;rate_120m&quot;, &quot;rate_15m&quot; },
                     row -&gt;
<span class="nc" id="L157">                     Collections.singletonList(new Object[]{ row.getString(&quot;keyspace_name&quot;),</span>
<span class="nc" id="L158">                                                             row.getString(&quot;columnfamily_name&quot;),</span>
<span class="nc" id="L159">                                                             new SequenceBasedSSTableId(row.getInt(&quot;generation&quot;)).toString(),</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">                                                             row.has(&quot;rate_120m&quot;) ? row.getDouble(&quot;rate_120m&quot;) : null,</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">                                                             row.has(&quot;rate_15m&quot;) ? row.getDouble(&quot;rate_15m&quot;) : null</span>
                     })
        );
<span class="fc" id="L164">    }</span>
    
    @VisibleForTesting
    static void migrateCompactionHistory()
    {
<span class="fc" id="L169">        migrateTable(false,</span>
                     SystemKeyspace.COMPACTION_HISTORY,
                     SystemKeyspace.COMPACTION_HISTORY,
                     new String[]{ &quot;id&quot;,
                                   &quot;bytes_in&quot;,
                                   &quot;bytes_out&quot;,
                                   &quot;columnfamily_name&quot;,
                                   &quot;compacted_at&quot;,
                                   &quot;keyspace_name&quot;,
                                   &quot;rows_merged&quot;,
                                   &quot;compaction_properties&quot; },
<span class="fc" id="L180">                     row -&gt; Collections.singletonList(new Object[]{ row.getTimeUUID(&quot;id&quot;) ,</span>
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">                                                                    row.has(&quot;bytes_in&quot;) ? row.getLong(&quot;bytes_in&quot;) : null,</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">                                                                    row.has(&quot;bytes_out&quot;) ? row.getLong(&quot;bytes_out&quot;) : null,</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">                                                                    row.has(&quot;columnfamily_name&quot;) ? row.getString(&quot;columnfamily_name&quot;) : null,</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">                                                                    row.has(&quot;compacted_at&quot;) ? row.getTimestamp(&quot;compacted_at&quot;) : null,</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">                                                                    row.has(&quot;keyspace_name&quot;) ? row.getString(&quot;keyspace_name&quot;) : null,</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">                                                                    row.has(&quot;rows_merged&quot;) ? row.getMap(&quot;rows_merged&quot;, Int32Type.instance, LongType.instance) : null,</span>
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">                                                                    row.has(&quot;compaction_properties&quot;) ? row.getMap(&quot;compaction_properties&quot;, UTF8Type.instance, UTF8Type.instance) : ImmutableMap.of() })</span>
        );
<span class="fc" id="L189">    }</span>

    /**
     * Perform table migration by reading data from the old table, converting it, and adding to the new table.
     * If oldName and newName are same, it means data in the table will be refreshed.
     * 
     * @param truncateIfExists truncate the existing table if it exists before migration; if it is disabled
     *                         and the new table is not empty and oldName is not equal to newName, no migration is performed
     * @param oldName          old table name
     * @param newName          new table name
     * @param columns          columns to fill in the new table in the same order as returned by the transformation
     * @param transformation   transformation function which gets the row from the old table and returns a row for the new table
     */
    @VisibleForTesting
    static void migrateTable(boolean truncateIfExists, String oldName, String newName, String[] columns, Function&lt;UntypedResultSet.Row, Collection&lt;Object[]&gt;&gt; transformation)
    {
<span class="fc" id="L205">        ColumnFamilyStore newTable = Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(newName);</span>

<span class="fc bfc" id="L207" title="All 6 branches covered.">        if (!newTable.isEmpty() &amp;&amp; !truncateIfExists &amp;&amp; !oldName.equals(newName))</span>
<span class="fc" id="L208">            return;</span>

<span class="fc bfc" id="L210" title="All 2 branches covered.">        if (truncateIfExists)</span>
<span class="fc" id="L211">            newTable.truncateBlockingWithoutSnapshot();</span>

<span class="fc" id="L213">        logger.info(&quot;{} table was empty, migrating legacy {}, if this fails you should fix the issue and then truncate {} to have it try again.&quot;,</span>
                    newName, oldName, newName);

<span class="fc" id="L216">        String query = String.format(&quot;SELECT * FROM %s.%s&quot;, SchemaConstants.SYSTEM_KEYSPACE_NAME, oldName);</span>
<span class="fc" id="L217">        String insert = String.format(&quot;INSERT INTO %s.%s (%s) VALUES (%s)&quot;, SchemaConstants.SYSTEM_KEYSPACE_NAME, newName,</span>
<span class="fc" id="L218">                                      StringUtils.join(columns, &quot;, &quot;), StringUtils.repeat(&quot;?&quot;, &quot;, &quot;, columns.length));</span>

<span class="fc" id="L220">        UntypedResultSet rows = QueryProcessor.executeInternal(query);</span>

<span class="pc bpc" id="L222" title="1 of 2 branches missed.">        assert rows != null : String.format(&quot;Migrating rows from legacy %s to %s was not done as returned rows from %s are null!&quot;, oldName, newName, oldName);</span>
        
<span class="fc" id="L224">        int transferred = 0;</span>
<span class="fc" id="L225">        logger.info(&quot;Migrating rows from legacy {} to {}&quot;, oldName, newName);</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">        for (UntypedResultSet.Row row : rows)</span>
        {
<span class="fc" id="L228">            logger.debug(&quot;Transferring row {}&quot;, transferred);</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">            for (Object[] newRow : transformation.apply(row))</span>
<span class="fc" id="L230">                QueryProcessor.executeInternal(insert, newRow);</span>
<span class="fc" id="L231">            transferred++;</span>
<span class="fc" id="L232">        }</span>

<span class="fc" id="L234">        logger.info(&quot;Migrated {} rows from legacy {} to {}&quot;, transferred, oldName, newName);</span>
<span class="fc" id="L235">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>