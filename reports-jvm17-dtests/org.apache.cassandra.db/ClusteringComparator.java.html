<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClusteringComparator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db</a> &gt; <span class="el_source">ClusteringComparator.java</span></div><h1>ClusteringComparator.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db;

import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;

import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableList;

import org.apache.cassandra.db.marshal.ValueAccessor;
import org.apache.cassandra.db.rows.Row;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.serializers.MarshalException;

import org.apache.cassandra.io.sstable.IndexInfo;
import org.apache.cassandra.utils.bytecomparable.ByteComparable;
import org.apache.cassandra.utils.bytecomparable.ByteSource;

import static org.apache.cassandra.utils.bytecomparable.ByteSource.EXCLUDED;
import static org.apache.cassandra.utils.bytecomparable.ByteSource.NEXT_COMPONENT;
import static org.apache.cassandra.utils.bytecomparable.ByteSource.NEXT_COMPONENT_EMPTY;
import static org.apache.cassandra.utils.bytecomparable.ByteSource.NEXT_COMPONENT_EMPTY_REVERSED;
import static org.apache.cassandra.utils.bytecomparable.ByteSource.NEXT_COMPONENT_NULL;
import static org.apache.cassandra.utils.bytecomparable.ByteSource.TERMINATOR;

/**
 * A comparator of clustering prefixes (or more generally of {@link Clusterable}}.
 * &lt;p&gt;
 * This is essentially just a composite comparator that the clustering values of the provided
 * clustering prefixes in lexicographical order, with each component being compared based on
 * the type of the clustering column this is a value of.
 */
<span class="fc" id="L52">public class ClusteringComparator implements Comparator&lt;Clusterable&gt;</span>
{
    private final List&lt;AbstractType&lt;?&gt;&gt; clusteringTypes;

    private final Comparator&lt;IndexInfo&gt; indexComparator;
    private final Comparator&lt;IndexInfo&gt; indexReverseComparator;
    private final Comparator&lt;Clusterable&gt; reverseComparator;

<span class="pc" id="L60">    private final Comparator&lt;Row&gt; rowComparator = (r1, r2) -&gt; compare((ClusteringPrefix&lt;?&gt;) r1.clustering(),</span>
<span class="nc" id="L61">                                                                      (ClusteringPrefix&lt;?&gt;) r2.clustering());</span>

    public ClusteringComparator(AbstractType&lt;?&gt;... clusteringTypes)
    {
<span class="nc" id="L65">        this(ImmutableList.copyOf(clusteringTypes));</span>
<span class="nc" id="L66">    }</span>

    public ClusteringComparator(Iterable&lt;AbstractType&lt;?&gt;&gt; clusteringTypes)
<span class="fc" id="L69">    {</span>
        // copy the list to ensure despatch is monomorphic
<span class="fc" id="L71">        this.clusteringTypes = ImmutableList.copyOf(clusteringTypes);</span>

<span class="fc" id="L73">        this.indexComparator = (o1, o2) -&gt; ClusteringComparator.this.compare((ClusteringPrefix&lt;?&gt;) o1.lastName,</span>
                                                                             (ClusteringPrefix&lt;?&gt;) o2.lastName);
<span class="pc" id="L75">        this.indexReverseComparator = (o1, o2) -&gt; ClusteringComparator.this.compare((ClusteringPrefix&lt;?&gt;) o1.firstName,</span>
                                                                                    (ClusteringPrefix&lt;?&gt;) o2.firstName);
<span class="fc" id="L77">        this.reverseComparator = (c1, c2) -&gt; ClusteringComparator.this.compare(c2, c1);</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">        for (AbstractType&lt;?&gt; type : clusteringTypes)</span>
<span class="fc" id="L79">            type.checkComparable(); // this should already be enforced by TableMetadata.Builder.addColumn, but we check again for other constructors</span>
<span class="fc" id="L80">    }</span>

    /**
     * The number of clustering columns for the table this is the comparator of.
     */
    public int size()
    {
<span class="fc" id="L87">        return clusteringTypes.size();</span>
    }

    /**
     * The &quot;subtypes&quot; of this clustering comparator, that is the types of the clustering
     * columns for the table this is a comparator of.
     */
    public List&lt;AbstractType&lt;?&gt;&gt; subtypes()
    {
<span class="fc" id="L96">        return clusteringTypes;</span>
    }

    /**
     * Returns the type of the ith clustering column of the table.
     */
    public AbstractType&lt;?&gt; subtype(int i)
    {
<span class="fc" id="L104">        return clusteringTypes.get(i);</span>
    }

    /**
     * Creates a row clustering based on the clustering values.
     * &lt;p&gt;
     * Every argument can either be a {@code ByteBuffer}, in which case it is used as-is, or a object
     * corresponding to the type of the corresponding clustering column, in which case it will be
     * converted to a byte buffer using the column type.
     *
     * @param values the values to use for the created clustering. There should be exactly {@code size()}
     * values which must be either byte buffers or of the type the column expect.
     *
     * @return the newly created clustering.
     */
    public Clustering&lt;?&gt; make(Object... values)
    {
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">        if (values.length != size())</span>
<span class="nc" id="L122">            throw new IllegalArgumentException(String.format(&quot;Invalid number of components, expecting %d but got %d&quot;, size(), values.length));</span>

<span class="fc" id="L124">        CBuilder builder = CBuilder.create(this);</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">        for (Object val : values)</span>
        {
<span class="fc bfc" id="L127" title="All 2 branches covered.">            if (val instanceof ByteBuffer)</span>
<span class="fc" id="L128">                builder.add((ByteBuffer) val);</span>
            else
<span class="fc" id="L130">                builder.add(val);</span>
        }
<span class="fc" id="L132">        return builder.build();</span>
    }

    public int compare(Clusterable c1, Clusterable c2)
    {
<span class="fc" id="L137">        return compare((ClusteringPrefix&lt;?&gt;) c1.clustering(), (ClusteringPrefix&lt;?&gt;) c2.clustering());</span>
    }

    public &lt;V1, V2&gt; int compare(ClusteringPrefix&lt;V1&gt; c1, ClusteringPrefix&lt;V2&gt; c2)
    {
<span class="fc" id="L142">        int s1 = c1.size();</span>
<span class="fc" id="L143">        int s2 = c2.size();</span>
<span class="fc" id="L144">        int minSize = Math.min(s1, s2);</span>

<span class="fc bfc" id="L146" title="All 2 branches covered.">        for (int i = 0; i &lt; minSize; i++)</span>
        {
<span class="fc" id="L148">            int cmp = compareComponent(i, c1.get(i), c1.accessor(), c2.get(i), c2.accessor());</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">            if (cmp != 0)</span>
<span class="fc" id="L150">                return cmp;</span>
        }

<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (s1 == s2)</span>
<span class="fc" id="L154">            return ClusteringPrefix.Kind.compare(c1.kind(), c2.kind());</span>

<span class="fc bfc" id="L156" title="All 2 branches covered.">        return s1 &lt; s2 ? c1.kind().comparedToClustering : -c2.kind().comparedToClustering;</span>
    }

    public &lt;V1, V2&gt; int compare(Clustering&lt;V1&gt; c1, Clustering&lt;V2&gt; c2)
    {
<span class="fc" id="L161">        return compare(c1, c2, size());</span>
    }

    /**
     * Compares the specified part of the specified clusterings.
     *
     * @param c1 the first clustering
     * @param c2 the second clustering
     * @param size the number of components to compare
     * @return a negative integer, zero, or a positive integer as the first argument is less than,
     * equal to, or greater than the second.
     */
    public &lt;V1, V2&gt; int compare(Clustering&lt;V1&gt; c1, Clustering&lt;V2&gt; c2, int size)
    {
<span class="fc bfc" id="L175" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="fc" id="L177">            int cmp = compareComponent(i, c1.get(i), c1.accessor(), c2.get(i), c2.accessor());</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">            if (cmp != 0)</span>
<span class="fc" id="L179">                return cmp;</span>
        }
<span class="fc" id="L181">        return 0;</span>
    }

    public &lt;V1, V2&gt; int compareComponent(int i, V1 v1, ValueAccessor&lt;V1&gt; accessor1, V2 v2, ValueAccessor&lt;V2&gt; accessor2)
    {
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        if (v1 == null)</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">            return v2 == null ? 0 : -1;</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">        if (v2 == null)</span>
<span class="nc" id="L189">            return 1;</span>

<span class="fc" id="L191">        return clusteringTypes.get(i).compare(v1, accessor1, v2, accessor2);</span>
    }

    public &lt;V1, V2&gt; int compareComponent(int i, ClusteringPrefix&lt;V1&gt; v1, ClusteringPrefix&lt;V2&gt; v2)
    {
<span class="nc" id="L196">        return compareComponent(i, v1.get(i), v1.accessor(), v2.get(i), v2.accessor());</span>
    }

    /**
     * Returns whether this clustering comparator is compatible with the provided one,
     * that is if the provided one can be safely replaced by this new one.
     *
     * @param previous the previous comparator that we want to replace and test
     * compatibility with.
     *
     * @return whether {@code previous} can be safely replaced by this comparator.
     */
    public boolean isCompatibleWith(ClusteringComparator previous)
    {
<span class="nc bnc" id="L210" title="All 2 branches missed.">        if (this == previous)</span>
<span class="nc" id="L211">            return true;</span>

        // Extending with new components is fine, shrinking is not
<span class="nc bnc" id="L214" title="All 2 branches missed.">        if (size() &lt; previous.size())</span>
<span class="nc" id="L215">            return false;</span>

<span class="nc bnc" id="L217" title="All 2 branches missed.">        for (int i = 0; i &lt; previous.size(); i++)</span>
        {
<span class="nc" id="L219">            AbstractType&lt;?&gt; tprev = previous.subtype(i);</span>
<span class="nc" id="L220">            AbstractType&lt;?&gt; tnew = subtype(i);</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">            if (!tnew.isCompatibleWith(tprev))</span>
<span class="nc" id="L222">                return false;</span>
        }
<span class="nc" id="L224">        return true;</span>
    }

    /**
     * Validates the provided prefix for corrupted data.
     *
     * @param clustering the clustering prefix to validate.
     *
     * @throws MarshalException if {@code clustering} contains some invalid data.
     */
    public &lt;T&gt; void validate(ClusteringPrefix&lt;T&gt; clustering)
    {
<span class="fc" id="L236">        ValueAccessor&lt;T&gt; accessor = clustering.accessor();</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">        for (int i = 0; i &lt; clustering.size(); i++)</span>
        {
<span class="fc" id="L239">            T value = clustering.get(i);</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">            if (value != null)</span>
<span class="fc" id="L241">                subtype(i).validate(value, accessor);</span>
        }
<span class="fc" id="L243">    }</span>

    /**
     * Produce a prefix-free byte-comparable representation of the given value, i.e. such a sequence of bytes that any
     * pair x, y of valid values of this type
     *   compare(x, y) == compareLexicographicallyUnsigned(asByteComparable(x), asByteComparable(y))
     * and
     *   asByteComparable(x) is not a prefix of asByteComparable(y)
     */
    public &lt;V&gt; ByteComparable asByteComparable(ClusteringPrefix&lt;V&gt; clustering)
    {
<span class="fc" id="L254">        return new ByteComparableClustering&lt;&gt;(clustering);</span>
    }

    /**
     * A prefix-free byte-comparable representation for a clustering or prefix.
     *
     * Adds a NEXT_COMPONENT byte before each component (allowing inclusive/exclusive bounds over incomplete prefixes
     * of that length) and finishes with a suitable byte for the clustering kind. Also deals with null entries.
     *
     * Since all types' encodings are weakly prefix-free, this is guaranteed to be prefix-free as long as the
     * bound/ClusteringPrefix terminators are different from the separator byte. It is okay for the terminator for
     * Clustering to be the same as the separator, as all Clusterings must be completely specified.
     *
     * See also {@link AbstractType#asComparableBytes}.
     *
     * Some examples:
     *    &quot;A&quot;, 0005, Clustering     -&gt; 40 4100 40 0005 40
     *    &quot;B&quot;, 0006, InclusiveEnd   -&gt; 40 4200 40 0006 60
     *    &quot;A&quot;, ExclusiveStart       -&gt; 40 4100 60
     *    &quot;&quot;, null, Clustering      -&gt; 40 00 3F 40
     *    &quot;&quot;, 0000, Clustering      -&gt; 40 00 40 0000 40
     *    BOTTOM                    -&gt; 20
     */
    private class ByteComparableClustering&lt;V&gt; implements ByteComparable
    {
        private final ClusteringPrefix&lt;V&gt; src;

        ByteComparableClustering(ClusteringPrefix&lt;V&gt; src)
<span class="fc" id="L282">        {</span>
<span class="fc" id="L283">            this.src = src;</span>
<span class="fc" id="L284">        }</span>

        @Override
        public ByteSource asComparableBytes(Version version)
        {
<span class="fc" id="L289">            return new ByteSource()</span>
<span class="fc" id="L290">            {</span>
<span class="fc" id="L291">                private ByteSource current = null;</span>
<span class="fc" id="L292">                private int srcnum = -1;</span>

                @Override
                public int next()
                {
<span class="fc bfc" id="L297" title="All 2 branches covered.">                    if (current != null)</span>
                    {
<span class="fc" id="L299">                        int b = current.next();</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">                        if (b &gt; END_OF_STREAM)</span>
<span class="fc" id="L301">                            return b;</span>
<span class="fc" id="L302">                        current = null;</span>
                    }

<span class="fc" id="L305">                    int sz = src.size();</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">                    if (srcnum == sz)</span>
<span class="fc" id="L307">                        return END_OF_STREAM;</span>

<span class="fc" id="L309">                    ++srcnum;</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">                    if (srcnum == sz)</span>
<span class="fc" id="L311">                        return src.kind().asByteComparableValue(version);</span>

<span class="fc" id="L313">                    final V nextComponent = src.get(srcnum);</span>
                    // We can have a null as the clustering component (this is a relic of COMPACT STORAGE, but also
                    // can appear in indexed partitions with no rows but static content),
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">                    if (nextComponent == null)</span>
                    {
<span class="nc bnc" id="L318" title="All 2 branches missed.">                        if (version != Version.LEGACY)</span>
<span class="nc" id="L319">                            return NEXT_COMPONENT_NULL; // always sorts before non-nulls, including for reversed types</span>
                        else
                        {
                            // legacy version did not permit nulls in clustering keys and treated these as null values
<span class="nc bnc" id="L323" title="All 2 branches missed.">                            return subtype(srcnum).isReversed() ? NEXT_COMPONENT_EMPTY_REVERSED : NEXT_COMPONENT_EMPTY;</span>
                        }
                    }

<span class="fc" id="L327">                    current = subtype(srcnum).asComparableBytes(src.accessor(), nextComponent, version);</span>
                    // and also null values for some types (e.g. int, varint but not text) that are encoded as empty
                    // buffers.
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">                    if (current == null)</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">                        return subtype(srcnum).isReversed() ? NEXT_COMPONENT_EMPTY_REVERSED : NEXT_COMPONENT_EMPTY;</span>

<span class="fc" id="L333">                    return NEXT_COMPONENT;</span>
                }
            };
        }

        public String toString()
        {
<span class="nc" id="L340">            return src.clusteringString(subtypes());</span>
        }
    }

    /**
     * Produces a clustering from the given byte-comparable value. The method will throw an exception if the value
     * does not correctly encode a clustering of this type, including if it encodes a position before or after a
     * clustering (i.e. a bound/boundary).
     *
     * @param accessor Accessor to use to construct components.
     * @param comparable The clustering encoded as a byte-comparable sequence.
     */
    public &lt;V&gt; Clustering&lt;V&gt; clusteringFromByteComparable(ValueAccessor&lt;V&gt; accessor, ByteComparable comparable)
    {
<span class="fc" id="L354">        ByteComparable.Version version = ByteComparable.Version.OSS50;</span>
<span class="fc" id="L355">        ByteSource.Peekable orderedBytes = ByteSource.peekable(comparable.asComparableBytes(version));</span>
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">        if (orderedBytes == null)</span>
<span class="nc" id="L357">            return null;</span>

        // First check for special cases (partition key only, static clustering) that can do without buffers.
<span class="fc" id="L360">        int sep = orderedBytes.next();</span>
<span class="pc bpc" id="L361" title="2 of 3 branches missed.">        switch (sep)</span>
        {
        case TERMINATOR:
<span class="nc bnc" id="L364" title="All 2 branches missed.">            assert size() == 0 : &quot;Terminator should be after &quot; + size() + &quot; components, got 0&quot;;</span>
<span class="nc" id="L365">            return accessor.factory().clustering();</span>
        case EXCLUDED:
<span class="nc" id="L367">            return accessor.factory().staticClustering();</span>
        default:
            // continue with processing
        }

<span class="fc" id="L372">        int cc = 0;</span>
<span class="fc" id="L373">        V[] components = accessor.createArray(size());</span>

        while (true)
        {
<span class="pc bpc" id="L377" title="4 of 6 branches missed.">            switch (sep)</span>
            {
            case NEXT_COMPONENT_NULL:
<span class="nc" id="L380">                components[cc] = null;</span>
<span class="nc" id="L381">                break;</span>
            case NEXT_COMPONENT_EMPTY:
            case NEXT_COMPONENT_EMPTY_REVERSED:
<span class="nc" id="L384">                components[cc] = subtype(cc).fromComparableBytes(accessor, null, version);</span>
<span class="nc" id="L385">                break;</span>
            case NEXT_COMPONENT:
                // Decode the next component, consuming bytes from orderedBytes.
<span class="fc" id="L388">                components[cc] = subtype(cc).fromComparableBytes(accessor, orderedBytes, version);</span>
<span class="fc" id="L389">                break;</span>
            case TERMINATOR:
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">                assert cc == size() : &quot;Terminator should be after &quot; + size() + &quot; components, got &quot; + cc;</span>
<span class="fc" id="L392">                return accessor.factory().clustering(components);</span>
            case EXCLUDED:
<span class="nc" id="L394">                throw new AssertionError(&quot;Unexpected static terminator after the first component&quot;);</span>
            default:
<span class="nc" id="L396">                throw new AssertionError(&quot;Unexpected separator &quot; + Integer.toHexString(sep) + &quot; in Clustering encoding&quot;);</span>
            }
<span class="fc" id="L398">            ++cc;</span>
<span class="fc" id="L399">            sep = orderedBytes.next();</span>
        }
    }

    /**
     * Produces a clustering bound from the given byte-comparable value. The method will throw an exception if the value
     * does not correctly encode a bound position of this type, including if it encodes an exact clustering.
     *
     * Note that the encoded clustering position cannot specify the type of bound (i.e. start/end/boundary) because to
     * correctly compare clustering positions the encoding must be the same for the different types (e.g. the position
     * for a exclusive end and an inclusive start is the same, before the exact clustering). The type must be supplied
     * separately (in the bound... vs boundary... call and isEnd argument).
     *
     * @param accessor Accessor to use to construct components.
     * @param comparable The clustering position encoded as a byte-comparable sequence.
     * @param isEnd true if the bound marks the end of a range, false is it marks the start.
     */
    public &lt;V&gt; ClusteringBound&lt;V&gt; boundFromByteComparable(ValueAccessor&lt;V&gt; accessor,
                                                          ByteComparable comparable,
                                                          boolean isEnd)
    {
<span class="nc" id="L420">        ByteComparable.Version version = ByteComparable.Version.OSS50;</span>
<span class="nc" id="L421">        ByteSource.Peekable orderedBytes = ByteSource.peekable(comparable.asComparableBytes(version));</span>

<span class="nc" id="L423">        int sep = orderedBytes.next();</span>
<span class="nc" id="L424">        int cc = 0;</span>
<span class="nc" id="L425">        V[] components = accessor.createArray(size());</span>

        while (true)
        {
<span class="nc bnc" id="L429" title="All 7 branches missed.">            switch (sep)</span>
            {
            case NEXT_COMPONENT_NULL:
<span class="nc" id="L432">                components[cc] = null;</span>
<span class="nc" id="L433">                break;</span>
            case NEXT_COMPONENT_EMPTY:
            case NEXT_COMPONENT_EMPTY_REVERSED:
<span class="nc" id="L436">                components[cc] = subtype(cc).fromComparableBytes(accessor, null, version);</span>
<span class="nc" id="L437">                break;</span>
            case NEXT_COMPONENT:
                // Decode the next component, consuming bytes from orderedBytes.
<span class="nc" id="L440">                components[cc] = subtype(cc).fromComparableBytes(accessor, orderedBytes, version);</span>
<span class="nc" id="L441">                break;</span>
            case ByteSource.LT_NEXT_COMPONENT:
<span class="nc bnc" id="L443" title="All 2 branches missed.">                return accessor.factory().bound(isEnd ? ClusteringPrefix.Kind.EXCL_END_BOUND</span>
<span class="nc" id="L444">                                                      : ClusteringPrefix.Kind.INCL_START_BOUND,</span>
<span class="nc" id="L445">                                                Arrays.copyOf(components, cc));</span>
            case ByteSource.GT_NEXT_COMPONENT:
<span class="nc bnc" id="L447" title="All 2 branches missed.">                return accessor.factory().bound(isEnd ? ClusteringPrefix.Kind.INCL_END_BOUND</span>
<span class="nc" id="L448">                                                      : ClusteringPrefix.Kind.EXCL_START_BOUND,</span>
<span class="nc" id="L449">                                                Arrays.copyOf(components, cc));</span>

            case ByteSource.LTLT_NEXT_COMPONENT:
            case ByteSource.GTGT_NEXT_COMPONENT:
<span class="nc" id="L453">                throw new AssertionError(&quot;Unexpected sstable lower/upper bound - byte comparable representation of artificial sstable bounds is not supported&quot;);</span>

            default:
<span class="nc" id="L456">                throw new AssertionError(&quot;Unexpected separator &quot; + Integer.toHexString(sep) + &quot; in ClusteringBound encoding&quot;);</span>
            }
<span class="nc" id="L458">            ++cc;</span>
<span class="nc" id="L459">            sep = orderedBytes.next();</span>
        }
    }

    /**
     * Produces a clustering boundary from the given byte-comparable value. The method will throw an exception if the
     * value does not correctly encode a bound position of this type, including if it encodes an exact clustering.
     *
     * Note that the encoded clustering position cannot specify the type of bound (i.e. start/end/boundary) because to
     * correctly compare clustering positions the encoding must be the same for the different types (e.g. the position
     * for a exclusive end and an inclusive start is the same, before the exact clustering). The type must be supplied
     * separately (in the bound... vs boundary... call and isEnd argument).
     *
     * @param accessor Accessor to use to construct components.
     * @param comparable The clustering position encoded as a byte-comparable sequence.
     */
    public &lt;V&gt; ClusteringBoundary&lt;V&gt; boundaryFromByteComparable(ValueAccessor&lt;V&gt; accessor, ByteComparable comparable)
    {
<span class="nc" id="L477">        ByteComparable.Version version = ByteComparable.Version.OSS50;</span>
<span class="nc" id="L478">        ByteSource.Peekable orderedBytes = ByteSource.peekable(comparable.asComparableBytes(version));</span>

<span class="nc" id="L480">        int sep = orderedBytes.next();</span>
<span class="nc" id="L481">        int cc = 0;</span>
<span class="nc" id="L482">        V[] components = accessor.createArray(size());</span>

        while (true)
        {
<span class="nc bnc" id="L486" title="All 6 branches missed.">            switch (sep)</span>
            {
            case NEXT_COMPONENT_NULL:
<span class="nc" id="L489">                components[cc] = null;</span>
<span class="nc" id="L490">                break;</span>
            case NEXT_COMPONENT_EMPTY:
            case NEXT_COMPONENT_EMPTY_REVERSED:
<span class="nc" id="L493">                components[cc] = subtype(cc).fromComparableBytes(accessor, null, version);</span>
<span class="nc" id="L494">                break;</span>
            case NEXT_COMPONENT:
                // Decode the next component, consuming bytes from orderedBytes.
<span class="nc" id="L497">                components[cc] = subtype(cc).fromComparableBytes(accessor, orderedBytes, version);</span>
<span class="nc" id="L498">                break;</span>
            case ByteSource.LT_NEXT_COMPONENT:
<span class="nc" id="L500">                return accessor.factory().boundary(ClusteringPrefix.Kind.EXCL_END_INCL_START_BOUNDARY,</span>
<span class="nc" id="L501">                                                   Arrays.copyOf(components, cc));</span>
            case ByteSource.GT_NEXT_COMPONENT:
<span class="nc" id="L503">                return accessor.factory().boundary(ClusteringPrefix.Kind.INCL_END_EXCL_START_BOUNDARY,</span>
<span class="nc" id="L504">                                                   Arrays.copyOf(components, cc));</span>
            default:
<span class="nc" id="L506">                throw new AssertionError(&quot;Unexpected separator &quot; + Integer.toHexString(sep) + &quot; in ClusteringBoundary encoding&quot;);</span>
            }
<span class="nc" id="L508">            ++cc;</span>
<span class="nc" id="L509">            sep = orderedBytes.next();</span>
        }
    }

    /**
     * A comparator for rows.
     *
     * A {@code Row} is a {@code Clusterable} so {@code ClusteringComparator} can be used
     * to compare rows directly, but when we know we deal with rows (and not {@code Clusterable} in
     * general), this is a little faster because by knowing we compare {@code Clustering} objects,
     * we know that 1) they all have the same size and 2) they all have the same kind.
     */
    public Comparator&lt;Row&gt; rowComparator()
    {
<span class="nc" id="L523">        return rowComparator;</span>
    }

    public Comparator&lt;IndexInfo&gt; indexComparator(boolean reversed)
    {
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">        return reversed ? indexReverseComparator : indexComparator;</span>
    }

    public Comparator&lt;Clusterable&gt; reversed()
    {
<span class="fc" id="L533">        return reverseComparator;</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L539">        return String.format(&quot;comparator(%s)&quot;, Joiner.on(&quot;, &quot;).join(clusteringTypes));</span>
    }

    @Override
    public boolean equals(Object o)
    {
<span class="nc bnc" id="L545" title="All 2 branches missed.">        if (this == o)</span>
<span class="nc" id="L546">            return true;</span>

<span class="nc bnc" id="L548" title="All 2 branches missed.">        if (!(o instanceof ClusteringComparator))</span>
<span class="nc" id="L549">            return false;</span>

<span class="nc" id="L551">        ClusteringComparator that = (ClusteringComparator)o;</span>
<span class="nc" id="L552">        return this.clusteringTypes.equals(that.clusteringTypes);</span>
    }

    @Override
    public int hashCode()
    {
<span class="fc" id="L558">        return Objects.hashCode(clusteringTypes);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>