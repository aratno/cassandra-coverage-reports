<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UnfilteredRowIterators.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.rows</a> &gt; <span class="el_source">UnfilteredRowIterators.java</span></div><h1>UnfilteredRowIterators.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.rows;

import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.db.Columns;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.DeletionTime;
import org.apache.cassandra.db.Digest;
import org.apache.cassandra.db.EmptyIterators;
import org.apache.cassandra.db.RegularAndStaticColumns;
import org.apache.cassandra.db.filter.ColumnFilter;
import org.apache.cassandra.db.transform.FilteredRows;
import org.apache.cassandra.db.transform.MoreRows;
import org.apache.cassandra.db.transform.Transformation;
import org.apache.cassandra.io.sstable.CorruptSSTableException;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.serializers.MarshalException;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.IMergeIterator;
import org.apache.cassandra.utils.MergeIterator;

/**
 * Static methods to work with atom iterators.
 */
public abstract class UnfilteredRowIterators
{
<span class="fc" id="L48">    private static final Logger logger = LoggerFactory.getLogger(UnfilteredRowIterators.class);</span>

    private UnfilteredRowIterators() {}

    /**
     * Interface for a listener interested in the result of merging multiple versions of a given row.
     * &lt;p&gt;
     * Implementors of this interface are given enough information that they can easily reconstruct the difference
     * between the merged result and each individual input. This is used when reconciling results on replias for
     * instance to figure out what to send as read-repair to each source.
     */
    public interface MergeListener
    {
        /**
         * Called once for the merged partition.
         *
         * @param mergedDeletion the partition level deletion for the merged partition. Implementors can test if the
         * merged partition actually has a partition level deletion or not by calling {@code mergedDeletion.isLive()}.
         * @param versions the partition level deletion for the sources of the merge. Elements of the array will never
         * be null, but be &quot;live&quot;.
         **/
        public void onMergedPartitionLevelDeletion(DeletionTime mergedDeletion, DeletionTime[] versions);

        /**
         * Called once for every row participating in the merge.
         * &lt;p&gt;
         * Note that this is called for every clustering where at least one of the source merged has a row. In
         * particular, this may be called in cases where there is no row in the merged output (if a source has a row
         * that is shadowed by another source range tombstone or partition level deletion).
         *
         * @param merged the result of the merge. This cannot be {@code null} (so that listener can always access the
         * clustering from this safely)but can be empty, in which case this is a placeholder for when at least one
         * source has a row, but that row is shadowed in the merged output.
         * @param versions for each source, the row in that source corresponding to {@code merged}. This can be
         * {@code null} for some sources if the source has not such row.
         * @return the row to use as result of the merge (can be {@code null}). Most implementations should simply
         * return {@code merged}, but this allows some implementations to impact the merge result if necessary. If this
         * returns either {@code null} or an empty row, then the row is skipped from the merge result. If this returns a
         * non {@code null} result, then the returned row &lt;b&gt;must&lt;/b&gt; have the same clustering than {@code merged}.
         */
        public Row onMergedRows(Row merged, Row[] versions);

        /**
         * Called once for every range tombstone marker participating in the merge.
         * &lt;p&gt;
         * Note that this is called for every &quot;clustering position&quot; where at least one of the source merged has a range
         * tombstone marker.
         *
         * @param merged the marker in the merged output. This can be {@code null} if there is no such marker, which
         * means that at least one source has a marker in {@code versions} but the merged out has nothing corresponding
         * (this basically mean the merged output has a currently open deletion that shadows whatever marker the source
         * had).
         * @param versions the marker for each source merged. This can be {@code null} for some source if that source
         * has not such marker.
         */
        public void onMergedRangeTombstoneMarkers(RangeTombstoneMarker merged, RangeTombstoneMarker[] versions);

        public void close();

<span class="fc" id="L107">        public static MergeListener NOOP = new MergeListener()</span>
<span class="fc" id="L108">        {</span>
<span class="fc" id="L109">            public void onMergedPartitionLevelDeletion(DeletionTime mergedDeletion, DeletionTime[] versions) {}</span>

<span class="fc" id="L111">            public Row onMergedRows(Row merged, Row[] versions) {return merged;}</span>

<span class="fc" id="L113">            public void onMergedRangeTombstoneMarkers(RangeTombstoneMarker merged, RangeTombstoneMarker[] versions) {}</span>

<span class="fc" id="L115">            public void close() {}</span>
        };
    }

    /**
     * Returns a iterator that only returns rows with only live content.
     *
     * This is mainly used in the CQL layer when we know we don't care about deletion
     * infos (and since an UnfilteredRowIterator cannot shadow it's own data, we know everyting
     * returned isn't shadowed by a tombstone).
     */
    public static RowIterator filter(UnfilteredRowIterator iter, long nowInSec)
    {
<span class="fc" id="L128">        return FilteredRows.filter(iter, nowInSec);</span>
    }

    /**
     * Returns an iterator that is the result of merging other iterators.
     */
    public static UnfilteredRowIterator merge(List&lt;UnfilteredRowIterator&gt; iterators)
    {
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">        assert !iterators.isEmpty();</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">        if (iterators.size() == 1)</span>
<span class="fc" id="L138">            return iterators.get(0);</span>

<span class="fc" id="L140">        return UnfilteredRowMergeIterator.create(iterators, null);</span>
    }

    /**
     * Returns an iterator that is the result of merging other iterators, and (optionally) using
     * specific MergeListener.
     *
     * Note that this method assumes that there is at least 2 iterators to merge.
     */
    public static UnfilteredRowIterator merge(List&lt;UnfilteredRowIterator&gt; iterators, MergeListener mergeListener)
    {
<span class="fc" id="L151">        return UnfilteredRowMergeIterator.create(iterators, mergeListener);</span>
    }

    /**
     * Returns an empty unfiltered iterator for a given partition.
     */
    public static UnfilteredRowIterator noRowsIterator(final TableMetadata metadata, final DecoratedKey partitionKey, final Row staticRow, final DeletionTime partitionDeletion, final boolean isReverseOrder)
    {
<span class="fc" id="L159">        return EmptyIterators.unfilteredRow(metadata, partitionKey, isReverseOrder, staticRow, partitionDeletion);</span>
    }

    public static UnfilteredRowIterator singleton(Unfiltered unfiltered,
                                                  TableMetadata metadata,
                                                  DecoratedKey partitionKey,
                                                  DeletionTime partitionLevelDeletion,
                                                  RegularAndStaticColumns columns,
                                                  Row staticRow,
                                                  boolean isReverseOrder,
                                                  EncodingStats encodingStats)
    {
<span class="fc" id="L171">        return new AbstractUnfilteredRowIterator(metadata, partitionKey, partitionLevelDeletion, columns, staticRow, isReverseOrder, encodingStats)</span>
<span class="fc" id="L172">        {</span>
<span class="fc" id="L173">            boolean isDone = false;</span>

            protected Unfiltered computeNext()
            {
<span class="fc bfc" id="L177" title="All 2 branches covered.">                if (!isDone)</span>
                {
<span class="fc" id="L179">                    isDone = true;</span>
<span class="fc" id="L180">                    return unfiltered;</span>
                }

<span class="fc" id="L183">                return endOfData();</span>
            }
        };
    }

    /**
     * Digests the partition represented by the provided iterator.
     *
     * @param iterator the iterator to digest.
     * @param digest the {@link Digest} to use.
     * @param version the messaging protocol to use when producing the digest.
     */
    public static void digest(UnfilteredRowIterator iterator, Digest digest, int version)
    {
<span class="fc" id="L197">        digest.update(iterator.partitionKey().getKey());</span>
<span class="fc" id="L198">        iterator.partitionLevelDeletion().digest(digest);</span>
<span class="fc" id="L199">        iterator.columns().regulars.digest(digest);</span>
        // When serializing an iterator, we skip the static columns if the iterator has not static row, even if the
        // columns() object itself has some (the columns() is a superset of what the iterator actually contains, and
        // will correspond to the queried columns pre-serialization). So we must avoid taking the satic column names
        // into account if there is no static row or we'd have a digest mismatch between depending on whether the digest
        // is computed on an iterator that has been serialized or not (see CASSANDRA-12090)
        // TODO: in practice we could completely skip digesting the columns since they are more informative of what the
        // iterator may contain, and digesting the actual content is enough. And in fact, that would be more correct
        // (since again, the columns could be different without the information represented by the iterator being
        // different), but removing them entirely is stricly speaking a breaking change (it would create mismatches on
        // upgrade) so we can only do on the next protocol version bump.
<span class="fc bfc" id="L210" title="All 2 branches covered.">        if (iterator.staticRow() != Rows.EMPTY_STATIC_ROW)</span>
<span class="fc" id="L211">            iterator.columns().statics.digest(digest);</span>
<span class="fc" id="L212">        digest.updateWithBoolean(iterator.isReverseOrder());</span>
<span class="fc" id="L213">        iterator.staticRow().digest(digest);</span>

<span class="fc bfc" id="L215" title="All 2 branches covered.">        while (iterator.hasNext())</span>
        {
<span class="fc" id="L217">            Unfiltered unfiltered = iterator.next();</span>
<span class="fc" id="L218">            unfiltered.digest(digest);</span>
<span class="fc" id="L219">        }</span>
<span class="fc" id="L220">    }</span>

    /**
     * Filter the provided iterator to exclude cells that have been fetched but are not queried by the user
     * (see ColumnFilter for detailes).
     *
     * @param iterator the iterator to filter.
     * @param filter the {@code ColumnFilter} to use when deciding which columns are the one queried by the
     * user. This should be the filter that was used when querying {@code iterator}.
     * @return the filtered iterator..
     */
    public static UnfilteredRowIterator withOnlyQueriedData(UnfilteredRowIterator iterator, ColumnFilter filter)
    {
<span class="fc bfc" id="L233" title="All 2 branches covered.">        if (filter.allFetchedColumnsAreQueried())</span>
<span class="fc" id="L234">            return iterator;</span>

<span class="fc" id="L236">        return Transformation.apply(iterator, new WithOnlyQueriedData(filter));</span>
    }

    /**
     * Returns an iterator that concatenate two atom iterators.
     * This method assumes that both iterator are from the same partition and that the atom from
     * {@code iter2} come after the ones of {@code iter1} (that is, that concatenating the iterator
     * make sense).
     */
    public static UnfilteredRowIterator concat(final UnfilteredRowIterator iter1, final UnfilteredRowIterator iter2)
    {
<span class="nc bnc" id="L247" title="All 2 branches missed.">        assert iter1.metadata().id.equals(iter2.metadata().id)</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">            &amp;&amp; iter1.partitionKey().equals(iter2.partitionKey())</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">            &amp;&amp; iter1.partitionLevelDeletion().equals(iter2.partitionLevelDeletion())</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            &amp;&amp; iter1.isReverseOrder() == iter2.isReverseOrder()</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">            &amp;&amp; iter1.staticRow().equals(iter2.staticRow());</span>

        class Extend implements MoreRows&lt;UnfilteredRowIterator&gt;
        {
            boolean returned = false;
            public UnfilteredRowIterator moreContents()
            {
                if (returned)
                    return null;
                returned = true;
                return iter2;
            }
        }

<span class="nc" id="L265">        return MoreRows.extend(iter1, new Extend(), iter1.columns().mergeTo(iter2.columns()));</span>
    }

    /**
     * Returns an iterator that concatenate the specified atom with the iterator.
     */
    public static UnfilteredRowIterator concat(final Unfiltered first, final UnfilteredRowIterator wrapped)
    {
<span class="nc" id="L273">        return new WrappingUnfilteredRowIterator()</span>
        {
            private boolean hasReturnedFirst;

            @Override
            public UnfilteredRowIterator wrapped()
            {
                return wrapped;
            }

            @Override
            public boolean hasNext()
            {
                return hasReturnedFirst ? wrapped.hasNext() : true;
            }

            @Override
            public Unfiltered next()
            {
                if (!hasReturnedFirst)
                {
                    hasReturnedFirst = true;
                    return first;
                }
                return wrapped.next();
            }
        };
    }

    /**
     * Validate that the data of the provided iterator is valid, that is that the values
     * it contains are valid for the type they represent, and more generally that the
     * infos stored are sensible.
     *
     * This is mainly used by scrubber to detect problems in sstables.
     *
     * @param iterator the partition to check.
     * @param filename the name of the file the data is comming from.
     * @return an iterator that returns the same data than {@code iterator} but that
     * checks said data and throws a {@code CorruptedSSTableException} if it detects
     * invalid data.
     */
    public static UnfilteredRowIterator withValidation(UnfilteredRowIterator iterator, final String filename)
    {
<span class="nc" id="L317">        class Validator extends Transformation</span>
        {
            @Override
            public Row applyToStatic(Row row)
            {
<span class="nc" id="L322">                validate(row);</span>
<span class="nc" id="L323">                return row;</span>
            }

            @Override
            public Row applyToRow(Row row)
            {
<span class="nc" id="L329">                validate(row);</span>
<span class="nc" id="L330">                return row;</span>
            }

            @Override
            public RangeTombstoneMarker applyToMarker(RangeTombstoneMarker marker)
            {
<span class="nc" id="L336">                validate(marker);</span>
<span class="nc" id="L337">                return marker;</span>
            }

            private void validate(Unfiltered unfiltered)
            {
                try
                {
<span class="nc" id="L344">                    unfiltered.validateData(iterator.metadata());</span>
                }
<span class="nc" id="L346">                catch (MarshalException me)</span>
                {
<span class="nc" id="L348">                    throw new CorruptSSTableException(me, filename);</span>
<span class="nc" id="L349">                }</span>
<span class="nc" id="L350">            }</span>
        }
<span class="nc" id="L352">        return Transformation.apply(iterator, new Validator());</span>
    }

    /**
     * Wraps the provided iterator so it logs the returned atoms for debugging purposes.
     * &lt;p&gt;
     * Note that this is only meant for debugging as this can log a very large amount of
     * logging at INFO.
     */
    public static UnfilteredRowIterator loggingIterator(UnfilteredRowIterator iterator, final String id, final boolean fullDetails)
    {
<span class="nc" id="L363">        TableMetadata metadata = iterator.metadata();</span>
<span class="nc" id="L364">        logger.info(&quot;[{}] Logging iterator on {}.{}, partition key={}, reversed={}, deletion={}&quot;,</span>
                    id,
                    metadata.keyspace,
                    metadata.name,
<span class="nc" id="L368">                    metadata.partitionKeyType.getString(iterator.partitionKey().getKey()),</span>
<span class="nc" id="L369">                    iterator.isReverseOrder(),</span>
<span class="nc" id="L370">                    iterator.partitionLevelDeletion().markedForDeleteAt());</span>

<span class="nc" id="L372">        class Logger extends Transformation</span>
        {
            @Override
            public Row applyToStatic(Row row)
            {
<span class="nc bnc" id="L377" title="All 2 branches missed.">                if (!row.isEmpty())</span>
<span class="nc" id="L378">                    logger.info(&quot;[{}] {}&quot;, id, row.toString(metadata, fullDetails));</span>
<span class="nc" id="L379">                return row;</span>
            }

            @Override
            public Row applyToRow(Row row)
            {
<span class="nc" id="L385">                logger.info(&quot;[{}] {}&quot;, id, row.toString(metadata, fullDetails));</span>
<span class="nc" id="L386">                return row;</span>
            }

            @Override
            public RangeTombstoneMarker applyToMarker(RangeTombstoneMarker marker)
            {
<span class="nc" id="L392">                logger.info(&quot;[{}] {}&quot;, id, marker.toString(metadata));</span>
<span class="nc" id="L393">                return marker;</span>
            }
        }
<span class="nc" id="L396">        return Transformation.apply(iterator, new Logger());</span>
    }

    /**
     * A wrapper over MergeIterator to implement the UnfilteredRowIterator interface.
     */
<span class="fc" id="L402">    private static class UnfilteredRowMergeIterator extends AbstractUnfilteredRowIterator</span>
    {
        private final IMergeIterator&lt;Unfiltered, Unfiltered&gt; mergeIterator;
        private final MergeListener listener;

        private UnfilteredRowMergeIterator(TableMetadata metadata,
                                           List&lt;UnfilteredRowIterator&gt; iterators,
                                           RegularAndStaticColumns columns,
                                           DeletionTime partitionDeletion,
                                           boolean reversed,
                                           MergeListener listener)
        {
<span class="fc" id="L414">            super(metadata,</span>
<span class="fc" id="L415">                  iterators.get(0).partitionKey(),</span>
                  partitionDeletion,
                  columns,
<span class="fc" id="L418">                  mergeStaticRows(iterators, columns.statics, listener, partitionDeletion),</span>
                  reversed,
<span class="fc" id="L420">                  EncodingStats.merge(iterators, UnfilteredRowIterator::stats));</span>

<span class="fc" id="L422">            this.mergeIterator = MergeIterator.get(iterators,</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">                                                   reversed ? metadata.comparator.reversed() : metadata.comparator,</span>
<span class="fc" id="L424">                                                   new MergeReducer(iterators.size(), reversed, listener));</span>
<span class="fc" id="L425">            this.listener = listener;</span>
<span class="fc" id="L426">        }</span>

        private static UnfilteredRowMergeIterator create(List&lt;UnfilteredRowIterator&gt; iterators, MergeListener listener)
        {
            try
            {
<span class="fc" id="L432">                checkForInvalidInput(iterators);</span>
<span class="fc" id="L433">                return new UnfilteredRowMergeIterator(iterators.get(0).metadata(),</span>
                                                      iterators,
<span class="fc" id="L435">                                                      collectColumns(iterators),</span>
<span class="fc" id="L436">                                                      collectPartitionLevelDeletion(iterators, listener),</span>
<span class="fc" id="L437">                                                      iterators.get(0).isReverseOrder(),</span>
                                                      listener);
            }
<span class="nc" id="L440">            catch (RuntimeException | Error e)</span>
            {
                try
                {
<span class="nc" id="L444">                    FBUtilities.closeAll(iterators);</span>
                }
<span class="nc" id="L446">                catch (Exception suppressed)</span>
                {
<span class="nc" id="L448">                    e.addSuppressed(suppressed);</span>
<span class="nc" id="L449">                }</span>
<span class="nc" id="L450">                throw e;</span>
            }
        }

        @SuppressWarnings(&quot;resource&quot;) // We're not really creating any resource here
        private static void checkForInvalidInput(List&lt;UnfilteredRowIterator&gt; iterators)
        {
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">            if (iterators.isEmpty())</span>
<span class="nc" id="L458">                return;</span>

<span class="fc" id="L460">            UnfilteredRowIterator first = iterators.get(0);</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">            for (int i = 1; i &lt; iterators.size(); i++)</span>
            {
<span class="fc" id="L463">                UnfilteredRowIterator iter = iterators.get(i);</span>
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">                assert first.metadata().id.equals(iter.metadata().id);</span>
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">                assert first.partitionKey().equals(iter.partitionKey());</span>
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">                assert first.isReverseOrder() == iter.isReverseOrder();</span>
            }
<span class="fc" id="L468">        }</span>

        @SuppressWarnings(&quot;resource&quot;) // We're not really creating any resource here
        private static DeletionTime collectPartitionLevelDeletion(List&lt;UnfilteredRowIterator&gt; iterators, MergeListener listener)
        {
<span class="fc bfc" id="L473" title="All 2 branches covered.">            DeletionTime[] versions = listener == null ? null : new DeletionTime[iterators.size()];</span>

<span class="fc" id="L475">            DeletionTime delTime = DeletionTime.LIVE;</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">            for (int i = 0; i &lt; iterators.size(); i++)</span>
            {
<span class="fc" id="L478">                UnfilteredRowIterator iter = iterators.get(i);</span>
<span class="fc" id="L479">                DeletionTime iterDeletion = iter.partitionLevelDeletion();</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">                if (listener != null)</span>
<span class="fc" id="L481">                    versions[i] = iterDeletion;</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">                if (!delTime.supersedes(iterDeletion))</span>
<span class="fc" id="L483">                    delTime = iterDeletion;</span>
            }
<span class="fc bfc" id="L485" title="All 2 branches covered.">            if (listener != null)</span>
<span class="fc" id="L486">                listener.onMergedPartitionLevelDeletion(delTime, versions);</span>
<span class="fc" id="L487">            return delTime;</span>
        }

        private static Row mergeStaticRows(List&lt;UnfilteredRowIterator&gt; iterators,
                                           Columns columns,
                                           MergeListener listener,
                                           DeletionTime partitionDeletion)
        {
<span class="fc bfc" id="L495" title="All 2 branches covered.">            if (columns.isEmpty())</span>
<span class="fc" id="L496">                return Rows.EMPTY_STATIC_ROW;</span>

<span class="fc bfc" id="L498" title="All 2 branches covered.">            if (iterators.stream().allMatch(iter -&gt; iter.staticRow().isEmpty()))</span>
<span class="fc" id="L499">                return Rows.EMPTY_STATIC_ROW;</span>

<span class="fc" id="L501">            Row.Merger merger = new Row.Merger(iterators.size(), columns.hasComplex());</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">            for (int i = 0; i &lt; iterators.size(); i++)</span>
<span class="fc" id="L503">                merger.add(i, iterators.get(i).staticRow());</span>

<span class="fc" id="L505">            Row merged = merger.merge(partitionDeletion);</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">            if (merged == null)</span>
<span class="fc" id="L507">                merged = Rows.EMPTY_STATIC_ROW;</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">            if (listener == null)</span>
<span class="fc" id="L509">                return merged;</span>

<span class="fc" id="L511">            merged = listener.onMergedRows(merged, merger.mergedRows());</span>
            // Note that onMergedRows can have returned null even though his input wasn't null
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">            return merged == null ? Rows.EMPTY_STATIC_ROW : merged;</span>
        }

        private static RegularAndStaticColumns collectColumns(List&lt;UnfilteredRowIterator&gt; iterators)
        {
<span class="fc" id="L518">            RegularAndStaticColumns first = iterators.get(0).columns();</span>
<span class="fc" id="L519">            Columns statics = first.statics;</span>
<span class="fc" id="L520">            Columns regulars = first.regulars;</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">            for (int i = 1; i &lt; iterators.size(); i++)</span>
            {
<span class="fc" id="L523">                RegularAndStaticColumns cols = iterators.get(i).columns();</span>
<span class="fc" id="L524">                statics = statics.mergeTo(cols.statics);</span>
<span class="fc" id="L525">                regulars = regulars.mergeTo(cols.regulars);</span>
            }
<span class="fc bfc" id="L527" title="All 4 branches covered.">            return statics == first.statics &amp;&amp; regulars == first.regulars</span>
<span class="fc" id="L528">                 ? first</span>
<span class="fc" id="L529">                 : new RegularAndStaticColumns(statics, regulars);</span>
        }

        protected Unfiltered computeNext()
        {
<span class="fc bfc" id="L534" title="All 2 branches covered.">            while (mergeIterator.hasNext())</span>
            {
<span class="fc" id="L536">                Unfiltered merged = mergeIterator.next();</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">                if (merged != null)</span>
<span class="fc" id="L538">                    return merged;</span>
<span class="fc" id="L539">            }</span>
<span class="fc" id="L540">            return endOfData();</span>
        }

        public void close()
        {
            // This will close the input iterators
<span class="fc" id="L546">            FileUtils.closeQuietly(mergeIterator);</span>

<span class="fc bfc" id="L548" title="All 2 branches covered.">            if (listener != null)</span>
<span class="fc" id="L549">                listener.close();</span>
<span class="fc" id="L550">        }</span>

        private class MergeReducer extends MergeIterator.Reducer&lt;Unfiltered, Unfiltered&gt;
        {
            private final MergeListener listener;

            private Unfiltered.Kind nextKind;

            private final Row.Merger rowMerger;
            private final RangeTombstoneMarker.Merger markerMerger;

            private MergeReducer(int size, boolean reversed, MergeListener listener)
<span class="fc" id="L562">            {</span>
<span class="fc" id="L563">                this.rowMerger = new Row.Merger(size, columns().regulars.hasComplex());</span>
<span class="fc" id="L564">                this.markerMerger = new RangeTombstoneMarker.Merger(size, partitionLevelDeletion(), reversed);</span>
<span class="fc" id="L565">                this.listener = listener;</span>
<span class="fc" id="L566">            }</span>

            @Override
            public boolean trivialReduceIsTrivial()
            {
                // If we have a listener, we must signal it even when we have a single version
<span class="fc bfc" id="L572" title="All 2 branches covered.">                return listener == null;</span>
            }

            public void reduce(int idx, Unfiltered current)
            {
<span class="fc" id="L577">                nextKind = current.kind();</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">                if (nextKind == Unfiltered.Kind.ROW)</span>
<span class="fc" id="L579">                    rowMerger.add(idx, (Row)current);</span>
                else
<span class="fc" id="L581">                    markerMerger.add(idx, (RangeTombstoneMarker)current);</span>
<span class="fc" id="L582">            }</span>

            protected Unfiltered getReduced()
            {
<span class="fc bfc" id="L586" title="All 2 branches covered.">                if (nextKind == Unfiltered.Kind.ROW)</span>
                {
<span class="fc" id="L588">                    Row merged = rowMerger.merge(markerMerger.activeDeletion());</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">                    if (listener == null)</span>
<span class="fc" id="L590">                        return merged;</span>

<span class="fc bfc" id="L592" title="All 2 branches covered.">                    merged = listener.onMergedRows(merged == null</span>
<span class="fc" id="L593">                                                   ? BTreeRow.emptyRow(rowMerger.mergedClustering())</span>
<span class="fc" id="L594">                                                   : merged,</span>
<span class="fc" id="L595">                                                   rowMerger.mergedRows());</span>

<span class="fc bfc" id="L597" title="All 4 branches covered.">                    return merged == null || merged.isEmpty() ? null : merged;</span>
                }
                else
                {
<span class="fc" id="L601">                    RangeTombstoneMarker merged = markerMerger.merge();</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">                    if (listener != null)</span>
<span class="fc" id="L603">                        listener.onMergedRangeTombstoneMarkers(merged, markerMerger.mergedMarkers());</span>
<span class="fc" id="L604">                    return merged;</span>
                }
            }

            protected void onKeyChange()
            {
<span class="fc bfc" id="L610" title="All 2 branches covered.">                if (nextKind == Unfiltered.Kind.ROW)</span>
<span class="fc" id="L611">                    rowMerger.clear();</span>
                else
<span class="fc" id="L613">                    markerMerger.clear();</span>
<span class="fc" id="L614">            }</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>