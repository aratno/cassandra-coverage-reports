<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TrieMemoryIndex.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.index.sai.memory</a> &gt; <span class="el_source">TrieMemoryIndex.java</span></div><h1>TrieMemoryIndex.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.index.sai.memory;

import java.nio.ByteBuffer;
import java.util.Iterator;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.SortedSet;
import java.util.concurrent.atomic.LongAdder;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.netty.util.concurrent.FastThreadLocal;
import org.apache.cassandra.db.Clustering;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.PartitionPosition;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.memtable.TrieMemtable;
import org.apache.cassandra.db.tries.InMemoryTrie;
import org.apache.cassandra.db.tries.Trie;
import org.apache.cassandra.dht.AbstractBounds;
import org.apache.cassandra.index.sai.IndexContext;
import org.apache.cassandra.index.sai.analyzer.AbstractAnalyzer;
import org.apache.cassandra.index.sai.plan.Expression;
import org.apache.cassandra.index.sai.utils.PrimaryKey;
import org.apache.cassandra.index.sai.utils.PrimaryKeys;
import org.apache.cassandra.index.sai.iterators.KeyRangeIterator;
import org.apache.cassandra.index.sai.utils.TypeUtil;
import org.apache.cassandra.utils.Pair;
import org.apache.cassandra.utils.bytecomparable.ByteComparable;
import org.apache.cassandra.utils.bytecomparable.ByteSource;
import org.apache.cassandra.utils.bytecomparable.ByteSourceInverse;

/**
 * This is an in-memory index using the {@link InMemoryTrie} to store a {@link ByteComparable}
 * representation of the indexed values. Data is stored on-heap or off-heap and follows the
 * settings of the {@link TrieMemtable} to determine where.
 *
 *
 */
public class TrieMemoryIndex
{
<span class="fc" id="L61">    private static final Logger logger = LoggerFactory.getLogger(TrieMemoryIndex.class);</span>
    private static final int MAX_RECURSIVE_KEY_LENGTH = 128;

    private final IndexContext indexContext;
    private final InMemoryTrie&lt;PrimaryKeys&gt; data;
    private final PrimaryKeysReducer primaryKeysReducer;
    private final AbstractAnalyzer.AnalyzerFactory analyzerFactory;
    private final AbstractType&lt;?&gt; validator;
    private final boolean isLiteral;

    private ByteBuffer minTerm;
    private ByteBuffer maxTerm;

    public TrieMemoryIndex(IndexContext indexContext)
<span class="fc" id="L75">    {</span>
<span class="fc" id="L76">        this.indexContext = indexContext;</span>
<span class="fc" id="L77">        this.data = new InMemoryTrie&lt;&gt;(TrieMemtable.BUFFER_TYPE);</span>
<span class="fc" id="L78">        this.primaryKeysReducer = new PrimaryKeysReducer();</span>
        // The use of the analyzer is within a synchronized block so can be considered thread-safe
<span class="fc" id="L80">        this.analyzerFactory = indexContext.getAnalyzerFactory();</span>
<span class="fc" id="L81">        this.validator = indexContext.getValidator();</span>
<span class="fc" id="L82">        this.isLiteral = TypeUtil.isLiteral(validator);</span>
<span class="fc" id="L83">    }</span>

    /**
     * Adds an index value to the in-memory index
     *
     * @param key partition key for the indexed value
     * @param clustering clustering for the indexed value
     * @param value indexed value
     * @return amount of heap allocated by the new value
     */
    public synchronized long add(DecoratedKey key, Clustering&lt;?&gt; clustering, ByteBuffer value)
    {
<span class="fc" id="L95">        AbstractAnalyzer analyzer = analyzerFactory.create();</span>
        try
        {
<span class="fc" id="L98">            value = TypeUtil.asIndexBytes(value, validator);</span>
<span class="fc" id="L99">            analyzer.reset(value);</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">            final PrimaryKey primaryKey = indexContext.hasClustering() ? indexContext.keyFactory().create(key, clustering)</span>
<span class="fc" id="L101">                                                                       : indexContext.keyFactory().create(key);</span>
<span class="fc" id="L102">            final long initialSizeOnHeap = data.sizeOnHeap();</span>
<span class="fc" id="L103">            final long initialSizeOffHeap = data.sizeOffHeap();</span>
<span class="fc" id="L104">            final long reducerHeapSize = primaryKeysReducer.heapAllocations();</span>

<span class="fc bfc" id="L106" title="All 2 branches covered.">            while (analyzer.hasNext())</span>
            {
<span class="fc" id="L108">                final ByteBuffer term = analyzer.next();</span>

<span class="fc" id="L110">                setMinMaxTerm(term.duplicate());</span>

<span class="fc" id="L112">                final ByteComparable comparableBytes = asComparableBytes(term);</span>

                try
                {
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">                    if (term.limit() &lt;= MAX_RECURSIVE_KEY_LENGTH)</span>
                    {
<span class="fc" id="L118">                        data.putRecursive(comparableBytes, primaryKey, primaryKeysReducer);</span>
                    }
                    else
                    {
<span class="nc" id="L122">                        data.apply(Trie.singleton(comparableBytes, primaryKey), primaryKeysReducer);</span>
                    }
                }
<span class="nc" id="L125">                catch (InMemoryTrie.SpaceExhaustedException e)</span>
                {
<span class="nc" id="L127">                    throw new RuntimeException(e);</span>
<span class="fc" id="L128">                }</span>
<span class="fc" id="L129">            }</span>

<span class="fc" id="L131">            long onHeap = data.sizeOnHeap();</span>
<span class="fc" id="L132">            long offHeap = data.sizeOffHeap();</span>
<span class="fc" id="L133">            long heapAllocations = primaryKeysReducer.heapAllocations();</span>
<span class="fc" id="L134">            return (onHeap - initialSizeOnHeap) + (offHeap - initialSizeOffHeap) + (heapAllocations - reducerHeapSize);</span>
        }
        finally
        {
<span class="fc" id="L138">            analyzer.end();</span>
        }
    }

    /**
     * Search for an expression in the in-memory index within the {@link AbstractBounds} defined
     * by keyRange. This can either be an exact match or a range match.

     * @param expression the {@link Expression} to search for
     * @param keyRange the {@link AbstractBounds} containing the key range to restrict the search to
     * @return a {@link KeyRangeIterator} containing the search results
     */
    public KeyRangeIterator search(Expression expression, AbstractBounds&lt;PartitionPosition&gt; keyRange)
    {
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">        if (logger.isTraceEnabled())</span>
<span class="nc" id="L153">            logger.trace(&quot;Searching memtable index on expression '{}'...&quot;, expression);</span>

<span class="pc bpc" id="L155" title="2 of 3 branches missed.">        switch (expression.getOp())</span>
        {
            case EQ:
            case CONTAINS_KEY:
            case CONTAINS_VALUE:
<span class="fc" id="L160">                return exactMatch(expression, keyRange);</span>
            case RANGE:
<span class="nc" id="L162">                return rangeMatch(expression, keyRange);</span>
            default:
<span class="nc" id="L164">                throw new IllegalArgumentException(&quot;Unsupported expression: &quot; + expression);</span>
        }
    }

    /**
     * Returns an {@link Iterator} over the entire dataset contained in the trie. This is used
     * when the index is flushed to disk.
     *
     * @return the iterator containing the trie data
     */
    public Iterator&lt;Pair&lt;ByteComparable, PrimaryKeys&gt;&gt; iterator()
    {
<span class="fc" id="L176">        Iterator&lt;Map.Entry&lt;ByteComparable, PrimaryKeys&gt;&gt; iterator = data.entrySet().iterator();</span>
<span class="fc" id="L177">        return new Iterator&lt;Pair&lt;ByteComparable, PrimaryKeys&gt;&gt;()</span>
<span class="fc" id="L178">        {</span>
            @Override
            public boolean hasNext()
            {
<span class="fc" id="L182">                return iterator.hasNext();</span>
            }

            @Override
            public Pair&lt;ByteComparable, PrimaryKeys&gt; next()
            {
<span class="fc" id="L188">                Map.Entry&lt;ByteComparable, PrimaryKeys&gt; entry = iterator.next();</span>
<span class="fc" id="L189">                return Pair.create(decode(entry.getKey()), entry.getValue());</span>
            }
        };
    }

    public ByteBuffer getMinTerm()
    {
<span class="fc" id="L196">        return minTerm;</span>
    }

    public ByteBuffer getMaxTerm()
    {
<span class="fc" id="L201">        return maxTerm;</span>
    }

    private void setMinMaxTerm(ByteBuffer term)
    {
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">        assert term != null;</span>

<span class="fc" id="L208">        minTerm = TypeUtil.min(term, minTerm, indexContext.getValidator());</span>
<span class="fc" id="L209">        maxTerm = TypeUtil.max(term, maxTerm, indexContext.getValidator());</span>
<span class="fc" id="L210">    }</span>

    private ByteComparable asComparableBytes(ByteBuffer input)
    {
<span class="fc bfc" id="L214" title="All 2 branches covered.">        return isLiteral ? version -&gt; terminated(ByteSource.of(input, version))</span>
<span class="fc" id="L215">                         : version -&gt; TypeUtil.asComparableBytes(input, validator, version);</span>
    }

    private ByteComparable decode(ByteComparable term)
    {
<span class="fc bfc" id="L220" title="All 2 branches covered.">        return isLiteral ? version -&gt; ByteSourceInverse.unescape(ByteSource.peekable(term.asComparableBytes(version)))</span>
<span class="fc" id="L221">                         : term;</span>
    }

    private ByteSource terminated(ByteSource src)
    {
<span class="fc" id="L226">        return new ByteSource()</span>
<span class="fc" id="L227">        {</span>
<span class="fc" id="L228">            boolean done = false;</span>

            @Override
            public int next()
            {
<span class="fc bfc" id="L233" title="All 2 branches covered.">                if (done)</span>
<span class="fc" id="L234">                    return END_OF_STREAM;</span>
<span class="fc" id="L235">                int n = src.next();</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">                if (n != END_OF_STREAM)</span>
<span class="fc" id="L237">                    return n;</span>

<span class="fc" id="L239">                done = true;</span>
<span class="fc" id="L240">                return ByteSource.TERMINATOR;</span>
            }
        };
    }

    private KeyRangeIterator exactMatch(Expression expression, AbstractBounds&lt;PartitionPosition&gt; keyRange)
    {
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">        ByteComparable comparableMatch = expression.lower == null ? ByteComparable.EMPTY</span>
<span class="fc" id="L248">                                                                  : asComparableBytes(expression.lower.value.encoded);</span>
<span class="fc" id="L249">        PrimaryKeys primaryKeys = data.get(comparableMatch);</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        return primaryKeys == null ? KeyRangeIterator.empty()</span>
<span class="fc" id="L251">                                   : new FilteringInMemoryKeyRangeIterator(primaryKeys.keys(), keyRange);</span>
    }

    private static class Collector
    {
        private static final int MINIMUM_QUEUE_SIZE = 128;

        // Maintain the last queue size used on this index to use for the next range match.
        // This allows for receiving a stream of wide range queries where the queue size
        // is larger than we would want to default the size to.
        // TODO Investigate using a decaying histogram here to avoid the effect of outliers.
        private static final FastThreadLocal&lt;Integer&gt; lastQueueSize = new FastThreadLocal&lt;Integer&gt;()
        {
            protected Integer initialValue()
            {
                return MINIMUM_QUEUE_SIZE;
            }
        };

        PrimaryKey minimumKey = null;
        PrimaryKey maximumKey = null;
        final PriorityQueue&lt;PrimaryKey&gt; mergedKeys = new PriorityQueue&lt;&gt;(lastQueueSize.get());

        final AbstractBounds&lt;PartitionPosition&gt; keyRange;

        public Collector(AbstractBounds&lt;PartitionPosition&gt; keyRange)
        {
            this.keyRange = keyRange;
        }

        public void processContent(PrimaryKeys keys)
        {
            if (keys.isEmpty())
                return;

            SortedSet&lt;PrimaryKey&gt; primaryKeys = keys.keys();

            // shortcut to avoid generating iterator
            if (primaryKeys.size() == 1)
            {
                processKey(primaryKeys.first());
                return;
            }

            // skip entire partition keys if they don't overlap
            if (!keyRange.right.isMinimum() &amp;&amp; primaryKeys.first().partitionKey().compareTo(keyRange.right) &gt; 0
                || primaryKeys.last().partitionKey().compareTo(keyRange.left) &lt; 0)
                return;

            primaryKeys.forEach(this::processKey);
        }

        public void updateLastQueueSize()
        {
            lastQueueSize.set(Math.max(MINIMUM_QUEUE_SIZE, mergedKeys.size()));
        }

        private void processKey(PrimaryKey key)
        {
            if (keyRange.contains(key.partitionKey()))
            {
                mergedKeys.add(key);

                minimumKey = minimumKey == null ? key : key.compareTo(minimumKey) &lt; 0 ? key : minimumKey;
                maximumKey = maximumKey == null ? key : key.compareTo(maximumKey) &gt; 0 ? key : maximumKey;
            }
        }
    }

    private KeyRangeIterator rangeMatch(Expression expression, AbstractBounds&lt;PartitionPosition&gt; keyRange)
    {
        ByteComparable lowerBound, upperBound;
        boolean lowerInclusive, upperInclusive;
<span class="nc bnc" id="L324" title="All 2 branches missed.">        if (expression.lower != null)</span>
        {
<span class="nc" id="L326">            lowerBound = asComparableBytes(expression.lower.value.encoded);</span>
<span class="nc" id="L327">            lowerInclusive = expression.lower.inclusive;</span>
        }
        else
        {
<span class="nc" id="L331">            lowerBound = ByteComparable.EMPTY;</span>
<span class="nc" id="L332">            lowerInclusive = false;</span>
        }

<span class="nc bnc" id="L335" title="All 2 branches missed.">        if (expression.upper != null)</span>
        {
<span class="nc" id="L337">            upperBound = asComparableBytes(expression.upper.value.encoded);</span>
<span class="nc" id="L338">            upperInclusive = expression.upper.inclusive;</span>
        }
        else
        {
<span class="nc" id="L342">            upperBound = null;</span>
<span class="nc" id="L343">            upperInclusive = false;</span>
        }

<span class="nc" id="L346">        Collector cd = new Collector(keyRange);</span>

<span class="nc" id="L348">        data.subtrie(lowerBound, lowerInclusive, upperBound, upperInclusive)</span>
<span class="nc" id="L349">            .values()</span>
<span class="nc" id="L350">            .forEach(cd::processContent);</span>

<span class="nc bnc" id="L352" title="All 2 branches missed.">        if (cd.mergedKeys.isEmpty())</span>
        {
<span class="nc" id="L354">            return KeyRangeIterator.empty();</span>
        }

<span class="nc" id="L357">        cd.updateLastQueueSize();</span>

<span class="nc" id="L359">        return new InMemoryKeyRangeIterator(cd.minimumKey, cd.maximumKey, cd.mergedKeys);</span>
    }

<span class="fc" id="L362">    private static class PrimaryKeysReducer implements InMemoryTrie.UpsertTransformer&lt;PrimaryKeys, PrimaryKey&gt;</span>
    {
<span class="fc" id="L364">        private final LongAdder heapAllocations = new LongAdder();</span>

        @Override
        public PrimaryKeys apply(PrimaryKeys existing, PrimaryKey neww)
        {
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">            if (existing == null)</span>
            {
<span class="fc" id="L371">                existing = new PrimaryKeys();</span>
<span class="fc" id="L372">                heapAllocations.add(existing.unsharedHeapSize());</span>
            }
<span class="fc" id="L374">            heapAllocations.add(existing.add(neww));</span>
<span class="fc" id="L375">            return existing;</span>
        }

        long heapAllocations()
        {
<span class="fc" id="L380">            return heapAllocations.longValue();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>