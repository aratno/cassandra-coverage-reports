<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PaxosRepairHistory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.service.paxos</a> &gt; <span class="el_source">PaxosRepairHistory.java</span></div><h1>PaxosRepairHistory.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.service.paxos;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableList;

import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.TypeSizes;
import org.apache.cassandra.db.marshal.ByteBufferAccessor;
import org.apache.cassandra.db.marshal.BytesType;
import org.apache.cassandra.db.marshal.TupleType;
import org.apache.cassandra.dht.Range;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.io.IVersionedSerializer;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;

import static java.lang.Math.min;
import static org.apache.cassandra.service.paxos.Commit.isAfter;
import static org.apache.cassandra.service.paxos.Commit.latest;

public class PaxosRepairHistory
{
<span class="fc" id="L47">    public static final PaxosRepairHistory EMPTY = new PaxosRepairHistory(new Token[0], new Ballot[] { Ballot.none() });</span>
<span class="fc" id="L48">    private static final Token.TokenFactory TOKEN_FACTORY = DatabaseDescriptor.getPartitioner().getTokenFactory();</span>
<span class="fc" id="L49">    private static final Token MIN_TOKEN = DatabaseDescriptor.getPartitioner().getMinimumToken();</span>
<span class="fc" id="L50">    private static final TupleType TYPE = new TupleType(ImmutableList.of(BytesType.instance, BytesType.instance));</span>

    /**
     * The following two fields represent the mapping of ranges to ballot lower bounds, for example:
     *
     *   ballotLowBound           = [ none(), b2, none(), b4, none() ]
     *   tokenInclusiveUpperBound = [ t1, t2, t3, t4 ]
     *
     * Correspond to the following token bounds:
     *
     *   (MIN_VALUE, t1] =&gt; none()
     *   (t1, t2]        =&gt; b2
     *   (t2, t3]        =&gt; none()
     *   (t3, t4]        =&gt; b4
     *   (t4, MAX_VALUE) =&gt; none()
     */

    private final Token[] tokenInclusiveUpperBound;
    private final Ballot[] ballotLowBound; // always one longer to capture values up to &quot;MAX_VALUE&quot; (which in some cases doesn't exist, as is infinite)

    PaxosRepairHistory(Token[] tokenInclusiveUpperBound, Ballot[] ballotLowBound)
<span class="fc" id="L71">    {</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">        assert ballotLowBound.length == tokenInclusiveUpperBound.length + 1;</span>
<span class="fc" id="L73">        this.tokenInclusiveUpperBound = tokenInclusiveUpperBound;</span>
<span class="fc" id="L74">        this.ballotLowBound = ballotLowBound;</span>
<span class="fc" id="L75">    }</span>

    public Ballot maxLowBound()
    {
<span class="nc" id="L79">        Ballot maxBallot = Ballot.none();</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">        for (Ballot lowBound : ballotLowBound)</span>
        {
<span class="nc" id="L82">            maxBallot = Commit.latest(maxBallot, lowBound);</span>
        }
<span class="nc" id="L84">        return maxBallot;</span>
    }

    public String toString()
    {
<span class="nc" id="L89">        return &quot;PaxosRepairHistory{&quot; +</span>
<span class="nc" id="L90">                IntStream.range(0, ballotLowBound.length)</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">                        .filter(i -&gt; !Ballot.none().equals(ballotLowBound[i]))</span>
<span class="nc" id="L92">                        .mapToObj(i -&gt; range(i) + &quot;=&quot; + ballotLowBound[i])</span>
<span class="nc" id="L93">                        .collect(Collectors.joining(&quot;, &quot;)) + '}';</span>
    }

    public boolean equals(Object o)
    {
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">        if (this == o) return true;</span>
<span class="pc bpc" id="L99" title="2 of 4 branches missed.">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L100">        PaxosRepairHistory that = (PaxosRepairHistory) o;</span>
<span class="pc bpc" id="L101" title="2 of 4 branches missed.">        return Arrays.equals(ballotLowBound, that.ballotLowBound) &amp;&amp; Arrays.equals(tokenInclusiveUpperBound, that.tokenInclusiveUpperBound);</span>
    }

    public int hashCode()
    {
<span class="nc" id="L106">        return Arrays.hashCode(ballotLowBound);</span>
    }

    public Ballot ballotForToken(Token token)
    {
<span class="fc" id="L111">        int idx = Arrays.binarySearch(tokenInclusiveUpperBound, token);</span>
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">        if (idx &lt; 0) idx = -1 - idx;</span>
<span class="fc" id="L113">        return ballotLowBound[idx];</span>
    }

    private Ballot ballotForIndex(int idx)
    {
<span class="pc bpc" id="L118" title="2 of 4 branches missed.">        if (idx &lt; 0 || idx &gt; size())</span>
<span class="nc" id="L119">            throw new IndexOutOfBoundsException();</span>

<span class="fc" id="L121">        return ballotLowBound[idx];</span>
    }

    private int indexForToken(Token token)
    {
<span class="fc" id="L126">        int idx = Arrays.binarySearch(tokenInclusiveUpperBound, token);</span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        if (idx &lt; 0) idx = -1 - idx;</span>
<span class="fc" id="L128">        return idx;</span>
    }

    private boolean contains(int idx, Token token)
    {
<span class="pc bpc" id="L133" title="2 of 4 branches missed.">        if (idx &lt; 0 || idx &gt; size())</span>
<span class="nc" id="L134">            throw new IndexOutOfBoundsException();</span>

<span class="pc bpc" id="L136" title="3 of 4 branches missed.">        return  (idx == 0      || tokenInclusiveUpperBound[idx - 1].compareTo(token) &lt;  0)</span>
<span class="pc bpc" id="L137" title="3 of 4 branches missed.">             &amp;&amp; (idx == size() || tokenInclusiveUpperBound[idx    ].compareTo(token) &gt;= 0);</span>
    }

    public int size()
    {
<span class="fc" id="L142">        return tokenInclusiveUpperBound.length;</span>
    }

    private RangeIterator rangeIterator()
    {
<span class="fc" id="L147">        return new RangeIterator();</span>
    }

    private Range&lt;Token&gt; range(int i)
    {
<span class="nc" id="L152">        return new Range&lt;&gt;(tokenExclusiveLowerBound(i), tokenInclusiveUpperBound(i));</span>
    }

    public Searcher searcher()
    {
<span class="fc" id="L157">        return new Searcher();</span>
    }

    private Token tokenExclusiveLowerBound(int i)
    {
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">        return i == 0 ? MIN_TOKEN : tokenInclusiveUpperBound[i - 1];</span>
    }

    private Token tokenInclusiveUpperBound(int i)
    {
<span class="fc bfc" id="L167" title="All 2 branches covered.">        return i == tokenInclusiveUpperBound.length ? MIN_TOKEN : tokenInclusiveUpperBound[i];</span>
    }

    public List&lt;ByteBuffer&gt; toTupleBufferList()
    {
<span class="fc" id="L172">        List&lt;ByteBuffer&gt; tuples = new ArrayList&lt;&gt;(size() + 1);</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">        for (int i = 0 ; i &lt; 1 + size() ; ++i)</span>
<span class="fc" id="L174">            tuples.add(TupleType.buildValue(new ByteBuffer[] { TOKEN_FACTORY.toByteArray(tokenInclusiveUpperBound(i)), ballotLowBound[i].toBytes() }));</span>
<span class="fc" id="L175">        return tuples;</span>
    }

    public static PaxosRepairHistory fromTupleBufferList(List&lt;ByteBuffer&gt; tuples)
    {
<span class="fc" id="L180">        Token[] tokenInclusiveUpperBounds = new Token[tuples.size() - 1];</span>
<span class="fc" id="L181">        Ballot[] ballotLowBounds = new Ballot[tuples.size()];</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">        for (int i = 0 ; i &lt; tuples.size() ; ++i)</span>
        {
<span class="fc" id="L184">            ByteBuffer[] split = TYPE.split(ByteBufferAccessor.instance, tuples.get(i));</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">            if (i &lt; tokenInclusiveUpperBounds.length)</span>
<span class="nc" id="L186">                tokenInclusiveUpperBounds[i] = TOKEN_FACTORY.fromByteArray(split[0]);</span>
<span class="fc" id="L187">            ballotLowBounds[i] = Ballot.deserialize(split[1]);</span>
        }

<span class="fc" id="L190">        return new PaxosRepairHistory(tokenInclusiveUpperBounds, ballotLowBounds);</span>
    }

    // append the item to the given list, modifying the underlying list
    // if the item makes previoud entries redundant

    public static PaxosRepairHistory merge(PaxosRepairHistory historyLeft, PaxosRepairHistory historyRight)
    {
<span class="fc bfc" id="L198" title="All 2 branches covered.">        if (historyLeft == null)</span>
<span class="fc" id="L199">            return historyRight;</span>

<span class="pc bpc" id="L201" title="1 of 2 branches missed.">        if (historyRight == null)</span>
<span class="nc" id="L202">            return historyLeft;</span>

<span class="fc" id="L204">        Builder builder = new Builder(historyLeft.size() + historyRight.size());</span>

<span class="fc" id="L206">        RangeIterator left = historyLeft.rangeIterator();</span>
<span class="fc" id="L207">        RangeIterator right = historyRight.rangeIterator();</span>
<span class="fc bfc" id="L208" title="All 4 branches covered.">        while (left.hasUpperBound() &amp;&amp; right.hasUpperBound())</span>
        {
<span class="fc" id="L210">            int cmp = left.tokenInclusiveUpperBound().compareTo(right.tokenInclusiveUpperBound());</span>

<span class="fc" id="L212">            Ballot ballot = latest(left.ballotLowBound(), right.ballotLowBound());</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">            if (cmp == 0)</span>
            {
<span class="fc" id="L215">                builder.append(left.tokenInclusiveUpperBound(), ballot);</span>
<span class="fc" id="L216">                left.next();</span>
<span class="fc" id="L217">                right.next();</span>
            }
            else
            {
<span class="fc bfc" id="L221" title="All 2 branches covered.">                RangeIterator firstIter = cmp &lt; 0 ? left : right;</span>
<span class="fc" id="L222">                builder.append(firstIter.tokenInclusiveUpperBound(), ballot);</span>
<span class="fc" id="L223">                firstIter.next();</span>
            }
<span class="fc" id="L225">        }</span>

<span class="fc bfc" id="L227" title="All 2 branches covered.">        while (left.hasUpperBound())</span>
        {
<span class="fc" id="L229">            builder.append(left.tokenInclusiveUpperBound(), latest(left.ballotLowBound(), right.ballotLowBound()));</span>
<span class="fc" id="L230">            left.next();</span>
        }

<span class="fc bfc" id="L233" title="All 2 branches covered.">        while (right.hasUpperBound())</span>
        {
<span class="fc" id="L235">            builder.append(right.tokenInclusiveUpperBound(), latest(left.ballotLowBound(), right.ballotLowBound()));</span>
<span class="fc" id="L236">            right.next();</span>
        }

<span class="fc" id="L239">        builder.appendLast(latest(left.ballotLowBound(), right.ballotLowBound()));</span>
<span class="fc" id="L240">        return builder.build();</span>
    }

    @VisibleForTesting
    public static PaxosRepairHistory add(PaxosRepairHistory existing, Collection&lt;Range&lt;Token&gt;&gt; ranges, Ballot ballot)
    {
<span class="fc" id="L246">        ranges = Range.normalize(ranges);</span>
<span class="fc" id="L247">        Builder builder = new Builder(ranges.size() * 2);</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">        for (Range&lt;Token&gt; range : ranges)</span>
        {
            // don't add a point for an opening min token, since it
            // effectively leaves the bottom of the range unbounded
<span class="fc" id="L252">            builder.appendMaybeMin(range.left, Ballot.none());</span>
<span class="fc" id="L253">            builder.appendMaybeMax(range.right, ballot);</span>
<span class="fc" id="L254">        }</span>

<span class="fc" id="L256">        return merge(existing, builder.build());</span>
    }

    /**
     * returns a copy of this PaxosRepairHistory limited to the ranges supplied, with all other ranges reporting Ballot.none()
     */
    @VisibleForTesting
    static PaxosRepairHistory trim(PaxosRepairHistory existing, Collection&lt;Range&lt;Token&gt;&gt; ranges)
    {
<span class="fc" id="L265">        Builder builder = new Builder(existing.size());</span>

<span class="fc" id="L267">        ranges = Range.normalize(ranges);</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">        for (Range&lt;Token&gt; select : ranges)</span>
        {
<span class="fc" id="L270">            RangeIterator intersects = existing.intersects(select);</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">            while (intersects.hasNext())</span>
            {
<span class="fc bfc" id="L273" title="All 2 branches covered.">                if (Ballot.none().equals(intersects.ballotLowBound()))</span>
                {
<span class="fc" id="L275">                    intersects.next();</span>
<span class="fc" id="L276">                    continue;</span>
                }

<span class="fc" id="L279">                Token exclusiveLowerBound = maxExclusiveLowerBound(select.left, intersects.tokenExclusiveLowerBound());</span>
<span class="fc" id="L280">                Token inclusiveUpperBound = minInclusiveUpperBound(select.right, intersects.tokenInclusiveUpperBound());</span>
<span class="pc bpc" id="L281" title="2 of 4 branches missed.">                assert exclusiveLowerBound.compareTo(inclusiveUpperBound) &lt; 0 || inclusiveUpperBound.isMinimum();</span>

<span class="fc" id="L283">                builder.appendMaybeMin(exclusiveLowerBound, Ballot.none());</span>
<span class="fc" id="L284">                builder.appendMaybeMax(inclusiveUpperBound, intersects.ballotLowBound());</span>
<span class="fc" id="L285">                intersects.next();</span>
<span class="fc" id="L286">            }</span>
<span class="fc" id="L287">        }</span>

<span class="fc" id="L289">        return builder.build();</span>
    }

    RangeIterator intersects(Range&lt;Token&gt; unwrapped)
    {
<span class="fc" id="L294">        int from = Arrays.binarySearch(tokenInclusiveUpperBound, unwrapped.left);</span>
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">        if (from &lt; 0) from = -1 - from; else ++from;</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">        int to = unwrapped.right.isMinimum() ? ballotLowBound.length - 1 : Arrays.binarySearch(tokenInclusiveUpperBound, unwrapped.right);</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">        if (to &lt; 0) to = -1 - to;</span>
<span class="fc" id="L298">        return new RangeIterator(from, min(1 + to, ballotLowBound.length));</span>
    }

    private static Token maxExclusiveLowerBound(Token a, Token b)
    {
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">        return a.compareTo(b) &lt; 0 ? b : a;</span>
    }

    private static Token minInclusiveUpperBound(Token a, Token b)
    {
<span class="pc bpc" id="L308" title="5 of 6 branches missed.">        if (!a.isMinimum() &amp;&amp; !b.isMinimum()) return a.compareTo(b) &lt;= 0 ? a : b;</span>
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">        else if (!a.isMinimum()) return a;</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">        else if (!b.isMinimum()) return b;</span>
<span class="fc" id="L311">        else return a;</span>
    }

<span class="fc" id="L314">    public static final IVersionedSerializer&lt;PaxosRepairHistory&gt; serializer = new IVersionedSerializer&lt;PaxosRepairHistory&gt;()</span>
<span class="fc" id="L315">    {</span>
        public void serialize(PaxosRepairHistory history, DataOutputPlus out, int version) throws IOException
        {
<span class="fc" id="L318">            out.writeUnsignedVInt32(history.size());</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">            for (int i = 0; i &lt; history.size() ; ++i)</span>
            {
<span class="nc" id="L321">                Token.serializer.serialize(history.tokenInclusiveUpperBound[i], out, version);</span>
<span class="nc" id="L322">                history.ballotLowBound[i].serialize(out);</span>
            }
<span class="fc" id="L324">            history.ballotLowBound[history.size()].serialize(out);</span>
<span class="fc" id="L325">        }</span>

        public PaxosRepairHistory deserialize(DataInputPlus in, int version) throws IOException
        {
<span class="fc" id="L329">            int size = in.readUnsignedVInt32();</span>
<span class="fc" id="L330">            Token[] tokenInclusiveUpperBounds = new Token[size];</span>
<span class="fc" id="L331">            Ballot[] ballotLowBounds = new Ballot[size + 1];</span>
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">            for (int i = 0; i &lt; size; i++)</span>
            {
<span class="nc" id="L334">                tokenInclusiveUpperBounds[i] = Token.serializer.deserialize(in, DatabaseDescriptor.getPartitioner(), version);</span>
<span class="nc" id="L335">                ballotLowBounds[i] = Ballot.deserialize(in);</span>
            }
<span class="fc" id="L337">            ballotLowBounds[size] = Ballot.deserialize(in);</span>
<span class="fc" id="L338">            return new PaxosRepairHistory(tokenInclusiveUpperBounds, ballotLowBounds);</span>
        }

        public long serializedSize(PaxosRepairHistory history, int version)
        {
<span class="fc" id="L343">            long size = TypeSizes.sizeofUnsignedVInt(history.size());</span>
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">            for (int i = 0; i &lt; history.size() ; ++i)</span>
            {
<span class="nc" id="L346">                size += Token.serializer.serializedSize(history.tokenInclusiveUpperBound[i], version);</span>
<span class="nc" id="L347">                size += Ballot.sizeInBytes();</span>
            }
<span class="fc" id="L349">            size += Ballot.sizeInBytes();</span>
<span class="fc" id="L350">            return size;</span>
        }
    };

<span class="fc" id="L354">    public class Searcher</span>
    {
<span class="fc" id="L356">        int idx = -1;</span>

        public Ballot ballotForToken(Token token)
        {
<span class="pc bpc" id="L360" title="1 of 4 branches missed.">            if (idx &lt; 0 || !contains(idx, token))</span>
<span class="fc" id="L361">                idx = indexForToken(token);</span>
<span class="fc" id="L362">            return ballotForIndex(idx);</span>
        }
    }

    class RangeIterator
    {
        final int end;
        int i;

        RangeIterator()
<span class="fc" id="L372">        {</span>
<span class="fc" id="L373">            this.end = ballotLowBound.length;</span>
<span class="fc" id="L374">        }</span>

        RangeIterator(int from, int to)
<span class="fc" id="L377">        {</span>
<span class="fc" id="L378">            this.i = from;</span>
<span class="fc" id="L379">            this.end = to;</span>
<span class="fc" id="L380">        }</span>

        boolean hasNext()
        {
<span class="fc bfc" id="L384" title="All 2 branches covered.">            return i &lt; end;</span>
        }

        boolean hasUpperBound()
        {
<span class="fc bfc" id="L389" title="All 2 branches covered.">            return i &lt; tokenInclusiveUpperBound.length;</span>
        }

        void next()
        {
<span class="fc" id="L394">            ++i;</span>
<span class="fc" id="L395">        }</span>

        Token tokenExclusiveLowerBound()
        {
<span class="fc" id="L399">            return PaxosRepairHistory.this.tokenExclusiveLowerBound(i);</span>
        }

        Token tokenInclusiveUpperBound()
        {
<span class="fc" id="L404">            return PaxosRepairHistory.this.tokenInclusiveUpperBound(i);</span>
        }

        Ballot ballotLowBound()
        {
<span class="fc" id="L409">            return ballotLowBound[i];</span>
        }
    }

<span class="fc" id="L413">    static class Builder</span>
    {
        final List&lt;Token&gt; tokenInclusiveUpperBounds;
        final List&lt;Ballot&gt; ballotLowBounds;

        Builder(int capacity)
<span class="fc" id="L419">        {</span>
<span class="fc" id="L420">            this.tokenInclusiveUpperBounds = new ArrayList&lt;&gt;(capacity);</span>
<span class="fc" id="L421">            this.ballotLowBounds = new ArrayList&lt;&gt;(capacity + 1);</span>
<span class="fc" id="L422">        }</span>

        void appendMaybeMin(Token inclusiveLowBound, Ballot ballotLowBound)
        {
<span class="fc bfc" id="L426" title="All 2 branches covered.">            if (inclusiveLowBound.isMinimum())</span>
<span class="pc bpc" id="L427" title="2 of 4 branches missed.">                assert ballotLowBound.equals(Ballot.none()) &amp;&amp; ballotLowBounds.isEmpty();</span>
            else
<span class="fc" id="L429">                append(inclusiveLowBound, ballotLowBound);</span>
<span class="fc" id="L430">        }</span>

        void appendMaybeMax(Token inclusiveLowBound, Ballot ballotLowBound)
        {
<span class="fc bfc" id="L434" title="All 2 branches covered.">            if (inclusiveLowBound.isMinimum())</span>
<span class="fc" id="L435">                appendLast(ballotLowBound);</span>
            else
<span class="fc" id="L437">                append(inclusiveLowBound, ballotLowBound);</span>
<span class="fc" id="L438">        }</span>

        void append(Token inclusiveLowBound, Ballot ballotLowBound)
        {
<span class="fc" id="L442">            int tailIdx = tokenInclusiveUpperBounds.size() - 1;</span>

<span class="pc bpc" id="L444" title="1 of 2 branches missed.">            assert tokenInclusiveUpperBounds.size() == ballotLowBounds.size();</span>
<span class="pc bpc" id="L445" title="1 of 4 branches missed.">            assert tailIdx &lt; 0 || inclusiveLowBound.compareTo(tokenInclusiveUpperBounds.get(tailIdx)) &gt;= 0;</span>

<span class="pc bpc" id="L447" title="1 of 4 branches missed.">            boolean sameAsTailToken = tailIdx &gt;= 0 &amp;&amp; inclusiveLowBound.equals(tokenInclusiveUpperBounds.get(tailIdx));</span>
<span class="pc bpc" id="L448" title="1 of 4 branches missed.">            boolean sameAsTailBallot = tailIdx &gt;= 0 &amp;&amp; ballotLowBound.equals(ballotLowBounds.get(tailIdx));</span>
<span class="pc bpc" id="L449" title="2 of 4 branches missed.">            if (sameAsTailToken || sameAsTailBallot)</span>
            {
<span class="nc bnc" id="L451" title="All 2 branches missed.">                if (sameAsTailBallot)</span>
<span class="nc" id="L452">                    tokenInclusiveUpperBounds.set(tailIdx, inclusiveLowBound);</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">                else if (isAfter(ballotLowBound, ballotLowBounds.get(tailIdx)))</span>
<span class="nc" id="L454">                    ballotLowBounds.set(tailIdx, ballotLowBound);</span>
            }
            else
            {
<span class="fc" id="L458">                tokenInclusiveUpperBounds.add(inclusiveLowBound);</span>
<span class="fc" id="L459">                ballotLowBounds.add(ballotLowBound);</span>
            }
<span class="fc" id="L461">        }</span>

        void appendLast(Ballot ballotLowBound)
        {
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">            assert ballotLowBounds.size() == tokenInclusiveUpperBounds.size();</span>
<span class="fc" id="L466">            int tailIdx = tokenInclusiveUpperBounds.size() - 1;</span>
<span class="pc bpc" id="L467" title="1 of 4 branches missed.">            if (!ballotLowBounds.isEmpty() &amp;&amp; ballotLowBound.equals(ballotLowBounds.get(tailIdx)))</span>
<span class="nc" id="L468">                tokenInclusiveUpperBounds.remove(tailIdx);</span>
            else
<span class="fc" id="L470">                ballotLowBounds.add(ballotLowBound);</span>
<span class="fc" id="L471">        }</span>

        PaxosRepairHistory build()
        {
<span class="fc bfc" id="L475" title="All 2 branches covered.">            if (tokenInclusiveUpperBounds.size() == ballotLowBounds.size())</span>
<span class="fc" id="L476">                ballotLowBounds.add(Ballot.none());</span>
<span class="fc" id="L477">            return new PaxosRepairHistory(tokenInclusiveUpperBounds.toArray(new Token[0]), ballotLowBounds.toArray(new Ballot[0]));</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>