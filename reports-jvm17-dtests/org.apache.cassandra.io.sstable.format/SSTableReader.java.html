<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SSTableReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.io.sstable.format</a> &gt; <span class="el_source">SSTableReader.java</span></div><h1>SSTableReader.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.io.sstable.format;


import java.io.IOException;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.Iterables;
import com.google.common.collect.Ordering;
import com.google.common.primitives.Longs;
import com.google.common.util.concurrent.RateLimiter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.clearspring.analytics.stream.cardinality.CardinalityMergeException;
import com.clearspring.analytics.stream.cardinality.ICardinality;
import org.apache.cassandra.concurrent.ExecutorPlus;
import org.apache.cassandra.concurrent.ScheduledExecutorPlus;
import org.apache.cassandra.concurrent.ScheduledExecutors;
import org.apache.cassandra.config.CassandraRelevantProperties;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.PartitionPosition;
import org.apache.cassandra.db.SerializationHeader;
import org.apache.cassandra.db.SystemKeyspace;
import org.apache.cassandra.db.rows.Cell;
import org.apache.cassandra.db.rows.EncodingStats;
import org.apache.cassandra.db.rows.UnfilteredRowIterator;
import org.apache.cassandra.db.rows.UnfilteredSource;
import org.apache.cassandra.dht.AbstractBounds;
import org.apache.cassandra.dht.Bounds;
import org.apache.cassandra.dht.Range;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.io.FSError;
import org.apache.cassandra.io.FSWriteError;
import org.apache.cassandra.io.compress.CompressionMetadata;
import org.apache.cassandra.io.sstable.AbstractRowIndexEntry;
import org.apache.cassandra.io.sstable.Component;
import org.apache.cassandra.io.sstable.CorruptSSTableException;
import org.apache.cassandra.io.sstable.Descriptor;
import org.apache.cassandra.io.sstable.ISSTableScanner;
import org.apache.cassandra.io.sstable.IVerifier;
import org.apache.cassandra.io.sstable.KeyIterator;
import org.apache.cassandra.io.sstable.KeyReader;
import org.apache.cassandra.io.sstable.SSTable;
import org.apache.cassandra.io.sstable.SSTableIdFactory;
import org.apache.cassandra.io.sstable.SSTableIdentityIterator;
import org.apache.cassandra.io.sstable.SSTableReadsListener;
import org.apache.cassandra.io.sstable.format.SSTableFormat.Components;
import org.apache.cassandra.io.sstable.metadata.CompactionMetadata;
import org.apache.cassandra.io.sstable.metadata.StatsMetadata;
import org.apache.cassandra.io.util.ChannelProxy;
import org.apache.cassandra.io.util.CheckedFunction;
import org.apache.cassandra.io.util.DataIntegrityMetadata;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.io.util.FileDataInput;
import org.apache.cassandra.io.util.FileHandle;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.io.util.RandomAccessReader;
import org.apache.cassandra.metrics.RestorableMeter;
import org.apache.cassandra.schema.SchemaConstants;
import org.apache.cassandra.schema.TableMetadataRef;
import org.apache.cassandra.service.ActiveRepairService;
import org.apache.cassandra.utils.EstimatedHistogram;
import org.apache.cassandra.utils.ExecutorUtils;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.JVMStabilityInspector;
import org.apache.cassandra.utils.NativeLibrary;
import org.apache.cassandra.utils.OutputHandler;
import org.apache.cassandra.utils.Throwables;
import org.apache.cassandra.utils.TimeUUID;
import org.apache.cassandra.utils.concurrent.OpOrder;
import org.apache.cassandra.utils.concurrent.Ref;
import org.apache.cassandra.utils.concurrent.SelfRefCounted;
import org.apache.cassandra.utils.concurrent.SharedCloseable;
import org.apache.cassandra.utils.concurrent.UncheckedInterruptedException;

import static org.apache.cassandra.concurrent.ExecutorFactory.Global.executorFactory;
import static org.apache.cassandra.utils.concurrent.BlockingQueues.newBlockingQueue;
import static org.apache.cassandra.utils.concurrent.SharedCloseable.sharedCopyOrNull;

/**
 * An SSTableReader can be constructed in a number of places, but typically is either read from disk at startup, or
 * constructed from a flushed memtable, or after compaction to replace some existing sstables. However once created,
 * an sstablereader may also be modified.
 * &lt;p&gt;
 * A reader's {@link OpenReason} describes its current stage in its lifecycle. Note that in parallel to this, there are
 * two different Descriptor types; TMPLINK and FINAL; the latter corresponds to {@link OpenReason#NORMAL} state readers
 * and all readers that replace a {@link OpenReason#NORMAL} one. TMPLINK is used for {@link OpenReason#EARLY} state
 * readers and no others.
 * &lt;p&gt;
 * When a reader is being compacted, if the result is large its replacement may be opened as {@link OpenReason#EARLY}
 * before compaction completes in order to present the result to consumers earlier. In this case the reader will itself
 * be changed to a {@link OpenReason#MOVED_START} state, where its start no longer represents its on-disk minimum key.
 * This is to permit reads to be directed to only one reader when the two represent the same data.
 * The {@link OpenReason#EARLY} file can represent a compaction result that is either partially complete and still
 * in-progress, or a complete and immutable sstable that is part of a larger macro compaction action that has not yet
 * fully completed.
 * &lt;p&gt;
 * Currently ALL compaction results at least briefly go through an {@link OpenReason#EARLY} open state prior to completion,
 * regardless of if early opening is enabled.
 * &lt;p&gt;
 * Since a reader can be created multiple times over the same shared underlying resources, and the exact resources it
 * shares between each instance differ subtly, we track the lifetime of any underlying resource with its own reference
 * count, which each instance takes a {@link Ref} to. Each instance then tracks references to itself, and once these
 * all expire it releases all its {@link Ref} to these underlying resources.
 * &lt;p&gt;
 * There is some shared cleanup behaviour needed only once all readers in a certain stage of their lifecycle
 * (i.e. {@link OpenReason#EARLY} or {@link OpenReason#NORMAL} opening), and some that must only occur once all readers
 * of any kind over a single logical sstable have expired. These are managed by the {@link InstanceTidier} and
 * {@link GlobalTidy} classes at the bottom, and are effectively managed as another resource each instance tracks its
 * own {@link Ref} instance to, to ensure all of these resources are cleaned up safely and can be debugged otherwise.
 * &lt;p&gt;
 * TODO: fill in details about Tracker and lifecycle interactions for tools, and for compaction strategies
 */
public abstract class SSTableReader extends SSTable implements UnfilteredSource, SelfRefCounted&lt;SSTableReader&gt;
{
<span class="fc" id="L154">    private static final Logger logger = LoggerFactory.getLogger(SSTableReader.class);</span>

<span class="fc" id="L156">    private static final boolean TRACK_ACTIVITY = CassandraRelevantProperties.DISABLE_SSTABLE_ACTIVITY_TRACKING.getBoolean();</span>

<span class="fc" id="L158">    private static final ScheduledExecutorPlus syncExecutor = initSyncExecutor();</span>

    private static ScheduledExecutorPlus initSyncExecutor()
    {
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (DatabaseDescriptor.isClientOrToolInitialized())</span>
<span class="fc" id="L163">            return null;</span>

        // Do NOT start this thread pool in client mode

<span class="fc" id="L167">        ScheduledExecutorPlus syncExecutor = executorFactory().scheduled(&quot;read-hotness-tracker&quot;);</span>
        // Immediately remove readMeter sync task when cancelled.
        // TODO: should we set this by default on all scheduled executors?
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        if (syncExecutor instanceof ScheduledThreadPoolExecutor)</span>
<span class="fc" id="L171">            ((ScheduledThreadPoolExecutor) syncExecutor).setRemoveOnCancelPolicy(true);</span>
<span class="fc" id="L172">        return syncExecutor;</span>
    }

<span class="fc" id="L175">    private static final RateLimiter meterSyncThrottle = RateLimiter.create(100.0);</span>

<span class="fc" id="L177">    public static final Comparator&lt;SSTableReader&gt; maxTimestampAscending = Comparator.comparingLong(SSTableReader::getMaxTimestamp);</span>
<span class="fc" id="L178">    public static final Comparator&lt;SSTableReader&gt; maxTimestampDescending = maxTimestampAscending.reversed();</span>

    // it's just an object, which we use regular Object equality on; we introduce a special class just for easy recognition
<span class="fc" id="L181">    public static final class UniqueIdentifier</span>
    {
    }
<span class="fc" id="L184">    public final UniqueIdentifier instanceId = new UniqueIdentifier();</span>

<span class="fc" id="L186">    public static final Comparator&lt;SSTableReader&gt; firstKeyComparator = (o1, o2) -&gt; o1.getFirst().compareTo(o2.getFirst());</span>
<span class="fc" id="L187">    public static final Ordering&lt;SSTableReader&gt; firstKeyOrdering = Ordering.from(firstKeyComparator);</span>
<span class="fc" id="L188">    public static final Comparator&lt;SSTableReader&gt; lastKeyComparator = (o1, o2) -&gt; o1.getLast().compareTo(o2.getLast());</span>

<span class="fc" id="L190">    public static final Comparator&lt;SSTableReader&gt; idComparator = Comparator.comparing(t -&gt; t.descriptor.id, SSTableIdFactory.COMPARATOR);</span>
<span class="fc" id="L191">    public static final Comparator&lt;SSTableReader&gt; idReverseComparator = idComparator.reversed();</span>

<span class="fc" id="L193">    public static final Comparator&lt;SSTableReader&gt; sizeComparator = (o1, o2) -&gt; Longs.compare(o1.onDiskLength(), o2.onDiskLength());</span>

    /**
     * maxDataAge is a timestamp in local server time (e.g. Global.currentTimeMilli) which represents an upper bound
     * to the newest piece of data stored in the sstable. In other words, this sstable does not contain items created
     * later than maxDataAge.
     * &lt;p&gt;
     * The field is not serialized to disk, so relying on it for more than what truncate does is not advised.
     * &lt;p&gt;
     * When a new sstable is flushed, maxDataAge is set to the time of creation.
     * When a sstable is created from compaction, maxDataAge is set to max of all merged sstables.
     * &lt;p&gt;
     * The age is in milliseconds since epoc and is local to this host.
     */
    public final long maxDataAge;

<span class="fc" id="L209">    public enum OpenReason</span>
    {
        /**
         * &lt;ul&gt;
         * &lt;li&gt;From {@code None} - Reader has been read from disk, either at startup or from a flushed memtable&lt;/li&gt;
         * &lt;li&gt;From {@link #EARLY} - Reader is the final result of a compaction&lt;/li&gt;
         * &lt;li&gt;From {@link #MOVED_START} - Reader WAS being compacted, but this failed and it has been restored
         *     to {code NORMAL}status&lt;/li&gt;
         * &lt;/ul&gt;
         */
<span class="fc" id="L219">        NORMAL,</span>

        /**
         * &lt;ul&gt;
         * &lt;li&gt;From {@code None} - Reader is a compaction replacement that is either incomplete and has been opened
         *     to represent its partial result status, or has been finished but the compaction it is a part of has not
         *     yet completed fully&lt;/li&gt;
         * &lt;li&gt;From {@link #EARLY} - Same as from {@code None}, only it is not the first time it has been
         * &lt;/ul&gt;
         */
<span class="fc" id="L229">        EARLY,</span>

        /**
         * From:
         * &lt;ul&gt;
         * &lt;li&gt;From {@link #NORMAL} - Reader has seen low traffic and the amount of memory available for index summaries
         *     is constrained, so its index summary has been downsampled&lt;/li&gt;
         * &lt;li&gt;From {@link #METADATA_CHANGE} - Same
         * &lt;/ul&gt;
         */
<span class="fc" id="L239">        METADATA_CHANGE,</span>

        /**
         * &lt;ul&gt;
         * &lt;li&gt;From {@link #NORMAL} - Reader is being compacted. This compaction has not finished, but the compaction
         *     result is either partially or fully opened, to either partially or fully replace this reader. This reader's
         *     start key has been updated to represent this, so that reads only hit one or the other reader.&lt;/li&gt;
         * &lt;/ul&gt;
         */
<span class="fc" id="L248">        MOVED_START</span>
    }

    public final OpenReason openReason;

    protected final FileHandle dfile;

    // technically isCompacted is not necessary since it should never be unreferenced unless it is also compacted,
    // but it seems like a good extra layer of protection against reference counting bugs to not delete data based on that alone
<span class="fc" id="L257">    public final AtomicBoolean isSuspect = new AtomicBoolean(false);</span>

    // not final since we need to be able to change level on a file.
    protected volatile StatsMetadata sstableMetadata;

    public final SerializationHeader header;

    private final InstanceTidier tidy;
    private final Ref&lt;SSTableReader&gt; selfRef;

    private RestorableMeter readMeter;

    private volatile double crcCheckChance;

    protected final DecoratedKey first;
    protected final DecoratedKey last;
    public final AbstractBounds&lt;Token&gt; bounds;

    /**
     * Calculate approximate key count.
     * If cardinality estimator is available on all given sstables, then this method use them to estimate
     * key count.
     * If not, then this uses index summaries.
     *
     * @param sstables SSTables to calculate key count
     * @return estimated key count
     */
    public static long getApproximateKeyCount(Iterable&lt;SSTableReader&gt; sstables)
    {
<span class="fc" id="L286">        long count = -1;</span>

<span class="fc bfc" id="L288" title="All 2 branches covered.">        if (Iterables.isEmpty(sstables))</span>
<span class="fc" id="L289">            return count;</span>

<span class="fc" id="L291">        boolean failed = false;</span>
<span class="fc" id="L292">        ICardinality cardinality = null;</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">        for (SSTableReader sstable : sstables)</span>
        {
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">            if (sstable.openReason == OpenReason.EARLY)</span>
<span class="nc" id="L296">                continue;</span>

            try
            {
<span class="fc" id="L300">                CompactionMetadata metadata = StatsComponent.load(sstable.descriptor).compactionMetadata();</span>
                // If we can't load the CompactionMetadata, we are forced to estimate the keys using the index
                // summary. (CASSANDRA-10676)
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">                if (metadata == null)</span>
                {
<span class="nc" id="L305">                    logger.warn(&quot;Reading cardinality from Statistics.db failed for {}&quot;, sstable.getFilename());</span>
<span class="nc" id="L306">                    failed = true;</span>
<span class="nc" id="L307">                    break;</span>
                }

<span class="fc bfc" id="L310" title="All 2 branches covered.">                if (cardinality == null)</span>
<span class="fc" id="L311">                    cardinality = metadata.cardinalityEstimator;</span>
                else
<span class="fc" id="L313">                    cardinality = cardinality.merge(metadata.cardinalityEstimator);</span>
            }
<span class="nc" id="L315">            catch (IOException e)</span>
            {
<span class="nc" id="L317">                logger.warn(&quot;Reading cardinality from Statistics.db failed.&quot;, e);</span>
<span class="nc" id="L318">                failed = true;</span>
<span class="nc" id="L319">                break;</span>
            }
<span class="nc" id="L321">            catch (CardinalityMergeException e)</span>
            {
<span class="nc" id="L323">                logger.warn(&quot;Cardinality merge failed.&quot;, e);</span>
<span class="nc" id="L324">                failed = true;</span>
<span class="nc" id="L325">                break;</span>
<span class="fc" id="L326">            }</span>
<span class="fc" id="L327">        }</span>
<span class="pc bpc" id="L328" title="2 of 4 branches missed.">        if (cardinality != null &amp;&amp; !failed)</span>
<span class="fc" id="L329">            count = cardinality.cardinality();</span>

        // if something went wrong above or cardinality is not available, calculate using index summary
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">        if (count &lt; 0)</span>
        {
<span class="nc" id="L334">            count = 0;</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">            for (SSTableReader sstable : sstables)</span>
<span class="nc" id="L336">                count += sstable.estimatedKeys();</span>
        }
<span class="fc" id="L338">        return count;</span>
    }

    public static SSTableReader open(SSTable.Owner owner, Descriptor descriptor)
    {
<span class="nc" id="L343">        return open(owner, descriptor, null);</span>
    }

    public static SSTableReader open(SSTable.Owner owner, Descriptor desc, TableMetadataRef metadata)
    {
<span class="nc" id="L348">        return open(owner, desc, null, metadata);</span>
    }

    public static SSTableReader open(SSTable.Owner owner, Descriptor descriptor, Set&lt;Component&gt; components, TableMetadataRef metadata)
    {
<span class="fc" id="L353">        return open(owner, descriptor, components, metadata, true, false);</span>
    }

    // use only for offline or &quot;Standalone&quot; operations
    public static SSTableReader openNoValidation(Descriptor descriptor, Set&lt;Component&gt; components, ColumnFamilyStore cfs)
    {
<span class="nc" id="L359">        return open(cfs, descriptor, components, cfs.metadata, false, true);</span>
    }

    // use only for offline or &quot;Standalone&quot; operations
    public static SSTableReader openNoValidation(SSTable.Owner owner, Descriptor descriptor, TableMetadataRef metadata)
    {
<span class="nc" id="L365">        return open(owner, descriptor, null, metadata, false, true);</span>
    }

    /**
     * Open SSTable reader to be used in batch mode(such as sstableloader).
     */
    public static SSTableReader openForBatch(SSTable.Owner owner, Descriptor descriptor, Set&lt;Component&gt; components, TableMetadataRef metadata)
    {
<span class="fc" id="L373">        return open(owner, descriptor, components, metadata, true, true);</span>
    }

    /**
     * Open an SSTable for reading
     *
     * @param owner      owning entity
     * @param descriptor SSTable to open
     * @param components Components included with this SSTable
     * @param metadata   for this SSTables CF
     * @param validate   Check SSTable for corruption (limited)
     * @param isOffline  Whether we are opening this SSTable &quot;offline&quot;, for example from an external tool or not for inclusion in queries (validations)
     *                   This stops regenerating BF + Summaries and also disables tracking of hotness for the SSTable.
     * @return {@link SSTableReader}
     */
    public static SSTableReader open(Owner owner,
                                     Descriptor descriptor,
                                     Set&lt;Component&gt; components,
                                     TableMetadataRef metadata,
                                     boolean validate,
                                     boolean isOffline)
    {
<span class="fc" id="L395">        SSTableReaderLoadingBuilder&lt;?, ?&gt; builder = descriptor.getFormat().getReaderFactory().loadingBuilder(descriptor, metadata, components);</span>

<span class="fc bfc" id="L397" title="All 2 branches covered.">        return builder.build(owner, validate, !isOffline);</span>
    }

    public static Collection&lt;SSTableReader&gt; openAll(SSTable.Owner owner, Set&lt;Map.Entry&lt;Descriptor, Set&lt;Component&gt;&gt;&gt; entries,
                                                    final TableMetadataRef metadata)
    {
<span class="fc" id="L403">        final Collection&lt;SSTableReader&gt; sstables = newBlockingQueue();</span>

<span class="fc" id="L405">        ExecutorPlus executor = executorFactory().pooled(&quot;SSTableBatchOpen&quot;, FBUtilities.getAvailableProcessors());</span>
        try
        {
<span class="fc bfc" id="L408" title="All 2 branches covered.">            for (final Map.Entry&lt;Descriptor, Set&lt;Component&gt;&gt; entry : entries)</span>
            {
<span class="fc" id="L410">                Runnable runnable = () -&gt; {</span>
                    SSTableReader sstable;
                    try
                    {
<span class="fc" id="L414">                        sstable = open(owner, entry.getKey(), entry.getValue(), metadata);</span>
                    }
<span class="nc" id="L416">                    catch (CorruptSSTableException ex)</span>
                    {
<span class="nc" id="L418">                        JVMStabilityInspector.inspectThrowable(ex);</span>
<span class="nc" id="L419">                        logger.error(&quot;Corrupt sstable {}; skipping table&quot;, entry, ex);</span>
<span class="nc" id="L420">                        return;</span>
                    }
<span class="nc" id="L422">                    catch (FSError ex)</span>
                    {
<span class="nc" id="L424">                        JVMStabilityInspector.inspectThrowable(ex);</span>
<span class="nc" id="L425">                        logger.error(&quot;Cannot read sstable {}; file system error, skipping table&quot;, entry, ex);</span>
<span class="nc" id="L426">                        return;</span>
<span class="fc" id="L427">                    }</span>
<span class="fc" id="L428">                    sstables.add(sstable);</span>
<span class="fc" id="L429">                };</span>
<span class="fc" id="L430">                executor.submit(runnable);</span>
<span class="fc" id="L431">            }</span>
        }
        finally
        {
<span class="fc" id="L435">            executor.shutdown();</span>
        }

        try
        {
<span class="fc" id="L440">            executor.awaitTermination(7, TimeUnit.DAYS);</span>
        }
<span class="nc" id="L442">        catch (InterruptedException e)</span>
        {
<span class="nc" id="L444">            throw new UncheckedInterruptedException(e);</span>
<span class="fc" id="L445">        }</span>

<span class="fc" id="L447">        return sstables;</span>
    }

    protected SSTableReader(Builder&lt;?, ?&gt; builder, Owner owner)
    {
<span class="fc" id="L452">        super(builder, owner);</span>

<span class="fc" id="L454">        this.sstableMetadata = builder.getStatsMetadata();</span>
<span class="fc" id="L455">        this.header = builder.getSerializationHeader();</span>
<span class="fc" id="L456">        this.dfile = builder.getDataFile();</span>
<span class="fc" id="L457">        this.maxDataAge = builder.getMaxDataAge();</span>
<span class="fc" id="L458">        this.openReason = builder.getOpenReason();</span>
<span class="fc" id="L459">        this.first = builder.getFirst();</span>
<span class="fc" id="L460">        this.last = builder.getLast();</span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">        this.bounds = AbstractBounds.strictlyWrapsAround(first.getToken(), last.getToken())</span>
<span class="nc" id="L462">                      ? null // this will cause the validation to fail, but the reader is opened with no validation,</span>
                             // e.g. for scrubbing, we should accept screwed bounds
<span class="fc" id="L464">                      : AbstractBounds.bounds(first.getToken(), true, last.getToken(), true);</span>

<span class="fc" id="L466">        tidy = new InstanceTidier(descriptor, owner);</span>
<span class="fc" id="L467">        selfRef = new Ref&lt;&gt;(this, tidy);</span>
<span class="fc" id="L468">    }</span>

    @Override
    public DecoratedKey getFirst()
    {
<span class="fc" id="L473">        return first;</span>
    }

    @Override
    public DecoratedKey getLast()
    {
<span class="fc" id="L479">        return last;</span>
    }

    @Override
    public AbstractBounds&lt;Token&gt; getBounds()
    {
<span class="fc" id="L485">        return Objects.requireNonNull(bounds, &quot;Bounds were not created because the sstable is out of order&quot;);</span>
    }

    public DataIntegrityMetadata.ChecksumValidator maybeGetChecksumValidator() throws IOException
    {
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">        if (descriptor.fileFor(Components.CRC).exists())</span>
<span class="fc" id="L491">            return new DataIntegrityMetadata.ChecksumValidator(descriptor.fileFor(Components.DATA), descriptor.fileFor(Components.CRC));</span>
        else
<span class="nc" id="L493">            return null;</span>
    }

    public DataIntegrityMetadata.FileDigestValidator maybeGetDigestValidator() throws IOException
    {
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">        if (descriptor.fileFor(Components.DIGEST).exists())</span>
<span class="fc" id="L499">            return new DataIntegrityMetadata.FileDigestValidator(descriptor.fileFor(Components.DATA), descriptor.fileFor(Components.DIGEST));</span>
        else
<span class="nc" id="L501">            return null;</span>
    }

    public static long getTotalBytes(Iterable&lt;SSTableReader&gt; sstables)
    {
<span class="fc" id="L506">        long sum = 0;</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">        for (SSTableReader sstable : sstables)</span>
<span class="fc" id="L508">            sum += sstable.onDiskLength();</span>
<span class="fc" id="L509">        return sum;</span>
    }

    public static long getTotalUncompressedBytes(Iterable&lt;SSTableReader&gt; sstables)
    {
<span class="nc" id="L514">        long sum = 0;</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">        for (SSTableReader sstable : sstables)</span>
<span class="nc" id="L516">            sum += sstable.uncompressedLength();</span>

<span class="nc" id="L518">        return sum;</span>
    }

    public boolean equals(Object that)
    {
<span class="pc bpc" id="L523" title="1 of 4 branches missed.">        return that instanceof SSTableReader &amp;&amp; ((SSTableReader) that).descriptor.equals(this.descriptor);</span>
    }

    public int hashCode()
    {
<span class="fc" id="L528">        return this.descriptor.hashCode();</span>
    }

    public String getFilename()
    {
<span class="fc" id="L533">        return dfile.path();</span>
    }

    public void setupOnline()
    {
<span class="fc" id="L538">         owner().ifPresent(o -&gt; setCrcCheckChance(o.getCrcCheckChance()));</span>
<span class="fc" id="L539">    }</span>

    /**
     * Execute provided task with sstable lock to avoid racing with index summary redistribution, SEE CASSANDRA-15861.
     *
     * @param task to be guarded by sstable lock
     */
    public &lt;R, E extends Exception&gt; R runWithLock(CheckedFunction&lt;Descriptor, R, E&gt; task) throws E
    {
<span class="fc" id="L548">        synchronized (tidy.global)</span>
        {
<span class="fc" id="L550">            return task.apply(descriptor);</span>
        }
    }

    public void setReplaced()
    {
<span class="fc" id="L556">        synchronized (tidy.global)</span>
        {
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">            assert !tidy.isReplaced;</span>
<span class="fc" id="L559">            tidy.isReplaced = true;</span>
<span class="fc" id="L560">        }</span>
<span class="fc" id="L561">    }</span>

    public boolean isReplaced()
    {
<span class="fc" id="L565">        synchronized (tidy.global)</span>
        {
<span class="fc" id="L567">            return tidy.isReplaced;</span>
        }
    }

    /**
     * The runnable passed to this method must not be an anonymous or non-static inner class. It can be a lambda or a
     * method reference provided that it does not retain a reference chain to this reader.
     */
    public void runOnClose(final Runnable runOnClose)
    {
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">        if (runOnClose == null)</span>
<span class="nc" id="L578">            return;</span>

<span class="fc" id="L580">        synchronized (tidy.global)</span>
        {
<span class="fc" id="L582">            final Runnable existing = tidy.runOnClose;</span>
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">            if (existing == null)</span>
<span class="fc" id="L584">                tidy.runOnClose = runOnClose;</span>
            else
<span class="nc" id="L586">                tidy.runOnClose = () -&gt; {</span>
<span class="nc" id="L587">                    existing.run();</span>
<span class="nc" id="L588">                    runOnClose.run();</span>
<span class="nc" id="L589">                };</span>
<span class="fc" id="L590">        }</span>
<span class="fc" id="L591">    }</span>

    /**
     * The method sets fields specific to this {@link SSTableReader} and the parent {@link SSTable} on the provided
     * {@link Builder}. The method is intended to be called from the overloaded {@code unbuildTo} method in subclasses.
     *
     * @param builder    the builder on which the fields should be set
     * @param sharedCopy whether the {@link SharedCloseable} resources should be passed as shared copies or directly;
     *                   note that the method will overwrite the fields representing {@link SharedCloseable} only if
     *                   they are not set in the builder yet (the relevant fields in the builder are {@code null}).
     * @return the same instance of builder as provided
     */
    protected final &lt;B extends Builder&lt;?, B&gt;&gt; B unbuildTo(B builder, boolean sharedCopy)
    {
<span class="fc" id="L605">        B b = super.unbuildTo(builder, sharedCopy);</span>
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">        if (builder.getDataFile() == null)</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">            b.setDataFile(sharedCopy ? sharedCopyOrNull(dfile) : dfile);</span>

<span class="fc" id="L609">        b.setStatsMetadata(sstableMetadata);</span>
<span class="fc" id="L610">        b.setSerializationHeader(header);</span>
<span class="fc" id="L611">        b.setMaxDataAge(maxDataAge);</span>
<span class="fc" id="L612">        b.setOpenReason(openReason);</span>
<span class="fc" id="L613">        b.setFirst(first);</span>
<span class="fc" id="L614">        b.setLast(last);</span>
<span class="fc" id="L615">        b.setSuspected(isSuspect.get());</span>
<span class="fc" id="L616">        return b;</span>
    }

    public abstract SSTableReader cloneWithRestoredStart(DecoratedKey restoredStart);

    public abstract SSTableReader cloneWithNewStart(DecoratedKey newStart);

    public RestorableMeter getReadMeter()
    {
<span class="fc" id="L625">        return readMeter;</span>
    }

    /**
     * All the resources which should be released upon closing this sstable reader are registered with in
     * {@link GlobalTidy}. This method lets close a provided resource explicitly any time and unregister it from
     * {@link GlobalTidy} so that it is not tried to be released twice.
     *
     * @param closeable a resource to be closed
     */
    protected void closeInternalComponent(AutoCloseable closeable)
    {
<span class="fc" id="L637">        synchronized (tidy.global)</span>
        {
<span class="fc" id="L639">            boolean removed = tidy.closeables.remove(closeable);</span>
<span class="fc" id="L640">            Preconditions.checkState(removed);</span>
            try
            {
<span class="fc" id="L643">                closeable.close();</span>
            }
<span class="nc" id="L645">            catch (Exception ex)</span>
            {
<span class="nc" id="L647">                throw new RuntimeException(&quot;Failed to close &quot; + closeable, ex);</span>
<span class="fc" id="L648">            }</span>
<span class="fc" id="L649">        }</span>
<span class="fc" id="L650">    }</span>

    /**
     * This method is expected to close the components which occupy memory but are not needed when we just want to
     * stream the components (for example, when SSTable is opened with SSTableLoader). The method should call
     * {@link #closeInternalComponent(AutoCloseable)} for each such component. Leaving the implementation empty is
     * valid given there are not such resources to release.
     */
    public abstract void releaseInMemoryComponents();

    /**
     * Perform any validation needed for the reader upon creation before returning it from the {@link Builder}.
     */
    public void validate()
    {
<span class="pc bpc" id="L665" title="2 of 4 branches missed.">        if (this.first.compareTo(this.last) &gt; 0 || bounds == null)</span>
        {
<span class="nc" id="L667">            throw new CorruptSSTableException(new IllegalStateException(String.format(&quot;SSTable first key %s &gt; last key %s&quot;, this.first, this.last)), getFilename());</span>
        }
<span class="fc" id="L669">    }</span>

    /**
     * Returns the compression metadata for this sstable. Note that the compression metdata is a resource and should not
     * be closed by the caller.
     * TODO do not return a closeable resource or return a shared copy
     *
     * @throws IllegalStateException if the sstable is not compressed
     */
    public CompressionMetadata getCompressionMetadata()
    {
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">        if (!compression)</span>
<span class="nc" id="L681">            throw new IllegalStateException(this + &quot; is not compressed&quot;);</span>

<span class="fc" id="L683">        return dfile.compressionMetadata().get();</span>
    }

    /**
     * Returns the amount of memory in bytes used off heap by the compression meta-data.
     *
     * @return the amount of memory in bytes used off heap by the compression meta-data
     */
    public long getCompressionMetadataOffHeapSize()
    {
<span class="pc bpc" id="L693" title="1 of 2 branches missed.">        if (!compression)</span>
<span class="nc" id="L694">            return 0;</span>

<span class="fc" id="L696">        return getCompressionMetadata().offHeapSize();</span>
    }

    /**
     * Calculates an estimate of the number of keys in the sstable represented by this reader.
     */
    public abstract long estimatedKeys();

    /**
     * Calculates an estimate of the number of keys for the given ranges in the sstable represented by this reader.
     */
    public abstract long estimatedKeysForRanges(Collection&lt;Range&lt;Token&gt;&gt; ranges);

    /**
     * Returns whether methods like {@link #estimatedKeys()} or {@link #estimatedKeysForRanges(Collection)} can return
     * sensible estimations.
     */
    public abstract boolean isEstimationInformative();

    /**
     * Returns sample keys for the provided token range.
     */
    public abstract Iterable&lt;DecoratedKey&gt; getKeySamples(final Range&lt;Token&gt; range);

    /**
     * Determine the minimal set of sections that can be extracted from this SSTable to cover the given ranges.
     *
     * @return A sorted list of (offset,end) pairs that cover the given ranges in the datafile for this SSTable.
     */
    public List&lt;PartitionPositionBounds&gt; getPositionsForRanges(Collection&lt;Range&lt;Token&gt;&gt; ranges)
    {
        // use the index to determine a minimal section for each range
<span class="fc" id="L728">        List&lt;PartitionPositionBounds&gt; positions = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">        for (Range&lt;Token&gt; range : Range.normalize(ranges))</span>
        {
<span class="pc bpc" id="L731" title="1 of 4 branches missed.">            assert !range.isWrapAround() || range.right.isMinimum();</span>
            // truncate the range so it at most covers the sstable
<span class="fc" id="L733">            AbstractBounds&lt;PartitionPosition&gt; bounds = Range.makeRowRange(range);</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">            PartitionPosition leftBound = bounds.left.compareTo(first) &gt; 0 ? bounds.left : first.getToken().minKeyBound();</span>
<span class="fc bfc" id="L735" title="All 2 branches covered.">            PartitionPosition rightBound = bounds.right.isMinimum() ? last.getToken().maxKeyBound() : bounds.right;</span>

<span class="fc bfc" id="L737" title="All 4 branches covered.">            if (leftBound.compareTo(last) &gt; 0 || rightBound.compareTo(first) &lt; 0)</span>
<span class="fc" id="L738">                continue;</span>

<span class="fc" id="L740">            long left = getPosition(leftBound, Operator.GT);</span>
<span class="fc bfc" id="L741" title="All 2 branches covered.">            long right = (rightBound.compareTo(last) &gt; 0)</span>
<span class="fc" id="L742">                         ? uncompressedLength()</span>
<span class="fc" id="L743">                         : getPosition(rightBound, Operator.GT);</span>

<span class="fc bfc" id="L745" title="All 2 branches covered.">            if (left == right)</span>
                // empty range
<span class="fc" id="L747">                continue;</span>

<span class="pc bpc" id="L749" title="1 of 2 branches missed.">            assert left &lt; right : String.format(&quot;Range=%s openReason=%s first=%s last=%s left=%d right=%d&quot;, range, openReason, first, last, left, right);</span>
<span class="fc" id="L750">            positions.add(new PartitionPositionBounds(left, right));</span>
<span class="fc" id="L751">        }</span>
<span class="fc" id="L752">        return positions;</span>
    }

    /**
     * Retrieves the position while updating the key cache and the stats.
     *
     * @param key The key to apply as the rhs to the given Operator. A 'fake' key is allowed to
     *            allow key selection by token bounds but only if op != * EQ
     * @param op  The Operator defining matching keys: the nearest key to the target matching the operator wins.
     */
    public final long getPosition(PartitionPosition key, Operator op)
    {
<span class="fc" id="L764">        return getPosition(key, op, SSTableReadsListener.NOOP_LISTENER);</span>
    }

    public final long getPosition(PartitionPosition key, Operator op, SSTableReadsListener listener)
    {
<span class="fc" id="L769">        return getPosition(key, op, true, listener);</span>
    }

    public final long getPosition(PartitionPosition key,
                                  Operator op,
                                  boolean updateStats)
    {
<span class="nc" id="L776">        return getPosition(key, op, updateStats, SSTableReadsListener.NOOP_LISTENER);</span>
    }

    /**
     * Retrieve a position in data file according to the provided key and operator.
     *
     * @param key         The key to apply as the rhs to the given Operator. A 'fake' key is allowed to
     *                    allow key selection by token bounds but only if op != * EQ
     * @param op          The Operator defining matching keys: the nearest key to the target matching the operator wins.
     * @param updateStats true if updating stats and cache
     * @param listener    a listener used to handle internal events
     * @return The index entry corresponding to the key, or null if the key is not present
     */
    protected long getPosition(PartitionPosition key,
                               Operator op,
                               boolean updateStats,
                               SSTableReadsListener listener)
    {
<span class="nc" id="L794">        AbstractRowIndexEntry rie = getRowIndexEntry(key, op, updateStats, listener);</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">        return rie != null ? rie.position : -1;</span>
    }

    /**
     * Retrieve an index entry for the partition found according to the provided key and operator.
     *
     * @param key         The key to apply as the rhs to the given Operator. A 'fake' key is allowed to
     *                    allow key selection by token bounds but only if op != * EQ
     * @param op          The Operator defining matching keys: the nearest key to the target matching the operator wins.
     * @param updateStats true if updating stats and cache
     * @param listener    a listener used to handle internal events
     * @return The index entry corresponding to the key, or null if the key is not present
     */
    @VisibleForTesting
    protected abstract AbstractRowIndexEntry getRowIndexEntry(PartitionPosition key,
                                                              Operator op,
                                                              boolean updateStats,
                                                              SSTableReadsListener listener);

    public UnfilteredRowIterator simpleIterator(FileDataInput file, DecoratedKey key, long dataPosition, boolean tombstoneOnly)
    {
<span class="nc" id="L816">        return SSTableIdentityIterator.create(this, file, dataPosition, key, tombstoneOnly);</span>
    }

    /**
     * Returns a {@link KeyReader} over all keys in the sstable.
     */
    public abstract KeyReader keyReader() throws IOException;

    /**
     * Returns a {@link KeyIterator} over all keys in the sstable.
     */
    public KeyIterator keyIterator() throws IOException
    {
<span class="fc" id="L829">        return new KeyIterator(keyReader(), getPartitioner(), uncompressedLength(), new ReentrantReadWriteLock());</span>
    }

    /**
     * Finds and returns the first key beyond a given token in this SSTable or null if no such key exists.
     */
    public abstract DecoratedKey firstKeyBeyond(PartitionPosition token);

    /**
     * Returns the length in bytes of the (uncompressed) data for this SSTable. For compressed files, this is not
     * the same thing as the on disk size (see {@link #onDiskLength()}).
     */
    public long uncompressedLength()
    {
<span class="fc" id="L843">        return dfile.dataLength();</span>
    }

    /**
     * @return the fraction of the token space for which this sstable has content. In the simplest case this is just the
     * size of the interval returned by {@link #getBounds()}, but the sstable may contain &quot;holes&quot; when the locally-owned
     * range is not contiguous (e.g. with vnodes).
     * As this is affected by the local ranges which can change, the token space fraction is calculated at the time of
     * writing the sstable and stored with its metadata.
     * For older sstables that do not contain this metadata field, this method returns NaN.
     */
    public double tokenSpaceCoverage()
    {
<span class="nc" id="L856">        return sstableMetadata.tokenSpaceCoverage;</span>
    }

    /**
     * The length in bytes of the on disk size for this SSTable. For compressed files, this is not the same thing
     * as the data length (see {@link #uncompressedLength()}).
     */
    public long onDiskLength()
    {
<span class="fc" id="L865">        return dfile.onDiskLength;</span>
    }

    @VisibleForTesting
    public double getCrcCheckChance()
    {
<span class="nc" id="L871">        return crcCheckChance;</span>
    }

    /**
     * Set the value of CRC check chance. The argument supplied is obtained from the property of the owning CFS.
     * Called when either the SSTR is initialized, or the CFS's property is updated via JMX
     */
    public void setCrcCheckChance(double crcCheckChance)
    {
<span class="fc" id="L880">        this.crcCheckChance = crcCheckChance;</span>
<span class="fc" id="L881">        dfile.compressionMetadata().ifPresent(metadata -&gt; metadata.parameters.setCrcCheckChance(crcCheckChance));</span>
<span class="fc" id="L882">    }</span>

    /**
     * Mark the sstable as obsolete, i.e., compacted into newer sstables.
     * &lt;p&gt;
     * When calling this function, the caller must ensure that the SSTableReader is not referenced anywhere except for
     * threads holding a reference.
     * &lt;p&gt;
     * Calling it multiple times is usually buggy.
     */
    public void markObsolete(Runnable tidier)
    {
<span class="pc bpc" id="L894" title="1 of 2 branches missed.">        if (logger.isTraceEnabled())</span>
<span class="nc" id="L895">            logger.trace(&quot;Marking {} compacted&quot;, getFilename());</span>

<span class="fc" id="L897">        synchronized (tidy.global)</span>
        {
<span class="pc bpc" id="L899" title="1 of 2 branches missed.">            assert !tidy.isReplaced;</span>
<span class="pc bpc" id="L900" title="1 of 2 branches missed.">            assert tidy.global.obsoletion == null : this + &quot; was already marked compacted&quot;;</span>

<span class="fc" id="L902">            tidy.global.obsoletion = tidier;</span>
<span class="fc" id="L903">            tidy.global.stopReadMeterPersistence();</span>
<span class="fc" id="L904">        }</span>
<span class="fc" id="L905">    }</span>

    public boolean isMarkedCompacted()
    {
<span class="pc bpc" id="L909" title="1 of 2 branches missed.">        return tidy.global.obsoletion != null;</span>
    }

    public void markSuspect()
    {
<span class="nc bnc" id="L914" title="All 2 branches missed.">        if (logger.isTraceEnabled())</span>
<span class="nc" id="L915">            logger.trace(&quot;Marking {} as a suspect to be excluded from reads.&quot;, getFilename());</span>

<span class="nc" id="L917">        isSuspect.getAndSet(true);</span>
<span class="nc" id="L918">    }</span>

    @VisibleForTesting
    public void unmarkSuspect()
    {
<span class="nc" id="L923">        isSuspect.getAndSet(false);</span>
<span class="nc" id="L924">    }</span>

    public boolean isMarkedSuspect()
    {
<span class="fc" id="L928">        return isSuspect.get();</span>
    }

    /**
     * Direct I/O SSTableScanner over a defined range of tokens.
     *
     * @param range the range of keys to cover
     * @return A Scanner for seeking over the rows of the SSTable.
     */
    public ISSTableScanner getScanner(Range&lt;Token&gt; range)
    {
<span class="nc bnc" id="L939" title="All 2 branches missed.">        if (range == null)</span>
<span class="nc" id="L940">            return getScanner();</span>
<span class="nc" id="L941">        return getScanner(Collections.singletonList(range));</span>
    }

    /**
     * Direct I/O SSTableScanner over the entirety of the sstable..
     *
     * @return A Scanner over the full content of the SSTable.
     */
    public abstract ISSTableScanner getScanner();

    /**
     * Direct I/O SSTableScanner over a defined collection of ranges of tokens.
     *
     * @param ranges the range of keys to cover
     * @return A Scanner for seeking over the rows of the SSTable.
     */
    public abstract ISSTableScanner getScanner(Collection&lt;Range&lt;Token&gt;&gt; ranges);

    /**
     * Direct I/O SSTableScanner over an iterator of bounds.
     *
     * @param rangeIterator the keys to cover
     * @return A Scanner for seeking over the rows of the SSTable.
     */
    public abstract ISSTableScanner getScanner(Iterator&lt;AbstractBounds&lt;PartitionPosition&gt;&gt; rangeIterator);

    /**
     * Create a {@link FileDataInput} for the data file of the sstable represented by this reader. This method returns
     * a newly opened resource which must be closed by the caller.
     *
     * @param position the data input will be opened and seek to this position
     */
    public FileDataInput getFileDataInput(long position)
    {
<span class="fc" id="L975">        return dfile.createReader(position);</span>
    }

    /**
     * Tests if the sstable contains data newer than the given age param (in localhost currentMillis time).
     * This works in conjunction with maxDataAge which is an upper bound on the data in the sstable represented
     * by this reader.
     *
     * @return {@code true} iff this sstable contains data that's newer than the given timestamp
     */
    public boolean newSince(long timestampMillis)
    {
<span class="pc bpc" id="L987" title="1 of 2 branches missed.">        return maxDataAge &gt; timestampMillis;</span>
    }

    public void createLinks(String snapshotDirectoryPath)
    {
<span class="fc" id="L992">        createLinks(snapshotDirectoryPath, null);</span>
<span class="fc" id="L993">    }</span>

    public void createLinks(String snapshotDirectoryPath, RateLimiter rateLimiter)
    {
<span class="fc" id="L997">        createLinks(descriptor, components, snapshotDirectoryPath, rateLimiter);</span>
<span class="fc" id="L998">    }</span>

    public static void createLinks(Descriptor descriptor, Set&lt;Component&gt; components, String snapshotDirectoryPath)
    {
<span class="nc" id="L1002">        createLinks(descriptor, components, snapshotDirectoryPath, null);</span>
<span class="nc" id="L1003">    }</span>

    public static void createLinks(Descriptor descriptor, Set&lt;Component&gt; components, String snapshotDirectoryPath, RateLimiter limiter)
    {
<span class="fc bfc" id="L1007" title="All 2 branches covered.">        for (Component component : components)</span>
        {
<span class="fc" id="L1009">            File sourceFile = descriptor.fileFor(component);</span>
<span class="pc bpc" id="L1010" title="1 of 2 branches missed.">            if (!sourceFile.exists())</span>
<span class="nc" id="L1011">                continue;</span>
<span class="fc bfc" id="L1012" title="All 2 branches covered.">            if (null != limiter)</span>
<span class="fc" id="L1013">                limiter.acquire();</span>
<span class="fc" id="L1014">            File targetLink = new File(snapshotDirectoryPath, sourceFile.name());</span>
<span class="fc" id="L1015">            FileUtils.createHardLink(sourceFile, targetLink);</span>
<span class="fc" id="L1016">        }</span>
<span class="fc" id="L1017">    }</span>

    public boolean isRepaired()
    {
<span class="fc bfc" id="L1021" title="All 2 branches covered.">        return sstableMetadata.repairedAt != ActiveRepairService.UNREPAIRED_SSTABLE;</span>
    }

    /**
     * Reads the key stored at the position saved in SASI.
     * &lt;p&gt;
     * When SASI is created, it uses key locations retrieved from {@link KeyReader#keyPositionForSecondaryIndex()}.
     * This method is to read the key stored at such position. It is up to the concrete SSTable format implementation
     * what that position means and which file it refers. The only requirement is that it is consistent with what
     * {@link KeyReader#keyPositionForSecondaryIndex()} returns.
     *
     * @return key if found, {@code null} otherwise
     */
    public abstract DecoratedKey keyAtPositionFromSecondaryIndex(long keyPositionFromSecondaryIndex) throws IOException;

    public boolean isPendingRepair()
    {
<span class="fc bfc" id="L1038" title="All 2 branches covered.">        return sstableMetadata.pendingRepair != ActiveRepairService.NO_PENDING_REPAIR;</span>
    }

    public TimeUUID getPendingRepair()
    {
<span class="fc" id="L1043">        return sstableMetadata.pendingRepair;</span>
    }

    public long getRepairedAt()
    {
<span class="fc" id="L1048">        return sstableMetadata.repairedAt;</span>
    }

    public boolean isTransient()
    {
<span class="fc" id="L1053">        return sstableMetadata.isTransient;</span>
    }

    public boolean intersects(Collection&lt;Range&lt;Token&gt;&gt; ranges)
    {
<span class="fc" id="L1058">        Bounds&lt;Token&gt; range = new Bounds&lt;&gt;(first.getToken(), last.getToken());</span>
<span class="fc" id="L1059">        return Iterables.any(ranges, r -&gt; r.intersects(range));</span>
    }

    /**
     * TODO: Move someplace reusable
     */
<span class="fc" id="L1065">    public abstract static class Operator</span>
    {
<span class="fc" id="L1067">        public static final Operator EQ = new Equals();</span>
<span class="fc" id="L1068">        public static final Operator GE = new GreaterThanOrEqualTo();</span>
<span class="fc" id="L1069">        public static final Operator GT = new GreaterThan();</span>

        /**
         * @param comparison The result of a call to compare/compareTo, with the desired field on the rhs.
         * @return less than 0 if the operator cannot match forward, 0 if it matches, greater than 0 if it might match forward.
         */
        public abstract int apply(int comparison);

<span class="fc" id="L1077">        final static class Equals extends Operator</span>
        {
            public int apply(int comparison)
            {
<span class="fc" id="L1081">                return -comparison;</span>
            }
        }

<span class="fc" id="L1085">        final static class GreaterThanOrEqualTo extends Operator</span>
        {
            public int apply(int comparison)
            {
<span class="fc bfc" id="L1089" title="All 2 branches covered.">                return comparison &gt;= 0 ? 0 : 1;</span>
            }
        }

<span class="fc" id="L1093">        final static class GreaterThan extends Operator</span>
        {
            public int apply(int comparison)
            {
<span class="fc bfc" id="L1097" title="All 2 branches covered.">                return comparison &gt; 0 ? 0 : 1;</span>
            }
        }
    }

    public EstimatedHistogram getEstimatedPartitionSize()
    {
<span class="fc" id="L1104">        return sstableMetadata.estimatedPartitionSize;</span>
    }

    public EstimatedHistogram getEstimatedCellPerPartitionCount()
    {
<span class="fc" id="L1109">        return sstableMetadata.estimatedCellPerPartitionCount;</span>
    }

    public double getEstimatedDroppableTombstoneRatio(long gcBefore)
    {
<span class="fc" id="L1114">        return sstableMetadata.getEstimatedDroppableTombstoneRatio(gcBefore);</span>
    }

    public double getDroppableTombstonesBefore(long gcBefore)
    {
<span class="fc" id="L1119">        return sstableMetadata.getDroppableTombstonesBefore(gcBefore);</span>
    }

    public double getCompressionRatio()
    {
<span class="nc" id="L1124">        return sstableMetadata.compressionRatio;</span>
    }

    public long getMinTimestamp()
    {
<span class="fc" id="L1129">        return sstableMetadata.minTimestamp;</span>
    }

    public long getMaxTimestamp()
    {
<span class="fc" id="L1134">        return sstableMetadata.maxTimestamp;</span>
    }

    public long getMinLocalDeletionTime()
    {
<span class="fc" id="L1139">        return sstableMetadata.minLocalDeletionTime;</span>
    }

    public long getMaxLocalDeletionTime()
    {
<span class="fc" id="L1144">        return sstableMetadata.maxLocalDeletionTime;</span>
    }

    /**
     * Whether the sstable may contain tombstones or if it is guaranteed to not contain any.
     * &lt;p&gt;
     * Note that having that method return {@code false} guarantees the sstable has no tombstones whatsoever (so no
     * cell tombstone, no range tombstone maker and no expiring columns), but having it return {@code true} doesn't
     * guarantee it contains any as it may simply have non-expired cells.
     */
    public boolean mayHaveTombstones()
    {
        // A sstable is guaranteed to have no tombstones if minLocalDeletionTime is still set to its default,
        // Cell.NO_DELETION_TIME, which is bigger than any valid deletion times.
<span class="nc bnc" id="L1158" title="All 2 branches missed.">        return getMinLocalDeletionTime() != Cell.NO_DELETION_TIME;</span>
    }

    public int getMinTTL()
    {
<span class="fc" id="L1163">        return sstableMetadata.minTTL;</span>
    }

    public int getMaxTTL()
    {
<span class="nc" id="L1168">        return sstableMetadata.maxTTL;</span>
    }

    public long getTotalColumnsSet()
    {
<span class="nc" id="L1173">        return sstableMetadata.totalColumnsSet;</span>
    }

    public long getTotalRows()
    {
<span class="fc" id="L1178">        return sstableMetadata.totalRows;</span>
    }

    public int getAvgColumnSetPerRow()
    {
<span class="nc bnc" id="L1183" title="All 2 branches missed.">        return sstableMetadata.totalRows &lt; 0</span>
<span class="nc" id="L1184">               ? -1</span>
<span class="nc bnc" id="L1185" title="All 2 branches missed.">               : (sstableMetadata.totalRows == 0 ? 0 : (int) (sstableMetadata.totalColumnsSet / sstableMetadata.totalRows));</span>
    }

    public int getSSTableLevel()
    {
<span class="fc" id="L1190">        return sstableMetadata.sstableLevel;</span>
    }

    /**
     * Mutate sstable level with a lock to avoid racing with entire-sstable-streaming and then reload sstable metadata
     */
    public void mutateLevelAndReload(int newLevel) throws IOException
    {
<span class="fc" id="L1198">        synchronized (tidy.global)</span>
        {
<span class="fc" id="L1200">            descriptor.getMetadataSerializer().mutateLevel(descriptor, newLevel);</span>
<span class="fc" id="L1201">            reloadSSTableMetadata();</span>
<span class="fc" id="L1202">        }</span>
<span class="fc" id="L1203">    }</span>

    /**
     * Mutate sstable repair metadata with a lock to avoid racing with entire-sstable-streaming and then reload sstable metadata
     */
    public void mutateRepairedAndReload(long newRepairedAt, TimeUUID newPendingRepair, boolean isTransient) throws IOException
    {
<span class="fc" id="L1210">        synchronized (tidy.global)</span>
        {
<span class="fc" id="L1212">            descriptor.getMetadataSerializer().mutateRepairMetadata(descriptor, newRepairedAt, newPendingRepair, isTransient);</span>
<span class="fc" id="L1213">            reloadSSTableMetadata();</span>
<span class="fc" id="L1214">        }</span>
<span class="fc" id="L1215">    }</span>

    /**
     * Reloads the sstable metadata from disk.
     * &lt;p&gt;
     * Called after level is changed on sstable, for example if the sstable is dropped to L0
     * &lt;p&gt;
     * Might be possible to remove in future versions
     *
     * @throws IOException
     */
    public void reloadSSTableMetadata() throws IOException
    {
<span class="fc" id="L1228">        this.sstableMetadata = StatsComponent.load(descriptor).statsMetadata();</span>
<span class="fc" id="L1229">    }</span>

    public StatsMetadata getSSTableMetadata()
    {
<span class="fc" id="L1233">        return sstableMetadata;</span>
    }

    public RandomAccessReader openDataReader(RateLimiter limiter)
    {
<span class="pc bpc" id="L1238" title="1 of 2 branches missed.">        assert limiter != null;</span>
<span class="fc" id="L1239">        return dfile.createReader(limiter);</span>
    }

    public RandomAccessReader openDataReader()
    {
<span class="fc" id="L1244">        return dfile.createReader();</span>
    }

    public void trySkipFileCacheBefore(DecoratedKey key)
    {
<span class="nc" id="L1249">        long position = getPosition(key, SSTableReader.Operator.GE);</span>
<span class="nc bnc" id="L1250" title="All 2 branches missed.">        NativeLibrary.trySkipCache(descriptor.fileFor(Components.DATA).absolutePath(), 0, position &lt; 0 ? 0 : position);</span>
<span class="nc" id="L1251">    }</span>

    public ChannelProxy getDataChannel()
    {
<span class="fc" id="L1255">        return dfile.channel;</span>
    }

    /**
     * @return last modified time for data component. 0 if given component does not exist or IO error occurs.
     */
    public long getDataCreationTime()
    {
<span class="fc" id="L1263">        return descriptor.fileFor(Components.DATA).lastModified();</span>
    }

    /**
     * Increment the total read count and read rate for this SSTable.  This should not be incremented for non-query reads,
     * like compaction.
     */
    public void incrementReadCount()
    {
<span class="fc bfc" id="L1272" title="All 2 branches covered.">        if (readMeter != null)</span>
<span class="fc" id="L1273">            readMeter.mark();</span>
<span class="fc" id="L1274">    }</span>

    public EncodingStats stats()
    {
        // We could return sstable.header.stats(), but this may not be as accurate than the actual sstable stats (see
        // SerializationHeader.make() for details) so we use the latter instead.
<span class="fc" id="L1280">        return sstableMetadata.encodingStats;</span>
    }

    public Ref&lt;SSTableReader&gt; tryRef()
    {
<span class="fc" id="L1285">        return selfRef.tryRef();</span>
    }

    public Ref&lt;SSTableReader&gt; selfRef()
    {
<span class="fc" id="L1290">        return selfRef;</span>
    }

    public Ref&lt;SSTableReader&gt; ref()
    {
<span class="fc" id="L1295">        return selfRef.ref();</span>
    }

    protected List&lt;AutoCloseable&gt; setupInstance(boolean trackHotness)
    {
<span class="fc" id="L1300">        return Collections.singletonList(dfile);</span>
    }

    public void setup(boolean trackHotness)
    {
<span class="pc bpc" id="L1305" title="1 of 2 branches missed.">        assert tidy.closeables == null;</span>
<span class="fc" id="L1306">        trackHotness &amp;= TRACK_ACTIVITY;</span>
<span class="fc" id="L1307">        tidy.setup(this, trackHotness, setupInstance(trackHotness));</span>
<span class="fc" id="L1308">        this.readMeter = tidy.global.readMeter;</span>
<span class="fc" id="L1309">    }</span>

    @VisibleForTesting
    public void overrideReadMeter(RestorableMeter readMeter)
    {
<span class="nc" id="L1314">        this.readMeter = tidy.global.readMeter = readMeter;</span>
<span class="nc" id="L1315">    }</span>

    public void addTo(Ref.IdentityCollection identities)
    {
<span class="fc" id="L1319">        identities.add(this);</span>
<span class="fc" id="L1320">        identities.add(tidy.globalRef);</span>
<span class="fc" id="L1321">        tidy.closeables.forEach(c -&gt; {</span>
<span class="pc bpc" id="L1322" title="1 of 2 branches missed.">            if (c instanceof SharedCloseable)</span>
<span class="fc" id="L1323">                ((SharedCloseable) c).addTo(identities);</span>
<span class="fc" id="L1324">        });</span>
<span class="fc" id="L1325">    }</span>

    /**
     * The method verifies whether the sstable may contain the provided key. The method does approximation using
     * Bloom filter if it is present and if it is not, performs accurate check in the index.
     */
    public abstract boolean mayContainAssumingKeyIsInRange(DecoratedKey key);

    /**
     * One instance per SSTableReader we create.
     * &lt;p&gt;
     * We can create many InstanceTidiers (one for every time we reopen an sstable with MOVED_START for example),
     * but there can only be one GlobalTidy for one single logical sstable.
     * &lt;p&gt;
     * When the InstanceTidier cleansup, it releases its reference to its GlobalTidy; when all InstanceTidiers
     * for that type have run, the GlobalTidy cleans up.
     */
    protected static final class InstanceTidier implements Tidy
    {
        private final Descriptor descriptor;
        private final WeakReference&lt;Owner&gt; owner;

        private List&lt;? extends AutoCloseable&gt; closeables;
        private Runnable runOnClose;

<span class="fc" id="L1350">        private boolean isReplaced = false;</span>

        // a reference to our shared tidy instance, that
        // we will release when we are ourselves released
        private Ref&lt;GlobalTidy&gt; globalRef;
        private GlobalTidy global;

        private volatile boolean setup;

        public void setup(SSTableReader reader, boolean trackHotness, Collection&lt;? extends AutoCloseable&gt; closeables)
        {
            // get a new reference to the shared descriptor-type tidy
<span class="fc" id="L1362">            this.globalRef = GlobalTidy.get(reader);</span>
<span class="fc" id="L1363">            this.global = globalRef.get();</span>
<span class="fc bfc" id="L1364" title="All 2 branches covered.">            if (trackHotness)</span>
<span class="fc" id="L1365">                global.ensureReadMeter();</span>
<span class="fc" id="L1366">            this.closeables = new ArrayList&lt;&gt;(closeables);</span>
            // to avoid tidy seeing partial state, set setup=true at the end
<span class="fc" id="L1368">            this.setup = true;</span>
<span class="fc" id="L1369">        }</span>

        private InstanceTidier(Descriptor descriptor, Owner owner)
<span class="fc" id="L1372">        {</span>
<span class="fc" id="L1373">            this.descriptor = descriptor;</span>
<span class="fc" id="L1374">            this.owner = new WeakReference&lt;&gt;(owner);</span>
<span class="fc" id="L1375">        }</span>

        @Override
        public void tidy()
        {
<span class="pc bpc" id="L1380" title="1 of 2 branches missed.">            if (logger.isTraceEnabled())</span>
<span class="nc" id="L1381">                logger.trace(&quot;Running instance tidier for {} with setup {}&quot;, descriptor, setup);</span>

            // don't try to cleanup if the sstablereader was never fully constructed
<span class="pc bpc" id="L1384" title="1 of 2 branches missed.">            if (!setup)</span>
<span class="nc" id="L1385">                return;</span>

            final OpOrder.Barrier barrier;
<span class="fc" id="L1388">            Owner owner = this.owner.get();</span>
<span class="fc bfc" id="L1389" title="All 2 branches covered.">            if (owner != null)</span>
            {
<span class="fc" id="L1391">                barrier = owner.newReadOrderingBarrier();</span>
<span class="fc" id="L1392">                barrier.issue();</span>
            }
            else
            {
<span class="fc" id="L1396">                barrier = null;</span>
            }

<span class="fc" id="L1399">            ScheduledExecutors.nonPeriodicTasks.execute(new Runnable()</span>
<span class="fc" id="L1400">            {</span>
                public void run()
                {
<span class="pc bpc" id="L1403" title="1 of 2 branches missed.">                    if (logger.isTraceEnabled())</span>
<span class="nc" id="L1404">                        logger.trace(&quot;Async instance tidier for {}, before barrier&quot;, descriptor);</span>

<span class="fc bfc" id="L1406" title="All 2 branches covered.">                    if (barrier != null)</span>
<span class="fc" id="L1407">                        barrier.await();</span>

<span class="pc bpc" id="L1409" title="1 of 2 branches missed.">                    if (logger.isTraceEnabled())</span>
<span class="nc" id="L1410">                        logger.trace(&quot;Async instance tidier for {}, after barrier&quot;, descriptor);</span>

<span class="fc" id="L1412">                    Throwable exceptions = null;</span>
<span class="fc bfc" id="L1413" title="All 2 branches covered.">                    if (runOnClose != null) try</span>
                    {
<span class="fc" id="L1415">                        runOnClose.run();</span>
                    }
<span class="nc" id="L1417">                    catch (RuntimeException | Error ex)</span>
                    {
<span class="nc" id="L1419">                        logger.error(&quot;Failed to run on-close listeners for sstable &quot; + descriptor.baseFile(), ex);</span>
<span class="nc" id="L1420">                        exceptions = ex;</span>
<span class="fc" id="L1421">                    }</span>

<span class="fc" id="L1423">                    Throwable closeExceptions = Throwables.close(null, Iterables.filter(closeables, Objects::nonNull));</span>
<span class="pc bpc" id="L1424" title="1 of 2 branches missed.">                    if (closeExceptions != null)</span>
                    {
<span class="nc" id="L1426">                        logger.error(&quot;Failed to close some sstable components of &quot; + descriptor.baseFile(), closeExceptions);</span>
<span class="nc" id="L1427">                        exceptions = Throwables.merge(exceptions, closeExceptions);</span>
                    }

                    try
                    {
<span class="fc" id="L1432">                        globalRef.release();</span>
                    }
<span class="nc" id="L1434">                    catch (RuntimeException | Error ex)</span>
                    {
<span class="nc" id="L1436">                        logger.error(&quot;Failed to release the global ref of &quot; + descriptor.baseFile(), ex);</span>
<span class="nc" id="L1437">                        exceptions = Throwables.merge(exceptions, ex);</span>
<span class="fc" id="L1438">                    }</span>

<span class="pc bpc" id="L1440" title="1 of 2 branches missed.">                    if (exceptions != null)</span>
<span class="nc" id="L1441">                        JVMStabilityInspector.inspectThrowable(exceptions);</span>

<span class="pc bpc" id="L1443" title="1 of 2 branches missed.">                    if (logger.isTraceEnabled())</span>
<span class="nc" id="L1444">                        logger.trace(&quot;Async instance tidier for {}, completed&quot;, descriptor);</span>
<span class="fc" id="L1445">                }</span>

                @Override
                public String toString()
                {
<span class="nc" id="L1450">                    return &quot;Tidy &quot; + descriptor.ksname + '.' + descriptor.cfname + '-' + descriptor.id;</span>
                }
            });
<span class="fc" id="L1453">        }</span>

        @Override
        public String name()
        {
<span class="fc" id="L1458">            return descriptor.toString();</span>
        }
    }

    /**
     * One instance per logical sstable. This both tracks shared cleanup and some shared state related
     * to the sstable's lifecycle.
     * &lt;p&gt;
     * All InstanceTidiers, on setup(), ask the static get() method for their shared state,
     * and stash a reference to it to be released when they are. Once all such references are
     * released, this shared tidy will be performed.
     */
    static final class GlobalTidy implements Tidy
    {
<span class="fc" id="L1472">        static final WeakReference&lt;ScheduledFuture&lt;?&gt;&gt; NULL = new WeakReference&lt;&gt;(null);</span>
        // keyed by descriptor, mapping to the shared GlobalTidy for that descriptor
<span class="fc" id="L1474">        static final ConcurrentMap&lt;Descriptor, Ref&lt;GlobalTidy&gt;&gt; lookup = new ConcurrentHashMap&lt;&gt;();</span>

        private final Descriptor desc;
        // the readMeter that is shared between all instances of the sstable, and can be overridden in all of them
        // at once also, for testing purposes
        private RestorableMeter readMeter;
        // the scheduled persistence of the readMeter, that we will cancel once all instances of this logical
        // sstable have been released
<span class="fc" id="L1482">        private WeakReference&lt;ScheduledFuture&lt;?&gt;&gt; readMeterSyncFuture = NULL;</span>
        // shared state managing if the logical sstable has been compacted; this is used in cleanup
        private volatile Runnable obsoletion;

        GlobalTidy(final SSTableReader reader)
<span class="fc" id="L1487">        {</span>
<span class="fc" id="L1488">            this.desc = reader.descriptor;</span>
<span class="fc" id="L1489">        }</span>

        void ensureReadMeter()
        {
<span class="fc bfc" id="L1493" title="All 2 branches covered.">            if (readMeter != null)</span>
<span class="fc" id="L1494">                return;</span>

            // Don't track read rates for tables in the system keyspace and don't bother trying to load or persist
            // the read meter when in client mode.
            // Also, do not track read rates when running in client or tools mode (syncExecuter isn't available in these modes)
<span class="pc bpc" id="L1499" title="2 of 6 branches missed.">            if (!TRACK_ACTIVITY || SchemaConstants.isLocalSystemKeyspace(desc.ksname) || DatabaseDescriptor.isClientOrToolInitialized())</span>
            {
<span class="fc" id="L1501">                readMeter = null;</span>
<span class="fc" id="L1502">                readMeterSyncFuture = NULL;</span>
<span class="fc" id="L1503">                return;</span>
            }

<span class="fc" id="L1506">            readMeter = SystemKeyspace.getSSTableReadMeter(desc.ksname, desc.cfname, desc.id);</span>
            // sync the average read rate to system.sstable_activity every five minutes, starting one minute from now
<span class="fc" id="L1508">            readMeterSyncFuture = new WeakReference&lt;&gt;(syncExecutor.scheduleAtFixedRate(this::maybePersistSSTableReadMeter, 1, 5, TimeUnit.MINUTES));</span>
<span class="fc" id="L1509">        }</span>

        void maybePersistSSTableReadMeter()
        {
<span class="pc bpc" id="L1513" title="2 of 4 branches missed.">            if (obsoletion == null &amp;&amp; DatabaseDescriptor.getSStableReadRatePersistenceEnabled())</span>
            {
<span class="nc" id="L1515">                meterSyncThrottle.acquire();</span>
<span class="nc" id="L1516">                SystemKeyspace.persistSSTableReadMeter(desc.ksname, desc.cfname, desc.id, readMeter);</span>
            }
<span class="fc" id="L1518">        }</span>

        private void stopReadMeterPersistence()
        {
<span class="fc" id="L1522">            ScheduledFuture&lt;?&gt; readMeterSyncFutureLocal = readMeterSyncFuture.get();</span>
<span class="fc bfc" id="L1523" title="All 2 branches covered.">            if (readMeterSyncFutureLocal != null)</span>
            {
<span class="fc" id="L1525">                readMeterSyncFutureLocal.cancel(true);</span>
<span class="fc" id="L1526">                readMeterSyncFuture = NULL;</span>
            }
<span class="fc" id="L1528">        }</span>

        public void tidy()
        {
<span class="fc" id="L1532">            lookup.remove(desc);</span>

<span class="fc bfc" id="L1534" title="All 2 branches covered.">            if (obsoletion != null)</span>
<span class="fc" id="L1535">                obsoletion.run();</span>

            // don't ideally want to dropPageCache for the file until all instances have been released
<span class="fc bfc" id="L1538" title="All 2 branches covered.">            for (Component c : desc.discoverComponents())</span>
<span class="fc" id="L1539">                NativeLibrary.trySkipCache(desc.fileFor(c).absolutePath(), 0, 0);</span>
<span class="fc" id="L1540">        }</span>

        public String name()
        {
<span class="fc" id="L1544">            return desc.toString();</span>
        }

        // get a new reference to the shared GlobalTidy for this sstable
        @SuppressWarnings(&quot;resource&quot;)
        public static Ref&lt;GlobalTidy&gt; get(SSTableReader sstable)
        {
<span class="fc" id="L1551">            Descriptor descriptor = sstable.descriptor;</span>

            while (true)
            {
<span class="fc" id="L1555">                Ref&lt;GlobalTidy&gt; ref = lookup.get(descriptor);</span>
<span class="fc bfc" id="L1556" title="All 2 branches covered.">                if (ref == null)</span>
                {
<span class="fc" id="L1558">                    final GlobalTidy tidy = new GlobalTidy(sstable);</span>
<span class="fc" id="L1559">                    ref = new Ref&lt;&gt;(tidy, tidy);</span>
<span class="fc" id="L1560">                    Ref&lt;GlobalTidy&gt; ex = lookup.putIfAbsent(descriptor, ref);</span>
<span class="pc bpc" id="L1561" title="1 of 2 branches missed.">                    if (ex == null)</span>
<span class="fc" id="L1562">                        return ref;</span>
<span class="nc" id="L1563">                    ref = ex;</span>
                }

<span class="fc" id="L1566">                Ref&lt;GlobalTidy&gt; newRef = ref.tryRef();</span>
<span class="pc bpc" id="L1567" title="1 of 2 branches missed.">                if (newRef != null)</span>
<span class="fc" id="L1568">                    return newRef;</span>

                // raced with tidy
<span class="nc" id="L1571">                lookup.remove(descriptor, ref);</span>
<span class="nc" id="L1572">            }</span>
        }
    }

    @VisibleForTesting
    public static void resetTidying()
    {
<span class="fc" id="L1579">        GlobalTidy.lookup.clear();</span>
<span class="fc" id="L1580">    }</span>

    public static class PartitionPositionBounds
    {
        public final long lowerPosition;
        public final long upperPosition;

        public PartitionPositionBounds(long lower, long upper)
<span class="fc" id="L1588">        {</span>
<span class="fc" id="L1589">            this.lowerPosition = lower;</span>
<span class="fc" id="L1590">            this.upperPosition = upper;</span>
<span class="fc" id="L1591">        }</span>

        @Override
        public final int hashCode()
        {
<span class="fc" id="L1596">            int hashCode = (int) lowerPosition ^ (int) (lowerPosition &gt;&gt;&gt; 32);</span>
<span class="fc" id="L1597">            return 31 * (hashCode ^ (int) ((int) upperPosition ^ (upperPosition &gt;&gt;&gt; 32)));</span>
        }

        @Override
        public final boolean equals(Object o)
        {
<span class="nc bnc" id="L1603" title="All 2 branches missed.">            if (!(o instanceof PartitionPositionBounds))</span>
<span class="nc" id="L1604">                return false;</span>
<span class="nc" id="L1605">            PartitionPositionBounds that = (PartitionPositionBounds) o;</span>
<span class="nc bnc" id="L1606" title="All 4 branches missed.">            return lowerPosition == that.lowerPosition &amp;&amp; upperPosition == that.upperPosition;</span>
        }
    }

    public static class IndexesBounds
    {
        public final int lowerPosition;
        public final int upperPosition;

        public IndexesBounds(int lower, int upper)
<span class="fc" id="L1616">        {</span>
<span class="fc" id="L1617">            this.lowerPosition = lower;</span>
<span class="fc" id="L1618">            this.upperPosition = upper;</span>
<span class="fc" id="L1619">        }</span>

        @Override
        public final int hashCode()
        {
<span class="nc" id="L1624">            return 31 * lowerPosition * upperPosition;</span>
        }

        @Override
        public final boolean equals(Object o)
        {
<span class="nc bnc" id="L1630" title="All 2 branches missed.">            if (!(o instanceof IndexesBounds))</span>
<span class="nc" id="L1631">                return false;</span>
<span class="nc" id="L1632">            IndexesBounds that = (IndexesBounds) o;</span>
<span class="nc bnc" id="L1633" title="All 4 branches missed.">            return lowerPosition == that.lowerPosition &amp;&amp; upperPosition == that.upperPosition;</span>
        }
    }

    /**
     * Moves the sstable in oldDescriptor to a new place (with generation etc) in newDescriptor.
     * &lt;p&gt;
     * All components given will be moved/renamed
     */
    public static SSTableReader moveAndOpenSSTable(ColumnFamilyStore cfs, Descriptor oldDescriptor, Descriptor newDescriptor, Set&lt;Component&gt; components, boolean copyData)
    {
<span class="pc bpc" id="L1644" title="1 of 2 branches missed.">        if (!oldDescriptor.isCompatible())</span>
<span class="nc" id="L1645">            throw new RuntimeException(String.format(&quot;Can't open incompatible SSTable! Current version %s, found file: %s&quot;,</span>
<span class="nc" id="L1646">                                                     oldDescriptor.getFormat().getLatestVersion(),</span>
                                                     oldDescriptor));

<span class="pc bpc" id="L1649" title="1 of 2 branches missed.">        boolean isLive = cfs.getLiveSSTables().stream().anyMatch(r -&gt; r.descriptor.equals(newDescriptor)</span>
<span class="pc bpc" id="L1650" title="1 of 2 branches missed.">                                                                      || r.descriptor.equals(oldDescriptor));</span>
<span class="pc bpc" id="L1651" title="1 of 2 branches missed.">        if (isLive)</span>
        {
<span class="nc" id="L1653">            String message = String.format(&quot;Can't move and open a file that is already in use in the table %s -&gt; %s&quot;, oldDescriptor, newDescriptor);</span>
<span class="nc" id="L1654">            logger.error(message);</span>
<span class="nc" id="L1655">            throw new RuntimeException(message);</span>
        }
<span class="pc bpc" id="L1657" title="1 of 2 branches missed.">        if (newDescriptor.fileFor(Components.DATA).exists())</span>
        {
<span class="nc" id="L1659">            String msg = String.format(&quot;File %s already exists, can't move the file there&quot;, newDescriptor.fileFor(Components.DATA));</span>
<span class="nc" id="L1660">            logger.error(msg);</span>
<span class="nc" id="L1661">            throw new RuntimeException(msg);</span>
        }

<span class="fc bfc" id="L1664" title="All 2 branches covered.">        if (copyData)</span>
        {
            try
            {
<span class="fc" id="L1668">                logger.info(&quot;Hardlinking new SSTable {} to {}&quot;, oldDescriptor, newDescriptor);</span>
<span class="fc" id="L1669">                hardlink(oldDescriptor, newDescriptor, components);</span>
            }
<span class="nc" id="L1671">            catch (FSWriteError ex)</span>
            {
<span class="nc" id="L1673">                logger.warn(&quot;Unable to hardlink new SSTable {} to {}, falling back to copying&quot;, oldDescriptor, newDescriptor, ex);</span>
<span class="nc" id="L1674">                copy(oldDescriptor, newDescriptor, components);</span>
<span class="pc" id="L1675">            }</span>
        }
        else
        {
<span class="fc" id="L1679">            logger.info(&quot;Moving new SSTable {} to {}&quot;, oldDescriptor, newDescriptor);</span>
<span class="fc" id="L1680">            rename(oldDescriptor, newDescriptor, components);</span>
        }

        SSTableReader reader;
        try
        {
<span class="fc" id="L1686">            reader = open(cfs, newDescriptor, components, cfs.metadata);</span>
        }
<span class="nc" id="L1688">        catch (Throwable t)</span>
        {
<span class="nc" id="L1690">            logger.error(&quot;Aborting import of sstables. {} was corrupt&quot;, newDescriptor);</span>
<span class="nc" id="L1691">            throw new RuntimeException(newDescriptor + &quot; is corrupt, can't import&quot;, t);</span>
<span class="fc" id="L1692">        }</span>
<span class="fc" id="L1693">        return reader;</span>
    }

    public static void shutdownBlocking(long timeout, TimeUnit unit) throws InterruptedException, TimeoutException
    {

<span class="fc" id="L1699">        ExecutorUtils.shutdownNowAndWait(timeout, unit, syncExecutor);</span>
<span class="fc" id="L1700">        resetTidying();</span>
<span class="fc" id="L1701">    }</span>

    /**
     * @return the physical size on disk of all components for this SSTable in bytes
     */
    public long bytesOnDisk()
    {
<span class="fc" id="L1708">        return bytesOnDisk(false);</span>
    }

    /**
     * @return the total logical/uncompressed size in bytes of all components for this SSTable
     */
    public long logicalBytesOnDisk()
    {
<span class="fc" id="L1716">        return bytesOnDisk(true);</span>
    }

    private long bytesOnDisk(boolean logical)
    {
<span class="fc" id="L1721">        long bytes = 0;</span>
<span class="fc bfc" id="L1722" title="All 2 branches covered.">        for (Component component : components)</span>
        {
            // Only the data file is compressable.
<span class="fc bfc" id="L1725" title="All 6 branches covered.">            bytes += logical &amp;&amp; component == Components.DATA &amp;&amp; compression</span>
<span class="fc" id="L1726">                     ? getCompressionMetadata().dataLength</span>
<span class="fc" id="L1727">                     : descriptor.fileFor(component).length();</span>
<span class="fc" id="L1728">        }</span>
<span class="fc" id="L1729">        return bytes;</span>
    }

    @VisibleForTesting
    public void maybePersistSSTableReadMeter()
    {
<span class="nc" id="L1735">        tidy.global.maybePersistSSTableReadMeter();</span>
<span class="nc" id="L1736">    }</span>

    /**
     * Returns a new verifier for this sstable. Note that the reader must match the provided cfs.
     */
    public abstract IVerifier getVerifier(ColumnFamilyStore cfs,
                                          OutputHandler outputHandler,
                                          boolean isOffline,
                                          IVerifier.Options options);

    /**
     * A method to be called by {@link #getPosition(PartitionPosition, Operator, boolean, SSTableReadsListener)}
     * and {@link #getRowIndexEntry(PartitionPosition, Operator, boolean, SSTableReadsListener)} methods when
     * a searched key is found. It adds a trace message and notify the provided listener.
     */
    protected void notifySelected(SSTableReadsListener.SelectionReason reason, SSTableReadsListener localListener, Operator op, boolean updateStats, AbstractRowIndexEntry entry)
    {
<span class="fc" id="L1753">        reason.trace(descriptor, entry);</span>

<span class="pc bpc" id="L1755" title="1 of 2 branches missed.">        if (localListener != null)</span>
<span class="fc" id="L1756">            localListener.onSSTableSelected(this, reason);</span>
<span class="fc" id="L1757">    }</span>

    /**
     * A method to be called by {@link #getPosition(PartitionPosition, Operator, boolean, SSTableReadsListener)}
     * and {@link #getRowIndexEntry(PartitionPosition, Operator, boolean, SSTableReadsListener)} methods when
     * a searched key is not found. It adds a trace message and notify the provided listener.
     */
    protected void notifySkipped(SSTableReadsListener.SkippingReason reason, SSTableReadsListener localListener, Operator op, boolean updateStats)
    {
<span class="fc" id="L1766">        reason.trace(descriptor);</span>

<span class="pc bpc" id="L1768" title="1 of 2 branches missed.">        if (localListener != null)</span>
<span class="fc" id="L1769">            localListener.onSSTableSkipped(this, reason);</span>
<span class="fc" id="L1770">    }</span>

    /**
     * A builder of this sstable reader. It should be extended for each implementation of {@link SSTableReader} with
     * the implementation specific fields.
     *
     * @param &lt;R&gt; type of the reader the builder creates
     * @param &lt;B&gt; type of this builder
     */
    public abstract static class Builder&lt;R extends SSTableReader, B extends Builder&lt;R, B&gt;&gt; extends SSTable.Builder&lt;R, B&gt;
    {
        private long maxDataAge;
        private StatsMetadata statsMetadata;
        private OpenReason openReason;
        private SerializationHeader serializationHeader;
        private FileHandle dataFile;
        private DecoratedKey first;
        private DecoratedKey last;
        private boolean suspected;

        public Builder(Descriptor descriptor)
        {
<span class="fc" id="L1792">            super(descriptor);</span>
<span class="fc" id="L1793">        }</span>

        public B setMaxDataAge(long maxDataAge)
        {
<span class="pc bpc" id="L1797" title="1 of 2 branches missed.">            Preconditions.checkArgument(maxDataAge &gt;= 0);</span>
<span class="fc" id="L1798">            this.maxDataAge = maxDataAge;</span>
<span class="fc" id="L1799">            return (B) this;</span>
        }

        public B setStatsMetadata(StatsMetadata statsMetadata)
        {
<span class="fc" id="L1804">            Preconditions.checkNotNull(statsMetadata);</span>
<span class="fc" id="L1805">            this.statsMetadata = statsMetadata;</span>
<span class="fc" id="L1806">            return (B) this;</span>
        }

        public B setOpenReason(OpenReason openReason)
        {
<span class="fc" id="L1811">            Preconditions.checkNotNull(openReason);</span>
<span class="fc" id="L1812">            this.openReason = openReason;</span>
<span class="fc" id="L1813">            return (B) this;</span>
        }

        public B setSerializationHeader(SerializationHeader serializationHeader)
        {
<span class="fc" id="L1818">            this.serializationHeader = serializationHeader;</span>
<span class="fc" id="L1819">            return (B) this;</span>
        }

        public B setDataFile(FileHandle dataFile)
        {
<span class="fc" id="L1824">            this.dataFile = dataFile;</span>
<span class="fc" id="L1825">            return (B) this;</span>
        }

        public B setFirst(DecoratedKey first)
        {
<span class="pc bpc" id="L1830" title="1 of 2 branches missed.">            this.first = first != null ? first.retainable() : null;</span>
<span class="fc" id="L1831">            return (B) this;</span>
        }

        public B setLast(DecoratedKey last)
        {
<span class="pc bpc" id="L1836" title="1 of 2 branches missed.">            this.last = last != null ? last.retainable() : null;</span>
<span class="fc" id="L1837">            return (B) this;</span>
        }

        public B setSuspected(boolean suspected)
        {
<span class="fc" id="L1842">            this.suspected = suspected;</span>
<span class="fc" id="L1843">            return (B) this;</span>
        }

        public long getMaxDataAge()
        {
<span class="fc" id="L1848">            return maxDataAge;</span>
        }

        public StatsMetadata getStatsMetadata()
        {
<span class="fc" id="L1853">            return statsMetadata;</span>
        }

        public OpenReason getOpenReason()
        {
<span class="fc" id="L1858">            return openReason;</span>
        }

        public SerializationHeader getSerializationHeader()
        {
<span class="fc" id="L1863">            return serializationHeader;</span>
        }

        public FileHandle getDataFile()
        {
<span class="fc" id="L1868">            return dataFile;</span>
        }

        public DecoratedKey getFirst()
        {
<span class="fc" id="L1873">            return first;</span>
        }

        public DecoratedKey getLast()
        {
<span class="fc" id="L1878">            return last;</span>
        }

        public boolean isSuspected()
        {
<span class="fc" id="L1883">            return suspected;</span>
        }

        protected abstract R buildInternal(Owner owner);

        public R build(Owner owner, boolean validate, boolean online)
        {
<span class="fc" id="L1890">            R reader = buildInternal(owner);</span>

            try
            {
<span class="pc bpc" id="L1894" title="1 of 2 branches missed.">                if (isSuspected())</span>
<span class="nc" id="L1895">                    reader.markSuspect();</span>

<span class="fc" id="L1897">                reader.setup(online);</span>

<span class="pc bpc" id="L1899" title="1 of 2 branches missed.">                if (validate)</span>
<span class="fc" id="L1900">                    reader.validate();</span>
            }
<span class="nc" id="L1902">            catch (RuntimeException | Error ex)</span>
            {
<span class="nc" id="L1904">                JVMStabilityInspector.inspectThrowable(ex);</span>
<span class="nc" id="L1905">                reader.selfRef().release();</span>
<span class="nc" id="L1906">                throw ex;</span>
<span class="fc" id="L1907">            }</span>

<span class="fc" id="L1909">            return reader;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>