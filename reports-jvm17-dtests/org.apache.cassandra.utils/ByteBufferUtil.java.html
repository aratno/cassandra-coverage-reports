<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ByteBufferUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.utils</a> &gt; <span class="el_source">ByteBufferUtil.java</span></div><h1>ByteBufferUtil.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.utils;

/*
 * BE ADVISED: New imports added here might introduce new dependencies for
 * the clientutil jar.  If in doubt, run the `ant test-clientutil-jar' target
 * afterward, and ensure the tests still pass.
 */

import java.io.DataInput;
import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.net.InetAddress;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.UUID;

import net.nicoulaj.compilecommand.annotations.Inline;
import org.apache.cassandra.db.TypeSizes;
import org.apache.cassandra.io.compress.BufferType;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.io.util.FileUtils;

/**
 * Utility methods to make ByteBuffers less painful
 * The following should illustrate the different ways byte buffers can be used
 *
 *        public void testArrayOffet()
 *        {
 *
 *            byte[] b = &quot;test_slice_array&quot;.getBytes();
 *            ByteBuffer bb = ByteBuffer.allocate(1024);
 *
 *            assert bb.position() == 0;
 *            assert bb.limit()    == 1024;
 *            assert bb.capacity() == 1024;
 *
 *            bb.put(b);
 *
 *            assert bb.position()  == b.length;
 *            assert bb.remaining() == bb.limit() - bb.position();
 *
 *            ByteBuffer bb2 = bb.slice();
 *
 *            assert bb2.position()    == 0;
 *
 *            //slice should begin at other buffers current position
 *            assert bb2.arrayOffset() == bb.position();
 *
 *            //to match the position in the underlying array one needs to
 *            //track arrayOffset
 *            assert bb2.limit()+bb2.arrayOffset() == bb.limit();
 *
 *
 *            assert bb2.remaining() == bb.remaining();
 *
 *        }
 *
 * }
 *
 */
<span class="nc" id="L84">public class ByteBufferUtil</span>
{
<span class="fc" id="L86">    public static final ByteBuffer EMPTY_BYTE_BUFFER = ByteBuffer.wrap(new byte[0]);</span>
    /** Represents an unset value in bound variables */
<span class="fc" id="L88">    public static final ByteBuffer UNSET_BYTE_BUFFER = ByteBuffer.wrap(new byte[]{});</span>

<span class="fc" id="L90">    public static final ByteBuffer[] EMPTY_ARRAY = new ByteBuffer[0];</span>

    @Inline
    public static int compareUnsigned(ByteBuffer o1, ByteBuffer o2)
    {
<span class="fc" id="L95">        return FastByteOperations.compareUnsigned(o1, o2);</span>
    }

    @Inline
    public static int compare(byte[] o1, ByteBuffer o2)
    {
<span class="fc" id="L101">        return FastByteOperations.compareUnsigned(o1, 0, o1.length, o2);</span>
    }

    @Inline
    public static int compare(ByteBuffer o1, byte[] o2)
    {
<span class="fc" id="L107">        return FastByteOperations.compareUnsigned(o1, o2, 0, o2.length);</span>
    }

    public static int compare(ByteBuffer o1, int s1, int l1, byte[] o2)
    {
<span class="fc" id="L112">        return FastByteOperations.compareUnsigned(o1, s1, l1, o2, 0, o2.length);</span>
    }

    public static int compare(byte[] o1, ByteBuffer o2, int s2, int l2)
    {
<span class="nc" id="L117">        return FastByteOperations.compareUnsigned(o1, 0, o1.length, o2, s2, l2);</span>
    }

    /**
     * Decode a String representation.
     * This method assumes that the encoding charset is UTF_8.
     *
     * @param buffer a byte buffer holding the string representation
     * @return the decoded string
     */
    public static String string(ByteBuffer buffer) throws CharacterCodingException
    {
<span class="fc" id="L129">        return string(buffer, StandardCharsets.UTF_8);</span>
    }

    /**
     * Decode a String representation.
     * This method assumes that the encoding charset is UTF_8.
     *
     * @param buffer a byte buffer holding the string representation
     * @param position the starting position in {@code buffer} to start decoding from
     * @param length the number of bytes from {@code buffer} to use
     * @return the decoded string
     */
    public static String string(ByteBuffer buffer, int position, int length) throws CharacterCodingException
    {
<span class="nc" id="L143">        return string(buffer, position, length, StandardCharsets.UTF_8);</span>
    }

    /**
     * Decode a String representation.
     *
     * @param buffer a byte buffer holding the string representation
     * @param position the starting position in {@code buffer} to start decoding from
     * @param length the number of bytes from {@code buffer} to use
     * @param charset the String encoding charset
     * @return the decoded string
     */
    public static String string(ByteBuffer buffer, int position, int length, Charset charset) throws CharacterCodingException
    {
<span class="nc" id="L157">        ByteBuffer copy = buffer.duplicate();</span>
<span class="nc" id="L158">        copy.position(position);</span>
<span class="nc" id="L159">        copy.limit(copy.position() + length);</span>
<span class="nc" id="L160">        return string(copy, charset);</span>
    }

    /**
     * Decode a String representation.
     *
     * @param buffer a byte buffer holding the string representation
     * @param charset the String encoding charset
     * @return the decoded string
     */
    public static String string(ByteBuffer buffer, Charset charset) throws CharacterCodingException
    {
<span class="fc" id="L172">        return charset.newDecoder().decode(buffer.duplicate()).toString();</span>
    }

    /**
     * You should almost never use this.  Instead, use the write* methods to avoid copies.
     */
    public static byte[] getArray(ByteBuffer buffer)
    {
<span class="fc" id="L180">        return getArray(buffer, buffer.position(), buffer.remaining());</span>
    }

    /**
     * You should almost never use this.  Instead, use the write* methods to avoid copies.
     */
    public static byte[] getArray(ByteBuffer buffer, int position, int length)
    {
<span class="fc bfc" id="L188" title="All 2 branches covered.">        if (buffer.hasArray())</span>
        {
<span class="fc" id="L190">            int boff = buffer.arrayOffset() + position;</span>
<span class="fc" id="L191">            return Arrays.copyOfRange(buffer.array(), boff, boff + length);</span>
        }

        // else, DirectByteBuffer.get() is the fastest route
<span class="fc" id="L195">        byte[] bytes = new byte[length];</span>
<span class="fc" id="L196">        ByteBuffer dup = buffer.duplicate();</span>
<span class="fc" id="L197">        dup.position(position).limit(position + length);</span>
<span class="fc" id="L198">        dup.get(bytes);</span>
<span class="fc" id="L199">        return bytes;</span>
    }

    /**
     * ByteBuffer adaptation of org.apache.commons.lang3.ArrayUtils.lastIndexOf method
     *
     * @param buffer the array to traverse for looking for the object, may be &lt;code&gt;null&lt;/code&gt;
     * @param valueToFind the value to find
     * @param startIndex the start index (i.e. BB position) to travers backwards from
     * @return the last index (i.e. BB position) of the value within the array
     * [between buffer.position() and buffer.limit()]; &lt;code&gt;-1&lt;/code&gt; if not found.
     */
    public static int lastIndexOf(ByteBuffer buffer, byte valueToFind, int startIndex)
    {
<span class="nc bnc" id="L213" title="All 2 branches missed.">        assert buffer != null;</span>

<span class="nc bnc" id="L215" title="All 2 branches missed.">        if (startIndex &lt; buffer.position())</span>
        {
<span class="nc" id="L217">            return -1;</span>
        }
<span class="nc bnc" id="L219" title="All 2 branches missed.">        else if (startIndex &gt;= buffer.limit())</span>
        {
<span class="nc" id="L221">            startIndex = buffer.limit() - 1;</span>
        }

<span class="nc bnc" id="L224" title="All 2 branches missed.">        for (int i = startIndex; i &gt;= buffer.position(); i--)</span>
        {
<span class="nc bnc" id="L226" title="All 2 branches missed.">            if (valueToFind == buffer.get(i))</span>
<span class="nc" id="L227">                return i;</span>
        }

<span class="nc" id="L230">        return -1;</span>
    }

    /**
     * Encode a String in a ByteBuffer using UTF_8.
     *
     * @param s the string to encode
     * @return the encoded string
     */
    public static ByteBuffer bytes(String s)
    {
<span class="fc" id="L241">        return ByteBuffer.wrap(s.getBytes(StandardCharsets.UTF_8));</span>
    }

    /**
     * Encode a String in a ByteBuffer using the provided charset.
     *
     * @param s the string to encode
     * @param charset the String encoding charset to use
     * @return the encoded string
     */
    public static ByteBuffer bytes(String s, Charset charset)
    {
<span class="fc" id="L253">        return ByteBuffer.wrap(s.getBytes(charset));</span>
    }

    /**
     * @return a new copy of the data in @param buffer
     * USUALLY YOU SHOULD USE ByteBuffer.duplicate() INSTEAD, which creates a new Buffer
     * (so you can mutate its position without affecting the original) without copying the underlying array.
     */
    public static ByteBuffer clone(ByteBuffer buffer)
    {
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        assert buffer != null;</span>

<span class="fc bfc" id="L265" title="All 2 branches covered.">        if (buffer.remaining() == 0)</span>
<span class="fc" id="L266">            return EMPTY_BYTE_BUFFER;</span>

<span class="fc" id="L268">        ByteBuffer clone = ByteBuffer.allocate(buffer.remaining());</span>

<span class="pc bpc" id="L270" title="1 of 2 branches missed.">        if (buffer.hasArray())</span>
        {
<span class="fc" id="L272">            System.arraycopy(buffer.array(), buffer.arrayOffset() + buffer.position(), clone.array(), 0, buffer.remaining());</span>
        }
        else
        {
<span class="nc" id="L276">            clone.put(buffer.duplicate());</span>
<span class="nc" id="L277">            clone.flip();</span>
        }

<span class="fc" id="L280">        return clone;</span>
    }

    /**
     * Transfer bytes from a ByteBuffer to byte array.
     *
     * @param src the source ByteBuffer
     * @param srcPos starting position in the source ByteBuffer
     * @param dst the destination byte array
     * @param dstPos starting position in the destination byte array
     * @param length the number of bytes to copy
     */
    public static void copyBytes(ByteBuffer src, int srcPos, byte[] dst, int dstPos, int length)
    {
<span class="nc" id="L294">        FastByteOperations.copy(src, srcPos, dst, dstPos, length);</span>
<span class="nc" id="L295">    }</span>

    /**
     * Transfer bytes from one ByteBuffer to another.
     * This function acts as System.arrayCopy() but for ByteBuffers, and operates safely on direct memory.
     *
     * @param src the source ByteBuffer
     * @param srcPos starting position in the source ByteBuffer
     * @param dst the destination ByteBuffer
     * @param dstPos starting position in the destination ByteBuffer
     * @param length the number of bytes to copy
     */
    public static void copyBytes(ByteBuffer src, int srcPos, ByteBuffer dst, int dstPos, int length)
    {
<span class="fc" id="L309">        FastByteOperations.copy(src, srcPos, dst, dstPos, length);</span>
<span class="fc" id="L310">    }</span>

    public static int put(ByteBuffer src, ByteBuffer trg)
    {
<span class="nc" id="L314">        int length = Math.min(src.remaining(), trg.remaining());</span>
<span class="nc" id="L315">        copyBytes(src, src.position(), trg, trg.position(), length);</span>
<span class="nc" id="L316">        trg.position(trg.position() + length);</span>
<span class="nc" id="L317">        src.position(src.position() + length);</span>
<span class="nc" id="L318">        return length;</span>
    }

    public static void writeZeroes(ByteBuffer dest, int count)
    {
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (count &gt;= 8)</span>
        {
            // align
<span class="nc bnc" id="L326" title="All 2 branches missed.">            while ((dest.position() &amp; 0x7) != 0)</span>
            {
<span class="nc" id="L328">                dest.put((byte) 0);</span>
<span class="nc" id="L329">                --count;</span>
            }
        }
        // write aligned longs
<span class="nc bnc" id="L333" title="All 2 branches missed.">        while (count &gt;= 8)</span>
        {
<span class="nc" id="L335">            dest.putLong(0L);</span>
<span class="nc" id="L336">            count -= 8;</span>
        }
        // finish up
<span class="nc bnc" id="L339" title="All 2 branches missed.">        while (count &gt; 0)</span>
        {
<span class="nc" id="L341">            dest.put((byte) 0);</span>
<span class="nc" id="L342">            --count;</span>
        }
<span class="nc" id="L344">    }</span>

    public static void writeWithLength(ByteBuffer bytes, DataOutputPlus out) throws IOException
    {
<span class="fc" id="L348">        out.writeInt(bytes.remaining());</span>
<span class="fc" id="L349">        out.write(bytes);</span>
<span class="fc" id="L350">    }</span>

    public static void writeWithVIntLength(ByteBuffer bytes, DataOutputPlus out) throws IOException
    {
<span class="fc" id="L354">        out.writeUnsignedVInt32(bytes.remaining());</span>
<span class="fc" id="L355">        out.write(bytes);</span>
<span class="fc" id="L356">    }</span>

    public static void writeWithShortLength(ByteBuffer buffer, DataOutputPlus out) throws IOException
    {
<span class="fc" id="L360">        int length = buffer.remaining();</span>
<span class="pc bpc" id="L361" title="2 of 4 branches missed.">        assert 0 &lt;= length &amp;&amp; length &lt;= FBUtilities.MAX_UNSIGNED_SHORT</span>
<span class="nc" id="L362">            : String.format(&quot;Attempted serializing to buffer exceeded maximum of %s bytes: %s&quot;, FBUtilities.MAX_UNSIGNED_SHORT, length);</span>
<span class="fc" id="L363">        out.writeShort(length);</span>
<span class="fc" id="L364">        out.write(buffer);</span>
<span class="fc" id="L365">    }</span>

    public static ByteBuffer readWithLength(DataInput in) throws IOException
    {
<span class="fc" id="L369">        int length = in.readInt();</span>
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">        if (length &lt; 0)</span>
        {
<span class="nc" id="L372">            throw new IOException(&quot;Corrupt (negative) value length encountered&quot;);</span>
        }

<span class="fc" id="L375">        return ByteBufferUtil.read(in, length);</span>
    }

    public static ByteBuffer readWithVIntLength(DataInputPlus in) throws IOException
    {
<span class="fc" id="L380">        int length = in.readUnsignedVInt32();</span>
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        if (length &lt; 0)</span>
<span class="nc" id="L382">            throw new IOException(&quot;Corrupt (negative) value length encountered&quot;);</span>

<span class="fc" id="L384">        return ByteBufferUtil.read(in, length);</span>
    }

    public static int serializedSizeWithLength(ByteBuffer buffer)
    {
<span class="nc" id="L389">        int size = buffer.remaining();</span>
<span class="nc" id="L390">        return TypeSizes.sizeof(size) + size;</span>
    }

    public static int serializedSizeWithVIntLength(ByteBuffer buffer)
    {
<span class="fc" id="L395">        int size = buffer.remaining();</span>
<span class="fc" id="L396">        return TypeSizes.sizeofUnsignedVInt(size) + size;</span>
    }

    public static void skipWithVIntLength(DataInputPlus in) throws IOException
    {
<span class="fc" id="L401">        int length = in.readUnsignedVInt32();</span>
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">        if (length &lt; 0)</span>
<span class="nc" id="L403">            throw new IOException(&quot;Corrupt (negative) value length encountered&quot;);</span>

<span class="fc" id="L405">        in.skipBytesFully(length);</span>
<span class="fc" id="L406">    }</span>

    /* @return An unsigned short in an integer. */
    public static int readShortLength(DataInput in) throws IOException
    {
<span class="fc" id="L411">        return in.readUnsignedShort();</span>
    }

    /**
     * @param in data input
     * @return An unsigned short in an integer.
     * @throws IOException if an I/O error occurs.
     */
    public static ByteBuffer readWithShortLength(DataInput in) throws IOException
    {
<span class="fc" id="L421">        return ByteBufferUtil.read(in, readShortLength(in));</span>
    }

    public static int serializedSizeWithShortLength(ByteBuffer buffer)
    {
<span class="fc" id="L426">        int size = buffer.remaining();</span>
<span class="fc" id="L427">        return TypeSizes.sizeof((short)size) + size;</span>
    }

    /**
     * @param in data input
     * @throws IOException if an I/O error occurs.
     */
    public static void skipShortLength(DataInputPlus in) throws IOException
    {
<span class="fc" id="L436">        int skip = readShortLength(in);</span>
<span class="fc" id="L437">        in.skipBytesFully(skip);</span>
<span class="fc" id="L438">    }</span>

    public static ByteBuffer read(DataInput in, int length) throws IOException
    {
<span class="fc bfc" id="L442" title="All 2 branches covered.">        if (length == 0)</span>
<span class="fc" id="L443">            return EMPTY_BYTE_BUFFER;</span>

<span class="fc" id="L445">        byte[] buff = new byte[length];</span>
<span class="fc" id="L446">        in.readFully(buff);</span>
<span class="fc" id="L447">        return ByteBuffer.wrap(buff);</span>
    }

    public static byte[] readBytes(DataInput in, int length) throws IOException
    {
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">        assert length &gt; 0 : &quot;length is not &gt; 0: &quot; + length;</span>
<span class="fc" id="L453">        byte[] bytes = new byte[length];</span>
<span class="fc" id="L454">        in.readFully(bytes);</span>
<span class="fc" id="L455">        return bytes;</span>
    }

    public static byte[] readBytesWithLength(DataInput in) throws IOException
    {
<span class="nc" id="L460">        int length = in.readInt();</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">        if (length &lt; 0)</span>
<span class="nc" id="L462">            throw new IOException(&quot;Corrupt (negative) value length encountered&quot;);</span>

<span class="nc" id="L464">        return readBytes(in, length);</span>
    }

    /**
     * Convert a byte buffer to an integer.
     * Does not change the byte buffer position.
     *
     * @param bytes byte buffer to convert to integer
     * @return int representation of the byte buffer
     */
    public static int toInt(ByteBuffer bytes)
    {
<span class="fc" id="L476">        return bytes.getInt(bytes.position());</span>
    }

    /**
     * Convert a byte buffer to a short.
     * Does not change the byte buffer position.
     *
     * @param bytes byte buffer to convert to short
     * @return short representation of the byte buffer
     */
    public static short toShort(ByteBuffer bytes)
    {
<span class="fc" id="L488">        return bytes.getShort(bytes.position());</span>
    }

    /**
     * Convert a byte buffer to a short.
     * Does not change the byte buffer position.
     *
     * @param bytes byte buffer to convert to byte
     * @return byte representation of the byte buffer
     */
    public static byte toByte(ByteBuffer bytes)
    {
<span class="nc" id="L500">        return bytes.get(bytes.position());</span>
    }

    public static long toLong(ByteBuffer bytes)
    {
<span class="fc" id="L505">        return bytes.getLong(bytes.position());</span>
    }

    public static float toFloat(ByteBuffer bytes)
    {
<span class="fc" id="L510">        return bytes.getFloat(bytes.position());</span>
    }

    public static double toDouble(ByteBuffer bytes)
    {
<span class="fc" id="L515">        return bytes.getDouble(bytes.position());</span>
    }

    public static ByteBuffer objectToBytes(Object obj)
    {
<span class="fc bfc" id="L520" title="All 2 branches covered.">        if (obj instanceof Integer)</span>
<span class="fc" id="L521">            return ByteBufferUtil.bytes((int) obj);</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">        else if (obj instanceof Byte)</span>
<span class="nc" id="L523">            return ByteBufferUtil.bytes((byte) obj);</span>
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">        else if (obj instanceof Short)</span>
<span class="nc" id="L525">            return ByteBufferUtil.bytes((short) obj);</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">        else if (obj instanceof Long)</span>
<span class="fc" id="L527">            return ByteBufferUtil.bytes((long) obj);</span>
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">        else if (obj instanceof Float)</span>
<span class="nc" id="L529">            return ByteBufferUtil.bytes((float) obj);</span>
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">        else if (obj instanceof Double)</span>
<span class="nc" id="L531">            return ByteBufferUtil.bytes((double) obj);</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">        else if (obj instanceof UUID)</span>
<span class="fc" id="L533">            return ByteBufferUtil.bytes((UUID) obj);</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">        else if (obj instanceof InetAddress)</span>
<span class="fc" id="L535">            return ByteBufferUtil.bytes((InetAddress) obj);</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">        else if (obj instanceof String)</span>
<span class="fc" id="L537">            return ByteBufferUtil.bytes((String) obj);</span>
<span class="pc bpc" id="L538" title="1 of 2 branches missed.">        else if (obj instanceof byte[])</span>
<span class="nc" id="L539">            return ByteBuffer.wrap((byte[]) obj);</span>
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">        else if (obj instanceof ByteBuffer)</span>
<span class="fc" id="L541">            return (ByteBuffer) obj;</span>
        else
<span class="nc" id="L543">            throw new IllegalArgumentException(String.format(&quot;Cannot convert value %s of type %s&quot;,</span>
                                                             obj,
<span class="nc" id="L545">                                                             obj.getClass()));</span>
    }

    public static ByteBuffer bytes(byte b)
    {
<span class="fc" id="L550">        return ByteBuffer.allocate(1).put(0, b);</span>
    }

    public static ByteBuffer bytes(short s)
    {
<span class="fc" id="L555">        return ByteBuffer.allocate(2).putShort(0, s);</span>
    }

    public static ByteBuffer bytes(int i)
    {
<span class="fc" id="L560">        return ByteBuffer.allocate(4).putInt(0, i);</span>
    }

    public static ByteBuffer bytes(long n)
    {
<span class="fc" id="L565">        return ByteBuffer.allocate(8).putLong(0, n);</span>
    }

    public static ByteBuffer bytes(float f)
    {
<span class="fc" id="L570">        return ByteBuffer.allocate(4).putFloat(0, f);</span>
    }

    public static ByteBuffer bytes(double d)
    {
<span class="fc" id="L575">        return ByteBuffer.allocate(8).putDouble(0, d);</span>
    }

    public static InputStream inputStream(ByteBuffer bytes)
    {
<span class="nc" id="L580">        final ByteBuffer copy = bytes.duplicate();</span>

<span class="nc" id="L582">        return new InputStream()</span>
<span class="nc" id="L583">        {</span>
            public int read()
            {
<span class="nc bnc" id="L586" title="All 2 branches missed.">                if (!copy.hasRemaining())</span>
<span class="nc" id="L587">                    return -1;</span>

<span class="nc" id="L589">                return copy.get() &amp; 0xFF;</span>
            }

            @Override
            public int read(byte[] bytes, int off, int len)
            {
<span class="nc bnc" id="L595" title="All 2 branches missed.">                if (!copy.hasRemaining())</span>
<span class="nc" id="L596">                    return -1;</span>

<span class="nc" id="L598">                len = Math.min(len, copy.remaining());</span>
<span class="nc" id="L599">                copy.get(bytes, off, len);</span>
<span class="nc" id="L600">                return len;</span>
            }

            @Override
            public int available()
            {
<span class="nc" id="L606">                return copy.remaining();</span>
            }
        };
    }

    /*
     * Does not modify position or limit of buffer even temporarily
     * so this is safe even without duplication.
     */
    public static String bytesToHex(ByteBuffer bytes)
    {
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">        if (bytes.hasArray())</span>
        {
<span class="fc" id="L619">            return Hex.bytesToHex(bytes.array(), bytes.arrayOffset() + bytes.position(), bytes.remaining());</span>
        }

<span class="nc" id="L622">        final int offset = bytes.position();</span>
<span class="nc" id="L623">        final int size = bytes.remaining();</span>
<span class="nc" id="L624">        final char[] c = new char[size * 2];</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L627">            final int bint = bytes.get(i+offset);</span>
<span class="nc" id="L628">            c[i * 2] = Hex.byteToChar[(bint &amp; 0xf0) &gt;&gt; 4];</span>
<span class="nc" id="L629">            c[1 + i * 2] = Hex.byteToChar[bint &amp; 0x0f];</span>
        }
<span class="nc" id="L631">        return Hex.wrapCharArray(c);</span>
    }

    public static ByteBuffer hexToBytes(String str)
    {
<span class="fc" id="L636">        return ByteBuffer.wrap(Hex.hexToBytes(str));</span>
    }

    /**
     * Compare two ByteBuffer at specified offsets for length.
     * Compares the non equal bytes as unsigned.
     * @param bytes1 First byte buffer to compare.
     * @param offset1 Position to start the comparison at in the first array.
     * @param bytes2 Second byte buffer to compare.
     * @param offset2 Position to start the comparison at in the second array.
     * @param length How many bytes to compare?
     * @return -1 if byte1 is less than byte2, 1 if byte2 is less than byte1 or 0 if equal.
     */
    public static int compareSubArrays(ByteBuffer bytes1, int offset1, ByteBuffer bytes2, int offset2, int length)
    {
<span class="pc bpc" id="L651" title="1 of 2 branches missed.">        if (bytes1 == null)</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">            return bytes2 == null ? 0 : -1;</span>
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">        if (bytes2 == null) return 1;</span>

<span class="pc bpc" id="L655" title="1 of 2 branches missed.">        assert bytes1.limit() &gt;= offset1 + length : &quot;The first byte array isn't long enough for the specified offset and length.&quot;;</span>
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">        assert bytes2.limit() &gt;= offset2 + length : &quot;The second byte array isn't long enough for the specified offset and length.&quot;;</span>

<span class="fc bfc" id="L658" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++)</span>
        {
<span class="fc" id="L660">            byte byte1 = bytes1.get(offset1 + i);</span>
<span class="fc" id="L661">            byte byte2 = bytes2.get(offset2 + i);</span>
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">            if (byte1 == byte2)</span>
<span class="fc" id="L663">                continue;</span>
            // compare non-equal bytes as unsigned
<span class="nc bnc" id="L665" title="All 2 branches missed.">            return (byte1 &amp; 0xFF) &lt; (byte2 &amp; 0xFF) ? -1 : 1;</span>
        }
<span class="fc" id="L667">        return 0;</span>
    }

    public static ByteBuffer bytes(InetAddress address)
    {
<span class="fc" id="L672">        return ByteBuffer.wrap(address.getAddress());</span>
    }

    public static ByteBuffer bytes(UUID uuid)
    {
<span class="fc" id="L677">        return ByteBuffer.wrap(UUIDGen.decompose(uuid));</span>
    }

    public static ByteBuffer bytes(TimeUUID uuid)
    {
<span class="fc" id="L682">        return bytes(uuid.asUUID());</span>
    }

    // Returns whether {@code prefix} is a prefix of {@code value}.
    public static boolean isPrefix(ByteBuffer prefix, ByteBuffer value)
    {
<span class="nc bnc" id="L688" title="All 2 branches missed.">        if (prefix.remaining() &gt; value.remaining())</span>
<span class="nc" id="L689">            return false;</span>

<span class="nc" id="L691">        int diff = value.remaining() - prefix.remaining();</span>
<span class="nc" id="L692">        return prefix.equals(value.duplicate().limit(value.remaining() - diff));</span>
    }

    public static boolean canMinimize(ByteBuffer buf)
    {
<span class="pc bpc" id="L697" title="2 of 6 branches missed.">        return buf != null &amp;&amp; (!buf.hasArray() || buf.array().length &gt; buf.remaining());</span>
        // Note: buf.array().length is different from buf.capacity() for sliced buffers.
    }

    /** trims size of bytebuffer to exactly number of bytes in it, to do not hold too much memory */
    public static ByteBuffer minimalBufferFor(ByteBuffer buf)
    {
<span class="pc bpc" id="L704" title="1 of 4 branches missed.">        return !buf.hasArray() || buf.array().length &gt; buf.remaining() ? ByteBuffer.wrap(getArray(buf)) : buf;</span>
    }

    public static ByteBuffer[] minimizeBuffers(ByteBuffer[] src)
    {
<span class="fc" id="L709">        ByteBuffer[] dst = new ByteBuffer[src.length];</span>
<span class="fc bfc" id="L710" title="All 2 branches covered.">        for (int i=0; i&lt;src.length; i++)</span>
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">            dst[i] = src[i] != null ? minimalBufferFor(src[i]) : null;</span>
<span class="fc" id="L712">        return dst;</span>
    }

    public static boolean canMinimize(ByteBuffer[] src)
    {
<span class="fc bfc" id="L717" title="All 2 branches covered.">        for (ByteBuffer buffer : src)</span>
        {
<span class="fc bfc" id="L719" title="All 2 branches covered.">            if (canMinimize(buffer))</span>
<span class="fc" id="L720">                return true;</span>
        }
<span class="fc" id="L722">        return false;</span>
    }

    public static int getUnsignedShort(ByteBuffer bb, int position)
    {
<span class="fc" id="L727">        return ((bb.get(position) &amp; 0xFF) &lt;&lt; 8) | (bb.get(position + 1) &amp; 0xFF);</span>
    }

    // Doesn't change bb position
    public static int getShortLength(ByteBuffer bb, int position)
    {
<span class="fc" id="L733">        return getUnsignedShort(bb, position);</span>
    }

    // changes bb position
    public static int readShortLength(ByteBuffer bb)
    {
<span class="fc" id="L739">        int length = (bb.get() &amp; 0xFF) &lt;&lt; 8;</span>
<span class="fc" id="L740">        return length | (bb.get() &amp; 0xFF);</span>
    }

    // changes bb position
    public static void writeShortLength(ByteBuffer bb, int length)
    {
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">        if (length &gt; FBUtilities.MAX_UNSIGNED_SHORT)</span>
<span class="nc" id="L747">            throw new IllegalArgumentException(String.format(&quot;Length %d &gt; max length %d&quot;, length, FBUtilities.MAX_UNSIGNED_SHORT));</span>
<span class="fc" id="L748">        bb.put((byte) ((length &gt;&gt; 8) &amp; 0xFF));</span>
<span class="fc" id="L749">        bb.put((byte) (length &amp; 0xFF));</span>
<span class="fc" id="L750">    }</span>

    // changes bb position
    public static ByteBuffer readBytes(ByteBuffer bb, int length)
    {
<span class="fc" id="L755">        ByteBuffer copy = bb.duplicate();</span>
<span class="fc" id="L756">        copy.limit(copy.position() + length);</span>
<span class="fc" id="L757">        bb.position(bb.position() + length);</span>
<span class="fc" id="L758">        return copy;</span>
    }

    // changes bb position
    public static ByteBuffer readBytesWithShortLength(ByteBuffer bb)
    {
<span class="fc" id="L764">        int length = readShortLength(bb);</span>
<span class="fc" id="L765">        return readBytes(bb, length);</span>
    }

    /**
     * Ensure {@code buf} is large enough for {@code outputLength}. If not, it is cleaned up and a new buffer is allocated;
     * else; buffer has it's position/limit set appropriately.
     *
     * @param buf buffer to test the size of; may be null, in which case, a new buffer is allocated.
     * @param outputLength the minimum target size of the buffer
     * @param allowBufferResize true if resizing (reallocating) the buffer is allowed
     * @return {@code buf} if it was large enough, else a newly allocated buffer.
     */
    public static ByteBuffer ensureCapacity(ByteBuffer buf, int outputLength, boolean allowBufferResize)
    {
<span class="nc bnc" id="L779" title="All 2 branches missed.">        BufferType bufferType = buf != null ? BufferType.typeOf(buf) : BufferType.ON_HEAP;</span>
<span class="nc" id="L780">        return ensureCapacity(buf, outputLength, allowBufferResize, bufferType);</span>
    }

    /**
     * Ensure {@code buf} is large enough for {@code outputLength}. If not, it is cleaned up and a new buffer is allocated;
     * else; buffer has it's position/limit set appropriately.
     *
     * @param buf buffer to test the size of; may be null, in which case, a new buffer is allocated.
     * @param outputLength the minimum target size of the buffer
     * @param allowBufferResize true if resizing (reallocating) the buffer is allowed
     * @param bufferType on- or off- heap byte buffer
     * @return {@code buf} if it was large enough, else a newly allocated buffer.
     */
    public static ByteBuffer ensureCapacity(ByteBuffer buf, int outputLength, boolean allowBufferResize, BufferType bufferType)
    {
<span class="nc bnc" id="L795" title="All 2 branches missed.">        if (0 &gt; outputLength)</span>
<span class="nc" id="L796">            throw new IllegalArgumentException(&quot;invalid size for output buffer: &quot; + outputLength);</span>
<span class="nc bnc" id="L797" title="All 4 branches missed.">        if (buf == null || buf.capacity() &lt; outputLength)</span>
        {
<span class="nc bnc" id="L799" title="All 2 branches missed.">            if (!allowBufferResize)</span>
<span class="nc" id="L800">                throw new IllegalStateException(String.format(&quot;output buffer is not large enough for data: current capacity %d, required %d&quot;, buf.capacity(), outputLength));</span>
<span class="nc" id="L801">            FileUtils.clean(buf);</span>
<span class="nc" id="L802">            buf = bufferType.allocate(outputLength);</span>
        }
        else
        {
<span class="nc" id="L806">            buf.position(0).limit(outputLength);</span>
        }
<span class="nc" id="L808">        return buf;</span>
    }

    /**
     * Check is the given buffer contains a given sub-buffer.
     *
     * @param buffer The buffer to search for sequence of bytes in.
     * @param subBuffer The buffer to match.
     *
     * @return true if buffer contains sub-buffer, false otherwise.
     */
    public static boolean contains(ByteBuffer buffer, ByteBuffer subBuffer)
    {
<span class="nc" id="L821">        int len = subBuffer.remaining();</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">        if (buffer.remaining() - len &lt; 0)</span>
<span class="nc" id="L823">            return false;</span>

        // adapted form the JDK's String.indexOf()
<span class="nc" id="L826">        byte first = subBuffer.get(subBuffer.position());</span>
<span class="nc" id="L827">        int max = buffer.position() + (buffer.remaining() - len);</span>

<span class="nc bnc" id="L829" title="All 2 branches missed.">        for (int i = buffer.position(); i &lt;= max; i++)</span>
        {
            /* Look for first character. */
<span class="nc bnc" id="L832" title="All 2 branches missed.">            if (buffer.get(i) != first)</span>
            {
<span class="nc bnc" id="L834" title="All 4 branches missed.">                while (++i &lt;= max &amp;&amp; buffer.get(i) != first)</span>
                {}
            }

            /* (maybe) Found first character, now look at the rest of v2 */
<span class="nc bnc" id="L839" title="All 2 branches missed.">            if (i &lt;= max)</span>
            {
<span class="nc" id="L841">                int j = i + 1;</span>
<span class="nc" id="L842">                int end = j + len - 1;</span>
<span class="nc bnc" id="L843" title="All 4 branches missed.">                for (int k = 1 + subBuffer.position(); j &lt; end &amp;&amp; buffer.get(j) == subBuffer.get(k); j++, k++)</span>
                {}

<span class="nc bnc" id="L846" title="All 2 branches missed.">                if (j == end)</span>
<span class="nc" id="L847">                    return true;</span>
            }
        }
<span class="nc" id="L850">        return false;</span>
    }

    public static boolean startsWith(ByteBuffer src, ByteBuffer prefix)
    {
<span class="nc" id="L855">        return startsWith(src, prefix, 0);</span>
    }

    public static boolean endsWith(ByteBuffer src, ByteBuffer suffix)
    {
<span class="nc" id="L860">        return startsWith(src, suffix, src.remaining() - suffix.remaining());</span>
    }

    private static boolean startsWith(ByteBuffer src, ByteBuffer prefix, int offset)
    {
<span class="nc bnc" id="L865" title="All 2 branches missed.">        if (offset &lt; 0)</span>
<span class="nc" id="L866">            return false;</span>

<span class="nc" id="L868">        int sPos = src.position() + offset;</span>
<span class="nc" id="L869">        int pPos = prefix.position();</span>

<span class="nc bnc" id="L871" title="All 2 branches missed.">        if (src.remaining() - offset &lt; prefix.remaining())</span>
<span class="nc" id="L872">            return false;</span>

<span class="nc" id="L874">        int len = Math.min(src.remaining() - offset, prefix.remaining());</span>

<span class="nc bnc" id="L876" title="All 2 branches missed.">        while (len-- &gt; 0)</span>
        {
<span class="nc bnc" id="L878" title="All 2 branches missed.">            if (src.get(sPos++) != prefix.get(pPos++))</span>
<span class="nc" id="L879">                return false;</span>
        }

<span class="nc" id="L882">        return true;</span>
    }

    /**
     * Returns true if the buffer at the current position in the input matches given buffer.
     * If true, the input is positioned at the end of the consumed buffer.
     * If false, the position of the input is undefined.
     * &lt;p&gt;
     * The matched buffer is unchanged
     */
    public static boolean equalsWithShortLength(DataInput in, ByteBuffer toMatch) throws IOException
    {
<span class="nc" id="L894">        int length = readShortLength(in);</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">        if (length != toMatch.remaining())</span>
<span class="nc" id="L896">            return false;</span>
<span class="nc" id="L897">        int limit = toMatch.limit();</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">        for (int i = toMatch.position(); i &lt; limit; ++i)</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">            if (toMatch.get(i) != in.readByte())</span>
<span class="nc" id="L900">                return false;</span>

<span class="nc" id="L902">        return true;</span>
    }

    public static void readFully(FileChannel channel, ByteBuffer dst, long position) throws IOException
    {
<span class="nc bnc" id="L907" title="All 2 branches missed.">        while (dst.hasRemaining())</span>
        {
<span class="nc" id="L909">            int read = channel.read(dst, position);</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">            if (read == -1)</span>
<span class="nc" id="L911">                throw new EOFException();</span>
<span class="nc" id="L912">            position += read;</span>
<span class="nc" id="L913">        }</span>
<span class="nc" id="L914">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>