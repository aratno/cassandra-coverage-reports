<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LocalSyncTask.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.repair</a> &gt; <span class="el_source">LocalSyncTask.java</span></div><h1>LocalSyncTask.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.repair;

import java.util.Collections;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.dht.Range;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.locator.RangesAtEndpoint;
import org.apache.cassandra.streaming.PreviewKind;
import org.apache.cassandra.streaming.ProgressInfo;
import org.apache.cassandra.streaming.StreamEvent;
import org.apache.cassandra.streaming.StreamEventHandler;
import org.apache.cassandra.streaming.StreamOperation;
import org.apache.cassandra.streaming.StreamPlan;
import org.apache.cassandra.streaming.StreamSession;
import org.apache.cassandra.streaming.StreamState;
import org.apache.cassandra.tracing.TraceState;
import org.apache.cassandra.tracing.Tracing;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.TimeUUID;
import org.apache.cassandra.utils.concurrent.AsyncPromise;
import org.apache.cassandra.utils.concurrent.Promise;

/**
 * LocalSyncTask performs streaming between local(coordinator) node and remote replica.
 */
public class LocalSyncTask extends SyncTask implements StreamEventHandler
{
<span class="fc" id="L53">    private final TraceState state = Tracing.instance.get();</span>

<span class="fc" id="L55">    private static final Logger logger = LoggerFactory.getLogger(LocalSyncTask.class);</span>

    private final TimeUUID pendingRepair;

    @VisibleForTesting
    public final boolean requestRanges;
    @VisibleForTesting
    public final boolean transferRanges;

<span class="fc" id="L64">    private final AtomicBoolean active = new AtomicBoolean(true);</span>
<span class="fc" id="L65">    private final Promise&lt;StreamPlan&gt; planPromise = new AsyncPromise&lt;&gt;();</span>

    public LocalSyncTask(SharedContext ctx, RepairJobDesc desc, InetAddressAndPort local, InetAddressAndPort remote,
                         List&lt;Range&lt;Token&gt;&gt; diff, TimeUUID pendingRepair,
                         boolean requestRanges, boolean transferRanges, PreviewKind previewKind)
    {
<span class="fc" id="L71">        super(ctx, desc, local, remote, diff, previewKind);</span>
<span class="pc bpc" id="L72" title="3 of 4 branches missed.">        Preconditions.checkArgument(requestRanges || transferRanges, &quot;Nothing to do in a sync job&quot;);</span>
<span class="fc" id="L73">        Preconditions.checkArgument(local.equals(ctx.broadcastAddressAndPort()));</span>

<span class="fc" id="L75">        this.pendingRepair = pendingRepair;</span>
<span class="fc" id="L76">        this.requestRanges = requestRanges;</span>
<span class="fc" id="L77">        this.transferRanges = transferRanges;</span>
<span class="fc" id="L78">    }</span>

    @VisibleForTesting
    StreamPlan createStreamPlan()
    {
<span class="fc" id="L83">        InetAddressAndPort remote =  nodePair.peer;</span>

<span class="fc" id="L85">        StreamPlan plan = new StreamPlan(StreamOperation.REPAIR, 1, false, pendingRepair, previewKind)</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">                          .listeners(this)</span>
<span class="fc" id="L87">                          .flushBeforeTransfer(pendingRepair == null);</span>

<span class="pc bpc" id="L89" title="1 of 2 branches missed.">        if (requestRanges)</span>
        {
            // see comment on RangesAtEndpoint.toDummyList for why we synthesize replicas here
<span class="fc" id="L92">            plan.requestRanges(remote, desc.keyspace, RangesAtEndpoint.toDummyList(rangesToSync),</span>
<span class="fc" id="L93">                               RangesAtEndpoint.toDummyList(Collections.emptyList()), desc.columnFamily);</span>
        }

<span class="fc bfc" id="L96" title="All 2 branches covered.">        if (transferRanges)</span>
        {
            // send ranges to the remote node if we are not performing a pull repair
            // see comment on RangesAtEndpoint.toDummyList for why we synthesize replicas here
<span class="fc" id="L100">            plan.transferRanges(remote, desc.keyspace, RangesAtEndpoint.toDummyList(rangesToSync), desc.columnFamily);</span>
        }

<span class="fc" id="L103">        return plan;</span>
    }

    /**
     * Starts sending/receiving our list of differences to/from the remote endpoint: creates a callback
     * that will be called out of band once the streams complete.
     */
    @Override
    protected void startSync()
    {
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        if (active.get())</span>
        {
<span class="fc" id="L115">            InetAddressAndPort remote = nodePair.peer;</span>

<span class="fc" id="L117">            String message = String.format(&quot;Performing streaming repair of %d ranges with %s&quot;, rangesToSync.size(), remote);</span>
<span class="fc" id="L118">            logger.info(&quot;{} {}&quot;, previewKind.logPrefix(desc.sessionId), message);</span>
<span class="fc" id="L119">            Tracing.traceRepair(message);</span>

<span class="fc" id="L121">            StreamPlan plan = createStreamPlan();</span>
<span class="fc" id="L122">            ctx.streamExecutor().execute(plan);</span>
<span class="fc" id="L123">            planPromise.setSuccess(plan);</span>
        }
<span class="fc" id="L125">    }</span>

    @Override
    public boolean isLocal()
    {
<span class="fc" id="L130">        return true;</span>
    }

    @Override
    public void handleStreamEvent(StreamEvent event)
    {
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">        if (state == null)</span>
<span class="fc" id="L137">            return;</span>
<span class="nc bnc" id="L138" title="All 4 branches missed.">        switch (event.eventType)</span>
        {
            case STREAM_PREPARED:
<span class="nc" id="L141">                StreamEvent.SessionPreparedEvent spe = (StreamEvent.SessionPreparedEvent) event;</span>
<span class="nc" id="L142">                state.trace(&quot;Streaming session with {} prepared&quot;, spe.session.peer);</span>
<span class="nc" id="L143">                break;</span>
            case STREAM_COMPLETE:
<span class="nc" id="L145">                StreamEvent.SessionCompleteEvent sce = (StreamEvent.SessionCompleteEvent) event;</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">                state.trace(&quot;Streaming session with {} {}&quot;, sce.peer, sce.success ? &quot;completed successfully&quot; : &quot;failed&quot;);</span>
<span class="nc" id="L147">                break;</span>
            case FILE_PROGRESS:
<span class="nc" id="L149">                ProgressInfo pi = ((StreamEvent.ProgressEvent) event).progress;</span>
<span class="nc" id="L150">                state.trace(&quot;{}/{} ({}%) {} idx:{}{}&quot;,</span>
<span class="nc" id="L151">                            new Object[] { FBUtilities.prettyPrintMemory(pi.currentBytes),</span>
<span class="nc" id="L152">                                           FBUtilities.prettyPrintMemory(pi.totalBytes),</span>
<span class="nc" id="L153">                                           pi.progressPercentage(),</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">                                           pi.direction == ProgressInfo.Direction.OUT ? &quot;sent to&quot; : &quot;received from&quot;,</span>
<span class="nc" id="L155">                                           pi.sessionIndex,</span>
                                           pi.peer });
        }
<span class="nc" id="L158">    }</span>

    @Override
    public void onSuccess(StreamState result)
    {
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">        if (active.compareAndSet(true, false))</span>
        {
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">            String status = result.hasAbortedSession() ? &quot;aborted&quot; : &quot;complete&quot;;</span>
<span class="fc" id="L166">            String message = String.format(&quot;Sync %s using session %s between %s and %s on %s&quot;,</span>
                                           status, desc.sessionId, nodePair.coordinator, nodePair.peer, desc.columnFamily);
<span class="fc" id="L168">            logger.info(&quot;{} {}&quot;, previewKind.logPrefix(desc.sessionId), message);</span>
<span class="fc" id="L169">            Tracing.traceRepair(message);</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">            trySuccess(result.hasAbortedSession() ? stat : stat.withSummaries(result.createSummaries()));</span>
<span class="fc" id="L171">            finished();</span>
        }
<span class="fc" id="L173">    }</span>

    @Override
    public void onFailure(Throwable t)
    {
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        if (active.compareAndSet(true, false))</span>
        {
<span class="fc" id="L180">            tryFailure(t);</span>
<span class="fc" id="L181">            finished();</span>
        }
<span class="fc" id="L183">    }</span>

    @Override
    public String toString()
    {
<span class="nc" id="L188">        return &quot;LocalSyncTask{&quot; +</span>
               &quot;requestRanges=&quot; + requestRanges +
               &quot;, transferRanges=&quot; + transferRanges +
               &quot;, rangesToSync=&quot; + rangesToSync +
               &quot;, nodePair=&quot; + nodePair +
               '}';
    }

    @Override
    public void abort(Throwable reason)
    {
<span class="fc" id="L199">        super.abort(reason);</span>
<span class="fc" id="L200">        planPromise.addCallback((plan, cause) -&gt;</span>
        {
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">            assert plan != null : &quot;StreamPlan future should never be completed exceptionally&quot;;</span>
<span class="fc" id="L203">            plan.getCoordinator().getAllStreamSessions().forEach(StreamSession::abort);</span>
<span class="fc" id="L204">        });</span>
<span class="fc" id="L205">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>