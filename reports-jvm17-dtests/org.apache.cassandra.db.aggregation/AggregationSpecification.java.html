<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AggregationSpecification.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.aggregation</a> &gt; <span class="el_source">AggregationSpecification.java</span></div><h1>AggregationSpecification.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.aggregation;

import java.io.IOException;
import java.util.Collections;
import java.util.List;

import org.apache.cassandra.cql3.QueryOptions;
import org.apache.cassandra.cql3.functions.Function;
import org.apache.cassandra.cql3.selection.Selector;
import org.apache.cassandra.db.ClusteringComparator;
import org.apache.cassandra.db.TypeSizes;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.TableMetadata;

/**
 * Defines how rows should be grouped for creating aggregates.
 */
public abstract class AggregationSpecification
{
<span class="fc" id="L39">    public static final Serializer serializer = new Serializer();</span>

    /**
     * &lt;code&gt;AggregationSpecification&lt;/code&gt; that group all the row together.
     */
<span class="fc" id="L44">    public static final AggregationSpecification AGGREGATE_EVERYTHING = new AggregationSpecification(Kind.AGGREGATE_EVERYTHING)</span>
<span class="fc" id="L45">    {</span>
        @Override
        public GroupMaker newGroupMaker(GroupingState state)
        {
<span class="fc" id="L49">            return GroupMaker.GROUP_EVERYTHING;</span>
        }
    };

    /**
     * Factory for &lt;code&gt;AggregationSpecification&lt;/code&gt; that group all the row together.
     */
<span class="fc" id="L56">    public static final AggregationSpecification.Factory AGGREGATE_EVERYTHING_FACTORY = options -&gt; AGGREGATE_EVERYTHING;</span>

    /**
     * The &lt;code&gt;AggregationSpecification&lt;/code&gt; kind.
     */
    private final Kind kind;

    /**
     * The &lt;code&gt;AggregationSpecification&lt;/code&gt; kinds.
     */
<span class="fc" id="L66">    public enum Kind</span>
    {
<span class="fc" id="L68">        AGGREGATE_EVERYTHING, AGGREGATE_BY_PK_PREFIX, AGGREGATE_BY_PK_PREFIX_WITH_SELECTOR</span>
    }

    /**
     * Returns the &lt;code&gt;AggregationSpecification&lt;/code&gt; kind.
     * @return the &lt;code&gt;AggregationSpecification&lt;/code&gt; kind
     */
    public Kind kind()
    {
<span class="fc" id="L77">        return kind;</span>
    }

    private AggregationSpecification(Kind kind)
<span class="fc" id="L81">    {</span>
<span class="fc" id="L82">        this.kind = kind;</span>
<span class="fc" id="L83">    }</span>

    /**
     * Creates a new &lt;code&gt;GroupMaker&lt;/code&gt; instance.
     *
     * @return a new &lt;code&gt;GroupMaker&lt;/code&gt; instance
     */
    public final GroupMaker newGroupMaker()
    {
<span class="fc" id="L92">        return newGroupMaker(GroupingState.EMPTY_STATE);</span>
    }

    /**
     * Creates a new &lt;code&gt;GroupMaker&lt;/code&gt; instance.
     *
     * @param state &lt;code&gt;GroupMaker&lt;/code&gt; state
     * @return a new &lt;code&gt;GroupMaker&lt;/code&gt; instance
     */
    public abstract GroupMaker newGroupMaker(GroupingState state);

    /**
     * Creates a new {@code Factory} instance to create {@code AggregationSpecification} that will build aggregates
     * based on primary key columns.
     *
     * @param comparator the comparator used to compare the clustering prefixes
     * @param clusteringPrefixSize the number of clustering columns used to create the aggregates
     * @return a  new {@code Factory} instance to create {@code AggregationSpecification} that will build aggregates
     * based on primary key columns.
     */
    public static AggregationSpecification.Factory aggregatePkPrefixFactory(ClusteringComparator comparator,
                                                                            int clusteringPrefixSize)
    {
<span class="fc" id="L115">        return options -&gt; new  AggregateByPkPrefix(comparator, clusteringPrefixSize);</span>
    }

    public static AggregationSpecification.Factory aggregatePkPrefixFactoryWithSelector(final ClusteringComparator comparator,
                                                                                        final int clusteringPrefixSize,
                                                                                        final Selector.Factory factory,
                                                                                        final List&lt;ColumnMetadata&gt; columns)
    {
<span class="fc" id="L123">        return new Factory()</span>
<span class="fc" id="L124">        {</span>
            @Override
            public void addFunctionsTo(List&lt;Function&gt; functions)
            {
<span class="nc" id="L128">                factory.addFunctionsTo(functions);</span>
<span class="nc" id="L129">            }</span>

            @Override
            public AggregationSpecification newInstance(QueryOptions options)
            {
<span class="fc" id="L134">                Selector selector = factory.newInstance(options);</span>
<span class="fc" id="L135">                selector.validateForGroupBy();</span>
<span class="fc" id="L136">                return new  AggregateByPkPrefixWithSelector(comparator,</span>
                                                            clusteringPrefixSize,
                                                            selector,
                                                            columns);
            }
        };
    }
    
    /**
     * Factory for {@code AggregationSpecification}.
     *
     */
    public static interface Factory
    {
        /**
         * Creates a new {@code AggregationSpecification} instance after having binded the parameters.
         *
         * @param options the query options
         * @return a new {@code AggregationSpecification} instance.
         */
        public AggregationSpecification newInstance(QueryOptions options);

        public default void addFunctionsTo(List&lt;Function&gt; functions)
        {
<span class="fc" id="L160">        }</span>
    }

    /**
     * &lt;code&gt;AggregationSpecification&lt;/code&gt; that build aggregates based on primary key columns
     */
    private static class AggregateByPkPrefix extends AggregationSpecification
    {
        /**
         * The number of clustering component to compare.
         */
        protected final int clusteringPrefixSize;

        /**
         * The comparator used to compare the clustering prefixes.
         */
        protected final ClusteringComparator comparator;

        public AggregateByPkPrefix(ClusteringComparator comparator, int clusteringPrefixSize)
        {
<span class="fc" id="L180">            this(Kind.AGGREGATE_BY_PK_PREFIX, comparator, clusteringPrefixSize);</span>
<span class="fc" id="L181">        }</span>

        protected AggregateByPkPrefix(Kind kind, ClusteringComparator comparator, int clusteringPrefixSize)
        {
<span class="fc" id="L185">            super(kind);</span>
<span class="fc" id="L186">            this.comparator = comparator;</span>
<span class="fc" id="L187">            this.clusteringPrefixSize = clusteringPrefixSize;</span>
<span class="fc" id="L188">        }</span>

        @Override
        public GroupMaker newGroupMaker(GroupingState state)
        {
<span class="fc" id="L193">            return GroupMaker.newPkPrefixGroupMaker(comparator, clusteringPrefixSize, state);</span>
        }
    }

    /**
     * &lt;code&gt;AggregationSpecification&lt;/code&gt; that build aggregates based on primary key columns using a selector.
     */
    private static final class AggregateByPkPrefixWithSelector extends AggregateByPkPrefix
    {
        /**
         * The selector.
         */
        private final Selector selector;

        /**
         * The columns used by the selector.
         */
        private final List&lt;ColumnMetadata&gt; columns;

        public AggregateByPkPrefixWithSelector(ClusteringComparator comparator,
                                               int clusteringPrefixSize,
                                               Selector selector,
                                               List&lt;ColumnMetadata&gt; columns)
        {
<span class="fc" id="L217">            super(Kind.AGGREGATE_BY_PK_PREFIX_WITH_SELECTOR, comparator, clusteringPrefixSize);</span>
<span class="fc" id="L218">            this.selector = selector;</span>
<span class="fc" id="L219">            this.columns = columns;</span>
<span class="fc" id="L220">        }</span>

        @Override
        public GroupMaker newGroupMaker(GroupingState state)
        {
<span class="fc" id="L225">            return GroupMaker.newSelectorGroupMaker(comparator, clusteringPrefixSize, selector, columns, state);</span>
        }
    }

<span class="fc" id="L229">    public static class Serializer</span>
    {
        public void serialize(AggregationSpecification aggregationSpec, DataOutputPlus out, int version) throws IOException
        {
<span class="fc" id="L233">            out.writeByte(aggregationSpec.kind().ordinal());</span>
<span class="pc bpc" id="L234" title="2 of 4 branches missed.">            switch (aggregationSpec.kind())</span>
            {
                case AGGREGATE_EVERYTHING:
<span class="nc" id="L237">                    break;</span>
                case AGGREGATE_BY_PK_PREFIX:
<span class="fc" id="L239">                    out.writeUnsignedVInt32(((AggregateByPkPrefix) aggregationSpec).clusteringPrefixSize);</span>
<span class="fc" id="L240">                    break;</span>
                case AGGREGATE_BY_PK_PREFIX_WITH_SELECTOR:
<span class="fc" id="L242">                    AggregateByPkPrefixWithSelector spec = (AggregateByPkPrefixWithSelector) aggregationSpec;</span>
<span class="fc" id="L243">                    out.writeUnsignedVInt32(spec.clusteringPrefixSize);</span>
<span class="fc" id="L244">                    Selector.serializer.serialize(spec.selector, out, version);</span>
                    // Ideally we should serialize the columns but that will break backward compatibility.
                    // So for the moment we can rebuild the list from the prefix size as we know that there will be
                    // only one column and that its indice will be: clusteringPrefixSize - 1.
<span class="fc" id="L248">                    break;</span>
                default:
<span class="nc" id="L250">                    throw new AssertionError(&quot;Unknow aggregation kind: &quot; + aggregationSpec.kind());</span>
            }
<span class="fc" id="L252">        }</span>

        public AggregationSpecification deserialize(DataInputPlus in, int version, TableMetadata metadata) throws IOException
        {
<span class="fc" id="L256">            Kind kind = Kind.values()[in.readUnsignedByte()];</span>
<span class="pc bpc" id="L257" title="2 of 4 branches missed.">            switch (kind)</span>
            {
                case AGGREGATE_EVERYTHING:
<span class="nc" id="L260">                    return AggregationSpecification.AGGREGATE_EVERYTHING;</span>
                case AGGREGATE_BY_PK_PREFIX:
<span class="fc" id="L262">                    return new AggregateByPkPrefix(metadata.comparator, in.readUnsignedVInt32());</span>
                case AGGREGATE_BY_PK_PREFIX_WITH_SELECTOR:
<span class="fc" id="L264">                    int clusteringPrefixSize = in.readUnsignedVInt32();</span>
<span class="fc" id="L265">                    Selector selector = Selector.serializer.deserialize(in, version, metadata);</span>
<span class="fc" id="L266">                    ColumnMetadata functionArgument = metadata.clusteringColumns().get(clusteringPrefixSize - 1);</span>
<span class="fc" id="L267">                    return new AggregateByPkPrefixWithSelector(metadata.comparator,</span>
                                                               clusteringPrefixSize,
                                                               selector,
<span class="fc" id="L270">                                                               Collections.singletonList(functionArgument));</span>
                default:
<span class="nc" id="L272">                    throw new AssertionError(&quot;Unknow aggregation kind: &quot; + kind);</span>
            }
        }

        public long serializedSize(AggregationSpecification aggregationSpec, int version)
        {
<span class="fc" id="L278">            long size = TypeSizes.sizeof((byte) aggregationSpec.kind().ordinal());</span>
<span class="pc bpc" id="L279" title="2 of 4 branches missed.">            switch (aggregationSpec.kind())</span>
            {
                case AGGREGATE_EVERYTHING:
<span class="nc" id="L282">                    break;</span>
                case AGGREGATE_BY_PK_PREFIX:
<span class="fc" id="L284">                    size += TypeSizes.sizeofUnsignedVInt(((AggregateByPkPrefix) aggregationSpec).clusteringPrefixSize);</span>
<span class="fc" id="L285">                    break;</span>
                case AGGREGATE_BY_PK_PREFIX_WITH_SELECTOR:
<span class="fc" id="L287">                    AggregateByPkPrefixWithSelector spec = (AggregateByPkPrefixWithSelector) aggregationSpec;</span>
<span class="fc" id="L288">                    size += TypeSizes.sizeofUnsignedVInt(spec.clusteringPrefixSize);</span>
<span class="fc" id="L289">                    size += Selector.serializer.serializedSize(spec.selector, version);</span>
<span class="fc" id="L290">                    break;</span>
                default:
<span class="nc" id="L292">                    throw new AssertionError(&quot;Unknow aggregation kind: &quot; + aggregationSpec.kind());</span>
            }
<span class="fc" id="L294">            return size;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>