<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Duration.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3</a> &gt; <span class="el_source">Duration.java</span></div><h1>Duration.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3;

import java.util.Calendar;
import java.util.Locale;
import java.util.TimeZone;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.google.common.base.Objects;

import org.apache.cassandra.serializers.MarshalException;

import static org.apache.cassandra.cql3.statements.RequestValidations.checkFalse;
import static org.apache.cassandra.cql3.statements.RequestValidations.checkTrue;
import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;
import static org.apache.commons.lang3.time.DateUtils.MILLIS_PER_DAY;

import io.netty.util.concurrent.FastThreadLocal;

/**
 * Represents a duration. A durations store separately months, days, and seconds due to the fact that
 * the number of days in a month varies, and a day can have 23 or 25 hours if a daylight saving is involved.
 */
public final class Duration
{
    public static final long NANOS_PER_MICRO = 1000L;
    public static final long NANOS_PER_MILLI = 1000 * NANOS_PER_MICRO;
    public static final long NANOS_PER_SECOND = 1000 * NANOS_PER_MILLI;
    public static final long NANOS_PER_MINUTE = 60 * NANOS_PER_SECOND;
    public static final long NANOS_PER_HOUR = 60 * NANOS_PER_MINUTE;
    public static final int DAYS_PER_WEEK = 7;
    public static final int MONTHS_PER_YEAR = 12;

    // For some operations, like floor, a Calendar is needed if months or years are involved. Unfortunatly, creating a
    // Calendar is a costly operation so instead of creating one with every call we reuse them.
<span class="fc" id="L53">    private static final FastThreadLocal&lt;Calendar&gt; CALENDAR_PROVIDER = new FastThreadLocal&lt;Calendar&gt;()</span>
<span class="fc" id="L54">    {</span>
        @Override
        public Calendar initialValue()
        {
<span class="fc" id="L58">            return Calendar.getInstance(TimeZone.getTimeZone(&quot;UTC&quot;), Locale.US);</span>
        }
    };

    /**
     * The Regexp used to parse the duration provided as String.
     */
<span class="fc" id="L65">    private static final Pattern STANDARD_PATTERN =</span>
<span class="fc" id="L66">            Pattern.compile(&quot;\\G(\\d+)(y|Y|mo|MO|mO|Mo|w|W|d|D|h|H|s|S|ms|MS|mS|Ms|us|US|uS|Us|µs|µS|ns|NS|nS|Ns|m|M)&quot;);</span>

    /**
     * The Regexp used to parse the duration when provided in the ISO 8601 format with designators.
     */
<span class="fc" id="L71">    private static final Pattern ISO8601_PATTERN =</span>
<span class="fc" id="L72">            Pattern.compile(&quot;P((\\d+)Y)?((\\d+)M)?((\\d+)D)?(T((\\d+)H)?((\\d+)M)?((\\d+)S)?)?&quot;);</span>

    /**
     * The Regexp used to parse the duration when provided in the ISO 8601 format with designators.
     */
<span class="fc" id="L77">    private static final Pattern ISO8601_WEEK_PATTERN = Pattern.compile(&quot;P(\\d+)W&quot;);</span>

    /**
     * The Regexp used to parse the duration when provided in the ISO 8601 alternative format.
     */
<span class="fc" id="L82">    private static final Pattern ISO8601_ALTERNATIVE_PATTERN =</span>
<span class="fc" id="L83">            Pattern.compile(&quot;P(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})&quot;);</span>

    /**
     * The number of months.
     */
    private final int months;

    /**
     * The number of days.
     */
    private final int days;

    /**
     * The number of nanoseconds.
     */
    private final long nanoseconds;

    /**
     * Creates a duration. A duration can be negative.
     * In this case all the non zero values must be negatives.
     *
     * @param months the number of months
     * @param days the number of days
     * @param nanoseconds the number of nanoseconds
     */
    private Duration(int months, int days, long nanoseconds)
<span class="fc" id="L109">    {</span>
        // Makes sure that all the values are negatives if one of them is
<span class="pc bpc" id="L111" title="9 of 12 branches missed.">        assert (months &gt;= 0 &amp;&amp; days &gt;= 0 &amp;&amp; nanoseconds &gt;= 0)</span>
            || ((months &lt;= 0 &amp;&amp; days &lt;=0 &amp;&amp; nanoseconds &lt;=0));

<span class="fc" id="L114">        this.months = months;</span>
<span class="fc" id="L115">        this.days = days;</span>
<span class="fc" id="L116">        this.nanoseconds = nanoseconds;</span>
<span class="fc" id="L117">    }</span>

    public static Duration newInstance(int months, int days, long nanoseconds)
    {
<span class="fc" id="L121">        return new Duration(months, days, nanoseconds);</span>
    }

    /**
     * Converts a &lt;code&gt;String&lt;/code&gt; into a duration.
     * &lt;p&gt;The accepted formats are:
     * &lt;ul&gt;
     * &lt;li&gt;multiple digits followed by a time unit like: 12h30m where the time unit can be:
     *   &lt;ul&gt;
     *      &lt;li&gt;{@code y}: years&lt;/li&gt;
     *      &lt;li&gt;{@code m}: months&lt;/li&gt;
     *      &lt;li&gt;{@code w}: weeks&lt;/li&gt;
     *      &lt;li&gt;{@code d}: days&lt;/li&gt;
     *      &lt;li&gt;{@code h}: hours&lt;/li&gt;
     *      &lt;li&gt;{@code m}: minutes&lt;/li&gt;
     *      &lt;li&gt;{@code s}: seconds&lt;/li&gt;
     *      &lt;li&gt;{@code ms}: milliseconds&lt;/li&gt;
     *      &lt;li&gt;{@code us} or {@code µs}: microseconds&lt;/li&gt;
     *      &lt;li&gt;{@code ns}: nanoseconds&lt;/li&gt;
     *   &lt;/ul&gt;
     * &lt;/li&gt;
     * &lt;li&gt;ISO 8601 format:  P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W&lt;/li&gt;
     * &lt;li&gt;ISO 8601 alternative format: P[YYYY]-[MM]-[DD]T[hh]:[mm]:[ss]&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param input the &lt;code&gt;String&lt;/code&gt; to convert
     * @return a number of nanoseconds
     */
    public static Duration from(String input)
    {
<span class="fc" id="L151">        boolean isNegative = input.startsWith(&quot;-&quot;);</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">        String source = isNegative ? input.substring(1) : input;</span>

<span class="pc bpc" id="L154" title="1 of 2 branches missed.">        if (source.startsWith(&quot;P&quot;))</span>
        {
<span class="nc bnc" id="L156" title="All 2 branches missed.">            if (source.endsWith(&quot;W&quot;))</span>
<span class="nc" id="L157">                return parseIso8601WeekFormat(isNegative, source);</span>

<span class="nc bnc" id="L159" title="All 2 branches missed.">            if (source.contains(&quot;-&quot;))</span>
<span class="nc" id="L160">                return parseIso8601AlternativeFormat(isNegative, source);</span>

<span class="nc" id="L162">            return parseIso8601Format(isNegative, source);</span>
        }
<span class="fc" id="L164">        return parseStandardFormat(isNegative, source);</span>
    }

    private static Duration parseIso8601Format(boolean isNegative, String source)
    {
<span class="nc" id="L169">        Matcher matcher = ISO8601_PATTERN.matcher(source);</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (!matcher.matches())</span>
<span class="nc" id="L171">            throw invalidRequest(&quot;Unable to convert '%s' to a duration&quot;, source);</span>

<span class="nc" id="L173">        Builder builder = new Builder(isNegative);</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (matcher.group(1) != null)</span>
<span class="nc" id="L175">            builder.addYears(groupAsLong(matcher, 2));</span>

<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (matcher.group(3) != null)</span>
<span class="nc" id="L178">            builder.addMonths(groupAsLong(matcher, 4));</span>

<span class="nc bnc" id="L180" title="All 2 branches missed.">        if (matcher.group(5) != null)</span>
<span class="nc" id="L181">            builder.addDays(groupAsLong(matcher, 6));</span>

        // Checks if the String contains time information
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (matcher.group(7) != null)</span>
        {
<span class="nc bnc" id="L186" title="All 2 branches missed.">            if (matcher.group(8) != null)</span>
<span class="nc" id="L187">                builder.addHours(groupAsLong(matcher, 9));</span>

<span class="nc bnc" id="L189" title="All 2 branches missed.">            if (matcher.group(10) != null)</span>
<span class="nc" id="L190">                builder.addMinutes(groupAsLong(matcher, 11));</span>

<span class="nc bnc" id="L192" title="All 2 branches missed.">            if (matcher.group(12) != null)</span>
<span class="nc" id="L193">                builder.addSeconds(groupAsLong(matcher, 13));</span>
        }
<span class="nc" id="L195">        return builder.build();</span>
    }

    private static Duration parseIso8601AlternativeFormat(boolean isNegative, String source)
    {
<span class="nc" id="L200">        Matcher matcher = ISO8601_ALTERNATIVE_PATTERN.matcher(source);</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (!matcher.matches())</span>
<span class="nc" id="L202">            throw invalidRequest(&quot;Unable to convert '%s' to a duration&quot;, source);</span>

<span class="nc" id="L204">        return new Builder(isNegative).addYears(groupAsLong(matcher, 1))</span>
<span class="nc" id="L205">                                      .addMonths(groupAsLong(matcher, 2))</span>
<span class="nc" id="L206">                                      .addDays(groupAsLong(matcher, 3))</span>
<span class="nc" id="L207">                                      .addHours(groupAsLong(matcher, 4))</span>
<span class="nc" id="L208">                                      .addMinutes(groupAsLong(matcher, 5))</span>
<span class="nc" id="L209">                                      .addSeconds(groupAsLong(matcher, 6))</span>
<span class="nc" id="L210">                                      .build();</span>
    }

    private static Duration parseIso8601WeekFormat(boolean isNegative, String source)
    {
<span class="nc" id="L215">        Matcher matcher = ISO8601_WEEK_PATTERN.matcher(source);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">        if (!matcher.matches())</span>
<span class="nc" id="L217">            throw invalidRequest(&quot;Unable to convert '%s' to a duration&quot;, source);</span>

<span class="nc" id="L219">        return new Builder(isNegative).addWeeks(groupAsLong(matcher, 1))</span>
<span class="nc" id="L220">                                      .build();</span>
    }

    private static Duration parseStandardFormat(boolean isNegative, String source)
    {
<span class="fc" id="L225">        Matcher matcher = STANDARD_PATTERN.matcher(source);</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">        if (!matcher.find())</span>
<span class="nc" id="L227">            throw invalidRequest(&quot;Unable to convert '%s' to a duration&quot;, source);</span>

<span class="fc" id="L229">        Builder builder = new Builder(isNegative);</span>
<span class="fc" id="L230">        boolean done = false;</span>

        do
        {
<span class="fc" id="L234">            long number = groupAsLong(matcher, 1);</span>
<span class="fc" id="L235">            String symbol = matcher.group(2);</span>
<span class="fc" id="L236">            add(builder, number, symbol);</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">            done = matcher.end() == source.length();</span>
        }
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">        while (matcher.find());</span>

<span class="pc bpc" id="L241" title="1 of 2 branches missed.">        if (!done)</span>
<span class="nc" id="L242">            throw invalidRequest(&quot;Unable to convert '%s' to a duration&quot;, source);</span>

<span class="fc" id="L244">        return builder.build();</span>
    }

    private static long groupAsLong(Matcher matcher, int group)
    {
<span class="fc" id="L249">        return Long.parseLong(matcher.group(group));</span>
    }

    private static Builder add(Builder builder, long number, String symbol)
    {
<span class="pc bpc" id="L254" title="9 of 11 branches missed.">        switch (symbol.toLowerCase())</span>
        {
<span class="nc" id="L256">            case &quot;y&quot;: return builder.addYears(number);</span>
<span class="fc" id="L257">            case &quot;mo&quot;: return builder.addMonths(number);</span>
<span class="nc" id="L258">            case &quot;w&quot;: return builder.addWeeks(number);</span>
<span class="nc" id="L259">            case &quot;d&quot;: return builder.addDays(number);</span>
<span class="nc" id="L260">            case &quot;h&quot;: return builder.addHours(number);</span>
<span class="fc" id="L261">            case &quot;m&quot;: return builder.addMinutes(number);</span>
<span class="nc" id="L262">            case &quot;s&quot;: return builder.addSeconds(number);</span>
<span class="nc" id="L263">            case &quot;ms&quot;: return builder.addMillis(number);</span>
            case &quot;us&quot;:
<span class="nc" id="L265">            case &quot;µs&quot;: return builder.addMicros(number);</span>
<span class="nc" id="L266">            case &quot;ns&quot;: return builder.addNanos(number);</span>
        }
<span class="nc" id="L268">        throw new MarshalException(String.format(&quot;Unknown duration symbol '%s'&quot;, symbol));</span>
    }

    public int getMonths()
    {
<span class="fc" id="L273">        return months;</span>
    }

    public int getDays()
    {
<span class="fc" id="L278">        return days;</span>
    }

    public long getNanoseconds()
    {
<span class="fc" id="L283">        return nanoseconds;</span>
    }

    /**
     * Adds this duration to the specified time in milliseconds.
     * @param timeInMillis the time to which the duration must be added
     * @return the specified time plus this duration
     */
    public long addTo(long timeInMillis)
    {
<span class="nc" id="L293">        return add(timeInMillis, months, days, nanoseconds);</span>
    }

    /**
     * Substracts this duration from the specified time in milliseconds.
     * @param timeInMillis the time from which the duration must be substracted
     * @return the specified time minus this duration
     */
    public long substractFrom(long timeInMillis)
    {
<span class="nc" id="L303">        return add(timeInMillis, -months, -days, -nanoseconds);</span>
    }

    /**
     * Adds the specified months, days and nanoseconds to the specified time in milliseconds.
     *
     * @param timeInMillis the time to which the months, days and nanoseconds must be added
     * @param months the number of months to add
     * @param days the number of days to add
     * @param nanoseconds the number of nanoseconds to add
     * @return the specified time plus the months, days and nanoseconds
     */
    private static long add(long timeInMillis, int months, int days, long nanoseconds)
    {
        // If the duration does not contains any months we can can ignore daylight saving,
        // as time zones are not supported, and simply look at the milliseconds
<span class="nc bnc" id="L319" title="All 2 branches missed.">        if (months == 0)</span>
        {
<span class="nc" id="L321">            long durationInMillis = (days * MILLIS_PER_DAY) + (nanoseconds / NANOS_PER_MILLI);</span>
<span class="nc" id="L322">            return timeInMillis + durationInMillis;</span>
        }

<span class="nc" id="L325">        Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone(&quot;UTC&quot;), Locale.US);</span>
<span class="nc" id="L326">        calendar.setTimeInMillis(timeInMillis);</span>
<span class="nc" id="L327">        calendar.add(Calendar.MONTH, months);</span>
<span class="nc" id="L328">        calendar.add(Calendar.DAY_OF_MONTH, days);</span>
<span class="nc" id="L329">        calendar.add(Calendar.MILLISECOND, (int) (nanoseconds / NANOS_PER_MILLI));</span>
<span class="nc" id="L330">        return calendar.getTimeInMillis();</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L336">        return Objects.hashCode(days, months, nanoseconds);</span>
    }

    @Override
    public boolean equals(Object obj)
    {
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (!(obj instanceof Duration))</span>
<span class="nc" id="L343">            return false;</span>

<span class="nc" id="L345">        Duration other = (Duration) obj;</span>
<span class="nc bnc" id="L346" title="All 6 branches missed.">        return days == other.days</span>
                &amp;&amp; months == other.months
                &amp;&amp; nanoseconds == other.nanoseconds;
    }

    @Override
    public String toString()
    {
<span class="nc" id="L354">        StringBuilder builder = new StringBuilder();</span>

<span class="nc bnc" id="L356" title="All 2 branches missed.">        if (isNegative())</span>
<span class="nc" id="L357">            builder.append('-');</span>

<span class="nc" id="L359">        long remainder = append(builder, Math.abs(months), MONTHS_PER_YEAR, &quot;y&quot;);</span>
<span class="nc" id="L360">        append(builder, remainder, 1, &quot;mo&quot;);</span>

<span class="nc" id="L362">        append(builder, Math.abs(days), 1, &quot;d&quot;);</span>

<span class="nc bnc" id="L364" title="All 2 branches missed.">        if (nanoseconds != 0)</span>
        {
<span class="nc" id="L366">            remainder = append(builder, Math.abs(nanoseconds), NANOS_PER_HOUR, &quot;h&quot;);</span>
<span class="nc" id="L367">            remainder = append(builder, remainder, NANOS_PER_MINUTE, &quot;m&quot;);</span>
<span class="nc" id="L368">            remainder = append(builder, remainder, NANOS_PER_SECOND, &quot;s&quot;);</span>
<span class="nc" id="L369">            remainder = append(builder, remainder, NANOS_PER_MILLI, &quot;ms&quot;);</span>
<span class="nc" id="L370">            remainder = append(builder, remainder, NANOS_PER_MICRO, &quot;us&quot;);</span>
<span class="nc" id="L371">            append(builder, remainder, 1, &quot;ns&quot;);</span>
        }
<span class="nc" id="L373">        return builder.toString();</span>
    }

    /**
     * Checks if that duration has a day precision (nothing bellow the day level).
     * @return {@code true} if that duration has a day precision, {@code false} otherwise
     */
    public boolean hasDayPrecision()
    {
<span class="nc bnc" id="L382" title="All 2 branches missed.">        return getNanoseconds() == 0;</span>
    }

    /**
     * Checks if that duration has a millisecond precision (nothing bellow the millisecond level).
     * @return {@code true} if that duration has a millisecond precision, {@code false} otherwise
     */
    public boolean hasMillisecondPrecision()
    {
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">        return getNanoseconds() % NANOS_PER_MILLI == 0;</span>
    }

    /**
     * Appends the result of the division to the specified builder if the dividend is not zero.
     *
     * @param builder the builder to append to
     * @param dividend the dividend
     * @param divisor the divisor
     * @param unit the time unit to append after the result of the division
     * @return the remainder of the division
     */
    private static long append(StringBuilder builder, long dividend, long divisor, String unit)
    {
<span class="nc bnc" id="L405" title="All 4 branches missed.">        if (dividend == 0 || dividend &lt; divisor)</span>
<span class="nc" id="L406">            return dividend;</span>

<span class="nc" id="L408">        builder.append(dividend / divisor).append(unit);</span>
<span class="nc" id="L409">        return dividend % divisor;</span>
    }

    /**
     * Rounds a timestamp down to the closest multiple of a duration.
     *
     * @param timeInMillis the time to round in millisecond
     * @param duration the duration
     * @param startingTimeInMillis the time offset in milliseconds
     * @return the timestamp rounded down to the closest multiple of the duration
     */
    public static long floorTimestamp(long timeInMillis, Duration duration, long startingTimeInMillis)
    {
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">        checkFalse(startingTimeInMillis &gt; timeInMillis, &quot;The floor function starting time is greater than the provided time&quot;);</span>
<span class="fc" id="L423">        checkFalse(duration.isNegative(), &quot;Negative durations are not supported by the floor function&quot;);</span>

        // If the duration does not contain any months we can ignore daylight saving,
        // as time zones are not supported, and simply look at the milliseconds
<span class="fc bfc" id="L427" title="All 2 branches covered.">        if (duration.months == 0)</span>
        {
<span class="fc" id="L429">            long durationInMillis = getDurationMilliseconds(duration);</span>

            // If the duration is smaller than millisecond
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">            if (durationInMillis == 0)</span>
<span class="nc" id="L433">                return timeInMillis;</span>

<span class="fc" id="L435">            long delta = (timeInMillis - startingTimeInMillis) % durationInMillis;</span>
<span class="fc" id="L436">            return timeInMillis - delta;</span>
        }

        /*
         * Otherwise, we resort to Calendar for the computation.
         * What we're trying to compute is the largest integer 'multiplier' value such that
         *   startingTimeMillis + (multiplier * duration) &lt;= timeInMillis
         * at which point we want to return 'startingTimeMillis + (multiplier * duration)'.
         *
         * One option would be to add 'duration' to 'statingTimeMillis' in a loop until we
         * cross 'timeInMillis' and return how many iterator we did. But this might be slow if there is very many
         * steps.
         *
         * So instead we first estimate 'multiplier' using the number of months between 'startingTimeMillis'
         * and 'timeInMillis' ('durationInMonths' below) and the duration months. As the real computation
         * should also take the 'days' and 'nanoseconds' parts of the duration, this multiplier may overshoot,
         * so we detect it and work back from that, decreasing the multiplier until we find the proper one.
         */

<span class="fc" id="L455">        Calendar calendar = CALENDAR_PROVIDER.get();</span>

<span class="fc" id="L457">        calendar.setTimeInMillis(timeInMillis);</span>
<span class="fc" id="L458">        int year = calendar.get(Calendar.YEAR);</span>
<span class="fc" id="L459">        int month = calendar.get(Calendar.MONTH);</span>

<span class="fc" id="L461">        calendar.setTimeInMillis(startingTimeInMillis);</span>
<span class="fc" id="L462">        int startingYear = calendar.get(Calendar.YEAR);</span>
<span class="fc" id="L463">        int startingMonth = calendar.get(Calendar.MONTH);</span>

<span class="fc" id="L465">        int durationInMonths = (year - startingYear) * MONTHS_PER_YEAR + (month - startingMonth);</span>
<span class="fc" id="L466">        int multiplier = durationInMonths / duration.months;</span>

<span class="fc" id="L468">        calendar.add(Calendar.MONTH, multiplier * duration.months);</span>

        // If the duration was only containing months, we are done.
<span class="pc bpc" id="L471" title="2 of 4 branches missed.">        if (duration.days == 0 &amp;&amp; duration.nanoseconds == 0)</span>
<span class="fc" id="L472">            return calendar.getTimeInMillis();</span>

<span class="nc" id="L474">        long durationInMillis = getDurationMilliseconds(duration);</span>
<span class="nc" id="L475">        long floor = calendar.getTimeInMillis() + (multiplier * durationInMillis);</span>

        // Once the milliseconds have been added we might have gone too far. If it is the case we will reduce the
        // multiplier until the floor value is smaller than time in millis.
<span class="nc bnc" id="L479" title="All 2 branches missed.">        while (floor &gt; timeInMillis)</span>
        {
<span class="nc" id="L481">            multiplier--;</span>
<span class="nc" id="L482">            calendar.add(Calendar.MONTH, -duration.months);</span>
<span class="nc" id="L483">            floor = calendar.getTimeInMillis() + (multiplier * durationInMillis);</span>
        }

<span class="nc" id="L486">        return Math.max(startingTimeInMillis, floor);</span>
    }

    /**
     * Returns the milliseconds part of the duration ignoring the month part
     *
     * @param duration the duration
     * @return the milliseconds corresponding to the duration days and nanoseconds
     */
    private static long getDurationMilliseconds(Duration duration)
    {
        // We can ignore daylight saving as time zones are not supported
<span class="fc" id="L498">        return (duration.days * MILLIS_PER_DAY) + (duration.nanoseconds / NANOS_PER_MILLI);</span>
    }

    /**
     * Rounds a time down to the closest multiple of a duration.
     *
     * @param timeInNanos the time of day in nanoseconds
     * @param duration the duration
     * @return the time rounded down to the closest multiple of the duration
     */
    public static long floorTime(long timeInNanos, Duration duration)
    {
<span class="fc" id="L510">        checkFalse(duration.isNegative(), &quot;Negative durations are not supported by the floor function&quot;);</span>
<span class="pc bpc" id="L511" title="3 of 6 branches missed.">        checkFalse(duration.getMonths() != 0 || duration.getDays() != 0 || duration.getNanoseconds() &gt; (NANOS_PER_HOUR * 24),</span>
                   &quot;For time values, the floor can only be computed for durations smaller that a day&quot;);

<span class="pc bpc" id="L514" title="1 of 2 branches missed.">        if (duration.nanoseconds == 0)</span>
<span class="nc" id="L515">            return timeInNanos;</span>

<span class="fc" id="L517">        long delta = timeInNanos % duration.nanoseconds;</span>
<span class="fc" id="L518">        return timeInNanos - delta;</span>
    }

    /**
     * Checks if the duration is negative.
     * @return {@code true} if the duration is negative, {@code false} otherwise
     */
    public boolean isNegative()
    {
<span class="pc bpc" id="L527" title="3 of 6 branches missed.">        return nanoseconds &lt; 0 || days &lt; 0 || months &lt; 0;</span>
    }

    private static class Builder
    {
        /**
         * {@code true} if the duration is a negative one, {@code false} otherwise.
         */
        private final boolean isNegative;

        /**
         * The number of months.
         */
        private int months;

        /**
         * The number of days.
         */
        private int days;

        /**
         * The number of nanoseconds.
         */
        private long nanoseconds;

        /**
         * We need to make sure that the values for each units are provided in order.
         */
        private int currentUnitIndex;

        public Builder(boolean isNegative)
<span class="fc" id="L558">        {</span>
<span class="fc" id="L559">            this.isNegative = isNegative;</span>
<span class="fc" id="L560">        }</span>

        /**
         * Adds the specified amount of years.
         *
         * @param numberOfYears the number of years to add.
         * @return this {@code Builder}
         */
        public Builder addYears(long numberOfYears)
        {
<span class="nc" id="L570">            validateOrder(1);</span>
<span class="nc" id="L571">            validateMonths(numberOfYears, MONTHS_PER_YEAR);</span>
<span class="nc" id="L572">            months += numberOfYears * MONTHS_PER_YEAR;</span>
<span class="nc" id="L573">            return this;</span>
        }

        /**
         * Adds the specified amount of months.
         *
         * @param numberOfMonths the number of months to add.
         * @return this {@code Builder}
         */
        public Builder addMonths(long numberOfMonths)
        {
<span class="fc" id="L584">            validateOrder(2);</span>
<span class="fc" id="L585">            validateMonths(numberOfMonths, 1);</span>
<span class="fc" id="L586">            months += numberOfMonths;</span>
<span class="fc" id="L587">            return this;</span>
        }

        /**
         * Adds the specified amount of weeks.
         *
         * @param numberOfWeeks the number of weeks to add.
         * @return this {@code Builder}
         */
        public Builder addWeeks(long numberOfWeeks)
        {
<span class="nc" id="L598">            validateOrder(3);</span>
<span class="nc" id="L599">            validateDays(numberOfWeeks, DAYS_PER_WEEK);</span>
<span class="nc" id="L600">            days += numberOfWeeks * DAYS_PER_WEEK;</span>
<span class="nc" id="L601">            return this;</span>
        }

        /**
         * Adds the specified amount of days.
         *
         * @param numberOfDays the number of days to add.
         * @return this {@code Builder}
         */
        public Builder addDays(long numberOfDays)
        {
<span class="nc" id="L612">            validateOrder(4);</span>
<span class="nc" id="L613">            validateDays(numberOfDays, 1);</span>
<span class="nc" id="L614">            days += numberOfDays;</span>
<span class="nc" id="L615">            return this;</span>
        }

        /**
         * Adds the specified amount of hours.
         *
         * @param numberOfHours the number of hours to add.
         * @return this {@code Builder}
         */
        public Builder addHours(long numberOfHours)
        {
<span class="nc" id="L626">            validateOrder(5);</span>
<span class="nc" id="L627">            validateNanos(numberOfHours, NANOS_PER_HOUR);</span>
<span class="nc" id="L628">            nanoseconds += numberOfHours * NANOS_PER_HOUR;</span>
<span class="nc" id="L629">            return this;</span>
        }

        /**
         * Adds the specified amount of minutes.
         *
         * @param numberOfMinutes the number of minutes to add.
         * @return this {@code Builder}
         */
        public Builder addMinutes(long numberOfMinutes)
        {
<span class="fc" id="L640">            validateOrder(6);</span>
<span class="fc" id="L641">            validateNanos(numberOfMinutes, NANOS_PER_MINUTE);</span>
<span class="fc" id="L642">            nanoseconds += numberOfMinutes * NANOS_PER_MINUTE;</span>
<span class="fc" id="L643">            return this;</span>
        }

        /**
         * Adds the specified amount of seconds.
         *
         * @param numberOfSeconds the number of seconds to add.
         * @return this {@code Builder}
         */
        public Builder addSeconds(long numberOfSeconds)
        {
<span class="nc" id="L654">            validateOrder(7);</span>
<span class="nc" id="L655">            validateNanos(numberOfSeconds, NANOS_PER_SECOND);</span>
<span class="nc" id="L656">            nanoseconds += numberOfSeconds * NANOS_PER_SECOND;</span>
<span class="nc" id="L657">            return this;</span>
        }

        /**
         * Adds the specified amount of milliseconds.
         *
         * @param numberOfMillis the number of milliseconds to add.
         * @return this {@code Builder}
         */
        public Builder addMillis(long numberOfMillis)
        {
<span class="nc" id="L668">            validateOrder(8);</span>
<span class="nc" id="L669">            validateNanos(numberOfMillis, NANOS_PER_MILLI);</span>
<span class="nc" id="L670">            nanoseconds += numberOfMillis * NANOS_PER_MILLI;</span>
<span class="nc" id="L671">            return this;</span>
        }

        /**
         * Adds the specified amount of microseconds.
         *
         * @param numberOfMicros the number of microseconds to add.
         * @return this {@code Builder}
         */
        public Builder addMicros(long numberOfMicros)
        {
<span class="nc" id="L682">            validateOrder(9);</span>
<span class="nc" id="L683">            validateNanos(numberOfMicros, NANOS_PER_MICRO);</span>
<span class="nc" id="L684">            nanoseconds += numberOfMicros * NANOS_PER_MICRO;</span>
<span class="nc" id="L685">            return this;</span>
        }

        /**
         * Adds the specified amount of nanoseconds.
         *
         * @param numberOfNanos the number of nanoseconds to add.
         * @return this {@code Builder}
         */
        public Builder addNanos(long numberOfNanos)
        {
<span class="nc" id="L696">            validateOrder(10);</span>
<span class="nc" id="L697">            validateNanos(numberOfNanos, 1);</span>
<span class="nc" id="L698">            nanoseconds += numberOfNanos;</span>
<span class="nc" id="L699">            return this;</span>
        }

        /**
         * Validates that the total number of months can be stored.
         * @param units the number of units that need to be added
         * @param monthsPerUnit the number of days per unit
         */
        private void validateMonths(long units, int monthsPerUnit)
        {
<span class="fc" id="L709">            validate(units, (Integer.MAX_VALUE - months) / monthsPerUnit, &quot;months&quot;);</span>
<span class="fc" id="L710">        }</span>

        /**
         * Validates that the total number of days can be stored.
         * @param units the number of units that need to be added
         * @param daysPerUnit the number of days per unit
         */
        private void validateDays(long units, int daysPerUnit)
        {
<span class="nc" id="L719">            validate(units, (Integer.MAX_VALUE - days) / daysPerUnit, &quot;days&quot;);</span>
<span class="nc" id="L720">        }</span>

        /**
         * Validates that the total number of nanoseconds can be stored.
         * @param units the number of units that need to be added
         * @param nanosPerUnit the number of nanoseconds per unit
         */
        private void validateNanos(long units, long nanosPerUnit)
        {
<span class="fc" id="L729">            validate(units, (Long.MAX_VALUE - nanoseconds) / nanosPerUnit, &quot;nanoseconds&quot;);</span>
<span class="fc" id="L730">        }</span>

        /**
         * Validates that the specified amount is less than the limit.
         * @param units the number of units to check
         * @param limit the limit on the number of units
         * @param unitName the unit name
         */
        private void validate(long units, long limit, String unitName)
        {
<span class="pc bpc" id="L740" title="1 of 2 branches missed.">            checkTrue(units &lt;= limit,</span>
                      &quot;Invalid duration. The total number of %s must be less or equal to %s&quot;,
                      unitName,
<span class="fc" id="L743">                      Integer.MAX_VALUE);</span>
<span class="fc" id="L744">        }</span>

        /**
         * Validates that the duration values are added in the proper order.
         * @param unitIndex the unit index (e.g. years=1, months=2, ...)
         */
        private void validateOrder(int unitIndex)
        {
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">            if (unitIndex == currentUnitIndex)</span>
<span class="nc" id="L753">                throw invalidRequest(&quot;Invalid duration. The %s are specified multiple times&quot;, getUnitName(unitIndex));</span>

<span class="pc bpc" id="L755" title="1 of 2 branches missed.">            if (unitIndex &lt;= currentUnitIndex)</span>
<span class="nc" id="L756">                throw invalidRequest(&quot;Invalid duration. The %s should be after %s&quot;,</span>
<span class="nc" id="L757">                      getUnitName(currentUnitIndex),</span>
<span class="nc" id="L758">                      getUnitName(unitIndex));</span>

<span class="fc" id="L760">            currentUnitIndex = unitIndex;</span>
<span class="fc" id="L761">        }</span>

        /**
         * Returns the name of the unit corresponding to the specified index.
         * @param unitIndex the unit index
         * @return the name of the unit corresponding to the specified index.
         */
        private String getUnitName(int unitIndex)
        {
<span class="nc bnc" id="L770" title="All 11 branches missed.">            switch (unitIndex)</span>
            {
<span class="nc" id="L772">                case 1: return &quot;years&quot;;</span>
<span class="nc" id="L773">                case 2: return &quot;months&quot;;</span>
<span class="nc" id="L774">                case 3: return &quot;weeks&quot;;</span>
<span class="nc" id="L775">                case 4: return &quot;days&quot;;</span>
<span class="nc" id="L776">                case 5: return &quot;hours&quot;;</span>
<span class="nc" id="L777">                case 6: return &quot;minutes&quot;;</span>
<span class="nc" id="L778">                case 7: return &quot;seconds&quot;;</span>
<span class="nc" id="L779">                case 8: return &quot;milliseconds&quot;;</span>
<span class="nc" id="L780">                case 9: return &quot;microseconds&quot;;</span>
<span class="nc" id="L781">                case 10: return &quot;nanoseconds&quot;;</span>
<span class="nc" id="L782">                default: throw new AssertionError(&quot;unknown unit index: &quot; + unitIndex);</span>
            }
        }

        public Duration build()
        {
<span class="pc bpc" id="L788" title="1 of 2 branches missed.">            return isNegative ? new Duration(-months, -days, -nanoseconds) : new Duration(months, days, nanoseconds);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>