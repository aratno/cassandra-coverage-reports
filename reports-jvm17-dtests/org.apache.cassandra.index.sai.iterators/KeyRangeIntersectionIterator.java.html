<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KeyRangeIntersectionIterator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.index.sai.iterators</a> &gt; <span class="el_source">KeyRangeIntersectionIterator.java</span></div><h1>KeyRangeIntersectionIterator.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.index.sai.iterators;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

import com.google.common.annotations.VisibleForTesting;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.config.CassandraRelevantProperties;
import org.apache.cassandra.index.sai.utils.PrimaryKey;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.tracing.Tracing;

/**
 * A simple intersection iterator that makes no real attempts at optimising the iteration apart from
 * initially sorting the ranges. This implementation also supports an intersection limit which limits
 * the number of ranges that will be included in the intersection. This currently defaults to 2.
 */
@SuppressWarnings({&quot;resource&quot;, &quot;RedundantSuppression&quot;})
public class KeyRangeIntersectionIterator extends KeyRangeIterator
{
<span class="fc" id="L42">    private static final Logger logger = LoggerFactory.getLogger(KeyRangeIntersectionIterator.class);</span>

    static
    {
<span class="fc" id="L46">        logger.info(String.format(&quot;Storage attached index intersection clause limit is %d&quot;, CassandraRelevantProperties.SAI_INTERSECTION_CLAUSE_LIMIT.getInt()));</span>
<span class="fc" id="L47">    }</span>

    private final List&lt;KeyRangeIterator&gt; ranges;

    private KeyRangeIntersectionIterator(Builder.Statistics statistics, List&lt;KeyRangeIterator&gt; ranges)
    {
<span class="nc" id="L53">        super(statistics);</span>
<span class="nc" id="L54">        this.ranges = ranges;</span>
<span class="nc" id="L55">    }</span>

    @Override
    protected PrimaryKey computeNext()
    {
        // Range iterator that has been advanced in the previous cycle of the outer loop.
        // Initially there hasn't been the previous cycle, so set to null.
<span class="nc" id="L62">        int alreadyAvanced = -1;</span>

        // The highest primary key seen on any range iterator so far.
        // It can become null when we reach the end of the iterator.
<span class="nc" id="L66">        PrimaryKey highestKey = getCurrent();</span>

        outer:
        // We need to check if highestKey exceeds the maximum because the maximum is
        // the lowest value maximum of all the ranges. As a result any value could
        // potentially exceed it.
<span class="nc bnc" id="L72" title="All 4 branches missed.">        while (highestKey != null &amp;&amp; highestKey.compareTo(getMaximum()) &lt;= 0)</span>
        {
            // Try advance all iterators to the highest key seen so far.
            // Once this inner loop finishes normally, all iterators are guaranteed to be at the same value.
<span class="nc bnc" id="L76" title="All 2 branches missed.">            for (int index = 0; index &lt; ranges.size(); index++)</span>
            {
<span class="nc bnc" id="L78" title="All 2 branches missed.">                if (index != alreadyAvanced)</span>
                {
<span class="nc" id="L80">                    KeyRangeIterator range = ranges.get(index);</span>
<span class="nc" id="L81">                    PrimaryKey nextKey = nextOrNull(range, highestKey);</span>
<span class="nc bnc" id="L82" title="All 4 branches missed.">                    if (nextKey == null || nextKey.compareTo(highestKey) &gt; 0)</span>
                    {
                        // We jumped over the highest key seen so far, so make it the new highest key.
<span class="nc" id="L85">                        highestKey = nextKey;</span>
                        // Remember this iterator to avoid advancing it again, because it is already at the highest key
<span class="nc" id="L87">                        alreadyAvanced = index;</span>
                        // This iterator jumped over, so the other iterators are lagging behind now,
                        // including the ones already advanced in the earlier cycles of the inner loop.
                        // Therefore, restart the inner loop in order to advance
                        // the other iterators except this one to match the new highest key.
<span class="nc" id="L92">                        continue outer;</span>
                    }
<span class="nc bnc" id="L94" title="All 2 branches missed.">                    assert nextKey.compareTo(highestKey) == 0:</span>
<span class="nc" id="L95">                    String.format(&quot;skipped to an item smaller than the target; &quot; +</span>
                                  &quot;iterator: %s, target key: %s, returned key: %s&quot;, range, highestKey, nextKey);
                }
            }
            // If we reached here, next() has been called at least once on each range iterator and
            // the last call to next() on each iterator returned a value equal to the highestKey.
<span class="nc" id="L101">            return highestKey;</span>
        }
<span class="nc" id="L103">        return endOfData();</span>
    }

    @Override
    protected void performSkipTo(PrimaryKey nextKey)
    {
<span class="nc bnc" id="L109" title="All 2 branches missed.">        for (KeyRangeIterator range : ranges)</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">            if (range.hasNext())</span>
<span class="nc" id="L111">                range.skipTo(nextKey);</span>
<span class="nc" id="L112">    }</span>

    @Override
    public void close()
    {
<span class="nc" id="L117">        FileUtils.closeQuietly(ranges);</span>
<span class="nc" id="L118">    }</span>

    /**
     * Fetches the next available item from the iterator, such that the item is not lower than the given key.
     * If no such items are available, returns null.
     */
    private PrimaryKey nextOrNull(KeyRangeIterator iterator, PrimaryKey minKey)
    {
<span class="nc" id="L126">        iterator.skipTo(minKey);</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        return iterator.hasNext() ? iterator.next() : null;</span>
    }

    public static Builder builder(int size)
    {
<span class="fc" id="L132">        return new Builder(size);</span>
    }

    @VisibleForTesting
    public static Builder builder(int size, int limit)
    {
<span class="nc" id="L138">        return new Builder(size, limit);</span>
    }

    @VisibleForTesting
    public static class Builder extends KeyRangeIterator.Builder
    {
        // This controls the maximum number of range iterators that will be used in the final
        // intersection of a query operation. It is set from cassandra.sai.intersection_clause_limit
        // and defaults to 2
        private final int limit;
        // tracks if any of the added ranges are disjoint with the other ranges, which is useful
        // in case of intersection, as it gives a direct answer whether the iterator is going
        // to produce any results.
        private boolean isDisjoint;

        protected final List&lt;KeyRangeIterator&gt; rangeIterators;

        Builder(int size)
        {
<span class="fc" id="L157">            this(size, CassandraRelevantProperties.SAI_INTERSECTION_CLAUSE_LIMIT.getInt());</span>
<span class="fc" id="L158">        }</span>

        Builder(int size, int limit)
        {
<span class="fc" id="L162">            super(new IntersectionStatistics());</span>
<span class="fc" id="L163">            rangeIterators = new ArrayList&lt;&gt;(size);</span>
<span class="fc" id="L164">            this.limit = limit;</span>
<span class="fc" id="L165">        }</span>

        @Override
        public KeyRangeIterator.Builder add(KeyRangeIterator range)
        {
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">            if (range == null)</span>
<span class="nc" id="L171">                return this;</span>

<span class="fc bfc" id="L173" title="All 2 branches covered.">            if (range.getCount() &gt; 0)</span>
<span class="fc" id="L174">                rangeIterators.add(range);</span>
            else
<span class="fc" id="L176">                FileUtils.closeQuietly(range);</span>

<span class="fc" id="L178">            updateStatistics(statistics, range);</span>

<span class="fc" id="L180">            return this;</span>
        }

        @Override
        public int rangeCount()
        {
<span class="fc" id="L186">            return rangeIterators.size();</span>
        }

        @Override
        public void cleanup()
        {
<span class="nc" id="L192">            FileUtils.closeQuietly(rangeIterators);</span>
<span class="nc" id="L193">        }</span>

        @Override
        protected KeyRangeIterator buildIterator()
        {
<span class="fc" id="L198">            rangeIterators.sort(Comparator.comparingLong(KeyRangeIterator::getCount));</span>
<span class="fc" id="L199">            int initialSize = rangeIterators.size();</span>
            // all ranges will be included
<span class="pc bpc" id="L201" title="3 of 4 branches missed.">            if (limit &gt;= rangeIterators.size() || limit &lt;= 0)</span>
<span class="fc" id="L202">                return buildIterator(statistics, rangeIterators);</span>

            // Apply most selective iterators during intersection, because larger number of iterators will result lots of disk seek.
<span class="nc" id="L205">            Statistics selectiveStatistics = new IntersectionStatistics();</span>
<span class="nc" id="L206">            isDisjoint = false;</span>
<span class="nc bnc" id="L207" title="All 4 branches missed.">            for (int i = rangeIterators.size() - 1; i &gt;= 0 &amp;&amp; i &gt;= limit; i--)</span>
<span class="nc" id="L208">                FileUtils.closeQuietly(rangeIterators.remove(i));</span>

<span class="nc" id="L210">            rangeIterators.forEach(range -&gt; updateStatistics(selectiveStatistics, range));</span>

<span class="nc bnc" id="L212" title="All 2 branches missed.">            if (Tracing.isTracing())</span>
<span class="nc" id="L213">                Tracing.trace(&quot;Selecting {} {} of {} out of {} indexes&quot;,</span>
<span class="nc" id="L214">                              rangeIterators.size(),</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">                              rangeIterators.size() &gt; 1 ? &quot;indexes with cardinalities&quot; : &quot;index with cardinality&quot;,</span>
<span class="nc" id="L216">                              rangeIterators.stream().map(KeyRangeIterator::getCount).map(Object::toString).collect(Collectors.joining(&quot;, &quot;)),</span>
<span class="nc" id="L217">                              initialSize);</span>

<span class="nc" id="L219">            return buildIterator(selectiveStatistics, rangeIterators);</span>
        }

        public boolean isDisjoint()
        {
<span class="nc" id="L224">            return isDisjoint;</span>
        }

        private KeyRangeIterator buildIterator(Statistics statistics, List&lt;KeyRangeIterator&gt; ranges)
        {
            // if the ranges are disjoint, or we have an intersection with an empty set,
            // we can simply return an empty iterator, because it's not going to produce any results.
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">            if (isDisjoint)</span>
            {
<span class="nc" id="L233">                FileUtils.closeQuietly(ranges);</span>
<span class="nc" id="L234">                return KeyRangeIterator.empty();</span>
            }

<span class="pc bpc" id="L237" title="1 of 2 branches missed.">            if (ranges.size() == 1)</span>
<span class="fc" id="L238">                return ranges.get(0);</span>

<span class="nc" id="L240">            return new KeyRangeIntersectionIterator(statistics, ranges);</span>
        }

        private void updateStatistics(Statistics statistics, KeyRangeIterator range)
        {
<span class="fc" id="L245">            statistics.update(range);</span>
<span class="fc" id="L246">            isDisjoint |= isDisjointInternal(statistics.min, statistics.max, range);</span>
<span class="fc" id="L247">        }</span>
    }

<span class="fc" id="L250">    private static class IntersectionStatistics extends KeyRangeIterator.Builder.Statistics</span>
    {
<span class="fc" id="L252">        private boolean empty = true;</span>

        @Override
        public void update(KeyRangeIterator range)
        {
            // minimum of the intersection is the biggest minimum of individual iterators
<span class="fc" id="L258">            min = nullSafeMax(min, range.getMinimum());</span>
            // maximum of the intersection is the smallest maximum of individual iterators
<span class="fc" id="L260">            max = nullSafeMin(max, range.getMaximum());</span>
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">            if (empty)</span>
            {
<span class="fc" id="L263">                empty = false;</span>
<span class="fc" id="L264">                count = range.getCount();</span>
            }
            else
            {
<span class="nc" id="L268">                count = Math.min(count, range.getCount());</span>
            }
<span class="fc" id="L270">        }</span>
    }

    @VisibleForTesting
    protected static boolean isDisjoint(KeyRangeIterator a, KeyRangeIterator b)
    {
<span class="nc" id="L276">        return isDisjointInternal(a.getCurrent(), a.getMaximum(), b);</span>
    }

    /**
     * Ranges are overlapping the following cases:
     *
     *   * When they have a common subrange:
     *
     *   min       b.current      max          b.max
     *   +---------|--------------+------------|
     *
     *   b.current      min       max          b.max
     *   |--------------+---------+------------|
     *
     *   min        b.current     b.max        max
     *   +----------|-------------|------------+
     *
     *
     *  If either range is empty, they're disjoint.
     */
    private static boolean isDisjointInternal(PrimaryKey min, PrimaryKey max, KeyRangeIterator b)
    {
<span class="pc bpc" id="L298" title="4 of 10 branches missed.">        return min == null || max == null || b.getCount() == 0 || min.compareTo(b.getMaximum()) &gt; 0 || b.getCurrent().compareTo(max) &gt; 0;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>