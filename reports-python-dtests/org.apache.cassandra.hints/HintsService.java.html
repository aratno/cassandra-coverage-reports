<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HintsService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.hints</a> &gt; <span class="el_source">HintsService.java</span></div><h1>HintsService.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.hints;

import java.net.UnknownHostException;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableMap;
import org.apache.cassandra.db.Keyspace;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.locator.ReplicaLayout;
import org.apache.cassandra.utils.Clock;
import org.apache.cassandra.utils.concurrent.Future;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.concurrent.ScheduledExecutors;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.config.ParameterizedClass;
import org.apache.cassandra.gms.FailureDetector;
import org.apache.cassandra.gms.IFailureDetector;
import org.apache.cassandra.locator.EndpointsForToken;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.metrics.HintedHandoffMetrics;
import org.apache.cassandra.metrics.StorageMetrics;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.service.StorageProxy;
import org.apache.cassandra.service.StorageService;
import org.apache.cassandra.utils.MBeanWrapper;
import org.apache.cassandra.utils.concurrent.UncheckedInterruptedException;

import static com.google.common.collect.Iterables.filter;
import static com.google.common.collect.Iterables.transform;

/**
 * A singleton-ish wrapper over various hints components:
 * - a catalog of all hints stores
 * - a single-threaded write executor
 * - a multi-threaded dispatch executor
 * - the buffer pool for writing hints into
 * - an optional scheduled task to clean up the applicable hints files
 *
 * The front-end for everything hints related.
 */
public final class HintsService implements HintsServiceMBean
{
<span class="fc" id="L74">    private static final Logger logger = LoggerFactory.getLogger(HintsService.class);</span>

<span class="fc" id="L76">    public static HintsService instance = new HintsService();</span>

    public static final String MBEAN_NAME = &quot;org.apache.cassandra.hints:type=HintsService&quot;;

    private static final int MIN_BUFFER_SIZE = 32 &lt;&lt; 20;
<span class="fc" id="L81">    static final ImmutableMap&lt;String, Object&gt; EMPTY_PARAMS = ImmutableMap.of();</span>

    private final HintsCatalog catalog;
    private final HintsWriteExecutor writeExecutor;
    private final HintsBufferPool bufferPool;
    final HintsDispatchExecutor dispatchExecutor;
    final AtomicBoolean isDispatchPaused;

<span class="fc" id="L89">    private volatile boolean isShutDown = false;</span>

    private final ScheduledFuture triggerFlushingFuture;
    private volatile ScheduledFuture triggerDispatchFuture;
    private final ScheduledFuture triggerCleanupFuture;

    public final HintedHandoffMetrics metrics;

    private HintsService()
    {
<span class="fc" id="L99">        this(FailureDetector.instance);</span>
<span class="fc" id="L100">    }</span>

    @VisibleForTesting
    HintsService(IFailureDetector failureDetector)
<span class="fc" id="L104">    {</span>
<span class="fc" id="L105">        File hintsDirectory = DatabaseDescriptor.getHintsDirectory();</span>
<span class="fc" id="L106">        int maxDeliveryThreads = DatabaseDescriptor.getMaxHintsDeliveryThreads();</span>

<span class="fc" id="L108">        catalog = HintsCatalog.load(hintsDirectory, createDescriptorParams());</span>
<span class="fc" id="L109">        writeExecutor = new HintsWriteExecutor(catalog);</span>

<span class="fc" id="L111">        int bufferSize = Math.max(DatabaseDescriptor.getMaxMutationSize() * 2, MIN_BUFFER_SIZE);</span>
<span class="fc" id="L112">        bufferPool = new HintsBufferPool(bufferSize, writeExecutor::flushBuffer);</span>

<span class="fc" id="L114">        isDispatchPaused = new AtomicBoolean(true);</span>
<span class="fc" id="L115">        dispatchExecutor = new HintsDispatchExecutor(hintsDirectory, maxDeliveryThreads, isDispatchPaused, failureDetector::isAlive);</span>

        // periodically empty the current content of the buffers
<span class="fc" id="L118">        int flushPeriod = DatabaseDescriptor.getHintsFlushPeriodInMS();</span>
<span class="fc" id="L119">        triggerFlushingFuture = ScheduledExecutors.optionalTasks.scheduleWithFixedDelay(() -&gt; writeExecutor.flushBufferPool(bufferPool),</span>
                                                                                        flushPeriod,
                                                                                        flushPeriod,
                                                                                        TimeUnit.MILLISECONDS);

        // periodically cleanup the expired hints
<span class="fc" id="L125">        HintsCleanupTrigger cleanupTrigger = new HintsCleanupTrigger(catalog, dispatchExecutor);</span>
<span class="fc" id="L126">        triggerCleanupFuture = ScheduledExecutors.optionalTasks.scheduleWithFixedDelay(cleanupTrigger, 1, 1, TimeUnit.HOURS);</span>

<span class="fc" id="L128">        metrics = new HintedHandoffMetrics();</span>
<span class="fc" id="L129">    }</span>

    private static ImmutableMap&lt;String, Object&gt; createDescriptorParams()
    {
<span class="fc" id="L133">        ImmutableMap.Builder&lt;String, Object&gt; builder = ImmutableMap.builder();</span>

<span class="fc" id="L135">        ParameterizedClass compressionConfig = DatabaseDescriptor.getHintsCompression();</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">        if (compressionConfig != null)</span>
        {
<span class="nc" id="L138">            ImmutableMap.Builder&lt;String, Object&gt; compressorParams = ImmutableMap.builder();</span>

<span class="nc" id="L140">            compressorParams.put(ParameterizedClass.CLASS_NAME, compressionConfig.class_name);</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">            if (compressionConfig.parameters != null)</span>
            {
<span class="nc" id="L143">                compressorParams.put(ParameterizedClass.PARAMETERS, compressionConfig.parameters);</span>
            }
<span class="nc" id="L145">            builder.put(HintsDescriptor.COMPRESSION, compressorParams.build());</span>
        }

<span class="fc" id="L148">        return builder.build();</span>
    }

    public void registerMBean()
    {
<span class="fc" id="L153">        MBeanWrapper.instance.registerMBean(this, MBEAN_NAME);</span>
<span class="fc" id="L154">    }</span>

    /**
     * Write a hint for a iterable of nodes.
     *
     * @param hostIds host ids of the hint's target nodes
     * @param hint the hint to store
     */
    public void write(Collection&lt;UUID&gt; hostIds, Hint hint)
    {
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">        if (isShutDown)</span>
<span class="nc" id="L165">            throw new IllegalStateException(&quot;HintsService is shut down and can't accept new hints&quot;);</span>

        // we have to make sure that the HintsStore instances get properly initialized - otherwise dispatch will not trigger
<span class="fc" id="L168">        catalog.maybeLoadStores(hostIds);</span>

<span class="fc" id="L170">        bufferPool.write(hostIds, hint);</span>

<span class="fc" id="L172">        StorageMetrics.totalHints.inc(hostIds.size());</span>
<span class="fc" id="L173">    }</span>

    /**
     * Write a hint for a single node.
     *
     * @param hostId host id of the hint's target node
     * @param hint the hint to store
     */
    public void write(UUID hostId, Hint hint)
    {
<span class="nc" id="L183">        write(Collections.singleton(hostId), hint);</span>
<span class="nc" id="L184">    }</span>

    /**
     * Write a hint for all replicas. Used to re-dispatch hints whose destination is either missing or no longer correct.
     */
    void writeForAllReplicas(Hint hint)
    {
<span class="nc" id="L191">        String keyspaceName = hint.mutation.getKeyspaceName();</span>
<span class="nc" id="L192">        Token token = hint.mutation.key().getToken();</span>

<span class="nc" id="L194">        EndpointsForToken replicas = ReplicaLayout.forTokenWriteLiveAndDown(Keyspace.open(keyspaceName), token).all();</span>

        // judicious use of streams: eagerly materializing probably cheaper
        // than performing filters / translations 2x extra via Iterables.filter/transform
<span class="nc" id="L198">        List&lt;UUID&gt; hostIds = replicas.stream()</span>
<span class="nc" id="L199">                .filter(replica -&gt; StorageProxy.shouldHint(replica, false))</span>
<span class="nc" id="L200">                .map(replica -&gt; StorageService.instance.getHostIdForEndpoint(replica.endpoint()))</span>
<span class="nc" id="L201">                .collect(Collectors.toList());</span>

<span class="nc" id="L203">        write(hostIds, hint);</span>
<span class="nc" id="L204">    }</span>

    /**
     * Flush the buffer pool for the selected target nodes, then fsync their writers.
     *
     * @param hostIds host ids of the nodes to flush and fsync hints for
     */
    public void flushAndFsyncBlockingly(Iterable&lt;UUID&gt; hostIds)
    {
<span class="fc" id="L213">        Iterable&lt;HintsStore&gt; stores = filter(transform(hostIds, catalog::getNullable), Objects::nonNull);</span>
<span class="fc" id="L214">        writeExecutor.flushBufferPool(bufferPool, stores);</span>
<span class="fc" id="L215">        writeExecutor.fsyncWritersBlockingly(stores);</span>
<span class="fc" id="L216">    }</span>

    public synchronized void startDispatch()
    {
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">        if (isShutDown)</span>
<span class="nc" id="L221">            throw new IllegalStateException(&quot;HintsService is shut down and cannot be restarted&quot;);</span>

<span class="fc" id="L223">        isDispatchPaused.set(false);</span>

<span class="fc" id="L225">        HintsServiceDiagnostics.dispatchingStarted(this);</span>

<span class="fc" id="L227">        HintsDispatchTrigger trigger = new HintsDispatchTrigger(catalog, writeExecutor, dispatchExecutor, isDispatchPaused);</span>
        // triggering hint dispatch is now very cheap, so we can do it more often - every 10 seconds vs. every 10 minutes,
        // previously; this reduces mean time to delivery, and positively affects batchlog delivery latencies, too
<span class="fc" id="L230">        triggerDispatchFuture = ScheduledExecutors.scheduledTasks.scheduleWithFixedDelay(trigger, 10, 10, TimeUnit.SECONDS);</span>
<span class="fc" id="L231">    }</span>

    public void pauseDispatch()
    {
<span class="fc" id="L235">        logger.info(&quot;Paused hints dispatch&quot;);</span>
<span class="fc" id="L236">        isDispatchPaused.set(true);</span>

<span class="fc" id="L238">        HintsServiceDiagnostics.dispatchingPaused(this);</span>
<span class="fc" id="L239">    }</span>

    public void resumeDispatch()
    {
<span class="fc" id="L243">        logger.info(&quot;Resumed hints dispatch&quot;);</span>
<span class="fc" id="L244">        isDispatchPaused.set(false);</span>

<span class="fc" id="L246">        HintsServiceDiagnostics.dispatchingResumed(this);</span>
<span class="fc" id="L247">    }</span>

    /**
     * Get the total size in bytes of all the hints files associating with the host on disk.
     * @param hostId, belonging host
     * @return total file size, in bytes
     */
    public long getTotalHintsSize(UUID hostId)
    {
<span class="fc" id="L256">        HintsStore store = catalog.getNullable(hostId);</span>
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">        if (store == null)</span>
<span class="nc" id="L258">            return 0;</span>
<span class="fc" id="L259">        return store.getTotalFileSize();</span>
    }

    /**
     * Gracefully and blockingly shut down the service.
     *
     * Will abort dispatch sessions that are currently in progress (which is okay, it's idempotent),
     * and make sure the buffers are flushed, hints files written and fsynced.
     */
    public synchronized void shutdownBlocking() throws ExecutionException, InterruptedException
    {
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">        if (isShutDown)</span>
<span class="nc" id="L271">            throw new IllegalStateException(&quot;HintsService has already been shut down&quot;);</span>
<span class="fc" id="L272">        isShutDown = true;</span>

<span class="pc bpc" id="L274" title="1 of 2 branches missed.">        if (triggerDispatchFuture != null)</span>
<span class="fc" id="L275">            triggerDispatchFuture.cancel(false);</span>
<span class="fc" id="L276">        pauseDispatch();</span>

<span class="fc" id="L278">        triggerFlushingFuture.cancel(false);</span>

<span class="fc" id="L280">        triggerCleanupFuture.cancel(false);</span>

<span class="fc" id="L282">        writeExecutor.flushBufferPool(bufferPool).get();</span>
<span class="fc" id="L283">        writeExecutor.closeAllWriters().get();</span>

<span class="fc" id="L285">        dispatchExecutor.shutdownBlocking();</span>
<span class="fc" id="L286">        writeExecutor.shutdownBlocking();</span>

<span class="fc" id="L288">        HintsServiceDiagnostics.dispatchingShutdown(this);</span>
<span class="fc" id="L289">        bufferPool.close();</span>
<span class="fc" id="L290">    }</span>

    /**
     * Returns all pending hints that this node has.
     *
     * @return a list of {@link PendingHintsInfo}
     */
    public List&lt;PendingHintsInfo&gt; getPendingHintsInfo()
    {
<span class="nc" id="L299">        return catalog.stores()</span>
<span class="nc" id="L300">                      .filter(HintsStore::hasFiles)</span>
<span class="nc" id="L301">                      .map(HintsStore::getPendingHintsInfo)</span>
<span class="nc" id="L302">                      .collect(Collectors.toList());</span>
    }

    /**
     * Returns all pending hints that this node has.
     *
     * @return a list of maps with endpoints' ids, total number of hint files, their oldest and newest timestamps.
     */
    public List&lt;Map&lt;String, String&gt;&gt; getPendingHints()
    {
<span class="nc" id="L312">        return getPendingHintsInfo().stream()</span>
<span class="nc" id="L313">                                    .map(PendingHintsInfo::asMap)</span>
<span class="nc" id="L314">                                    .collect(Collectors.toList());</span>
    }

    /**
     * Deletes all hints for all destinations. Doesn't make snapshots - should be used with care.
     */
    public void deleteAllHints()
    {
<span class="nc" id="L322">        catalog.deleteAllHints();</span>
<span class="nc" id="L323">    }</span>

    /**
     * Deletes all hints for the provided destination. Doesn't make snapshots - should be used with care.
     *
     * @param address inet address of the target node - encoded as a string for easier JMX consumption
     */
    public void deleteAllHintsForEndpoint(String address)
    {
        InetAddressAndPort target;
        try
        {
<span class="nc" id="L335">            target = InetAddressAndPort.getByName(address);</span>
        }
<span class="nc" id="L337">        catch (UnknownHostException e)</span>
        {
<span class="nc" id="L339">            throw new IllegalArgumentException(e);</span>
<span class="nc" id="L340">        }</span>
<span class="nc" id="L341">        deleteAllHintsForEndpoint(target);</span>
<span class="nc" id="L342">    }</span>

    /**
     * Deletes all hints for the provided destination. Doesn't make snapshots - should be used with care.
     *
     * @param target inet address of the target node
     */
    public void deleteAllHintsForEndpoint(InetAddressAndPort target)
    {
<span class="nc" id="L351">        UUID hostId = StorageService.instance.getHostIdForEndpoint(target);</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">        if (hostId == null)</span>
<span class="nc" id="L353">            throw new IllegalArgumentException(&quot;Can't delete hints for unknown address &quot; + target);</span>
<span class="nc" id="L354">        catalog.deleteAllHints(hostId);</span>
<span class="nc" id="L355">    }</span>

    /**
     * Cleans up hints-related state after a node with id = hostId left.
     *
     * Dispatcher can not stop itself (isHostAlive() can not start returning false for the leaving host because this
     * method is called by the same thread as gossip, which blocks gossip), so we can't simply wait for
     * completion.
     *
     * We should also flush the buffer if there are any hints for the node there, and close the writer (if any),
     * so that we don't leave any hint files lying around.
     *
     * Once that is done, we can simply delete all hint files and remove the host id from the catalog.
     *
     * The worst that can happen if we don't get everything right is a hints file (or two) remaining undeleted.
     *
     * @param hostId id of the node being excised
     */
    public void excise(UUID hostId)
    {
<span class="fc" id="L375">        HintsStore store = catalog.getNullable(hostId);</span>
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">        if (store == null)</span>
<span class="fc" id="L377">            return;</span>

        // flush the buffer and then close the writer for the excised host id, to make sure that no new files will appear
        // for this host id after we are done
<span class="nc" id="L381">        Future flushFuture = writeExecutor.flushBufferPool(bufferPool, Collections.singleton(store));</span>
<span class="nc" id="L382">        Future closeFuture = writeExecutor.closeWriter(store);</span>
        try
        {
<span class="nc" id="L385">            flushFuture.get();</span>
<span class="nc" id="L386">            closeFuture.get();</span>
        }
<span class="nc" id="L388">        catch (InterruptedException e)</span>
        {
<span class="nc" id="L390">            throw new UncheckedInterruptedException(e);</span>
        }
<span class="nc" id="L392">        catch (ExecutionException e)</span>
        {
<span class="nc" id="L394">            throw new RuntimeException(e);</span>
<span class="nc" id="L395">        }</span>

        // interrupt the current dispatch session to end (if any), so that the currently dispatched file gets removed
<span class="nc" id="L398">        dispatchExecutor.interruptDispatch(store.hostId);</span>

        // delete all the hints files and remove the HintsStore instance from the map in the catalog
<span class="nc" id="L401">        catalog.exciseStore(hostId);</span>
<span class="nc" id="L402">    }</span>

    /**
     * Transfer all local hints to the hostId supplied by hostIdSupplier
     *
     * Flushes the buffer to make sure all hints are on disk and closes the hint writers
     * so we don't leave any hint files around.
     *
     * After that, we serially dispatch all the hints in the HintsCatalog.
     *
     * If we fail delivering all hints, we will ask the hostIdSupplier for a new target host
     * and retry delivering any remaining hints there, once, with a delay of 10 seconds before retrying.
     *
     * @param hostIdSupplier supplier of stream target host ids. This is generally
     *                       the closest one according to the DynamicSnitch
     * @return When this future is done, it either has streamed all hints to remote nodes or has failed with a proper
     *         log message
     */
    public Future transferHints(Supplier&lt;UUID&gt; hostIdSupplier)
    {
<span class="fc" id="L422">        Future flushFuture = writeExecutor.flushBufferPool(bufferPool);</span>
<span class="fc" id="L423">        Future closeFuture = writeExecutor.closeAllWriters();</span>
        try
        {
<span class="fc" id="L426">            flushFuture.get();</span>
<span class="fc" id="L427">            closeFuture.get();</span>
        }
<span class="nc" id="L429">        catch (InterruptedException e)</span>
        {
<span class="nc" id="L431">            throw new UncheckedInterruptedException(e);</span>
        }
<span class="nc" id="L433">        catch (ExecutionException e)</span>
        {
<span class="nc" id="L435">            throw new RuntimeException(e);</span>
<span class="fc" id="L436">        }</span>

        // unpause dispatch, or else transfer() will return immediately
<span class="fc" id="L439">        resumeDispatch();</span>

        // wait for the current dispatch session to end
<span class="fc" id="L442">        catalog.stores().forEach(dispatchExecutor::completeDispatchBlockingly);</span>

<span class="fc" id="L444">        return dispatchExecutor.transfer(catalog, hostIdSupplier);</span>
    }

    /**
     * Get the earliest hint written for a particular node,
     * @param hostId UUID of the node to check it's hints.
     * @return earliest hint as per unix time or Long.MIN_VALUE if hostID is null
     */
    public long getEarliestHintForHost(UUID hostId)
    {
        // Need to check only the first descriptor + all buffers.
<span class="fc" id="L455">        HintsStore store = catalog.get(hostId);</span>
<span class="fc" id="L456">        HintsDescriptor desc = store.getFirstDescriptor();</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">        long timestamp = desc == null ? Clock.Global.currentTimeMillis() : desc.timestamp;</span>
<span class="fc" id="L458">        return Math.min(timestamp, bufferPool.getEarliestHintForHost(hostId));</span>
    }

    HintsCatalog getCatalog()
    {
<span class="nc" id="L463">        return catalog;</span>
    }

    /**
     * Returns true in case service is shut down.
     */
    public boolean isShutDown()
    {
<span class="nc" id="L471">        return isShutDown;</span>
    }
    
    @VisibleForTesting
    public boolean isDispatchPaused()
    {
<span class="nc" id="L477">        return isDispatchPaused.get();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>