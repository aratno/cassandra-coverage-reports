<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Columns.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db</a> &gt; <span class="el_source">Columns.java</span></div><h1>Columns.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.*;
import java.util.function.Consumer;
import java.util.function.Predicate;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterators;

import net.nicoulaj.compilecommand.annotations.DontInline;
import org.apache.cassandra.cql3.ColumnIdentifier;
import org.apache.cassandra.db.marshal.SetType;
import org.apache.cassandra.db.marshal.UTF8Type;
import org.apache.cassandra.db.rows.ColumnData;
import org.apache.cassandra.db.rows.Row;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.ObjectSizes;
import org.apache.cassandra.utils.SearchIterator;
import org.apache.cassandra.utils.btree.BTree;
import org.apache.cassandra.utils.btree.BTreeRemoval;
import org.apache.cassandra.utils.btree.BTreeSearchIterator;

/**
 * An immutable and sorted list of (non-PK) columns for a given table.
 * &lt;p&gt;
 * Note that in practice, it will either store only static columns, or only regular ones. When
 * we need both type of columns, we use a {@link RegularAndStaticColumns} object.
 */
public class Columns extends AbstractCollection&lt;ColumnMetadata&gt; implements Collection&lt;ColumnMetadata&gt;
{
<span class="fc" id="L54">    public static final Serializer serializer = new Serializer();</span>
<span class="fc" id="L55">    public static final Columns NONE = new Columns(BTree.empty(), 0);</span>
<span class="fc" id="L56">    static final long EMPTY_SIZE = ObjectSizes.measure(NONE);</span>

<span class="fc" id="L58">    public static final ColumnMetadata FIRST_COMPLEX_STATIC =</span>
        new ColumnMetadata(&quot;&quot;,
                           &quot;&quot;,
<span class="fc" id="L61">                           ColumnIdentifier.getInterned(ByteBufferUtil.EMPTY_BYTE_BUFFER, UTF8Type.instance),</span>
<span class="fc" id="L62">                           SetType.getInstance(UTF8Type.instance, true),</span>
                           ColumnMetadata.NO_POSITION,
                           ColumnMetadata.Kind.STATIC,
                           null);

<span class="fc" id="L67">    public static final ColumnMetadata FIRST_COMPLEX_REGULAR =</span>
        new ColumnMetadata(&quot;&quot;,
                           &quot;&quot;,
<span class="fc" id="L70">                           ColumnIdentifier.getInterned(ByteBufferUtil.EMPTY_BYTE_BUFFER, UTF8Type.instance),</span>
<span class="fc" id="L71">                           SetType.getInstance(UTF8Type.instance, true),</span>
                           ColumnMetadata.NO_POSITION,
                           ColumnMetadata.Kind.REGULAR,
                           null);

    private final Object[] columns;
    private final int complexIdx; // Index of the first complex column

    private Columns(Object[] columns, int complexIdx)
<span class="fc" id="L80">    {</span>
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">        assert complexIdx &lt;= BTree.size(columns);</span>
<span class="fc" id="L82">        this.columns = columns;</span>
<span class="fc" id="L83">        this.complexIdx = complexIdx;</span>
<span class="fc" id="L84">    }</span>

    private Columns(Object[] columns)
    {
<span class="fc" id="L88">        this(columns, findFirstComplexIdx(columns));</span>
<span class="fc" id="L89">    }</span>

    /**
     * Creates a {@code Columns} holding only the one column provided.
     *
     * @param c the column for which to create a {@code Columns} object.
     *
     * @return the newly created {@code Columns} containing only {@code c}.
     */
    public static Columns of(ColumnMetadata c)
    {
<span class="nc bnc" id="L100" title="All 2 branches missed.">        return new Columns(BTree.singleton(c), c.isComplex() ? 0 : 1);</span>
    }

   /**
    * Returns a new {@code Columns} object holing the same columns as the provided Row.
    *
    * @param row the row from which to create the new {@code Columns}.
    * @return the newly created {@code Columns} containing the columns from {@code row}.
    */
   public static Columns from(Row row)
   {
<span class="fc" id="L111">       try (BTree.FastBuilder&lt;ColumnMetadata&gt; builder = BTree.fastBuilder())</span>
       {
<span class="fc bfc" id="L113" title="All 2 branches covered.">           for (ColumnData cd : row)</span>
<span class="fc" id="L114">               builder.add(cd.column());</span>
<span class="fc" id="L115">           Object[] tree = builder.build();</span>
<span class="fc" id="L116">           return new Columns(tree, findFirstComplexIdx(tree));</span>
       }
   }

   public static Columns from(BTree.Builder&lt;ColumnMetadata&gt; builder)
   {
<span class="fc" id="L122">       Object[] tree = builder.build();</span>
<span class="fc" id="L123">       return new Columns(tree, findFirstComplexIdx(tree));</span>
   }

    /**
    * Returns a new {@code Columns} object holding the same columns than the provided set.
     * This method assumes nothing about the order of {@code s}.
     *
     * @param s the set from which to create the new {@code Columns}.
     * @return the newly created {@code Columns} containing the columns from {@code s}.
     */
    public static Columns from(Collection&lt;ColumnMetadata&gt; s)
    {
<span class="nc" id="L135">        Object[] tree = BTree.&lt;ColumnMetadata&gt;builder(Comparator.naturalOrder()).addAll(s).build();</span>
<span class="nc" id="L136">        return new Columns(tree, findFirstComplexIdx(tree));</span>
    }

    private static int findFirstComplexIdx(Object[] tree)
    {
<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (BTree.isEmpty(tree))</span>
<span class="fc" id="L142">            return 0;</span>

<span class="fc" id="L144">        int size = BTree.size(tree);</span>
<span class="fc" id="L145">        ColumnMetadata last = BTree.findByIndex(tree, size - 1);</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">        return last.isSimple()</span>
<span class="fc" id="L147">             ? size</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">             : BTree.ceilIndex(tree, Comparator.naturalOrder(), last.isStatic() ? FIRST_COMPLEX_STATIC : FIRST_COMPLEX_REGULAR);</span>
    }

    /**
     * Whether this columns is empty.
     *
     * @return whether this columns is empty.
     */
    public boolean isEmpty()
    {
<span class="fc" id="L158">        return BTree.isEmpty(columns);</span>
    }

    /**
     * The number of simple columns in this object.
     *
     * @return the number of simple columns in this object.
     */
    public int simpleColumnCount()
    {
<span class="nc" id="L168">        return complexIdx;</span>
    }

    /**
     * The number of complex columns (non-frozen collections, udts, ...) in this object.
     *
     * @return the number of complex columns in this object.
     */
    public int complexColumnCount()
    {
<span class="nc" id="L178">        return BTree.size(columns) - complexIdx;</span>
    }

    /**
     * The total number of columns in this object.
     *
     * @return the total number of columns in this object.
     */
    public int size()
    {
<span class="fc" id="L188">        return BTree.size(columns);</span>
    }

    /**
     * Whether this objects contains simple columns.
     *
     * @return whether this objects contains simple columns.
     */
    public boolean hasSimple()
    {
<span class="nc bnc" id="L198" title="All 2 branches missed.">        return complexIdx &gt; 0;</span>
    }

    /**
     * Whether this objects contains complex columns.
     *
     * @return whether this objects contains complex columns.
     */
    public boolean hasComplex()
    {
<span class="fc bfc" id="L208" title="All 2 branches covered.">        return complexIdx &lt; BTree.size(columns);</span>
    }

    /**
     * Returns the ith simple column of this object.
     *
     * @param i the index for the simple column to fectch. This must
     * satisfy {@code 0 &lt;= i &lt; simpleColumnCount()}.
     *
     * @return the {@code i}th simple column in this object.
     */
    public ColumnMetadata getSimple(int i)
    {
<span class="nc" id="L221">        return BTree.findByIndex(columns, i);</span>
    }

    /**
     * Returns the ith complex column of this object.
     *
     * @param i the index for the complex column to fectch. This must
     * satisfy {@code 0 &lt;= i &lt; complexColumnCount()}.
     *
     * @return the {@code i}th complex column in this object.
     */
    public ColumnMetadata getComplex(int i)
    {
<span class="nc" id="L234">        return BTree.findByIndex(columns, complexIdx + i);</span>
    }

    /**
     * The index of the provided simple column in this object (if it contains
     * the provided column).
     *
     * @param c the simple column for which to return the index of.
     *
     * @return the index for simple column {@code c} if it is contains in this
     * object
     */
    public int simpleIdx(ColumnMetadata c)
    {
<span class="nc" id="L248">        return BTree.findIndex(columns, Comparator.naturalOrder(), c);</span>
    }

    /**
     * The index of the provided complex column in this object (if it contains
     * the provided column).
     *
     * @param c the complex column for which to return the index of.
     *
     * @return the index for complex column {@code c} if it is contains in this
     * object
     */
    public int complexIdx(ColumnMetadata c)
    {
<span class="nc" id="L262">        return BTree.findIndex(columns, Comparator.naturalOrder(), c) - complexIdx;</span>
    }

    /**
     * Whether the provided column is contained by this object.
     *
     * @param c the column to check presence of.
     *
     * @return whether {@code c} is contained by this object.
     */
    public boolean contains(ColumnMetadata c)
    {
<span class="fc bfc" id="L274" title="All 2 branches covered.">        return BTree.findIndex(columns, Comparator.naturalOrder(), c) &gt;= 0;</span>
    }

    /**
     * Returns the result of merging this {@code Columns} object with the
     * provided one.
     *
     * @param other the other {@code Columns} to merge this object with.
     *
     * @return the result of merging/taking the union of {@code this} and
     * {@code other}. The returned object may be one of the operand and that
     * operand is a subset of the other operand.
     */
    public Columns mergeTo(Columns other)
    {
<span class="fc bfc" id="L289" title="All 4 branches covered.">        if (this == other || other == NONE)</span>
<span class="fc" id="L290">            return this;</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">        if (this == NONE)</span>
<span class="fc" id="L292">            return other;</span>

<span class="fc" id="L294">        Object[] tree = BTree.update(this.columns, other.columns, Comparator.naturalOrder());</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">        if (tree == this.columns)</span>
<span class="fc" id="L296">            return this;</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">        if (tree == other.columns)</span>
<span class="fc" id="L298">            return other;</span>

<span class="fc" id="L300">        return new Columns(tree, findFirstComplexIdx(tree));</span>
    }

    /**
     * Whether this object is a superset of the provided other {@code Columns object}.
     *
     * @param other the other object to test for inclusion in this object.
     *
     * @return whether all the columns of {@code other} are contained by this object.
     */
    public boolean containsAll(Collection&lt;?&gt; other)
    {
<span class="fc bfc" id="L312" title="All 2 branches covered.">        if (other == this)</span>
<span class="fc" id="L313">            return true;</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">        if (other.size() &gt; this.size())</span>
<span class="nc" id="L315">            return false;</span>

<span class="fc" id="L317">        BTreeSearchIterator&lt;ColumnMetadata, ColumnMetadata&gt; iter = BTree.slice(columns, Comparator.naturalOrder(), BTree.Dir.ASC);</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">        for (Object def : other)</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">            if (iter.next((ColumnMetadata) def) == null)</span>
<span class="nc" id="L320">                return false;</span>
<span class="fc" id="L321">        return true;</span>
    }

    /**
     * Iterator over the simple columns of this object.
     *
     * @return an iterator over the simple columns of this object.
     */
    public Iterator&lt;ColumnMetadata&gt; simpleColumns()
    {
<span class="fc" id="L331">        return BTree.iterator(columns, 0, complexIdx - 1, BTree.Dir.ASC);</span>
    }

    /**
     * Iterator over the complex columns of this object.
     *
     * @return an iterator over the complex columns of this object.
     */
    public Iterator&lt;ColumnMetadata&gt; complexColumns()
    {
<span class="fc" id="L341">        return BTree.iterator(columns, complexIdx, BTree.size(columns) - 1, BTree.Dir.ASC);</span>
    }

    /**
     * Iterator over all the columns of this object.
     *
     * @return an iterator over all the columns of this object.
     */
    public BTreeSearchIterator&lt;ColumnMetadata, ColumnMetadata&gt; iterator()
    {
<span class="fc" id="L351">        return BTree.&lt;ColumnMetadata, ColumnMetadata&gt;slice(columns, Comparator.naturalOrder(), BTree.Dir.ASC);</span>
    }

    /**
     * An iterator that returns the columns of this object in &quot;select&quot; order (that
     * is in global alphabetical order, where the &quot;normal&quot; iterator returns simple
     * columns first and the complex second).
     *
     * @return an iterator returning columns in alphabetical order.
     */
    public Iterator&lt;ColumnMetadata&gt; selectOrderIterator()
    {
        // In wildcard selection, we want to return all columns in alphabetical order,
        // irregarding of whether they are complex or not
<span class="fc" id="L365">        return Iterators.&lt;ColumnMetadata&gt;</span>
<span class="fc" id="L366">                         mergeSorted(ImmutableList.of(simpleColumns(), complexColumns()),</span>
                                     (s, c) -&gt;
                                     {
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">                                         assert !s.kind.isPrimaryKeyKind();</span>
<span class="fc" id="L370">                                         return s.name.bytes.compareTo(c.name.bytes);</span>
                                     });
    }

    /**
     * Returns the equivalent of those columns but with the provided column removed.
     *
     * @param column the column to remove.
     *
     * @return newly allocated columns containing all the columns of {@code this} expect
     * for {@code column}.
     */
    public Columns without(ColumnMetadata column)
    {
<span class="nc bnc" id="L384" title="All 2 branches missed.">        if (!contains(column))</span>
<span class="nc" id="L385">            return this;</span>

<span class="nc" id="L387">        Object[] newColumns = BTreeRemoval.&lt;ColumnMetadata&gt;remove(columns, Comparator.naturalOrder(), column);</span>
<span class="nc" id="L388">        return new Columns(newColumns);</span>
    }

    /**
     * Returns a predicate to test whether columns are included in this {@code Columns} object,
     * assuming that tes tested columns are passed to the predicate in sorted order.
     *
     * @return a predicate to test the inclusion of sorted columns in this object.
     */
    public Predicate&lt;ColumnMetadata&gt; inOrderInclusionTester()
    {
<span class="fc" id="L399">        SearchIterator&lt;ColumnMetadata, ColumnMetadata&gt; iter = BTree.slice(columns, Comparator.naturalOrder(), BTree.Dir.ASC);</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">        return column -&gt; iter.next(column) != null;</span>
    }

    public void digest(Digest digest)
    {
<span class="fc bfc" id="L405" title="All 2 branches covered.">        for (ColumnMetadata c : this)</span>
<span class="fc" id="L406">            digest.update(c.name.bytes);</span>
<span class="fc" id="L407">    }</span>

    /**
     * Apply a function to each column definition in forwards or reversed order.
     * @param function
     */
    public void apply(Consumer&lt;ColumnMetadata&gt; function)
    {
<span class="fc" id="L415">        BTree.apply(columns, function);</span>
<span class="fc" id="L416">    }</span>

    @Override
    public boolean equals(Object other)
    {
<span class="fc bfc" id="L421" title="All 2 branches covered.">        if (other == this)</span>
<span class="fc" id="L422">            return true;</span>
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">        if (!(other instanceof Columns))</span>
<span class="nc" id="L424">            return false;</span>

<span class="fc" id="L426">        Columns that = (Columns)other;</span>
<span class="fc bfc" id="L427" title="All 4 branches covered.">        return this.complexIdx == that.complexIdx &amp;&amp; BTree.equals(this.columns, that.columns);</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L433">        return Objects.hash(complexIdx, BTree.hashCode(columns));</span>
    }

    public long unsharedHeapSize()
    {
<span class="fc bfc" id="L438" title="All 2 branches covered.">        if(this == NONE)</span>
<span class="fc" id="L439">            return 0;</span>

<span class="fc" id="L441">        return EMPTY_SIZE + BTree.sizeOfStructureOnHeap(columns);</span>
    }

    @Override
    public String toString()
    {
<span class="fc" id="L447">        StringBuilder sb = new StringBuilder(&quot;[&quot;);</span>
<span class="fc" id="L448">        boolean first = true;</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">        for (ColumnMetadata def : this)</span>
        {
<span class="fc bfc" id="L451" title="All 2 branches covered.">            if (first) first = false; else sb.append(&quot; &quot;);</span>
<span class="fc" id="L452">            sb.append(def.name);</span>
<span class="fc" id="L453">        }</span>
<span class="fc" id="L454">        return sb.append(&quot;]&quot;).toString();</span>
    }

<span class="fc" id="L457">    public static class Serializer</span>
    {
        public void serialize(Columns columns, DataOutputPlus out) throws IOException
        {
<span class="fc" id="L461">            out.writeUnsignedVInt32(columns.size());</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">            for (ColumnMetadata column : columns)</span>
<span class="fc" id="L463">                ByteBufferUtil.writeWithVIntLength(column.name.bytes, out);</span>
<span class="fc" id="L464">        }</span>

        public long serializedSize(Columns columns)
        {
<span class="fc" id="L468">            long size = TypeSizes.sizeofUnsignedVInt(columns.size());</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">            for (ColumnMetadata column : columns)</span>
<span class="fc" id="L470">                size += ByteBufferUtil.serializedSizeWithVIntLength(column.name.bytes);</span>
<span class="fc" id="L471">            return size;</span>
        }

        public Columns deserialize(DataInputPlus in, TableMetadata metadata) throws IOException
        {
<span class="fc" id="L476">            int length = in.readUnsignedVInt32();</span>
<span class="fc" id="L477">            try (BTree.FastBuilder&lt;ColumnMetadata&gt; builder = BTree.fastBuilder())</span>
            {
<span class="fc bfc" id="L479" title="All 2 branches covered.">                for (int i = 0; i &lt; length; i++)</span>
                {
<span class="fc" id="L481">                    ByteBuffer name = ByteBufferUtil.readWithVIntLength(in);</span>
<span class="fc" id="L482">                    ColumnMetadata column = metadata.getColumn(name);</span>
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">                    if (column == null)</span>
                    {
                        // If we don't find the definition, it could be we have data for a dropped column, and we shouldn't
                        // fail deserialization because of that. So we grab a &quot;fake&quot; ColumnMetadata that ensure proper
                        // deserialization. The column will be ignore later on anyway.
<span class="nc" id="L488">                        column = metadata.getDroppedColumn(name);</span>

<span class="nc bnc" id="L490" title="All 2 branches missed.">                        if (column == null)</span>
<span class="nc" id="L491">                            throw new RuntimeException(&quot;Unknown column &quot; + UTF8Type.instance.getString(name) + &quot; during deserialization&quot;);</span>
                    }
<span class="fc" id="L493">                    builder.add(column);</span>
                }
<span class="fc" id="L495">                return new Columns(builder.build());</span>
            }
        }

        /**
         * If both ends have a pre-shared superset of the columns we are serializing, we can send them much
         * more efficiently. Both ends must provide the identically same set of columns.
         */
        public void serializeSubset(Collection&lt;ColumnMetadata&gt; columns, Columns superset, DataOutputPlus out) throws IOException
        {
            /**
             * We weight this towards small sets, and sets where the majority of items are present, since
             * we expect this to mostly be used for serializing result sets.
             *
             * For supersets with fewer than 64 columns, we encode a bitmap of *missing* columns,
             * which equates to a zero (single byte) when all columns are present, and otherwise
             * a positive integer that can typically be vint encoded efficiently.
             *
             * If we have 64 or more columns, we cannot neatly perform a bitmap encoding, so we just switch
             * to a vint encoded set of deltas, either adding or subtracting (whichever is most efficient).
             * We indicate this switch by sending our bitmap with every bit set, i.e. -1L
             */
<span class="fc" id="L517">            int columnCount = columns.size();</span>
<span class="fc" id="L518">            int supersetCount = superset.size();</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">            if (columnCount == supersetCount)</span>
            {
<span class="fc" id="L521">                out.writeUnsignedVInt32(0);</span>
            }
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">            else if (supersetCount &lt; 64)</span>
            {
<span class="fc" id="L525">                out.writeUnsignedVInt(encodeBitmap(columns, superset, supersetCount));</span>
            }
            else
            {
<span class="nc" id="L529">                serializeLargeSubset(columns, columnCount, superset, supersetCount, out);</span>
            }
<span class="fc" id="L531">        }</span>

        public long serializedSubsetSize(Collection&lt;ColumnMetadata&gt; columns, Columns superset)
        {
<span class="fc" id="L535">            int columnCount = columns.size();</span>
<span class="fc" id="L536">            int supersetCount = superset.size();</span>
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">            if (columnCount == supersetCount)</span>
            {
<span class="nc" id="L539">                return TypeSizes.sizeofUnsignedVInt(0);</span>
            }
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">            else if (supersetCount &lt; 64)</span>
            {
<span class="fc" id="L543">                return TypeSizes.sizeofUnsignedVInt(encodeBitmap(columns, superset, supersetCount));</span>
            }
            else
            {
<span class="nc" id="L547">                return serializeLargeSubsetSize(columns, columnCount, superset, supersetCount);</span>
            }
        }

        public Columns deserializeSubset(Columns superset, DataInputPlus in) throws IOException
        {
<span class="fc" id="L553">            long encoded = in.readUnsignedVInt();</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">            if (encoded == 0L)</span>
            {
<span class="fc" id="L556">                return superset;</span>
            }
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">            else if (superset.size() &gt;= 64)</span>
            {
<span class="nc" id="L560">                return deserializeLargeSubset(in, superset, (int) encoded);</span>
            }
            else
            {
<span class="fc" id="L564">                try (BTree.FastBuilder&lt;ColumnMetadata&gt; builder = BTree.fastBuilder())</span>
                {
<span class="fc" id="L566">                    int firstComplexIdx = 0;</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">                    for (ColumnMetadata column : superset)</span>
                    {
<span class="fc bfc" id="L569" title="All 2 branches covered.">                        if ((encoded &amp; 1) == 0)</span>
                        {
<span class="fc" id="L571">                            builder.add(column);</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">                            if (column.isSimple())</span>
<span class="fc" id="L573">                                ++firstComplexIdx;</span>
                        }
<span class="fc" id="L575">                        encoded &gt;&gt;&gt;= 1;</span>
<span class="fc" id="L576">                    }</span>
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">                    if (encoded != 0)</span>
<span class="nc" id="L578">                        throw new IOException(&quot;Invalid Columns subset bytes; too many bits set:&quot; + Long.toBinaryString(encoded));</span>
<span class="fc" id="L579">                    return new Columns(builder.build(), firstComplexIdx);</span>
                }
            }
        }

        // encodes a 1 bit for every *missing* column, on the assumption presence is more common,
        // and because this is consistent with encoding 0 to represent all present
        private static long encodeBitmap(Collection&lt;ColumnMetadata&gt; columns, Columns superset, int supersetCount)
        {
<span class="fc" id="L588">            long bitmap = 0L;</span>
<span class="fc" id="L589">            BTreeSearchIterator&lt;ColumnMetadata, ColumnMetadata&gt; iter = superset.iterator();</span>
            // the index we would encounter next if all columns are present
<span class="fc" id="L591">            int expectIndex = 0;</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">            for (ColumnMetadata column : columns)</span>
            {
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">                if (iter.next(column) == null)</span>
<span class="nc" id="L595">                    throw new IllegalStateException(columns + &quot; is not a subset of &quot; + superset);</span>

<span class="fc" id="L597">                int currentIndex = iter.indexOfCurrent();</span>
<span class="fc" id="L598">                int count = currentIndex - expectIndex;</span>
                // (1L &lt;&lt; count) - 1 gives us count bits set at the bottom of the register
                // so &lt;&lt; expectIndex moves these bits to start at expectIndex, which is where our missing portion
                // begins (assuming count &gt; 0; if not, we're adding 0 bits, so it's a no-op)
<span class="fc" id="L602">                bitmap |= ((1L &lt;&lt; count) - 1) &lt;&lt; expectIndex;</span>
<span class="fc" id="L603">                expectIndex = currentIndex + 1;</span>
<span class="fc" id="L604">            }</span>
<span class="fc" id="L605">            int count = supersetCount - expectIndex;</span>
<span class="fc" id="L606">            bitmap |= ((1L &lt;&lt; count) - 1) &lt;&lt; expectIndex;</span>
<span class="fc" id="L607">            return bitmap;</span>
        }

        @DontInline
        private void serializeLargeSubset(Collection&lt;ColumnMetadata&gt; columns, int columnCount, Columns superset, int supersetCount, DataOutputPlus out) throws IOException
        {
            // write flag indicating we're in lengthy mode
<span class="nc" id="L614">            out.writeUnsignedVInt32(supersetCount - columnCount);</span>
<span class="nc" id="L615">            BTreeSearchIterator&lt;ColumnMetadata, ColumnMetadata&gt; iter = superset.iterator();</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">            if (columnCount &lt; supersetCount / 2)</span>
            {
                // write present columns
<span class="nc bnc" id="L619" title="All 2 branches missed.">                for (ColumnMetadata column : columns)</span>
                {
<span class="nc bnc" id="L621" title="All 2 branches missed.">                    if (iter.next(column) == null)</span>
<span class="nc" id="L622">                        throw new IllegalStateException();</span>
<span class="nc" id="L623">                    out.writeUnsignedVInt32(iter.indexOfCurrent());</span>
<span class="nc" id="L624">                }</span>
            }
            else
            {
                // write missing columns
<span class="nc" id="L629">                int prev = -1;</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">                for (ColumnMetadata column : columns)</span>
                {
<span class="nc bnc" id="L632" title="All 2 branches missed.">                    if (iter.next(column) == null)</span>
<span class="nc" id="L633">                        throw new IllegalStateException();</span>
<span class="nc" id="L634">                    int cur = iter.indexOfCurrent();</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">                    while (++prev != cur)</span>
<span class="nc" id="L636">                        out.writeUnsignedVInt32(prev);</span>
<span class="nc" id="L637">                }</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">                while (++prev != supersetCount)</span>
<span class="nc" id="L639">                    out.writeUnsignedVInt32(prev);</span>
            }
<span class="nc" id="L641">        }</span>

        @DontInline
        private Columns deserializeLargeSubset(DataInputPlus in, Columns superset, int delta) throws IOException
        {
<span class="nc" id="L646">            int supersetCount = superset.size();</span>
<span class="nc" id="L647">            int columnCount = supersetCount - delta;</span>

<span class="nc" id="L649">            try (BTree.FastBuilder&lt;ColumnMetadata&gt; builder = BTree.fastBuilder())</span>
            {
<span class="nc bnc" id="L651" title="All 2 branches missed.">                if (columnCount &lt; supersetCount / 2)</span>
                {
<span class="nc bnc" id="L653" title="All 2 branches missed.">                    for (int i = 0 ; i &lt; columnCount ; i++)</span>
                    {
<span class="nc" id="L655">                        int idx = in.readUnsignedVInt32();</span>
<span class="nc" id="L656">                        builder.add(BTree.findByIndex(superset.columns, idx));</span>
                    }
                }
                else
                {
<span class="nc" id="L661">                    Iterator&lt;ColumnMetadata&gt; iter = superset.iterator();</span>
<span class="nc" id="L662">                    int idx = 0;</span>
<span class="nc" id="L663">                    int skipped = 0;</span>
                    while (true)
                    {
<span class="nc bnc" id="L666" title="All 2 branches missed.">                        int nextMissingIndex = skipped &lt; delta ? in.readUnsignedVInt32() : supersetCount;</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">                        while (idx &lt; nextMissingIndex)</span>
                        {
<span class="nc" id="L669">                            ColumnMetadata def = iter.next();</span>
<span class="nc" id="L670">                            builder.add(def);</span>
<span class="nc" id="L671">                            idx++;</span>
<span class="nc" id="L672">                        }</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">                        if (idx == supersetCount)</span>
<span class="nc" id="L674">                            break;</span>
<span class="nc" id="L675">                        iter.next();</span>
<span class="nc" id="L676">                        idx++;</span>
<span class="nc" id="L677">                        skipped++;</span>
<span class="nc" id="L678">                    }</span>
                }
<span class="nc" id="L680">                return new Columns(builder.build());</span>
            }
        }

        @DontInline
        private int serializeLargeSubsetSize(Collection&lt;ColumnMetadata&gt; columns, int columnCount, Columns superset, int supersetCount)
        {
            // write flag indicating we're in lengthy mode
<span class="nc" id="L688">            int size = TypeSizes.sizeofUnsignedVInt(supersetCount - columnCount);</span>
<span class="nc" id="L689">            BTreeSearchIterator&lt;ColumnMetadata, ColumnMetadata&gt; iter = superset.iterator();</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">            if (columnCount &lt; supersetCount / 2)</span>
            {
                // write present columns
<span class="nc bnc" id="L693" title="All 2 branches missed.">                for (ColumnMetadata column : columns)</span>
                {
<span class="nc bnc" id="L695" title="All 2 branches missed.">                    if (iter.next(column) == null)</span>
<span class="nc" id="L696">                        throw new IllegalStateException();</span>
<span class="nc" id="L697">                    size += TypeSizes.sizeofUnsignedVInt(iter.indexOfCurrent());</span>
<span class="nc" id="L698">                }</span>
            }
            else
            {
                // write missing columns
<span class="nc" id="L703">                int prev = -1;</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">                for (ColumnMetadata column : columns)</span>
                {
<span class="nc bnc" id="L706" title="All 2 branches missed.">                    if (iter.next(column) == null)</span>
<span class="nc" id="L707">                        throw new IllegalStateException();</span>
<span class="nc" id="L708">                    int cur = iter.indexOfCurrent();</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">                    while (++prev != cur)</span>
<span class="nc" id="L710">                        size += TypeSizes.sizeofUnsignedVInt(prev);</span>
<span class="nc" id="L711">                }</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">                while (++prev != supersetCount)</span>
<span class="nc" id="L713">                    size += TypeSizes.sizeofUnsignedVInt(prev);</span>
            }
<span class="nc" id="L715">            return size;</span>
        }

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>