<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Slices.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db</a> &gt; <span class="el_source">Slices.java</span></div><h1>Slices.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.*;
import java.util.stream.Collectors;

import com.google.common.base.Preconditions;
import com.google.common.collect.Iterators;

import org.apache.cassandra.cql3.Operator;
import org.apache.cassandra.db.filter.RowFilter;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;

/**
 * Represents the selection of multiple range of rows within a partition.
 * &lt;p&gt;
 * A {@code Slices} is basically a list of {@code Slice}, though those are guaranteed to be non-overlapping
 * and always in clustering order.
 */
public abstract class Slices implements Iterable&lt;Slice&gt;
{
<span class="fc" id="L44">    public static final Serializer serializer = new Serializer();</span>

    /** Slices selecting all the rows of a partition. */
<span class="fc" id="L47">    public static final Slices ALL = new SelectAllSlices();</span>
    /** Slices selecting no rows in a partition. */
<span class="fc" id="L49">    public static final Slices NONE = new SelectNoSlices();</span>

    protected Slices()
<span class="fc" id="L52">    {</span>
<span class="fc" id="L53">    }</span>

    /**
     * Creates a {@code Slices} object that contains a single slice.
     *
     * @param comparator the comparator for the table {@code slice} is a slice of.
     * @param slice the single slice that the return object should contain.
     *
     * @return the newly created {@code Slices} object.
     */
    public static Slices with(ClusteringComparator comparator, Slice slice)
    {
<span class="fc bfc" id="L65" title="All 4 branches covered.">        if (slice.start().isBottom() &amp;&amp; slice.end().isTop())</span>
<span class="fc" id="L66">            return Slices.ALL;</span>

<span class="pc bpc" id="L68" title="1 of 2 branches missed.">        Preconditions.checkArgument(!slice.isEmpty(comparator));</span>
<span class="fc" id="L69">        return new ArrayBackedSlices(comparator, new Slice[]{ slice });</span>
    }

    /**
     * Whether the slices instance has a lower bound, that is whether it's first slice start is {@code Slice.BOTTOM}.
     *
     * @return whether this slices instance has a lower bound.
     */
    public abstract boolean hasLowerBound();

    /**
     * Whether the slices instance has an upper bound, that is whether it's last slice end is {@code Slice.TOP}.
     *
     * @return whether this slices instance has an upper bound.
     */
    public abstract boolean hasUpperBound();

    /**
     * The number of slice this object contains.
     *
     * @return the number of slice this object contains.
     */
    public abstract int size();

    /**
     * Returns the ith slice of this {@code Slices} object.
     *
     * @return the ith slice of this object.
     */
    public abstract Slice get(int i);

    public ClusteringBound&lt;?&gt; start()
    {
<span class="fc" id="L102">        return get(0).start();</span>
    }

    public ClusteringBound&lt;?&gt; end()
    {
<span class="fc" id="L107">        return get(size() - 1).end();</span>
    }

    /**
     * Returns slices for continuing the paging of those slices given the last returned clustering prefix.
     *
     * @param comparator the comparator for the table this is a filter for.
     * @param lastReturned the last clustering that was returned for the query we are paging for. The
     * resulting slices will be such that only results coming stricly after {@code lastReturned} are returned
     * (where coming after means &quot;greater than&quot; if {@code !reversed} and &quot;lesser than&quot; otherwise).
     * @param inclusive whether we want to include the {@code lastReturned} in the newly returned page of results.
     * @param reversed whether the query we're paging for is reversed or not.
     *
     * @return new slices that select results coming after {@code lastReturned}.
     */
    public abstract Slices forPaging(ClusteringComparator comparator, Clustering&lt;?&gt; lastReturned, boolean inclusive, boolean reversed);

    /**
     * An object that allows to test whether rows are selected by this {@code Slices} objects assuming those rows
     * are tested in clustering order.
     *
     * @param reversed if true, the rows passed to the returned object will be assumed to be in reversed clustering
     * order, otherwise they should be in clustering order.
     *
     * @return an object that tests for selection of rows by this {@code Slices} object.
     */
    public abstract InOrderTester inOrderTester(boolean reversed);

    /**
     * Whether a given clustering (row) is selected by this {@code Slices} object.
     *
     * @param clustering the clustering to test for selection.
     *
     * @return whether a given clustering (row) is selected by this {@code Slices} object.
     */
    public abstract boolean selects(Clustering&lt;?&gt; clustering);

    /**
     * Checks whether any of the slices intersects witht the given one.
     *
     * @return {@code true} if there exists a slice which ({@link Slice#intersects(ClusteringComparator, Slice)}) with
     * the provided slice
     */
    public abstract boolean intersects(Slice slice);

    public abstract String toCQLString(TableMetadata metadata, RowFilter rowFilter);

    /**
     * Checks if this &lt;code&gt;Slices&lt;/code&gt; is empty.
     * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Slices&lt;/code&gt; is empty, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public final boolean isEmpty()
    {
<span class="fc bfc" id="L160" title="All 2 branches covered.">        return size() == 0;</span>
    }

    /**
     * In simple object that allows to test the inclusion of rows in those slices assuming those rows
     * are passed (to {@link #includes}) in clustering order (or reverse clustering ordered, depending
     * on the argument passed to {@link #inOrderTester}).
     */
    public interface InOrderTester
    {
        boolean includes(Clustering&lt;?&gt; value);
        boolean isDone();
    }

    /**
     * Builder to create {@code Slices} objects.
     */
    public static class Builder
    {
        private final ClusteringComparator comparator;

        private final List&lt;Slice&gt; slices;

        private boolean needsNormalizing;

        public Builder(ClusteringComparator comparator)
<span class="fc" id="L186">        {</span>
<span class="fc" id="L187">            this.comparator = comparator;</span>
<span class="fc" id="L188">            this.slices = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L189">        }</span>

        public Builder(ClusteringComparator comparator, int initialSize)
<span class="fc" id="L192">        {</span>
<span class="fc" id="L193">            this.comparator = comparator;</span>
<span class="fc" id="L194">            this.slices = new ArrayList&lt;&gt;(initialSize);</span>
<span class="fc" id="L195">        }</span>

        public Builder add(ClusteringBound&lt;?&gt; start, ClusteringBound&lt;?&gt; end)
        {
<span class="fc" id="L199">            return add(Slice.make(start, end));</span>
        }

        public Builder add(Slice slice)
        {
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">            Preconditions.checkArgument(!slice.isEmpty(comparator));</span>
<span class="fc bfc" id="L205" title="All 4 branches covered.">            if (slices.size() &gt; 0 &amp;&amp; comparator.compare(slices.get(slices.size()-1).end(), slice.start()) &gt; 0)</span>
<span class="fc" id="L206">                needsNormalizing = true;</span>
<span class="fc" id="L207">            slices.add(slice);</span>
<span class="fc" id="L208">            return this;</span>
        }

        public Builder addAll(Slices slices)
        {
<span class="fc bfc" id="L213" title="All 2 branches covered.">            for (Slice slice : slices)</span>
<span class="fc" id="L214">                add(slice);</span>
<span class="fc" id="L215">            return this;</span>
        }

        public int size()
        {
<span class="nc" id="L220">            return slices.size();</span>
        }

        public Slices build()
        {
<span class="fc bfc" id="L225" title="All 2 branches covered.">            if (slices.isEmpty())</span>
<span class="fc" id="L226">                return NONE;</span>

<span class="fc bfc" id="L228" title="All 4 branches covered.">            if (slices.size() == 1 &amp;&amp; slices.get(0) == Slice.ALL)</span>
<span class="fc" id="L229">                return ALL;</span>

<span class="fc bfc" id="L231" title="All 2 branches covered.">            List&lt;Slice&gt; normalized = needsNormalizing</span>
<span class="fc" id="L232">                                   ? normalize(slices)</span>
<span class="fc" id="L233">                                   : slices;</span>

<span class="fc" id="L235">            return new ArrayBackedSlices(comparator, normalized.toArray(new Slice[normalized.size()]));</span>
        }

        /**
         * Given an array of slices (potentially overlapping and in any order) and return an equivalent array
         * of non-overlapping slices in clustering order.
         *
         * @param slices an array of slices. This may be modified by this method.
         * @return the smallest possible array of non-overlapping slices in clustering order. If the original
         * slices are already non-overlapping and in comparator order, this may or may not return the provided slices
         * directly.
         */
        private List&lt;Slice&gt; normalize(List&lt;Slice&gt; slices)
        {
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">            if (slices.size() &lt;= 1)</span>
<span class="nc" id="L250">                return slices;</span>

<span class="fc" id="L252">            slices.sort((s1, s2) -&gt; {</span>
<span class="fc" id="L253">                int c = comparator.compare(s1.start(), s2.start());</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">                if (c != 0)</span>
<span class="fc" id="L255">                    return c;</span>

<span class="nc" id="L257">                return comparator.compare(s2.end(), s1.end());</span>
            });

<span class="fc" id="L260">            List&lt;Slice&gt; slicesCopy = new ArrayList&lt;&gt;(slices.size());</span>

<span class="fc" id="L262">            Slice last = slices.get(0);</span>

<span class="fc bfc" id="L264" title="All 2 branches covered.">            for (int i = 1; i &lt; slices.size(); i++)</span>
            {
<span class="fc" id="L266">                Slice s2 = slices.get(i);</span>

<span class="fc" id="L268">                boolean includesStart = last.includes(comparator, s2.start());</span>
<span class="fc" id="L269">                boolean includesFinish = last.includes(comparator, s2.end());</span>

<span class="pc bpc" id="L271" title="3 of 4 branches missed.">                if (includesStart &amp;&amp; includesFinish)</span>
<span class="nc" id="L272">                    continue;</span>

<span class="pc bpc" id="L274" title="2 of 4 branches missed.">                if (!includesStart &amp;&amp; !includesFinish)</span>
                {
<span class="fc" id="L276">                    slicesCopy.add(last);</span>
<span class="fc" id="L277">                    last = s2;</span>
<span class="fc" id="L278">                    continue;</span>
                }

<span class="nc bnc" id="L281" title="All 2 branches missed.">                if (includesStart)</span>
<span class="nc" id="L282">                    last = Slice.make(last.start(), s2.end());</span>
            }

<span class="fc" id="L285">            slicesCopy.add(last);</span>
<span class="fc" id="L286">            return slicesCopy;</span>
        }
    }

<span class="fc" id="L290">    public static class Serializer</span>
    {
        public void serialize(Slices slices, DataOutputPlus out, int version) throws IOException
        {
<span class="fc" id="L294">            int size = slices.size();</span>
<span class="fc" id="L295">            out.writeUnsignedVInt32(size);</span>

<span class="pc bpc" id="L297" title="1 of 2 branches missed.">            if (size == 0)</span>
<span class="nc" id="L298">                return;</span>

<span class="fc bfc" id="L300" title="All 2 branches covered.">            List&lt;AbstractType&lt;?&gt;&gt; types = slices == ALL</span>
<span class="fc" id="L301">                                        ? Collections.emptyList()</span>
<span class="fc" id="L302">                                        : ((ArrayBackedSlices)slices).comparator.subtypes();</span>

<span class="fc bfc" id="L304" title="All 2 branches covered.">            for (Slice slice : slices)</span>
<span class="fc" id="L305">                Slice.serializer.serialize(slice, out, version, types);</span>
<span class="fc" id="L306">        }</span>

        public long serializedSize(Slices slices, int version)
        {
<span class="fc" id="L310">            long size = TypeSizes.sizeofUnsignedVInt(slices.size());</span>

<span class="pc bpc" id="L312" title="1 of 2 branches missed.">            if (slices.size() == 0)</span>
<span class="nc" id="L313">                return size;</span>

<span class="fc bfc" id="L315" title="All 2 branches covered.">            List&lt;AbstractType&lt;?&gt;&gt; types = slices instanceof SelectAllSlices</span>
<span class="fc" id="L316">                                        ? Collections.emptyList()</span>
<span class="fc" id="L317">                                        : ((ArrayBackedSlices)slices).comparator.subtypes();</span>

<span class="fc bfc" id="L319" title="All 2 branches covered.">            for (Slice slice : slices)</span>
<span class="fc" id="L320">                size += Slice.serializer.serializedSize(slice, version, types);</span>

<span class="fc" id="L322">            return size;</span>
        }

        public Slices deserialize(DataInputPlus in, int version, TableMetadata metadata) throws IOException
        {
<span class="fc" id="L327">            int size = in.readUnsignedVInt32();</span>

<span class="pc bpc" id="L329" title="1 of 2 branches missed.">            if (size == 0)</span>
<span class="nc" id="L330">                return NONE;</span>

<span class="fc" id="L332">            Slice[] slices = new Slice[size];</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++)</span>
<span class="fc" id="L334">                slices[i] = Slice.serializer.deserialize(in, version, metadata.comparator.subtypes());</span>

<span class="fc bfc" id="L336" title="All 6 branches covered.">            if (size == 1 &amp;&amp; slices[0].start().isBottom() &amp;&amp; slices[0].end().isTop())</span>
<span class="fc" id="L337">                return ALL;</span>

<span class="fc" id="L339">            return new ArrayBackedSlices(metadata.comparator, slices);</span>
        }
    }

    /**
     * Simple {@code Slices} implementation that stores its slices in an array.
     */
    private static class ArrayBackedSlices extends Slices
    {
        private final ClusteringComparator comparator;

        private final Slice[] slices;

        private ArrayBackedSlices(ClusteringComparator comparator, Slice[] slices)
<span class="fc" id="L353">        {</span>
<span class="fc" id="L354">            this.comparator = comparator;</span>
<span class="fc" id="L355">            this.slices = slices;</span>
<span class="fc" id="L356">        }</span>

        public int size()
        {
<span class="fc" id="L360">            return slices.length;</span>
        }

        public boolean hasLowerBound()
        {
<span class="fc bfc" id="L365" title="All 2 branches covered.">            return slices[0].start().size() != 0;</span>
        }

        public boolean hasUpperBound()
        {
<span class="fc bfc" id="L370" title="All 2 branches covered.">            return slices[slices.length - 1].end().size() != 0;</span>
        }

        public Slice get(int i)
        {
<span class="fc" id="L375">            return slices[i];</span>
        }

        public boolean selects(Clustering&lt;?&gt; clustering)
        {
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">            for (int i = 0; i &lt; slices.length; i++)</span>
            {
<span class="fc" id="L382">                Slice slice = slices[i];</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">                if (comparator.compare(clustering, slice.start()) &lt; 0)</span>
<span class="fc" id="L384">                    return false;</span>

<span class="pc bpc" id="L386" title="1 of 2 branches missed.">                if (comparator.compare(clustering, slice.end()) &lt;= 0)</span>
<span class="fc" id="L387">                    return true;</span>
            }
<span class="nc" id="L389">            return false;</span>
        }

        public InOrderTester inOrderTester(boolean reversed)
        {
<span class="nc bnc" id="L394" title="All 2 branches missed.">            return reversed ? new InReverseOrderTester() : new InForwardOrderTester();</span>
        }

        public Slices forPaging(ClusteringComparator comparator, Clustering&lt;?&gt; lastReturned, boolean inclusive, boolean reversed)
        {
<span class="fc bfc" id="L399" title="All 2 branches covered.">            return reversed ? forReversePaging(comparator, lastReturned, inclusive) : forForwardPaging(comparator, lastReturned, inclusive);</span>
        }

        private Slices forForwardPaging(ClusteringComparator comparator, Clustering&lt;?&gt; lastReturned, boolean inclusive)
        {
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">            for (int i = 0; i &lt; slices.length; i++)</span>
            {
<span class="fc" id="L406">                Slice slice = slices[i];</span>
<span class="fc" id="L407">                Slice newSlice = slice.forPaging(comparator, lastReturned, inclusive, false);</span>
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">                if (newSlice == null)</span>
<span class="nc" id="L409">                    continue;</span>

<span class="pc bpc" id="L411" title="3 of 4 branches missed.">                if (slice == newSlice &amp;&amp; i == 0)</span>
<span class="nc" id="L412">                    return this;</span>

<span class="fc" id="L414">                ArrayBackedSlices newSlices = new ArrayBackedSlices(comparator, Arrays.copyOfRange(slices, i, slices.length));</span>
<span class="fc" id="L415">                newSlices.slices[0] = newSlice;</span>
<span class="fc" id="L416">                return newSlices;</span>
            }
<span class="nc" id="L418">            return Slices.NONE;</span>
        }

        private Slices forReversePaging(ClusteringComparator comparator, Clustering&lt;?&gt; lastReturned, boolean inclusive)
        {
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">            for (int i = slices.length - 1; i &gt;= 0; i--)</span>
            {
<span class="fc" id="L425">                Slice slice = slices[i];</span>
<span class="fc" id="L426">                Slice newSlice = slice.forPaging(comparator, lastReturned, inclusive, true);</span>
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">                if (newSlice == null)</span>
<span class="nc" id="L428">                    continue;</span>

<span class="pc bpc" id="L430" title="3 of 4 branches missed.">                if (slice == newSlice &amp;&amp; i == slices.length - 1)</span>
<span class="nc" id="L431">                    return this;</span>

<span class="fc" id="L433">                ArrayBackedSlices newSlices = new ArrayBackedSlices(comparator, Arrays.copyOfRange(slices, 0, i + 1));</span>
<span class="fc" id="L434">                newSlices.slices[i] = newSlice;</span>
<span class="fc" id="L435">                return newSlices;</span>
            }
<span class="nc" id="L437">            return Slices.NONE;</span>
        }

        @Override
        public boolean intersects(Slice slice)
        {
<span class="fc bfc" id="L443" title="All 2 branches covered.">            for (Slice s : this)</span>
            {
<span class="fc bfc" id="L445" title="All 2 branches covered.">                if (s.intersects(comparator, slice))</span>
<span class="fc" id="L446">                    return true;</span>
<span class="fc" id="L447">            }</span>
<span class="fc" id="L448">            return false;</span>
        }

        public Iterator&lt;Slice&gt; iterator()
        {
<span class="fc" id="L453">            return Iterators.forArray(slices);</span>
        }

<span class="nc" id="L456">        private class InForwardOrderTester implements InOrderTester</span>
        {
            private int idx;
            private boolean inSlice;

            public boolean includes(Clustering&lt;?&gt; value)
            {
<span class="nc bnc" id="L463" title="All 2 branches missed.">                while (idx &lt; slices.length)</span>
                {
<span class="nc bnc" id="L465" title="All 2 branches missed.">                    if (!inSlice)</span>
                    {
<span class="nc" id="L467">                        int cmp = comparator.compare(value, slices[idx].start());</span>
                        // value &lt; start
<span class="nc bnc" id="L469" title="All 2 branches missed.">                        if (cmp &lt; 0)</span>
<span class="nc" id="L470">                            return false;</span>

<span class="nc" id="L472">                        inSlice = true;</span>

<span class="nc bnc" id="L474" title="All 2 branches missed.">                        if (cmp == 0)</span>
<span class="nc" id="L475">                            return true;</span>
                    }

                    // Here, start &lt; value and inSlice
<span class="nc bnc" id="L479" title="All 2 branches missed.">                    if (comparator.compare(value, slices[idx].end()) &lt;= 0)</span>
<span class="nc" id="L480">                        return true;</span>

<span class="nc" id="L482">                    ++idx;</span>
<span class="nc" id="L483">                    inSlice = false;</span>
                }
<span class="nc" id="L485">                return false;</span>
            }

            public boolean isDone()
            {
<span class="nc bnc" id="L490" title="All 2 branches missed.">                return idx &gt;= slices.length;</span>
            }
        }

        private class InReverseOrderTester implements InOrderTester
        {
            private int idx;
            private boolean inSlice;

            public InReverseOrderTester()
<span class="nc" id="L500">            {</span>
<span class="nc" id="L501">                this.idx = slices.length - 1;</span>
<span class="nc" id="L502">            }</span>

            public boolean includes(Clustering&lt;?&gt; value)
            {
<span class="nc bnc" id="L506" title="All 2 branches missed.">                while (idx &gt;= 0)</span>
                {
<span class="nc bnc" id="L508" title="All 2 branches missed.">                    if (!inSlice)</span>
                    {
<span class="nc" id="L510">                        int cmp = comparator.compare(slices[idx].end(), value);</span>
                        // value &gt; end
<span class="nc bnc" id="L512" title="All 2 branches missed.">                        if (cmp &gt; 0)</span>
<span class="nc" id="L513">                            return false;</span>

<span class="nc" id="L515">                        inSlice = true;</span>

<span class="nc bnc" id="L517" title="All 2 branches missed.">                        if (cmp == 0)</span>
<span class="nc" id="L518">                            return true;</span>
                    }

                    // Here, value &lt;= end and inSlice
<span class="nc bnc" id="L522" title="All 2 branches missed.">                    if (comparator.compare(slices[idx].start(), value) &lt;= 0)</span>
<span class="nc" id="L523">                        return true;</span>

<span class="nc" id="L525">                    --idx;</span>
<span class="nc" id="L526">                    inSlice = false;</span>
                }
<span class="nc" id="L528">                return false;</span>
            }

            public boolean isDone()
            {
<span class="nc bnc" id="L533" title="All 2 branches missed.">                return idx &lt; 0;</span>
            }
        }

        @Override
        public String toString()
        {
<span class="nc" id="L540">            return Arrays.stream(slices).map(s -&gt; s.toString(comparator)).collect(Collectors.joining(&quot;, &quot;, &quot;{&quot;, &quot;}&quot;));</span>
        }

        @Override
        public String toCQLString(TableMetadata metadata, RowFilter rowFilter)
        {
<span class="fc" id="L546">            StringBuilder sb = new StringBuilder();</span>

            // In CQL, condition are expressed by column, so first group things that way,
            // i.e. for each column, we create a list of what each slice contains on that column
<span class="fc" id="L550">            int clusteringSize = metadata.clusteringColumns().size();</span>
<span class="fc" id="L551">            List&lt;List&lt;ComponentOfSlice&gt;&gt; columnComponents = new ArrayList&lt;&gt;(clusteringSize);</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">            for (int i = 0; i &lt; clusteringSize; i++)</span>
            {
<span class="fc" id="L554">                List&lt;ComponentOfSlice&gt; perSlice = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L555">                columnComponents.add(perSlice);</span>

<span class="fc bfc" id="L557" title="All 2 branches covered.">                for (int j = 0; j &lt; slices.length; j++)</span>
                {
<span class="fc" id="L559">                    ComponentOfSlice c = ComponentOfSlice.fromSlice(i, slices[j]);</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">                    if (c != null)</span>
<span class="fc" id="L561">                        perSlice.add(c);</span>
                }
            }

<span class="fc" id="L565">            boolean needAnd = false;</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">            for (int i = 0; i &lt; clusteringSize; i++)</span>
            {
<span class="fc" id="L568">                ColumnMetadata column = metadata.clusteringColumns().get(i);</span>
<span class="fc" id="L569">                List&lt;ComponentOfSlice&gt; componentInfo = columnComponents.get(i);</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">                if (componentInfo.isEmpty())</span>
<span class="fc" id="L571">                    break;</span>

                // For a given column, there is only 3 cases that CQL currently generates:
                //   1) every slice are EQ with the same value, it's a simple '=' relation.
                //   2) every slice are EQ but with different values, it's a IN relation.
                //   3) every slice aren't EQ but have the same values, we have inequality relations.
                // Note that this doesn't cover everything that ReadCommand can express, but
                // as it's all that CQL support for now, we'll ignore other cases (which would then
                // display a bogus query but that's not the end of the world).
                // TODO: we should improve this at some point.
<span class="fc" id="L581">                ComponentOfSlice first = componentInfo.get(0);</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">                if (first.isEQ())</span>
                {
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">                    if (needAnd)</span>
<span class="nc" id="L585">                        sb.append(&quot; AND &quot;);</span>
<span class="fc" id="L586">                    needAnd = true;</span>

<span class="fc" id="L588">                    sb.append(column.name.toCQLString());</span>

<span class="fc" id="L590">                    Set&lt;ByteBuffer&gt; values = new LinkedHashSet&lt;&gt;();</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">                    for (int j = 0; j &lt; componentInfo.size(); j++)</span>
<span class="fc" id="L592">                        values.add(componentInfo.get(j).startValue);</span>

<span class="fc bfc" id="L594" title="All 2 branches covered.">                    if (values.size() == 1)</span>
                    {
<span class="fc" id="L596">                        sb.append(&quot; = &quot;).append(column.type.toCQLString(first.startValue));</span>
<span class="fc" id="L597">                        rowFilter = rowFilter.without(column, Operator.EQ, first.startValue);</span>
                    }
                    else
                    {
<span class="fc" id="L601">                        sb.append(&quot; IN (&quot;);</span>
<span class="fc" id="L602">                        int j = 0;</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">                        for (ByteBuffer value : values)</span>
                        {
<span class="fc bfc" id="L605" title="All 2 branches covered.">                            sb.append(j++ == 0 ? &quot;&quot; : &quot;, &quot;).append(column.type.toCQLString(value));</span>
<span class="fc" id="L606">                            rowFilter = rowFilter.without(column, Operator.EQ, value);</span>
<span class="fc" id="L607">                        }</span>
<span class="fc" id="L608">                        sb.append(&quot;)&quot;);</span>
                    }
<span class="fc" id="L610">                }</span>
                else
                {
<span class="fc" id="L613">                    boolean isReversed = column.isReversedType();</span>
                    Operator operator;

                    // As said above, we assume (without checking) that this means all ComponentOfSlice for this column
                    // are the same, so we only bother about the first.
<span class="fc bfc" id="L618" title="All 2 branches covered.">                    if (first.startValue != null)</span>
                    {
<span class="fc bfc" id="L620" title="All 2 branches covered.">                        if (needAnd)</span>
<span class="fc" id="L621">                            sb.append(&quot; AND &quot;);</span>
<span class="fc" id="L622">                        needAnd = true;</span>
<span class="fc" id="L623">                        sb.append(column.name.toCQLString());</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">                        if (isReversed)</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">                            operator = first.startInclusive ? Operator.LTE : Operator.LT;</span>
                        else
<span class="fc bfc" id="L627" title="All 2 branches covered.">                            operator = first.startInclusive ? Operator.GTE : Operator.GT;</span>
<span class="fc" id="L628">                        sb.append(' ').append(operator).append(' ')</span>
<span class="fc" id="L629">                          .append(column.type.toCQLString(first.startValue));</span>
<span class="fc" id="L630">                        rowFilter = rowFilter.without(column, operator, first.startValue);</span>
                    }
<span class="fc bfc" id="L632" title="All 2 branches covered.">                    if (first.endValue != null)</span>
                    {
<span class="fc bfc" id="L634" title="All 2 branches covered.">                        if (needAnd)</span>
<span class="fc" id="L635">                            sb.append(&quot; AND &quot;);</span>
<span class="fc" id="L636">                        needAnd = true;</span>
<span class="fc" id="L637">                        sb.append(column.name.toCQLString());</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">                        if (isReversed)</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">                            operator = first.endInclusive ? Operator.GTE : Operator.GT;</span>
                        else
<span class="fc bfc" id="L641" title="All 2 branches covered.">                            operator = first.endInclusive ? Operator.LTE : Operator.LT;</span>
<span class="fc" id="L642">                        sb.append(' ').append(operator).append(' ')</span>
<span class="fc" id="L643">                          .append(column.type.toCQLString(first.endValue));</span>
<span class="fc" id="L644">                        rowFilter = rowFilter.without(column, operator, first.endValue);</span>
                    }
                }
            }

<span class="pc bpc" id="L649" title="1 of 2 branches missed.">            if (!rowFilter.isEmpty())</span>
            {
<span class="nc bnc" id="L651" title="All 2 branches missed.">                if (needAnd)</span>
<span class="nc" id="L652">                    sb.append(&quot; AND &quot;);</span>
<span class="nc" id="L653">                sb.append(rowFilter.toCQLString());</span>
            }

<span class="fc" id="L656">            return sb.toString();</span>
        }

        // Somewhat adhoc utility class only used by nameAsCQLString
        private static class ComponentOfSlice
        {
            public final boolean startInclusive;
            public final ByteBuffer startValue;
            public final boolean endInclusive;
            public final ByteBuffer endValue;

            private ComponentOfSlice(boolean startInclusive, ByteBuffer startValue, boolean endInclusive, ByteBuffer endValue)
<span class="fc" id="L668">            {</span>
<span class="fc" id="L669">                this.startInclusive = startInclusive;</span>
<span class="fc" id="L670">                this.startValue = startValue;</span>
<span class="fc" id="L671">                this.endInclusive = endInclusive;</span>
<span class="fc" id="L672">                this.endValue = endValue;</span>
<span class="fc" id="L673">            }</span>

            public static ComponentOfSlice fromSlice(int component, Slice slice)
            {
<span class="fc" id="L677">                ClusteringBound&lt;?&gt; start = slice.start();</span>
<span class="fc" id="L678">                ClusteringBound&lt;?&gt; end = slice.end();</span>

<span class="fc bfc" id="L680" title="All 4 branches covered.">                if (component &gt;= start.size() &amp;&amp; component &gt;= end.size())</span>
<span class="fc" id="L681">                    return null;</span>

<span class="fc" id="L683">                boolean startInclusive = true, endInclusive = true;</span>
<span class="fc" id="L684">                ByteBuffer startValue = null, endValue = null;</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">                if (component &lt; start.size())</span>
                {
<span class="fc" id="L687">                    startInclusive = start.isInclusive();</span>
<span class="fc" id="L688">                    startValue = start.bufferAt(component);</span>
                }
<span class="fc bfc" id="L690" title="All 2 branches covered.">                if (component &lt; end.size())</span>
                {
<span class="fc" id="L692">                    endInclusive = end.isInclusive();</span>
<span class="fc" id="L693">                    endValue = end.bufferAt(component);</span>
                }
<span class="fc" id="L695">                return new ComponentOfSlice(startInclusive, startValue, endInclusive, endValue);</span>
            }

            public boolean isEQ()
            {
<span class="fc" id="L700">                return Objects.equals(startValue, endValue);</span>
            }
        }
    }

    /**
     * Specialized implementation of {@code Slices} that selects all rows.
     * &lt;p&gt;
     * This is equivalent to having the single {@code Slice.ALL} slice, but is somewhat more effecient.
     */
    private static class SelectAllSlices extends Slices
    {
<span class="fc" id="L712">        private static final InOrderTester trivialTester = new InOrderTester()</span>
<span class="fc" id="L713">        {</span>
            public boolean includes(Clustering&lt;?&gt; value)
            {
<span class="nc" id="L716">                return true;</span>
            }

            public boolean isDone()
            {
<span class="nc" id="L721">                return false;</span>
            }
        };

        public int size()
        {
<span class="fc" id="L727">            return 1;</span>
        }

        public Slice get(int i)
        {
<span class="fc" id="L732">            return Slice.ALL;</span>
        }

        public boolean hasLowerBound()
        {
<span class="fc" id="L737">            return false;</span>
        }

        public boolean hasUpperBound()
        {
<span class="fc" id="L742">            return false;</span>
        }

        public boolean selects(Clustering&lt;?&gt; clustering)
        {
<span class="fc" id="L747">            return true;</span>
        }

        public Slices forPaging(ClusteringComparator comparator, Clustering&lt;?&gt; lastReturned, boolean inclusive, boolean reversed)
        {
<span class="fc" id="L752">            return new ArrayBackedSlices(comparator, new Slice[]{ Slice.ALL.forPaging(comparator, lastReturned, inclusive, reversed) });</span>
        }

        public InOrderTester inOrderTester(boolean reversed)
        {
<span class="nc" id="L757">            return trivialTester;</span>
        }

        @Override
        public boolean intersects(Slice slice)
        {
<span class="fc" id="L763">            return true;</span>
        }

        public Iterator&lt;Slice&gt; iterator()
        {
<span class="fc" id="L768">            return Iterators.singletonIterator(Slice.ALL);</span>
        }

        @Override
        public String toString()
        {
<span class="fc" id="L774">            return &quot;ALL&quot;;</span>
        }

        @Override
        public String toCQLString(TableMetadata metadata, RowFilter rowFilter)
        {
<span class="fc" id="L780">            return rowFilter.toCQLString();</span>
        }
    }

    /**
     * Specialized implementation of {@code Slices} that selects no rows.
     */
    private static class SelectNoSlices extends Slices
    {
<span class="fc" id="L789">        private static final InOrderTester trivialTester = new InOrderTester()</span>
<span class="fc" id="L790">        {</span>
            public boolean includes(Clustering&lt;?&gt; value)
            {
<span class="nc" id="L793">                return false;</span>
            }

            public boolean isDone()
            {
<span class="nc" id="L798">                return true;</span>
            }
        };

        public int size()
        {
<span class="fc" id="L804">            return 0;</span>
        }

        public Slice get(int i)
        {
<span class="nc" id="L809">            throw new UnsupportedOperationException();</span>
        }

        public boolean hasLowerBound()
        {
<span class="nc" id="L814">            return false;</span>
        }

        public boolean hasUpperBound()
        {
<span class="nc" id="L819">            return false;</span>
        }

        public Slices forPaging(ClusteringComparator comparator, Clustering&lt;?&gt; lastReturned, boolean inclusive, boolean reversed)
        {
<span class="nc" id="L824">            return this;</span>
        }

        public boolean selects(Clustering&lt;?&gt; clustering)
        {
<span class="nc" id="L829">            return false;</span>
        }

        public InOrderTester inOrderTester(boolean reversed)
        {
<span class="nc" id="L834">            return trivialTester;</span>
        }

        @Override
        public boolean intersects(Slice slice)
        {
<span class="nc" id="L840">            return false;</span>
        }

        public Iterator&lt;Slice&gt; iterator()
        {
<span class="nc" id="L845">            return Collections.emptyIterator();</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L851">            return &quot;NONE&quot;;</span>
        }

        @Override
        public String toCQLString(TableMetadata metadata, RowFilter rowFilter)
        {
<span class="nc" id="L857">            return &quot;&quot;;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>