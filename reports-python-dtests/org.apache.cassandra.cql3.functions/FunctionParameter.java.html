<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FunctionParameter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.functions</a> &gt; <span class="el_source">FunctionParameter.java</span></div><h1>FunctionParameter.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.cql3.functions;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import javax.annotation.Nullable;

import org.apache.cassandra.cql3.AssignmentTestable;
import org.apache.cassandra.cql3.CQL3Type;
import org.apache.cassandra.cql3.selection.Selectable;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.marshal.CollectionType;
import org.apache.cassandra.db.marshal.ListType;
import org.apache.cassandra.db.marshal.MapType;
import org.apache.cassandra.db.marshal.NumberType;
import org.apache.cassandra.db.marshal.SetType;
import org.apache.cassandra.db.marshal.VectorType;
import org.apache.cassandra.exceptions.InvalidRequestException;

import static java.lang.String.format;
import static org.apache.cassandra.cql3.AssignmentTestable.TestResult.NOT_ASSIGNABLE;

/**
 * Generic, loose definition of a function parameter, able to infer the specific data type of the parameter in the
 * function specifically built by a {@link FunctionFactory} for a particular function call.
 */
<span class="pc bpc" id="L45" title="1 of 2 branches missed.">public interface FunctionParameter</span>
{
    /**
     * Tries to infer the data type of the parameter for an argument in a call to the function.
     *
     * @param keyspace the current keyspace
     * @param arg a parameter value in a specific function call
     * @param receiverType the type of the object that will receive the result of the function call
     * @param inferredTypes the types that have been inferred for the other parameters
     * @return the inferred data type of the parameter, or {@link null} it isn't possible to infer it
     */
    @Nullable
    default AbstractType&lt;?&gt; inferType(String keyspace,
                                      AssignmentTestable arg,
                                      @Nullable AbstractType&lt;?&gt; receiverType,
                                      @Nullable List&lt;AbstractType&lt;?&gt;&gt; inferredTypes)
    {
<span class="nc" id="L62">        return arg.getCompatibleTypeIfKnown(keyspace);</span>
    }

    void validateType(FunctionName name, AssignmentTestable arg, AbstractType&lt;?&gt; argType);

    /**
     * @return whether this parameter is optional
     */
    default boolean isOptional()
    {
<span class="fc" id="L72">        return false;</span>
    }

    /**
     * @param wrapped the wrapped parameter
     * @return a function parameter definition that accepts the specified wrapped parameter, considering it optional as
     * defined by {@link #isOptional()}.
     */
    static FunctionParameter optional(FunctionParameter wrapped)
    {
<span class="fc" id="L82">        return new FunctionParameter()</span>
<span class="fc" id="L83">        {</span>
            @Nullable
            @Override
            public AbstractType&lt;?&gt; inferType(String keyspace,
                                             AssignmentTestable arg,
                                             @Nullable AbstractType&lt;?&gt; receiverType,
                                             @Nullable List&lt;AbstractType&lt;?&gt;&gt; inferredTypes)
            {
<span class="nc" id="L91">                return wrapped.inferType(keyspace, arg, receiverType, inferredTypes);</span>
            }

            @Override
            public void validateType(FunctionName name, AssignmentTestable arg, AbstractType&lt;?&gt; argType)
            {
<span class="nc" id="L97">                wrapped.validateType(name, arg, argType);</span>
<span class="nc" id="L98">            }</span>

            @Override
            public boolean isOptional()
            {
<span class="fc" id="L103">                return true;</span>
            }

            @Override
            public String toString()
            {
<span class="nc" id="L109">                return '[' + wrapped.toString() + ']';</span>
            }
        };
    }

    /**
     * @return a function parameter definition that accepts values of string-based data types (text, varchar and ascii)
     */
    static FunctionParameter string()
    {
<span class="fc" id="L119">        return fixed(CQL3Type.Native.TEXT, CQL3Type.Native.VARCHAR, CQL3Type.Native.ASCII);</span>
    }

    /**
     * @param types the accepted data types
     * @return a function parameter definition that accepts values of a specific data type
     */
    static FunctionParameter fixed(CQL3Type... types)
    {
<span class="pc bpc" id="L128" title="2 of 4 branches missed.">        assert types.length &gt; 0;</span>

<span class="fc" id="L130">        return new FunctionParameter()</span>
<span class="fc" id="L131">        {</span>
            @Override
            public AbstractType&lt;?&gt; inferType(String keyspace,
                                             AssignmentTestable arg,
                                             @Nullable AbstractType&lt;?&gt; receiverType,
                                             @Nullable List&lt;AbstractType&lt;?&gt;&gt; inferredTypes)
            {
<span class="fc" id="L138">                AbstractType&lt;?&gt; inferred = arg.getCompatibleTypeIfKnown(keyspace);</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">                return inferred != null ? inferred : types[0].getType();</span>
            }

            @Override
            public void validateType(FunctionName name, AssignmentTestable arg, AbstractType&lt;?&gt; argType)
            {
<span class="pc bpc" id="L145" title="2 of 4 branches missed.">                if (Arrays.stream(types).allMatch(t -&gt; argType.testAssignment(t.getType()) == NOT_ASSIGNABLE))</span>
<span class="nc" id="L146">                    throw new InvalidRequestException(format(&quot;Function %s requires an argument of type %s, &quot; +</span>
                                                             &quot;but found argument %s of type %s&quot;,
<span class="nc" id="L148">                                                             name, this, arg, argType.asCQL3Type()));</span>
<span class="fc" id="L149">            }</span>

            @Override
            public String toString()
            {
<span class="nc bnc" id="L154" title="All 2 branches missed.">                if (types.length == 1)</span>
<span class="nc" id="L155">                    return types[0].toString();</span>

<span class="nc" id="L157">                return '[' + Arrays.stream(types).map(Object::toString).collect(Collectors.joining(&quot;|&quot;)) + ']';</span>
            }
        };
    }

    /**
     * @param inferFromReceiver whether the parameter should try to use the function receiver to infer its data type
     * @return a function parameter definition that accepts columns of any data type
     */
    static FunctionParameter anyType(boolean inferFromReceiver)
    {
<span class="fc" id="L168">        return new FunctionParameter()</span>
<span class="fc" id="L169">        {</span>
            @Override
            public AbstractType&lt;?&gt; inferType(String keyspace,
                                             AssignmentTestable arg,
                                             @Nullable AbstractType&lt;?&gt; receiverType,
                                             @Nullable List&lt;AbstractType&lt;?&gt;&gt; inferredTypes)
            {
<span class="fc" id="L176">                AbstractType&lt;?&gt; type = arg.getCompatibleTypeIfKnown(keyspace);</span>
<span class="pc bpc" id="L177" title="3 of 4 branches missed.">                return type == null &amp;&amp; inferFromReceiver ? receiverType : type;</span>
            }

            @Override
            public void validateType(FunctionName name, AssignmentTestable arg, AbstractType&lt;?&gt; argType)
            {
                // nothing to do here, all types are accepted
<span class="fc" id="L184">            }</span>

            @Override
            public String toString()
            {
<span class="nc" id="L189">                return &quot;any&quot;;</span>
            }
        };
    }

    /**
     * @param index the index of the function argument that this parameter is associated with
     * @param preferOther whether the parameter should prefer the type of the other parameter over its own type
     * @param parameter the type of this parameter when the type of the associated parameter is unknown
     * @return a function parameter definition that is expected to have the same type as another parameter
     */
    static FunctionParameter sameAs(int index, boolean preferOther, FunctionParameter parameter)
    {
<span class="fc" id="L202">        return new FunctionParameter()</span>
<span class="fc" id="L203">        {</span>
            @Override
            public AbstractType&lt;?&gt; inferType(String keyspace,
                                             AssignmentTestable arg,
                                             @Nullable AbstractType&lt;?&gt; receiverType,
                                             @Nullable List&lt;AbstractType&lt;?&gt;&gt; inferredTypes)
            {
<span class="nc bnc" id="L210" title="All 2 branches missed.">                if (preferOther)</span>
                {
<span class="nc bnc" id="L212" title="All 2 branches missed.">                    AbstractType&lt;?&gt; other = inferredTypes == null ? null : inferredTypes.get(index);</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">                    return other == null ? parameter.inferType(keyspace, arg, receiverType, inferredTypes) : other;</span>
                }

<span class="nc" id="L216">                AbstractType&lt;?&gt; inferred = parameter.inferType(keyspace, arg, receiverType, inferredTypes);</span>
<span class="nc bnc" id="L217" title="All 4 branches missed.">                return inferred == null &amp;&amp; inferredTypes != null ? inferredTypes.get(index) : inferred;</span>
            }

            @Override
            public void validateType(FunctionName name, AssignmentTestable arg, AbstractType&lt;?&gt; argType)
            {
<span class="nc" id="L223">                parameter.validateType(name, arg, argType);</span>
<span class="nc" id="L224">            }</span>

            @Override
            public String toString()
            {
<span class="nc" id="L229">                return parameter.toString();</span>
            }
        };
    }

    /**
     * @return a function parameter definition that accepts values of type {@link CollectionType}, independently of the
     * types of its elements.
     */
    static FunctionParameter anyCollection()
    {
<span class="fc" id="L240">        return new FunctionParameter()</span>
<span class="fc" id="L241">        {</span>
            @Override
            public void validateType(FunctionName name, AssignmentTestable arg, AbstractType&lt;?&gt; argType)
            {
<span class="nc bnc" id="L245" title="All 2 branches missed.">                if (!argType.isCollection())</span>
<span class="nc" id="L246">                    throw new InvalidRequestException(format(&quot;Function %s requires a collection argument, &quot; +</span>
                                                             &quot;but found argument %s of type %s&quot;,
<span class="nc" id="L248">                                                             name, arg, argType.asCQL3Type()));</span>
<span class="nc" id="L249">            }</span>

            @Override
            public String toString()
            {
<span class="nc" id="L254">                return &quot;collection&quot;;</span>
            }
        };
    }

    /**
     * @return a function parameter definition that accepts values of type {@link SetType} or {@link ListType}.
     */
    static FunctionParameter setOrList()
    {
<span class="fc" id="L264">        return new FunctionParameter()</span>
<span class="fc" id="L265">        {</span>
            @Override
            public void validateType(FunctionName name, AssignmentTestable arg, AbstractType&lt;?&gt; argType)
            {
<span class="nc bnc" id="L269" title="All 2 branches missed.">                if (argType.isCollection())</span>
                {
<span class="nc" id="L271">                    CollectionType.Kind kind = ((CollectionType&lt;?&gt;) argType).kind;</span>
<span class="nc bnc" id="L272" title="All 4 branches missed.">                    if (kind == CollectionType.Kind.SET || kind == CollectionType.Kind.LIST)</span>
<span class="nc" id="L273">                        return;</span>
                }

<span class="nc" id="L276">                throw new InvalidRequestException(format(&quot;Function %s requires a set or list argument, &quot; +</span>
                                                         &quot;but found argument %s of type %s&quot;,
<span class="nc" id="L278">                                                         name, arg, argType.asCQL3Type()));</span>
            }

            @Override
            public String toString()
            {
<span class="nc" id="L284">                return &quot;numeric_set_or_list&quot;;</span>
            }
        };
    }

    /**
     * @return a function parameter definition that accepts values of type {@link SetType} or {@link ListType},
     * provided that its elements are numeric.
     */
    static FunctionParameter numericSetOrList()
    {
<span class="fc" id="L295">        return new FunctionParameter()</span>
<span class="fc" id="L296">        {</span>
            @Override
            public void validateType(FunctionName name, AssignmentTestable arg, AbstractType&lt;?&gt; argType)
            {
<span class="nc" id="L300">                AbstractType&lt;?&gt; elementType = null;</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">                if (argType.isCollection())</span>
                {
<span class="nc" id="L303">                    CollectionType&lt;?&gt; collectionType = (CollectionType&lt;?&gt;) argType;</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">                    if (collectionType.kind == CollectionType.Kind.SET)</span>
                    {
<span class="nc" id="L306">                        elementType = ((SetType&lt;?&gt;) argType).getElementsType();</span>
                    }
<span class="nc bnc" id="L308" title="All 2 branches missed.">                    else if (collectionType.kind == CollectionType.Kind.LIST)</span>
                    {
<span class="nc" id="L310">                        elementType = ((ListType&lt;?&gt;) argType).getElementsType();</span>
                    }
                }

<span class="nc bnc" id="L314" title="All 2 branches missed.">                if (!(elementType instanceof NumberType))</span>
<span class="nc" id="L315">                    throw new InvalidRequestException(format(&quot;Function %s requires a numeric set/list argument, &quot; +</span>
                                                             &quot;but found argument %s of type %s&quot;,
<span class="nc" id="L317">                                                             name, arg, argType.asCQL3Type()));</span>
<span class="nc" id="L318">            }</span>

            @Override
            public String toString()
            {
<span class="nc" id="L323">                return &quot;numeric_set_or_list&quot;;</span>
            }
        };
    }

    /**
     * @return a function parameter definition that accepts values of type {@link MapType}, independently of the types
     * of the map keys and values.
     */
    static FunctionParameter anyMap()
    {
<span class="fc" id="L334">        return new FunctionParameter()</span>
<span class="fc" id="L335">        {</span>
            @Override
            public void validateType(FunctionName name, AssignmentTestable arg, AbstractType&lt;?&gt; argType)
            {
<span class="nc bnc" id="L339" title="All 4 branches missed.">                if (!argType.isUDT() &amp;&amp; !(argType instanceof MapType))</span>
<span class="nc" id="L340">                    throw new InvalidRequestException(format(&quot;Function %s requires a map argument, &quot; +</span>
                                                             &quot;but found argument %s of type %s&quot;,
<span class="nc" id="L342">                                                             name, arg, argType.asCQL3Type()));</span>
<span class="nc" id="L343">            }</span>

            @Override
            public String toString()
            {
<span class="nc" id="L348">                return &quot;map&quot;;</span>
            }
        };
    }

    /**
     * @param type the type of the vector elements
     * @return a function parameter definition that accepts values of type {@link VectorType} with elements of the
     * specified {@code type} and any dimensions.
     */
    static FunctionParameter vector(CQL3Type type)
    {
<span class="fc" id="L360">        return new FunctionParameter()</span>
<span class="fc" id="L361">        {</span>
            @Override
            public AbstractType&lt;?&gt; inferType(String keyspace,
                                             AssignmentTestable arg,
                                             @Nullable AbstractType&lt;?&gt; receiverType,
                                             @Nullable List&lt;AbstractType&lt;?&gt;&gt; inferredTypes)
            {
<span class="nc bnc" id="L368" title="All 2 branches missed.">                if (arg instanceof Selectable.WithArrayLiteral)</span>
<span class="nc" id="L369">                    return VectorType.getInstance(type.getType(), ((Selectable.WithArrayLiteral) arg).getSize());</span>

<span class="nc" id="L371">                AbstractType&lt;?&gt; inferred = arg.getCompatibleTypeIfKnown(keyspace);</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">                return inferred == null ? receiverType : inferred;</span>
            }

            @Override
            public void validateType(FunctionName name, AssignmentTestable arg, AbstractType&lt;?&gt; argType)
            {
<span class="nc bnc" id="L378" title="All 2 branches missed.">                if (argType.isVector())</span>
                {
<span class="nc" id="L380">                    VectorType&lt;?&gt; vectorType = (VectorType&lt;?&gt;) argType;</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">                    if (vectorType.elementType.asCQL3Type() == type)</span>
<span class="nc" id="L382">                        return;</span>
<span class="nc" id="L383">                }</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">                else if (argType instanceof ListType) // if it's terminal it will be a list</span>
                {
<span class="nc" id="L386">                    ListType&lt;?&gt; listType = (ListType&lt;?&gt;) argType;</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">                    if (listType.getElementsType().testAssignment(type.getType()) == NOT_ASSIGNABLE)</span>
<span class="nc" id="L388">                        return;</span>
                }

<span class="nc" id="L391">                throw new InvalidRequestException(format(&quot;Function %s requires a %s vector argument, &quot; +</span>
                                                         &quot;but found argument %s of type %s&quot;,
<span class="nc" id="L393">                                                         name, type, arg, argType.asCQL3Type()));</span>
            }

            @Override
            public String toString()
            {
<span class="nc" id="L399">                return format(&quot;vector&lt;%s, n&gt;&quot;, type);</span>
            }
        };
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>