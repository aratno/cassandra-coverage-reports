<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FunctionCall.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.functions</a> &gt; <span class="el_source">FunctionCall.java</span></div><h1>FunctionCall.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3.functions;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import org.apache.cassandra.cql3.*;
import org.apache.cassandra.cql3.statements.RequestValidations;
import org.apache.cassandra.db.marshal.*;
import org.apache.cassandra.exceptions.InvalidRequestException;
import org.apache.cassandra.serializers.MarshalException;
import org.apache.cassandra.utils.ByteBufferUtil;

import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;

public class FunctionCall extends Term.NonTerminal
{
    private final ScalarFunction fun;
    private final List&lt;Term&gt; terms;

    private FunctionCall(ScalarFunction fun, List&lt;Term&gt; terms)
<span class="fc" id="L42">    {</span>
<span class="fc" id="L43">        this.fun = fun;</span>
<span class="fc" id="L44">        this.terms = terms;</span>
<span class="fc" id="L45">    }</span>

    public void addFunctionsTo(List&lt;Function&gt; functions)
    {
<span class="fc" id="L49">        Terms.addFunctions(terms, functions);</span>
<span class="fc" id="L50">        fun.addFunctionsTo(functions);</span>
<span class="fc" id="L51">    }</span>

    public void collectMarkerSpecification(VariableSpecifications boundNames)
    {
<span class="fc bfc" id="L55" title="All 2 branches covered.">        for (Term t : terms)</span>
<span class="fc" id="L56">            t.collectMarkerSpecification(boundNames);</span>
<span class="fc" id="L57">    }</span>

    @Override
    public Term.Terminal bind(QueryOptions options) throws InvalidRequestException
    {
<span class="fc" id="L62">        return makeTerminal(fun, bindAndGet(options));</span>
    }

    @Override
    public ByteBuffer bindAndGet(QueryOptions options) throws InvalidRequestException
    {
<span class="fc" id="L68">        Arguments arguments = fun.newArguments(options.getProtocolVersion());</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">        for (int i = 0, m = terms.size(); i &lt; m; i++)</span>
        {
<span class="fc" id="L71">            Term t = terms.get(i);</span>
<span class="fc" id="L72">            ByteBuffer argument = t.bindAndGet(options);</span>
<span class="fc" id="L73">            RequestValidations.checkBindValueSet(argument, &quot;Invalid unset value for argument in call to function %s&quot;, fun.name().name);</span>
<span class="fc" id="L74">            arguments.set(i, argument);</span>
        }
<span class="fc" id="L76">        return executeInternal(fun, arguments);</span>
    }

    private static ByteBuffer executeInternal(ScalarFunction fun, Arguments arguments) throws InvalidRequestException
    {
<span class="fc" id="L81">        ByteBuffer result = fun.execute(arguments);</span>
        try
        {
            // Check the method didn't lie on it's declared return type
<span class="pc bpc" id="L85" title="1 of 2 branches missed.">            if (result != null)</span>
<span class="fc" id="L86">                fun.returnType().validate(result);</span>

<span class="fc" id="L88">            return result;</span>
        }
<span class="nc" id="L90">        catch (MarshalException e)</span>
        {
<span class="nc" id="L92">            throw new RuntimeException(String.format(&quot;Return of function %s (%s) is not a valid value for its declared return type %s&quot;,</span>
<span class="nc" id="L93">                                                     fun, ByteBufferUtil.bytesToHex(result), fun.returnType().asCQL3Type()), e);</span>
        }
    }

    public boolean containsBindMarker()
    {
<span class="nc bnc" id="L99" title="All 2 branches missed.">        for (Term t : terms)</span>
        {
<span class="nc bnc" id="L101" title="All 2 branches missed.">            if (t.containsBindMarker())</span>
<span class="nc" id="L102">                return true;</span>
<span class="nc" id="L103">        }</span>
<span class="nc" id="L104">        return false;</span>
    }

    private static Term.Terminal makeTerminal(Function fun, ByteBuffer result) throws InvalidRequestException
    {
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">        if (result == null)</span>
<span class="nc" id="L110">            return null;</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">        if (fun.returnType().isCollection())</span>
        {
<span class="pc bpc" id="L113" title="1 of 4 branches missed.">            switch (((CollectionType&lt;?&gt;) fun.returnType()).kind)</span>
            {
                case LIST:
<span class="fc" id="L116">                    return Lists.Value.fromSerialized(result, (ListType&lt;?&gt;) fun.returnType());</span>
                case SET:
<span class="fc" id="L118">                    return Sets.Value.fromSerialized(result, (SetType&lt;?&gt;) fun.returnType());</span>
                case MAP:
<span class="pc" id="L120">                    return Maps.Value.fromSerialized(result, (MapType&lt;?, ?&gt;) fun.returnType());</span>
            }
        }
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">        else if (fun.returnType().isUDT())</span>
        {
<span class="fc" id="L125">            return UserTypes.Value.fromSerialized(result, (UserType) fun.returnType());</span>
        }

<span class="nc" id="L128">        return new Constants.Value(result);</span>
    }

    public static class Raw extends Term.Raw
    {
        private final FunctionName name;
        private final List&lt;Term.Raw&gt; terms;

        public Raw(FunctionName name, List&lt;Term.Raw&gt; terms)
<span class="fc" id="L137">        {</span>
<span class="fc" id="L138">            this.name = name;</span>
<span class="fc" id="L139">            this.terms = terms;</span>
<span class="fc" id="L140">        }</span>

        public static Raw newOperation(char operator, Term.Raw left, Term.Raw right)
        {
<span class="nc" id="L144">            FunctionName name = OperationFcts.getFunctionNameFromOperator(operator);</span>
<span class="nc" id="L145">            return new Raw(name, Arrays.asList(left, right));</span>
        }

        public static Raw newNegation(Term.Raw raw)
        {
<span class="nc" id="L150">            FunctionName name = FunctionName.nativeFunction(OperationFcts.NEGATION_FUNCTION_NAME);</span>
<span class="nc" id="L151">            return new Raw(name, Collections.singletonList(raw));</span>
        }

        public static Raw newCast(Term.Raw raw, CQL3Type type)
        {
<span class="nc" id="L156">            FunctionName name = FunctionName.nativeFunction(CastFcts.getFunctionName(type));</span>
<span class="nc" id="L157">            return new Raw(name, Collections.singletonList(raw));</span>
        }

        public Term prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
        {
<span class="fc" id="L162">            Function fun = FunctionResolver.get(keyspace, name, terms, receiver.ksName, receiver.cfName, receiver.type);</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">            if (fun == null)</span>
<span class="nc" id="L164">                throw invalidRequest(&quot;Unknown function %s called&quot;, name);</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">            if (fun.isAggregate())</span>
<span class="nc" id="L166">                throw invalidRequest(&quot;Aggregation function are not supported in the where clause&quot;);</span>

<span class="fc" id="L168">            ScalarFunction scalarFun = (ScalarFunction) fun;</span>

            // Functions.get() will complain if no function &quot;name&quot; type check with the provided arguments.
            // We still have to validate that the return type matches however
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">            if (!scalarFun.testAssignment(keyspace, receiver).isAssignable())</span>
            {
<span class="nc bnc" id="L174" title="All 2 branches missed.">                if (OperationFcts.isOperation(name))</span>
<span class="nc" id="L175">                    throw invalidRequest(&quot;Type error: cannot assign result of operation %s (type %s) to %s (type %s)&quot;,</span>
<span class="nc" id="L176">                                         OperationFcts.getOperator(scalarFun.name()), scalarFun.returnType().asCQL3Type(),</span>
<span class="nc" id="L177">                                         receiver.name, receiver.type.asCQL3Type());</span>

<span class="nc" id="L179">                throw invalidRequest(&quot;Type error: cannot assign result of function %s (type %s) to %s (type %s)&quot;,</span>
<span class="nc" id="L180">                                     scalarFun.name(), scalarFun.returnType().asCQL3Type(),</span>
<span class="nc" id="L181">                                     receiver.name, receiver.type.asCQL3Type());</span>
            }

<span class="pc bpc" id="L184" title="1 of 2 branches missed.">            if (fun.argTypes().size() != terms.size())</span>
<span class="nc" id="L185">                throw invalidRequest(&quot;Incorrect number of arguments specified for function %s (expected %d, found %d)&quot;,</span>
<span class="nc" id="L186">                                     fun, fun.argTypes().size(), terms.size());</span>

<span class="fc" id="L188">            List&lt;Term&gt; parameters = new ArrayList&lt;&gt;(terms.size());</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">            for (int i = 0; i &lt; terms.size(); i++)</span>
            {
<span class="fc" id="L191">                Term t = terms.get(i).prepare(keyspace, FunctionResolver.makeArgSpec(receiver.ksName, receiver.cfName, scalarFun, i));</span>
<span class="fc" id="L192">                parameters.add(t);</span>
            }

<span class="fc" id="L195">            return new FunctionCall(scalarFun, parameters);</span>
        }

        public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
        {
            // Note: Functions.get() will return null if the function doesn't exist, or throw is no function matching
            // the arguments can be found. We may get one of those if an undefined/wrong function is used as argument
            // of another, existing, function. In that case, we return true here because we'll throw a proper exception
            // later with a more helpful error message that if we were to return false here.
            try
            {
<span class="fc" id="L206">                Function fun = FunctionResolver.get(keyspace, name, terms, receiver.ksName, receiver.cfName, receiver.type);</span>

                // Because the return type of functions built by factories is not fixed but depending on the types of
                // their arguments, we'll always get EXACT_MATCH.  To handle potentially ambiguous function calls with
                // dynamically built functions as an argument, always return WEAKLY_ASSIGNABLE to force the user to
                // typecast if necessary
<span class="pc bpc" id="L212" title="2 of 4 branches missed.">                if (fun != null &amp;&amp; NativeFunctions.instance.hasFactory(fun.name()))</span>
<span class="nc" id="L213">                    return TestResult.WEAKLY_ASSIGNABLE;</span>

<span class="pc bpc" id="L215" title="1 of 4 branches missed.">                if (fun != null &amp;&amp; receiver.type.udfType().equals(fun.returnType()))</span>
<span class="fc" id="L216">                    return AssignmentTestable.TestResult.EXACT_MATCH;</span>
<span class="pc bpc" id="L217" title="2 of 4 branches missed.">                else if (fun == null || receiver.type.udfType().isValueCompatibleWith(fun.returnType()))</span>
<span class="nc" id="L218">                    return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;</span>
                else
<span class="fc" id="L220">                    return AssignmentTestable.TestResult.NOT_ASSIGNABLE;</span>
            }
<span class="nc" id="L222">            catch (InvalidRequestException e)</span>
            {
<span class="nc" id="L224">                return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;</span>
            }
        }

        @Override
        public AbstractType&lt;?&gt; getExactTypeIfKnown(String keyspace)
        {
            try
            {
<span class="nc" id="L233">                Function fun = FunctionResolver.get(keyspace, name, terms, null, null, null);</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">                return fun == null ? null : fun.returnType();</span>
            }
<span class="nc" id="L236">            catch (InvalidRequestException e)</span>
            {
<span class="nc" id="L238">                return null;</span>
            }
        }

        public String getText()
        {
<span class="nc" id="L244">            CqlBuilder cqlNameBuilder = new CqlBuilder();</span>
<span class="nc" id="L245">            name.appendCqlTo(cqlNameBuilder);</span>
<span class="nc" id="L246">            return cqlNameBuilder + terms.stream().map(Term.Raw::getText).collect(Collectors.joining(&quot;, &quot;, &quot;(&quot;, &quot;)&quot;));</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>