<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OperationFcts.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.functions</a> &gt; <span class="el_source">OperationFcts.java</span></div><h1>OperationFcts.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3.functions;

import java.nio.ByteBuffer;
import java.util.List;

import org.apache.cassandra.cql3.Duration;
import org.apache.cassandra.schema.SchemaConstants;
import org.apache.cassandra.db.marshal.*;
import org.apache.cassandra.exceptions.OperationExecutionException;

/**
 * Operation functions (Mathematics).
 *
 */
<span class="fc" id="L32">public final class OperationFcts</span>
{
<span class="fc" id="L34">    private enum OPERATION</span>
    {
<span class="fc" id="L36">        ADDITION('+', &quot;_add&quot;)</span>
        {
            protected ByteBuffer executeOnNumerics(NumberType&lt;?&gt; resultType, Number left, Number right)
            {
<span class="nc" id="L40">                return resultType.add(left, right);</span>
            }

            @Override
            protected ByteBuffer executeOnTemporals(TemporalType&lt;?&gt; type, Number temporal, Duration duration)
            {
<span class="nc" id="L46">                return type.addDuration(temporal, duration);</span>
            }

            @Override
            protected ByteBuffer excuteOnStrings(StringType resultType, String left, String right)
            {
<span class="nc" id="L52">                return resultType.concat(left, right);</span>
            }
        },
<span class="fc" id="L55">        SUBSTRACTION('-', &quot;_substract&quot;)</span>
        {
            protected ByteBuffer executeOnNumerics(NumberType&lt;?&gt; resultType, Number left, Number right)
            {
<span class="nc" id="L59">                return resultType.substract(left, right);</span>
            }

            @Override
            protected ByteBuffer executeOnTemporals(TemporalType&lt;?&gt; type, Number temporal, Duration duration)
            {
<span class="nc" id="L65">                return type.substractDuration(temporal, duration);</span>
            }
        },
<span class="fc" id="L68">        MULTIPLICATION('*', &quot;_multiply&quot;)</span>
        {
            protected ByteBuffer executeOnNumerics(NumberType&lt;?&gt; resultType, Number left, Number right)
            {
<span class="nc" id="L72">                return resultType.multiply(left, right);</span>
            }
        },
<span class="fc" id="L75">        DIVISION('/', &quot;_divide&quot;)</span>
        {
            protected ByteBuffer executeOnNumerics(NumberType&lt;?&gt; resultType, Number left, Number right)
            {
<span class="nc" id="L79">                return resultType.divide(left, right);</span>
            }
        },
<span class="fc" id="L82">        MODULO('%', &quot;_modulo&quot;)</span>
        {
            protected ByteBuffer executeOnNumerics(NumberType&lt;?&gt; resultType, Number left, Number right)
            {
<span class="nc" id="L86">                return resultType.mod(left, right);</span>
            }
        };

        /**
         * The operator symbol.
         */
        private final char symbol;

        /**
         * The name of the function associated to this operation
         */
        private final String functionName;

        private OPERATION(char symbol, String functionName)
<span class="fc" id="L101">        {</span>
<span class="fc" id="L102">            this.symbol = symbol;</span>
<span class="fc" id="L103">            this.functionName = functionName;</span>
<span class="fc" id="L104">        }</span>

        /**
         * Executes the operation between the specified numeric operand.
         *
         * @param resultType the result ype of the operation
         * @param left the left operand
         * @param right the right operand
         * @return the operation result
         */
        protected abstract ByteBuffer executeOnNumerics(NumberType&lt;?&gt; resultType, Number left, Number right);

        /**
         * Executes the operation on the specified temporal operand.
         *
         * @param type the temporal type
         * @param temporal the temporal value
         * @param duration the duration
         * @return the operation result
         */
        protected ByteBuffer executeOnTemporals(TemporalType&lt;?&gt; type, Number temporal, Duration duration)
        {
<span class="nc" id="L126">            throw new UnsupportedOperationException();</span>
        }

        /**
         * Executes the operation between the specified string operand.
         *
         * @param resultType the result type of the operation
         * @param left the left operand
         * @param right the right operand
         * @return the operation result
         */
        protected ByteBuffer excuteOnStrings(StringType resultType, String left, String right)
        {
<span class="nc" id="L139">            throw new UnsupportedOperationException();</span>
        }

        /**
         * Returns the {@code OPERATOR} associated to the specified function.
         * @param functionName the function name
         * @return the {@code OPERATOR} associated to the specified function
         */
        public static OPERATION fromFunctionName(String functionName)
        {
<span class="nc bnc" id="L149" title="All 2 branches missed.">            for (OPERATION operator : values())</span>
            {
<span class="nc bnc" id="L151" title="All 2 branches missed.">                if (operator.functionName.equals(functionName))</span>
<span class="nc" id="L152">                    return operator;</span>
            }
<span class="nc" id="L154">            return null;</span>
        }

        /**
         * Returns the {@code OPERATOR} with the specified symbol.
         *
         * @param symbol a symbol
         * @return the {@code OPERATOR} with the specified symbol
         */
        public static OPERATION fromSymbol(char symbol)
        {
<span class="nc bnc" id="L165" title="All 2 branches missed.">            for (OPERATION operator : values())</span>
            {
<span class="nc bnc" id="L167" title="All 2 branches missed.">                if (operator.symbol == symbol)</span>
<span class="nc" id="L168">                    return operator;</span>
            }
<span class="nc" id="L170">            return null;</span>
        }
    }

    /**
     * The name of the function used to perform negations
     */
    public static final String NEGATION_FUNCTION_NAME = &quot;_negate&quot;;

    public static void addFunctionsTo(NativeFunctions functions)
    {
<span class="fc" id="L181">        final NumberType&lt;?&gt;[] numericTypes = new NumberType[] { ByteType.instance,</span>
                                                                ShortType.instance,
                                                                Int32Type.instance,
                                                                LongType.instance,
                                                                FloatType.instance,
                                                                DoubleType.instance,
                                                                DecimalType.instance,
                                                                IntegerType.instance,
                                                                CounterColumnType.instance};

<span class="fc bfc" id="L191" title="All 2 branches covered.">        for (NumberType&lt;?&gt; left : numericTypes)</span>
        {
<span class="fc bfc" id="L193" title="All 2 branches covered.">            for (NumberType&lt;?&gt; right : numericTypes)</span>
            {
<span class="fc" id="L195">                NumberType&lt;?&gt; returnType = returnType(left, right);</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">                for (OPERATION operation : OPERATION.values())</span>
<span class="fc" id="L197">                    functions.add(new NumericOperationFunction(returnType, left, operation, right));</span>
            }
<span class="fc" id="L199">            functions.add(new NumericNegationFunction(left));</span>
        }

<span class="fc bfc" id="L202" title="All 2 branches covered.">        for (OPERATION operation : new OPERATION[] {OPERATION.ADDITION, OPERATION.SUBSTRACTION})</span>
        {
<span class="fc" id="L204">            functions.add(new TemporalOperationFunction(TimestampType.instance, operation));</span>
<span class="fc" id="L205">            functions.add(new TemporalOperationFunction(SimpleDateType.instance, operation));</span>
        }

<span class="fc" id="L208">        addStringConcatenations(functions);</span>
<span class="fc" id="L209">    }</span>

    private static void addStringConcatenations(NativeFunctions functions)
    {
<span class="fc" id="L213">        functions.add(new StringOperationFunction(UTF8Type.instance, UTF8Type.instance, OPERATION.ADDITION, UTF8Type.instance));</span>
<span class="fc" id="L214">        functions.add(new StringOperationFunction(AsciiType.instance, AsciiType.instance, OPERATION.ADDITION, AsciiType.instance));</span>
<span class="fc" id="L215">        functions.add(new StringOperationFunction(UTF8Type.instance, AsciiType.instance, OPERATION.ADDITION, UTF8Type.instance));</span>
<span class="fc" id="L216">        functions.add(new StringOperationFunction(UTF8Type.instance, UTF8Type.instance, OPERATION.ADDITION, AsciiType.instance));</span>
<span class="fc" id="L217">    }</span>

    /**
     * Checks if the function with the specified name is an operation.
     *
     * @param function the function name
     * @return {@code true} if the function is an operation, {@code false} otherwise.
     */
    public static boolean isOperation(FunctionName function)
    {
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">        return SchemaConstants.SYSTEM_KEYSPACE_NAME.equals(function.keyspace)</span>
<span class="pc bnc" id="L228" title="All 2 branches missed.">                &amp;&amp; OPERATION.fromFunctionName(function.name) != null;</span>
    }

    /**
     * Checks if the function with the specified name is a negation.
     *
     * @param function the function name
     * @return {@code true} if the function is an negation, {@code false} otherwise.
     */
    public static boolean isNegation(FunctionName function)
    {
<span class="nc bnc" id="L239" title="All 4 branches missed.">        return SchemaConstants.SYSTEM_KEYSPACE_NAME.equals(function.keyspace)&amp;&amp; NEGATION_FUNCTION_NAME.equals(function.name);</span>
    }

    /**
     * Returns the operator associated to the specified function.
     *
     * @return the operator associated to the specified function.
     */
    public static char getOperator(FunctionName function)
    {
<span class="nc bnc" id="L249" title="All 2 branches missed.">        assert SchemaConstants.SYSTEM_KEYSPACE_NAME.equals(function.keyspace);</span>
<span class="nc" id="L250">        return OPERATION.fromFunctionName(function.name).symbol;</span>
    }

    /**
     * Returns the name of the function associated to the specified operator.
     *
     * @param operator the operator
     * @return the name of the function associated to the specified operator
     */
    public static FunctionName getFunctionNameFromOperator(char operator)
    {
<span class="nc" id="L261">        return FunctionName.nativeFunction(OPERATION.fromSymbol(operator).functionName);</span>
    }

    /**
     * Determine the return type for an operation between the specified types.
     *
     * @param left the type of the left operand
     * @param right the type of the right operand
     * @return the return type for an operation between the specified types
     */
    private static NumberType&lt;?&gt; returnType(NumberType&lt;?&gt; left, NumberType&lt;?&gt; right)
    {
<span class="fc bfc" id="L273" title="All 4 branches covered.">        boolean isFloatingPoint = left.isFloatingPoint() || right.isFloatingPoint();</span>
<span class="fc" id="L274">        int size = Math.max(size(left), size(right));</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">        return isFloatingPoint</span>
<span class="fc" id="L276">             ? floatPointType(size)</span>
<span class="fc" id="L277">             : integerType(size);</span>
    }

    /**
     * Returns the number of bytes used to represent a value of this type.
     * @return the number of bytes used to represent a value of this type or {@code Integer.MAX} if the number of bytes
     * is not limited.
     */
    private static int size(NumberType&lt;?&gt; type)
    {
<span class="fc" id="L287">        int size = type.valueLengthIfFixed();</span>

<span class="fc bfc" id="L289" title="All 2 branches covered.">        if (size &gt; 0)</span>
<span class="fc" id="L290">            return size;</span>

        // tinyint and smallint type are not fixed length types even if they should be.
        // So we need to handle them in a special way.
<span class="fc bfc" id="L294" title="All 2 branches covered.">        if (type == ByteType.instance)</span>
<span class="fc" id="L295">            return 1;</span>

<span class="fc bfc" id="L297" title="All 2 branches covered.">        if (type == ShortType.instance)</span>
<span class="fc" id="L298">            return 2;</span>

<span class="fc bfc" id="L300" title="All 2 branches covered.">        if (type.isCounter())</span>
<span class="fc" id="L301">            return LongType.instance.valueLengthIfFixed();</span>

<span class="fc" id="L303">        return Integer.MAX_VALUE;</span>
    }

    private static NumberType&lt;?&gt; floatPointType(int size)
    {
<span class="fc bfc" id="L308" title="All 3 branches covered.">        switch (size)</span>
        {
<span class="fc" id="L310">            case 4: return FloatType.instance;</span>
<span class="fc" id="L311">            case 8: return DoubleType.instance;</span>
<span class="fc" id="L312">            default: return DecimalType.instance;</span>
        }
    }

    private static NumberType&lt;?&gt; integerType(int size)
    {
<span class="fc bfc" id="L318" title="All 5 branches covered.">        switch (size)</span>
        {
<span class="fc" id="L320">            case 1: return ByteType.instance;</span>
<span class="fc" id="L321">            case 2: return ShortType.instance;</span>
<span class="fc" id="L322">            case 4: return Int32Type.instance;</span>
<span class="fc" id="L323">            case 8: return LongType.instance;</span>
<span class="fc" id="L324">            default: return IntegerType.instance;</span>
        }
    }

    /**
     * The class must not be instantiated.
     */
    private OperationFcts()
    {
    }

    /**
     * Base class for functions that execute operations.
     */
    private static abstract class OperationFunction extends NativeScalarFunction
    {
        private final OPERATION operation;

        public OperationFunction(AbstractType&lt;?&gt; returnType,
                                 AbstractType&lt;?&gt; left,
                                 OPERATION operation,
                                 AbstractType&lt;?&gt; right)
        {
<span class="fc" id="L347">            super(operation.functionName, returnType, left, right);</span>
<span class="fc" id="L348">            this.operation = operation;</span>
<span class="fc" id="L349">        }</span>

        @Override
        public final String columnName(List&lt;String&gt; columnNames)
        {
<span class="nc" id="L354">            return String.format(&quot;%s %s %s&quot;, columnNames.get(0), getOperator(), columnNames.get(1));</span>
        }

        @Override
        public final ByteBuffer execute(Arguments arguments)
        {
<span class="nc bnc" id="L360" title="All 2 branches missed.">            if (arguments.containsNulls())</span>
<span class="nc" id="L361">                return null;</span>

            try
            {
<span class="nc" id="L365">                return doExecute(arguments.get(0), operation, arguments.get(1));</span>
            }
<span class="nc" id="L367">            catch (Exception e)</span>
            {
<span class="nc" id="L369">                throw OperationExecutionException.create(getOperator(), argTypes, e);</span>
            }
        }

        protected abstract ByteBuffer doExecute(Object left, OPERATION operation, Object right);

        /**
         * Returns the operator symbol.
         * @return the operator symbol
         */
        private char getOperator()
        {
<span class="nc" id="L381">            return operation.symbol;</span>
        }
    }

    /**
     * Function that execute operations on numbers.
     */
    private static class NumericOperationFunction extends OperationFunction
    {
        public NumericOperationFunction(NumberType&lt;?&gt; returnType,
                                        NumberType&lt;?&gt; left,
                                        OPERATION operation,
                                        NumberType&lt;?&gt; right)
        {
<span class="fc" id="L395">            super(returnType, left, operation, right);</span>
<span class="fc" id="L396">        }</span>

        @Override
        protected ByteBuffer doExecute(Object left, OPERATION operation, Object right)
        {
<span class="nc" id="L401">            NumberType&lt;?&gt; resultType = (NumberType&lt;?&gt;) returnType();</span>

<span class="nc" id="L403">            return operation.executeOnNumerics(resultType, (Number) left, (Number) right);</span>
        }
    }

    private static class StringOperationFunction extends OperationFunction
    {
        public StringOperationFunction(StringType returnType,
                                       StringType left,
                                       OPERATION operation,
                                       StringType right)
        {
<span class="fc" id="L414">            super(returnType, left, operation, right);</span>
<span class="fc" id="L415">        }</span>

        @Override
        protected ByteBuffer doExecute(Object left, OPERATION operation, Object right)
        {
<span class="nc" id="L420">            StringType resultType = (StringType) returnType();</span>

<span class="nc" id="L422">            return operation.excuteOnStrings(resultType, (String) left, (String) right);</span>
        }
    }

    /**
     * Function that execute operations on temporals (timestamp, date, ...).
     */
    private static class TemporalOperationFunction extends OperationFunction
    {
        public TemporalOperationFunction(TemporalType&lt;?&gt; type, OPERATION operation)
        {
<span class="fc" id="L433">            super(type, type, operation, DurationType.instance);</span>
<span class="fc" id="L434">        }</span>

        @Override
        protected ByteBuffer doExecute(Object left, OPERATION operation, Object right)
        {
<span class="nc" id="L439">            TemporalType&lt;?&gt; resultType = (TemporalType&lt;?&gt;) returnType();</span>
<span class="nc" id="L440">            return operation.executeOnTemporals(resultType, (Number) left, (Duration) right);</span>
        }
    }

    /**
     * Function that negate a number.
     */
    private static class NumericNegationFunction extends NativeScalarFunction
    {
        public NumericNegationFunction(NumberType&lt;?&gt; inputType)
        {
<span class="fc" id="L451">            super(NEGATION_FUNCTION_NAME, inputType, inputType);</span>
<span class="fc" id="L452">        }</span>

        @Override
        public final String columnName(List&lt;String&gt; columnNames)
        {
<span class="nc" id="L457">            return String.format(&quot;-%s&quot;, columnNames.get(0));</span>
        }

        @Override
        public final ByteBuffer execute(Arguments arguments)
        {
<span class="nc bnc" id="L463" title="All 2 branches missed.">            if (arguments.containsNulls())</span>
<span class="nc" id="L464">                return null;</span>

<span class="nc" id="L466">            NumberType&lt;?&gt; inputType = (NumberType&lt;?&gt;) argTypes().get(0);</span>

<span class="nc" id="L468">            return inputType.negate(arguments.get(0));</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>