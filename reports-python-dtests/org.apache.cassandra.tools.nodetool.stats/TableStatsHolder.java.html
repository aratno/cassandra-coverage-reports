<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TableStatsHolder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.tools.nodetool.stats</a> &gt; <span class="el_source">TableStatsHolder.java</span></div><h1>TableStatsHolder.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.tools.nodetool.stats;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.*;

import com.google.common.collect.ArrayListMultimap;

import javax.management.InstanceNotFoundException;

import org.apache.commons.lang3.time.DurationFormatUtils;

import org.apache.cassandra.db.*;
import org.apache.cassandra.db.compaction.TimeWindowCompactionStrategy;
import org.apache.cassandra.db.compaction.TimeWindowCompactionStrategyOptions;
import org.apache.cassandra.io.util.*;
import org.apache.cassandra.metrics.*;
import org.apache.cassandra.tools.*;

public class TableStatsHolder implements StatsHolder
{
    public final List&lt;StatsKeyspace&gt; keyspaces;
<span class="fc" id="L41">    public int numberOfTables = 0;</span>
    public final boolean humanReadable;
    public final String sortKey;
    public final int top;
    public final boolean locationCheck;

    public TableStatsHolder(NodeProbe probe, boolean humanReadable, boolean ignore, List&lt;String&gt; tableNames, String sortKey, int top, boolean locationCheck)
<span class="fc" id="L48">    {</span>
<span class="fc" id="L49">        this.keyspaces = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L50">        this.humanReadable = humanReadable;</span>
<span class="fc" id="L51">        this.sortKey = sortKey;</span>
<span class="fc" id="L52">        this.top = top;</span>
<span class="fc" id="L53">        this.locationCheck = locationCheck;</span>

<span class="pc bpc" id="L55" title="1 of 2 branches missed.">        if (!this.isTestTableStatsHolder())</span>
<span class="fc" id="L56">            this.initializeKeyspaces(probe, ignore, tableNames);</span>
<span class="fc" id="L57">    }</span>

    @Override
    public Map&lt;String, Object&gt; convert2Map()
    {
<span class="nc bnc" id="L62" title="All 2 branches missed.">        if (sortKey.isEmpty())</span>
<span class="nc" id="L63">            return convertAllToMap();</span>
        else
<span class="nc" id="L65">            return convertSortedFilteredSubsetToMap();</span>
    }

    /**
     * @returns Map&lt;String, Object&gt; a nested HashMap of keyspaces, their tables, and the tables' statistics.
     */
    private Map&lt;String, Object&gt; convertAllToMap()
    {
<span class="nc" id="L73">        HashMap&lt;String, Object&gt; mpRet = new HashMap&lt;&gt;();</span>
<span class="nc" id="L74">        mpRet.put(&quot;total_number_of_tables&quot;, numberOfTables);</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">        for (StatsKeyspace keyspace : keyspaces)</span>
        {
            // store each keyspace's metrics to map
<span class="nc" id="L78">            HashMap&lt;String, Object&gt; mpKeyspace = new HashMap&lt;&gt;();</span>
<span class="nc" id="L79">            mpKeyspace.put(&quot;read_latency&quot;, keyspace.readLatency());</span>
<span class="nc" id="L80">            mpKeyspace.put(&quot;read_count&quot;, keyspace.readCount);</span>
<span class="nc" id="L81">            mpKeyspace.put(&quot;read_latency_ms&quot;, keyspace.readLatency());</span>
<span class="nc" id="L82">            mpKeyspace.put(&quot;write_count&quot;, keyspace.writeCount);</span>
<span class="nc" id="L83">            mpKeyspace.put(&quot;write_latency_ms&quot;, keyspace.writeLatency());</span>
<span class="nc" id="L84">            mpKeyspace.put(&quot;pending_flushes&quot;, keyspace.pendingFlushes);</span>

            // store each table's metrics to map
<span class="nc" id="L87">            List&lt;StatsTable&gt; tables = keyspace.tables;</span>
<span class="nc" id="L88">            Map&lt;String, Map&lt;String, Object&gt;&gt; mpTables = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">            for (StatsTable table : tables)</span>
            {
<span class="nc" id="L91">                Map&lt;String, Object&gt; mpTable = convertStatsTableToMap(table);</span>
<span class="nc" id="L92">                mpTables.put(table.tableName, mpTable);</span>
<span class="nc" id="L93">            }</span>
<span class="nc" id="L94">            mpKeyspace.put(&quot;tables&quot;, mpTables);</span>
<span class="nc" id="L95">            mpRet.put(keyspace.name, mpKeyspace);</span>
<span class="nc" id="L96">        }</span>
<span class="nc" id="L97">        return mpRet;</span>
    }

    /**
     * @returns Map&lt;String, Object&gt; a nested HashMap of the sorted and filtered table names and the HashMaps of their statistics.
     */
    private Map&lt;String, Object&gt; convertSortedFilteredSubsetToMap()
    {
<span class="nc" id="L105">        HashMap&lt;String, Object&gt; mpRet = new HashMap&lt;&gt;();</span>
<span class="nc" id="L106">        mpRet.put(&quot;total_number_of_tables&quot;, numberOfTables);</span>
<span class="nc" id="L107">        List&lt;StatsTable&gt; sortedFilteredTables = getSortedFilteredTables();</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">        for (StatsTable table : sortedFilteredTables)</span>
        {
<span class="nc" id="L110">            String tableDisplayName = table.keyspaceName + &quot;.&quot; + table.tableName;</span>
<span class="nc" id="L111">            Map&lt;String, Object&gt; mpTable = convertStatsTableToMap(table);</span>
<span class="nc" id="L112">            mpRet.put(tableDisplayName, mpTable);</span>
<span class="nc" id="L113">        }</span>
<span class="nc" id="L114">        return mpRet;</span>
    }

    private Map&lt;String, Object&gt; convertStatsTableToMap(StatsTable table)
    {
<span class="nc" id="L119">        Map&lt;String, Object&gt; mpTable = new HashMap&lt;&gt;();</span>
<span class="nc" id="L120">        mpTable.put(&quot;sstable_count&quot;, table.sstableCount);</span>
<span class="nc" id="L121">        mpTable.put(&quot;old_sstable_count&quot;, table.oldSSTableCount);</span>
<span class="nc" id="L122">        mpTable.put(&quot;sstables_in_each_level&quot;, table.sstablesInEachLevel);</span>
<span class="nc" id="L123">        mpTable.put(&quot;sstable_bytes_in_each_level&quot;, table.sstableBytesInEachLevel);</span>
<span class="nc" id="L124">        mpTable.put(&quot;max_sstable_size&quot;, table.maxSSTableSize);</span>
<span class="nc" id="L125">        mpTable.put(&quot;twcs&quot;, table.twcs);</span>
<span class="nc" id="L126">        mpTable.put(&quot;space_used_live&quot;, table.spaceUsedLive);</span>
<span class="nc" id="L127">        mpTable.put(&quot;space_used_total&quot;, table.spaceUsedTotal);</span>
<span class="nc" id="L128">        mpTable.put(&quot;space_used_by_snapshots_total&quot;, table.spaceUsedBySnapshotsTotal);</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        if (table.offHeapUsed)</span>
<span class="nc" id="L130">            mpTable.put(&quot;off_heap_memory_used_total&quot;, table.offHeapMemoryUsedTotal);</span>
<span class="nc" id="L131">        mpTable.put(&quot;sstable_compression_ratio&quot;, table.sstableCompressionRatio);</span>
<span class="nc" id="L132">        mpTable.put(&quot;number_of_partitions_estimate&quot;, table.numberOfPartitionsEstimate);</span>
<span class="nc" id="L133">        mpTable.put(&quot;memtable_cell_count&quot;, table.memtableCellCount);</span>
<span class="nc" id="L134">        mpTable.put(&quot;memtable_data_size&quot;, table.memtableDataSize);</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (table.memtableOffHeapUsed)</span>
<span class="nc" id="L136">            mpTable.put(&quot;memtable_off_heap_memory_used&quot;, table.memtableOffHeapMemoryUsed);</span>
<span class="nc" id="L137">        mpTable.put(&quot;memtable_switch_count&quot;, table.memtableSwitchCount);</span>
<span class="nc" id="L138">        mpTable.put(&quot;speculative_retries&quot;, table.speculativeRetries);</span>
<span class="nc" id="L139">        mpTable.put(&quot;local_read_count&quot;, table.localReadCount);</span>
<span class="nc" id="L140">        mpTable.put(&quot;local_read_latency_ms&quot;, String.format(&quot;%01.3f&quot;, table.localReadLatencyMs));</span>
<span class="nc" id="L141">        mpTable.put(&quot;local_write_count&quot;, table.localWriteCount);</span>
<span class="nc" id="L142">        mpTable.put(&quot;local_write_latency_ms&quot;, String.format(&quot;%01.3f&quot;, table.localWriteLatencyMs));</span>
<span class="nc" id="L143">        mpTable.put(&quot;local_read_write_ratio&quot;, String.format(&quot;%01.5f&quot;, table.localReadWriteRatio));</span>
<span class="nc" id="L144">        mpTable.put(&quot;pending_flushes&quot;, table.pendingFlushes);</span>
<span class="nc" id="L145">        mpTable.put(&quot;percent_repaired&quot;, table.percentRepaired);</span>
<span class="nc" id="L146">        mpTable.put(&quot;bytes_repaired&quot;, table.bytesRepaired);</span>
<span class="nc" id="L147">        mpTable.put(&quot;bytes_unrepaired&quot;, table.bytesUnrepaired);</span>
<span class="nc" id="L148">        mpTable.put(&quot;bytes_pending_repair&quot;, table.bytesPendingRepair);</span>
<span class="nc" id="L149">        mpTable.put(&quot;bloom_filter_false_positives&quot;, table.bloomFilterFalsePositives);</span>
<span class="nc" id="L150">        mpTable.put(&quot;bloom_filter_false_ratio&quot;, String.format(&quot;%01.5f&quot;, table.bloomFilterFalseRatio));</span>
<span class="nc" id="L151">        mpTable.put(&quot;bloom_filter_space_used&quot;, table.bloomFilterSpaceUsed);</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">        if (table.bloomFilterOffHeapUsed)</span>
<span class="nc" id="L153">            mpTable.put(&quot;bloom_filter_off_heap_memory_used&quot;, table.bloomFilterOffHeapMemoryUsed);</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">        if (table.indexSummaryOffHeapUsed)</span>
<span class="nc" id="L155">            mpTable.put(&quot;index_summary_off_heap_memory_used&quot;, table.indexSummaryOffHeapMemoryUsed);</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">        if (table.compressionMetadataOffHeapUsed)</span>
<span class="nc" id="L157">            mpTable.put(&quot;compression_metadata_off_heap_memory_used&quot;,</span>
                        table.compressionMetadataOffHeapMemoryUsed);
<span class="nc" id="L159">        mpTable.put(&quot;compacted_partition_minimum_bytes&quot;, table.compactedPartitionMinimumBytes);</span>
<span class="nc" id="L160">        mpTable.put(&quot;compacted_partition_maximum_bytes&quot;, table.compactedPartitionMaximumBytes);</span>
<span class="nc" id="L161">        mpTable.put(&quot;compacted_partition_mean_bytes&quot;, table.compactedPartitionMeanBytes);</span>
<span class="nc" id="L162">        mpTable.put(&quot;average_live_cells_per_slice_last_five_minutes&quot;,</span>
<span class="nc" id="L163">                    table.averageLiveCellsPerSliceLastFiveMinutes);</span>
<span class="nc" id="L164">        mpTable.put(&quot;maximum_live_cells_per_slice_last_five_minutes&quot;,</span>
<span class="nc" id="L165">                    table.maximumLiveCellsPerSliceLastFiveMinutes);</span>
<span class="nc" id="L166">        mpTable.put(&quot;average_tombstones_per_slice_last_five_minutes&quot;,</span>
<span class="nc" id="L167">                    table.averageTombstonesPerSliceLastFiveMinutes);</span>
<span class="nc" id="L168">        mpTable.put(&quot;maximum_tombstones_per_slice_last_five_minutes&quot;,</span>
<span class="nc" id="L169">                    table.maximumTombstonesPerSliceLastFiveMinutes);</span>
<span class="nc" id="L170">        mpTable.put(&quot;droppable_tombstone_ratio&quot;,</span>
<span class="nc" id="L171">                    String.format(&quot;%01.5f&quot;, table.droppableTombstoneRatio));</span>
<span class="nc" id="L172">        mpTable.put(&quot;top_size_partitions&quot;, table.topSizePartitions);</span>
<span class="nc" id="L173">        mpTable.put(&quot;top_tombstone_partitions&quot;, table.topTombstonePartitions);</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (locationCheck)</span>
<span class="nc" id="L175">            mpTable.put(&quot;sstables_in_correct_location&quot;, table.isInCorrectLocation);</span>
<span class="nc" id="L176">        return mpTable;</span>
    }

    private void initializeKeyspaces(NodeProbe probe, boolean ignore, List&lt;String&gt; tableNames)
    {
<span class="fc" id="L181">        OptionFilter filter = new OptionFilter(ignore, tableNames);</span>
<span class="fc" id="L182">        ArrayListMultimap&lt;String, ColumnFamilyStoreMBean&gt; selectedTableMbeans = ArrayListMultimap.create();</span>
<span class="fc" id="L183">        Map&lt;String, StatsKeyspace&gt; keyspaceStats = new HashMap&lt;&gt;();</span>

        // get a list of table stores
<span class="fc" id="L186">        Iterator&lt;Map.Entry&lt;String, ColumnFamilyStoreMBean&gt;&gt; tableMBeans = probe.getColumnFamilyStoreMBeanProxies();</span>

<span class="fc bfc" id="L188" title="All 2 branches covered.">        while (tableMBeans.hasNext())</span>
        {
<span class="fc" id="L190">            Map.Entry&lt;String, ColumnFamilyStoreMBean&gt; entry = tableMBeans.next();</span>
<span class="fc" id="L191">            String keyspaceName = entry.getKey();</span>
<span class="fc" id="L192">            ColumnFamilyStoreMBean tableProxy = entry.getValue();</span>

<span class="pc bpc" id="L194" title="1 of 2 branches missed.">            if (filter.isKeyspaceIncluded(keyspaceName))</span>
            {
<span class="fc" id="L196">                StatsKeyspace stats = keyspaceStats.get(keyspaceName);</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">                if (stats == null)</span>
                {
<span class="fc" id="L199">                    stats = new StatsKeyspace(probe, keyspaceName);</span>
<span class="fc" id="L200">                    keyspaceStats.put(keyspaceName, stats);</span>
                }
<span class="fc" id="L202">                stats.add(tableProxy);</span>

<span class="pc bpc" id="L204" title="1 of 2 branches missed.">                if (filter.isTableIncluded(keyspaceName, tableProxy.getTableName()))</span>
<span class="fc" id="L205">                    selectedTableMbeans.put(keyspaceName, tableProxy);</span>
            }
<span class="fc" id="L207">        }</span>

<span class="fc" id="L209">        numberOfTables = selectedTableMbeans.size();</span>

        // make sure all specified keyspace and tables exist
<span class="fc" id="L212">        filter.verifyKeyspaces(probe.getKeyspaces());</span>
<span class="fc" id="L213">        filter.verifyTables();</span>

        // get metrics of keyspace
<span class="fc bfc" id="L216" title="All 2 branches covered.">        for (Map.Entry&lt;String, Collection&lt;ColumnFamilyStoreMBean&gt;&gt; entry : selectedTableMbeans.asMap().entrySet())</span>
        {
<span class="fc" id="L218">            String keyspaceName = entry.getKey();</span>
<span class="fc" id="L219">            Collection&lt;ColumnFamilyStoreMBean&gt; tables = entry.getValue();</span>
<span class="fc" id="L220">            StatsKeyspace statsKeyspace = keyspaceStats.get(keyspaceName);</span>

            // get metrics of table statistics for this keyspace
<span class="fc bfc" id="L223" title="All 2 branches covered.">            for (ColumnFamilyStoreMBean table : tables)</span>
            {
<span class="fc" id="L225">                String tableName = table.getTableName();</span>
<span class="fc" id="L226">                StatsTable statsTable = new StatsTable();</span>
<span class="fc" id="L227">                statsTable.fullName = keyspaceName + &quot;.&quot; + tableName;</span>
<span class="fc" id="L228">                statsTable.keyspaceName = keyspaceName;</span>
<span class="fc" id="L229">                statsTable.tableName = tableName;</span>
<span class="fc" id="L230">                statsTable.isIndex = tableName.contains(&quot;.&quot;);</span>
<span class="fc" id="L231">                statsTable.sstableCount = probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;LiveSSTableCount&quot;);</span>
<span class="fc" id="L232">                statsTable.oldSSTableCount = probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;OldVersionSSTableCount&quot;);</span>
<span class="fc" id="L233">                Long sstableSize = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;MaxSSTableSize&quot;);</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">                statsTable.maxSSTableSize = sstableSize == null ? 0 : sstableSize;</span>

<span class="fc" id="L236">                int[] leveledSStables = table.getSSTableCountPerLevel();</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">                if (leveledSStables != null)</span>
                {
<span class="fc" id="L239">                    statsTable.isLeveledSstable = true;</span>

<span class="fc bfc" id="L241" title="All 2 branches covered.">                    for (int level = 0; level &lt; leveledSStables.length; level++)</span>
                    {
<span class="fc" id="L243">                        int count = leveledSStables[level];</span>
<span class="fc" id="L244">                        long maxCount = 4L; // for L0</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">                        if (level &gt; 0)</span>
<span class="fc" id="L246">                            maxCount = (long) Math.pow(table.getLevelFanoutSize(), level);</span>
                        // show max threshold for level when exceeded
<span class="fc bfc" id="L248" title="All 2 branches covered.">                        statsTable.sstablesInEachLevel.add(count + ((count &gt; maxCount) ? &quot;/&quot; + maxCount : &quot;&quot;));</span>
                    }
                }
<span class="fc" id="L251">                statsTable.sstableCountPerTWCSBucket = table.getSSTableCountPerTWCSBucket();</span>

<span class="fc" id="L253">                long[] leveledSSTablesBytes = table.getPerLevelSizeBytes();</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">                if (leveledSSTablesBytes != null)</span>
                {
<span class="fc" id="L256">                    statsTable.isLeveledSstable = true;</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">                    for (int level = 0; level &lt; leveledSSTablesBytes.length; level++)</span>
                    {
<span class="fc" id="L259">                        long size = leveledSSTablesBytes[level];</span>
<span class="fc" id="L260">                        statsTable.sstableBytesInEachLevel.add(format(size, humanReadable));</span>
                    }
                }

<span class="pc bpc" id="L264" title="1 of 2 branches missed.">                if (locationCheck)</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">                    statsTable.isInCorrectLocation = !table.hasMisplacedSSTables();</span>

<span class="fc" id="L267">                Long memtableOffHeapSize = null;</span>
<span class="fc" id="L268">                Long bloomFilterOffHeapSize = null;</span>
<span class="fc" id="L269">                Long indexSummaryOffHeapSize = null;</span>
<span class="fc" id="L270">                Long compressionMetadataOffHeapSize = null;</span>
<span class="fc" id="L271">                Long offHeapSize = null;</span>
<span class="fc" id="L272">                Double percentRepaired = null;</span>
<span class="fc" id="L273">                Long bytesRepaired = null;</span>
<span class="fc" id="L274">                Long bytesUnrepaired = null;</span>
<span class="fc" id="L275">                Long bytesPendingRepair = null;</span>

                try
                {
<span class="fc" id="L279">                    memtableOffHeapSize = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;MemtableOffHeapSize&quot;);</span>
<span class="fc" id="L280">                    bloomFilterOffHeapSize = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;BloomFilterOffHeapMemoryUsed&quot;);</span>
<span class="fc" id="L281">                    indexSummaryOffHeapSize = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;IndexSummaryOffHeapMemoryUsed&quot;);</span>
<span class="fc" id="L282">                    compressionMetadataOffHeapSize = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;CompressionMetadataOffHeapMemoryUsed&quot;);</span>
<span class="fc" id="L283">                    offHeapSize = memtableOffHeapSize + bloomFilterOffHeapSize + indexSummaryOffHeapSize + compressionMetadataOffHeapSize;</span>
<span class="fc" id="L284">                    percentRepaired = (Double) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;PercentRepaired&quot;);</span>
<span class="fc" id="L285">                    bytesRepaired = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;BytesRepaired&quot;);</span>
<span class="fc" id="L286">                    bytesUnrepaired = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;BytesUnrepaired&quot;);</span>
<span class="fc" id="L287">                    bytesPendingRepair = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;BytesPendingRepair&quot;);</span>
                }
<span class="nc" id="L289">                catch (RuntimeException e)</span>
                {
                    // offheap-metrics introduced in 2.1.3 - older versions do not have the appropriate mbeans
<span class="nc bnc" id="L292" title="All 2 branches missed.">                    if (!(e.getCause() instanceof InstanceNotFoundException))</span>
<span class="nc" id="L293">                        throw e;</span>
<span class="fc" id="L294">                }</span>

<span class="fc" id="L296">                statsTable.spaceUsedLive = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;LiveDiskSpaceUsed&quot;), humanReadable);</span>
<span class="fc" id="L297">                statsTable.spaceUsedTotal = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;TotalDiskSpaceUsed&quot;), humanReadable);</span>
<span class="fc" id="L298">                statsTable.spaceUsedBySnapshotsTotal = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;SnapshotsSize&quot;), humanReadable);</span>

<span class="fc" id="L300">                maybeAddTWCSWindowWithMaxDuration(statsTable, probe, keyspaceName, tableName);</span>

<span class="pc bpc" id="L302" title="1 of 2 branches missed.">                if (offHeapSize != null)</span>
                {
<span class="fc" id="L304">                    statsTable.offHeapUsed = true;</span>
<span class="fc" id="L305">                    statsTable.offHeapMemoryUsedTotal = format(offHeapSize, humanReadable);</span>

                }
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">                if (percentRepaired != null)</span>
                {
<span class="fc" id="L310">                    statsTable.percentRepaired = Math.round(100 * percentRepaired) / 100.0;</span>
                }

<span class="pc bpc" id="L313" title="1 of 2 branches missed.">                statsTable.bytesRepaired = bytesRepaired != null ? bytesRepaired : 0;</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">                statsTable.bytesUnrepaired = bytesUnrepaired != null ? bytesUnrepaired : 0;</span>
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">                statsTable.bytesPendingRepair = bytesPendingRepair != null ? bytesPendingRepair : 0;</span>

<span class="fc" id="L317">                statsTable.sstableCompressionRatio = probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;CompressionRatio&quot;);</span>
<span class="fc" id="L318">                Object estimatedPartitionCount = probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;EstimatedPartitionCount&quot;);</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">                if (Long.valueOf(-1L).equals(estimatedPartitionCount))</span>
                {
<span class="fc" id="L321">                    estimatedPartitionCount = 0L;</span>
                }
<span class="fc" id="L323">                statsTable.numberOfPartitionsEstimate = estimatedPartitionCount;</span>

<span class="fc" id="L325">                statsTable.memtableCellCount = probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;MemtableColumnsCount&quot;);</span>
<span class="fc" id="L326">                statsTable.memtableDataSize = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;MemtableLiveDataSize&quot;), humanReadable);</span>
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">                if (memtableOffHeapSize != null)</span>
                {
<span class="fc" id="L329">                    statsTable.memtableOffHeapUsed = true;</span>
<span class="fc" id="L330">                    statsTable.memtableOffHeapMemoryUsed = format(memtableOffHeapSize, humanReadable);</span>
                }
<span class="fc" id="L332">                statsTable.memtableSwitchCount = probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;MemtableSwitchCount&quot;);</span>
<span class="fc" id="L333">                statsTable.speculativeRetries = probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;SpeculativeRetries&quot;);</span>
<span class="fc" id="L334">                statsTable.localReadCount = ((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;ReadLatency&quot;)).getCount();</span>

<span class="fc" id="L336">                double localReadLatency = ((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;ReadLatency&quot;)).getMean() / 1000;</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">                double localRLatency = localReadLatency &gt; 0 ? localReadLatency : Double.NaN;</span>
<span class="fc" id="L338">                statsTable.localReadLatencyMs = localRLatency;</span>
<span class="fc" id="L339">                statsTable.localWriteCount = ((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;WriteLatency&quot;)).getCount();</span>

<span class="fc" id="L341">                double localWriteLatency = ((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;WriteLatency&quot;)).getMean() / 1000;</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">                double localWLatency = localWriteLatency &gt; 0 ? localWriteLatency : Double.NaN;</span>

<span class="fc bfc" id="L344" title="All 2 branches covered.">                statsTable.localReadWriteRatio = statsTable.localWriteCount &gt; 0 ? statsTable.localReadCount / (double) statsTable.localWriteCount : 0;</span>

<span class="fc" id="L346">                statsTable.localWriteLatencyMs = localWLatency;</span>
<span class="fc" id="L347">                statsTable.pendingFlushes = probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;PendingFlushes&quot;);</span>

<span class="fc" id="L349">                statsTable.bloomFilterFalsePositives = probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;BloomFilterFalsePositives&quot;);</span>
<span class="fc" id="L350">                statsTable.bloomFilterFalseRatio = probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;RecentBloomFilterFalseRatio&quot;);</span>
<span class="fc" id="L351">                statsTable.bloomFilterSpaceUsed = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;BloomFilterDiskSpaceUsed&quot;), humanReadable);</span>

<span class="pc bpc" id="L353" title="1 of 2 branches missed.">                if (bloomFilterOffHeapSize != null)</span>
                {
<span class="fc" id="L355">                    statsTable.bloomFilterOffHeapUsed = true;</span>
<span class="fc" id="L356">                    statsTable.bloomFilterOffHeapMemoryUsed = format(bloomFilterOffHeapSize, humanReadable);</span>
                }

<span class="pc bpc" id="L359" title="1 of 2 branches missed.">                if (indexSummaryOffHeapSize != null)</span>
                {
<span class="fc" id="L361">                    statsTable.indexSummaryOffHeapUsed = true;</span>
<span class="fc" id="L362">                    statsTable.indexSummaryOffHeapMemoryUsed = format(indexSummaryOffHeapSize, humanReadable);</span>
                }
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">                if (compressionMetadataOffHeapSize != null)</span>
                {
<span class="fc" id="L366">                    statsTable.compressionMetadataOffHeapUsed = true;</span>
<span class="fc" id="L367">                    statsTable.compressionMetadataOffHeapMemoryUsed = format(compressionMetadataOffHeapSize, humanReadable);</span>
                }
<span class="fc" id="L369">                statsTable.compactedPartitionMinimumBytes = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;MinPartitionSize&quot;);</span>
<span class="fc" id="L370">                statsTable.compactedPartitionMaximumBytes = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;MaxPartitionSize&quot;);</span>
<span class="fc" id="L371">                statsTable.compactedPartitionMeanBytes = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;MeanPartitionSize&quot;);</span>

<span class="fc" id="L373">                CassandraMetricsRegistry.JmxHistogramMBean histogram = (CassandraMetricsRegistry.JmxHistogramMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;LiveScannedHistogram&quot;);</span>
<span class="fc" id="L374">                statsTable.averageLiveCellsPerSliceLastFiveMinutes = histogram.getMean();</span>
<span class="fc" id="L375">                statsTable.maximumLiveCellsPerSliceLastFiveMinutes = histogram.getMax();</span>

<span class="fc" id="L377">                histogram = (CassandraMetricsRegistry.JmxHistogramMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;TombstoneScannedHistogram&quot;);</span>
<span class="fc" id="L378">                statsTable.averageTombstonesPerSliceLastFiveMinutes = histogram.getMean();</span>
<span class="fc" id="L379">                statsTable.maximumTombstonesPerSliceLastFiveMinutes = histogram.getMax();</span>
<span class="fc" id="L380">                statsTable.droppableTombstoneRatio = probe.getDroppableTombstoneRatio(keyspaceName, tableName);</span>
<span class="fc" id="L381">                statsTable.topSizePartitions = format(table.getTopSizePartitions(), humanReadable);</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">                if (table.getTopSizePartitionsLastUpdate() != null)</span>
<span class="fc" id="L383">                    statsTable.topSizePartitionsLastUpdate = millisToDateString(table.getTopSizePartitionsLastUpdate());</span>
<span class="fc" id="L384">                statsTable.topTombstonePartitions = table.getTopTombstonePartitions();</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">                if (table.getTopTombstonePartitionsLastUpdate() != null)</span>
<span class="fc" id="L386">                    statsTable.topTombstonePartitionsLastUpdate = millisToDateString(table.getTopTombstonePartitionsLastUpdate());</span>

<span class="fc" id="L388">                statsKeyspace.tables.add(statsTable);</span>
<span class="fc" id="L389">            }</span>
<span class="fc" id="L390">            keyspaces.add(statsKeyspace);</span>
<span class="fc" id="L391">        }</span>
<span class="fc" id="L392">    }</span>

    private void maybeAddTWCSWindowWithMaxDuration(StatsTable statsTable, NodeProbe probe, String keyspaceName, String tableName)
    {
<span class="fc" id="L396">        Map&lt;String, String&gt; compactionParameters = probe.getCfsProxy(statsTable.keyspaceName, statsTable.tableName)</span>
<span class="fc" id="L397">                                                        .getCompactionParameters();</span>

<span class="pc bpc" id="L399" title="1 of 2 branches missed.">        if (compactionParameters == null)</span>
<span class="nc" id="L400">            return;</span>

<span class="fc" id="L402">        String compactor = compactionParameters.get(&quot;class&quot;);</span>

<span class="pc bpc" id="L404" title="1 of 4 branches missed.">        if (compactor == null || !compactor.endsWith(TimeWindowCompactionStrategy.class.getSimpleName()))</span>
<span class="fc" id="L405">            return;</span>

<span class="fc" id="L407">        String unit = compactionParameters.get(TimeWindowCompactionStrategyOptions.COMPACTION_WINDOW_UNIT_KEY);</span>
<span class="fc" id="L408">        String size = compactionParameters.get(TimeWindowCompactionStrategyOptions.COMPACTION_WINDOW_SIZE_KEY);</span>

<span class="fc" id="L410">        statsTable.twcsDurationInMillis = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, &quot;MaxSSTableDuration&quot;);</span>
<span class="fc" id="L411">        String maxDuration = millisToDuration(statsTable.twcsDurationInMillis);</span>
<span class="fc" id="L412">        statsTable.twcs = String.format(&quot;%s %s, max duration: %s&quot;, size, unit, maxDuration);</span>
<span class="fc" id="L413">    }</span>

    private String format(long bytes, boolean humanReadable)
    {
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">        return humanReadable ? FileUtils.stringifyFileSize(bytes) : Long.toString(bytes);</span>
    }

    private Map&lt;String, String&gt; format(Map&lt;String, Long&gt; map, boolean humanReadable)
    {
<span class="fc" id="L422">        LinkedHashMap&lt;String, String&gt; retMap = new LinkedHashMap&lt;&gt;();</span>
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">        for (Map.Entry&lt;String, Long&gt; entry : map.entrySet())</span>
<span class="nc" id="L424">            retMap.put(entry.getKey(), format(entry.getValue(), humanReadable));</span>
<span class="fc" id="L425">        return retMap;</span>
    }

    private String millisToDateString(long millis)
    {
<span class="fc" id="L430">        TimeZone tz = TimeZone.getTimeZone(&quot;UTC&quot;);</span>
<span class="fc" id="L431">        DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;);</span>
<span class="fc" id="L432">        df.setTimeZone(tz);</span>
<span class="fc" id="L433">        return df.format(new Date(millis));</span>
    }

    private String millisToDuration(long millis)
    {
<span class="fc" id="L438">        return DurationFormatUtils.formatDurationWords(millis, true, true);</span>
    }

    /**
     * Sort and filter this TableStatHolder's tables as specified by its sortKey and top attributes.
     */
    public List&lt;StatsTable&gt; getSortedFilteredTables() {
<span class="nc" id="L445">        List&lt;StatsTable&gt; tables = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">        for (StatsKeyspace keyspace : keyspaces)</span>
<span class="nc" id="L447">            tables.addAll(keyspace.tables);</span>
<span class="nc" id="L448">        Collections.sort(tables, new StatsTableComparator(sortKey, humanReadable));</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">        int k = (tables.size() &gt;= top) ? top : tables.size();</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">        if (k &gt; 0)</span>
<span class="nc" id="L451">            tables = tables.subList(0, k);</span>
<span class="nc" id="L452">        return tables;</span>
    }

    protected boolean isTestTableStatsHolder() {
<span class="fc" id="L456">        return false;</span>
    }

    /**
     * Used for filtering keyspaces and tables to be displayed using the tablestats command.
     */
    private static class OptionFilter
    {
<span class="fc" id="L464">        private final Map&lt;String, List&lt;String&gt;&gt; filter = new HashMap&lt;&gt;();</span>
<span class="fc" id="L465">        private final Map&lt;String, List&lt;String&gt;&gt; verifier = new HashMap&lt;&gt;(); // Same as filter initially, but we remove tables every time we've checked them for inclusion</span>
        // in isTableIncluded() so that we detect if those table requested don't exist (verifyTables())
<span class="fc" id="L467">        private final List&lt;String&gt; filterList = new ArrayList&lt;&gt;();</span>
        private final boolean ignoreMode;

        OptionFilter(boolean ignoreMode, List&lt;String&gt; filterList)
<span class="fc" id="L471">        {</span>
<span class="fc" id="L472">            this.filterList.addAll(filterList);</span>
<span class="fc" id="L473">            this.ignoreMode = ignoreMode;</span>

<span class="pc bpc" id="L475" title="1 of 2 branches missed.">            for (String s : filterList)</span>
            {
<span class="nc" id="L477">                String[] keyValues = s.split(&quot;\\.&quot;, 2);</span>

                // build the map that stores the keyspaces and tables to use
<span class="nc bnc" id="L480" title="All 2 branches missed.">                if (!filter.containsKey(keyValues[0]))</span>
                {
<span class="nc" id="L482">                    filter.put(keyValues[0], new ArrayList&lt;&gt;());</span>
<span class="nc" id="L483">                    verifier.put(keyValues[0], new ArrayList&lt;&gt;());</span>
                }

<span class="nc bnc" id="L486" title="All 2 branches missed.">                if (keyValues.length == 2)</span>
                {
<span class="nc" id="L488">                    filter.get(keyValues[0]).add(keyValues[1]);</span>
<span class="nc" id="L489">                    verifier.get(keyValues[0]).add(keyValues[1]);</span>
                }
<span class="nc" id="L491">            }</span>
<span class="fc" id="L492">        }</span>

        public boolean isTableIncluded(String keyspace, String table)
        {
            // supplying empty params list is treated as wanting to display all keyspaces and tables
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">            if (filterList.isEmpty())</span>
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">                return !ignoreMode;</span>

<span class="nc" id="L500">            List&lt;String&gt; tables = filter.get(keyspace);</span>

            // no such keyspace is in the map
<span class="nc bnc" id="L503" title="All 2 branches missed.">            if (tables == null)</span>
<span class="nc" id="L504">                return ignoreMode;</span>
                // only a keyspace with no tables was supplied
                // so ignore or include (based on the flag) every column family in specified keyspace
<span class="nc bnc" id="L507" title="All 2 branches missed.">            else if (tables.isEmpty())</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">                return !ignoreMode;</span>

            // keyspace exists, and it contains specific table
<span class="nc" id="L511">            verifier.get(keyspace).remove(table);</span>
<span class="nc" id="L512">            return ignoreMode ^ tables.contains(table);</span>
        }

        public boolean isKeyspaceIncluded(String keyspace)
        {
            // supplying empty params list is treated as wanting to display all keyspaces and tables
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">            if (filterList.isEmpty())</span>
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">                return !ignoreMode;</span>

            // Note that if there is any table for the keyspace, we want to include the keyspace irregarding
            // of the ignoreMode, since the ignoreMode then apply to the table inside the keyspace but the
            // keyspace itself is not ignored
<span class="nc bnc" id="L524" title="All 4 branches missed.">            return filter.get(keyspace) != null || ignoreMode;</span>
        }

        public void verifyKeyspaces(Collection&lt;String&gt; keyspaces)
        {
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">            for (String ks : verifier.keySet())</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">                if (!keyspaces.contains(ks))</span>
<span class="nc" id="L531">                    throw new IllegalArgumentException(&quot;Unknown keyspace: &quot; + ks);</span>
<span class="fc" id="L532">        }</span>

        public void verifyTables()
        {
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">            for (String ks : filter.keySet())</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">                if (!verifier.get(ks).isEmpty())</span>
<span class="nc" id="L538">                    throw new IllegalArgumentException(&quot;Unknown tables: &quot; + verifier.get(ks) + &quot; in keyspace: &quot; + ks);</span>
<span class="fc" id="L539">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>