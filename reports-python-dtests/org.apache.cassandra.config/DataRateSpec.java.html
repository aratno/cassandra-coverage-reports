<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataRateSpec.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.config</a> &gt; <span class="el_source">DataRateSpec.java</span></div><h1>DataRateSpec.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.config;

import java.util.Arrays;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import com.google.common.math.DoubleMath;
import com.google.common.primitives.Ints;

import static org.apache.cassandra.config.DataRateSpec.DataRateUnit.BYTES_PER_SECOND;

/**
 * Represents a data rate type used for cassandra configuration. It supports the opportunity for the users to be able to
 * add units to the confiuration parameter value. (CASSANDRA-15234)
 */
public abstract class DataRateSpec
{
    /**
     * The Regexp used to parse the rate provided as String in cassandra.yaml.
     */
<span class="fc" id="L40">    private static final Pattern UNITS_PATTERN = Pattern.compile(&quot;^(\\d+)(MiB/s|KiB/s|B/s)$&quot;);</span>

    private final long quantity;

    private final DataRateUnit unit;

    private DataRateSpec(String value)
<span class="fc" id="L47">    {</span>
        //parse the string field value
<span class="fc" id="L49">        Matcher matcher = UNITS_PATTERN.matcher(value);</span>

<span class="pc bpc" id="L51" title="1 of 2 branches missed.">        if (!matcher.find())</span>
<span class="nc" id="L52">            throw new IllegalArgumentException(&quot;Invalid data rate: &quot; + value + &quot; Accepted units: MiB/s, KiB/s, B/s where &quot; +</span>
                                                &quot;case matters and &quot; + &quot;only non-negative values are valid&quot;);

<span class="fc" id="L55">        quantity = Long.parseLong(matcher.group(1));</span>
<span class="fc" id="L56">        unit = DataRateUnit.fromSymbol(matcher.group(2));</span>
<span class="fc" id="L57">    }</span>

    private DataRateSpec(String value, DataRateUnit minUnit, long max)
    {
<span class="fc" id="L61">        this(value);</span>

<span class="fc" id="L63">        validateQuantity(value, quantity(), unit(), minUnit, max);</span>
<span class="fc" id="L64">    }</span>

    private DataRateSpec(long quantity, DataRateUnit unit, DataRateUnit minUnit, long max)
<span class="fc" id="L67">    {</span>
<span class="fc" id="L68">        this.quantity = quantity;</span>
<span class="fc" id="L69">        this.unit = unit;</span>

<span class="fc" id="L71">        validateQuantity(quantity, unit, minUnit, max);</span>
<span class="fc" id="L72">    }</span>

    private static void validateQuantity(String value, double quantity, DataRateUnit unit, DataRateUnit minUnit, long max)
    {
        // negatives are not allowed by the regex pattern
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">        if (minUnit.convert(quantity, unit) &gt;= max)</span>
<span class="nc" id="L78">            throw new IllegalArgumentException(&quot;Invalid data rate: &quot; + value + &quot;. It shouldn't be more than &quot; +</span>
<span class="nc" id="L79">                                             (max - 1) + &quot; in &quot; + minUnit.name().toLowerCase());</span>
<span class="fc" id="L80">    }</span>

    private static void validateQuantity(double quantity, DataRateUnit unit, DataRateUnit minUnit, long max)
    {
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">        if (quantity &lt; 0)</span>
<span class="nc" id="L85">            throw new IllegalArgumentException(&quot;Invalid data rate: value must be non-negative&quot;);</span>

<span class="pc bpc" id="L87" title="1 of 2 branches missed.">        if (minUnit.convert(quantity, unit) &gt;= max)</span>
<span class="nc" id="L88">            throw new IllegalArgumentException(String.format(&quot;Invalid data rate: %s %s. It shouldn't be more than %d in %s&quot;,</span>
<span class="nc" id="L89">                                                       quantity, unit.name().toLowerCase(),</span>
<span class="nc" id="L90">                                                       max - 1, minUnit.name().toLowerCase()));</span>
<span class="fc" id="L91">    }</span>

    // get vs no-get prefix is not consistent in the code base, but for classes involved with config parsing, it is
    // imporant to be explicit about get/set as this changes how parsing is done; this class is a data-type, so is
    // not nested, having get/set can confuse parsing thinking this is a nested type
    /**
     * @return the data rate unit assigned.
     */
    public DataRateUnit unit()
    {
<span class="fc" id="L101">        return unit;</span>
    }

    /**
     * @return the data rate quantity.
     */
    private double quantity()
    {
<span class="fc" id="L109">        return quantity;</span>
    }

    /**
     * @return the data rate in bytes per second
     */
    public double toBytesPerSecond()
    {
<span class="fc" id="L117">        return unit.toBytesPerSecond(quantity);</span>
    }

    /**
     * Returns the data rate in bytes per second as an {@code int}
     *
     * @return the data rate in bytes per second or {@code Integer.MAX_VALUE} if the rate is too large.
     */
    public int toBytesPerSecondAsInt()
    {
<span class="fc" id="L127">        return Ints.saturatedCast(Math.round(toBytesPerSecond()));</span>
    }

    /**
     * @return the data rate in kibibytes per second
     */
    public double toKibibytesPerSecond()
    {
<span class="nc" id="L135">        return unit.toKibibytesPerSecond(quantity);</span>
    }

    /**
     * Returns the data rate in kibibytes per second as an {@code int}
     *
     * @return the data rate in kibibytes per second or {@code Integer.MAX_VALUE} if the number of kibibytes is too large.
     */
    public int toKibibytesPerSecondAsInt()
    {
<span class="nc" id="L145">        return Ints.saturatedCast(Math.round(toKibibytesPerSecond()));</span>
    }

    /**
     * @return the data rate in mebibytes per second
     */
    public double toMebibytesPerSecond()
    {
<span class="fc" id="L153">        return unit.toMebibytesPerSecond(quantity);</span>
    }

    /**
     * Returns the data rate in mebibytes per second as an {@code int}
     *
     * @return the data rate in mebibytes per second or {@code Integer.MAX_VALUE} if the number of mebibytes is too large.
     */
    public int toMebibytesPerSecondAsInt()
    {
<span class="nc" id="L163">        return Ints.saturatedCast(Math.round(toMebibytesPerSecond()));</span>
    }

    /**
     * This method is required in order to support backward compatibility with the old unit used for a few Data Rate
     * parameters before CASSANDRA-15234
     *
     * @return the data rate in megabits per second.
     */
    public double toMegabitsPerSecond()
    {
<span class="fc" id="L174">        return unit.toMegabitsPerSecond(quantity);</span>
    }

    /**
     * Returns the data rate in megabits per second as an {@code int}. This method is required in order to support
     * backward compatibility with the old unit used for a few Data Rate parameters before CASSANDRA-15234
     *
     * @return the data rate in mebibytes per second or {@code Integer.MAX_VALUE} if the number of mebibytes is too large.
     */
    public int toMegabitsPerSecondAsInt()
    {
<span class="nc" id="L185">        return Ints.saturatedCast(Math.round(toMegabitsPerSecond()));</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L191">        return Objects.hash(unit.toKibibytesPerSecond(quantity));</span>
    }

    @Override
    public boolean equals(Object obj)
    {
<span class="nc bnc" id="L197" title="All 2 branches missed.">        if (this == obj)</span>
<span class="nc" id="L198">            return true;</span>

<span class="nc bnc" id="L200" title="All 2 branches missed.">        if (!(obj instanceof DataRateSpec))</span>
<span class="nc" id="L201">            return false;</span>

<span class="nc" id="L203">        DataRateSpec other = (DataRateSpec) obj;</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (unit == other.unit)</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">            return quantity == other.quantity;</span>

        // Due to overflows we can only guarantee that the 2 data rates are equal if we get the same results
        // doing the conversion in both directions.
<span class="nc bnc" id="L209" title="All 4 branches missed.">        return unit.convert(other.quantity, other.unit) == quantity &amp;&amp; other.unit.convert(quantity, unit) == other.quantity;</span>
    }

    @Override
    public String toString()
    {
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">        return (DoubleMath.isMathematicalInteger(quantity) ? (long) quantity : quantity) + unit.symbol;</span>
    }

    /**
     * Represents a data rate used for Cassandra configuration. The bound is [0, Long.MAX_VALUE) in bytes per second.
     * If the user sets a different unit, we still validate that converted to bytes per second the quantity will not exceed
     * that upper bound. (CASSANDRA-17571)
     */
    public final static class LongBytesPerSecondBound extends DataRateSpec
    {
        /**
         * Creates a {@code DataRateSpec.LongBytesPerSecondBound} of the specified amount.
         *
         * @param value the data rate
         */
        public LongBytesPerSecondBound(String value)
        {
<span class="fc" id="L232">            super(value, BYTES_PER_SECOND, Long.MAX_VALUE);</span>
<span class="fc" id="L233">        }</span>

        /**
         * Creates a {@code DataRateSpec.LongBytesPerSecondBound} of the specified amount in the specified unit.
         *
         * @param quantity where quantity shouldn't be bigger than Long.MAX_VALUE - 1 in bytes per second
         * @param unit     in which the provided quantity is
         */
        public LongBytesPerSecondBound(long quantity, DataRateUnit unit)
        {
<span class="fc" id="L243">            super(quantity, unit, BYTES_PER_SECOND, Long.MAX_VALUE);</span>
<span class="fc" id="L244">        }</span>

        /**
         * Creates a {@code DataRateSpec.LongBytesPerSecondBound} of the specified amount in bytes per second.
         *
         * @param bytesPerSecond where bytesPerSecond shouldn't be bigger than Long.MAX_VALUE
         */
        public LongBytesPerSecondBound(long bytesPerSecond)
        {
<span class="fc" id="L253">            this(bytesPerSecond, BYTES_PER_SECOND);</span>
<span class="fc" id="L254">        }</span>

        // this one should be used only for backward compatibility for stream_throughput_outbound and inter_dc_stream_throughput_outbound
        // which were in megabits per second in 4.0. Do not start using it for any new properties
        @Deprecated
        public static LongBytesPerSecondBound megabitsPerSecondInBytesPerSecond(long megabitsPerSecond)
        {
<span class="fc" id="L261">            final long BYTES_PER_MEGABIT = 125_000;</span>
<span class="fc" id="L262">            long bytesPerSecond = megabitsPerSecond * BYTES_PER_MEGABIT;</span>

<span class="pc bpc" id="L264" title="1 of 2 branches missed.">            if (megabitsPerSecond &gt;= Integer.MAX_VALUE)</span>
<span class="nc" id="L265">                throw new IllegalArgumentException(&quot;Invalid data rate: &quot; + megabitsPerSecond + &quot; megabits per second; &quot; +</span>
                                                   &quot;stream_throughput_outbound and inter_dc_stream_throughput_outbound&quot; +
                                                   &quot; should be between 0 and &quot; + (Integer.MAX_VALUE - 1) + &quot; in megabits per second&quot;);

<span class="fc" id="L269">            return new LongBytesPerSecondBound(bytesPerSecond, BYTES_PER_SECOND);</span>
        }
    }

<span class="fc" id="L273">    public enum DataRateUnit</span>
    {
<span class="fc" id="L275">        BYTES_PER_SECOND(&quot;B/s&quot;)</span>
        {
            public double toBytesPerSecond(double d)
            {
<span class="fc" id="L279">                return d;</span>
            }

            public double toKibibytesPerSecond(double d)
            {
<span class="nc" id="L284">                return d / 1024.0;</span>
            }

            public double toMebibytesPerSecond(double d)
            {
<span class="nc" id="L289">                return d / (1024.0 * 1024.0);</span>
            }

            public double toMegabitsPerSecond(double d)
            {
<span class="fc" id="L294">                return (d / 125000.0);</span>
            }

            public double convert(double source, DataRateUnit sourceUnit)
            {
<span class="fc" id="L299">                return sourceUnit.toBytesPerSecond(source);</span>
            }
        },
<span class="fc" id="L302">        KIBIBYTES_PER_SECOND(&quot;KiB/s&quot;)</span>
        {
            public double toBytesPerSecond(double d)
            {
<span class="nc" id="L306">                return x(d, 1024.0, (MAX / 1024.0));</span>
            }

            public double toKibibytesPerSecond(double d)
            {
<span class="nc" id="L311">                return d;</span>
            }

            public double toMebibytesPerSecond(double d)
            {
<span class="nc" id="L316">                return d / 1024.0;</span>
            }

            public double toMegabitsPerSecond(double d)
            {
<span class="nc" id="L321">                return d / 122.0;</span>
            }

            public double convert(double source, DataRateUnit sourceUnit)
            {
<span class="nc" id="L326">                return sourceUnit.toKibibytesPerSecond(source);</span>
            }
        },
<span class="fc" id="L329">        MEBIBYTES_PER_SECOND(&quot;MiB/s&quot;)</span>
        {
            public double toBytesPerSecond(double d)
            {
<span class="fc" id="L333">                return x(d, (1024.0 * 1024.0), (MAX / (1024.0 * 1024.0)));</span>
            }

            public double toKibibytesPerSecond(double d)
            {
<span class="nc" id="L338">                return x(d, 1024.0, (MAX / 1024.0));</span>
            }

            public double toMebibytesPerSecond(double d)
            {
<span class="fc" id="L343">                return d;</span>
            }

            public double toMegabitsPerSecond(double d)
            {
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">                if (d &gt; MAX / (MEGABITS_PER_MEBIBYTE))</span>
<span class="nc" id="L349">                    return MAX;</span>
<span class="fc" id="L350">                return d * MEGABITS_PER_MEBIBYTE;</span>
            }

            public double convert(double source, DataRateUnit sourceUnit)
            {
<span class="nc" id="L355">                return sourceUnit.toMebibytesPerSecond(source);</span>
            }
        };

        static final double MAX = Long.MAX_VALUE;
        static final double MEGABITS_PER_MEBIBYTE = 8.388608;

        /**
         * Scale d by m, checking for overflow. This has a short name to make above code more readable.
         */
        static double x(double d, double m, double over)
        {
<span class="pc bpc" id="L367" title="3 of 6 branches missed.">            assert (over &gt; 0.0) &amp;&amp; (over &lt; (MAX - 1)) &amp;&amp; (over == (MAX / m));</span>

<span class="pc bpc" id="L369" title="1 of 2 branches missed.">            if (d &gt; over)</span>
<span class="nc" id="L370">                return MAX;</span>
<span class="fc" id="L371">            return d * m;</span>
        }

        /**
         * @param symbol the unit symbol
         * @return the rate unit corresponding to the given symbol
         */
        public static DataRateUnit fromSymbol(String symbol)
        {
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">            for (DataRateUnit value : values())</span>
            {
<span class="fc bfc" id="L382" title="All 2 branches covered.">                if (value.symbol.equalsIgnoreCase(symbol))</span>
<span class="fc" id="L383">                    return value;</span>
            }
<span class="nc" id="L385">            throw new IllegalArgumentException(String.format(&quot;Unsupported data rate unit: %s. Supported units are: %s&quot;,</span>
<span class="nc" id="L386">                                                             symbol, Arrays.stream(values())</span>
<span class="nc" id="L387">                                                                           .map(u -&gt; u.symbol)</span>
<span class="nc" id="L388">                                                                           .collect(Collectors.joining(&quot;, &quot;))));</span>
        }

        /**
         * The unit symbol
         */
        private final String symbol;

        DataRateUnit(String symbol)
<span class="fc" id="L397">        {</span>
<span class="fc" id="L398">            this.symbol = symbol;</span>
<span class="fc" id="L399">        }</span>

        public double toBytesPerSecond(double d)
        {
<span class="nc" id="L403">            throw new AbstractMethodError();</span>
        }

        public double toKibibytesPerSecond(double d)
        {
<span class="nc" id="L408">            throw new AbstractMethodError();</span>
        }

        public double toMebibytesPerSecond(double d)
        {
<span class="nc" id="L413">            throw new AbstractMethodError();</span>
        }

        public double toMegabitsPerSecond(double d)
        {
<span class="nc" id="L418">            throw new AbstractMethodError();</span>
        }

        public double convert(double source, DataRateUnit sourceUnit)
        {
<span class="nc" id="L423">            throw new AbstractMethodError();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>