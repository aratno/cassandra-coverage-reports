<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ColumnSubselection.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.filter</a> &gt; <span class="el_source">ColumnSubselection.java</span></div><h1>ColumnSubselection.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.filter;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Comparator;

import org.apache.cassandra.db.TypeSizes;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.marshal.CollectionType;
import org.apache.cassandra.db.marshal.UTF8Type;
import org.apache.cassandra.db.rows.CellPath;
import org.apache.cassandra.exceptions.UnknownColumnException;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.utils.ByteBufferUtil;

/**
 * Handles the selection of a subpart of a column.
 * &lt;p&gt;
 * This only make sense for complex column. For those, this allow for instance
 * to select only a slice of a map.
 */
public abstract class ColumnSubselection implements Comparable&lt;ColumnSubselection&gt;
{
<span class="fc" id="L44">    public static final Serializer serializer = new Serializer();</span>

    /* this enum is used in serialization; preserve order for compatibility */
<span class="fc" id="L47">    private enum Kind { SLICE, ELEMENT }</span>

    protected final ColumnMetadata column;

    protected ColumnSubselection(ColumnMetadata column)
<span class="fc" id="L52">    {</span>
<span class="fc" id="L53">        this.column = column;</span>
<span class="fc" id="L54">    }</span>

    public static ColumnSubselection slice(ColumnMetadata column, CellPath from, CellPath to)
    {
<span class="nc bnc" id="L58" title="All 4 branches missed.">        assert column.isComplex() &amp;&amp; column.type instanceof CollectionType;</span>
<span class="nc bnc" id="L59" title="All 4 branches missed.">        assert from.size() &lt;= 1 &amp;&amp; to.size() &lt;= 1;</span>
<span class="nc" id="L60">        return new Slice(column, from, to);</span>
    }

    public static ColumnSubselection element(ColumnMetadata column, CellPath elt)
    {
<span class="pc bpc" id="L65" title="2 of 4 branches missed.">        assert column.isComplex() &amp;&amp; column.type instanceof CollectionType;</span>
<span class="pc bpc" id="L66" title="1 of 2 branches missed.">        assert elt.size() == 1;</span>
<span class="fc" id="L67">        return new Element(column, elt);</span>
    }

    public ColumnMetadata column()
    {
<span class="fc" id="L72">        return column;</span>
    }

    protected abstract Kind kind();

    protected abstract CellPath comparisonPath();

    public int compareTo(ColumnSubselection other)
    {
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">        assert other.column().name.equals(column().name);</span>
<span class="fc" id="L82">        return column().cellPathComparator().compare(comparisonPath(), other.comparisonPath());</span>
    }

    /**
     * Given a path, return -1 if the path is before anything selected by this subselection, 0 if it is selected by this
     * subselection and 1 if the path is after anything selected by this subselection.
     */
    public abstract int compareInclusionOf(CellPath path);

    @Override
    public String toString()
    {
<span class="nc" id="L94">        return toString(false);</span>
    }

    protected abstract String toString(boolean cql);

    private static class Slice extends ColumnSubselection
    {
        private final CellPath from;
        private final CellPath to;

        private Slice(ColumnMetadata column, CellPath from, CellPath to)
        {
<span class="nc" id="L106">            super(column);</span>
<span class="nc" id="L107">            this.from = from;</span>
<span class="nc" id="L108">            this.to = to;</span>
<span class="nc" id="L109">        }</span>

        protected Kind kind()
        {
<span class="nc" id="L113">            return Kind.SLICE;</span>
        }

        public CellPath comparisonPath()
        {
<span class="nc" id="L118">            return from;</span>
        }

        public int compareInclusionOf(CellPath path)
        {
<span class="nc" id="L123">            Comparator&lt;CellPath&gt; cmp = column.cellPathComparator();</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">            if (cmp.compare(path, from) &lt; 0)</span>
<span class="nc" id="L125">                return -1;</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">            else if (cmp.compare(to, path) &lt; 0)</span>
<span class="nc" id="L127">                return 1;</span>
            else
<span class="nc" id="L129">                return 0;</span>
        }

        @Override
        protected String toString(boolean cql)
        {
            // This assert we're dealing with a collection since that's the only thing it's used for so far.
<span class="nc" id="L136">            AbstractType&lt;?&gt; type = ((CollectionType&lt;?&gt;)column().type).nameComparator();</span>
<span class="nc" id="L137">            return String.format(&quot;[%s:%s]&quot;,</span>
<span class="nc bnc" id="L138" title="All 4 branches missed.">                                 from == CellPath.BOTTOM ? &quot;&quot; : (cql ? type.toCQLString(from.get(0)) : type.getString(from.get(0))),</span>
<span class="nc bnc" id="L139" title="All 4 branches missed.">                                 to == CellPath.TOP ? &quot;&quot; : (cql ? type.toCQLString(to.get(0)) : type.getString(to.get(0))));</span>
        }
    }

    private static class Element extends ColumnSubselection
    {
        private final CellPath element;

        private Element(ColumnMetadata column, CellPath elt)
        {
<span class="fc" id="L149">            super(column);</span>
<span class="fc" id="L150">            this.element = elt;</span>
<span class="fc" id="L151">        }</span>

        protected Kind kind()
        {
<span class="fc" id="L155">            return Kind.ELEMENT;</span>
        }

        public CellPath comparisonPath()
        {
<span class="fc" id="L160">            return element;</span>
        }

        public int compareInclusionOf(CellPath path)
        {
<span class="nc" id="L165">            return column.cellPathComparator().compare(path, element);</span>
        }

        @Override
        protected String toString(boolean cql)
        {
            // This assert we're dealing with a collection since that's the only thing it's used for so far.
<span class="fc" id="L172">            AbstractType&lt;?&gt; type = ((CollectionType&lt;?&gt;)column().type).nameComparator();</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">            return String.format(&quot;[%s]&quot;, cql ? type.toCQLString(element.get(0)) : type.getString(element.get(0)));</span>
        }
    }

<span class="fc" id="L177">    public static class Serializer</span>
    {
        public void serialize(ColumnSubselection subSel, DataOutputPlus out, int version) throws IOException
        {
<span class="fc" id="L181">            ColumnMetadata column = subSel.column();</span>
<span class="fc" id="L182">            ByteBufferUtil.writeWithShortLength(column.name.bytes, out);</span>
<span class="fc" id="L183">            out.writeByte(subSel.kind().ordinal());</span>
<span class="pc bpc" id="L184" title="2 of 3 branches missed.">            switch (subSel.kind())</span>
            {
                case SLICE:
<span class="nc" id="L187">                    Slice slice = (Slice)subSel;</span>
<span class="nc" id="L188">                    column.cellPathSerializer().serialize(slice.from, out);</span>
<span class="nc" id="L189">                    column.cellPathSerializer().serialize(slice.to, out);</span>
<span class="nc" id="L190">                    break;</span>
                case ELEMENT:
<span class="fc" id="L192">                    Element eltSelection = (Element)subSel;</span>
<span class="fc" id="L193">                    column.cellPathSerializer().serialize(eltSelection.element, out);</span>
<span class="fc" id="L194">                    break;</span>
                default:
<span class="nc" id="L196">                    throw new AssertionError();</span>
            }
<span class="fc" id="L198">        }</span>

        public ColumnSubselection deserialize(DataInputPlus in, int version, TableMetadata metadata) throws IOException
        {
<span class="fc" id="L202">            ByteBuffer name = ByteBufferUtil.readWithShortLength(in);</span>
<span class="fc" id="L203">            ColumnMetadata column = metadata.getColumn(name);</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">            if (column == null)</span>
            {
                // If we don't find the definition, it could be we have data for a dropped column, and we shouldn't
                // fail deserialization because of that. So we grab a &quot;fake&quot; ColumnMetadata that ensure proper
                // deserialization. The column will be ignored later on anyway.
<span class="nc" id="L209">                column = metadata.getDroppedColumn(name);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">                if (column == null)</span>
                {
<span class="nc" id="L212">                    String errorMsg = String.format(&quot;Unknown column %s in table %s.%s during deserialization&quot;,</span>
<span class="nc" id="L213">                                                    UTF8Type.instance.getString(name), metadata.keyspace, metadata.name);</span>
<span class="nc" id="L214">                    throw new UnknownColumnException(errorMsg);</span>
                }
            }

<span class="fc" id="L218">            Kind kind = Kind.values()[in.readUnsignedByte()];</span>
<span class="pc bpc" id="L219" title="2 of 3 branches missed.">            switch (kind)</span>
            {
                case SLICE:
<span class="nc" id="L222">                    CellPath from = column.cellPathSerializer().deserialize(in);</span>
<span class="nc" id="L223">                    CellPath to = column.cellPathSerializer().deserialize(in);</span>
<span class="nc" id="L224">                    return new Slice(column, from, to);</span>
                case ELEMENT:
<span class="fc" id="L226">                    CellPath elt = column.cellPathSerializer().deserialize(in);</span>
<span class="fc" id="L227">                    return new Element(column, elt);</span>
            }
<span class="nc" id="L229">            throw new AssertionError();</span>
        }

        public long serializedSize(ColumnSubselection subSel, int version)
        {
<span class="fc" id="L234">            long size = 0;</span>

<span class="fc" id="L236">            ColumnMetadata column = subSel.column();</span>
<span class="fc" id="L237">            size += TypeSizes.sizeofWithShortLength(column.name.bytes);</span>
<span class="fc" id="L238">            size += 1; // kind</span>
<span class="pc bpc" id="L239" title="2 of 3 branches missed.">            switch (subSel.kind())</span>
            {
                case SLICE:
<span class="nc" id="L242">                    Slice slice = (Slice)subSel;</span>
<span class="nc" id="L243">                    size += column.cellPathSerializer().serializedSize(slice.from);</span>
<span class="nc" id="L244">                    size += column.cellPathSerializer().serializedSize(slice.to);</span>
<span class="nc" id="L245">                    break;</span>
                case ELEMENT:
<span class="fc" id="L247">                    Element element = (Element)subSel;</span>
<span class="fc" id="L248">                    size += column.cellPathSerializer().serializedSize(element.element);</span>
                    break;
            }
<span class="fc" id="L251">            return size;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>