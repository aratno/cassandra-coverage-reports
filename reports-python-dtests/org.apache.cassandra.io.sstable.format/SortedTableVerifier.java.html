<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SortedTableVerifier.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.io.sstable.format</a> &gt; <span class="el_source">SortedTableVerifier.java</span></div><h1>SortedTableVerifier.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.io.sstable.format;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.function.Function;
import java.util.function.LongPredicate;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Throwables;
import com.google.common.collect.ImmutableSet;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.compaction.CompactionController;
import org.apache.cassandra.db.compaction.CompactionInfo;
import org.apache.cassandra.db.compaction.CompactionInterruptedException;
import org.apache.cassandra.db.compaction.CompactionManager;
import org.apache.cassandra.db.compaction.OperationType;
import org.apache.cassandra.db.rows.UnfilteredRowIterator;
import org.apache.cassandra.dht.LocalPartitioner;
import org.apache.cassandra.dht.Range;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.io.sstable.CorruptSSTableException;
import org.apache.cassandra.io.sstable.IVerifier;
import org.apache.cassandra.io.sstable.KeyIterator;
import org.apache.cassandra.io.sstable.KeyReader;
import org.apache.cassandra.io.sstable.SSTableIdentityIterator;
import org.apache.cassandra.io.sstable.metadata.MetadataType;
import org.apache.cassandra.io.util.DataIntegrityMetadata;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.io.util.RandomAccessReader;
import org.apache.cassandra.service.ActiveRepairService;
import org.apache.cassandra.service.StorageService;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.IFilter;
import org.apache.cassandra.utils.OutputHandler;
import org.apache.cassandra.utils.TimeUUID;

public abstract class SortedTableVerifier&lt;R extends SSTableReaderWithFilter&gt; implements IVerifier
{
<span class="fc" id="L69">    private final static Logger logger = LoggerFactory.getLogger(SortedTableVerifier.class);</span>

    protected final ColumnFamilyStore cfs;
    protected final R sstable;

    protected final ReadWriteLock fileAccessLock;
    protected final RandomAccessReader dataFile;
    protected final VerifyInfo verifyInfo;
    protected final Options options;
    protected final boolean isOffline;

    /**
     * Given a keyspace, return the set of local and pending token ranges.  By default {@link StorageService#getLocalAndPendingRanges(String)}
     * is expected, but for the standalone verifier case we can't use that, so this is here to allow the CLI to provide
     * the token ranges.
     */
    protected final Function&lt;String, ? extends Collection&lt;Range&lt;Token&gt;&gt;&gt; tokenLookup;
    protected int goodRows;

    protected final OutputHandler outputHandler;

    public SortedTableVerifier(ColumnFamilyStore cfs, R sstable, OutputHandler outputHandler, boolean isOffline, Options options)
<span class="fc" id="L91">    {</span>
<span class="fc" id="L92">        this.cfs = cfs;</span>
<span class="fc" id="L93">        this.sstable = sstable;</span>
<span class="fc" id="L94">        this.outputHandler = outputHandler;</span>

<span class="fc" id="L96">        this.fileAccessLock = new ReentrantReadWriteLock();</span>
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">        this.dataFile = isOffline</span>
<span class="fc" id="L98">                        ? sstable.openDataReader()</span>
<span class="pc" id="L99">                        : sstable.openDataReader(CompactionManager.instance.getRateLimiter());</span>
<span class="fc" id="L100">        this.verifyInfo = new VerifyInfo(dataFile, sstable, fileAccessLock.readLock());</span>
<span class="fc" id="L101">        this.options = options;</span>
<span class="fc" id="L102">        this.isOffline = isOffline;</span>
<span class="fc" id="L103">        this.tokenLookup = options.tokenLookup;</span>
<span class="fc" id="L104">    }</span>

    protected void deserializeBloomFilter(SSTableReader sstable) throws IOException
    {
<span class="fc" id="L108">        try (IFilter filter = FilterComponent.load(sstable.descriptor)) {</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">            if (filter != null)</span>
<span class="fc" id="L110">                logger.trace(&quot;Filter loaded for {}&quot;, sstable);</span>
        }
<span class="fc" id="L112">    }</span>

    public CompactionInfo.Holder getVerifyInfo()
    {
<span class="nc" id="L116">        return verifyInfo;</span>
    }

    protected void markAndThrow(Throwable cause)
    {
<span class="nc" id="L121">        markAndThrow(cause, true);</span>
<span class="nc" id="L122">    }</span>

    protected void markAndThrow(Throwable cause, boolean mutateRepaired)
    {
<span class="pc bpc" id="L126" title="2 of 4 branches missed.">        if (mutateRepaired &amp;&amp; options.mutateRepairStatus) // if we are able to mutate repaired flag, an incremental repair should be enough</span>
        {
            try
            {
<span class="nc" id="L130">                sstable.mutateRepairedAndReload(ActiveRepairService.UNREPAIRED_SSTABLE, sstable.getPendingRepair(), sstable.isTransient());</span>
<span class="nc" id="L131">                cfs.getTracker().notifySSTableRepairedStatusChanged(Collections.singleton(sstable));</span>
            }
<span class="nc" id="L133">            catch (IOException ioe)</span>
            {
<span class="nc" id="L135">                outputHandler.output(&quot;Error mutating repairedAt for SSTable %s, as part of markAndThrow&quot;, sstable.getFilename());</span>
<span class="nc" id="L136">            }</span>
        }
<span class="pc bpc" id="L138" title="2 of 4 branches missed.">        Exception e = new Exception(String.format(&quot;Invalid SSTable %s, please force %srepair&quot;, sstable.getFilename(), (mutateRepaired &amp;&amp; options.mutateRepairStatus) ? &quot;&quot; : &quot;a full &quot;), cause);</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">        if (options.invokeDiskFailurePolicy)</span>
<span class="nc" id="L140">            throw new CorruptSSTableException(e, sstable.getFilename());</span>
        else
<span class="fc" id="L142">            throw new RuntimeException(e);</span>
    }

    public void verify()
    {
<span class="fc" id="L147">        verifySSTableVersion();</span>

<span class="fc" id="L149">        verifySSTableMetadata();</span>

<span class="fc" id="L151">        verifyIndex();</span>

<span class="fc" id="L153">        verifyBloomFilter();</span>

<span class="pc bpc" id="L155" title="5 of 6 branches missed.">        if (options.checkOwnsTokens &amp;&amp; !isOffline &amp;&amp; !(cfs.getPartitioner() instanceof LocalPartitioner))</span>
        {
<span class="nc bnc" id="L157" title="All 2 branches missed.">            if (verifyOwnedRanges() == 0)</span>
<span class="nc" id="L158">                return;</span>
        }

<span class="pc bpc" id="L161" title="1 of 2 branches missed.">        if (options.quick)</span>
<span class="nc" id="L162">            return;</span>

<span class="pc bpc" id="L164" title="2 of 4 branches missed.">        if (verifyDigest() &amp;&amp; !options.extendedVerification)</span>
<span class="fc" id="L165">            return;</span>

<span class="nc" id="L167">        verifySSTable();</span>

<span class="nc" id="L169">        outputHandler.output(&quot;Verify of %s succeeded. All %d rows read successfully&quot;, sstable, goodRows);</span>
<span class="nc" id="L170">    }</span>

    protected void verifyBloomFilter()
    {
        try
        {
<span class="fc" id="L176">            outputHandler.debug(&quot;Deserializing bloom filter for %s&quot;, sstable);</span>
<span class="fc" id="L177">            deserializeBloomFilter(sstable);</span>
        }
<span class="nc" id="L179">        catch (Throwable t)</span>
        {
<span class="nc" id="L181">            outputHandler.warn(t);</span>
<span class="nc" id="L182">            markAndThrow(t);</span>
<span class="fc" id="L183">        }</span>
<span class="fc" id="L184">    }</span>

    protected void verifySSTableMetadata()
    {
<span class="fc" id="L188">        outputHandler.output(&quot;Deserializing sstable metadata for %s &quot;, sstable);</span>
        try
        {
<span class="fc" id="L191">            StatsComponent statsComponent = StatsComponent.load(sstable.descriptor, MetadataType.VALIDATION, MetadataType.STATS, MetadataType.HEADER);</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">            if (statsComponent.validationMetadata() != null &amp;&amp;</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">                !statsComponent.validationMetadata().partitioner.equals(sstable.getPartitioner().getClass().getCanonicalName()))</span>
<span class="nc" id="L194">                throw new IOException(&quot;Partitioner does not match validation metadata&quot;);</span>
        }
<span class="nc" id="L196">        catch (Throwable t)</span>
        {
<span class="nc" id="L198">            outputHandler.warn(t);</span>
<span class="nc" id="L199">            markAndThrow(t, false);</span>
<span class="fc" id="L200">        }</span>
<span class="fc" id="L201">    }</span>

    protected void verifySSTableVersion()
    {
<span class="fc" id="L205">        outputHandler.output(&quot;Verifying %s (%s)&quot;, sstable, FBUtilities.prettyPrintMemory(dataFile.length()));</span>
<span class="pc bpc" id="L206" title="3 of 4 branches missed.">        if (options.checkVersion &amp;&amp; !sstable.descriptor.version.isLatestVersion())</span>
        {
<span class="nc" id="L208">            String msg = String.format(&quot;%s is not the latest version, run upgradesstables&quot;, sstable);</span>
<span class="nc" id="L209">            outputHandler.output(msg);</span>
            // don't use markAndThrow here because we don't want a CorruptSSTableException for this.
<span class="nc" id="L211">            throw new RuntimeException(msg);</span>
        }
<span class="fc" id="L213">    }</span>

    protected int verifyOwnedRanges()
    {
<span class="nc" id="L217">        List&lt;Range&lt;Token&gt;&gt; ownedRanges = Collections.emptyList();</span>
<span class="nc" id="L218">        outputHandler.debug(&quot;Checking that all tokens are owned by the current node&quot;);</span>
<span class="nc" id="L219">        try (KeyIterator iter = sstable.keyIterator())</span>
        {
<span class="nc" id="L221">            ownedRanges = Range.normalize(tokenLookup.apply(cfs.metadata.keyspace));</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">            if (ownedRanges.isEmpty())</span>
<span class="nc" id="L223">                return 0;</span>
<span class="nc" id="L224">            RangeOwnHelper rangeOwnHelper = new RangeOwnHelper(ownedRanges);</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">            while (iter.hasNext())</span>
            {
<span class="nc" id="L227">                DecoratedKey key = iter.next();</span>
<span class="nc" id="L228">                rangeOwnHelper.validate(key);</span>
<span class="nc" id="L229">            }</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">        }</span>
<span class="nc" id="L231">        catch (Throwable t)</span>
        {
<span class="nc" id="L233">            outputHandler.warn(t);</span>
<span class="nc" id="L234">            markAndThrow(t);</span>
<span class="nc" id="L235">        }</span>

<span class="nc" id="L237">        return ownedRanges.size();</span>
    }

    protected boolean verifyDigest()
    {
<span class="fc" id="L242">        boolean passed = true;</span>
        // Verify will use the Digest files, which works for both compressed and uncompressed sstables
<span class="fc" id="L244">        outputHandler.output(&quot;Checking computed hash of %s &quot;, sstable);</span>
        try
        {
<span class="fc" id="L247">            DataIntegrityMetadata.FileDigestValidator validator = sstable.maybeGetDigestValidator();</span>

<span class="pc bpc" id="L249" title="1 of 2 branches missed.">            if (validator != null)</span>
            {
<span class="fc" id="L251">                validator.validate();</span>
            }
            else
            {
<span class="nc" id="L255">                outputHandler.output(&quot;Data digest missing, assuming extended verification of disk values&quot;);</span>
<span class="nc" id="L256">                passed = false;</span>
            }
        }
<span class="fc" id="L259">        catch (IOException e)</span>
        {
<span class="fc" id="L261">            outputHandler.warn(e);</span>
<span class="nc" id="L262">            markAndThrow(e);</span>
<span class="fc" id="L263">        }</span>
<span class="fc" id="L264">        return passed;</span>
    }

    protected void verifySSTable()
    {
<span class="nc" id="L269">        outputHandler.output(&quot;Extended Verify requested, proceeding to inspect values&quot;);</span>

<span class="nc" id="L271">        try (VerifyController verifyController = new VerifyController(cfs);</span>
<span class="nc" id="L272">             KeyReader indexIterator = sstable.keyReader())</span>
        {
<span class="nc bnc" id="L274" title="All 2 branches missed.">            if (indexIterator.dataPosition() != 0)</span>
<span class="nc" id="L275">                markAndThrow(new RuntimeException(&quot;First row position from index != 0: &quot; + indexIterator.dataPosition()));</span>

<span class="nc bnc" id="L277" title="All 2 branches missed.">            List&lt;Range&lt;Token&gt;&gt; ownedRanges = isOffline ? Collections.emptyList() : Range.normalize(tokenLookup.apply(cfs.metadata().keyspace));</span>
<span class="nc" id="L278">            RangeOwnHelper rangeOwnHelper = new RangeOwnHelper(ownedRanges);</span>
<span class="nc" id="L279">            DecoratedKey prevKey = null;</span>

<span class="nc bnc" id="L281" title="All 2 branches missed.">            while (!dataFile.isEOF())</span>
            {

<span class="nc bnc" id="L284" title="All 2 branches missed.">                if (verifyInfo.isStopRequested())</span>
<span class="nc" id="L285">                    throw new CompactionInterruptedException(verifyInfo.getCompactionInfo());</span>

<span class="nc" id="L287">                long rowStart = dataFile.getFilePointer();</span>
<span class="nc" id="L288">                outputHandler.debug(&quot;Reading row at %d&quot;, rowStart);</span>

<span class="nc" id="L290">                DecoratedKey key = null;</span>
                try
                {
<span class="nc" id="L293">                    key = sstable.decorateKey(ByteBufferUtil.readWithShortLength(dataFile));</span>
                }
<span class="nc" id="L295">                catch (Throwable th)</span>
                {
<span class="nc" id="L297">                    markAndThrow(th);</span>
<span class="nc" id="L298">                }</span>

<span class="nc bnc" id="L300" title="All 6 branches missed.">                if (options.checkOwnsTokens &amp;&amp; ownedRanges.size() &gt; 0 &amp;&amp; !(cfs.getPartitioner() instanceof LocalPartitioner))</span>
                {
                    try
                    {
<span class="nc" id="L304">                        rangeOwnHelper.validate(key);</span>
                    }
<span class="nc" id="L306">                    catch (Throwable t)</span>
                    {
<span class="nc" id="L308">                        outputHandler.warn(t, &quot;Key %s in sstable %s not owned by local ranges %s&quot;, key, sstable, ownedRanges);</span>
<span class="nc" id="L309">                        markAndThrow(t);</span>
<span class="nc" id="L310">                    }</span>
                }

<span class="nc" id="L313">                ByteBuffer currentIndexKey = indexIterator.key();</span>
<span class="nc" id="L314">                long nextRowPositionFromIndex = 0;</span>
                try
                {
<span class="nc bnc" id="L317" title="All 2 branches missed.">                    nextRowPositionFromIndex = indexIterator.advance()</span>
<span class="nc" id="L318">                                               ? indexIterator.dataPosition()</span>
<span class="nc" id="L319">                                               : dataFile.length();</span>
                }
<span class="nc" id="L321">                catch (Throwable th)</span>
                {
<span class="nc" id="L323">                    markAndThrow(th);</span>
<span class="nc" id="L324">                }</span>

<span class="nc" id="L326">                long dataStart = dataFile.getFilePointer();</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">                long dataStartFromIndex = currentIndexKey == null</span>
<span class="nc" id="L328">                                          ? -1</span>
<span class="nc" id="L329">                                          : rowStart + 2 + currentIndexKey.remaining();</span>

<span class="nc" id="L331">                long dataSize = nextRowPositionFromIndex - dataStartFromIndex;</span>
                // avoid an NPE if key is null
<span class="nc bnc" id="L333" title="All 2 branches missed.">                String keyName = key == null ? &quot;(unreadable key)&quot; : ByteBufferUtil.bytesToHex(key.getKey());</span>
<span class="nc" id="L334">                outputHandler.debug(&quot;row %s is %s&quot;, keyName, FBUtilities.prettyPrintMemory(dataSize));</span>

                try
                {
<span class="nc bnc" id="L338" title="All 4 branches missed.">                    if (key == null || dataSize &gt; dataFile.length())</span>
<span class="nc" id="L339">                        markAndThrow(new RuntimeException(String.format(&quot;key = %s, dataSize=%d, dataFile.length() = %d&quot;, key, dataSize, dataFile.length())));</span>

<span class="nc" id="L341">                    try (UnfilteredRowIterator iterator = SSTableIdentityIterator.create(sstable, dataFile, key))</span>
                    {
<span class="nc" id="L343">                        verifyPartition(key, iterator);</span>
                    }

<span class="nc bnc" id="L346" title="All 8 branches missed.">                    if ((prevKey != null &amp;&amp; prevKey.compareTo(key) &gt; 0) || !key.getKey().equals(currentIndexKey) || dataStart != dataStartFromIndex)</span>
<span class="nc" id="L347">                        markAndThrow(new RuntimeException(&quot;Key out of order: previous = &quot; + prevKey + &quot; : current = &quot; + key));</span>

<span class="nc" id="L349">                    goodRows++;</span>
<span class="nc" id="L350">                    prevKey = key;</span>


<span class="nc" id="L353">                    outputHandler.debug(&quot;Row %s at %s valid, moving to next row at %s &quot;, goodRows, rowStart, nextRowPositionFromIndex);</span>
<span class="nc" id="L354">                    dataFile.seek(nextRowPositionFromIndex);</span>
                }
<span class="nc" id="L356">                catch (Throwable th)</span>
                {
<span class="nc" id="L358">                    markAndThrow(th);</span>
<span class="nc" id="L359">                }</span>
<span class="nc" id="L360">            }</span>
        }
<span class="nc" id="L362">        catch (Throwable t)</span>
        {
<span class="nc" id="L364">            Throwables.throwIfUnchecked(t);</span>
<span class="nc" id="L365">            throw new RuntimeException(t);</span>
<span class="nc" id="L366">        }</span>
<span class="nc" id="L367">    }</span>

    protected abstract void verifyPartition(DecoratedKey key, UnfilteredRowIterator iterator);

    protected void verifyIndex()
    {
        try
        {
<span class="fc" id="L375">            outputHandler.debug(&quot;Deserializing index for %s&quot;, sstable);</span>
<span class="fc" id="L376">            deserializeIndex(sstable);</span>
        }
<span class="nc" id="L378">        catch (Throwable t)</span>
        {
<span class="nc" id="L380">            outputHandler.warn(t);</span>
<span class="nc" id="L381">            markAndThrow(t);</span>
<span class="fc" id="L382">        }</span>
<span class="fc" id="L383">    }</span>

    private void deserializeIndex(SSTableReader sstable) throws IOException
    {
<span class="fc" id="L387">        try (KeyReader it = sstable.keyReader())</span>
        {
<span class="fc" id="L389">            ByteBuffer last = it.key();</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">            while (it.advance()) last = it.key(); // no-op, just check if index is readable</span>
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">            if (!Objects.equals(last, sstable.getLast().getKey()))</span>
<span class="nc" id="L392">                throw new CorruptSSTableException(new IOException(&quot;Failed to read partition index&quot;), it.toString());</span>
        }
<span class="fc" id="L394">    }</span>

    @Override
    public void close()
    {
<span class="fc" id="L399">        fileAccessLock.writeLock().lock();</span>
        try
        {
<span class="fc" id="L402">            FileUtils.closeQuietly(dataFile);</span>
        }
        finally
        {
<span class="fc" id="L406">            fileAccessLock.writeLock().unlock();</span>
        }
<span class="fc" id="L408">    }</span>

    /**
     * Use the fact that check(...) is called with sorted tokens - we keep a pointer in to the normalized ranges
     * and only bump the pointer if the key given is out of range. This is done to avoid calling .contains(..) many
     * times for each key (with vnodes for example)
     */
<span class="nc" id="L415">    @VisibleForTesting</span>
    public static class RangeOwnHelper
    {
        private final List&lt;Range&lt;Token&gt;&gt; normalizedRanges;
<span class="nc" id="L419">        private int rangeIndex = 0;</span>
        private DecoratedKey lastKey;

        public RangeOwnHelper(List&lt;Range&lt;Token&gt;&gt; normalizedRanges)
<span class="nc" id="L423">        {</span>
<span class="nc" id="L424">            this.normalizedRanges = normalizedRanges;</span>
<span class="nc" id="L425">            Range.assertNormalized(normalizedRanges);</span>
<span class="nc" id="L426">        }</span>

        /**
         * check if the given key is contained in any of the given ranges
         * &lt;p&gt;
         * Must be called in sorted order - key should be increasing
         *
         * @param key the key
         * @throws RuntimeException if the key is not contained
         */
        public void validate(DecoratedKey key)
        {
<span class="nc bnc" id="L438" title="All 2 branches missed.">            if (!check(key))</span>
<span class="nc" id="L439">                throw new RuntimeException(&quot;Key &quot; + key + &quot; is not contained in the given ranges&quot;);</span>
<span class="nc" id="L440">        }</span>

        /**
         * check if the given key is contained in any of the given ranges
         * &lt;p&gt;
         * Must be called in sorted order - key should be increasing
         *
         * @param key the key
         * @return boolean
         */
        public boolean check(DecoratedKey key)
        {
<span class="nc bnc" id="L452" title="All 4 branches missed.">            assert lastKey == null || key.compareTo(lastKey) &gt; 0;</span>
<span class="nc" id="L453">            lastKey = key;</span>

<span class="nc bnc" id="L455" title="All 2 branches missed.">            if (normalizedRanges.isEmpty()) // handle tests etc. where we don't have any ranges</span>
<span class="nc" id="L456">                return true;</span>

<span class="nc bnc" id="L458" title="All 2 branches missed.">            if (rangeIndex &gt; normalizedRanges.size() - 1)</span>
<span class="nc" id="L459">                throw new IllegalStateException(&quot;RangeOwnHelper can only be used to find the first out-of-range-token&quot;);</span>

<span class="nc bnc" id="L461" title="All 2 branches missed.">            while (!normalizedRanges.get(rangeIndex).contains(key.getToken()))</span>
            {
<span class="nc" id="L463">                rangeIndex++;</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">                if (rangeIndex &gt; normalizedRanges.size() - 1)</span>
<span class="nc" id="L465">                    return false;</span>
            }

<span class="nc" id="L468">            return true;</span>
        }
    }

    protected static class VerifyInfo extends CompactionInfo.Holder
    {
        private final RandomAccessReader dataFile;
        private final SSTableReader sstable;
        private final TimeUUID verificationCompactionId;
        private final Lock fileReadLock;

        public VerifyInfo(RandomAccessReader dataFile, SSTableReader sstable, Lock fileReadLock)
<span class="fc" id="L480">        {</span>
<span class="fc" id="L481">            this.dataFile = dataFile;</span>
<span class="fc" id="L482">            this.sstable = sstable;</span>
<span class="fc" id="L483">            this.fileReadLock = fileReadLock;</span>
<span class="fc" id="L484">            verificationCompactionId = TimeUUID.Generator.nextTimeUUID();</span>
<span class="fc" id="L485">        }</span>

        public CompactionInfo getCompactionInfo()
        {
<span class="nc" id="L489">            fileReadLock.lock();</span>
            try
            {
<span class="nc" id="L492">                return new CompactionInfo(sstable.metadata(),</span>
                                          OperationType.VERIFY,
<span class="nc" id="L494">                                          dataFile.getFilePointer(),</span>
<span class="nc" id="L495">                                          dataFile.length(),</span>
                                          verificationCompactionId,
<span class="nc" id="L497">                                          ImmutableSet.of(sstable));</span>
            }
<span class="nc" id="L499">            catch (Exception e)</span>
            {
<span class="nc" id="L501">                throw new RuntimeException();</span>
            }
            finally
            {
<span class="nc" id="L505">                fileReadLock.unlock();</span>
            }
        }

        public boolean isGlobal()
        {
<span class="nc" id="L511">            return false;</span>
        }
    }

    protected static class VerifyController extends CompactionController
    {
        public VerifyController(ColumnFamilyStore cfs)
        {
<span class="nc" id="L519">            super(cfs, Integer.MAX_VALUE);</span>
<span class="nc" id="L520">        }</span>

        @Override
        public LongPredicate getPurgeEvaluator(DecoratedKey key)
        {
<span class="nc" id="L525">            return time -&gt; false;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>