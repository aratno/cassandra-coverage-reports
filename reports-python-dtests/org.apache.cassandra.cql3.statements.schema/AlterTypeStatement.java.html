<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AlterTypeStatement.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.statements.schema</a> &gt; <span class="el_source">AlterTypeStatement.java</span></div><h1>AlterTypeStatement.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3.statements.schema;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.cassandra.audit.AuditLogContext;
import org.apache.cassandra.audit.AuditLogEntryType;
import org.apache.cassandra.auth.Permission;
import org.apache.cassandra.cql3.*;
import org.apache.cassandra.db.guardrails.Guardrails;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.marshal.UserType;
import org.apache.cassandra.schema.KeyspaceMetadata;
import org.apache.cassandra.schema.Keyspaces;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.service.ClientState;
import org.apache.cassandra.transport.Event.SchemaChange;
import org.apache.cassandra.transport.Event.SchemaChange.Change;
import org.apache.cassandra.transport.Event.SchemaChange.Target;

import static com.google.common.collect.Iterables.any;
import static com.google.common.collect.Iterables.filter;
import static com.google.common.collect.Iterables.transform;
import static java.lang.String.join;
import static java.util.function.Predicate.isEqual;
import static java.util.stream.Collectors.toList;

import static org.apache.cassandra.utils.ByteBufferUtil.bytes;

public abstract class AlterTypeStatement extends AlterSchemaStatement
{
    protected final String typeName;
    protected final boolean ifExists;

    public AlterTypeStatement(String keyspaceName, String typeName, boolean ifExists)
    {
<span class="fc" id="L57">        super(keyspaceName);</span>
<span class="fc" id="L58">        this.ifExists = ifExists;</span>
<span class="fc" id="L59">        this.typeName = typeName;</span>
<span class="fc" id="L60">    }</span>

    public void authorize(ClientState client)
    {
<span class="fc" id="L64">        client.ensureAllTablesPermission(keyspaceName, Permission.ALTER);</span>
<span class="fc" id="L65">    }</span>

    SchemaChange schemaChangeEvent(Keyspaces.KeyspacesDiff diff)
    {
<span class="fc" id="L69">        return new SchemaChange(Change.UPDATED, Target.TYPE, keyspaceName, typeName);</span>
    }

    public Keyspaces apply(Keyspaces schema)
    {
<span class="fc" id="L74">        KeyspaceMetadata keyspace = schema.getNullable(keyspaceName);</span>

<span class="pc bpc" id="L76" title="1 of 2 branches missed.">        UserType type = null == keyspace</span>
<span class="nc" id="L77">                      ? null</span>
<span class="fc" id="L78">                      : keyspace.types.getNullable(bytes(typeName));</span>

<span class="pc bpc" id="L80" title="1 of 2 branches missed.">        if (null == type)</span>
        {
<span class="nc bnc" id="L82" title="All 2 branches missed.">            if (!ifExists)</span>
<span class="nc" id="L83">                throw ire(&quot;Type %s.%s doesn't exist&quot;, keyspaceName, typeName);</span>
<span class="nc" id="L84">            return schema;</span>
        }

<span class="fc" id="L87">        return schema.withAddedOrUpdated(keyspace.withUpdatedUserType(apply(keyspace, type)));</span>
    }

    abstract UserType apply(KeyspaceMetadata keyspace, UserType type);

    @Override
    public AuditLogContext getAuditLogContext()
    {
<span class="nc" id="L95">        return new AuditLogContext(AuditLogEntryType.ALTER_TYPE, keyspaceName, typeName);</span>
    }

    public String toString()
    {
<span class="nc" id="L100">        return String.format(&quot;%s (%s, %s)&quot;, getClass().getSimpleName(), keyspaceName, typeName);</span>
    }

    private static final class AddField extends AlterTypeStatement
    {
        private final FieldIdentifier fieldName;
        private final CQL3Type.Raw type;
        private final boolean ifFieldNotExists;

        private ClientState state;

        private AddField(String keyspaceName, String typeName, FieldIdentifier fieldName, CQL3Type.Raw type, boolean ifExists, boolean ifFieldNotExists)
        {
<span class="fc" id="L113">            super(keyspaceName, typeName, ifExists);</span>
<span class="fc" id="L114">            this.fieldName = fieldName;</span>
<span class="fc" id="L115">            this.ifFieldNotExists = ifFieldNotExists;</span>
<span class="fc" id="L116">            this.type = type;</span>
<span class="fc" id="L117">        }</span>

        @Override
        public void validate(ClientState state)
        {
<span class="fc" id="L122">            super.validate(state);</span>

            // save the query state to use it for guardrails validation in #apply
<span class="fc" id="L125">            this.state = state;</span>
<span class="fc" id="L126">        }</span>

        UserType apply(KeyspaceMetadata keyspace, UserType userType)
        {
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">            if (type.isCounter())</span>
<span class="nc" id="L131">                throw ire(&quot;A user type cannot contain counters&quot;);</span>

<span class="pc bpc" id="L133" title="3 of 4 branches missed.">            if (type.isUDT() &amp;&amp; !type.isFrozen())</span>
<span class="nc" id="L134">                throw ire(&quot;A user type cannot contain non-frozen UDTs&quot;);</span>

<span class="pc bpc" id="L136" title="1 of 2 branches missed.">            if (userType.fieldPosition(fieldName) &gt;= 0)</span>
            {
<span class="nc bnc" id="L138" title="All 2 branches missed.">                if (!ifFieldNotExists)</span>
<span class="nc" id="L139">                    throw ire(&quot;Cannot add field %s to type %s: a field with name %s already exists&quot;, fieldName, userType.getCqlTypeName(), fieldName);</span>
<span class="nc" id="L140">                return userType;</span>
            }

<span class="fc" id="L143">            AbstractType&lt;?&gt; fieldType = type.prepare(keyspaceName, keyspace.types).getType();</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">            if (fieldType.referencesUserType(userType.name))</span>
<span class="nc" id="L145">                throw ire(&quot;Cannot add new field %s of type %s to user type %s as it would create a circular reference&quot;, fieldName, type, userType.getCqlTypeName());</span>

<span class="fc" id="L147">            Collection&lt;TableMetadata&gt; tablesWithTypeInPartitionKey = findTablesReferencingTypeInPartitionKey(keyspace, userType);</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">            if (!tablesWithTypeInPartitionKey.isEmpty())</span>
            {
<span class="nc" id="L150">                throw ire(&quot;Cannot add new field %s of type %s to user type %s as the type is being used in partition key by the following tables: %s&quot;,</span>
<span class="nc" id="L151">                          fieldName, type, userType.getCqlTypeName(),</span>
<span class="nc" id="L152">                          String.join(&quot;, &quot;, transform(tablesWithTypeInPartitionKey, TableMetadata::toString)));</span>
            }

<span class="fc" id="L155">            Guardrails.fieldsPerUDT.guard(userType.size() + 1, userType.getNameAsString(), false, state);</span>
<span class="fc" id="L156">            type.validate(state, &quot;Field &quot; + fieldName);</span>

<span class="fc" id="L158">            List&lt;FieldIdentifier&gt; fieldNames = new ArrayList&lt;&gt;(userType.fieldNames()); fieldNames.add(fieldName);</span>
<span class="fc" id="L159">            List&lt;AbstractType&lt;?&gt;&gt; fieldTypes = new ArrayList&lt;&gt;(userType.fieldTypes()); fieldTypes.add(fieldType);</span>

<span class="fc" id="L161">            return new UserType(keyspaceName, userType.name, fieldNames, fieldTypes, true);</span>
        }

        private static Collection&lt;TableMetadata&gt; findTablesReferencingTypeInPartitionKey(KeyspaceMetadata keyspace, UserType userType)
        {
<span class="fc" id="L166">            Collection&lt;TableMetadata&gt; tables = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L167">            filter(keyspace.tablesAndViews(),</span>
<span class="fc" id="L168">                   table -&gt; any(table.partitionKeyColumns(), column -&gt; column.type.referencesUserType(userType.name)))</span>
<span class="fc" id="L169">                  .forEach(tables::add);</span>
<span class="fc" id="L170">            return tables;</span>
        }
    }

    private static final class RenameFields extends AlterTypeStatement
    {
        private final Map&lt;FieldIdentifier, FieldIdentifier&gt; renamedFields;
        private final boolean ifFieldExists;

        private RenameFields(String keyspaceName, String typeName, Map&lt;FieldIdentifier, FieldIdentifier&gt; renamedFields, boolean ifExists, boolean ifFieldExists)
        {
<span class="fc" id="L181">            super(keyspaceName, typeName, ifExists);</span>
<span class="fc" id="L182">            this.ifFieldExists = ifFieldExists;</span>
<span class="fc" id="L183">            this.renamedFields = renamedFields;</span>
<span class="fc" id="L184">        }</span>

        UserType apply(KeyspaceMetadata keyspace, UserType userType)
        {
<span class="fc" id="L188">            List&lt;String&gt; dependentAggregates =</span>
                keyspace.userFunctions
<span class="fc" id="L190">                        .udas()</span>
<span class="pc bnc" id="L191" title="All 4 branches missed.">                        .filter(uda -&gt; null != uda.initialCondition() &amp;&amp; uda.stateType().referencesUserType(userType.name))</span>
<span class="pc" id="L192">                        .map(uda -&gt; uda.name().toString())</span>
<span class="fc" id="L193">                        .collect(toList());</span>

<span class="pc bpc" id="L195" title="1 of 2 branches missed.">            if (!dependentAggregates.isEmpty())</span>
            {
<span class="nc" id="L197">                throw ire(&quot;Cannot alter user type %s as it is still used in INITCOND by aggregates %s&quot;,</span>
<span class="nc" id="L198">                          userType.getCqlTypeName(),</span>
<span class="nc" id="L199">                          join(&quot;, &quot;, dependentAggregates));</span>
            }

<span class="fc" id="L202">            List&lt;FieldIdentifier&gt; fieldNames = new ArrayList&lt;&gt;(userType.fieldNames());</span>

<span class="fc" id="L204">            renamedFields.forEach((oldName, newName) -&gt;</span>
            {
<span class="fc" id="L206">                int idx = userType.fieldPosition(oldName);</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">                if (idx &lt; 0)</span>
                {
<span class="nc bnc" id="L209" title="All 2 branches missed.">                    if (!ifFieldExists)</span>
<span class="nc" id="L210">                        throw ire(&quot;Unkown field %s in user type %s&quot;, oldName, userType.getCqlTypeName());</span>
<span class="nc" id="L211">                    return;</span>
                }
<span class="fc" id="L213">                fieldNames.set(idx, newName);</span>
<span class="fc" id="L214">            });</span>

<span class="fc" id="L216">            fieldNames.forEach(name -&gt;</span>
            {
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">                if (fieldNames.stream().filter(isEqual(name)).count() &gt; 1)</span>
<span class="nc" id="L219">                    throw ire(&quot;Duplicate field name %s in type %s&quot;, name, keyspaceName, userType.getCqlTypeName());</span>
<span class="fc" id="L220">            });</span>

<span class="fc" id="L222">            return new UserType(keyspaceName, userType.name, fieldNames, userType.fieldTypes(), true);</span>
        }
    }

    private static final class AlterField extends AlterTypeStatement
    {
        private AlterField(String keyspaceName, String typeName, boolean ifExists)
        {
<span class="nc" id="L230">            super(keyspaceName, typeName, ifExists);</span>
<span class="nc" id="L231">        }</span>

        UserType apply(KeyspaceMetadata keyspace, UserType userType)
        {
<span class="nc" id="L235">            throw ire(&quot;Altering field types is no longer supported&quot;);</span>
        }
    }

    public static final class Raw extends CQLStatement.Raw
    {
<span class="fc" id="L241">        private enum Kind</span>
        {
<span class="fc" id="L243">            ADD_FIELD, RENAME_FIELDS, ALTER_FIELD</span>
        }

        private final UTName name;
        private final boolean ifExists;
        private boolean ifFieldExists;
        private boolean ifFieldNotExists;

        private Kind kind;

        // ADD
        private FieldIdentifier newFieldName;
        private CQL3Type.Raw newFieldType;

        // RENAME
<span class="fc" id="L258">        private final Map&lt;FieldIdentifier, FieldIdentifier&gt; renamedFields = new HashMap&lt;&gt;();</span>

        public Raw(UTName name, boolean ifExists)
<span class="fc" id="L261">        {</span>
<span class="fc" id="L262">            this.ifExists = ifExists;</span>
<span class="fc" id="L263">            this.name = name;</span>
<span class="fc" id="L264">        }</span>

        public AlterTypeStatement prepare(ClientState state)
        {
<span class="fc bfc" id="L268" title="All 2 branches covered.">            String keyspaceName = name.hasKeyspace() ? name.getKeyspace() : state.getKeyspace();</span>
<span class="fc" id="L269">            String typeName = name.getStringTypeName();</span>

<span class="pc bpc" id="L271" title="2 of 4 branches missed.">            switch (kind)</span>
            {
<span class="fc" id="L273">                case     ADD_FIELD: return new AddField(keyspaceName, typeName, newFieldName, newFieldType, ifExists, ifFieldNotExists);</span>
<span class="fc" id="L274">                case RENAME_FIELDS: return new RenameFields(keyspaceName, typeName, renamedFields, ifExists, ifFieldExists);</span>
<span class="nc" id="L275">                case   ALTER_FIELD: return new AlterField(keyspaceName, typeName, ifExists);</span>
            }

<span class="nc" id="L278">            throw new AssertionError();</span>
        }

        public void add(FieldIdentifier name, CQL3Type.Raw type)
        {
<span class="fc" id="L283">            kind = Kind.ADD_FIELD;</span>
<span class="fc" id="L284">            newFieldName = name;</span>
<span class="fc" id="L285">            newFieldType = type;</span>
<span class="fc" id="L286">        }</span>

        public void ifFieldNotExists(boolean ifNotExists)
        {
<span class="nc" id="L290">            this.ifFieldNotExists = ifNotExists;</span>
<span class="nc" id="L291">        }</span>

        public void rename(FieldIdentifier from, FieldIdentifier to)
        {
<span class="fc" id="L295">            kind = Kind.RENAME_FIELDS;</span>
<span class="fc" id="L296">            renamedFields.put(from, to);</span>
<span class="fc" id="L297">        }</span>

        public void ifFieldExists(boolean ifExists)
        {
<span class="nc" id="L301">            this.ifFieldExists = ifExists;</span>
<span class="nc" id="L302">        }</span>

        public void alter(FieldIdentifier name, CQL3Type.Raw type)
        {
<span class="nc" id="L306">            kind = Kind.ALTER_FIELD;</span>
<span class="nc" id="L307">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>