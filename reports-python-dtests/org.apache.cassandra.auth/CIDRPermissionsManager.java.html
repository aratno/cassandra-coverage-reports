<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CIDRPermissionsManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.auth</a> &gt; <span class="el_source">CIDRPermissionsManager.java</span></div><h1>CIDRPermissionsManager.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.auth;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Lists;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.cql3.QueryOptions;
import org.apache.cassandra.cql3.QueryProcessor;
import org.apache.cassandra.cql3.UntypedResultSet;
import org.apache.cassandra.cql3.statements.SelectStatement;
import org.apache.cassandra.db.ConsistencyLevel;
import org.apache.cassandra.db.marshal.UTF8Type;
import org.apache.cassandra.exceptions.RequestExecutionException;
import org.apache.cassandra.schema.SchemaConstants;
import org.apache.cassandra.service.ClientState;
import org.apache.cassandra.service.reads.range.RangeCommands;
import org.apache.cassandra.transport.messages.ResultMessage;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.MBeanWrapper;

import static org.apache.cassandra.service.QueryState.forInternalCalls;
import static org.apache.cassandra.utils.Clock.Global.nanoTime;

/**
 * Provides functionality to list/update/drop CIDR permissions of a role
 * Backend to build Role to CIDR permissions cache
 */
<span class="fc" id="L55">public class CIDRPermissionsManager implements CIDRPermissionsManagerMBean, AuthCache.BulkLoader&lt;RoleResource, CIDRPermissions&gt;</span>
{
    public static final String MBEAN_NAME = &quot;org.apache.cassandra.db:type=CIDRPermissionsManager&quot;;

<span class="fc" id="L59">    private static final Logger logger = LoggerFactory.getLogger(CIDRPermissionsManager.class);</span>
<span class="fc" id="L60">    private SelectStatement getCidrPermissionsOfUserStatement = null;</span>

    public void setup()
    {
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">        if (!MBeanWrapper.instance.isRegistered(MBEAN_NAME))</span>
<span class="fc" id="L65">            MBeanWrapper.instance.registerMBean(this, MBEAN_NAME);</span>

<span class="fc" id="L67">        String getCidrPermissionsOfUserQuery = String.format(&quot;SELECT %s FROM %s.%s WHERE %s = ?&quot;,</span>
                                                             AuthKeyspace.CIDR_PERMISSIONS_TBL_CIDR_GROUPS_COL_NAME,
                                                             SchemaConstants.AUTH_KEYSPACE_NAME,
                                                             AuthKeyspace.CIDR_PERMISSIONS,
                                                             AuthKeyspace.CIDR_PERMISSIONS_TBL_ROLE_COL_NAME);
<span class="fc" id="L72">        getCidrPermissionsOfUserStatement = (SelectStatement) QueryProcessor.getStatement(getCidrPermissionsOfUserQuery,</span>
<span class="fc" id="L73">                                                                                          ClientState.forInternalCalls());</span>
<span class="fc" id="L74">    }</span>

    @VisibleForTesting
    ResultMessage.Rows select(SelectStatement statement, QueryOptions options)
    {
<span class="nc" id="L79">        return statement.execute(forInternalCalls(), options, nanoTime());</span>
    }

    @VisibleForTesting
    UntypedResultSet process(String query, ConsistencyLevel cl) throws RequestExecutionException
    {
<span class="fc" id="L85">        return QueryProcessor.process(query, cl);</span>
    }

    private Set&lt;String&gt; getAuthorizedCIDRGroups(String name)
    {
<span class="nc" id="L90">        QueryOptions options = QueryOptions.forInternalCalls(CassandraAuthorizer.authReadConsistencyLevel(),</span>
<span class="nc" id="L91">                                                             Lists.newArrayList(ByteBufferUtil.bytes(name)));</span>

<span class="nc" id="L93">        ResultMessage.Rows rows = select(getCidrPermissionsOfUserStatement, options);</span>
<span class="nc" id="L94">        UntypedResultSet result = UntypedResultSet.create(rows.result);</span>
<span class="nc bnc" id="L95" title="All 4 branches missed.">        if (!result.isEmpty() &amp;&amp; result.one().has(AuthKeyspace.CIDR_PERMISSIONS_TBL_CIDR_GROUPS_COL_NAME))</span>
        {
<span class="nc" id="L97">            return result.one().getFrozenSet(AuthKeyspace.CIDR_PERMISSIONS_TBL_CIDR_GROUPS_COL_NAME, UTF8Type.instance);</span>
        }

<span class="nc" id="L100">        return Collections.emptySet();</span>
    }

    private static String getCidrPermissionsSetString(CIDRPermissions permissions)
    {
<span class="fc" id="L105">        String inner = &quot;&quot;;</span>

<span class="pc bpc" id="L107" title="1 of 2 branches missed.">        if (permissions.restrictsAccess())</span>
<span class="nc" id="L108">            inner = permissions.allowedCIDRGroups().stream().map(s -&gt; '\'' + s + '\'')</span>
<span class="nc" id="L109">                               .collect(Collectors.joining(&quot;, &quot;));</span>

<span class="fc" id="L111">        return '{' + inner + '}';</span>
    }

    /**
     * Get CIDR permissions of a role
     * @param role role for which to get CIDR permissions
     * @return returns CIDR permissions of a role
     */
    public CIDRPermissions getCidrPermissionsForRole(RoleResource role)
    {
<span class="nc bnc" id="L121" title="All 2 branches missed.">        if (!Roles.canLogin(role))</span>
        {
<span class="nc" id="L123">            return CIDRPermissions.none();</span>
        }
<span class="nc bnc" id="L125" title="All 4 branches missed.">        if (Roles.hasSuperuserStatus(role) &amp;&amp; !DatabaseDescriptor.getCidrChecksForSuperusers())</span>
        {
<span class="nc" id="L127">            return CIDRPermissions.all();</span>
        }

<span class="nc" id="L130">        Set&lt;String&gt; cidrGroups = getAuthorizedCIDRGroups(role.getRoleName());</span>
        // User don't have CIDR permissions explicitly enabled, i.e, allow from all
<span class="nc bnc" id="L132" title="All 4 branches missed.">        if (cidrGroups == null || cidrGroups.isEmpty())</span>
        {
            // No explicit CIDR groups set for the role, allow from all
<span class="nc" id="L135">            return CIDRPermissions.all();</span>
        }

<span class="nc" id="L138">        return CIDRPermissions.subset(cidrGroups);</span>
    }

    /**
     * Set CIDR permissions for a given role
     * @param role role for which to set CIDR permissions
     * @param cidrPermissions CIR permissions to set for the role
     */
    public void setCidrGroupsForRole(RoleResource role, CIDRPermissions cidrPermissions)
    {
<span class="fc" id="L148">        String query = String.format(&quot;UPDATE %s.%s SET %s = %s WHERE %s = '%s'&quot;,</span>
                                     SchemaConstants.AUTH_KEYSPACE_NAME,
                                     AuthKeyspace.CIDR_PERMISSIONS,
                                     AuthKeyspace.CIDR_PERMISSIONS_TBL_CIDR_GROUPS_COL_NAME,
<span class="fc" id="L152">                                     getCidrPermissionsSetString(cidrPermissions),</span>
                                     AuthKeyspace.CIDR_PERMISSIONS_TBL_ROLE_COL_NAME,
<span class="fc" id="L154">                                     role.getRoleName());</span>

<span class="fc" id="L156">        process(query, CassandraAuthorizer.authWriteConsistencyLevel());</span>
<span class="fc" id="L157">    }</span>

    /**
     * Drop CIDR permissions of a role, i.e, delete corresponding row from the table
     * @param role for which to drop cidr permissions
     */
    public void drop(RoleResource role)
    {
<span class="fc" id="L165">        String query = String.format(&quot;DELETE FROM %s.%s WHERE role = '%s'&quot;,</span>
                                     SchemaConstants.AUTH_KEYSPACE_NAME,
                                     AuthKeyspace.CIDR_PERMISSIONS,
<span class="fc" id="L168">                                     role.getRoleName());</span>

<span class="fc" id="L170">        process(query, CassandraAuthorizer.authWriteConsistencyLevel());</span>
<span class="fc" id="L171">    }</span>

    /**
     * Function to bulk load role to cidr permissions cache
     * This gets called when cache warmup is enabled in the config
     * @return returns nothing
     */
    @Override
    public Supplier&lt;Map&lt;RoleResource, CIDRPermissions&gt;&gt; bulkLoader()
    {
<span class="nc" id="L181">        return () -&gt; {</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">            if (!RangeCommands.sufficientLiveNodesForSelectStar(AuthKeyspace.metadata().tables.getNullable(AuthKeyspace.CIDR_PERMISSIONS),</span>
<span class="nc" id="L183">                                                                AuthProperties.instance.getReadConsistencyLevel()))</span>
            {
                // Prevent running the query we know will fail so as not to increment unavailable stats for a performance
                // optimization
<span class="nc" id="L187">                throw new RuntimeException(&quot;insufficient live nodes for &quot; +</span>
<span class="nc" id="L188">                                           AuthProperties.instance.getReadConsistencyLevel() +</span>
                                           &quot;pre-warm query again system_auth.&quot; + AuthKeyspace.CIDR_PERMISSIONS);
            }

<span class="nc" id="L192">            logger.info(&quot;Pre-warming CIDR permissions cache from cidr_permissions table&quot;);</span>
<span class="nc" id="L193">            Map&lt;RoleResource, CIDRPermissions&gt; entries = new HashMap&lt;&gt;();</span>
<span class="nc" id="L194">            UntypedResultSet rows = process(String.format(&quot;SELECT %s, %s FROM %s.%s&quot;,</span>
                                                          AuthKeyspace.CIDR_PERMISSIONS_TBL_ROLE_COL_NAME,
                                                          AuthKeyspace.CIDR_PERMISSIONS_TBL_CIDR_GROUPS_COL_NAME,
                                                          SchemaConstants.AUTH_KEYSPACE_NAME,
                                                          AuthKeyspace.CIDR_PERMISSIONS),
<span class="nc" id="L199">                                            CassandraAuthorizer.authReadConsistencyLevel());</span>

<span class="nc bnc" id="L201" title="All 2 branches missed.">            for (UntypedResultSet.Row row : rows)</span>
            {
<span class="nc" id="L203">                RoleResource role = RoleResource.role(row.getString(AuthKeyspace.CIDR_PERMISSIONS_TBL_ROLE_COL_NAME));</span>
<span class="nc" id="L204">                CIDRPermissions.Builder builder = new CIDRPermissions.Builder();</span>
<span class="nc" id="L205">                Set&lt;String&gt; cidrGroups = row.getFrozenSet(AuthKeyspace.CIDR_PERMISSIONS_TBL_CIDR_GROUPS_COL_NAME,</span>
                                                          UTF8Type.instance);
<span class="nc bnc" id="L207" title="All 2 branches missed.">                for (String cidrGroup : cidrGroups)</span>
<span class="nc" id="L208">                    builder.add(cidrGroup);</span>
<span class="nc" id="L209">                entries.put(role, builder.build());</span>
<span class="nc" id="L210">            }</span>

<span class="nc" id="L212">            return entries;</span>
        };
    }

    public boolean invalidateCidrPermissionsCache(String roleName)
    {
<span class="nc" id="L218">        return DatabaseDescriptor.getCIDRAuthorizer().invalidateCidrPermissionsCache(roleName);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>