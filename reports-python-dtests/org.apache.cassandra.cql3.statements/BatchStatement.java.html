<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BatchStatement.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.statements</a> &gt; <span class="el_source">BatchStatement.java</span></div><h1>BatchStatement.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3.statements;

import java.nio.ByteBuffer;
import java.util.*;
import java.util.concurrent.TimeUnit;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.HashMultiset;
import com.google.common.collect.Iterables;
import com.google.common.collect.Maps;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.helpers.MessageFormatter;

import org.apache.cassandra.audit.AuditLogContext;
import org.apache.cassandra.audit.AuditLogEntryType;
import org.apache.cassandra.db.guardrails.Guardrails;
import org.apache.cassandra.schema.TableId;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.cql3.*;
import org.apache.cassandra.db.*;
import org.apache.cassandra.db.partitions.PartitionUpdate;
import org.apache.cassandra.db.rows.RowIterator;
import org.apache.cassandra.exceptions.*;
import org.apache.cassandra.metrics.BatchMetrics;
import org.apache.cassandra.metrics.ClientRequestSizeMetrics;
import org.apache.cassandra.service.*;
import org.apache.cassandra.tracing.Tracing;
import org.apache.cassandra.transport.messages.ResultMessage;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.NoSpamLogger;
import org.apache.cassandra.utils.Pair;

import static java.util.function.Predicate.isEqual;

import static org.apache.cassandra.cql3.statements.RequestValidations.checkFalse;
import static org.apache.cassandra.utils.Clock.Global.nanoTime;

/**
 * A &lt;code&gt;BATCH&lt;/code&gt; statement parsed from a CQL query.
 */
public class BatchStatement implements CQLStatement
{
<span class="fc" id="L63">    public enum Type</span>
    {
<span class="fc" id="L65">        LOGGED, UNLOGGED, COUNTER</span>
    }

    public final Type type;
    private final VariableSpecifications bindVariables;
    private final List&lt;ModificationStatement&gt; statements;

    // Columns modified for each table (keyed by the table ID)
    private final Map&lt;TableId, RegularAndStaticColumns&gt; updatedColumns;
    // Columns on which there is conditions. Note that if there is any, then the batch can only be on a single partition (and thus table).
    private final RegularAndStaticColumns conditionColumns;

    private final boolean updatesRegularRows;
    private final boolean updatesStaticRow;
    private final Attributes attrs;
    private final boolean hasConditions;
    private final boolean updatesVirtualTables;

<span class="fc" id="L83">    private static final Logger logger = LoggerFactory.getLogger(BatchStatement.class);</span>

    private static final String UNLOGGED_BATCH_WARNING = &quot;Unlogged batch covering {} partitions detected &quot; +
                                                         &quot;against table{} {}. You should use a logged batch for &quot; +
                                                         &quot;atomicity, or asynchronous writes for performance.&quot;;

    private static final String LOGGED_BATCH_LOW_GCGS_WARNING = &quot;Executing a LOGGED BATCH on table{} {}, configured with a &quot; +
                                                                &quot;gc_grace_seconds of 0. The gc_grace_seconds is used to TTL &quot; +
                                                                &quot;batchlog entries, so setting gc_grace_seconds too low on &quot; +
                                                                &quot;tables involved in an atomic batch might cause batchlog &quot; +
                                                                &quot;entries to expire before being replayed.&quot;;

<span class="fc" id="L95">    public static final BatchMetrics metrics = new BatchMetrics();</span>

    /**
     * Creates a new BatchStatement.
     *
     * @param type       type of the batch
     * @param statements the list of statements in the batch
     * @param attrs      additional attributes for statement (CL, timestamp, timeToLive)
     */
    public BatchStatement(Type type, VariableSpecifications bindVariables, List&lt;ModificationStatement&gt; statements, Attributes attrs)
<span class="fc" id="L105">    {</span>
<span class="fc" id="L106">        this.type = type;</span>
<span class="fc" id="L107">        this.bindVariables = bindVariables;</span>
<span class="fc" id="L108">        this.statements = statements;</span>
<span class="fc" id="L109">        this.attrs = attrs;</span>

<span class="fc" id="L111">        boolean hasConditions = false;</span>
<span class="fc" id="L112">        MultiTableColumnsBuilder regularBuilder = new MultiTableColumnsBuilder();</span>
<span class="fc" id="L113">        RegularAndStaticColumns.Builder conditionBuilder = RegularAndStaticColumns.builder();</span>
<span class="fc" id="L114">        boolean updateRegular = false;</span>
<span class="fc" id="L115">        boolean updateStatic = false;</span>
<span class="fc" id="L116">        boolean updatesVirtualTables = false;</span>

<span class="fc bfc" id="L118" title="All 2 branches covered.">        for (ModificationStatement stmt : statements)</span>
        {
<span class="fc" id="L120">            regularBuilder.addAll(stmt.metadata(), stmt.updatedColumns());</span>
<span class="fc" id="L121">            updateRegular |= stmt.updatesRegularRows();</span>
<span class="fc" id="L122">            updatesVirtualTables |= stmt.isVirtual();</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">            if (stmt.hasConditions())</span>
            {
<span class="fc" id="L125">                hasConditions = true;</span>
<span class="fc" id="L126">                conditionBuilder.addAll(stmt.conditionColumns());</span>
<span class="fc" id="L127">                updateStatic |= stmt.updatesStaticRow();</span>
            }
<span class="fc" id="L129">        }</span>

<span class="fc" id="L131">        this.updatedColumns = regularBuilder.build();</span>
<span class="fc" id="L132">        this.conditionColumns = conditionBuilder.build();</span>
<span class="fc" id="L133">        this.updatesRegularRows = updateRegular;</span>
<span class="fc" id="L134">        this.updatesStaticRow = updateStatic;</span>
<span class="fc" id="L135">        this.hasConditions = hasConditions;</span>
<span class="fc" id="L136">        this.updatesVirtualTables = updatesVirtualTables;</span>
<span class="fc" id="L137">    }</span>

    @Override
    public List&lt;ColumnSpecification&gt; getBindVariables()
    {
<span class="fc" id="L142">        return bindVariables.getBindVariables();</span>
    }

    @Override
    public short[] getPartitionKeyBindVariableIndexes()
    {
<span class="fc" id="L148">        boolean affectsMultipleTables =</span>
<span class="pc bpc" id="L149" title="2 of 4 branches missed.">            !statements.isEmpty() &amp;&amp; !statements.stream().map(s -&gt; s.metadata().id).allMatch(isEqual(statements.get(0).metadata().id));</span>

        // Use the TableMetadata of the first statement for partition key bind indexes.  If the statements affect
        // multiple tables, we won't send partition key bind indexes.
<span class="pc bpc" id="L153" title="2 of 4 branches missed.">        return (affectsMultipleTables || statements.isEmpty())</span>
<span class="nc" id="L154">             ? null</span>
<span class="fc" id="L155">             : bindVariables.getPartitionKeyBindVariableIndexes(statements.get(0).metadata());</span>
    }

    @Override
    public Iterable&lt;org.apache.cassandra.cql3.functions.Function&gt; getFunctions()
    {
<span class="nc" id="L161">        List&lt;org.apache.cassandra.cql3.functions.Function&gt; functions = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        for (ModificationStatement statement : statements)</span>
<span class="nc" id="L163">            statement.addFunctionsTo(functions);</span>
<span class="nc" id="L164">        return functions;</span>
    }

    public void authorize(ClientState state) throws InvalidRequestException, UnauthorizedException
    {
<span class="fc bfc" id="L169" title="All 2 branches covered.">        for (ModificationStatement statement : statements)</span>
<span class="fc" id="L170">            statement.authorize(state);</span>
<span class="fc" id="L171">    }</span>

    // Validates a prepared batch statement without validating its nested statements.
    public void validate() throws InvalidRequestException
    {
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">        if (attrs.isTimeToLiveSet())</span>
<span class="nc" id="L177">            throw new InvalidRequestException(&quot;Global TTL on the BATCH statement is not supported.&quot;);</span>

<span class="fc" id="L179">        boolean timestampSet = attrs.isTimestampSet();</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">        if (timestampSet)</span>
        {
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">            if (hasConditions)</span>
<span class="nc" id="L183">                throw new InvalidRequestException(&quot;Cannot provide custom timestamp for conditional BATCH&quot;);</span>

<span class="pc bpc" id="L185" title="1 of 2 branches missed.">            if (isCounter())</span>
<span class="nc" id="L186">                throw new InvalidRequestException(&quot;Cannot provide custom timestamp for counter BATCH&quot;);</span>
        }

<span class="fc" id="L189">        boolean hasCounters = false;</span>
<span class="fc" id="L190">        boolean hasNonCounters = false;</span>

<span class="fc" id="L192">        boolean hasVirtualTables = false;</span>
<span class="fc" id="L193">        boolean hasRegularTables = false;</span>

<span class="fc bfc" id="L195" title="All 2 branches covered.">        for (ModificationStatement statement : statements)</span>
        {
<span class="fc bfc" id="L197" title="All 4 branches covered.">            if (timestampSet &amp;&amp; statement.isTimestampSet())</span>
<span class="fc" id="L198">                throw new InvalidRequestException(&quot;Timestamp must be set either on BATCH or individual statements&quot;);</span>

<span class="fc bfc" id="L200" title="All 2 branches covered.">            if (statement.isCounter())</span>
<span class="fc" id="L201">                hasCounters = true;</span>
            else
<span class="fc" id="L203">                hasNonCounters = true;</span>

<span class="pc bpc" id="L205" title="1 of 2 branches missed.">            if (statement.isVirtual())</span>
<span class="nc" id="L206">                hasVirtualTables = true;</span>
            else
<span class="fc" id="L208">                hasRegularTables = true;</span>
<span class="fc" id="L209">        }</span>

<span class="pc bpc" id="L211" title="1 of 4 branches missed.">        if (timestampSet &amp;&amp; hasCounters)</span>
<span class="nc" id="L212">            throw new InvalidRequestException(&quot;Cannot provide custom timestamp for a BATCH containing counters&quot;);</span>

<span class="fc bfc" id="L214" title="All 4 branches covered.">        if (isCounter() &amp;&amp; hasNonCounters)</span>
<span class="fc" id="L215">            throw new InvalidRequestException(&quot;Cannot include non-counter statement in a counter batch&quot;);</span>

<span class="fc bfc" id="L217" title="All 4 branches covered.">        if (hasCounters &amp;&amp; hasNonCounters)</span>
<span class="fc" id="L218">            throw new InvalidRequestException(&quot;Counter and non-counter mutations cannot exist in the same batch&quot;);</span>

<span class="pc bpc" id="L220" title="1 of 4 branches missed.">        if (isLogged() &amp;&amp; hasCounters)</span>
<span class="nc" id="L221">            throw new InvalidRequestException(&quot;Cannot include a counter statement in a logged batch&quot;);</span>

<span class="pc bpc" id="L223" title="1 of 4 branches missed.">        if (isLogged() &amp;&amp; hasVirtualTables)</span>
<span class="nc" id="L224">            throw new InvalidRequestException(&quot;Cannot include a virtual table statement in a logged batch&quot;);</span>

<span class="pc bpc" id="L226" title="3 of 4 branches missed.">        if (hasVirtualTables &amp;&amp; hasRegularTables)</span>
<span class="nc" id="L227">            throw new InvalidRequestException(&quot;Mutations for virtual and regular tables cannot exist in the same batch&quot;);</span>

<span class="pc bpc" id="L229" title="1 of 4 branches missed.">        if (hasConditions &amp;&amp; hasVirtualTables)</span>
<span class="nc" id="L230">            throw new InvalidRequestException(&quot;Conditional BATCH statements cannot include mutations for virtual tables&quot;);</span>

<span class="fc bfc" id="L232" title="All 2 branches covered.">        if (hasConditions)</span>
        {
<span class="fc" id="L234">            String ksName = null;</span>
<span class="fc" id="L235">            String cfName = null;</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">            for (ModificationStatement stmt : statements)</span>
            {
<span class="pc bpc" id="L238" title="2 of 6 branches missed.">                if (ksName != null &amp;&amp; (!stmt.keyspace().equals(ksName) || !stmt.table().equals(cfName)))</span>
<span class="nc" id="L239">                    throw new InvalidRequestException(&quot;Batch with conditions cannot span multiple tables&quot;);</span>
<span class="fc" id="L240">                ksName = stmt.keyspace();</span>
<span class="fc" id="L241">                cfName = stmt.table();</span>
<span class="fc" id="L242">            }</span>
        }
<span class="fc" id="L244">    }</span>

    private boolean isCounter()
    {
<span class="fc bfc" id="L248" title="All 2 branches covered.">        return type == Type.COUNTER;</span>
    }

    private boolean isLogged()
    {
<span class="fc bfc" id="L253" title="All 2 branches covered.">        return type == Type.LOGGED;</span>
    }

    // The batch itself will be validated in either Parsed#prepare() - for regular CQL3 batches,
    //   or in QueryProcessor.processBatch() - for native protocol batches.
    public void validate(ClientState state) throws InvalidRequestException
    {
<span class="fc bfc" id="L260" title="All 2 branches covered.">        for (ModificationStatement statement : statements)</span>
<span class="fc" id="L261">            statement.validate(state);</span>
<span class="fc" id="L262">    }</span>

    public List&lt;ModificationStatement&gt; getStatements()
    {
<span class="nc" id="L266">        return statements;</span>
    }

    @VisibleForTesting
    public List&lt;? extends IMutation&gt; getMutations(ClientState state,
                                                  BatchQueryOptions options,
                                                  boolean local,
                                                  long batchTimestamp,
                                                  long nowInSeconds,
                                                  long queryStartNanoTime)
    {
<span class="fc bfc" id="L277" title="All 2 branches covered.">        if (statements.isEmpty())</span>
<span class="fc" id="L278">            return Collections.emptyList();</span>
<span class="fc" id="L279">        List&lt;List&lt;ByteBuffer&gt;&gt; partitionKeys = new ArrayList&lt;&gt;(statements.size());</span>
<span class="fc" id="L280">        Map&lt;TableId, HashMultiset&lt;ByteBuffer&gt;&gt; partitionCounts = new HashMap&lt;&gt;(updatedColumns.size());</span>
<span class="fc" id="L281">        TableMetadata metadata = statements.get(0).metadata;</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">        for (int i = 0, isize = statements.size(); i &lt; isize; i++)</span>
        {
<span class="fc" id="L284">            ModificationStatement stmt = statements.get(i);</span>
<span class="pc bpc" id="L285" title="1 of 4 branches missed.">            if (metadata != null &amp;&amp; !stmt.metadata.id.equals(metadata.id))</span>
<span class="fc" id="L286">                metadata = null;</span>
<span class="fc" id="L287">            List&lt;ByteBuffer&gt; stmtPartitionKeys = stmt.buildPartitionKeyNames(options.forStatement(i), state);</span>
<span class="fc" id="L288">            partitionKeys.add(stmtPartitionKeys);</span>
<span class="fc" id="L289">            HashMultiset&lt;ByteBuffer&gt; perKeyCountsForTable = partitionCounts.computeIfAbsent(stmt.metadata.id, k -&gt; HashMultiset.create());</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">            for (int stmtIdx = 0, stmtSize = stmtPartitionKeys.size(); stmtIdx &lt; stmtSize; stmtIdx++)</span>
<span class="fc" id="L291">                perKeyCountsForTable.add(stmtPartitionKeys.get(stmtIdx));</span>
        }

<span class="fc" id="L294">        Set&lt;String&gt; tablesWithZeroGcGs = null;</span>
        UpdatesCollector collector;
<span class="fc bfc" id="L296" title="All 2 branches covered.">        if (metadata != null)</span>
<span class="fc" id="L297">            collector = new SingleTableUpdatesCollector(metadata, updatedColumns.get(metadata.id), partitionCounts.get(metadata.id));</span>
        else
<span class="fc" id="L299">            collector = new BatchUpdatesCollector(updatedColumns, partitionCounts);</span>

<span class="fc bfc" id="L301" title="All 2 branches covered.">        for (int i = 0, isize = statements.size(); i &lt; isize; i++)</span>
        {
<span class="fc" id="L303">            ModificationStatement statement = statements.get(i);</span>
<span class="fc bfc" id="L304" title="All 4 branches covered.">            if (isLogged() &amp;&amp; statement.metadata().params.gcGraceSeconds == 0)</span>
            {
<span class="fc bfc" id="L306" title="All 2 branches covered.">                if (tablesWithZeroGcGs == null)</span>
<span class="fc" id="L307">                    tablesWithZeroGcGs = new HashSet&lt;&gt;();</span>
<span class="fc" id="L308">                tablesWithZeroGcGs.add(statement.metadata.toString());</span>
            }
<span class="fc" id="L310">            QueryOptions statementOptions = options.forStatement(i);</span>
<span class="fc" id="L311">            long timestamp = attrs.getTimestamp(batchTimestamp, statementOptions);</span>
<span class="fc" id="L312">            statement.addUpdates(collector, partitionKeys.get(i), state, statementOptions, local, timestamp, nowInSeconds, queryStartNanoTime);</span>
        }

<span class="fc bfc" id="L315" title="All 2 branches covered.">        if (tablesWithZeroGcGs != null)</span>
        {
<span class="fc bfc" id="L317" title="All 2 branches covered.">            String suffix = tablesWithZeroGcGs.size() == 1 ? &quot;&quot; : &quot;s&quot;;</span>
<span class="fc" id="L318">            NoSpamLogger.log(logger, NoSpamLogger.Level.WARN, 1, TimeUnit.MINUTES, LOGGED_BATCH_LOW_GCGS_WARNING,</span>
                             suffix, tablesWithZeroGcGs);
<span class="fc" id="L320">            ClientWarn.instance.warn(MessageFormatter.arrayFormat(LOGGED_BATCH_LOW_GCGS_WARNING, new Object[] { suffix, tablesWithZeroGcGs })</span>
<span class="fc" id="L321">                                                     .getMessage());</span>
        }
<span class="fc" id="L323">        return collector.toMutations();</span>
    }

    /**
     * Checks batch size to ensure threshold is met. If not, a warning is logged.
     *
     * @param mutations - the batch mutations.
     */
    private static void verifyBatchSize(Collection&lt;? extends IMutation&gt; mutations) throws InvalidRequestException
    {
        // We only warn for batch spanning multiple mutations (#10876)
<span class="fc bfc" id="L334" title="All 2 branches covered.">        if (mutations.size() &lt;= 1)</span>
<span class="fc" id="L335">            return;</span>

<span class="fc" id="L337">        long warnThreshold = DatabaseDescriptor.getBatchSizeWarnThreshold();</span>
<span class="fc" id="L338">        long size = IMutation.dataSize(mutations);</span>

<span class="fc bfc" id="L340" title="All 2 branches covered.">        if (size &gt; warnThreshold)</span>
        {
<span class="fc" id="L342">            Set&lt;String&gt; tableNames = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">            for (IMutation mutation : mutations)</span>
            {
<span class="fc bfc" id="L345" title="All 2 branches covered.">                for (PartitionUpdate update : mutation.getPartitionUpdates())</span>
<span class="fc" id="L346">                    tableNames.add(update.metadata().toString());</span>
<span class="fc" id="L347">            }</span>

<span class="fc" id="L349">            long failThreshold = DatabaseDescriptor.getBatchSizeFailThreshold();</span>

<span class="fc" id="L351">            String format = &quot;Batch for {} is of size {}, exceeding specified threshold of {} by {}.{}&quot;;</span>
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">            if (size &gt; failThreshold)</span>
            {
<span class="nc" id="L354">                Tracing.trace(format, tableNames, FBUtilities.prettyPrintMemory(size), FBUtilities.prettyPrintMemory(failThreshold),</span>
<span class="nc" id="L355">                              FBUtilities.prettyPrintMemory(size - failThreshold), &quot; (see batch_size_fail_threshold)&quot;);</span>
<span class="nc" id="L356">                logger.error(format, tableNames, FBUtilities.prettyPrintMemory(size), FBUtilities.prettyPrintMemory(failThreshold),</span>
<span class="nc" id="L357">                             FBUtilities.prettyPrintMemory(size - failThreshold), &quot; (see batch_size_fail_threshold)&quot;);</span>
<span class="nc" id="L358">                throw new InvalidRequestException(&quot;Batch too large&quot;);</span>
            }
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">            else if (logger.isWarnEnabled())</span>
            {
<span class="fc" id="L362">                logger.warn(format, tableNames, FBUtilities.prettyPrintMemory(size), FBUtilities.prettyPrintMemory(warnThreshold),</span>
<span class="fc" id="L363">                            FBUtilities.prettyPrintMemory(size - warnThreshold), &quot;&quot;);</span>
            }
<span class="fc" id="L365">            ClientWarn.instance.warn(MessageFormatter.arrayFormat(format, new Object[] {tableNames, size, warnThreshold, size - warnThreshold, &quot;&quot;}).getMessage());</span>
        }
<span class="fc" id="L367">    }</span>

    private void verifyBatchType(Collection&lt;? extends IMutation&gt; mutations)
    {
<span class="fc bfc" id="L371" title="All 4 branches covered.">        if (!isLogged() &amp;&amp; mutations.size() &gt; 1)</span>
        {
<span class="fc" id="L373">            Set&lt;DecoratedKey&gt; keySet = new HashSet&lt;&gt;();</span>
<span class="fc" id="L374">            Set&lt;String&gt; tableNames = new HashSet&lt;&gt;();</span>

<span class="fc bfc" id="L376" title="All 2 branches covered.">            for (IMutation mutation : mutations)</span>
            {
<span class="fc bfc" id="L378" title="All 2 branches covered.">                for (PartitionUpdate update : mutation.getPartitionUpdates())</span>
                {
<span class="fc" id="L380">                    keySet.add(update.partitionKey());</span>

<span class="fc" id="L382">                    tableNames.add(update.metadata().toString());</span>
<span class="fc" id="L383">                }</span>
<span class="fc" id="L384">            }</span>

            // CASSANDRA-11529: log only if we have more than a threshold of keys, this was also suggested in the
            // original ticket that introduced this warning, CASSANDRA-9282
<span class="fc bfc" id="L388" title="All 2 branches covered.">            if (keySet.size() &gt; DatabaseDescriptor.getUnloggedBatchAcrossPartitionsWarnThreshold())</span>
            {
<span class="fc" id="L390">                NoSpamLogger.log(logger, NoSpamLogger.Level.WARN, 1, TimeUnit.MINUTES, UNLOGGED_BATCH_WARNING,</span>
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">                                 keySet.size(), tableNames.size() == 1 ? &quot;&quot; : &quot;s&quot;, tableNames);</span>

<span class="fc" id="L393">                ClientWarn.instance.warn(MessageFormatter.arrayFormat(UNLOGGED_BATCH_WARNING, new Object[]{keySet.size(),</span>
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">                                                    tableNames.size() == 1 ? &quot;&quot; : &quot;s&quot;, tableNames}).getMessage());</span>
            }
        }
<span class="fc" id="L397">    }</span>


    public ResultMessage execute(QueryState queryState, QueryOptions options, long queryStartNanoTime)
    {
<span class="fc" id="L402">        return execute(queryState, BatchQueryOptions.withoutPerStatementVariables(options), queryStartNanoTime);</span>
    }

    public ResultMessage execute(QueryState queryState, BatchQueryOptions options, long queryStartNanoTime)
    {
<span class="fc" id="L407">        long timestamp = options.getTimestamp(queryState);</span>
<span class="fc" id="L408">        long nowInSeconds = options.getNowInSeconds(queryState);</span>

<span class="pc bpc" id="L410" title="1 of 2 branches missed.">        if (options.getConsistency() == null)</span>
<span class="nc" id="L411">            throw new InvalidRequestException(&quot;Invalid empty consistency level&quot;);</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">        if (options.getSerialConsistency() == null)</span>
<span class="nc" id="L413">            throw new InvalidRequestException(&quot;Invalid empty serial consistency level&quot;);</span>

<span class="fc" id="L415">        ClientState clientState = queryState.getClientState();</span>
<span class="fc" id="L416">        Guardrails.writeConsistencyLevels.guard(EnumSet.of(options.getConsistency(), options.getSerialConsistency()),</span>
                                                clientState);

<span class="fc bfc" id="L419" title="All 2 branches covered.">        for (int i = 0; i &lt; statements.size(); i++ )</span>
<span class="fc" id="L420">            statements.get(i).validateDiskUsage(options.forStatement(i), clientState);</span>

<span class="fc bfc" id="L422" title="All 2 branches covered.">        if (hasConditions)</span>
<span class="fc" id="L423">            return executeWithConditions(options, queryState, queryStartNanoTime);</span>

<span class="pc bpc" id="L425" title="1 of 2 branches missed.">        if (updatesVirtualTables)</span>
<span class="nc" id="L426">            executeInternalWithoutCondition(queryState, options, queryStartNanoTime);</span>
        else    
<span class="fc" id="L428">            executeWithoutConditions(getMutations(clientState, options, false, timestamp, nowInSeconds, queryStartNanoTime),</span>
<span class="fc" id="L429">                                     options.getConsistency(), queryStartNanoTime);</span>

<span class="fc" id="L431">        return new ResultMessage.Void();</span>
    }

    private void executeWithoutConditions(List&lt;? extends IMutation&gt; mutations, ConsistencyLevel cl, long queryStartNanoTime) throws RequestExecutionException, RequestValidationException
    {
<span class="fc bfc" id="L436" title="All 2 branches covered.">        if (mutations.isEmpty())</span>
<span class="fc" id="L437">            return;</span>

<span class="fc" id="L439">        verifyBatchSize(mutations);</span>
<span class="fc" id="L440">        verifyBatchType(mutations);</span>

<span class="fc" id="L442">        updatePartitionsPerBatchMetrics(mutations.size());</span>

<span class="fc bfc" id="L444" title="All 4 branches covered.">        boolean mutateAtomic = (isLogged() &amp;&amp; mutations.size() &gt; 1);</span>
<span class="fc" id="L445">        StorageProxy.mutateWithTriggers(mutations, cl, mutateAtomic, queryStartNanoTime);</span>
<span class="fc" id="L446">        ClientRequestSizeMetrics.recordRowAndColumnCountMetrics(mutations);</span>
<span class="fc" id="L447">    }</span>

    private void updatePartitionsPerBatchMetrics(int updatedPartitions)
    {
<span class="fc bfc" id="L451" title="All 2 branches covered.">        if (isLogged()) {</span>
<span class="fc" id="L452">            metrics.partitionsPerLoggedBatch.update(updatedPartitions);</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">        } else if (isCounter()) {</span>
<span class="fc" id="L454">            metrics.partitionsPerCounterBatch.update(updatedPartitions);</span>
        } else {
<span class="fc" id="L456">            metrics.partitionsPerUnloggedBatch.update(updatedPartitions);</span>
        }
<span class="fc" id="L458">    }</span>

    private ResultMessage executeWithConditions(BatchQueryOptions options, QueryState state, long queryStartNanoTime)
    {
<span class="fc" id="L462">        Pair&lt;CQL3CasRequest, Set&lt;ColumnMetadata&gt;&gt; p = makeCasRequest(options, state);</span>
<span class="fc" id="L463">        CQL3CasRequest casRequest = p.left;</span>
<span class="fc" id="L464">        Set&lt;ColumnMetadata&gt; columnsWithConditions = p.right;</span>

<span class="fc" id="L466">        String ksName = casRequest.metadata.keyspace;</span>
<span class="fc" id="L467">        String tableName = casRequest.metadata.name;</span>

<span class="fc" id="L469">        try (RowIterator result = StorageProxy.cas(ksName,</span>
                                                   tableName,
                                                   casRequest.key,
                                                   casRequest,
<span class="fc" id="L473">                                                   options.getSerialConsistency(),</span>
<span class="fc" id="L474">                                                   options.getConsistency(),</span>
<span class="fc" id="L475">                                                   state.getClientState(),</span>
<span class="fc" id="L476">                                                   options.getNowInSeconds(state),</span>
                                                   queryStartNanoTime))
        {
<span class="fc" id="L479">            return new ResultMessage.Rows(ModificationStatement.buildCasResultSet(ksName,</span>
                                                                                  tableName,
                                                                                  result,
                                                                                  columnsWithConditions,
                                                                                  true,
                                                                                  state,
<span class="fc" id="L485">                                                                                  options.forStatement(0)));</span>
        }
    }

    private Pair&lt;CQL3CasRequest,Set&lt;ColumnMetadata&gt;&gt; makeCasRequest(BatchQueryOptions options, QueryState state)
    {
<span class="fc" id="L491">        long batchTimestamp = options.getTimestamp(state);</span>
<span class="fc" id="L492">        long nowInSeconds = options.getNowInSeconds(state);</span>
<span class="fc" id="L493">        DecoratedKey key = null;</span>
<span class="fc" id="L494">        CQL3CasRequest casRequest = null;</span>
<span class="fc" id="L495">        Set&lt;ColumnMetadata&gt; columnsWithConditions = new LinkedHashSet&lt;&gt;();</span>

<span class="fc bfc" id="L497" title="All 2 branches covered.">        for (int i = 0; i &lt; statements.size(); i++)</span>
        {
<span class="fc" id="L499">            ModificationStatement statement = statements.get(i);</span>
<span class="fc" id="L500">            QueryOptions statementOptions = options.forStatement(i);</span>
<span class="fc" id="L501">            long timestamp = attrs.getTimestamp(batchTimestamp, statementOptions);</span>
<span class="fc" id="L502">            List&lt;ByteBuffer&gt; pks = statement.buildPartitionKeyNames(statementOptions, state.getClientState());</span>
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">            if (statement.getRestrictions().keyIsInRelation())</span>
<span class="nc" id="L504">                throw new IllegalArgumentException(&quot;Batch with conditions cannot span multiple partitions (you cannot use IN on the partition key)&quot;);</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">            if (key == null)</span>
            {
<span class="fc" id="L507">                key = statement.metadata().partitioner.decorateKey(pks.get(0));</span>
<span class="fc" id="L508">                casRequest = new CQL3CasRequest(statement.metadata(), key, conditionColumns, updatesRegularRows, updatesStaticRow);</span>
            }
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">            else if (!key.getKey().equals(pks.get(0)))</span>
            {
<span class="nc" id="L512">                throw new InvalidRequestException(&quot;Batch with conditions cannot span multiple partitions&quot;);</span>
            }

<span class="fc" id="L515">            checkFalse(statement.getRestrictions().clusteringKeyRestrictionsHasIN(),</span>
                       &quot;IN on the clustering key columns is not supported with conditional %s&quot;,
<span class="fc bfc" id="L517" title="All 2 branches covered.">                       statement.type.isUpdate()? &quot;updates&quot; : &quot;deletions&quot;);</span>

<span class="pc bpc" id="L519" title="1 of 2 branches missed.">            if (statement.hasSlices())</span>
            {
                // All of the conditions require meaningful Clustering, not Slices
<span class="nc bnc" id="L522" title="All 2 branches missed.">                assert !statement.hasConditions();</span>

<span class="nc" id="L524">                Slices slices = statement.createSlices(statementOptions);</span>
                // If all the ranges were invalid we do not need to do anything.
<span class="nc bnc" id="L526" title="All 2 branches missed.">                if (slices.isEmpty())</span>
<span class="nc" id="L527">                    continue;</span>

<span class="nc bnc" id="L529" title="All 2 branches missed.">                for (Slice slice : slices)</span>
                {
<span class="nc" id="L531">                    casRequest.addRangeDeletion(slice, statement, statementOptions, timestamp, nowInSeconds);</span>
<span class="nc" id="L532">                }</span>

<span class="nc" id="L534">            }</span>
            else
            {
<span class="fc" id="L537">                Clustering&lt;?&gt; clustering = Iterables.getOnlyElement(statement.createClustering(statementOptions, state.getClientState()));</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">                if (statement.hasConditions())</span>
                {
<span class="fc" id="L540">                    statement.addConditions(clustering, casRequest, statementOptions);</span>
                    // As soon as we have a ifNotExists, we set columnsWithConditions to null so that everything is in the resultSet
<span class="pc bpc" id="L542" title="1 of 4 branches missed.">                    if (statement.hasIfNotExistCondition() || statement.hasIfExistCondition())</span>
<span class="fc" id="L543">                        columnsWithConditions = null;</span>
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">                    else if (columnsWithConditions != null)</span>
<span class="fc" id="L545">                        Iterables.addAll(columnsWithConditions, statement.getColumnsWithConditions());</span>
                }
<span class="fc" id="L547">                casRequest.addRowUpdate(clustering, statement, statementOptions, timestamp, nowInSeconds);</span>
            }
        }

<span class="fc" id="L551">        return Pair.create(casRequest, columnsWithConditions);</span>
    }

    public boolean hasConditions()
    {
<span class="fc" id="L556">        return hasConditions;</span>
    }

    public ResultMessage executeLocally(QueryState queryState, QueryOptions options) throws RequestValidationException, RequestExecutionException
    {
<span class="nc" id="L561">        BatchQueryOptions batchOptions = BatchQueryOptions.withoutPerStatementVariables(options);</span>

<span class="nc bnc" id="L563" title="All 2 branches missed.">        if (hasConditions)</span>
<span class="nc" id="L564">            return executeInternalWithConditions(batchOptions, queryState);</span>

<span class="nc" id="L566">        executeInternalWithoutCondition(queryState, batchOptions, nanoTime());</span>
<span class="nc" id="L567">        return new ResultMessage.Void();</span>
    }

    private ResultMessage executeInternalWithoutCondition(QueryState queryState, BatchQueryOptions batchOptions, long queryStartNanoTime)
    {
<span class="nc" id="L572">        long timestamp = batchOptions.getTimestamp(queryState);</span>
<span class="nc" id="L573">        long nowInSeconds = batchOptions.getNowInSeconds(queryState);</span>

<span class="nc bnc" id="L575" title="All 2 branches missed.">        for (IMutation mutation : getMutations(queryState.getClientState(), batchOptions, true, timestamp, nowInSeconds, queryStartNanoTime))</span>
<span class="nc" id="L576">            mutation.apply();</span>
<span class="nc" id="L577">        return null;</span>
    }

    private ResultMessage executeInternalWithConditions(BatchQueryOptions options, QueryState state)
    {
<span class="nc" id="L582">        Pair&lt;CQL3CasRequest, Set&lt;ColumnMetadata&gt;&gt; p = makeCasRequest(options, state);</span>
<span class="nc" id="L583">        CQL3CasRequest request = p.left;</span>
<span class="nc" id="L584">        Set&lt;ColumnMetadata&gt; columnsWithConditions = p.right;</span>

<span class="nc" id="L586">        String ksName = request.metadata.keyspace;</span>
<span class="nc" id="L587">        String tableName = request.metadata.name;</span>

<span class="nc" id="L589">        long timestamp = options.getTimestamp(state);</span>
<span class="nc" id="L590">        long nowInSeconds = options.getNowInSeconds(state);</span>

<span class="nc" id="L592">        try (RowIterator result = ModificationStatement.casInternal(state.getClientState(), request, timestamp, nowInSeconds))</span>
        {
<span class="nc" id="L594">            ResultSet resultSet =</span>
<span class="nc" id="L595">                ModificationStatement.buildCasResultSet(ksName,</span>
                                                        tableName,
                                                        result,
                                                        columnsWithConditions,
                                                        true,
                                                        state,
<span class="nc" id="L601">                                                        options.forStatement(0));</span>
<span class="nc" id="L602">            return new ResultMessage.Rows(resultSet);</span>
        }
    }

    public String toString()
    {
<span class="nc" id="L608">        return String.format(&quot;BatchStatement(type=%s, statements=%s)&quot;, type, statements);</span>
    }

    public static class Parsed extends QualifiedStatement
    {
        private final Type type;
        private final Attributes.Raw attrs;
        private final List&lt;ModificationStatement.Parsed&gt; parsedStatements;

        public Parsed(Type type, Attributes.Raw attrs, List&lt;ModificationStatement.Parsed&gt; parsedStatements)
        {
<span class="fc" id="L619">            super(null);</span>
<span class="fc" id="L620">            this.type = type;</span>
<span class="fc" id="L621">            this.attrs = attrs;</span>
<span class="fc" id="L622">            this.parsedStatements = parsedStatements;</span>
<span class="fc" id="L623">        }</span>

        // Not doing this in the constructor since we only need this for prepared statements
        @Override
        public boolean isFullyQualified()
        {
<span class="pc bpc" id="L629" title="1 of 2 branches missed.">            for (ModificationStatement.Parsed statement : parsedStatements)</span>
<span class="pc bpc" id="L630" title="1 of 2 branches missed.">                if (!statement.isFullyQualified())</span>
<span class="fc" id="L631">                    return false;</span>

<span class="nc" id="L633">            return true;</span>
        }

        @Override
        public void setKeyspace(ClientState state) throws InvalidRequestException
        {
<span class="fc bfc" id="L639" title="All 2 branches covered.">            for (ModificationStatement.Parsed statement : parsedStatements)</span>
<span class="fc" id="L640">                statement.setKeyspace(state);</span>
<span class="fc" id="L641">        }</span>

        @Override
        public String keyspace()
        {
<span class="fc" id="L646">            return null;</span>
        }

        public BatchStatement prepare(ClientState state)
        {
<span class="fc" id="L651">            List&lt;ModificationStatement&gt; statements = new ArrayList&lt;&gt;(parsedStatements.size());</span>
<span class="fc" id="L652">            parsedStatements.forEach(s -&gt; statements.add(s.prepare(state, bindVariables)));</span>

<span class="fc" id="L654">            Attributes prepAttrs = attrs.prepare(&quot;[batch]&quot;, &quot;[batch]&quot;);</span>
<span class="fc" id="L655">            prepAttrs.collectMarkerSpecification(bindVariables);</span>

<span class="fc" id="L657">            BatchStatement batchStatement = new BatchStatement(type, bindVariables, statements, prepAttrs);</span>
<span class="fc" id="L658">            batchStatement.validate();</span>

<span class="fc" id="L660">            return batchStatement;</span>
        }
    }

<span class="fc" id="L664">    private static class MultiTableColumnsBuilder</span>
    {
<span class="fc" id="L666">        private final Map&lt;TableId, RegularAndStaticColumns.Builder&gt; perTableBuilders = new HashMap&lt;&gt;();</span>

        public void addAll(TableMetadata table, RegularAndStaticColumns columns)
        {
<span class="fc" id="L670">            RegularAndStaticColumns.Builder builder = perTableBuilders.get(table.id);</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">            if (builder == null)</span>
            {
<span class="fc" id="L673">                builder = RegularAndStaticColumns.builder();</span>
<span class="fc" id="L674">                perTableBuilders.put(table.id, builder);</span>
            }
<span class="fc" id="L676">            builder.addAll(columns);</span>
<span class="fc" id="L677">        }</span>

        public Map&lt;TableId, RegularAndStaticColumns&gt; build()
        {
<span class="fc" id="L681">            Map&lt;TableId, RegularAndStaticColumns&gt; m = Maps.newHashMapWithExpectedSize(perTableBuilders.size());</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">            for (Map.Entry&lt;TableId, RegularAndStaticColumns.Builder&gt; p : perTableBuilders.entrySet())</span>
<span class="fc" id="L683">                m.put(p.getKey(), p.getValue().build());</span>
<span class="fc" id="L684">            return m;</span>
        }
    }

    @Override
    public AuditLogContext getAuditLogContext()
    {
<span class="nc" id="L691">        return new AuditLogContext(AuditLogEntryType.BATCH);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>