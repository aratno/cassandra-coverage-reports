<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SSTableContext.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.index.sai</a> &gt; <span class="el_source">SSTableContext.java</span></div><h1>SSTableContext.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.index.sai;

import java.util.Collections;

import com.google.common.base.Objects;

import org.apache.cassandra.index.sai.disk.PrimaryKeyMap;
import org.apache.cassandra.index.sai.disk.SSTableIndex;
import org.apache.cassandra.index.sai.disk.format.IndexDescriptor;
import org.apache.cassandra.io.sstable.Descriptor;
import org.apache.cassandra.io.sstable.format.SSTableReader;
import org.apache.cassandra.utils.Throwables;
import org.apache.cassandra.utils.concurrent.Ref;
import org.apache.cassandra.utils.concurrent.RefCounted;
import org.apache.cassandra.utils.concurrent.SharedCloseableImpl;

/**
 * An {@link SSTableContext} is created for an individual sstable and is shared across column indexes to track per-sstable
 * index files.
 * &lt;p&gt;
 * The {@link SSTableContext} will be released when receiving a sstable removed notification, but its shared copies in
 * individual {@link SSTableIndex}es will be released when in-flight read requests complete.
 */
public class SSTableContext extends SharedCloseableImpl
{
    public final SSTableReader sstable;
    public final IndexDescriptor indexDescriptor;
    public final PrimaryKeyMap.Factory primaryKeyMapFactory;

    private SSTableContext(SSTableReader sstable,
                           IndexDescriptor indexDescriptor,
                           PrimaryKeyMap.Factory primaryKeyMapFactory,
                           Cleanup cleanup)
    {
<span class="nc" id="L52">        super(cleanup);</span>
<span class="nc" id="L53">        this.sstable = sstable;</span>
<span class="nc" id="L54">        this.indexDescriptor = indexDescriptor;</span>
<span class="nc" id="L55">        this.primaryKeyMapFactory = primaryKeyMapFactory;</span>
<span class="nc" id="L56">    }</span>

    private SSTableContext(SSTableContext copy)
    {
<span class="nc" id="L60">        super(copy);</span>
<span class="nc" id="L61">        this.sstable = copy.sstable;</span>
<span class="nc" id="L62">        this.indexDescriptor = copy.indexDescriptor;</span>
<span class="nc" id="L63">        this.primaryKeyMapFactory = copy.primaryKeyMapFactory;</span>
<span class="nc" id="L64">    }</span>

    @SuppressWarnings({&quot;resource&quot;, &quot;RedundantSuppression&quot;})
    public static SSTableContext create(SSTableReader sstable)
    {
<span class="nc" id="L69">        Ref&lt;? extends SSTableReader&gt; sstableRef = null;</span>
<span class="nc" id="L70">        PrimaryKeyMap.Factory primaryKeyMapFactory = null;</span>

<span class="nc" id="L72">        IndexDescriptor indexDescriptor = IndexDescriptor.create(sstable);</span>
        try
        {
<span class="nc" id="L75">            sstableRef = sstable.tryRef();</span>

<span class="nc bnc" id="L77" title="All 2 branches missed.">            if (sstableRef == null)</span>
            {
<span class="nc" id="L79">                throw new IllegalStateException(&quot;Couldn't acquire reference to the sstable: &quot; + sstable);</span>
            }

<span class="nc" id="L82">            primaryKeyMapFactory = indexDescriptor.newPrimaryKeyMapFactory(sstable);</span>

<span class="nc" id="L84">            Cleanup cleanup = new Cleanup(primaryKeyMapFactory, indexDescriptor, sstableRef);</span>

<span class="nc" id="L86">            return new SSTableContext(sstable, indexDescriptor, primaryKeyMapFactory, cleanup);</span>
        }
<span class="nc" id="L88">        catch (Throwable t)</span>
        {
<span class="nc bnc" id="L90" title="All 2 branches missed.">            if (sstableRef != null)</span>
            {
<span class="nc" id="L92">                sstableRef.release();</span>
            }

<span class="nc" id="L95">            throw Throwables.unchecked(Throwables.close(t, Collections.singleton(primaryKeyMapFactory)));</span>
        }
    }

    @Override
    public SSTableContext sharedCopy()
    {
<span class="nc" id="L102">        return new SSTableContext(this);</span>
    }

    /**
     * Returns a new {@link SSTableIndex} for a per-column index
     */
    public SSTableIndex newSSTableIndex(IndexContext indexContext)
    {
<span class="nc" id="L110">        return indexDescriptor.newSSTableIndex(this, indexContext);</span>
    }

    /**
     * @return descriptor of attached sstable
     */
    public Descriptor descriptor()
    {
<span class="nc" id="L118">        return sstable.descriptor;</span>
    }

    /**
     * @return disk usage (in bytes) of per-sstable index files
     */
    public long diskUsage()
    {
<span class="nc" id="L126">        return indexDescriptor.sizeOnDiskOfPerSSTableComponents();</span>
    }

    /**
     * @return number of open files per {@link SSTableContext} instance
     */
    public int openFilesPerSSTable()
    {
<span class="nc" id="L134">        return indexDescriptor.version.onDiskFormat().openFilesPerSSTableIndex(indexDescriptor.hasClustering());</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L140">        return &quot;SSTableContext{&quot; +</span>
               &quot;sstable=&quot; + sstable.descriptor +
               '}';
    }

    @Override
    public boolean equals(Object o)
    {
<span class="nc bnc" id="L148" title="All 2 branches missed.">        if (this == o) return true;</span>
<span class="nc bnc" id="L149" title="All 4 branches missed.">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="nc" id="L150">        SSTableContext that = (SSTableContext) o;</span>
<span class="nc" id="L151">        return Objects.equal(sstable.descriptor, that.sstable.descriptor);</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L157">        return Objects.hashCode(sstable.descriptor.hashCode());</span>
    }

    private static class Cleanup implements RefCounted.Tidy
    {
        private final PrimaryKeyMap.Factory primaryKeyMapFactory;
        private final IndexDescriptor indexDescriptor;
        private final Ref&lt;? extends SSTableReader&gt; sstableRef;

        private Cleanup(PrimaryKeyMap.Factory primaryKeyMapFactory,
                        IndexDescriptor indexDescriptor,
                        Ref&lt;? extends SSTableReader&gt; sstableRef)
<span class="nc" id="L169">        {</span>
<span class="nc" id="L170">            this.primaryKeyMapFactory = primaryKeyMapFactory;</span>
<span class="nc" id="L171">            this.indexDescriptor = indexDescriptor;</span>
<span class="nc" id="L172">            this.sstableRef = sstableRef;</span>
<span class="nc" id="L173">        }</span>

        @Override
        public void tidy()
        {
<span class="nc" id="L178">            Throwable t = sstableRef.ensureReleased(null);</span>
<span class="nc" id="L179">            t = Throwables.close(t, Collections.singleton(primaryKeyMapFactory));</span>

<span class="nc" id="L181">            Throwables.maybeFail(t);</span>
<span class="nc" id="L182">        }</span>

        @Override
        public String name()
        {
<span class="nc" id="L187">            return indexDescriptor.toString();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>