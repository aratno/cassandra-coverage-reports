<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CommitLogReplayer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.commitlog</a> &gt; <span class="el_source">CommitLogReplayer.java</span></div><h1>CommitLogReplayer.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cassandra.db.commitlog;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Predicate;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.Iterables;
import com.google.common.collect.Multimap;
import com.google.common.collect.Ordering;

import org.apache.cassandra.io.util.File;
import org.apache.commons.lang3.StringUtils;

import org.apache.cassandra.utils.concurrent.Future;
import org.cliffc.high_scale_lib.NonBlockingHashSet;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.concurrent.Stage;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.Keyspace;
import org.apache.cassandra.db.Mutation;
import org.apache.cassandra.db.SystemKeyspace;
import org.apache.cassandra.db.partitions.PartitionUpdate;
import org.apache.cassandra.io.sstable.format.SSTableReader;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.io.util.RandomAccessReader;
import org.apache.cassandra.schema.Schema;
import org.apache.cassandra.schema.SchemaConstants;
import org.apache.cassandra.schema.TableId;
import org.apache.cassandra.schema.TableMetadataRef;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.WrappedRunnable;

import static java.lang.String.format;
import static org.apache.cassandra.config.CassandraRelevantProperties.COMMITLOG_IGNORE_REPLAY_ERRORS;
import static org.apache.cassandra.config.CassandraRelevantProperties.COMMITLOG_MAX_OUTSTANDING_REPLAY_BYTES;
import static org.apache.cassandra.config.CassandraRelevantProperties.COMMITLOG_MAX_OUTSTANDING_REPLAY_COUNT;
import static org.apache.cassandra.config.CassandraRelevantProperties.COMMIT_LOG_REPLAY_LIST;

public class CommitLogReplayer implements CommitLogReadHandler
{
    @VisibleForTesting
<span class="fc" id="L66">    public static long MAX_OUTSTANDING_REPLAY_BYTES = COMMITLOG_MAX_OUTSTANDING_REPLAY_BYTES.getLong();</span>
    @VisibleForTesting
<span class="fc" id="L68">    public static MutationInitiator mutationInitiator = new MutationInitiator();</span>
<span class="fc" id="L69">    private static final Logger logger = LoggerFactory.getLogger(CommitLogReplayer.class);</span>
<span class="fc" id="L70">    private static final int MAX_OUTSTANDING_REPLAY_COUNT = COMMITLOG_MAX_OUTSTANDING_REPLAY_COUNT.getInt();</span>

    private final Set&lt;Keyspace&gt; keyspacesReplayed;
    private final Queue&lt;Future&lt;Integer&gt;&gt; futures;

    private final AtomicInteger replayedCount;
    private final Map&lt;TableId, IntervalSet&lt;CommitLogPosition&gt;&gt; cfPersisted;
    private final CommitLogPosition globalPosition;

    // Used to throttle speed of replay of mutations if we pass the max outstanding count
<span class="fc" id="L80">    private long pendingMutationBytes = 0;</span>

    private final ReplayFilter replayFilter;
    private final CommitLogArchiver archiver;

    @VisibleForTesting
    protected boolean sawCDCMutation;

    @VisibleForTesting
    protected CommitLogReader commitLogReader;

    CommitLogReplayer(CommitLog commitLog,
                      CommitLogPosition globalPosition,
                      Map&lt;TableId, IntervalSet&lt;CommitLogPosition&gt;&gt; cfPersisted,
                      ReplayFilter replayFilter)
<span class="fc" id="L95">    {</span>
<span class="fc" id="L96">        this.keyspacesReplayed = new NonBlockingHashSet&lt;&gt;();</span>
<span class="fc" id="L97">        this.futures = new ArrayDeque&lt;&gt;();</span>
        // count the number of replayed mutation. We don't really care about atomicity, but we need it to be a reference.
<span class="fc" id="L99">        this.replayedCount = new AtomicInteger();</span>
<span class="fc" id="L100">        this.cfPersisted = cfPersisted;</span>
<span class="fc" id="L101">        this.globalPosition = globalPosition;</span>
<span class="fc" id="L102">        this.replayFilter = replayFilter;</span>
<span class="fc" id="L103">        this.archiver = commitLog.archiver;</span>
<span class="fc" id="L104">        this.commitLogReader = new CommitLogReader();</span>
<span class="fc" id="L105">    }</span>

    public static CommitLogReplayer construct(CommitLog commitLog, UUID localHostId)
    {
        // compute per-CF and global replay intervals
<span class="fc" id="L110">        Map&lt;TableId, IntervalSet&lt;CommitLogPosition&gt;&gt; cfPersisted = new HashMap&lt;&gt;();</span>
<span class="fc" id="L111">        ReplayFilter replayFilter = ReplayFilter.create();</span>

<span class="fc bfc" id="L113" title="All 2 branches covered.">        for (ColumnFamilyStore cfs : ColumnFamilyStore.all())</span>
        {
            // but, if we've truncated the cf in question, then we need to need to start replay after the truncation
<span class="fc" id="L116">            CommitLogPosition truncatedAt = SystemKeyspace.getTruncatedPosition(cfs.metadata.id);</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">            if (truncatedAt != null)</span>
            {
                // Point in time restore is taken to mean that the tables need to be replayed even if they were
                // deleted at a later point in time. Any truncation record after that point must thus be cleared prior
                // to replay (CASSANDRA-9195).
<span class="fc" id="L122">                long restoreTime = commitLog.archiver.restorePointInTime;</span>
<span class="fc" id="L123">                long truncatedTime = SystemKeyspace.getTruncatedAt(cfs.metadata.id);</span>
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">                if (truncatedTime &gt; restoreTime)</span>
                {
<span class="nc bnc" id="L126" title="All 2 branches missed.">                    if (replayFilter.includes(cfs.metadata))</span>
                    {
<span class="nc" id="L128">                        logger.info(&quot;Restore point in time is before latest truncation of table {}.{}. Clearing truncation record.&quot;,</span>
                                    cfs.metadata.keyspace,
                                    cfs.metadata.name);
<span class="nc" id="L131">                        SystemKeyspace.removeTruncationRecord(cfs.metadata.id);</span>
<span class="nc" id="L132">                        truncatedAt = null;</span>
                    }
                }
            }

            IntervalSet&lt;CommitLogPosition&gt; filter;
<span class="fc" id="L138">            final CommitLogPosition snapshotPosition = commitLog.archiver.snapshotCommitLogPosition;</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">            if (snapshotPosition == CommitLogPosition.NONE)</span>
            {
                // normal path: snapshot position is not explicitly specified, find it from sstables
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">                if (!cfs.memtableWritesAreDurable())</span>
                {
<span class="fc" id="L144">                    filter = persistedIntervals(cfs.getLiveSSTables(), truncatedAt, localHostId);</span>
                }
                else
                {
<span class="nc bnc" id="L148" title="All 2 branches missed.">                    if (commitLog.archiver.restorePointInTime == Long.MAX_VALUE)</span>
                    {
                        // Normal restart, everything is persisted and restored by the memtable itself.
<span class="nc" id="L151">                        filter = new IntervalSet&lt;&gt;(CommitLogPosition.NONE, CommitLog.instance.getCurrentPosition());</span>
                    }
                    else
                    {
                        // Point-in-time restore with a persistent memtable. In this case user should have restored
                        // the memtable from a snapshot and specified that snapshot's commit log position, reaching
                        // the &quot;else&quot; path below.
                        // If they haven't, do not filter any commit log data -- this supports a mode of operation where
                        // the user deletes old archived commit log segments when a snapshot completes -- but issue a
                        // message as this may be inefficient / not what the user wants.
<span class="nc" id="L161">                        logger.info(&quot;Point-in-time restore on a persistent memtable started without a snapshot time. &quot; +</span>
                                    &quot;All commit log data will be replayed.&quot;);
<span class="nc" id="L163">                        filter = IntervalSet.empty();</span>
                    }
                }
            }
            else
            {
                // If the positions is specified, it must override whatever we calculate.
<span class="nc" id="L170">                filter = new IntervalSet&lt;&gt;(CommitLogPosition.NONE, snapshotPosition);</span>
            }
<span class="fc" id="L172">            cfPersisted.put(cfs.metadata.id, filter);</span>
<span class="fc" id="L173">        }</span>
<span class="fc" id="L174">        CommitLogPosition globalPosition = firstNotCovered(cfPersisted.values());</span>
<span class="fc" id="L175">        logger.debug(&quot;Global replay position is {} from columnfamilies {}&quot;, globalPosition, FBUtilities.toString(cfPersisted));</span>
<span class="fc" id="L176">        return new CommitLogReplayer(commitLog, globalPosition, cfPersisted, replayFilter);</span>
    }

    public void replayPath(File file, boolean tolerateTruncation) throws IOException
    {
<span class="nc" id="L181">        sawCDCMutation = false;</span>
<span class="nc" id="L182">        commitLogReader.readCommitLogSegment(this, file, globalPosition, CommitLogReader.ALL_MUTATIONS, tolerateTruncation);</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">        if (sawCDCMutation)</span>
<span class="nc" id="L184">            handleCDCReplayCompletion(file);</span>
<span class="nc" id="L185">    }</span>

    public void replayFiles(File[] clogs) throws IOException
    {
<span class="fc" id="L189">        List&lt;File&gt; filteredLogs = CommitLogReader.filterCommitLogFiles(clogs);</span>
<span class="fc" id="L190">        int i = 0;</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">        for (File file: filteredLogs)</span>
        {
<span class="fc" id="L193">            i++;</span>
<span class="fc" id="L194">            sawCDCMutation = false;</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">            commitLogReader.readCommitLogSegment(this, file, globalPosition, i == filteredLogs.size());</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">            if (sawCDCMutation)</span>
<span class="fc" id="L197">                handleCDCReplayCompletion(file);</span>
<span class="fc" id="L198">        }</span>
<span class="fc" id="L199">    }</span>


    /**
     * Upon replay completion, CDC needs to hard-link files in the CDC folder and calculate index files so consumers can
     * begin their work.
     */
    private void handleCDCReplayCompletion(File f) throws IOException
    {
        // Can only reach this point if CDC is enabled, thus we have a CDCSegmentManager
<span class="fc" id="L209">        ((CommitLogSegmentManagerCDC)CommitLog.instance.segmentManager).addCDCSize(f.length());</span>

<span class="fc" id="L211">        File dest = new File(DatabaseDescriptor.getCDCLogLocation(), f.name());</span>

        // If hard link already exists, assume it's from a previous node run. If people are mucking around in the cdc_raw
        // directory that's on them.
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">        if (!dest.exists())</span>
<span class="fc" id="L216">            FileUtils.createHardLink(f, dest);</span>

        // The reader has already verified we can deserialize the descriptor.
        CommitLogDescriptor desc;
<span class="fc" id="L220">        try(RandomAccessReader reader = RandomAccessReader.open(f))</span>
        {
<span class="fc" id="L222">            desc = CommitLogDescriptor.readHeader(reader, DatabaseDescriptor.getEncryptionContext());</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">            assert desc != null;</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">            assert f.length() &lt; Integer.MAX_VALUE;</span>
<span class="fc" id="L225">            CommitLogSegment.writeCDCIndexFile(desc, (int)f.length(), true);</span>
        }
<span class="fc" id="L227">    }</span>


    /**
     * Flushes all keyspaces associated with this replayer in parallel, blocking until their flushes are complete.
     * @return the number of mutations replayed
     */
    public int blockForWrites()
    {
<span class="fc bfc" id="L236" title="All 2 branches covered.">        for (Map.Entry&lt;TableId, AtomicInteger&gt; entry : commitLogReader.getInvalidMutations())</span>
<span class="fc" id="L237">            logger.warn(&quot;Skipped {} mutations from unknown (probably removed) CF with id {}&quot;, entry.getValue(), entry.getKey());</span>

        // wait for all the writes to finish on the mutation stage
<span class="fc" id="L240">        FBUtilities.waitOnFutures(futures);</span>
<span class="fc" id="L241">        logger.trace(&quot;Finished waiting on mutations from recovery&quot;);</span>

        // flush replayed keyspaces
<span class="fc" id="L244">        futures.clear();</span>
<span class="fc" id="L245">        boolean flushingSystem = false;</span>

<span class="fc" id="L247">        List&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;Future&lt;?&gt;&gt;();</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">        for (Keyspace keyspace : keyspacesReplayed)</span>
        {
<span class="fc bfc" id="L250" title="All 2 branches covered.">            if (keyspace.getName().equals(SchemaConstants.SYSTEM_KEYSPACE_NAME))</span>
<span class="fc" id="L251">                flushingSystem = true;</span>

<span class="fc" id="L253">            futures.addAll(keyspace.flush(ColumnFamilyStore.FlushReason.STARTUP));</span>
<span class="fc" id="L254">        }</span>

        // also flush batchlog incase of any MV updates
<span class="fc bfc" id="L257" title="All 2 branches covered.">        if (!flushingSystem)</span>
<span class="fc" id="L258">            futures.add(Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME)</span>
<span class="fc" id="L259">                                .getColumnFamilyStore(SystemKeyspace.BATCHES)</span>
<span class="fc" id="L260">                                .forceFlush(ColumnFamilyStore.FlushReason.INTERNALLY_FORCED));</span>

<span class="fc" id="L262">        FBUtilities.waitOnFutures(futures);</span>

<span class="fc" id="L264">        return replayedCount.get();</span>
    }

    /*
     * Wrapper around initiating mutations read from the log to make it possible
     * to spy on initiated mutations for test
     */
    @VisibleForTesting
<span class="fc" id="L272">    public static class MutationInitiator</span>
    {
        protected Future&lt;Integer&gt; initiateMutation(final Mutation mutation,
                                                   final long segmentId,
                                                   final int serializedSize,
                                                   final int entryLocation,
                                                   final CommitLogReplayer commitLogReplayer)
        {
<span class="fc" id="L280">            Runnable runnable = new WrappedRunnable()</span>
<span class="fc" id="L281">            {</span>
                public void runMayThrow()
                {
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">                    if (Schema.instance.getKeyspaceMetadata(mutation.getKeyspaceName()) == null)</span>
<span class="nc" id="L285">                        return;</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">                    if (commitLogReplayer.pointInTimeExceeded(mutation))</span>
<span class="nc" id="L287">                        return;</span>

<span class="fc" id="L289">                    final Keyspace keyspace = Keyspace.open(mutation.getKeyspaceName());</span>

                    // Rebuild the mutation, omitting column families that
                    //    a) the user has requested that we ignore,
                    //    b) have already been flushed,
                    // or c) are part of a cf that was dropped.
                    // Keep in mind that the cf.name() is suspect. do every thing based on the cfid instead.
<span class="fc" id="L296">                    Mutation.PartitionUpdateCollector newPUCollector = null;</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">                    for (PartitionUpdate update : commitLogReplayer.replayFilter.filter(mutation))</span>
                    {
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">                        if (Schema.instance.getTableMetadata(update.metadata().id) == null)</span>
<span class="nc" id="L300">                            continue; // dropped</span>

                        // replay if current segment is newer than last flushed one or,
                        // if it is the last known segment, if we are after the commit log segment position
<span class="fc bfc" id="L304" title="All 2 branches covered.">                        if (commitLogReplayer.shouldReplay(update.metadata().id, new CommitLogPosition(segmentId, entryLocation)))</span>
                        {
<span class="fc bfc" id="L306" title="All 2 branches covered.">                            if (newPUCollector == null)</span>
<span class="fc" id="L307">                                newPUCollector = new Mutation.PartitionUpdateCollector(mutation.getKeyspaceName(), mutation.key());</span>
<span class="fc" id="L308">                            newPUCollector.add(update);</span>
<span class="fc" id="L309">                            commitLogReplayer.replayedCount.incrementAndGet();</span>
                        }
<span class="fc" id="L311">                    }</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">                    if (newPUCollector != null)</span>
                    {
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">                        assert !newPUCollector.isEmpty();</span>

<span class="fc" id="L316">                        Keyspace.open(newPUCollector.getKeyspaceName()).apply(newPUCollector.build(), false, true, false);</span>
<span class="fc" id="L317">                        commitLogReplayer.keyspacesReplayed.add(keyspace);</span>
                    }
<span class="fc" id="L319">                }</span>
            };
<span class="fc" id="L321">            return Stage.MUTATION.submit(runnable, serializedSize);</span>
        }
    }

    /**
     * A set of known safe-to-discard commit log replay positions, based on
     * the range covered by on disk sstables and those prior to the most recent truncation record
     */
    public static IntervalSet&lt;CommitLogPosition&gt; persistedIntervals(Iterable&lt;SSTableReader&gt; onDisk,
                                                                    CommitLogPosition truncatedAt,
                                                                    UUID localhostId)
    {
<span class="fc" id="L333">        IntervalSet.Builder&lt;CommitLogPosition&gt; builder = new IntervalSet.Builder&lt;&gt;();</span>
<span class="fc" id="L334">        List&lt;String&gt; skippedSSTables = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">        for (SSTableReader reader : onDisk)</span>
        {
<span class="fc" id="L337">            UUID originatingHostId = reader.getSSTableMetadata().originatingHostId;</span>
<span class="fc bfc" id="L338" title="All 4 branches covered.">            if (originatingHostId != null &amp;&amp; originatingHostId.equals(localhostId))</span>
<span class="fc" id="L339">                builder.addAll(reader.getSSTableMetadata().commitLogIntervals);</span>
            else
<span class="fc" id="L341">                skippedSSTables.add(reader.getFilename());</span>
<span class="fc" id="L342">        }</span>

<span class="fc bfc" id="L344" title="All 2 branches covered.">        if (!skippedSSTables.isEmpty()) {</span>
<span class="fc" id="L345">            logger.warn(&quot;Origin of {} sstables is unknown or doesn't match the local node; commitLogIntervals for them were ignored&quot;, skippedSSTables.size());</span>
<span class="fc" id="L346">            logger.debug(&quot;Ignored commitLogIntervals from the following sstables: {}&quot;, skippedSSTables);</span>
        }

<span class="fc bfc" id="L349" title="All 2 branches covered.">        if (truncatedAt != null)</span>
<span class="fc" id="L350">            builder.add(CommitLogPosition.NONE, truncatedAt);</span>
<span class="fc" id="L351">        return builder.build();</span>
    }

    /**
     * Find the earliest commit log position that is not covered by the known flushed ranges for some table.
     *
     * For efficiency this assumes that the first contiguously flushed interval we know of contains the moment that the
     * given table was constructed* and hence we can start replay from the end of that interval.
     *
     * If such an interval is not known, we must replay from the beginning.
     *
     * * This is not true only until if the very first flush of a table stalled or failed, while the second or latter
     *   succeeded. The chances of this happening are at most very low, and if the assumption does prove to be
     *   incorrect during replay there is little chance that the affected deployment is in production.
     */
    public static CommitLogPosition firstNotCovered(Collection&lt;IntervalSet&lt;CommitLogPosition&gt;&gt; ranges)
    {
<span class="fc" id="L368">        return ranges.stream()</span>
<span class="fc" id="L369">                .map(intervals -&gt; Iterables.getFirst(intervals.ends(), CommitLogPosition.NONE))</span>
<span class="fc" id="L370">                .min(Ordering.natural())</span>
<span class="fc" id="L371">                .get(); // iteration is per known-CF, there must be at least one.</span>
    }

<span class="fc" id="L374">    abstract static class ReplayFilter</span>
    {
        public abstract Iterable&lt;PartitionUpdate&gt; filter(Mutation mutation);

        public abstract boolean includes(TableMetadataRef metadata);

        /**
         * Creates filter for entities to replay mutations for upon commit log replay.
         *
         * @see org.apache.cassandra.config.CassandraRelevantProperties#COMMIT_LOG_REPLAY_LIST
         * */
        public static ReplayFilter create()
        {
<span class="fc" id="L387">            String replayList = COMMIT_LOG_REPLAY_LIST.getString();</span>

<span class="pc bpc" id="L389" title="1 of 2 branches missed.">            if (replayList == null)</span>
<span class="fc" id="L390">                return new AlwaysReplayFilter();</span>

<span class="nc" id="L392">            Multimap&lt;String, String&gt; toReplay = HashMultimap.create();</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">            for (String rawPair : replayList.split(&quot;,&quot;))</span>
            {
<span class="nc" id="L395">                String trimmedRawPair = rawPair.trim();</span>
<span class="nc bnc" id="L396" title="All 4 branches missed.">                if (trimmedRawPair.isEmpty() || trimmedRawPair.endsWith(&quot;.&quot;))</span>
<span class="nc" id="L397">                    throw new IllegalArgumentException(format(&quot;Invalid pair: '%s'&quot;, trimmedRawPair));</span>

<span class="nc" id="L399">                String[] pair = StringUtils.split(trimmedRawPair, '.');</span>

<span class="nc bnc" id="L401" title="All 2 branches missed.">                if (pair.length &gt; 2)</span>
<span class="nc" id="L402">                    throw new IllegalArgumentException(format(&quot;%s property contains an item which &quot; +</span>
                                                              &quot;is not in format 'keyspace' or 'keyspace.table' &quot; +
                                                              &quot;but it is '%s'&quot;,
<span class="nc" id="L405">                                                              COMMIT_LOG_REPLAY_LIST.getKey(),</span>
<span class="nc" id="L406">                                                              String.join(&quot;.&quot;, pair)));</span>

<span class="nc" id="L408">                String keyspaceName = pair[0];</span>

<span class="nc" id="L410">                Keyspace ks = Schema.instance.getKeyspaceInstance(keyspaceName);</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">                if (ks == null)</span>
<span class="nc" id="L412">                    throw new IllegalArgumentException(&quot;Unknown keyspace &quot; + keyspaceName);</span>

<span class="nc bnc" id="L414" title="All 2 branches missed.">                if (pair.length == 1)</span>
                {
<span class="nc bnc" id="L416" title="All 2 branches missed.">                    for (ColumnFamilyStore cfs : ks.getColumnFamilyStores())</span>
<span class="nc" id="L417">                        toReplay.put(keyspaceName, cfs.name);</span>
                }
                else
                {
<span class="nc" id="L421">                    ColumnFamilyStore cfs = ks.getColumnFamilyStore(pair[1]);</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">                    if (cfs == null)</span>
<span class="nc" id="L423">                        throw new IllegalArgumentException(format(&quot;Unknown table %s.%s&quot;, keyspaceName, pair[1]));</span>

<span class="nc" id="L425">                    toReplay.put(keyspaceName, pair[1]);</span>
                }
            }

<span class="nc bnc" id="L429" title="All 2 branches missed.">            if (toReplay.isEmpty())</span>
<span class="nc" id="L430">                logger.info(&quot;All tables will be included in commit log replay.&quot;);</span>
            else
<span class="nc" id="L432">                logger.info(&quot;Tables to be replayed: {}&quot;, toReplay.asMap().toString());</span>

<span class="nc" id="L434">            return new CustomReplayFilter(toReplay);</span>
        }
    }

    private static class AlwaysReplayFilter extends ReplayFilter
    {
        public Iterable&lt;PartitionUpdate&gt; filter(Mutation mutation)
        {
<span class="fc" id="L442">            return mutation.getPartitionUpdates();</span>
        }

        public boolean includes(TableMetadataRef metadata)
        {
<span class="nc" id="L447">            return true;</span>
        }
    }

    private static class CustomReplayFilter extends ReplayFilter
    {
        private Multimap&lt;String, String&gt; toReplay;

        public CustomReplayFilter(Multimap&lt;String, String&gt; toReplay)
<span class="nc" id="L456">        {</span>
<span class="nc" id="L457">            this.toReplay = toReplay;</span>
<span class="nc" id="L458">        }</span>

        public Iterable&lt;PartitionUpdate&gt; filter(Mutation mutation)
        {
<span class="nc" id="L462">            final Collection&lt;String&gt; cfNames = toReplay.get(mutation.getKeyspaceName());</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">            if (cfNames == null)</span>
<span class="nc" id="L464">                return Collections.emptySet();</span>

<span class="nc" id="L466">            return Iterables.filter(mutation.getPartitionUpdates(), new Predicate&lt;PartitionUpdate&gt;()</span>
<span class="nc" id="L467">            {</span>
                public boolean apply(PartitionUpdate upd)
                {
<span class="nc" id="L470">                    return cfNames.contains(upd.metadata().name);</span>
                }
            });
        }

        public boolean includes(TableMetadataRef metadata)
        {
<span class="nc" id="L477">            return toReplay.containsEntry(metadata.keyspace, metadata.name);</span>
        }
    }

    /**
     * consult the known-persisted ranges for our sstables;
     * if the position is covered by one of them it does not need to be replayed
     *
     * @return true iff replay is necessary
     */
    private boolean shouldReplay(TableId tableId, CommitLogPosition position)
    {
<span class="fc bfc" id="L489" title="All 2 branches covered.">        return !cfPersisted.get(tableId).contains(position);</span>
    }

    protected boolean pointInTimeExceeded(Mutation fm)
    {
<span class="fc" id="L494">        long restoreTarget = archiver.restorePointInTime;</span>

<span class="fc bfc" id="L496" title="All 2 branches covered.">        for (PartitionUpdate upd : fm.getPartitionUpdates())</span>
        {
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">            if (archiver.precision.toMillis(upd.maxTimestamp()) &gt; restoreTarget)</span>
<span class="nc" id="L499">                return true;</span>
<span class="fc" id="L500">        }</span>
<span class="fc" id="L501">        return false;</span>
    }

    public void handleMutation(Mutation m, int size, int entryLocation, CommitLogDescriptor desc)
    {
<span class="fc bfc" id="L506" title="All 4 branches covered.">        if (DatabaseDescriptor.isCDCEnabled() &amp;&amp; m.trackedByCDC())</span>
<span class="fc" id="L507">            sawCDCMutation = true;</span>

<span class="fc" id="L509">        pendingMutationBytes += size;</span>
<span class="fc" id="L510">        futures.offer(mutationInitiator.initiateMutation(m,</span>
                                                         desc.id,
                                                         size,
                                                         entryLocation,
                                                         this));
        // If there are finished mutations, or too many outstanding bytes/mutations
        // drain the futures in the queue
<span class="pc bpc" id="L517" title="1 of 4 branches missed.">        while (futures.size() &gt; MAX_OUTSTANDING_REPLAY_COUNT</span>
               || pendingMutationBytes &gt; MAX_OUTSTANDING_REPLAY_BYTES
<span class="fc bfc" id="L519" title="All 4 branches covered.">               || (!futures.isEmpty() &amp;&amp; futures.peek().isDone()))</span>
        {
<span class="fc" id="L521">            pendingMutationBytes -= FBUtilities.waitOnFuture(futures.poll());</span>
        }
<span class="fc" id="L523">    }</span>

    public boolean shouldSkipSegmentOnError(CommitLogReadException exception) throws IOException
    {
<span class="nc bnc" id="L527" title="All 2 branches missed.">        if (exception.permissible)</span>
<span class="nc" id="L528">            logger.error(&quot;Ignoring commit log replay error likely due to incomplete flush to disk&quot;, exception);</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">        else if (COMMITLOG_IGNORE_REPLAY_ERRORS.getBoolean())</span>
<span class="nc" id="L530">            logger.error(&quot;Ignoring commit log replay error&quot;, exception);</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">        else if (!CommitLog.handleCommitError(&quot;Failed commit log replay&quot;, exception))</span>
        {
<span class="nc" id="L533">            logger.error(&quot;Replay stopped. If you wish to override this error and continue starting the node ignoring &quot; +</span>
                         &quot;commit log replay problems, specify -D{}=true on the command line&quot;,
<span class="nc" id="L535">                         COMMITLOG_IGNORE_REPLAY_ERRORS.getKey());</span>
<span class="nc" id="L536">            throw new CommitLogReplayException(exception.getMessage(), exception);</span>
        }
<span class="nc" id="L538">        return false;</span>
    }

    /**
     * The logic for whether or not we throw on an error is identical for the replayer between recoverable or non.
     */
    public void handleUnrecoverableError(CommitLogReadException exception) throws IOException
    {
        // Don't care about return value, use this simply to throw exception as appropriate.
<span class="nc" id="L547">        shouldSkipSegmentOnError(exception);</span>
<span class="nc" id="L548">    }</span>

    @SuppressWarnings(&quot;serial&quot;)
    public static class CommitLogReplayException extends IOException
    {
        public CommitLogReplayException(String message, Throwable cause)
        {
<span class="nc" id="L555">            super(message, cause);</span>
<span class="nc" id="L556">        }</span>

        public CommitLogReplayException(String message)
        {
<span class="nc" id="L560">            super(message);</span>
<span class="nc" id="L561">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>