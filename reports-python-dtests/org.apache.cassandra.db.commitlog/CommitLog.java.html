<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CommitLog.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.commitlog</a> &gt; <span class="el_source">CommitLog.java</span></div><h1>CommitLog.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.commitlog;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.file.FileStore;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.UUID;
import java.util.concurrent.TimeUnit;
import java.util.function.BiPredicate;
import java.util.function.Function;
import java.util.zip.CRC32;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.config.ParameterizedClass;
import org.apache.cassandra.db.Mutation;
import org.apache.cassandra.exceptions.CDCWriteException;
import org.apache.cassandra.io.FSWriteError;
import org.apache.cassandra.io.compress.ICompressor;
import org.apache.cassandra.io.util.BufferedDataOutputStreamPlus;
import org.apache.cassandra.io.util.DataOutputBuffer;
import org.apache.cassandra.io.util.DataOutputBufferFixed;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.io.util.PathUtils;
import org.apache.cassandra.metrics.CommitLogMetrics;
import org.apache.cassandra.net.MessagingService;
import org.apache.cassandra.schema.CompressionParams;
import org.apache.cassandra.schema.TableId;
import org.apache.cassandra.security.EncryptionContext;
import org.apache.cassandra.service.StorageService;
import org.apache.cassandra.utils.JVMStabilityInspector;
import org.apache.cassandra.utils.MBeanWrapper;
import org.apache.cassandra.utils.concurrent.UncheckedInterruptedException;

import static org.apache.cassandra.db.commitlog.CommitLogSegment.Allocation;
import static org.apache.cassandra.db.commitlog.CommitLogSegment.ENTRY_OVERHEAD_SIZE;
import static org.apache.cassandra.utils.FBUtilities.updateChecksum;
import static org.apache.cassandra.utils.FBUtilities.updateChecksumInt;

/*
 * Commit Log tracks every write operation into the system. The aim of the commit log is to be able to
 * successfully recover data that was not stored to disk via the Memtable.
 */
public class CommitLog implements CommitLogMBean
{
<span class="fc" id="L75">    private static final Logger logger = LoggerFactory.getLogger(CommitLog.class);</span>

<span class="fc" id="L77">    public static final CommitLog instance = CommitLog.construct();</span>

<span class="pc bpc" id="L79" title="1 of 4 branches missed.">    private static final BiPredicate&lt;File, String&gt; unmanagedFilesFilter = (dir, name) -&gt; CommitLogDescriptor.isValid(name) &amp;&amp; CommitLogSegment.shouldReplay(name);</span>

    final public AbstractCommitLogSegmentManager segmentManager;

    public final CommitLogArchiver archiver;
    public final CommitLogMetrics metrics;
    final AbstractCommitLogService executor;

    volatile Configuration configuration;
<span class="fc" id="L88">    private boolean started = false;</span>

    private static CommitLog construct()
    {
<span class="fc" id="L92">        CommitLog log = new CommitLog(CommitLogArchiver.construct(), DatabaseDescriptor.getCommitLogSegmentMgrProvider());</span>
<span class="fc" id="L93">        MBeanWrapper.instance.registerMBean(log, &quot;org.apache.cassandra.db:type=Commitlog&quot;);</span>
<span class="fc" id="L94">        return log;</span>
    }

    @VisibleForTesting
    CommitLog(CommitLogArchiver archiver)
    {
<span class="nc" id="L100">        this(archiver, DatabaseDescriptor.getCommitLogSegmentMgrProvider());</span>
<span class="nc" id="L101">    }</span>

    @VisibleForTesting
    CommitLog(CommitLogArchiver archiver, Function&lt;CommitLog, AbstractCommitLogSegmentManager&gt; segmentManagerProvider)
<span class="fc" id="L105">    {</span>
<span class="fc" id="L106">        this.configuration = new Configuration(DatabaseDescriptor.getCommitLogCompression(),</span>
<span class="fc" id="L107">                                               DatabaseDescriptor.getEncryptionContext());</span>
<span class="fc" id="L108">        DatabaseDescriptor.createAllDirectories();</span>

<span class="fc" id="L110">        this.archiver = archiver;</span>
<span class="fc" id="L111">        metrics = new CommitLogMetrics();</span>

<span class="pc bpc" id="L113" title="2 of 4 branches missed.">        switch (DatabaseDescriptor.getCommitLogSync())</span>
        {
            case periodic:
<span class="fc" id="L116">                executor = new PeriodicCommitLogService(this);</span>
<span class="fc" id="L117">                break;</span>
            case batch:
<span class="fc" id="L119">                executor = new BatchCommitLogService(this);</span>
<span class="fc" id="L120">                break;</span>
            case group:
<span class="nc" id="L122">                executor = new GroupCommitLogService(this);</span>
<span class="nc" id="L123">                break;</span>
            default:
<span class="nc" id="L125">                throw new IllegalArgumentException(&quot;Unknown commitlog service type: &quot; + DatabaseDescriptor.getCommitLogSync());</span>
        }

<span class="fc" id="L128">        segmentManager = segmentManagerProvider.apply(this);</span>

        // register metrics
<span class="fc" id="L131">        metrics.attach(executor, segmentManager);</span>
<span class="fc" id="L132">    }</span>

    /**
     * Tries to start the CommitLog if not already started.
     */
    synchronized public CommitLog start()
    {
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">        if (started)</span>
<span class="nc" id="L140">            return this;</span>

        try
        {
<span class="fc" id="L144">            segmentManager.start();</span>
<span class="fc" id="L145">            executor.start();</span>
<span class="fc" id="L146">            started = true;</span>
<span class="nc" id="L147">        } catch (Throwable t)</span>
        {
<span class="nc" id="L149">            started = false;</span>
<span class="nc" id="L150">            throw t;</span>
<span class="fc" id="L151">        }</span>
<span class="fc" id="L152">        return this;</span>
    }

    public boolean isStarted()
    {
<span class="fc" id="L157">        return started;</span>
    }

    public boolean hasFilesToReplay()
    {
<span class="fc bfc" id="L162" title="All 2 branches covered.">        return getUnmanagedFiles().length &gt; 0;</span>
    }

    private File[] getUnmanagedFiles()
    {
<span class="fc" id="L167">        File[] files = new File(segmentManager.storageDirectory).tryList(unmanagedFilesFilter);</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        if (files == null)</span>
<span class="nc" id="L169">            return new File[0];</span>
<span class="fc" id="L170">        return files;</span>
    }

    /**
     * Perform recovery on commit logs located in the directory specified by the config file.
     *
     * @return the number of mutations replayed
     * @throws IOException
     */
    public int recoverSegmentsOnDisk() throws IOException
    {
        // submit all files for this segment manager for archiving prior to recovery - CASSANDRA-6904
        // The files may have already been archived by normal CommitLog operation. This may cause errors in this
        // archiving pass, which we should not treat as serious.
<span class="fc bfc" id="L184" title="All 2 branches covered.">        for (File file : getUnmanagedFiles())</span>
        {
<span class="fc" id="L186">            archiver.maybeArchive(file.path(), file.name());</span>
<span class="fc" id="L187">            archiver.maybeWaitForArchiving(file.name());</span>
        }

<span class="pc bpc" id="L190" title="1 of 2 branches missed.">        assert archiver.archivePending.isEmpty() : &quot;Not all commit log archive tasks were completed before restore&quot;;</span>
<span class="fc" id="L191">        archiver.maybeRestoreArchive();</span>

        // List the files again as archiver may have added segments.
<span class="fc" id="L194">        File[] files = getUnmanagedFiles();</span>
<span class="fc" id="L195">        int replayed = 0;</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">        if (files.length == 0)</span>
        {
<span class="fc" id="L198">            logger.info(&quot;No commitlog files found; skipping replay&quot;);</span>
        }
        else
        {
<span class="fc" id="L202">            Arrays.sort(files, new CommitLogSegment.CommitLogSegmentFileComparator());</span>
<span class="fc" id="L203">            logger.info(&quot;Replaying {}&quot;, StringUtils.join(files, &quot;, &quot;));</span>
<span class="fc" id="L204">            replayed = recoverFiles(files);</span>
<span class="fc" id="L205">            logger.info(&quot;Log replay complete, {} replayed mutations&quot;, replayed);</span>

<span class="fc bfc" id="L207" title="All 2 branches covered.">            for (File f : files)</span>
<span class="fc" id="L208">                segmentManager.handleReplayedSegment(f);</span>
        }

<span class="fc" id="L211">        return replayed;</span>
    }

    /**
     * Perform recovery on a list of commit log files.
     *
     * @param clogs   the list of commit log files to replay
     * @return the number of mutations replayed
     */
    public int recoverFiles(File... clogs) throws IOException
    {
<span class="fc" id="L222">        CommitLogReplayer replayer = CommitLogReplayer.construct(this, getLocalHostId());</span>
<span class="fc" id="L223">        replayer.replayFiles(clogs);</span>
<span class="fc" id="L224">        return replayer.blockForWrites();</span>
    }

    public void recoverPath(String path) throws IOException
    {
<span class="nc" id="L229">        CommitLogReplayer replayer = CommitLogReplayer.construct(this, getLocalHostId());</span>
<span class="nc" id="L230">        replayer.replayPath(new File(path), false);</span>
<span class="nc" id="L231">        replayer.blockForWrites();</span>
<span class="nc" id="L232">    }</span>

    private static UUID getLocalHostId()
    {
<span class="fc" id="L236">        return StorageService.instance.getLocalHostUUID();</span>
    }

    /**
     * Perform recovery on a single commit log. Kept w/sub-optimal name due to coupling w/MBean / JMX
     */
    public void recover(String path) throws IOException
    {
<span class="nc" id="L244">        recoverPath(path);</span>
<span class="nc" id="L245">    }</span>

    /**
     * @return a CommitLogPosition which, if {@code &gt;= one} returned from add(), implies add() was started
     * (but not necessarily finished) prior to this call
     */
    public CommitLogPosition getCurrentPosition()
    {
<span class="fc" id="L253">        return segmentManager.getCurrentPosition();</span>
    }

    /**
     * Flushes all dirty CFs, waiting for them to free and recycle any segments they were retaining
     */
    public void forceRecycleAllSegments(Collection&lt;TableId&gt; droppedTables)
    {
<span class="fc" id="L261">        segmentManager.forceRecycleAll(droppedTables);</span>
<span class="fc" id="L262">    }</span>

    /**
     * Flushes all dirty CFs, waiting for them to free and recycle any segments they were retaining
     */
    public void forceRecycleAllSegments()
    {
<span class="fc" id="L269">        segmentManager.forceRecycleAll(Collections.emptyList());</span>
<span class="fc" id="L270">    }</span>

    /**
     * Forces a disk flush on the commit log files that need it.  Blocking.
     */
    public void sync(boolean flush) throws IOException
    {
<span class="fc" id="L277">        segmentManager.sync(flush);</span>
<span class="fc" id="L278">    }</span>

    /**
     * Preempts the CLExecutor, telling to to sync immediately
     */
    public void requestExtraSync()
    {
<span class="fc" id="L285">        executor.requestExtraSync();</span>
<span class="fc" id="L286">    }</span>

    /**
     * Add a Mutation to the commit log. If CDC is enabled, this can fail.
     *
     * @param mutation the Mutation to add to the log
     * @throws CDCWriteException
     */
    public CommitLogPosition add(Mutation mutation) throws CDCWriteException
    {
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">        assert mutation != null;</span>

<span class="fc" id="L298">        mutation.validateSize(MessagingService.current_version, ENTRY_OVERHEAD_SIZE);</span>

<span class="fc" id="L300">        try (DataOutputBuffer dob = DataOutputBuffer.scratchBuffer.get())</span>
        {
<span class="fc" id="L302">            Mutation.serializer.serialize(mutation, dob, MessagingService.current_version);</span>
<span class="fc" id="L303">            int size = dob.getLength();</span>
<span class="fc" id="L304">            int totalSize = size + ENTRY_OVERHEAD_SIZE;</span>
<span class="fc" id="L305">            Allocation alloc = segmentManager.allocate(mutation, totalSize);</span>

<span class="fc" id="L307">            CRC32 checksum = new CRC32();</span>
<span class="fc" id="L308">            final ByteBuffer buffer = alloc.getBuffer();</span>
<span class="fc" id="L309">            try (BufferedDataOutputStreamPlus dos = new DataOutputBufferFixed(buffer))</span>
            {
                // checksummed length
<span class="fc" id="L312">                dos.writeInt(size);</span>
<span class="fc" id="L313">                updateChecksumInt(checksum, size);</span>
<span class="fc" id="L314">                buffer.putInt((int) checksum.getValue());</span>

                // checksummed mutation
<span class="fc" id="L317">                dos.write(dob.unsafeGetBufferAndFlip());</span>
<span class="fc" id="L318">                updateChecksum(checksum, buffer, buffer.position() - size, size);</span>
<span class="fc" id="L319">                buffer.putInt((int) checksum.getValue());</span>
            }
<span class="nc" id="L321">            catch (IOException e)</span>
            {
<span class="nc" id="L323">                throw new FSWriteError(e, alloc.getSegment().getPath());</span>
            }
            finally
            {
<span class="fc" id="L327">                alloc.markWritten();</span>
            }

<span class="fc" id="L330">            executor.finishWriteFor(alloc);</span>
<span class="fc" id="L331">            return alloc.getCommitLogPosition();</span>
        }
<span class="nc" id="L333">        catch (IOException e)</span>
        {
<span class="nc" id="L335">            throw new FSWriteError(e, segmentManager.allocatingFrom().getPath());</span>
        }
    }

    /**
     * Modifies the per-CF dirty cursors of any commit log segments for the column family according to the position
     * given. Discards any commit log segments that are no longer used.
     *
     * @param id         the table that was flushed
     * @param lowerBound the lowest covered replay position of the flush
     * @param lowerBound the highest covered replay position of the flush
     */
    public void discardCompletedSegments(final TableId id, final CommitLogPosition lowerBound, final CommitLogPosition upperBound)
    {
<span class="fc" id="L349">        logger.trace(&quot;discard completed log segments for {}-{}, table {}&quot;, lowerBound, upperBound, id);</span>

        // Go thru the active segment files, which are ordered oldest to newest, marking the
        // flushed CF as clean, until we reach the segment file containing the CommitLogPosition passed
        // in the arguments. Any segments that become unused after they are marked clean will be
        // recycled or discarded.
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">        for (Iterator&lt;CommitLogSegment&gt; iter = segmentManager.getActiveSegments().iterator(); iter.hasNext();)</span>
        {
<span class="fc" id="L357">            CommitLogSegment segment = iter.next();</span>
<span class="fc" id="L358">            segment.markClean(id, lowerBound, upperBound);</span>

<span class="fc bfc" id="L360" title="All 2 branches covered.">            if (segment.isUnused())</span>
            {
<span class="fc" id="L362">                logger.debug(&quot;Commit log segment {} is unused&quot;, segment);</span>
<span class="fc" id="L363">                segmentManager.archiveAndDiscard(segment);</span>
            }
            else
            {
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">                if (logger.isTraceEnabled())</span>
<span class="nc" id="L368">                    logger.trace(&quot;Not safe to delete{} commit log segment {}; dirty is {}&quot;,</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">                            (iter.hasNext() ? &quot;&quot; : &quot; active&quot;), segment, segment.dirtyString());</span>
            }

            // Don't mark or try to delete any newer segments once we've reached the one containing the
            // position of the flush.
<span class="fc bfc" id="L374" title="All 2 branches covered.">            if (segment.contains(upperBound))</span>
<span class="fc" id="L375">                break;</span>
<span class="fc" id="L376">        }</span>
<span class="fc" id="L377">    }</span>

    @Override
    public String getArchiveCommand()
    {
<span class="nc" id="L382">        return archiver.archiveCommand;</span>
    }

    @Override
    public String getRestoreCommand()
    {
<span class="nc" id="L388">        return archiver.restoreCommand;</span>
    }

    @Override
    public String getRestoreDirectories()
    {
<span class="nc" id="L394">        return archiver.restoreDirectories;</span>
    }

    @Override
    public long getRestorePointInTime()
    {
<span class="nc" id="L400">        return archiver.restorePointInTime;</span>
    }

    @Override
    public String getRestorePrecision()
    {
<span class="nc" id="L406">        return archiver.precision.toString();</span>
    }

    public List&lt;String&gt; getActiveSegmentNames()
    {
<span class="nc" id="L411">        Collection&lt;CommitLogSegment&gt; segments = segmentManager.getActiveSegments();</span>
<span class="nc" id="L412">        List&lt;String&gt; segmentNames = new ArrayList&lt;&gt;(segments.size());</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">        for (CommitLogSegment seg : segments)</span>
<span class="nc" id="L414">            segmentNames.add(seg.getName());</span>
<span class="nc" id="L415">        return segmentNames;</span>
    }

    public List&lt;String&gt; getArchivingSegmentNames()
    {
<span class="nc" id="L420">        return new ArrayList&lt;&gt;(archiver.archivePending.keySet());</span>
    }

    @Override
    public long getActiveContentSize()
    {
<span class="nc" id="L426">        long size = 0;</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">        for (CommitLogSegment seg : segmentManager.getActiveSegments())</span>
<span class="nc" id="L428">            size += seg.contentSize();</span>
<span class="nc" id="L429">        return size;</span>
    }

    @Override
    public long getActiveOnDiskSize()
    {
<span class="nc" id="L435">        return segmentManager.onDiskSize();</span>
    }

    @Override
    public Map&lt;String, Double&gt; getActiveSegmentCompressionRatios()
    {
<span class="nc" id="L441">        Map&lt;String, Double&gt; segmentRatios = new TreeMap&lt;&gt;();</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">        for (CommitLogSegment seg : segmentManager.getActiveSegments())</span>
<span class="nc" id="L443">            segmentRatios.put(seg.getName(), 1.0 * seg.onDiskSize() / seg.contentSize());</span>
<span class="nc" id="L444">        return segmentRatios;</span>
    }

    @Override
    public boolean getCDCBlockWrites()
    {
<span class="nc" id="L450">        return DatabaseDescriptor.getCDCBlockWrites();</span>
    }

    @Override
    public void setCDCBlockWrites(boolean val)
    {
<span class="nc" id="L456">        ensureCDCEnabled(&quot;Unable to set block_writes.&quot;);</span>
<span class="nc" id="L457">        boolean oldVal = DatabaseDescriptor.getCDCBlockWrites();</span>
<span class="nc" id="L458">        CommitLogSegment currentSegment = segmentManager.allocatingFrom();</span>
        // Update the current segment CDC state to PERMITTED if block_writes is disabled now, and it was in FORBIDDEN state
<span class="nc bnc" id="L460" title="All 4 branches missed.">        if (!val &amp;&amp; currentSegment.getCDCState() == CommitLogSegment.CDCState.FORBIDDEN)</span>
<span class="nc" id="L461">            currentSegment.setCDCState(CommitLogSegment.CDCState.PERMITTED);</span>
<span class="nc" id="L462">        DatabaseDescriptor.setCDCBlockWrites(val);</span>
<span class="nc" id="L463">        logger.info(&quot;Updated CDC block_writes from {} to {}&quot;, oldVal, val);</span>
<span class="nc" id="L464">    }</span>


    @Override
    public boolean isCDCOnRepairEnabled()
    {
<span class="nc" id="L470">        return DatabaseDescriptor.isCDCOnRepairEnabled();</span>
    }

    @Override
    public void setCDCOnRepairEnabled(boolean value)
    {
<span class="nc" id="L476">        ensureCDCEnabled(&quot;Unable to set cdc_on_repair_enabled.&quot;);</span>
<span class="nc" id="L477">        DatabaseDescriptor.setCDCOnRepairEnabled(value);</span>
<span class="nc" id="L478">        logger.info(&quot;Set cdc_on_repair_enabled to {}&quot;, value);</span>
<span class="nc" id="L479">    }</span>

    private void ensureCDCEnabled(String hint)
    {
<span class="nc" id="L483">        Preconditions.checkState(DatabaseDescriptor.isCDCEnabled(), &quot;CDC is not enabled. %s&quot;, hint);</span>
<span class="nc" id="L484">        Preconditions.checkState(segmentManager instanceof CommitLogSegmentManagerCDC,</span>
                                 &quot;CDC is enabled but we have the wrong CommitLogSegmentManager type: %s. &quot; +
<span class="nc" id="L486">                                 &quot;Please report this as bug.&quot;, segmentManager.getClass().getName());</span>
<span class="nc" id="L487">    }</span>

    /**
     * Shuts down the threads used by the commit log, blocking until completion.
     * TODO this should accept a timeout, and throw TimeoutException
     */
    synchronized public void shutdownBlocking() throws InterruptedException
    {
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">        if (!started)</span>
<span class="nc" id="L496">            return;</span>

<span class="fc" id="L498">        started = false;</span>
<span class="fc" id="L499">        executor.shutdown();</span>
<span class="fc" id="L500">        executor.awaitTermination();</span>
<span class="fc" id="L501">        segmentManager.shutdown();</span>
<span class="fc" id="L502">        segmentManager.awaitTermination(1L, TimeUnit.MINUTES);</span>
<span class="fc" id="L503">    }</span>

    /**
     * FOR TESTING PURPOSES
     * @return the number of files recovered
     */
    @VisibleForTesting
    synchronized public int resetUnsafe(boolean deleteSegments) throws IOException
    {
<span class="nc" id="L512">        stopUnsafe(deleteSegments);</span>
<span class="nc" id="L513">        resetConfiguration();</span>
<span class="nc" id="L514">        return restartUnsafe();</span>
    }

    /**
     * FOR TESTING PURPOSES.
     */
    @VisibleForTesting
    synchronized public void resetConfiguration()
    {
<span class="nc" id="L523">        configuration = new Configuration(DatabaseDescriptor.getCommitLogCompression(),</span>
<span class="nc" id="L524">                                          DatabaseDescriptor.getEncryptionContext());</span>
<span class="nc" id="L525">    }</span>

    /**
     * FOR TESTING PURPOSES
     */
    @VisibleForTesting
    synchronized public void stopUnsafe(boolean deleteSegments)
    {
<span class="nc bnc" id="L533" title="All 2 branches missed.">        if (!started)</span>
<span class="nc" id="L534">            return;</span>

<span class="nc" id="L536">        started = false;</span>
<span class="nc" id="L537">        executor.shutdown();</span>
        try
        {
<span class="nc" id="L540">            executor.awaitTermination();</span>
        }
<span class="nc" id="L542">        catch (InterruptedException e)</span>
        {
<span class="nc" id="L544">            throw new UncheckedInterruptedException(e);</span>
<span class="nc" id="L545">        }</span>
<span class="nc" id="L546">        segmentManager.stopUnsafe(deleteSegments);</span>
<span class="nc" id="L547">        CommitLogSegment.resetReplayLimit();</span>
<span class="nc bnc" id="L548" title="All 4 branches missed.">        if (DatabaseDescriptor.isCDCEnabled() &amp;&amp; deleteSegments)</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">            for (File f : new File(DatabaseDescriptor.getCDCLogLocation()).tryList())</span>
<span class="nc" id="L550">                f.delete();</span>
<span class="nc" id="L551">    }</span>

    /**
     * FOR TESTING PURPOSES
     */
    @VisibleForTesting
    synchronized public int restartUnsafe() throws IOException
    {
<span class="nc" id="L559">        started = false;</span>
<span class="nc" id="L560">        return start().recoverSegmentsOnDisk();</span>
    }

    public static long freeDiskSpace()
    {
<span class="fc" id="L565">        return PathUtils.tryGetSpace(new File(DatabaseDescriptor.getCommitLogLocation()).toPath(), FileStore::getTotalSpace);</span>
    }

    @VisibleForTesting
    public static boolean handleCommitError(String message, Throwable t)
    {
<span class="fc" id="L571">        JVMStabilityInspector.inspectCommitLogThrowable(t);</span>
<span class="pc bpc" id="L572" title="2 of 4 branches missed.">        switch (DatabaseDescriptor.getCommitFailurePolicy())</span>
        {
            // Needed here for unit tests to not fail on default assertion
            case die:
            case stop:
<span class="fc" id="L577">                StorageService.instance.stopTransports();</span>
                //$FALL-THROUGH$
            case stop_commit:
<span class="fc" id="L580">                String errorMsg = String.format(&quot;%s. Commit disk failure policy is %s; terminating thread.&quot;, message, DatabaseDescriptor.getCommitFailurePolicy());</span>
<span class="fc" id="L581">                logger.error(addAdditionalInformationIfPossible(errorMsg), t);</span>
<span class="fc" id="L582">                return false;</span>
            case ignore:
<span class="nc" id="L584">                logger.error(addAdditionalInformationIfPossible(message), t);</span>
<span class="nc" id="L585">                return true;</span>
            default:
<span class="nc" id="L587">                throw new AssertionError(DatabaseDescriptor.getCommitFailurePolicy());</span>
        }
    }

    /**
     * Add additional information to the error message if the commit directory does not have enough free space.
     *
     * @param msg the original error message
     * @return the message with additional information if possible
     */
    private static String addAdditionalInformationIfPossible(String msg)
    {
<span class="fc" id="L599">        long unallocatedSpace = freeDiskSpace();</span>
<span class="fc" id="L600">        int segmentSize = DatabaseDescriptor.getCommitLogSegmentSize();</span>

<span class="pc bpc" id="L602" title="1 of 2 branches missed.">        if (unallocatedSpace &lt; segmentSize)</span>
        {
<span class="nc" id="L604">            return String.format(&quot;%s. %d bytes required for next commitlog segment but only %d bytes available. Check %s to see if not enough free space is the reason for this error.&quot;,</span>
<span class="nc" id="L605">                                 msg, segmentSize, unallocatedSpace, DatabaseDescriptor.getCommitLogLocation());</span>
        }
<span class="fc" id="L607">        return msg;</span>
    }

    public static final class Configuration
    {
        /**
         * The compressor class.
         */
        private final ParameterizedClass compressorClass;

        /**
         * The compressor used to compress the segments.
         */
        private final ICompressor compressor;

        /**
         * The encryption context used to encrypt the segments.
         */
        private EncryptionContext encryptionContext;

        public Configuration(ParameterizedClass compressorClass, EncryptionContext encryptionContext)
<span class="fc" id="L628">        {</span>
<span class="fc" id="L629">            this.compressorClass = compressorClass;</span>
<span class="fc bfc" id="L630" title="All 2 branches covered.">            this.compressor = compressorClass != null ? CompressionParams.createCompressor(compressorClass) : null;</span>
<span class="fc" id="L631">            this.encryptionContext = encryptionContext;</span>
<span class="fc" id="L632">        }</span>

        /**
         * Checks if the segments must be compressed.
         * @return &lt;code&gt;true&lt;/code&gt; if the segments must be compressed, &lt;code&gt;false&lt;/code&gt; otherwise.
         */
        public boolean useCompression()
        {
<span class="fc bfc" id="L640" title="All 2 branches covered.">            return compressor != null;</span>
        }

        /**
         * Checks if the segments must be encrypted.
         * @return &lt;code&gt;true&lt;/code&gt; if the segments must be encrypted, &lt;code&gt;false&lt;/code&gt; otherwise.
         */
        public boolean useEncryption()
        {
<span class="pc bpc" id="L649" title="2 of 4 branches missed.">            return encryptionContext != null &amp;&amp; encryptionContext.isEnabled();</span>
        }

        /**
         * Returns the compressor used to compress the segments.
         * @return the compressor used to compress the segments
         */
        public ICompressor getCompressor()
        {
<span class="fc" id="L658">            return compressor;</span>
        }

        /**
         * Returns the compressor class.
         * @return the compressor class
         */
        public ParameterizedClass getCompressorClass()
        {
<span class="fc" id="L667">            return compressorClass;</span>
        }

        /**
         * Returns the compressor name.
         * @return the compressor name.
         */
        public String getCompressorName()
        {
<span class="nc bnc" id="L676" title="All 2 branches missed.">            return useCompression() ? compressor.getClass().getSimpleName() : &quot;none&quot;;</span>
        }

        /**
         * Returns the encryption context used to encrypt the segments.
         * @return the encryption context used to encrypt the segments
         */
        public EncryptionContext getEncryptionContext()
        {
<span class="fc" id="L685">            return encryptionContext;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>