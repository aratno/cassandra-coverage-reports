<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CommitLogReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.commitlog</a> &gt; <span class="el_source">CommitLogReader.java</span></div><h1>CommitLogReader.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.commitlog;

import java.nio.file.Files;
import java.nio.file.Path;
import java.io.*;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.zip.CRC32;

import com.google.common.annotations.VisibleForTesting;
import org.apache.cassandra.io.util.File;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.Mutation;
import org.apache.cassandra.db.commitlog.CommitLogReadHandler.CommitLogReadErrorReason;
import org.apache.cassandra.db.commitlog.CommitLogReadHandler.CommitLogReadException;
import org.apache.cassandra.db.partitions.PartitionUpdate;
import org.apache.cassandra.db.rows.DeserializationHelper;
import org.apache.cassandra.exceptions.UnknownTableException;
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.io.util.DataInputBuffer;
import org.apache.cassandra.io.util.FileDataInput;
import org.apache.cassandra.io.util.RandomAccessReader;
import org.apache.cassandra.io.util.RebufferingInputStream;
import org.apache.cassandra.schema.TableId;
import org.apache.cassandra.utils.JVMStabilityInspector;

import static org.apache.cassandra.utils.FBUtilities.updateChecksumInt;

public class CommitLogReader
{
<span class="fc" id="L52">    private static final Logger logger = LoggerFactory.getLogger(CommitLogReader.class);</span>

    private static final int LEGACY_END_OF_SEGMENT_MARKER = 0;

    @VisibleForTesting
    public static final int ALL_MUTATIONS = -1;
    private final CRC32 checksum;
    private final Map&lt;TableId, AtomicInteger&gt; invalidMutations;

    private byte[] buffer;

    public CommitLogReader()
<span class="fc" id="L64">    {</span>
<span class="fc" id="L65">        checksum = new CRC32();</span>
<span class="fc" id="L66">        invalidMutations = new HashMap&lt;&gt;();</span>
<span class="fc" id="L67">        buffer = new byte[4096];</span>
<span class="fc" id="L68">    }</span>

    public Set&lt;Map.Entry&lt;TableId, AtomicInteger&gt;&gt; getInvalidMutations()
    {
<span class="fc" id="L72">        return invalidMutations.entrySet();</span>
    }

    /**
     * Reads all passed in files with no minimum, no start, and no mutation limit.
     */
    public void readAllFiles(CommitLogReadHandler handler, File[] files) throws IOException
    {
<span class="nc" id="L80">        readAllFiles(handler, files, CommitLogPosition.NONE);</span>
<span class="nc" id="L81">    }</span>

    private static boolean shouldSkip(File file) throws IOException, ConfigurationException
    {
<span class="fc" id="L85">        try(RandomAccessReader reader = RandomAccessReader.open(file))</span>
        {
<span class="fc" id="L87">            CommitLogDescriptor.readHeader(reader, DatabaseDescriptor.getEncryptionContext());</span>
<span class="fc" id="L88">            int end = reader.readInt();</span>
<span class="fc" id="L89">            long filecrc = reader.readInt() &amp; 0xffffffffL;</span>
<span class="pc bpc" id="L90" title="1 of 4 branches missed.">            return end == 0 &amp;&amp; filecrc == 0;</span>
        }
    }

    static List&lt;File&gt; filterCommitLogFiles(File[] toFilter)
    {
<span class="fc" id="L96">        List&lt;File&gt; filtered = new ArrayList&lt;&gt;(toFilter.length);</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">        for (File file: toFilter)</span>
        {
            try
            {
<span class="fc bfc" id="L101" title="All 2 branches covered.">                if (shouldSkip(file))</span>
                {
<span class="fc" id="L103">                    logger.info(&quot;Skipping playback of empty log: {}&quot;, file.name());</span>
                }
                else
                {
<span class="fc" id="L107">                    filtered.add(file);</span>
                }
            }
<span class="fc" id="L110">            catch (Exception e)</span>
            {
                // let recover deal with it
<span class="fc" id="L113">                filtered.add(file);</span>
<span class="fc" id="L114">            }</span>
        }

<span class="fc" id="L117">        return filtered;</span>
    }

    /**
     * Reads all passed in files with minPosition, no start, and no mutation limit.
     */
    public void readAllFiles(CommitLogReadHandler handler, File[] files, CommitLogPosition minPosition) throws IOException
    {
<span class="nc" id="L125">        List&lt;File&gt; filteredLogs = filterCommitLogFiles(files);</span>
<span class="nc" id="L126">        int i = 0;</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        for (File file: filteredLogs)</span>
        {
<span class="nc" id="L129">            i++;</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">            readCommitLogSegment(handler, file, minPosition, ALL_MUTATIONS, i == filteredLogs.size());</span>
<span class="nc" id="L131">        }</span>
<span class="nc" id="L132">    }</span>

    /**
     * Reads passed in file fully
     */
    public void readCommitLogSegment(CommitLogReadHandler handler, File file, boolean tolerateTruncation) throws IOException
    {
<span class="nc" id="L139">        readCommitLogSegment(handler, file, CommitLogPosition.NONE, ALL_MUTATIONS, tolerateTruncation);</span>
<span class="nc" id="L140">    }</span>

    /**
     * Reads all mutations from passed in file from minPosition
     */
    public void readCommitLogSegment(CommitLogReadHandler handler, File file, CommitLogPosition minPosition, boolean tolerateTruncation) throws IOException
    {
<span class="fc" id="L147">        readCommitLogSegment(handler, file, minPosition, ALL_MUTATIONS, tolerateTruncation);</span>
<span class="fc" id="L148">    }</span>

    /**
     * Reads passed in file fully, up to mutationLimit count
     */
    @VisibleForTesting
    public void readCommitLogSegment(CommitLogReadHandler handler, File file, int mutationLimit, boolean tolerateTruncation) throws IOException
    {
<span class="nc" id="L156">        readCommitLogSegment(handler, file, CommitLogPosition.NONE, mutationLimit, tolerateTruncation);</span>
<span class="nc" id="L157">    }</span>

    /**
     * Reads mutations from file, handing them off to handler
     * @param handler Handler that will take action based on deserialized Mutations
     * @param file CommitLogSegment file to read
     * @param minPosition Optional minimum CommitLogPosition - all segments with id larger or matching w/greater position will be read
     * @param mutationLimit Optional limit on # of mutations to replay. Local ALL_MUTATIONS serves as marker to play all.
     * @param tolerateTruncation Whether or not we should allow truncation of this file or throw if EOF found
     *
     * @throws IOException
     */
    public void readCommitLogSegment(CommitLogReadHandler handler,
                                     File file,
                                     CommitLogPosition minPosition,
                                     int mutationLimit,
                                     boolean tolerateTruncation) throws IOException
    {
        // just transform from the file name (no reading of headers) to determine version
<span class="fc" id="L176">        CommitLogDescriptor desc = CommitLogDescriptor.fromFileName(file.name());</span>

<span class="fc" id="L178">        try(RandomAccessReader reader = RandomAccessReader.open(file))</span>
        {
<span class="fc" id="L180">            final long segmentIdFromFilename = desc.id;</span>
            try
            {
                // The following call can either throw or legitimately return null. For either case, we need to check
                // desc outside this block and set it to null in the exception case.
<span class="fc" id="L185">                desc = CommitLogDescriptor.readHeader(reader, DatabaseDescriptor.getEncryptionContext());</span>
            }
<span class="fc" id="L187">            catch (Exception e)</span>
            {
<span class="fc" id="L189">                desc = null;</span>
<span class="fc" id="L190">            }</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">            if (desc == null)</span>
            {
                // don't care about whether or not the handler thinks we can continue. We can't w/out descriptor.
                // whether or not we can continue depends on whether this is the last segment
<span class="pc" id="L195">                handler.handleUnrecoverableError(new CommitLogReadException(</span>
<span class="fc" id="L196">                    String.format(&quot;Could not read commit log descriptor in file %s&quot;, file),</span>
                    CommitLogReadErrorReason.UNRECOVERABLE_DESCRIPTOR_ERROR,
                    tolerateTruncation));
<span class="nc" id="L199">                return;</span>
            }

<span class="pc bpc" id="L202" title="1 of 2 branches missed.">            if (segmentIdFromFilename != desc.id)</span>
            {
<span class="nc bnc" id="L204" title="All 2 branches missed.">                if (handler.shouldSkipSegmentOnError(new CommitLogReadException(String.format(</span>
<span class="nc" id="L205">                    &quot;Segment id mismatch (filename %d, descriptor %d) in file %s&quot;, segmentIdFromFilename, desc.id, file),</span>
                                                                                CommitLogReadErrorReason.RECOVERABLE_DESCRIPTOR_ERROR,
                                                                                false)))
                {
<span class="nc" id="L209">                    return;</span>
                }
            }

<span class="pc bpc" id="L213" title="1 of 2 branches missed.">            if (shouldSkipSegmentId(file, desc, minPosition))</span>
<span class="nc" id="L214">                return;</span>

            CommitLogSegmentReader segmentReader;
            try
            {
<span class="fc" id="L219">                segmentReader = new CommitLogSegmentReader(handler, desc, reader, tolerateTruncation);</span>
            }
<span class="nc" id="L221">            catch(Exception e)</span>
            {
<span class="nc" id="L223">                handler.handleUnrecoverableError(new CommitLogReadException(</span>
<span class="nc" id="L224">                    String.format(&quot;Unable to create segment reader for commit log file: %s&quot;, e),</span>
                    CommitLogReadErrorReason.UNRECOVERABLE_UNKNOWN_ERROR,
                    tolerateTruncation));
<span class="nc" id="L227">                return;</span>
<span class="fc" id="L228">            }</span>

            try
            {
<span class="fc" id="L232">                ReadStatusTracker statusTracker = new ReadStatusTracker(mutationLimit, tolerateTruncation);</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">                for (CommitLogSegmentReader.SyncSegment syncSegment : segmentReader)</span>
                {
                    // Only tolerate truncation if we allow in both global and segment
<span class="fc" id="L236">                    statusTracker.tolerateErrorsInSection = tolerateTruncation &amp; syncSegment.toleratesErrorsInSection;</span>

                    // Skip segments that are completely behind the desired minPosition
<span class="pc bpc" id="L239" title="3 of 4 branches missed.">                    if (desc.id == minPosition.segmentId &amp;&amp; syncSegment.endPosition &lt; minPosition.position)</span>
<span class="nc" id="L240">                        continue;</span>

<span class="fc" id="L242">                    statusTracker.errorContext = String.format(&quot;Next section at %d in %s&quot;, syncSegment.fileStartPosition, desc.fileName());</span>

<span class="fc" id="L244">                    readSection(handler, syncSegment.input, minPosition, syncSegment.endPosition, statusTracker, desc);</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">                    if (!statusTracker.shouldContinue())</span>
<span class="nc" id="L246">                        break;</span>
<span class="fc" id="L247">                }</span>
            }
            // Unfortunately AbstractIterator cannot throw a checked exception, so we check to see if a RuntimeException
            // is wrapping an IOException.
<span class="nc" id="L251">            catch (RuntimeException re)</span>
            {
<span class="nc bnc" id="L253" title="All 2 branches missed.">                if (re.getCause() instanceof IOException)</span>
<span class="nc" id="L254">                    throw (IOException) re.getCause();</span>
<span class="nc" id="L255">                throw re;</span>
<span class="fc" id="L256">            }</span>
<span class="fc" id="L257">            logger.info(&quot;Finished reading {}&quot;, file);</span>
<span class="nc bnc" id="L258" title="All 8 branches missed.">        }</span>
<span class="fc" id="L259">    }</span>

    /**
     * Any segment with id &gt;= minPosition.segmentId is a candidate for read.
     */
    private boolean shouldSkipSegmentId(File file, CommitLogDescriptor desc, CommitLogPosition minPosition)
    {
<span class="fc" id="L266">        logger.debug(&quot;Reading {} (CL version {}, messaging version {}, compression {})&quot;,</span>
<span class="fc" id="L267">            file.path(),</span>
<span class="fc" id="L268">            desc.version,</span>
<span class="fc" id="L269">            desc.getMessagingVersion(),</span>
            desc.compression);

<span class="pc bpc" id="L272" title="1 of 2 branches missed.">        if (minPosition.segmentId &gt; desc.id)</span>
        {
<span class="nc" id="L274">            logger.trace(&quot;Skipping read of fully-flushed {}&quot;, file);</span>
<span class="nc" id="L275">            return true;</span>
        }
<span class="fc" id="L277">        return false;</span>
    }

    /**
     * Reads a section of a file containing mutations
     *
     * @param handler Handler that will take action based on deserialized Mutations
     * @param reader FileDataInput / logical buffer containing commitlog mutations
     * @param minPosition CommitLogPosition indicating when we should start actively replaying mutations
     * @param end logical numeric end of the segment being read
     * @param statusTracker ReadStatusTracker with current state of mutation count, error state, etc
     * @param desc Descriptor for CommitLog serialization
     */
    private void readSection(CommitLogReadHandler handler,
                             FileDataInput reader,
                             CommitLogPosition minPosition,
                             int end,
                             ReadStatusTracker statusTracker,
                             CommitLogDescriptor desc) throws IOException
    {
        // seek rather than deserializing mutation-by-mutation to reach the desired minPosition in this SyncSegment
<span class="pc bpc" id="L298" title="3 of 4 branches missed.">        if (desc.id == minPosition.segmentId &amp;&amp; reader.getFilePointer() &lt; minPosition.position)</span>
<span class="nc" id="L299">            reader.seek(minPosition.position);</span>

<span class="pc bpc" id="L301" title="2 of 6 branches missed.">        while (statusTracker.shouldContinue() &amp;&amp; reader.getFilePointer() &lt; end &amp;&amp; !reader.isEOF())</span>
        {
<span class="fc" id="L303">            long mutationStart = reader.getFilePointer();</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">            if (logger.isTraceEnabled())</span>
<span class="nc" id="L305">                logger.trace(&quot;Reading mutation at {}&quot;, mutationStart);</span>

            long claimedCRC32;
            int serializedSize;
            try
            {
                // We rely on reading serialized size == 0 (LEGACY_END_OF_SEGMENT_MARKER) to identify the end
                // of a segment, which happens naturally due to the 0 padding of the empty segment on creation.
                // However, it's possible with 2.1 era commitlogs that the last mutation ended less than 4 bytes
                // from the end of the file, which means that we'll be unable to read an a full int and instead
                // read an EOF here
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">                if(end - reader.getFilePointer() &lt; 4)</span>
                {
<span class="nc" id="L318">                    logger.trace(&quot;Not enough bytes left for another mutation in this CommitLog section, continuing&quot;);</span>
<span class="nc" id="L319">                    statusTracker.requestTermination();</span>
<span class="nc" id="L320">                    return;</span>
                }

                // any of the reads may hit EOF
<span class="fc" id="L324">                serializedSize = reader.readInt();</span>
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">                if (serializedSize == LEGACY_END_OF_SEGMENT_MARKER)</span>
                {
<span class="nc" id="L327">                    logger.trace(&quot;Encountered end of segment marker at {}&quot;, reader.getFilePointer());</span>
<span class="nc" id="L328">                    statusTracker.requestTermination();</span>
<span class="nc" id="L329">                    return;</span>
                }

                // Mutation must be at LEAST 10 bytes:
                //    3 for a non-empty Keyspace
                //    3 for a Key (including the 2-byte length from writeUTF/writeWithShortLength)
                //    4 bytes for column count.
                // This prevents CRC by being fooled by special-case garbage in the file; see CASSANDRA-2128
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">                if (serializedSize &lt; 10)</span>
                {
<span class="nc bnc" id="L339" title="All 2 branches missed.">                    if (handler.shouldSkipSegmentOnError(new CommitLogReadException(</span>
<span class="nc" id="L340">                                                    String.format(&quot;Invalid mutation size %d at %d in %s&quot;, serializedSize, mutationStart, statusTracker.errorContext),</span>
                                                    CommitLogReadErrorReason.MUTATION_ERROR,
                                                    statusTracker.tolerateErrorsInSection)))
                    {
<span class="nc" id="L344">                        statusTracker.requestTermination();</span>
                    }
<span class="nc" id="L346">                    return;</span>
                }

<span class="fc" id="L349">                long claimedSizeChecksum = CommitLogFormat.calculateClaimedChecksum(reader, desc.version);</span>
<span class="fc" id="L350">                checksum.reset();</span>
<span class="fc" id="L351">                CommitLogFormat.updateChecksum(checksum, serializedSize, desc.version);</span>

<span class="pc bpc" id="L353" title="1 of 2 branches missed.">                if (checksum.getValue() != claimedSizeChecksum)</span>
                {
<span class="nc bnc" id="L355" title="All 2 branches missed.">                    if (handler.shouldSkipSegmentOnError(new CommitLogReadException(</span>
<span class="nc" id="L356">                                                    String.format(&quot;Mutation size checksum failure at %d in %s&quot;, mutationStart, statusTracker.errorContext),</span>
                                                    CommitLogReadErrorReason.MUTATION_ERROR,
                                                    statusTracker.tolerateErrorsInSection)))
                    {
<span class="nc" id="L360">                        statusTracker.requestTermination();</span>
                    }
<span class="nc" id="L362">                    return;</span>
                }

<span class="fc bfc" id="L365" title="All 2 branches covered.">                if (serializedSize &gt; buffer.length)</span>
<span class="fc" id="L366">                    buffer = new byte[(int) (1.2 * serializedSize)];</span>
<span class="fc" id="L367">                reader.readFully(buffer, 0, serializedSize);</span>

<span class="fc" id="L369">                claimedCRC32 = CommitLogFormat.calculateClaimedCRC32(reader, desc.version);</span>
            }
<span class="nc" id="L371">            catch (EOFException eof)</span>
            {
<span class="nc bnc" id="L373" title="All 2 branches missed.">                if (handler.shouldSkipSegmentOnError(new CommitLogReadException(</span>
<span class="nc" id="L374">                                                String.format(&quot;Unexpected end of segment at %d in %s&quot;, mutationStart, statusTracker.errorContext),</span>
                                                CommitLogReadErrorReason.EOF,
                                                statusTracker.tolerateErrorsInSection)))
                {
<span class="nc" id="L378">                    statusTracker.requestTermination();</span>
                }
<span class="nc" id="L380">                return;</span>
<span class="fc" id="L381">            }</span>

<span class="fc" id="L383">            checksum.update(buffer, 0, serializedSize);</span>
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">            if (claimedCRC32 != checksum.getValue())</span>
            {
<span class="nc bnc" id="L386" title="All 2 branches missed.">                if (handler.shouldSkipSegmentOnError(new CommitLogReadException(</span>
<span class="nc" id="L387">                                                String.format(&quot;Mutation checksum failure at %d in %s&quot;, mutationStart, statusTracker.errorContext),</span>
                                                CommitLogReadErrorReason.MUTATION_ERROR,
                                                statusTracker.tolerateErrorsInSection)))
                {
<span class="nc" id="L391">                    statusTracker.requestTermination();</span>
                }
                continue;
            }

<span class="fc" id="L396">            long mutationPosition = reader.getFilePointer();</span>
<span class="fc" id="L397">            readMutation(handler, buffer, serializedSize, minPosition, (int)mutationPosition, desc);</span>

            // Only count this as a processed mutation if it is after our min as we suppress reading of mutations that
            // are before this mark.
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">            if (mutationPosition &gt;= minPosition.position)</span>
<span class="fc" id="L402">                statusTracker.addProcessedMutation();</span>
<span class="fc" id="L403">        }</span>
<span class="fc" id="L404">    }</span>

    /**
     * Deserializes and passes a Mutation to the ICommitLogReadHandler requested
     *
     * @param handler Handler that will take action based on deserialized Mutations
     * @param inputBuffer raw byte array w/Mutation data
     * @param size deserialized size of mutation
     * @param minPosition We need to suppress replay of mutations that are before the required minPosition
     * @param entryLocation filePointer offset of end of mutation within CommitLogSegment
     * @param desc CommitLogDescriptor being worked on
     */
    @VisibleForTesting
    protected void readMutation(CommitLogReadHandler handler,
                                byte[] inputBuffer,
                                int size,
                                CommitLogPosition minPosition,
                                final int entryLocation,
                                final CommitLogDescriptor desc) throws IOException
    {
        // For now, we need to go through the motions of deserializing the mutation to determine its size and move
        // the file pointer forward accordingly, even if we're behind the requested minPosition within this SyncSegment.
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">        boolean shouldReplay = entryLocation &gt; minPosition.position;</span>

        final Mutation mutation;
<span class="fc" id="L429">        try (RebufferingInputStream bufIn = new DataInputBuffer(inputBuffer, 0, size))</span>
        {
<span class="fc" id="L431">            mutation = Mutation.serializer.deserialize(bufIn,</span>
<span class="fc" id="L432">                                                       desc.getMessagingVersion(),</span>
                                                       DeserializationHelper.Flag.LOCAL);
            // doublecheck that what we read is still] valid for the current schema
<span class="fc bfc" id="L435" title="All 2 branches covered.">            for (PartitionUpdate upd : mutation.getPartitionUpdates())</span>
<span class="fc" id="L436">                upd.validate();</span>
        }
<span class="fc" id="L438">        catch (UnknownTableException ex)</span>
        {
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">            if (ex.id == null)</span>
<span class="nc" id="L441">                return;</span>
<span class="fc" id="L442">            AtomicInteger i = invalidMutations.get(ex.id);</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">            if (i == null)</span>
            {
<span class="fc" id="L445">                i = new AtomicInteger(1);</span>
<span class="fc" id="L446">                invalidMutations.put(ex.id, i);</span>
            }
            else
<span class="fc" id="L449">                i.incrementAndGet();</span>
<span class="fc" id="L450">            return;</span>
        }
<span class="nc" id="L452">        catch (Throwable t)</span>
        {
<span class="nc" id="L454">            JVMStabilityInspector.inspectThrowable(t);</span>
<span class="nc" id="L455">            Path p = Files.createTempFile(&quot;mutation&quot;, &quot;dat&quot;);</span>

<span class="nc" id="L457">            try (DataOutputStream out = new DataOutputStream(Files.newOutputStream(p)))</span>
            {
<span class="nc" id="L459">                out.write(inputBuffer, 0, size);</span>
            }

            // Checksum passed so this error can't be permissible.
<span class="nc" id="L463">            handler.handleUnrecoverableError(new CommitLogReadException(</span>
<span class="nc" id="L464">                String.format(</span>
                    &quot;Unexpected error deserializing mutation; saved to %s.  &quot; +
                    &quot;This may be caused by replaying a mutation against a table with the same name but incompatible schema.  &quot; +
<span class="nc" id="L467">                    &quot;Exception follows: %s&quot;, p.toString(), t),</span>
                CommitLogReadErrorReason.MUTATION_ERROR,
                false));
<span class="nc" id="L470">            return;</span>
<span class="fc" id="L471">        }</span>

<span class="pc bpc" id="L473" title="1 of 2 branches missed.">        if (logger.isTraceEnabled())</span>
<span class="nc" id="L474">            logger.trace(&quot;Read mutation for {}.{}: {}&quot;, mutation.getKeyspaceName(), mutation.key(),</span>
<span class="nc" id="L475">                         &quot;{&quot; + StringUtils.join(mutation.getPartitionUpdates().iterator(), &quot;, &quot;) + &quot;}&quot;);</span>

<span class="pc bpc" id="L477" title="1 of 2 branches missed.">        if (shouldReplay)</span>
<span class="fc" id="L478">            handler.handleMutation(mutation, size, entryLocation, desc);</span>
<span class="fc" id="L479">    }</span>

    /**
     * Helper methods to deal with changing formats of internals of the CommitLog without polluting deserialization code.
     */
    private static class CommitLogFormat
    {
        public static long calculateClaimedChecksum(FileDataInput input, int commitLogVersion) throws IOException
        {
<span class="fc" id="L488">            return input.readInt() &amp; 0xffffffffL;</span>
        }

        public static void updateChecksum(CRC32 checksum, int serializedSize, int commitLogVersion)
        {
<span class="fc" id="L493">            updateChecksumInt(checksum, serializedSize);</span>
<span class="fc" id="L494">        }</span>

        public static long calculateClaimedCRC32(FileDataInput input, int commitLogVersion) throws IOException
        {
<span class="fc" id="L498">            return input.readInt() &amp; 0xffffffffL;</span>
        }
    }

    private static class ReadStatusTracker
    {
        private int mutationsLeft;
<span class="fc" id="L505">        public String errorContext = &quot;&quot;;</span>
        public boolean tolerateErrorsInSection;
        private boolean error;

        public ReadStatusTracker(int mutationLimit, boolean tolerateErrorsInSection)
<span class="fc" id="L510">        {</span>
<span class="fc" id="L511">            this.mutationsLeft = mutationLimit;</span>
<span class="fc" id="L512">            this.tolerateErrorsInSection = tolerateErrorsInSection;</span>
<span class="fc" id="L513">        }</span>

        public void addProcessedMutation()
        {
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">            if (mutationsLeft == ALL_MUTATIONS)</span>
<span class="fc" id="L518">                return;</span>
<span class="nc" id="L519">            --mutationsLeft;</span>
<span class="nc" id="L520">        }</span>

        public boolean shouldContinue()
        {
<span class="pc bpc" id="L524" title="4 of 6 branches missed.">            return !error &amp;&amp; (mutationsLeft != 0 || mutationsLeft == ALL_MUTATIONS);</span>
        }

        public void requestTermination()
        {
<span class="nc" id="L529">            error = true;</span>
<span class="nc" id="L530">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>