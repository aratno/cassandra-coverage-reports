<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EstimatedHistogram.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.utils</a> &gt; <span class="el_source">EstimatedHistogram.java</span></div><h1>EstimatedHistogram.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.utils;

import java.io.IOException;
import java.util.Arrays;
import java.util.concurrent.atomic.AtomicLongArray;
import java.util.function.DoubleToLongFunction;

import com.google.common.base.Objects;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.db.TypeSizes;
import org.apache.cassandra.io.ISerializer;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;

public class EstimatedHistogram implements DoubleToLongFunction
{
<span class="fc" id="L36">    public static final EstimatedHistogramSerializer serializer = new EstimatedHistogramSerializer();</span>

    public static final int DEFAULT_BUCKET_COUNT = 90;

    /**
     * The series of values to which the counts in `buckets` correspond:
     * 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 17, 20, etc.
     * Thus, a `buckets` of [0, 0, 1, 10] would mean we had seen one value of 3 and 10 values of 4.
     *
     * The series starts at 1 and grows by 1.2 each time (rounding and removing duplicates). It goes from 1
     * to around 36M by default (creating 90+1 buckets), which will give us timing resolution from microseconds to
     * 36 seconds, with less precision as the numbers get larger.
     *
     * Each bucket represents values from (previous bucket offset, current offset].
     */
    private final long[] bucketOffsets;

    // buckets is one element longer than bucketOffsets -- the last element is values greater than the last offset
    final AtomicLongArray buckets;

    public EstimatedHistogram()
    {
<span class="nc" id="L58">        this(DEFAULT_BUCKET_COUNT);</span>
<span class="nc" id="L59">    }</span>

    public EstimatedHistogram(int bucketCount)
    {
<span class="fc" id="L63">        this(bucketCount, false);</span>
<span class="fc" id="L64">    }</span>

    public EstimatedHistogram(int bucketCount, boolean considerZeroes)
<span class="fc" id="L67">    {</span>
<span class="fc" id="L68">        bucketOffsets = newOffsets(bucketCount, considerZeroes);</span>
<span class="fc" id="L69">        buckets = new AtomicLongArray(bucketOffsets.length + 1);</span>
<span class="fc" id="L70">    }</span>

    /**
     * Create EstimatedHistogram from only bucket data.
     *
     * @param bucketData bucket data
     */
    public EstimatedHistogram(long[] bucketData)
<span class="nc" id="L78">    {</span>
<span class="nc bnc" id="L79" title="All 4 branches missed.">        assert bucketData != null &amp;&amp; bucketData.length &gt; 0 : &quot;Bucket data must be an array of size more than 0&quot;;</span>
<span class="nc" id="L80">        bucketOffsets = newOffsets(bucketData.length - 1, false);</span>
<span class="nc" id="L81">        buckets = new AtomicLongArray(bucketData);</span>
<span class="nc" id="L82">    }</span>

    public EstimatedHistogram(long[] offsets, long[] bucketData)
<span class="fc" id="L85">    {</span>
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">        assert bucketData.length == offsets.length +1;</span>
<span class="fc" id="L87">        bucketOffsets = offsets;</span>
<span class="fc" id="L88">        buckets = new AtomicLongArray(bucketData);</span>
<span class="fc" id="L89">    }</span>

    public static long[] newOffsets(int size, boolean considerZeroes)
    {
<span class="fc bfc" id="L93" title="All 2 branches covered.">        long[] result = new long[size + (considerZeroes ? 1 : 0)];</span>
<span class="fc" id="L94">        int i = 0;</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">        if (considerZeroes)</span>
<span class="fc" id="L96">            result[i++] = 0;</span>
<span class="fc" id="L97">        long last = 1;</span>
<span class="fc" id="L98">        result[i++] = last;</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">        for (; i &lt; result.length; i++)</span>
        {
<span class="fc" id="L101">            long next = Math.round(last * 1.2);</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">            if (next == last)</span>
<span class="fc" id="L103">                next++;</span>
<span class="fc" id="L104">            result[i] = next;</span>
<span class="fc" id="L105">            last = next;</span>
        }

<span class="fc" id="L108">        return result;</span>
    }

    /**
     * @return the histogram values corresponding to each bucket index
     */
    public long[] getBucketOffsets()
    {
<span class="fc" id="L116">        return bucketOffsets;</span>
    }

    private int findIndex(long n)
    {
<span class="fc" id="L121">        int index = Arrays.binarySearch(bucketOffsets, n);</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">        if (index &lt; 0)</span>
        {
            // inexact match, take the first bucket higher than n
<span class="fc" id="L125">            index = -index - 1;</span>
        }
<span class="fc" id="L127">        return index;</span>
    }

    /**
     * Increments the count of the bucket closest to n, rounding UP.
     * @param n
     */
    public void add(long n)
    {
<span class="fc" id="L136">        buckets.incrementAndGet(findIndex(n));</span>
<span class="fc" id="L137">    }</span>

    /**
     * Increments the count of the bucket closest to n, rounding UP by delta
     * @param n
     */
    public void add(long n, long delta)
    {
<span class="fc" id="L145">        buckets.addAndGet(findIndex(n), delta);</span>
<span class="fc" id="L146">    }</span>

    /**
     * @return the count in the given bucket
     */
    long get(int bucket)
    {
<span class="nc" id="L153">        return buckets.get(bucket);</span>
    }

    /**
     * @param reset zero out buckets afterwards if true
     * @return a long[] containing the current histogram buckets
     */
    public long[] getBuckets(boolean reset)
    {
<span class="fc" id="L162">        final int len = buckets.length();</span>
<span class="fc" id="L163">        long[] rv = new long[len];</span>

<span class="pc bpc" id="L165" title="1 of 2 branches missed.">        if (reset)</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">            for (int i = 0; i &lt; len; i++)</span>
<span class="nc" id="L167">                rv[i] = buckets.getAndSet(i, 0L);</span>
        else
<span class="fc bfc" id="L169" title="All 2 branches covered.">            for (int i = 0; i &lt; len; i++)</span>
<span class="fc" id="L170">                rv[i] = buckets.get(i);</span>

<span class="fc" id="L172">        return rv;</span>
    }

    /**
     * @return the smallest value that could have been added to this histogram
     */
    public long min()
    {
<span class="fc bfc" id="L180" title="All 2 branches covered.">        for (int i = 0; i &lt; buckets.length(); i++)</span>
        {
<span class="fc bfc" id="L182" title="All 2 branches covered.">            if (buckets.get(i) &gt; 0)</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">                return i == 0 ? 0 : 1 + bucketOffsets[i - 1];</span>
        }
<span class="fc" id="L185">        return 0;</span>
    }

    /**
     * @return the largest value that could have been added to this histogram.  If the histogram
     * overflowed, returns Long.MAX_VALUE.
     */
    public long max()
    {
<span class="fc" id="L194">        int lastBucket = buckets.length() - 1;</span>
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">        if (buckets.get(lastBucket) &gt; 0)</span>
<span class="nc" id="L196">            return Long.MAX_VALUE;</span>

<span class="fc bfc" id="L198" title="All 2 branches covered.">        for (int i = lastBucket - 1; i &gt;= 0; i--)</span>
        {
<span class="fc bfc" id="L200" title="All 2 branches covered.">            if (buckets.get(i) &gt; 0)</span>
<span class="fc" id="L201">                return bucketOffsets[i];</span>
        }
<span class="fc" id="L203">        return 0;</span>
    }

    /**
     * @param percentile
     * @return estimated value at given percentile
     */
    public long percentile(double percentile)
    {
<span class="pc bpc" id="L212" title="2 of 4 branches missed.">        assert percentile &gt;= 0 &amp;&amp; percentile &lt;= 1.0;</span>
<span class="fc" id="L213">        int lastBucket = buckets.length() - 1;</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">        if (buckets.get(lastBucket) &gt; 0)</span>
<span class="nc" id="L215">            throw new IllegalStateException(&quot;Unable to compute when histogram overflowed&quot;);</span>

<span class="fc" id="L217">        long pcount = (long) Math.ceil(count() * percentile);</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">        if (pcount == 0)</span>
<span class="fc" id="L219">            return 0;</span>

<span class="fc" id="L221">        long elements = 0;</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">        for (int i = 0; i &lt; lastBucket; i++)</span>
        {
<span class="fc" id="L224">            elements += buckets.get(i);</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">            if (elements &gt;= pcount)</span>
<span class="fc" id="L226">                return bucketOffsets[i];</span>
        }
<span class="nc" id="L228">        return 0;</span>
    }

    /**
     * @return the ceil of mean histogram value (average of bucket offsets, weighted by count)
     * @throws IllegalStateException if any values were greater than the largest bucket threshold
     */
    public long mean()
    {
<span class="fc" id="L237">        return (long) Math.ceil(rawMean());</span>
    }

    /**
     * @return the mean histogram value (average of bucket offsets, weighted by count)
     * @throws IllegalStateException if any values were greater than the largest bucket threshold
     */
    public double rawMean()
    {
<span class="fc" id="L246">        int lastBucket = buckets.length() - 1;</span>
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">        if (buckets.get(lastBucket) &gt; 0)</span>
<span class="nc" id="L248">            throw new IllegalStateException(&quot;Unable to compute ceiling for max when histogram overflowed&quot;);</span>

<span class="fc" id="L250">        long elements = 0;</span>
<span class="fc" id="L251">        long sum = 0;</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">        for (int i = 0; i &lt; lastBucket; i++)</span>
        {
<span class="fc" id="L254">            long bCount = buckets.get(i);</span>
<span class="fc" id="L255">            elements += bCount;</span>
<span class="fc" id="L256">            sum += bCount * bucketOffsets[i];</span>
        }

<span class="fc" id="L259">        return (double) sum / elements;</span>
    }

    /**
     * @return the total number of non-zero values
     */
    public long count()
    {
<span class="fc" id="L267">       long sum = 0L;</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">       for (int i = 0; i &lt; buckets.length(); i++)</span>
<span class="fc" id="L269">           sum += buckets.get(i);</span>
<span class="fc" id="L270">       return sum;</span>
    }

    /**
     * @return the largest bucket offset
     */
    public long getLargestBucketOffset()
    {
<span class="nc" id="L278">        return bucketOffsets[bucketOffsets.length - 1];</span>
    }

    /**
     * @return true if a value larger than our largest bucket offset has been recorded, and false otherwise
     */
    public boolean isOverflowed()
    {
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">        return overflowCount() &gt; 0;</span>
    }

    /**
     * @return the number of recorded values larger than the largest bucket offset
     */
    public long overflowCount()
    {
<span class="fc" id="L294">        return buckets.get(buckets.length() - 1);</span>
    }

    /**
     * Resets the count in the overflow bucket to zero. Subsequent calls to {@link #isOverflowed()} will return false.
     */
    public void clearOverflow()
    {
<span class="nc" id="L302">        buckets.set(buckets.length() - 1, 0);</span>
<span class="nc" id="L303">    }</span>

    /**
     * log.debug() every record in the histogram
     *
     * @param log
     */
    public void log(Logger log)
    {
        // only print overflow if there is any
        int nameCount;
<span class="fc bfc" id="L314" title="All 2 branches covered.">        if (buckets.get(buckets.length() - 1) == 0)</span>
<span class="fc" id="L315">            nameCount = buckets.length() - 1;</span>
        else
<span class="fc" id="L317">            nameCount = buckets.length();</span>
<span class="fc" id="L318">        String[] names = new String[nameCount];</span>

<span class="fc" id="L320">        int maxNameLength = 0;</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">        for (int i = 0; i &lt; nameCount; i++)</span>
        {
<span class="fc" id="L323">            names[i] = nameOfRange(bucketOffsets, i);</span>
<span class="fc" id="L324">            maxNameLength = Math.max(maxNameLength, names[i].length());</span>
        }

        // emit log records
<span class="fc" id="L328">        String formatstr = &quot;%&quot; + maxNameLength + &quot;s: %d&quot;;</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">        for (int i = 0; i &lt; nameCount; i++)</span>
        {
<span class="fc" id="L331">            long count = buckets.get(i);</span>
            // sort-of-hack to not print empty ranges at the start that are only used to demarcate the
            // first populated range. for code clarity we don't omit this record from the maxNameLength
            // calculation, and accept the unnecessary whitespace prefixes that will occasionally occur
<span class="fc bfc" id="L335" title="All 4 branches covered.">            if (i == 0 &amp;&amp; count == 0)</span>
<span class="fc" id="L336">                continue;</span>
<span class="fc" id="L337">            log.debug(String.format(formatstr, names[i], count));</span>
        }
<span class="fc" id="L339">    }</span>

    private static String nameOfRange(long[] bucketOffsets, int index)
    {
<span class="fc" id="L343">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L344">        appendRange(sb, bucketOffsets, index);</span>
<span class="fc" id="L345">        return sb.toString();</span>
    }

    private static void appendRange(StringBuilder sb, long[] bucketOffsets, int index)
    {
<span class="fc" id="L350">        sb.append(&quot;[&quot;);</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">        if (index == 0)</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">            if (bucketOffsets[0] &gt; 0)</span>
                // by original definition, this histogram is for values greater than zero only;
                // if values of 0 or less are required, an entry of lb-1 must be inserted at the start
<span class="fc" id="L355">                sb.append(&quot;1&quot;);</span>
            else
<span class="fc" id="L357">                sb.append(&quot;-Inf&quot;);</span>
        else
<span class="fc" id="L359">            sb.append(bucketOffsets[index - 1] + 1);</span>
<span class="fc" id="L360">        sb.append(&quot;..&quot;);</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">        if (index == bucketOffsets.length)</span>
<span class="fc" id="L362">            sb.append(&quot;Inf&quot;);</span>
        else
<span class="fc" id="L364">            sb.append(bucketOffsets[index]);</span>
<span class="fc" id="L365">        sb.append(&quot;]&quot;);</span>
<span class="fc" id="L366">    }</span>

    @Override
    public boolean equals(Object o)
    {
<span class="nc bnc" id="L371" title="All 2 branches missed.">        if (this == o)</span>
<span class="nc" id="L372">            return true;</span>

<span class="nc bnc" id="L374" title="All 2 branches missed.">        if (!(o instanceof EstimatedHistogram))</span>
<span class="nc" id="L375">            return false;</span>

<span class="nc" id="L377">        EstimatedHistogram that = (EstimatedHistogram) o;</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">        return Arrays.equals(getBucketOffsets(), that.getBucketOffsets()) &amp;&amp;</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">               Arrays.equals(getBuckets(false), that.getBuckets(false));</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L385">        return Objects.hashCode(getBucketOffsets(), getBuckets(false));</span>
    }

    @Override
    public long applyAsLong(double value)
    {
<span class="nc" id="L391">        return percentile(value);</span>
    }

<span class="fc" id="L394">    public static class EstimatedHistogramSerializer implements ISerializer&lt;EstimatedHistogram&gt;</span>
    {
<span class="fc" id="L396">        private static final Logger logger = LoggerFactory.getLogger(EstimatedHistogramSerializer.class);</span>

        public void serialize(EstimatedHistogram eh, DataOutputPlus out) throws IOException
        {
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">            if (eh.isOverflowed())</span>
            {
<span class="nc" id="L402">                logger.warn(&quot;Serializing a histogram with {} values greater than the maximum of {}...&quot;,</span>
<span class="nc" id="L403">                            eh.overflowCount(), eh.getLargestBucketOffset());</span>
            }

<span class="fc" id="L406">            long[] offsets = eh.getBucketOffsets();</span>
<span class="fc" id="L407">            long[] buckets = eh.getBuckets(false);</span>
<span class="fc" id="L408">            out.writeInt(buckets.length);</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">            for (int i = 0; i &lt; buckets.length; i++)</span>
            {
<span class="fc bfc" id="L411" title="All 2 branches covered.">                out.writeLong(offsets[i == 0 ? 0 : i - 1]);</span>
<span class="fc" id="L412">                out.writeLong(buckets[i]);</span>
            }
<span class="fc" id="L414">        }</span>

        public EstimatedHistogram deserialize(DataInputPlus in) throws IOException
        {
<span class="fc" id="L418">            int size = in.readInt();</span>
<span class="fc" id="L419">            long[] offsets = new long[size - 1];</span>
<span class="fc" id="L420">            long[] buckets = new long[size];</span>

<span class="fc bfc" id="L422" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++)</span>
            {
<span class="fc bfc" id="L424" title="All 2 branches covered.">                offsets[i == 0 ? 0 : i - 1] = in.readLong();</span>
<span class="fc" id="L425">                buckets[i] = in.readLong();</span>
            }
<span class="fc" id="L427">            return new EstimatedHistogram(offsets, buckets);</span>
        }

        public long serializedSize(EstimatedHistogram eh)
        {
<span class="fc" id="L432">            int size = 0;</span>

<span class="fc" id="L434">            long[] offsets = eh.getBucketOffsets();</span>
<span class="fc" id="L435">            long[] buckets = eh.getBuckets(false);</span>
<span class="fc" id="L436">            size += TypeSizes.sizeof(buckets.length);</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">            for (int i = 0; i &lt; buckets.length; i++)</span>
            {
<span class="fc bfc" id="L439" title="All 2 branches covered.">                size += TypeSizes.sizeof(offsets[i == 0 ? 0 : i - 1]);</span>
<span class="fc" id="L440">                size += TypeSizes.sizeof(buckets[i]);</span>
            }
<span class="fc" id="L442">            return size;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>