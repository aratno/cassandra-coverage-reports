<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ParseUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.functions.types</a> &gt; <span class="el_source">ParseUtils.java</span></div><h1>ParseUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3.functions.types;

import java.text.*;
import java.util.Date;
import java.util.TimeZone;
import java.util.concurrent.TimeUnit;

/**
 * Simple utility class used to help parsing CQL values (mainly UDT and collection ones).
 */
public abstract class ParseUtils
{

    /**
     * Valid ISO-8601 patterns for CQL timestamp literals.
     */
<span class="fc" id="L34">    private static final String[] iso8601Patterns =</span>
    new String[]{
    &quot;yyyy-MM-dd HH:mm&quot;,
    &quot;yyyy-MM-dd HH:mm:ss&quot;,
    &quot;yyyy-MM-dd HH:mmZ&quot;,
    &quot;yyyy-MM-dd HH:mm:ssZ&quot;,
    &quot;yyyy-MM-dd HH:mm:ss.SSS&quot;,
    &quot;yyyy-MM-dd HH:mm:ss.SSSZ&quot;,
    &quot;yyyy-MM-dd'T'HH:mm&quot;,
    &quot;yyyy-MM-dd'T'HH:mmZ&quot;,
    &quot;yyyy-MM-dd'T'HH:mm:ss&quot;,
    &quot;yyyy-MM-dd'T'HH:mm:ssZ&quot;,
    &quot;yyyy-MM-dd'T'HH:mm:ss.SSS&quot;,
    &quot;yyyy-MM-dd'T'HH:mm:ss.SSSZ&quot;,
    &quot;yyyy-MM-dd&quot;,
    &quot;yyyy-MM-ddZ&quot;
    };

    /**
     * Returns the index of the first character in toParse from idx that is not a &quot;space&quot;.
     *
     * @param toParse the string to skip space on.
     * @param idx     the index to start skipping space from.
     * @return the index of the first character in toParse from idx that is not a &quot;space.
     */
    static int skipSpaces(String toParse, int idx)
    {
<span class="nc bnc" id="L61" title="All 2 branches missed.">        while (isBlank(toParse.charAt(idx))) ++idx;</span>
<span class="nc" id="L62">        return idx;</span>
    }

    /**
     * Assuming that idx points to the beginning of a CQL value in toParse, returns the index of the
     * first character after this value.
     *
     * @param toParse the string to skip a value form.
     * @param idx     the index to start parsing a value from.
     * @return the index ending the CQL value starting at {@code idx}.
     * @throws IllegalArgumentException if idx doesn't point to the start of a valid CQL value.
     */
    static int skipCQLValue(String toParse, int idx)
    {
<span class="nc bnc" id="L76" title="All 2 branches missed.">        if (idx &gt;= toParse.length()) throw new IllegalArgumentException();</span>

<span class="nc bnc" id="L78" title="All 2 branches missed.">        if (isBlank(toParse.charAt(idx))) throw new IllegalArgumentException();</span>

<span class="nc" id="L80">        int cbrackets = 0;</span>
<span class="nc" id="L81">        int sbrackets = 0;</span>
<span class="nc" id="L82">        int parens = 0;</span>
<span class="nc" id="L83">        boolean inString = false;</span>

        do
        {
<span class="nc" id="L87">            char c = toParse.charAt(idx);</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">            if (inString)</span>
            {
<span class="nc bnc" id="L90" title="All 2 branches missed.">                if (c == '\'')</span>
                {
<span class="nc bnc" id="L92" title="All 4 branches missed.">                    if (idx + 1 &lt; toParse.length() &amp;&amp; toParse.charAt(idx + 1) == '\'')</span>
                    {
<span class="nc" id="L94">                        ++idx; // this is an escaped quote, skip it</span>
                    }
                    else
                    {
<span class="nc" id="L98">                        inString = false;</span>
<span class="nc bnc" id="L99" title="All 6 branches missed.">                        if (cbrackets == 0 &amp;&amp; sbrackets == 0 &amp;&amp; parens == 0) return idx + 1;</span>
                    }
                }
                // Skip any other character
            }
<span class="nc bnc" id="L104" title="All 2 branches missed.">            else if (c == '\'')</span>
            {
<span class="nc" id="L106">                inString = true;</span>
            }
<span class="nc bnc" id="L108" title="All 2 branches missed.">            else if (c == '{')</span>
            {
<span class="nc" id="L110">                ++cbrackets;</span>
            }
<span class="nc bnc" id="L112" title="All 2 branches missed.">            else if (c == '[')</span>
            {
<span class="nc" id="L114">                ++sbrackets;</span>
            }
<span class="nc bnc" id="L116" title="All 2 branches missed.">            else if (c == '(')</span>
            {
<span class="nc" id="L118">                ++parens;</span>
            }
<span class="nc bnc" id="L120" title="All 2 branches missed.">            else if (c == '}')</span>
            {
<span class="nc bnc" id="L122" title="All 2 branches missed.">                if (cbrackets == 0) return idx;</span>

<span class="nc" id="L124">                --cbrackets;</span>
<span class="nc bnc" id="L125" title="All 6 branches missed.">                if (cbrackets == 0 &amp;&amp; sbrackets == 0 &amp;&amp; parens == 0) return idx + 1;</span>
            }
<span class="nc bnc" id="L127" title="All 2 branches missed.">            else if (c == ']')</span>
            {
<span class="nc bnc" id="L129" title="All 2 branches missed.">                if (sbrackets == 0) return idx;</span>

<span class="nc" id="L131">                --sbrackets;</span>
<span class="nc bnc" id="L132" title="All 6 branches missed.">                if (cbrackets == 0 &amp;&amp; sbrackets == 0 &amp;&amp; parens == 0) return idx + 1;</span>
            }
<span class="nc bnc" id="L134" title="All 2 branches missed.">            else if (c == ')')</span>
            {
<span class="nc bnc" id="L136" title="All 2 branches missed.">                if (parens == 0) return idx;</span>

<span class="nc" id="L138">                --parens;</span>
<span class="nc bnc" id="L139" title="All 6 branches missed.">                if (cbrackets == 0 &amp;&amp; sbrackets == 0 &amp;&amp; parens == 0) return idx + 1;</span>
            }
<span class="nc bnc" id="L141" title="All 4 branches missed.">            else if (isBlank(c) || !isIdentifierChar(c))</span>
            {
<span class="nc bnc" id="L143" title="All 6 branches missed.">                if (cbrackets == 0 &amp;&amp; sbrackets == 0 &amp;&amp; parens == 0) return idx;</span>
            }
<span class="nc bnc" id="L145" title="All 2 branches missed.">        } while (++idx &lt; toParse.length());</span>

<span class="nc bnc" id="L147" title="All 8 branches missed.">        if (inString || cbrackets != 0 || sbrackets != 0 || parens != 0)</span>
<span class="nc" id="L148">            throw new IllegalArgumentException();</span>
<span class="nc" id="L149">        return idx;</span>
    }

    /**
     * Assuming that idx points to the beginning of a CQL identifier in toParse, returns the index of
     * the first character after this identifier.
     *
     * @param toParse the string to skip an identifier from.
     * @param idx     the index to start parsing an identifier from.
     * @return the index ending the CQL identifier starting at {@code idx}.
     * @throws IllegalArgumentException if idx doesn't point to the start of a valid CQL identifier.
     */
    static int skipCQLId(String toParse, int idx)
    {
<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (idx &gt;= toParse.length()) throw new IllegalArgumentException();</span>

<span class="nc" id="L165">        char c = toParse.charAt(idx);</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">        if (isIdentifierChar(c))</span>
        {
<span class="nc bnc" id="L168" title="All 4 branches missed.">            while (idx &lt; toParse.length() &amp;&amp; isIdentifierChar(toParse.charAt(idx))) idx++;</span>
<span class="nc" id="L169">            return idx;</span>
        }

<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (c != '&quot;') throw new IllegalArgumentException();</span>

<span class="nc bnc" id="L174" title="All 2 branches missed.">        while (++idx &lt; toParse.length())</span>
        {
<span class="nc" id="L176">            c = toParse.charAt(idx);</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">            if (c != '&quot;') continue;</span>

<span class="nc bnc" id="L179" title="All 4 branches missed.">            if (idx + 1 &lt; toParse.length() &amp;&amp; toParse.charAt(idx + 1) == '\&quot;')</span>
<span class="nc" id="L180">                ++idx; // this is an escaped double quote, skip it</span>
<span class="nc" id="L181">            else return idx + 1;</span>
        }
<span class="nc" id="L183">        throw new IllegalArgumentException();</span>
    }

    /**
     * Return {@code true} if the given character is allowed in a CQL identifier, that is, if it is in
     * the range: {@code [0..9a..zA..Z-+._&amp;]}.
     *
     * @param c The character to inspect.
     * @return {@code true} if the given character is allowed in a CQL identifier, {@code false}
     * otherwise.
     */
    static boolean isIdentifierChar(int c)
    {
<span class="pc bpc" id="L196" title="6 of 22 branches missed.">        return (c &gt;= '0' &amp;&amp; c &lt;= '9')</span>
               || (c &gt;= 'a' &amp;&amp; c &lt;= 'z')
               || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z')
               || c == '-'
               || c == '+'
               || c == '.'
               || c == '_'
               || c == '&amp;';
    }

    /**
     * Return {@code true} if the given character is a valid whitespace character in CQL, that is, if
     * it is a regular space, a tabulation sign, or a new line sign.
     *
     * @param c The character to inspect.
     * @return {@code true} if the given character is a valid whitespace character, {@code false}
     * otherwise.
     */
    static boolean isBlank(int c)
    {
<span class="pc bpc" id="L216" title="3 of 6 branches missed.">        return c == ' ' || c == '\t' || c == '\n';</span>
    }

    /**
     * Check whether the given string corresponds to a valid CQL long literal. Long literals are
     * composed solely by digits, but can have an optional leading minus sign.
     *
     * @param str The string to inspect.
     * @return {@code true} if the given string corresponds to a valid CQL integer literal, {@code
     * false} otherwise.
     */
    static boolean isLongLiteral(String str)
    {
<span class="nc bnc" id="L229" title="All 4 branches missed.">        if (str == null || str.isEmpty()) return false;</span>
<span class="nc" id="L230">        char[] chars = str.toCharArray();</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">        for (int i = 0; i &lt; chars.length; i++)</span>
        {
<span class="nc" id="L233">            char c = chars[i];</span>
<span class="nc bnc" id="L234" title="All 8 branches missed.">            if ((c &lt; '0' &amp;&amp; (i != 0 || c != '-')) || c &gt; '9') return false;</span>
        }
<span class="nc" id="L236">        return true;</span>
    }

    /**
     * Return {@code true} if the given string is surrounded by single quotes, and {@code false}
     * otherwise.
     *
     * @param value The string to inspect.
     * @return {@code true} if the given string is surrounded by single quotes, and {@code false}
     * otherwise.
     */
    static boolean isQuoted(String value)
    {
<span class="nc" id="L249">        return isQuoted(value, '\'');</span>
    }

    /**
     * Quote the given string; single quotes are escaped. If the given string is null, this method
     * returns a quoted empty string ({@code ''}).
     *
     * @param value The value to quote.
     * @return The quoted string.
     */
    public static String quote(String value)
    {
<span class="fc" id="L261">        return quote(value, '\'');</span>
    }

    /**
     * Unquote the given string if it is quoted; single quotes are unescaped. If the given string is
     * not quoted, it is returned without any modification.
     *
     * @param value The string to unquote.
     * @return The unquoted string.
     */
    static String unquote(String value)
    {
<span class="nc" id="L273">        return unquote(value, '\'');</span>
    }

    /**
     * Double quote the given string; double quotes are escaped. If the given string is null, this
     * method returns a quoted empty string ({@code &quot;&quot;}).
     *
     * @param value The value to double quote.
     * @return The double quoted string.
     */
    static String doubleQuote(String value)
    {
<span class="nc" id="L285">        return quote(value, '&quot;');</span>
    }

    /**
     * Unquote the given string if it is double quoted; double quotes are unescaped. If the given
     * string is not double quoted, it is returned without any modification.
     *
     * @param value The string to un-double quote.
     * @return The un-double quoted string.
     */
    public static String unDoubleQuote(String value)
    {
<span class="nc" id="L297">        return unquote(value, '&quot;');</span>
    }

    /**
     * Parse the given string as a date, using one of the accepted ISO-8601 date patterns.
     *
     * &lt;p&gt;This method is adapted from Apache Commons {@code DateUtils.parseStrictly()} method (that is
     * used Cassandra side to parse date strings)..
     *
     * @throws ParseException If the given string is not a valid ISO-8601 date.
     * @see &lt;a href=&quot;https://cassandra.apache.org/doc/cql3/CQL-2.2.html#usingtimestamps&quot;&gt;'Working with
     * timestamps' section of CQL specification&lt;/a&gt;
     */
    static Date parseDate(String str) throws ParseException
    {
<span class="nc" id="L312">        SimpleDateFormat parser = new SimpleDateFormat();</span>
<span class="nc" id="L313">        parser.setLenient(false);</span>
        // set a default timezone for patterns that do not provide one
<span class="nc" id="L315">        parser.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));</span>
        // Java 6 has very limited support for ISO-8601 time zone formats,
        // so we need to transform the string first
        // so that accepted patterns are correctly handled,
        // such as Z for UTC, or &quot;+00:00&quot; instead of &quot;+0000&quot;.
        // Note: we cannot use the X letter in the pattern
        // because it has been introduced in Java 7.
<span class="nc" id="L322">        str = str.replaceAll(&quot;(\\+|\\-)(\\d\\d):(\\d\\d)$&quot;, &quot;$1$2$3&quot;);</span>
<span class="nc" id="L323">        str = str.replaceAll(&quot;Z$&quot;, &quot;+0000&quot;);</span>
<span class="nc" id="L324">        ParsePosition pos = new ParsePosition(0);</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">        for (String parsePattern : iso8601Patterns)</span>
        {
<span class="nc" id="L327">            parser.applyPattern(parsePattern);</span>
<span class="nc" id="L328">            pos.setIndex(0);</span>
<span class="nc" id="L329">            Date date = parser.parse(str, pos);</span>
<span class="nc bnc" id="L330" title="All 4 branches missed.">            if (date != null &amp;&amp; pos.getIndex() == str.length())</span>
            {
<span class="nc" id="L332">                return date;</span>
            }
        }
<span class="nc" id="L335">        throw new ParseException(&quot;Unable to parse the date: &quot; + str, -1);</span>
    }

    /**
     * Parse the given string as a date, using the supplied date pattern.
     *
     * &lt;p&gt;This method is adapted from Apache Commons {@code DateUtils.parseStrictly()} method (that is
     * used Cassandra side to parse date strings)..
     *
     * @throws ParseException If the given string cannot be parsed with the given pattern.
     * @see &lt;a href=&quot;https://cassandra.apache.org/doc/cql3/CQL-2.2.html#usingtimestamps&quot;&gt;'Working with
     * timestamps' section of CQL specification&lt;/a&gt;
     */
    static Date parseDate(String str, String pattern) throws ParseException
    {
<span class="nc" id="L350">        SimpleDateFormat parser = new SimpleDateFormat();</span>
<span class="nc" id="L351">        parser.setLenient(false);</span>
        // set a default timezone for patterns that do not provide one
<span class="nc" id="L353">        parser.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));</span>
        // Java 6 has very limited support for ISO-8601 time zone formats,
        // so we need to transform the string first
        // so that accepted patterns are correctly handled,
        // such as Z for UTC, or &quot;+00:00&quot; instead of &quot;+0000&quot;.
        // Note: we cannot use the X letter in the pattern
        // because it has been introduced in Java 7.
<span class="nc" id="L360">        str = str.replaceAll(&quot;(\\+|\\-)(\\d\\d):(\\d\\d)$&quot;, &quot;$1$2$3&quot;);</span>
<span class="nc" id="L361">        str = str.replaceAll(&quot;Z$&quot;, &quot;+0000&quot;);</span>
<span class="nc" id="L362">        ParsePosition pos = new ParsePosition(0);</span>
<span class="nc" id="L363">        parser.applyPattern(pattern);</span>
<span class="nc" id="L364">        pos.setIndex(0);</span>
<span class="nc" id="L365">        Date date = parser.parse(str, pos);</span>
<span class="nc bnc" id="L366" title="All 4 branches missed.">        if (date != null &amp;&amp; pos.getIndex() == str.length())</span>
        {
<span class="nc" id="L368">            return date;</span>
        }
<span class="nc" id="L370">        throw new ParseException(&quot;Unable to parse the date: &quot; + str, -1);</span>
    }

    /**
     * Parse the given string as a time, using the following time pattern: {@code
     * hh:mm:ss[.fffffffff]}.
     *
     * &lt;p&gt;This method is loosely based on {@code java.sql.Timestamp}.
     *
     * @param str The string to parse.
     * @return A long value representing the number of nanoseconds since midnight.
     * @throws ParseException if the string cannot be parsed.
     * @see &lt;a href=&quot;https://cassandra.apache.org/doc/cql3/CQL-2.2.html#usingtime&quot;&gt;'Working with time'
     * section of CQL specification&lt;/a&gt;
     */
    static long parseTime(String str) throws ParseException
    {
        String nanos_s;

        long hour;
        long minute;
        long second;
<span class="nc" id="L392">        long a_nanos = 0;</span>

<span class="nc" id="L394">        String formatError = &quot;Timestamp format must be hh:mm:ss[.fffffffff]&quot;;</span>
<span class="nc" id="L395">        String zeros = &quot;000000000&quot;;</span>

<span class="nc bnc" id="L397" title="All 2 branches missed.">        if (str == null) throw new IllegalArgumentException(formatError);</span>
<span class="nc" id="L398">        str = str.trim();</span>

        // Parse the time
<span class="nc" id="L401">        int firstColon = str.indexOf(':');</span>
<span class="nc" id="L402">        int secondColon = str.indexOf(':', firstColon + 1);</span>

        // Convert the time; default missing nanos
<span class="nc bnc" id="L405" title="All 6 branches missed.">        if (firstColon &gt; 0 &amp;&amp; secondColon &gt; 0 &amp;&amp; secondColon &lt; str.length() - 1)</span>
        {
<span class="nc" id="L407">            int period = str.indexOf('.', secondColon + 1);</span>
<span class="nc" id="L408">            hour = Integer.parseInt(str.substring(0, firstColon));</span>
<span class="nc bnc" id="L409" title="All 4 branches missed.">            if (hour &lt; 0 || hour &gt;= 24) throw new IllegalArgumentException(&quot;Hour out of bounds.&quot;);</span>

<span class="nc" id="L411">            minute = Integer.parseInt(str.substring(firstColon + 1, secondColon));</span>
<span class="nc bnc" id="L412" title="All 4 branches missed.">            if (minute &lt; 0 || minute &gt;= 60) throw new IllegalArgumentException(&quot;Minute out of bounds.&quot;);</span>

<span class="nc bnc" id="L414" title="All 4 branches missed.">            if (period &gt; 0 &amp;&amp; period &lt; str.length() - 1)</span>
            {
<span class="nc" id="L416">                second = Integer.parseInt(str.substring(secondColon + 1, period));</span>
<span class="nc bnc" id="L417" title="All 4 branches missed.">                if (second &lt; 0 || second &gt;= 60) throw new IllegalArgumentException(&quot;Second out of bounds.&quot;);</span>

<span class="nc" id="L419">                nanos_s = str.substring(period + 1);</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">                if (nanos_s.length() &gt; 9) throw new IllegalArgumentException(formatError);</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">                if (!Character.isDigit(nanos_s.charAt(0))) throw new IllegalArgumentException(formatError);</span>
<span class="nc" id="L422">                nanos_s = nanos_s + zeros.substring(0, 9 - nanos_s.length());</span>
<span class="nc" id="L423">                a_nanos = Integer.parseInt(nanos_s);</span>
            }
<span class="nc bnc" id="L425" title="All 2 branches missed.">            else if (period &gt; 0) throw new ParseException(formatError, -1);</span>
            else
            {
<span class="nc" id="L428">                second = Integer.parseInt(str.substring(secondColon + 1));</span>
<span class="nc bnc" id="L429" title="All 4 branches missed.">                if (second &lt; 0 || second &gt;= 60) throw new ParseException(&quot;Second out of bounds.&quot;, -1);</span>
            }
<span class="nc" id="L431">        }</span>
<span class="nc" id="L432">        else throw new ParseException(formatError, -1);</span>

<span class="nc" id="L434">        long rawTime = 0;</span>
<span class="nc" id="L435">        rawTime += TimeUnit.HOURS.toNanos(hour);</span>
<span class="nc" id="L436">        rawTime += TimeUnit.MINUTES.toNanos(minute);</span>
<span class="nc" id="L437">        rawTime += TimeUnit.SECONDS.toNanos(second);</span>
<span class="nc" id="L438">        rawTime += a_nanos;</span>
<span class="nc" id="L439">        return rawTime;</span>
    }

    /**
     * Format the given long value as a CQL time literal, using the following time pattern: {@code
     * hh:mm:ss[.fffffffff]}.
     *
     * @param value A long value representing the number of nanoseconds since midnight.
     * @return The formatted value.
     * @see &lt;a href=&quot;https://cassandra.apache.org/doc/cql3/CQL-2.2.html#usingtime&quot;&gt;'Working with time'
     * section of CQL specification&lt;/a&gt;
     */
    static String formatTime(long value)
    {
<span class="nc" id="L453">        int nano = (int) (value % 1000000000);</span>
<span class="nc" id="L454">        value -= nano;</span>
<span class="nc" id="L455">        value /= 1000000000;</span>
<span class="nc" id="L456">        int seconds = (int) (value % 60);</span>
<span class="nc" id="L457">        value -= seconds;</span>
<span class="nc" id="L458">        value /= 60;</span>
<span class="nc" id="L459">        int minutes = (int) (value % 60);</span>
<span class="nc" id="L460">        value -= minutes;</span>
<span class="nc" id="L461">        value /= 60;</span>
<span class="nc" id="L462">        int hours = (int) (value % 24);</span>
<span class="nc" id="L463">        value -= hours;</span>
<span class="nc" id="L464">        value /= 24;</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">        assert (value == 0);</span>
<span class="nc" id="L466">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L467">        leftPadZeros(hours, 2, sb);</span>
<span class="nc" id="L468">        sb.append(':');</span>
<span class="nc" id="L469">        leftPadZeros(minutes, 2, sb);</span>
<span class="nc" id="L470">        sb.append(':');</span>
<span class="nc" id="L471">        leftPadZeros(seconds, 2, sb);</span>
<span class="nc" id="L472">        sb.append('.');</span>
<span class="nc" id="L473">        leftPadZeros(nano, 9, sb);</span>
<span class="nc" id="L474">        return sb.toString();</span>
    }

    /**
     * Return {@code true} if the given string is surrounded by the quote character given, and {@code
     * false} otherwise.
     *
     * @param value The string to inspect.
     * @return {@code true} if the given string is surrounded by the quote character, and {@code
     * false} otherwise.
     */
    public static boolean isQuoted(String value, char quoteChar)
    {
<span class="nc bnc" id="L487" title="All 2 branches missed.">        return value != null</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">               &amp;&amp; value.length() &gt; 1</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">               &amp;&amp; value.charAt(0) == quoteChar</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">               &amp;&amp; value.charAt(value.length() - 1) == quoteChar;</span>
    }

    /**
     * @param quoteChar &quot; or '
     * @return A quoted empty string.
     */
    private static String emptyQuoted(char quoteChar)
    {
        // don't handle non quote characters, this is done so that these are interned and don't create
        // repeated empty quoted strings.
<span class="pc bpc" id="L501" title="2 of 4 branches missed.">        assert quoteChar == '&quot;' || quoteChar == '\'';</span>
<span class="pc bpc" id="L502" title="1 of 2 branches missed.">        if (quoteChar == '&quot;') return &quot;\&quot;\&quot;&quot;;</span>
<span class="fc" id="L503">        else return &quot;''&quot;;</span>
    }

    /**
     * Quotes text and escapes any existing quotes in the text. {@code String.replace()} is a bit too
     * inefficient (see JAVA-67, JAVA-1262).
     *
     * @param text      The text.
     * @param quoteChar The character to use as a quote.
     * @return The text with surrounded in quotes with all existing quotes escaped with (i.e. '
     * becomes '')
     */
    private static String quote(String text, char quoteChar)
    {
<span class="pc bpc" id="L517" title="2 of 4 branches missed.">        if (text == null || text.isEmpty()) return emptyQuoted(quoteChar);</span>

<span class="nc" id="L519">        int nbMatch = 0;</span>
<span class="nc" id="L520">        int start = -1;</span>
        do
        {
<span class="nc" id="L523">            start = text.indexOf(quoteChar, start + 1);</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">            if (start != -1) ++nbMatch;</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">        } while (start != -1);</span>

        // no quotes found that need to be escaped, simply surround in quotes and return.
<span class="nc bnc" id="L528" title="All 2 branches missed.">        if (nbMatch == 0) return quoteChar + text + quoteChar;</span>

        // 2 for beginning and end quotes.
        // length for original text
        // nbMatch for escape characters to add to quotes to be escaped.
<span class="nc" id="L533">        int newLength = 2 + text.length() + nbMatch;</span>
<span class="nc" id="L534">        char[] result = new char[newLength];</span>
<span class="nc" id="L535">        result[0] = quoteChar;</span>
<span class="nc" id="L536">        result[newLength - 1] = quoteChar;</span>
<span class="nc" id="L537">        int newIdx = 1;</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">        for (int i = 0; i &lt; text.length(); i++)</span>
        {
<span class="nc" id="L540">            char c = text.charAt(i);</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">            if (c == quoteChar)</span>
            {
                // escape quote with another occurrence.
<span class="nc" id="L544">                result[newIdx++] = c;</span>
<span class="nc" id="L545">                result[newIdx++] = c;</span>
            }
            else
            {
<span class="nc" id="L549">                result[newIdx++] = c;</span>
            }
        }
<span class="nc" id="L552">        return new String(result);</span>
    }

    /**
     * Unquotes text and unescapes non surrounding quotes. {@code String.replace()} is a bit too
     * inefficient (see JAVA-67, JAVA-1262).
     *
     * @param text      The text
     * @param quoteChar The character to use as a quote.
     * @return The text with surrounding quotes removed and non surrounding quotes unescaped (i.e. ''
     * becomes ')
     */
    private static String unquote(String text, char quoteChar)
    {
<span class="nc bnc" id="L566" title="All 2 branches missed.">        if (!isQuoted(text, quoteChar)) return text;</span>

<span class="nc bnc" id="L568" title="All 2 branches missed.">        if (text.length() == 2) return &quot;&quot;;</span>

<span class="nc" id="L570">        String search = emptyQuoted(quoteChar);</span>
<span class="nc" id="L571">        int nbMatch = 0;</span>
<span class="nc" id="L572">        int start = -1;</span>
        do
        {
<span class="nc" id="L575">            start = text.indexOf(search, start + 2);</span>
            // ignore the second to last character occurrence, as the last character is a quote.
<span class="nc bnc" id="L577" title="All 4 branches missed.">            if (start != -1 &amp;&amp; start != text.length() - 2) ++nbMatch;</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">        } while (start != -1);</span>

        // no escaped quotes found, simply remove surrounding quotes and return.
<span class="nc bnc" id="L581" title="All 2 branches missed.">        if (nbMatch == 0) return text.substring(1, text.length() - 1);</span>

        // length of the new string will be its current length - the number of occurrences.
<span class="nc" id="L584">        int newLength = text.length() - nbMatch - 2;</span>
<span class="nc" id="L585">        char[] result = new char[newLength];</span>
<span class="nc" id="L586">        int newIdx = 0;</span>
        // track whenever a quoteChar is encountered and the previous character is not a quoteChar.
<span class="nc" id="L588">        boolean firstFound = false;</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">        for (int i = 1; i &lt; text.length() - 1; i++)</span>
        {
<span class="nc" id="L591">            char c = text.charAt(i);</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">            if (c == quoteChar)</span>
            {
<span class="nc bnc" id="L594" title="All 2 branches missed.">                if (firstFound)</span>
                {
                    // The previous character was a quoteChar, don't add this to result, this action in
                    // effect removes consecutive quotes.
<span class="nc" id="L598">                    firstFound = false;</span>
                }
                else
                {
                    // found a quoteChar and the previous character was not a quoteChar, include in result.
<span class="nc" id="L603">                    firstFound = true;</span>
<span class="nc" id="L604">                    result[newIdx++] = c;</span>
                }
            }
            else
            {
                // non quoteChar encountered, include in result.
<span class="nc" id="L610">                result[newIdx++] = c;</span>
<span class="nc" id="L611">                firstFound = false;</span>
            }
        }
<span class="nc" id="L614">        return new String(result);</span>
    }

    private static void leftPadZeros(int value, int digits, StringBuilder sb)
    {
<span class="nc" id="L619">        sb.append(String.format(&quot;%0&quot; + digits + 'd', value));</span>
<span class="nc" id="L620">    }</span>

    private ParseUtils()
    {
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>