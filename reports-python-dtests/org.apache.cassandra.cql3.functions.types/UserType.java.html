<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UserType.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.functions.types</a> &gt; <span class="el_source">UserType.java</span></div><h1>UserType.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3.functions.types;

import java.util.*;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Iterators;

import org.apache.cassandra.transport.ProtocolVersion;

/**
 * A User Defined Type (UDT).
 *
 * &lt;p&gt;A UDT is a essentially a named collection of fields (with a name and a type).
 */
public class UserType extends DataType implements Iterable&lt;UserType.Field&gt;
{

    private final String keyspace;
    private final String typeName;
    private final boolean frozen;
    private final ProtocolVersion protocolVersion;

    // can be null, if this object is being constructed from a response message
    // see Responses.Result.Rows.Metadata.decode()
    private final CodecRegistry codecRegistry;

    // Note that we don't expose the order of fields, from an API perspective this is a map
    // of String-&gt;Field, but internally we care about the order because the serialization format
    // of UDT expects a particular order.
    final Field[] byIdx;
    // For a given name, we can only have one field with that name, so we don't need a int[] in
    // practice. However, storing one element arrays save allocations in UDTValue.getAllIndexesOf
    // implementation.
    final Map&lt;String, int[]&gt; byName;

    private UserType(
    Name name,
    String keyspace,
    String typeName,
    boolean frozen,
    ProtocolVersion protocolVersion,
    CodecRegistry codecRegistry,
    Field[] byIdx,
    Map&lt;String, int[]&gt; byName)
    {
<span class="fc" id="L63">        super(name);</span>
<span class="fc" id="L64">        this.keyspace = keyspace;</span>
<span class="fc" id="L65">        this.typeName = typeName;</span>
<span class="fc" id="L66">        this.frozen = frozen;</span>
<span class="fc" id="L67">        this.protocolVersion = protocolVersion;</span>
<span class="fc" id="L68">        this.codecRegistry = codecRegistry;</span>
<span class="fc" id="L69">        this.byIdx = byIdx;</span>
<span class="fc" id="L70">        this.byName = byName;</span>
<span class="fc" id="L71">    }</span>

    UserType(
    String keyspace,
    String typeName,
    boolean frozen,
    Collection&lt;Field&gt; fields,
    ProtocolVersion protocolVersion,
    CodecRegistry codecRegistry)
    {
<span class="fc" id="L81">        this(</span>
        DataType.Name.UDT,
        keyspace,
        typeName,
        frozen,
        protocolVersion,
        codecRegistry,
<span class="fc" id="L88">        fields.toArray(new Field[fields.size()]),</span>
<span class="fc" id="L89">        mapByName(fields));</span>
<span class="fc" id="L90">    }</span>

    private static ImmutableMap&lt;String, int[]&gt; mapByName(Collection&lt;Field&gt; fields)
    {
<span class="fc" id="L94">        ImmutableMap.Builder&lt;String, int[]&gt; builder = new ImmutableMap.Builder&lt;&gt;();</span>
<span class="fc" id="L95">        int i = 0;</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">        for (Field field : fields)</span>
        {
<span class="fc" id="L98">            builder.put(field.getName(), new int[]{ i });</span>
<span class="fc" id="L99">            i += 1;</span>
<span class="fc" id="L100">        }</span>
<span class="fc" id="L101">        return builder.build();</span>
    }

    /**
     * Returns a new empty value for this user type definition.
     *
     * @return an empty value for this user type definition.
     */
    public UDTValue newValue()
    {
<span class="fc" id="L111">        return new UDTValue(this);</span>
    }

    /**
     * The name of the keyspace this UDT is part of.
     *
     * @return the name of the keyspace this UDT is part of.
     */
    public String getKeyspace()
    {
<span class="nc" id="L121">        return keyspace;</span>
    }

    /**
     * The name of this user type.
     *
     * @return the name of this user type.
     */
    public String getTypeName()
    {
<span class="nc" id="L131">        return typeName;</span>
    }

    /**
     * Returns the number of fields in this UDT.
     *
     * @return the number of fields in this UDT.
     */
    public int size()
    {
<span class="fc" id="L141">        return byIdx.length;</span>
    }

    /**
     * Returns whether this UDT contains a given field.
     *
     * @param name the name to check. Note that {@code name} obey the usual CQL identifier rules: it
     *             should be quoted if it denotes a case sensitive identifier (you can use {@link
     *             Metadata#quote} for the quoting).
     * @return {@code true} if this UDT contains a field named {@code name}, {@code false} otherwise.
     */
    public boolean contains(String name)
    {
<span class="nc" id="L154">        return byName.containsKey(Metadata.handleId(name));</span>
    }

    /**
     * Returns an iterator over the fields of this UDT.
     *
     * @return an iterator over the fields of this UDT.
     */
    @Override
    public Iterator&lt;Field&gt; iterator()
    {
<span class="fc" id="L165">        return Iterators.forArray(byIdx);</span>
    }

    /**
     * Returns the type of a given field.
     *
     * @param name the name of the field. Note that {@code name} obey the usual CQL identifier rules:
     *             it should be quoted if it denotes a case sensitive identifier (you can use {@link
     *             Metadata#quote} for the quoting).
     * @return the type of field {@code name} if this UDT has a field of this name, {@code null}
     * otherwise.
     * @throws IllegalArgumentException if {@code name} is not a field of this UDT definition.
     */
    DataType getFieldType(String name)
    {
<span class="nc" id="L180">        int[] idx = byName.get(Metadata.handleId(name));</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">        if (idx == null)</span>
<span class="nc" id="L182">            throw new IllegalArgumentException(name + &quot; is not a field defined in this definition&quot;);</span>

<span class="nc" id="L184">        return byIdx[idx[0]].getType();</span>
    }

    @Override
    public boolean isFrozen()
    {
<span class="nc" id="L190">        return frozen;</span>
    }

    public UserType copy(boolean newFrozen)
    {
<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (newFrozen == frozen)</span>
        {
<span class="nc" id="L197">            return this;</span>
        }
        else
        {
<span class="nc" id="L201">            return new UserType(</span>
            name, keyspace, typeName, newFrozen, protocolVersion, codecRegistry, byIdx, byName);
        }
    }

    @Override
    public int hashCode()
    {
<span class="fc" id="L209">        int result = name.hashCode();</span>
<span class="fc" id="L210">        result = 31 * result + keyspace.hashCode();</span>
<span class="fc" id="L211">        result = 31 * result + typeName.hashCode();</span>
<span class="fc" id="L212">        result = 31 * result + Arrays.hashCode(byIdx);</span>
<span class="fc" id="L213">        return result;</span>
    }

    @Override
    public boolean equals(Object o)
    {
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">        if (!(o instanceof UserType)) return false;</span>

<span class="fc" id="L221">        UserType other = (UserType) o;</span>

        // Note: we don't test byName because it's redundant with byIdx in practice,
        // but also because the map holds 'int[]' which don't have proper equal.
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">        return name.equals(other.name)</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">               &amp;&amp; keyspace.equals(other.keyspace)</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">               &amp;&amp; typeName.equals(other.typeName)</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">               &amp;&amp; Arrays.equals(byIdx, other.byIdx);</span>
    }

    /**
     * Return the protocol version that has been used to deserialize this UDT, or that will be used to
     * serialize it. In most cases this should be the version currently in use by the cluster instance
     * that this UDT belongs to, as reported by {@code ProtocolOptions#getProtocolVersion()}.
     *
     * @return the protocol version that has been used to deserialize this UDT, or that will be used
     * to serialize it.
     */
    ProtocolVersion getProtocolVersion()
    {
<span class="fc" id="L241">        return protocolVersion;</span>
    }

    CodecRegistry getCodecRegistry()
    {
<span class="fc" id="L246">        return codecRegistry;</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L252">        String str =</span>
<span class="nc" id="L253">        Metadata.quoteIfNecessary(getKeyspace()) + '.' + Metadata.quoteIfNecessary(getTypeName());</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">        return isFrozen() ? &quot;frozen&lt;&quot; + str + '&gt;' : str;</span>
    }

    @Override
    public String asFunctionParameterString()
    {
<span class="nc" id="L260">        return Metadata.quoteIfNecessary(getTypeName());</span>
    }

    /**
     * A UDT field.
     */
    public static class Field
    {
        private final String name;
        private final DataType type;

        Field(String name, DataType type)
<span class="fc" id="L272">        {</span>
<span class="fc" id="L273">            this.name = name;</span>
<span class="fc" id="L274">            this.type = type;</span>
<span class="fc" id="L275">        }</span>

        /**
         * Returns the name of the field.
         *
         * @return the name of the field.
         */
        public String getName()
        {
<span class="fc" id="L284">            return name;</span>
        }

        /**
         * Returns the type of the field.
         *
         * @return the type of the field.
         */
        public DataType getType()
        {
<span class="fc" id="L294">            return type;</span>
        }

        @Override
        public final int hashCode()
        {
<span class="fc" id="L300">            return Arrays.hashCode(new Object[]{ name, type });</span>
        }

        @Override
        public final boolean equals(Object o)
        {
<span class="nc bnc" id="L306" title="All 2 branches missed.">            if (!(o instanceof Field)) return false;</span>

<span class="nc" id="L308">            Field other = (Field) o;</span>
<span class="nc bnc" id="L309" title="All 4 branches missed.">            return name.equals(other.name) &amp;&amp; type.equals(other.type);</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L315">            return Metadata.quoteIfNecessary(name) + ' ' + type;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>