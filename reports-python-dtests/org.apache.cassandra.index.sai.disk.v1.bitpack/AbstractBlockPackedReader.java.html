<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractBlockPackedReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.index.sai.disk.v1.bitpack</a> &gt; <span class="el_source">AbstractBlockPackedReader.java</span></div><h1>AbstractBlockPackedReader.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.index.sai.disk.v1.bitpack;

import javax.annotation.concurrent.NotThreadSafe;

import org.apache.cassandra.index.sai.disk.io.SeekingRandomAccessInput;
import org.apache.cassandra.index.sai.disk.v1.LongArray;
import org.apache.lucene.store.IndexInput;
import org.apache.lucene.util.LongValues;
import org.apache.lucene.util.packed.DirectReader;

@NotThreadSafe
public abstract class AbstractBlockPackedReader implements LongArray
{
    private final int blockShift;
    private final int blockMask;
    private final long valueCount;
    private final byte[] blockBitsPerValue;
    private final SeekingRandomAccessInput input;

<span class="nc" id="L37">    private long previousValue = Long.MIN_VALUE;</span>
    private long lastIndex; // the last index visited by token -&gt; row ID searches

    AbstractBlockPackedReader(IndexInput indexInput, byte[] blockBitsPerValue, int blockShift, int blockMask, long valueCount)
<span class="nc" id="L41">    {</span>
<span class="nc" id="L42">        this.blockShift = blockShift;</span>
<span class="nc" id="L43">        this.blockMask = blockMask;</span>
<span class="nc" id="L44">        this.valueCount = valueCount;</span>
<span class="nc" id="L45">        this.input = new SeekingRandomAccessInput(indexInput);</span>
<span class="nc" id="L46">        this.blockBitsPerValue = blockBitsPerValue;</span>
<span class="nc" id="L47">    }</span>

    protected abstract long blockOffsetAt(int block);

    @Override
    public long get(final long valueIndex)
    {
<span class="nc bnc" id="L54" title="All 4 branches missed.">        if (valueIndex &lt; 0 || valueIndex &gt;= valueCount)</span>
        {
<span class="nc" id="L56">            throw new IndexOutOfBoundsException(String.format(&quot;Index should be between [0, %d), but was %d.&quot;, valueCount, valueIndex));</span>
        }

<span class="nc" id="L59">        int blockIndex = (int) (valueIndex &gt;&gt;&gt; blockShift);</span>
<span class="nc" id="L60">        int inBlockIndex = (int) (valueIndex &amp; blockMask);</span>
<span class="nc" id="L61">        byte bitsPerValue = blockBitsPerValue[blockIndex];</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">        final LongValues subReader = bitsPerValue == 0 ? LongValues.ZEROES</span>
<span class="nc" id="L63">                                                       : DirectReader.getInstance(input, bitsPerValue, blockOffsetAt(blockIndex));</span>
<span class="nc" id="L64">        return delta(blockIndex, inBlockIndex) + subReader.get(inBlockIndex);</span>
    }

    @Override
    public long length()
    {
<span class="nc" id="L70">        return valueCount;</span>
    }

    @Override
    public long indexOf(long value)
    {
        // already out of range
<span class="nc bnc" id="L77" title="All 2 branches missed.">        if (lastIndex &gt;= valueCount)</span>
<span class="nc" id="L78">            return -1;</span>

        // We keep track previous returned value in lastIndex, so searching backward will not return correct result.
        // Also it's logically wrong to search backward during token iteration in PostingListRangeIterator.
<span class="nc bnc" id="L82" title="All 2 branches missed.">        if (value &lt; previousValue)</span>
<span class="nc" id="L83">            throw new IllegalArgumentException(String.format(&quot;%d is smaller than prev token value %d&quot;, value, previousValue));</span>
<span class="nc" id="L84">        previousValue = value;</span>

<span class="nc" id="L86">        int blockIndex = binarySearchBlockMinValues(value);</span>

        // We need to check next block's min value on an exact match.
<span class="nc bnc" id="L89" title="All 2 branches missed.">        boolean exactMatch = blockIndex &gt;= 0;</span>

<span class="nc bnc" id="L91" title="All 2 branches missed.">        if (blockIndex &lt; 0)</span>
        {
            // A non-exact match, which is the negative index of the first value greater than the target.
            // For example, searching for 4 against min values [3,3,5,7] produces -2, which we convert to 2.
<span class="nc" id="L95">            blockIndex = -blockIndex;</span>
        }

<span class="nc bnc" id="L98" title="All 2 branches missed.">        if (blockIndex &gt; 0)</span>
        {
            // Start at the previous block, because there could be duplicate values in the previous block.
            // For example, with block 1: [1,2,3,3] &amp; block 2: [3,3,5,7], binary search for 3 would find
            // block 2, but we need to start from block 1 and search both.
            // In case non-exact match, we need to pivot left as target is less than next block's min.
<span class="nc" id="L104">            blockIndex--;</span>
        }

        // Find the global (not block-specific) index of the target token, which is equivalent to its row ID:
<span class="nc" id="L108">        lastIndex = findBlockRowID(value, blockIndex, exactMatch);</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">        return lastIndex &gt;= valueCount ? -1 : lastIndex;</span>
    }

    /**
     *
     * @return a positive block index for an exact match, or a negative one for a non-exact match
     */
    private int binarySearchBlockMinValues(long targetValue)
    {
<span class="nc" id="L118">        int high = Math.toIntExact(blockBitsPerValue.length) - 1;</span>

        // Assume here that we'll never move backward through the blocks:
<span class="nc" id="L121">        int low = Math.toIntExact(lastIndex &gt;&gt; blockShift);</span>

        // Short-circuit the search if the target is in current block:
<span class="nc bnc" id="L124" title="All 2 branches missed.">        if (low + 1 &lt;= high)</span>
        {
<span class="nc" id="L126">            long cmp = Long.compare(targetValue, delta(low + 1, 0));</span>

<span class="nc bnc" id="L128" title="All 2 branches missed.">            if (cmp == 0)</span>
            {
                // We have an exact match, so return the index of the next block, which means we'll start
                // searching from the current one and also inspect the first value of the next block.
<span class="nc" id="L132">                return low + 1;</span>
            }
<span class="nc bnc" id="L134" title="All 2 branches missed.">            else if (cmp &lt; 0)</span>
            {
                // We're in the same block. Indicate a non-exact match, and this value will be both
                // negated and then decremented to wind up at the current value of &quot;low&quot; here.
<span class="nc" id="L138">                return -low - 1;</span>
            }

            // The target is greater than the next block's min value, so advance to that
            // block before starting the usual search...
<span class="nc" id="L143">            low++;</span>
        }

<span class="nc bnc" id="L146" title="All 2 branches missed.">        while (low &lt;= high)</span>
        {
<span class="nc" id="L148">            int mid = low + ((high - low) &gt;&gt; 1);</span>

<span class="nc" id="L150">            long midVal = delta(mid, 0);</span>

<span class="nc bnc" id="L152" title="All 2 branches missed.">            if (midVal &lt; targetValue)</span>
            {
<span class="nc" id="L154">                low = mid + 1;</span>
            }
<span class="nc bnc" id="L156" title="All 2 branches missed.">            else if (midVal &gt; targetValue)</span>
            {
<span class="nc" id="L158">                high = mid - 1;</span>
            }
            else
            {
                // target found, but we need to check for duplicates
<span class="nc bnc" id="L163" title="All 4 branches missed.">                if (mid &gt; 0 &amp;&amp; delta(mid - 1, 0) == targetValue)</span>
                {
                    // there are duplicates, pivot left
<span class="nc" id="L166">                    high = mid - 1;</span>
                }
                else
                {
                    // no duplicates
<span class="nc" id="L171">                    return mid;</span>
                }
            }
<span class="nc" id="L174">        }</span>

<span class="nc" id="L176">        return -low; // no exact match found</span>
    }

    private long findBlockRowID(long targetValue, long blockIdx, boolean exactMatch)
    {
        // Calculate the global offset for the selected block:
<span class="nc" id="L182">        long offset = blockIdx &lt;&lt; blockShift;</span>

        // Resume from previous index if it's larger than offset
<span class="nc" id="L185">        long low = Math.max(lastIndex, offset);</span>

        // The high is either the last local index in the block, or something smaller if the block isn't full:
<span class="nc bnc" id="L188" title="All 2 branches missed.">        long high = Math.min(offset + blockMask + (exactMatch ? 1 : 0), valueCount - 1);</span>

<span class="nc" id="L190">        return binarySearchBlock(targetValue, low, high);</span>
    }

    /**
     * binary search target value between low and high.
     *
     * @return index if exact match is found, or *positive* insertion point if no exact match is found.
     */
    private long binarySearchBlock(long target, long low, long high)
    {
<span class="nc bnc" id="L200" title="All 2 branches missed.">        while (low &lt;= high)</span>
        {
<span class="nc" id="L202">            long mid = low + ((high - low) &gt;&gt; 1);</span>

<span class="nc" id="L204">            long midVal = get(mid);</span>

<span class="nc bnc" id="L206" title="All 2 branches missed.">            if (midVal &lt; target)</span>
            {
<span class="nc" id="L208">                low = mid + 1;</span>
                // future rowId cannot be smaller than mid as long as next token not smaller than current token.
<span class="nc" id="L210">                lastIndex = mid;</span>
            }
<span class="nc bnc" id="L212" title="All 2 branches missed.">            else if (midVal &gt; target)</span>
            {
<span class="nc" id="L214">                high = mid - 1;</span>
            }
            else
            {
                // target found, but we need to check for duplicates
<span class="nc bnc" id="L219" title="All 4 branches missed.">                if (mid &gt; 0 &amp;&amp; get(mid - 1) == target)</span>
                {
                    // there are duplicates, pivot left
<span class="nc" id="L222">                    high = mid - 1;</span>
                }
                else
                {
                    // exact match and no duplicates
<span class="nc" id="L227">                    return mid;</span>
                }
            }
<span class="nc" id="L230">        }</span>

        // target not found
<span class="nc" id="L233">        return low;</span>
    }

    abstract long delta(int block, int idx);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>