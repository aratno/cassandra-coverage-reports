<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CompactionManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.compaction</a> &gt; <span class="el_source">CompactionManager.java</span></div><h1>CompactionManager.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.compaction;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BooleanSupplier;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import javax.management.openmbean.OpenDataException;
import javax.management.openmbean.TabularData;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicates;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Collections2;
import com.google.common.collect.ConcurrentHashMultiset;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multiset;
import com.google.common.collect.Sets;
import com.google.common.util.concurrent.RateLimiter;
import com.google.common.util.concurrent.Uninterruptibles;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import net.openhft.chronicle.core.util.ThrowingSupplier;
import org.apache.cassandra.cache.AutoSavingCache;
import org.apache.cassandra.concurrent.ExecutorFactory;
import org.apache.cassandra.concurrent.WrappedExecutorPlus;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.Directories;
import org.apache.cassandra.db.DiskBoundaries;
import org.apache.cassandra.db.Keyspace;
import org.apache.cassandra.db.SerializationHeader;
import org.apache.cassandra.db.SystemKeyspace;
import org.apache.cassandra.db.compaction.CompactionInfo.Holder;
import org.apache.cassandra.db.lifecycle.ILifecycleTransaction;
import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
import org.apache.cassandra.db.lifecycle.SSTableIntervalTree;
import org.apache.cassandra.db.lifecycle.SSTableSet;
import org.apache.cassandra.db.lifecycle.View;
import org.apache.cassandra.db.lifecycle.WrappedLifecycleTransaction;
import org.apache.cassandra.db.rows.UnfilteredRowIterator;
import org.apache.cassandra.db.view.ViewBuilderTask;
import org.apache.cassandra.dht.AbstractBounds;
import org.apache.cassandra.dht.Range;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.index.SecondaryIndexBuilder;
import org.apache.cassandra.io.sstable.Descriptor;
import org.apache.cassandra.io.sstable.ISSTableScanner;
import org.apache.cassandra.io.sstable.IScrubber;
import org.apache.cassandra.io.sstable.IVerifier;
import org.apache.cassandra.io.sstable.SSTableRewriter;
import org.apache.cassandra.io.sstable.format.SSTableFormat;
import org.apache.cassandra.io.sstable.format.SSTableReader;
import org.apache.cassandra.io.sstable.format.SSTableWriter;
import org.apache.cassandra.io.sstable.metadata.MetadataCollector;
import org.apache.cassandra.io.sstable.metadata.StatsMetadata;
import org.apache.cassandra.io.util.File;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.locator.RangesAtEndpoint;
import org.apache.cassandra.metrics.CompactionMetrics;
import org.apache.cassandra.metrics.TableMetrics;
import org.apache.cassandra.repair.NoSuchRepairSessionException;
import org.apache.cassandra.schema.CompactionParams.TombstoneOption;
import org.apache.cassandra.schema.Schema;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.service.ActiveRepairService;
import org.apache.cassandra.service.StorageService;
import org.apache.cassandra.streaming.PreviewKind;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.JVMStabilityInspector;
import org.apache.cassandra.utils.MBeanWrapper;
import org.apache.cassandra.utils.OutputHandler;
import org.apache.cassandra.utils.Throwables;
import org.apache.cassandra.utils.TimeUUID;
import org.apache.cassandra.utils.WrappedRunnable;
import org.apache.cassandra.utils.concurrent.Future;
import org.apache.cassandra.utils.concurrent.ImmediateFuture;
import org.apache.cassandra.utils.concurrent.Refs;

import static java.util.Collections.singleton;
import static org.apache.cassandra.concurrent.ExecutorFactory.Global.executorFactory;
import static org.apache.cassandra.concurrent.FutureTask.callable;
import static org.apache.cassandra.config.DatabaseDescriptor.getConcurrentCompactors;
import static org.apache.cassandra.db.compaction.CompactionManager.CompactionExecutor.compactionThreadGroup;
import static org.apache.cassandra.service.ActiveRepairService.NO_PENDING_REPAIR;
import static org.apache.cassandra.service.ActiveRepairService.UNREPAIRED_SSTABLE;
import static org.apache.cassandra.utils.Clock.Global.nanoTime;
import static org.apache.cassandra.utils.TimeUUID.Generator.nextTimeUUID;

/**
 * &lt;p&gt;
 * A singleton which manages a private executor of ongoing compactions.
 * &lt;/p&gt;
 * Scheduling for compaction is accomplished by swapping sstables to be compacted into
 * a set via Tracker. New scheduling attempts will ignore currently compacting
 * sstables.
 */
<span class="fc" id="L138">public class CompactionManager implements CompactionManagerMBean, ICompactionManager</span>
{
    public static final String MBEAN_OBJECT_NAME = &quot;org.apache.cassandra.db:type=CompactionManager&quot;;
<span class="fc" id="L141">    private static final Logger logger = LoggerFactory.getLogger(CompactionManager.class);</span>
    public static final CompactionManager instance;

<span class="fc" id="L144">    @VisibleForTesting</span>
    public final AtomicInteger currentlyBackgroundUpgrading = new AtomicInteger(0);

    public static final int NO_GC = Integer.MIN_VALUE;
    public static final int GC_ALL = Integer.MAX_VALUE;

    static
    {
<span class="fc" id="L152">        instance = new CompactionManager();</span>

<span class="fc" id="L154">        MBeanWrapper.instance.registerMBean(instance, MBEAN_OBJECT_NAME);</span>
<span class="fc" id="L155">    }</span>

<span class="fc" id="L157">    private final CompactionExecutor executor = new CompactionExecutor();</span>
<span class="fc" id="L158">    private final ValidationExecutor validationExecutor = new ValidationExecutor();</span>
<span class="fc" id="L159">    private final CompactionExecutor cacheCleanupExecutor = new CacheCleanupExecutor();</span>
<span class="fc" id="L160">    private final CompactionExecutor viewBuildExecutor = new ViewBuildExecutor();</span>

    // We can't house 2i builds in SecondaryIndexManagement because it could cause deadlocks with itself, and can cause
    // massive to indefinite pauses if prioritized either before or after normal compactions so we instead put it in its
    // own pool to prevent either scenario.
<span class="fc" id="L165">    private final SecondaryIndexExecutor secondaryIndexExecutor = new SecondaryIndexExecutor();</span>

<span class="fc" id="L167">    private final CompactionMetrics metrics = new CompactionMetrics(executor, validationExecutor, viewBuildExecutor, secondaryIndexExecutor);</span>

<span class="fc" id="L169">    @VisibleForTesting</span>
<span class="fc" id="L170">    final Multiset&lt;ColumnFamilyStore&gt; compactingCF = ConcurrentHashMultiset.create();</span>

<span class="fc" id="L172">    public final ActiveCompactions active = new ActiveCompactions();</span>

    // used to temporarily pause non-strategy managed compactions (like index summary redistribution)
<span class="fc" id="L175">    private final AtomicInteger globalCompactionPauseCount = new AtomicInteger(0);</span>

<span class="fc" id="L177">    private final RateLimiter compactionRateLimiter = RateLimiter.create(Double.MAX_VALUE);</span>

    public CompactionMetrics getMetrics()
    {
<span class="fc" id="L181">        return metrics;</span>
    }

    /**
     * Gets compaction rate limiter.
     * Rate unit is bytes per sec.
     *
     * @return RateLimiter with rate limit set
     */
    public RateLimiter getRateLimiter()
    {
<span class="fc" id="L192">        setRateInBytes(DatabaseDescriptor.getCompactionThroughputBytesPerSec());</span>
<span class="fc" id="L193">        return compactionRateLimiter;</span>
    }

    /**
     * Sets the rate for the rate limiter. When compaction_throughput is 0 or node is bootstrapping,
     * this sets the rate to Double.MAX_VALUE bytes per second.
     * @param throughputMbPerSec throughput to set in MiB/s
     * @deprecated Use setRateInBytes instead
     */
    @Deprecated
    public void setRate(final double throughputMbPerSec)
    {
<span class="nc" id="L205">        setRateInBytes(throughputMbPerSec * 1024.0 * 1024);</span>
<span class="nc" id="L206">    }</span>

    /**
     * Sets the rate for the rate limiter. When compaction_throughput is 0 or node is bootstrapping,
     * this sets the rate to Double.MAX_VALUE bytes per second.
     * @param throughputBytesPerSec throughput to set in B/s
     */
    public void setRateInBytes(final double throughputBytesPerSec)
    {
<span class="fc" id="L215">        double throughput = throughputBytesPerSec;</span>
        // if throughput is set to 0, throttling is disabled
<span class="fc bfc" id="L217" title="All 4 branches covered.">        if (throughput == 0 || StorageService.instance.isBootstrapMode())</span>
<span class="fc" id="L218">            throughput = Double.MAX_VALUE;</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">        if (compactionRateLimiter.getRate() != throughput)</span>
<span class="fc" id="L220">            compactionRateLimiter.setRate(throughput);</span>
<span class="fc" id="L221">    }</span>

    /**
     * Call this whenever a compaction might be needed on the given columnfamily.
     * It's okay to over-call (within reason) if a call is unnecessary, it will
     * turn into a no-op in the bucketing/candidate-scan phase.
     */
    public List&lt;Future&lt;?&gt;&gt; submitBackground(final ColumnFamilyStore cfs)
    {
<span class="fc bfc" id="L230" title="All 2 branches covered.">        if (cfs.isAutoCompactionDisabled())</span>
        {
<span class="fc" id="L232">            logger.trace(&quot;Autocompaction is disabled&quot;);</span>
<span class="fc" id="L233">            return Collections.emptyList();</span>
        }

        /**
         * If a CF is currently being compacted, and there are no idle threads, submitBackground should be a no-op;
         * we can wait for the current compaction to finish and re-submit when more information is available.
         * Otherwise, we should submit at least one task to prevent starvation by busier CFs, and more if there
         * are idle threads stil. (CASSANDRA-4310)
         */
<span class="fc" id="L242">        int count = compactingCF.count(cfs);</span>
<span class="fc bfc" id="L243" title="All 4 branches covered.">        if (count &gt; 0 &amp;&amp; executor.getActiveTaskCount() &gt;= executor.getMaximumPoolSize())</span>
        {
<span class="fc" id="L245">            logger.trace(&quot;Background compaction is still running for {}.{} ({} remaining). Skipping&quot;,</span>
<span class="fc" id="L246">                         cfs.getKeyspaceName(), cfs.name, count);</span>
<span class="fc" id="L247">            return Collections.emptyList();</span>
        }

<span class="fc" id="L250">        logger.trace(&quot;Scheduling a background task check for {}.{} with {}&quot;,</span>
<span class="fc" id="L251">                     cfs.getKeyspaceName(),</span>
                     cfs.name,
<span class="fc" id="L253">                     cfs.getCompactionStrategyManager().getName());</span>

<span class="fc" id="L255">        List&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;(1);</span>
<span class="fc" id="L256">        Future&lt;?&gt; fut = executor.submitIfRunning(new BackgroundCompactionCandidate(cfs), &quot;background task&quot;);</span>
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">        if (!fut.isCancelled())</span>
<span class="fc" id="L258">            futures.add(fut);</span>
        else
<span class="nc" id="L260">            compactingCF.remove(cfs);</span>
<span class="fc" id="L261">        return futures;</span>
    }

    public boolean isCompacting(Iterable&lt;ColumnFamilyStore&gt; cfses, Predicate&lt;SSTableReader&gt; sstablePredicate)
    {
<span class="fc bfc" id="L266" title="All 2 branches covered.">        for (ColumnFamilyStore cfs : cfses)</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">            if (cfs.getTracker().getCompacting().stream().anyMatch(sstablePredicate))</span>
<span class="fc" id="L268">                return true;</span>
<span class="fc" id="L269">        return false;</span>
    }

    @VisibleForTesting
    public boolean hasOngoingOrPendingTasks()
    {
<span class="nc bnc" id="L275" title="All 4 branches missed.">        if (!active.getCompactions().isEmpty() || !compactingCF.isEmpty())</span>
<span class="nc" id="L276">            return true;</span>

<span class="nc" id="L278">        int pendingTasks = executor.getPendingTaskCount() +</span>
<span class="nc" id="L279">                           validationExecutor.getPendingTaskCount() +</span>
<span class="nc" id="L280">                           viewBuildExecutor.getPendingTaskCount() +</span>
<span class="nc" id="L281">                           cacheCleanupExecutor.getPendingTaskCount() +</span>
<span class="nc" id="L282">                           secondaryIndexExecutor.getPendingTaskCount();</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">        if (pendingTasks &gt; 0)</span>
<span class="nc" id="L284">            return true;</span>

<span class="nc" id="L286">        int activeTasks = executor.getActiveTaskCount() +</span>
<span class="nc" id="L287">                          validationExecutor.getActiveTaskCount() +</span>
<span class="nc" id="L288">                          viewBuildExecutor.getActiveTaskCount() +</span>
<span class="nc" id="L289">                          cacheCleanupExecutor.getActiveTaskCount() +</span>
<span class="nc" id="L290">                          secondaryIndexExecutor.getActiveTaskCount();</span>

<span class="nc bnc" id="L292" title="All 2 branches missed.">        return activeTasks &gt; 0;</span>
    }

    /**
     * Shutdowns both compaction and validation executors, cancels running compaction / validation,
     * and waits for tasks to complete if tasks were not cancelable.
     */
    public void forceShutdown()
    {
        // shutdown executors to prevent further submission
<span class="fc" id="L302">        executor.shutdown();</span>
<span class="fc" id="L303">        validationExecutor.shutdown();</span>
<span class="fc" id="L304">        viewBuildExecutor.shutdown();</span>
<span class="fc" id="L305">        cacheCleanupExecutor.shutdown();</span>
<span class="fc" id="L306">        secondaryIndexExecutor.shutdown();</span>

        // interrupt compactions and validations
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">        for (Holder compactionHolder : active.getCompactions())</span>
        {
<span class="nc" id="L311">            compactionHolder.stop();</span>
<span class="nc" id="L312">        }</span>

        // wait for tasks to terminate
        // compaction tasks are interrupted above, so it shuold be fairy quick
        // until not interrupted tasks to complete.
<span class="fc bfc" id="L317" title="All 2 branches covered.">        for (ExecutorService exec : Arrays.asList(executor, validationExecutor, viewBuildExecutor,</span>
                                                  cacheCleanupExecutor, secondaryIndexExecutor))
        {
            try
            {
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">                if (!exec.awaitTermination(1, TimeUnit.MINUTES))</span>
<span class="nc" id="L323">                    logger.warn(&quot;Failed to wait for compaction executors shutdown&quot;);</span>
            }
<span class="nc" id="L325">            catch (InterruptedException e)</span>
            {
<span class="nc" id="L327">                logger.error(&quot;Interrupted while waiting for tasks to be terminated&quot;, e);</span>
<span class="fc" id="L328">            }</span>
<span class="fc" id="L329">        }</span>
<span class="fc" id="L330">    }</span>

    public void finishCompactionsAndShutdown(long timeout, TimeUnit unit) throws InterruptedException
    {
<span class="fc" id="L334">        executor.shutdown();</span>
<span class="fc" id="L335">        executor.awaitTermination(timeout, unit);</span>
<span class="fc" id="L336">    }</span>

    // the actual sstables to compact are not determined until we run the BCT; that way, if new sstables
    // are created between task submission and execution, we execute against the most up-to-date information
    @VisibleForTesting
    class BackgroundCompactionCandidate implements Runnable
    {
        private final ColumnFamilyStore cfs;

        BackgroundCompactionCandidate(ColumnFamilyStore cfs)
<span class="fc" id="L346">        {</span>
<span class="fc" id="L347">            compactingCF.add(cfs);</span>
<span class="fc" id="L348">            this.cfs = cfs;</span>
<span class="fc" id="L349">        }</span>

        public void run()
        {
<span class="fc" id="L353">            boolean ranCompaction = false;</span>
            try
            {
<span class="fc" id="L356">                logger.trace(&quot;Checking {}.{}&quot;, cfs.getKeyspaceName(), cfs.name);</span>
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">                if (!cfs.isValid())</span>
                {
<span class="nc" id="L359">                    logger.trace(&quot;Aborting compaction for dropped CF&quot;);</span>
<span class="nc" id="L360">                    return;</span>
                }

<span class="fc" id="L363">                CompactionStrategyManager strategy = cfs.getCompactionStrategyManager();</span>
<span class="fc" id="L364">                AbstractCompactionTask task = strategy.getNextBackgroundTask(getDefaultGcBefore(cfs, FBUtilities.nowInSeconds()));</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">                if (task == null)</span>
                {
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">                    if (DatabaseDescriptor.automaticSSTableUpgrade())</span>
<span class="nc" id="L368">                        ranCompaction = maybeRunUpgradeTask(strategy);</span>
                }
                else
                {
<span class="fc" id="L372">                    task.execute(active);</span>
<span class="fc" id="L373">                    ranCompaction = true;</span>
                }
            }
            finally
            {
<span class="fc" id="L378">                compactingCF.remove(cfs);</span>
            }
<span class="fc bfc" id="L380" title="All 2 branches covered.">            if (ranCompaction) // only submit background if we actually ran a compaction - otherwise we end up in an infinite loop submitting noop background tasks</span>
<span class="fc" id="L381">                submitBackground(cfs);</span>
<span class="fc" id="L382">        }</span>

        boolean maybeRunUpgradeTask(CompactionStrategyManager strategy)
        {
<span class="nc" id="L386">            logger.debug(&quot;Checking for upgrade tasks {}.{}&quot;, cfs.getKeyspaceName(), cfs.getTableName());</span>
            try
            {
<span class="nc bnc" id="L389" title="All 2 branches missed.">                if (currentlyBackgroundUpgrading.incrementAndGet() &lt;= DatabaseDescriptor.maxConcurrentAutoUpgradeTasks())</span>
                {
<span class="nc" id="L391">                    AbstractCompactionTask upgradeTask = strategy.findUpgradeSSTableTask();</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">                    if (upgradeTask != null)</span>
                    {
<span class="nc" id="L394">                        upgradeTask.execute(active);</span>
<span class="nc" id="L395">                        return true;</span>
                    }
                }
            }
            finally
            {
<span class="nc" id="L401">                currentlyBackgroundUpgrading.decrementAndGet();</span>
            }
<span class="nc" id="L403">            logger.trace(&quot;No tasks available&quot;);</span>
<span class="nc" id="L404">            return false;</span>
        }
    }

    @VisibleForTesting
    public BackgroundCompactionCandidate getBackgroundCompactionCandidate(ColumnFamilyStore cfs)
    {
<span class="nc" id="L411">        return new BackgroundCompactionCandidate(cfs);</span>
    }

    /**
     * Run an operation over all sstables using jobs threads
     *
     * @param cfs the column family store to run the operation on
     * @param operation the operation to run
     * @param jobs the number of threads to use - 0 means use all available. It never uses more than concurrent_compactors threads
     * @return status of the operation
     */
    @SuppressWarnings(&quot;resource&quot;)
    private AllSSTableOpStatus parallelAllSSTableOperation(final ColumnFamilyStore cfs,
                                                           final OneSSTableOperation operation,
                                                           int jobs,
                                                           OperationType operationType)
    {
<span class="fc" id="L428">        String operationName = operationType.name();</span>
<span class="fc" id="L429">        String keyspace = cfs.getKeyspaceName();</span>
<span class="fc" id="L430">        String table = cfs.getTableName();</span>
<span class="fc" id="L431">        return cfs.withAllSSTables(operationType, (compacting) -&gt; {</span>
<span class="fc" id="L432">            logger.info(&quot;Starting {} for {}.{}&quot;, operationType, cfs.getKeyspaceName(), cfs.getTableName());</span>
<span class="fc" id="L433">            List&lt;LifecycleTransaction&gt; transactions = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L434">            List&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;();</span>
            try
            {
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">                if (compacting == null)</span>
<span class="nc" id="L438">                    return AllSSTableOpStatus.UNABLE_TO_CANCEL;</span>

<span class="fc" id="L440">                Iterable&lt;SSTableReader&gt; sstables = Lists.newArrayList(operation.filterSSTables(compacting));</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">                if (Iterables.isEmpty(sstables))</span>
                {
<span class="fc" id="L443">                    logger.info(&quot;No sstables to {} for {}.{}&quot;, operationName, keyspace, table);</span>
<span class="fc" id="L444">                    return AllSSTableOpStatus.SUCCESSFUL;</span>
                }

<span class="fc bfc" id="L447" title="All 2 branches covered.">                for (final SSTableReader sstable : sstables)</span>
                {
<span class="fc" id="L449">                    final LifecycleTransaction txn = compacting.split(singleton(sstable));</span>
<span class="fc" id="L450">                    transactions.add(txn);</span>
<span class="fc" id="L451">                    Callable&lt;Object&gt; callable = new Callable&lt;Object&gt;()</span>
<span class="fc" id="L452">                    {</span>
                        @Override
                        public Object call() throws Exception
                        {
<span class="fc" id="L456">                            operation.execute(txn);</span>
<span class="fc" id="L457">                            return this;</span>
                        }
                    };
<span class="fc" id="L460">                    Future&lt;?&gt; fut = executor.submitIfRunning(callable, &quot;parallel SSTable operation&quot;);</span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">                    if (!fut.isCancelled())</span>
<span class="fc" id="L462">                        futures.add(fut);</span>
                    else
<span class="nc" id="L464">                        return AllSSTableOpStatus.ABORTED;</span>

<span class="pc bpc" id="L466" title="1 of 4 branches missed.">                    if (jobs &gt; 0 &amp;&amp; futures.size() == jobs)</span>
                    {
<span class="fc" id="L468">                        Future&lt;?&gt; f = FBUtilities.waitOnFirstFuture(futures);</span>
<span class="fc" id="L469">                        futures.remove(f);</span>
                    }
<span class="fc" id="L471">                }</span>
<span class="fc" id="L472">                FBUtilities.waitOnFutures(futures);</span>
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">                assert compacting.originals().isEmpty();</span>
<span class="fc" id="L474">                logger.info(&quot;Finished {} for {}.{} successfully&quot;, operationType, keyspace, table);</span>
<span class="fc" id="L475">                return AllSSTableOpStatus.SUCCESSFUL;</span>
            }
            finally
            {
                // wait on any unfinished futures to make sure we don't close an ongoing transaction
                try
                {
<span class="fc" id="L482">                    FBUtilities.waitOnFutures(futures);</span>
                }
<span class="nc" id="L484">                catch (Throwable t)</span>
                {
                    // these are handled/logged in CompactionExecutor#afterExecute
<span class="fc" id="L487">                }</span>
<span class="fc" id="L488">                Throwable fail = Throwables.close(null, transactions);</span>
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">                if (fail != null)</span>
<span class="nc" id="L490">                    logger.error(&quot;Failed to cleanup lifecycle transactions ({} for {}.{})&quot;, operationType, keyspace, table, fail);</span>
            }
        });
    }

    private static interface OneSSTableOperation
    {
        Iterable&lt;SSTableReader&gt; filterSSTables(LifecycleTransaction transaction);
        void execute(LifecycleTransaction input) throws IOException;
    }

<span class="fc" id="L501">    public enum AllSSTableOpStatus</span>
    {
<span class="fc" id="L503">        SUCCESSFUL(0),</span>
<span class="fc" id="L504">        ABORTED(1),</span>
<span class="fc" id="L505">        UNABLE_TO_CANCEL(2);</span>

        public final int statusCode;

        AllSSTableOpStatus(int statusCode)
<span class="fc" id="L510">        {</span>
<span class="fc" id="L511">            this.statusCode = statusCode;</span>
<span class="fc" id="L512">        }</span>
    }

    public AllSSTableOpStatus performScrub(ColumnFamilyStore cfs, IScrubber.Options options, int jobs)
    {
<span class="fc" id="L517">        return parallelAllSSTableOperation(cfs, new OneSSTableOperation()</span>
<span class="fc" id="L518">        {</span>
            @Override
            public Iterable&lt;SSTableReader&gt; filterSSTables(LifecycleTransaction input)
            {
<span class="fc" id="L522">                return input.originals();</span>
            }

            @Override
            public void execute(LifecycleTransaction input)
            {
<span class="fc" id="L528">                scrubOne(cfs, input, options, active);</span>
<span class="fc" id="L529">            }</span>
        }, jobs, OperationType.SCRUB);
    }

    public AllSSTableOpStatus performVerify(ColumnFamilyStore cfs, IVerifier.Options options) throws InterruptedException, ExecutionException
    {
<span class="nc bnc" id="L535" title="All 2 branches missed.">        assert !cfs.isIndex();</span>
<span class="nc" id="L536">        return parallelAllSSTableOperation(cfs, new OneSSTableOperation()</span>
<span class="nc" id="L537">        {</span>
            @Override
            public Iterable&lt;SSTableReader&gt; filterSSTables(LifecycleTransaction input)
            {
<span class="nc" id="L541">                return input.originals();</span>
            }

            @Override
            public void execute(LifecycleTransaction input)
            {
<span class="nc" id="L547">                verifyOne(cfs, input.onlyOne(), options, active);</span>
<span class="nc" id="L548">            }</span>
        }, 0, OperationType.VERIFY);
    }

    public AllSSTableOpStatus performSSTableRewrite(final ColumnFamilyStore cfs,
                                                    final boolean skipIfCurrentVersion,
                                                    final long skipIfOlderThanTimestamp,
                                                    final boolean skipIfCompressionMatches,
                                                    int jobs) throws InterruptedException, ExecutionException
    {
<span class="nc" id="L558">        return performSSTableRewrite(cfs, (sstable) -&gt; {</span>
            // Skip if descriptor version matches current version
<span class="nc bnc" id="L560" title="All 4 branches missed.">            if (skipIfCurrentVersion &amp;&amp; sstable.descriptor.version.equals(sstable.descriptor.getFormat().getLatestVersion()))</span>
<span class="nc" id="L561">                return false;</span>

            // Skip if SSTable creation time is past given timestamp
<span class="nc bnc" id="L564" title="All 2 branches missed.">            if (sstable.getDataCreationTime() &gt; skipIfOlderThanTimestamp)</span>
<span class="nc" id="L565">                return false;</span>

<span class="nc" id="L567">            TableMetadata metadata = cfs.metadata.get();</span>
            // Skip if SSTable compression parameters match current ones
<span class="nc bnc" id="L569" title="All 4 branches missed.">            if (skipIfCompressionMatches &amp;&amp;</span>
<span class="nc bnc" id="L570" title="All 4 branches missed.">                ((!sstable.compression &amp;&amp; !metadata.params.compression.isEnabled()) ||</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">                 (sstable.compression &amp;&amp; metadata.params.compression.equals(sstable.getCompressionMetadata().parameters))))</span>
<span class="nc" id="L572">                return false;</span>

<span class="nc" id="L574">            return true;</span>
        }, jobs);
    }

    /**
     * Perform SSTable rewrite

     * @param sstableFilter sstables for which predicate returns {@link false} will be excluded
     */
    public AllSSTableOpStatus performSSTableRewrite(final ColumnFamilyStore cfs, Predicate&lt;SSTableReader&gt; sstableFilter, int jobs) throws InterruptedException, ExecutionException
    {
<span class="nc" id="L585">        return parallelAllSSTableOperation(cfs, new OneSSTableOperation()</span>
<span class="nc" id="L586">        {</span>
            @Override
            public Iterable&lt;SSTableReader&gt; filterSSTables(LifecycleTransaction transaction)
            {
<span class="nc" id="L590">                List&lt;SSTableReader&gt; sortedSSTables = Lists.newArrayList(transaction.originals());</span>
<span class="nc" id="L591">                Collections.sort(sortedSSTables, SSTableReader.sizeComparator.reversed());</span>
<span class="nc" id="L592">                Iterator&lt;SSTableReader&gt; iter = sortedSSTables.iterator();</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">                while (iter.hasNext())</span>
                {
<span class="nc" id="L595">                    SSTableReader sstable = iter.next();</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">                    if (!sstableFilter.test(sstable))</span>
                    {
<span class="nc" id="L598">                        transaction.cancel(sstable);</span>
<span class="nc" id="L599">                        iter.remove();</span>
                    }
<span class="nc" id="L601">                }</span>
<span class="nc" id="L602">                return sortedSSTables;</span>
            }

            @Override
            public void execute(LifecycleTransaction txn)
            {
<span class="nc" id="L608">                AbstractCompactionTask task = cfs.getCompactionStrategyManager().getCompactionTask(txn, NO_GC, Long.MAX_VALUE);</span>
<span class="nc" id="L609">                task.setUserDefined(true);</span>
<span class="nc" id="L610">                task.setCompactionType(OperationType.UPGRADE_SSTABLES);</span>
<span class="nc" id="L611">                task.execute(active);</span>
<span class="nc" id="L612">            }</span>
        }, jobs, OperationType.UPGRADE_SSTABLES);
    }

    public AllSSTableOpStatus performCleanup(final ColumnFamilyStore cfStore, int jobs) throws InterruptedException, ExecutionException
    {
<span class="pc bpc" id="L618" title="1 of 2 branches missed.">        assert !cfStore.isIndex();</span>
<span class="fc" id="L619">        Keyspace keyspace = cfStore.keyspace;</span>

        // if local ranges is empty, it means no data should remain
<span class="fc" id="L622">        final RangesAtEndpoint replicas = StorageService.instance.getLocalReplicas(keyspace.getName());</span>
<span class="fc" id="L623">        final Set&lt;Range&lt;Token&gt;&gt; allRanges = replicas.ranges();</span>
<span class="fc" id="L624">        final Set&lt;Range&lt;Token&gt;&gt; transientRanges = replicas.onlyTransient().ranges();</span>
<span class="fc" id="L625">        final Set&lt;Range&lt;Token&gt;&gt; fullRanges = replicas.onlyFull().ranges();</span>
<span class="fc" id="L626">        final boolean hasIndexes = cfStore.indexManager.hasIndexes();</span>

<span class="fc" id="L628">        return parallelAllSSTableOperation(cfStore, new OneSSTableOperation()</span>
<span class="fc" id="L629">        {</span>
            @Override
            public Iterable&lt;SSTableReader&gt; filterSSTables(LifecycleTransaction transaction)
            {
<span class="fc" id="L633">                List&lt;SSTableReader&gt; sortedSSTables = Lists.newArrayList(transaction.originals());</span>
<span class="fc" id="L634">                Iterator&lt;SSTableReader&gt; sstableIter = sortedSSTables.iterator();</span>
<span class="fc" id="L635">                int totalSSTables = 0;</span>
<span class="fc" id="L636">                int skippedSStables = 0;</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">                while (sstableIter.hasNext())</span>
                {
<span class="fc" id="L639">                    SSTableReader sstable = sstableIter.next();</span>
<span class="fc" id="L640">                    boolean needsCleanupFull = needsCleanup(sstable, fullRanges);</span>
<span class="pc bpc" id="L641" title="5 of 6 branches missed.">                    boolean needsCleanupTransient = !transientRanges.isEmpty() &amp;&amp; sstable.isRepaired() &amp;&amp; needsCleanup(sstable, transientRanges);</span>
                    //If there are no ranges for which the table needs cleanup either due to lack of intersection or lack
                    //of the table being repaired.
<span class="fc" id="L644">                    totalSSTables++;</span>
<span class="pc bpc" id="L645" title="1 of 4 branches missed.">                    if (!needsCleanupFull &amp;&amp; !needsCleanupTransient)</span>
                    {
<span class="fc" id="L647">                        logger.debug(&quot;Skipping {} ([{}, {}]) for cleanup; all rows should be kept. Needs cleanup full ranges: {} Needs cleanup transient ranges: {} Repaired: {}&quot;,</span>
                                    sstable,
<span class="fc" id="L649">                                    sstable.getFirst().getToken(),</span>
<span class="fc" id="L650">                                    sstable.getLast().getToken(),</span>
<span class="fc" id="L651">                                    needsCleanupFull,</span>
<span class="fc" id="L652">                                    needsCleanupTransient,</span>
<span class="fc" id="L653">                                    sstable.isRepaired());</span>
<span class="fc" id="L654">                        sstableIter.remove();</span>
<span class="fc" id="L655">                        transaction.cancel(sstable);</span>
<span class="fc" id="L656">                        skippedSStables++;</span>
                    }
<span class="fc" id="L658">                }</span>
<span class="fc" id="L659">                logger.info(&quot;Skipping cleanup for {}/{} sstables for {}.{} since they are fully contained in owned ranges (full ranges: {}, transient ranges: {})&quot;,</span>
<span class="fc" id="L660">                            skippedSStables, totalSSTables, cfStore.getKeyspaceName(), cfStore.getTableName(), fullRanges, transientRanges);</span>
<span class="fc" id="L661">                sortedSSTables.sort(SSTableReader.sizeComparator);</span>
<span class="fc" id="L662">                return sortedSSTables;</span>
            }

            @Override
            public void execute(LifecycleTransaction txn) throws IOException
            {
<span class="fc" id="L668">                CleanupStrategy cleanupStrategy = CleanupStrategy.get(cfStore, allRanges, transientRanges, txn.onlyOne().isRepaired(), FBUtilities.nowInSeconds());</span>
<span class="fc" id="L669">                doCleanupOne(cfStore, txn, cleanupStrategy, replicas.ranges(), hasIndexes);</span>
<span class="fc" id="L670">            }</span>
        }, jobs, OperationType.CLEANUP);
    }

    public AllSSTableOpStatus performGarbageCollection(final ColumnFamilyStore cfStore, TombstoneOption tombstoneOption, int jobs) throws InterruptedException, ExecutionException
    {
<span class="nc bnc" id="L676" title="All 2 branches missed.">        assert !cfStore.isIndex();</span>

<span class="nc" id="L678">        return parallelAllSSTableOperation(cfStore, new OneSSTableOperation()</span>
<span class="nc" id="L679">        {</span>
            @Override
            public Iterable&lt;SSTableReader&gt; filterSSTables(LifecycleTransaction transaction)
            {
<span class="nc" id="L683">                List&lt;SSTableReader&gt; filteredSSTables = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">                if (cfStore.getCompactionStrategyManager().onlyPurgeRepairedTombstones())</span>
                {
<span class="nc bnc" id="L686" title="All 2 branches missed.">                    for (SSTableReader sstable : transaction.originals())</span>
                    {
<span class="nc bnc" id="L688" title="All 2 branches missed.">                        if (!sstable.isRepaired())</span>
                        {
                            try
                            {
<span class="nc" id="L692">                                transaction.cancel(sstable);</span>
                            }
<span class="nc" id="L694">                            catch (Throwable t)</span>
                            {
<span class="nc" id="L696">                                logger.warn(String.format(&quot;Unable to cancel %s from transaction %s&quot;, sstable, transaction.opId()), t);</span>
<span class="nc" id="L697">                            }</span>
                        }
                        else
                        {
<span class="nc" id="L701">                            filteredSSTables.add(sstable);</span>
                        }
<span class="nc" id="L703">                    }</span>
                }
                else
                {
<span class="nc" id="L707">                    filteredSSTables.addAll(transaction.originals());</span>
                }

<span class="nc" id="L710">                filteredSSTables.sort(SSTableReader.maxTimestampAscending);</span>
<span class="nc" id="L711">                return filteredSSTables;</span>
            }

            @Override
            public void execute(LifecycleTransaction txn) throws IOException
            {
<span class="nc" id="L717">                logger.debug(&quot;Garbage collecting {}&quot;, txn.originals());</span>
<span class="nc" id="L718">                CompactionTask task = new CompactionTask(cfStore, txn, getDefaultGcBefore(cfStore, FBUtilities.nowInSeconds()))</span>
<span class="nc" id="L719">                {</span>
                    @Override
                    protected CompactionController getCompactionController(Set&lt;SSTableReader&gt; toCompact)
                    {
<span class="nc" id="L723">                        return new CompactionController(cfStore, toCompact, gcBefore, null, tombstoneOption);</span>
                    }

                    @Override
                    protected int getLevel()
                    {
<span class="nc" id="L729">                        return txn.onlyOne().getSSTableLevel();</span>
                    }
                };
<span class="nc" id="L732">                task.setUserDefined(true);</span>
<span class="nc" id="L733">                task.setCompactionType(OperationType.GARBAGE_COLLECT);</span>
<span class="nc" id="L734">                task.execute(active);</span>
<span class="nc" id="L735">            }</span>
        }, jobs, OperationType.GARBAGE_COLLECT);
    }

    public AllSSTableOpStatus relocateSSTables(final ColumnFamilyStore cfs, int jobs) throws ExecutionException, InterruptedException
    {
<span class="fc bfc" id="L741" title="All 2 branches covered.">        if (!cfs.getPartitioner().splitter().isPresent())</span>
        {
<span class="fc" id="L743">            logger.info(&quot;Partitioner does not support splitting&quot;);</span>
<span class="fc" id="L744">            return AllSSTableOpStatus.ABORTED;</span>
        }

<span class="fc bfc" id="L747" title="All 2 branches covered.">        if (StorageService.instance.getLocalReplicas(cfs.getKeyspaceName()).isEmpty())</span>
        {
<span class="fc" id="L749">            logger.info(&quot;Relocate cannot run before a node has joined the ring&quot;);</span>
<span class="fc" id="L750">            return AllSSTableOpStatus.ABORTED;</span>
        }

<span class="fc" id="L753">        final DiskBoundaries diskBoundaries = cfs.getDiskBoundaries();</span>

<span class="fc" id="L755">        return parallelAllSSTableOperation(cfs, new OneSSTableOperation()</span>
<span class="fc" id="L756">        {</span>
            @Override
            public Iterable&lt;SSTableReader&gt; filterSSTables(LifecycleTransaction transaction)
            {
<span class="fc" id="L760">                Set&lt;SSTableReader&gt; originals = Sets.newHashSet(transaction.originals());</span>
<span class="fc bfc" id="L761" title="All 2 branches covered.">                Set&lt;SSTableReader&gt; needsRelocation = originals.stream().filter(s -&gt; !inCorrectLocation(s)).collect(Collectors.toSet());</span>
<span class="fc" id="L762">                transaction.cancel(Sets.difference(originals, needsRelocation));</span>

<span class="fc" id="L764">                Map&lt;Integer, List&lt;SSTableReader&gt;&gt; groupedByDisk = groupByDiskIndex(needsRelocation);</span>

<span class="fc" id="L766">                int maxSize = 0;</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">                for (List&lt;SSTableReader&gt; diskSSTables : groupedByDisk.values())</span>
<span class="fc" id="L768">                    maxSize = Math.max(maxSize, diskSSTables.size());</span>

<span class="fc" id="L770">                List&lt;SSTableReader&gt; mixedSSTables = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L772" title="All 2 branches covered.">                for (int i = 0; i &lt; maxSize; i++)</span>
<span class="fc bfc" id="L773" title="All 2 branches covered.">                    for (List&lt;SSTableReader&gt; diskSSTables : groupedByDisk.values())</span>
<span class="fc bfc" id="L774" title="All 2 branches covered.">                        if (i &lt; diskSSTables.size())</span>
<span class="fc" id="L775">                            mixedSSTables.add(diskSSTables.get(i));</span>

<span class="fc" id="L777">                return mixedSSTables;</span>
            }

            public Map&lt;Integer, List&lt;SSTableReader&gt;&gt; groupByDiskIndex(Set&lt;SSTableReader&gt; needsRelocation)
            {
<span class="fc" id="L782">                return needsRelocation.stream().collect(Collectors.groupingBy((s) -&gt; diskBoundaries.getDiskIndex(s)));</span>
            }

            private boolean inCorrectLocation(SSTableReader sstable)
            {
<span class="pc bpc" id="L787" title="1 of 2 branches missed.">                if (!cfs.getPartitioner().splitter().isPresent())</span>
<span class="nc" id="L788">                    return true;</span>

                // Compare the expected data directory for the sstable with its current data directory
<span class="fc" id="L791">                Directories.DataDirectory currentDirectory = cfs.getDirectories().getDataDirectoryForFile(sstable.descriptor);</span>
<span class="fc" id="L792">                return diskBoundaries.isInCorrectLocation(sstable, currentDirectory);</span>
            }

            @Override
            public void execute(LifecycleTransaction txn)
            {
<span class="fc" id="L798">                logger.debug(&quot;Relocating {}&quot;, txn.originals());</span>
<span class="fc" id="L799">                AbstractCompactionTask task = cfs.getCompactionStrategyManager().getCompactionTask(txn, NO_GC, Long.MAX_VALUE);</span>
<span class="fc" id="L800">                task.setUserDefined(true);</span>
<span class="fc" id="L801">                task.setCompactionType(OperationType.RELOCATE);</span>
<span class="fc" id="L802">                task.execute(active);</span>
<span class="fc" id="L803">            }</span>
        }, jobs, OperationType.RELOCATE);
    }

    /**
     * Splits the given token ranges of the given sstables into a pending repair silo
     */
    public Future&lt;Void&gt; submitPendingAntiCompaction(ColumnFamilyStore cfs,
                                                    RangesAtEndpoint tokenRanges,
                                                    Refs&lt;SSTableReader&gt; sstables,
                                                    LifecycleTransaction txn,
                                                    TimeUUID sessionId,
                                                    BooleanSupplier isCancelled)
    {
<span class="fc" id="L817">        Runnable runnable = new WrappedRunnable()</span>
<span class="fc" id="L818">        {</span>
            protected void runMayThrow() throws Exception
            {
<span class="fc" id="L821">                try (TableMetrics.TableTimer.Context ctx = cfs.metric.anticompactionTime.time())</span>
                {
<span class="fc" id="L823">                    performAnticompaction(cfs, tokenRanges, sstables, txn, sessionId, isCancelled);</span>
                }
<span class="fc" id="L825">            }</span>
        };

<span class="fc" id="L828">        Future&lt;Void&gt; task = null;</span>
        try
        {
<span class="fc" id="L831">            task = executor.submitIfRunning(runnable, &quot;pending anticompaction&quot;);</span>
<span class="fc" id="L832">            return task;</span>
        }
        finally
        {
<span class="pc bpc" id="L836" title="2 of 4 branches missed.">            if (task == null || task.isCancelled())</span>
            {
<span class="nc" id="L838">                sstables.release();</span>
<span class="nc" id="L839">                txn.abort();</span>
            }
        }
    }

    /**
     * for sstables that are fully contained in the given ranges, just rewrite their metadata with
     * the pending repair id and remove them from the transaction
     */
    private static void mutateFullyContainedSSTables(ColumnFamilyStore cfs,
                                                     Refs&lt;SSTableReader&gt; refs,
                                                     Iterator&lt;SSTableReader&gt; sstableIterator,
                                                     Collection&lt;Range&lt;Token&gt;&gt; ranges,
                                                     LifecycleTransaction txn,
                                                     TimeUUID sessionID,
                                                     boolean isTransient) throws IOException
    {
<span class="fc bfc" id="L856" title="All 2 branches covered.">        if (ranges.isEmpty())</span>
<span class="fc" id="L857">            return;</span>

<span class="fc" id="L859">        List&lt;Range&lt;Token&gt;&gt; normalizedRanges = Range.normalize(ranges);</span>

<span class="fc" id="L861">        Set&lt;SSTableReader&gt; fullyContainedSSTables = findSSTablesToAnticompact(sstableIterator, normalizedRanges, sessionID);</span>

<span class="fc" id="L863">        cfs.metric.bytesMutatedAnticompaction.inc(SSTableReader.getTotalBytes(fullyContainedSSTables));</span>
<span class="fc" id="L864">        cfs.getCompactionStrategyManager().mutateRepaired(fullyContainedSSTables, UNREPAIRED_SSTABLE, sessionID, isTransient);</span>
        // since we're just re-writing the sstable metdata for the fully contained sstables, we don't want
        // them obsoleted when the anti-compaction is complete. So they're removed from the transaction here
<span class="fc" id="L867">        txn.cancel(fullyContainedSSTables);</span>
<span class="fc" id="L868">        refs.release(fullyContainedSSTables);</span>
<span class="fc" id="L869">    }</span>

    /**
     * Make sure the {validatedForRepair} are marked for compaction before calling this.
     *
     * Caller must reference the validatedForRepair sstables (via ParentRepairSession.getActiveRepairedSSTableRefs(..)).
     *
     * @param cfs
     * @param replicas token ranges to be repaired
     * @param validatedForRepair SSTables containing the repaired ranges. Should be referenced before passing them.
     * @param sessionID the repair session we're anti-compacting for
     * @param isCancelled function that indicates if active anti-compaction should be canceled
     * @throws InterruptedException
     * @throws IOException
     */
    public void performAnticompaction(ColumnFamilyStore cfs,
                                      RangesAtEndpoint replicas,
                                      Refs&lt;SSTableReader&gt; validatedForRepair,
                                      LifecycleTransaction txn,
                                      TimeUUID sessionID,
                                      BooleanSupplier isCancelled) throws IOException
    {
        try
        {
            ActiveRepairService.ParentRepairSession prs;
            try
            {
<span class="fc" id="L896">                prs = ActiveRepairService.instance().getParentRepairSession(sessionID);</span>
            }
<span class="nc" id="L898">            catch (NoSuchRepairSessionException e)</span>
            {
<span class="nc" id="L900">                throw new CompactionInterruptedException(e.getMessage());</span>
<span class="fc" id="L901">            }</span>
<span class="pc bpc" id="L902" title="1 of 2 branches missed.">            Preconditions.checkArgument(!prs.isPreview(), &quot;Cannot anticompact for previews&quot;);</span>
<span class="pc bpc" id="L903" title="1 of 2 branches missed.">            Preconditions.checkArgument(!replicas.isEmpty(), &quot;No ranges to anti-compact&quot;);</span>

<span class="pc bpc" id="L905" title="1 of 2 branches missed.">            if (logger.isInfoEnabled())</span>
<span class="fc" id="L906">                logger.info(&quot;{} Starting anticompaction for {}.{} on {}/{} sstables&quot;, PreviewKind.NONE.logPrefix(sessionID), cfs.getKeyspaceName(), cfs.getTableName(), validatedForRepair.size(), cfs.getLiveSSTables().size());</span>
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">            if (logger.isTraceEnabled())</span>
<span class="nc" id="L908">                logger.trace(&quot;{} Starting anticompaction for ranges {}&quot;, PreviewKind.NONE.logPrefix(sessionID), replicas);</span>

<span class="fc" id="L910">            Set&lt;SSTableReader&gt; sstables = new HashSet&lt;&gt;(validatedForRepair);</span>
<span class="fc" id="L911">            validateSSTableBoundsForAnticompaction(sessionID, sstables, replicas);</span>
<span class="fc" id="L912">            mutateFullyContainedSSTables(cfs, validatedForRepair, sstables.iterator(), replicas.onlyFull().ranges(), txn, sessionID, false);</span>
<span class="fc" id="L913">            mutateFullyContainedSSTables(cfs, validatedForRepair, sstables.iterator(), replicas.onlyTransient().ranges(), txn, sessionID, true);</span>

<span class="pc bpc" id="L915" title="1 of 2 branches missed.">            assert txn.originals().equals(sstables);</span>
<span class="fc bfc" id="L916" title="All 2 branches covered.">            if (!sstables.isEmpty())</span>
<span class="fc" id="L917">                doAntiCompaction(cfs, replicas, txn, sessionID, isCancelled);</span>
<span class="fc" id="L918">            txn.finish();</span>
        }
        finally
        {
<span class="fc" id="L922">            validatedForRepair.release();</span>
<span class="fc" id="L923">            txn.close();</span>
        }

<span class="fc" id="L926">        logger.info(&quot;{} Completed anticompaction successfully&quot;, PreviewKind.NONE.logPrefix(sessionID));</span>
<span class="fc" id="L927">    }</span>

    static void validateSSTableBoundsForAnticompaction(TimeUUID sessionID,
                                                       Collection&lt;SSTableReader&gt; sstables,
                                                       RangesAtEndpoint ranges)
    {
<span class="fc" id="L933">        List&lt;Range&lt;Token&gt;&gt; normalizedRanges = Range.normalize(ranges.ranges());</span>
<span class="fc bfc" id="L934" title="All 2 branches covered.">        for (SSTableReader sstable : sstables)</span>
        {
<span class="fc" id="L936">            AbstractBounds&lt;Token&gt; bounds = sstable.getBounds();</span>

<span class="pc bpc" id="L938" title="1 of 8 branches missed.">            if (!Iterables.any(normalizedRanges, r -&gt; (r.contains(bounds.left) &amp;&amp; r.contains(bounds.right)) || r.intersects(bounds)))</span>
            {
                // this should never happen - in PendingAntiCompaction#getSSTables we select all sstables that intersect the repaired ranges, that can't have changed here
<span class="nc" id="L941">                String message = String.format(&quot;%s SSTable %s (%s) does not intersect repaired ranges %s, this sstable should not have been included.&quot;,</span>
<span class="nc" id="L942">                                               PreviewKind.NONE.logPrefix(sessionID), sstable, bounds, normalizedRanges);</span>
<span class="nc" id="L943">                logger.error(message);</span>
<span class="nc" id="L944">                throw new IllegalStateException(message);</span>
            }
<span class="fc" id="L946">        }</span>

<span class="fc" id="L948">    }</span>

    @VisibleForTesting
    static Set&lt;SSTableReader&gt; findSSTablesToAnticompact(Iterator&lt;SSTableReader&gt; sstableIterator, List&lt;Range&lt;Token&gt;&gt; normalizedRanges, TimeUUID parentRepairSession)
    {
<span class="fc" id="L953">        Set&lt;SSTableReader&gt; fullyContainedSSTables = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L954" title="All 2 branches covered.">        while (sstableIterator.hasNext())</span>
        {
<span class="fc" id="L956">            SSTableReader sstable = sstableIterator.next();</span>

<span class="fc" id="L958">            AbstractBounds&lt;Token&gt; sstableBounds = sstable.getBounds();</span>

<span class="fc bfc" id="L960" title="All 2 branches covered.">            for (Range&lt;Token&gt; r : normalizedRanges)</span>
            {
                // ranges are normalized - no wrap around - if first and last are contained we know that all tokens are contained in the range
<span class="fc bfc" id="L963" title="All 4 branches covered.">                if (r.contains(sstable.getFirst().getToken()) &amp;&amp; r.contains(sstable.getLast().getToken()))</span>
                {
<span class="fc" id="L965">                    logger.info(&quot;{} SSTable {} fully contained in range {}, mutating repairedAt instead of anticompacting&quot;, PreviewKind.NONE.logPrefix(parentRepairSession), sstable, r);</span>
<span class="fc" id="L966">                    fullyContainedSSTables.add(sstable);</span>
<span class="fc" id="L967">                    sstableIterator.remove();</span>
<span class="fc" id="L968">                    break;</span>
                }
<span class="fc bfc" id="L970" title="All 2 branches covered.">                else if (r.intersects(sstableBounds))</span>
                {
<span class="fc" id="L972">                    logger.info(&quot;{} SSTable {} ({}) will be anticompacted on range {}&quot;, PreviewKind.NONE.logPrefix(parentRepairSession), sstable, sstableBounds, r);</span>
                }
<span class="fc" id="L974">            }</span>
<span class="fc" id="L975">        }</span>
<span class="fc" id="L976">        return fullyContainedSSTables;</span>
    }

    public void performMaximal(final ColumnFamilyStore cfStore, boolean splitOutput)
    {
<span class="fc" id="L981">        FBUtilities.waitOnFutures(submitMaximal(cfStore, getDefaultGcBefore(cfStore, FBUtilities.nowInSeconds()), splitOutput));</span>
<span class="fc" id="L982">    }</span>

    @SuppressWarnings(&quot;resource&quot;) // the tasks are executed in parallel on the executor, making sure that they get closed
    public List&lt;Future&lt;?&gt;&gt; submitMaximal(final ColumnFamilyStore cfStore, final long gcBefore, boolean splitOutput)
    {
<span class="fc" id="L987">            return submitMaximal(cfStore, gcBefore, splitOutput, OperationType.MAJOR_COMPACTION);</span>
    }

    @SuppressWarnings(&quot;resource&quot;)
    public List&lt;Future&lt;?&gt;&gt; submitMaximal(final ColumnFamilyStore cfStore, final long gcBefore, boolean splitOutput, OperationType operationType)
    {
        // here we compute the task off the compaction executor, so having that present doesn't
        // confuse runWithCompactionsDisabled -- i.e., we don't want to deadlock ourselves, waiting
        // for ourselves to finish/acknowledge cancellation before continuing.
<span class="fc" id="L996">        CompactionTasks tasks = cfStore.getCompactionStrategyManager().getMaximalTasks(gcBefore, splitOutput, operationType);</span>

<span class="fc bfc" id="L998" title="All 2 branches covered.">        if (tasks.isEmpty())</span>
<span class="fc" id="L999">            return Collections.emptyList();</span>

<span class="fc" id="L1001">        List&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L1003">        int nonEmptyTasks = 0;</span>
<span class="fc bfc" id="L1004" title="All 2 branches covered.">        for (final AbstractCompactionTask task : tasks)</span>
        {
<span class="pc bpc" id="L1006" title="1 of 2 branches missed.">            if (task.transaction.originals().size() &gt; 0)</span>
<span class="fc" id="L1007">                nonEmptyTasks++;</span>

<span class="fc" id="L1009">            Runnable runnable = new WrappedRunnable()</span>
<span class="fc" id="L1010">            {</span>
                protected void runMayThrow()
                {
<span class="fc" id="L1013">                    task.execute(active);</span>
<span class="fc" id="L1014">                }</span>
            };

<span class="fc" id="L1017">            Future&lt;?&gt; fut = executor.submitIfRunning(runnable, &quot;maximal task&quot;);</span>
<span class="pc bpc" id="L1018" title="1 of 2 branches missed.">            if (!fut.isCancelled())</span>
<span class="fc" id="L1019">                futures.add(fut);</span>
<span class="fc" id="L1020">        }</span>
<span class="fc bfc" id="L1021" title="All 2 branches covered.">        if (nonEmptyTasks &gt; 1)</span>
<span class="fc" id="L1022">            logger.info(&quot;Major compaction will not result in a single sstable - repaired and unrepaired data is kept separate and compaction runs per data_file_directory.&quot;);</span>

<span class="fc" id="L1024">        return futures;</span>
    }

    public void forceCompaction(ColumnFamilyStore cfStore, Supplier&lt;Collection&lt;SSTableReader&gt;&gt; sstablesFn, com.google.common.base.Predicate&lt;SSTableReader&gt; sstablesPredicate)
    {
<span class="nc" id="L1029">        Callable&lt;CompactionTasks&gt; taskCreator = () -&gt; {</span>
<span class="nc" id="L1030">            Collection&lt;SSTableReader&gt; sstables = sstablesFn.get();</span>
<span class="nc bnc" id="L1031" title="All 4 branches missed.">            if (sstables == null || sstables.isEmpty())</span>
            {
<span class="nc" id="L1033">                logger.debug(&quot;No sstables found for the provided token range&quot;);</span>
<span class="nc" id="L1034">                return CompactionTasks.empty();</span>
            }
<span class="nc" id="L1036">            return cfStore.getCompactionStrategyManager().getUserDefinedTasks(sstables, getDefaultGcBefore(cfStore, FBUtilities.nowInSeconds()));</span>
        };

<span class="nc" id="L1039">        try (CompactionTasks tasks = cfStore.runWithCompactionsDisabled(taskCreator,</span>
                                                                        sstablesPredicate,
                                                                        OperationType.MAJOR_COMPACTION,
                                                                        false,
                                                                        false,
                                                                        false))
        {
<span class="nc bnc" id="L1046" title="All 2 branches missed.">            if (tasks.isEmpty())</span>
<span class="nc" id="L1047">                return;</span>

<span class="nc" id="L1049">            Runnable runnable = new WrappedRunnable()</span>
<span class="nc" id="L1050">            {</span>
                protected void runMayThrow()
                {
<span class="nc bnc" id="L1053" title="All 2 branches missed.">                    for (AbstractCompactionTask task : tasks)</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">                        if (task != null)</span>
                        {
<span class="nc" id="L1056">                            task.setCompactionType(OperationType.MAJOR_COMPACTION);</span>
<span class="nc" id="L1057">                            task.execute(active);</span>
                        }
<span class="nc" id="L1059">                }</span>
            };

<span class="nc" id="L1062">            FBUtilities.waitOnFuture(executor.submitIfRunning(runnable, &quot;force compaction for token range&quot;));</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">        }</span>
<span class="nc" id="L1064">    }</span>

    /**
     * Forces a major compaction of specified token ranges of the specified column family.
     * &lt;p&gt;
     * The token ranges will be interpreted as closed intervals to match the closed interval defined by the first and
     * last keys of a sstable, even though the {@link Range} class is suppossed to be half-open by definition.
     *
     * @param cfStore The column family store to be compacted.
     * @param ranges The token ranges to be compacted, interpreted as closed intervals.
     */
    public void forceCompactionForTokenRange(ColumnFamilyStore cfStore, Collection&lt;Range&lt;Token&gt;&gt; ranges)
    {
<span class="nc" id="L1077">        forceCompaction(cfStore,</span>
<span class="nc" id="L1078">                        () -&gt; sstablesInBounds(cfStore, ranges),</span>
<span class="nc" id="L1079">                        sstable -&gt; sstable.getBounds().intersects(ranges));</span>
<span class="nc" id="L1080">    }</span>

    /**
     * Returns the sstables of the specified column family store that intersect with the specified token ranges.
     * &lt;p&gt;
     * The token ranges will be interpreted as closed intervals to match the closed interval defined by the first and
     * last keys of a sstable, even though the {@link Range} class is suppossed to be half-open by definition.
     */
    private static Collection&lt;SSTableReader&gt; sstablesInBounds(ColumnFamilyStore cfs, Collection&lt;Range&lt;Token&gt;&gt; tokenRangeCollection)
    {
<span class="nc" id="L1090">        final Set&lt;SSTableReader&gt; sstables = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1091">        Iterable&lt;SSTableReader&gt; liveTables = cfs.getTracker().getView().select(SSTableSet.LIVE);</span>
<span class="nc" id="L1092">        SSTableIntervalTree tree = SSTableIntervalTree.build(liveTables);</span>

<span class="nc bnc" id="L1094" title="All 2 branches missed.">        for (Range&lt;Token&gt; tokenRange : tokenRangeCollection)</span>
        {
<span class="nc bnc" id="L1096" title="All 2 branches missed.">            if (!AbstractBounds.strictlyWrapsAround(tokenRange.left, tokenRange.right))</span>
            {
<span class="nc" id="L1098">                Iterable&lt;SSTableReader&gt; ssTableReaders = View.sstablesInBounds(tokenRange.left.minKeyBound(), tokenRange.right.maxKeyBound(), tree);</span>
<span class="nc" id="L1099">                Iterables.addAll(sstables, ssTableReaders);</span>
<span class="nc" id="L1100">            }</span>
            else
            {
                // Searching an interval tree will not return the correct results for a wrapping range
                // so we have to unwrap it first
<span class="nc bnc" id="L1105" title="All 2 branches missed.">                for (Range&lt;Token&gt; unwrappedRange : tokenRange.unwrap())</span>
                {
<span class="nc" id="L1107">                    Iterable&lt;SSTableReader&gt; ssTableReaders = View.sstablesInBounds(unwrappedRange.left.minKeyBound(), unwrappedRange.right.maxKeyBound(), tree);</span>
<span class="nc" id="L1108">                    Iterables.addAll(sstables, ssTableReaders);</span>
<span class="nc" id="L1109">                }</span>
            }
<span class="nc" id="L1111">        }</span>
<span class="nc" id="L1112">        return sstables;</span>
    }

    public void forceCompactionForKey(ColumnFamilyStore cfStore, DecoratedKey key)
    {
<span class="nc" id="L1117">        forceCompaction(cfStore, () -&gt; sstablesWithKey(cfStore, key), Predicates.alwaysTrue());</span>
<span class="nc" id="L1118">    }</span>

    public void forceCompactionForKeys(ColumnFamilyStore cfStore, Collection&lt;DecoratedKey&gt; keys)
    {
<span class="nc" id="L1122">        forceCompaction(cfStore, () -&gt; sstablesWithKeys(cfStore, keys), Predicates.alwaysTrue());</span>
<span class="nc" id="L1123">    }</span>

    private static Collection&lt;SSTableReader&gt; sstablesWithKey(ColumnFamilyStore cfs, DecoratedKey key)
    {
<span class="nc" id="L1127">        final Set&lt;SSTableReader&gt; sstables = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1128">        Iterable&lt;SSTableReader&gt; liveTables = cfs.getTracker().getView().liveSSTablesInBounds(key.getToken().minKeyBound(),</span>
<span class="nc" id="L1129">                                                                                             key.getToken().maxKeyBound());</span>
<span class="nc bnc" id="L1130" title="All 2 branches missed.">        for (SSTableReader sstable : liveTables)</span>
        {
<span class="nc bnc" id="L1132" title="All 2 branches missed.">            if (sstable.mayContainAssumingKeyIsInRange(key))</span>
<span class="nc" id="L1133">                sstables.add(sstable);</span>
<span class="nc" id="L1134">        }</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">        return sstables.isEmpty() ? Collections.emptyList() : sstables;</span>
    }

    private static Collection&lt;SSTableReader&gt; sstablesWithKeys(ColumnFamilyStore cfs, Collection&lt;DecoratedKey&gt; decoratedKeys)
    {
<span class="nc" id="L1140">        final Set&lt;SSTableReader&gt; sstables = new HashSet&lt;&gt;();</span>

<span class="nc bnc" id="L1142" title="All 2 branches missed.">        for (DecoratedKey decoratedKey : decoratedKeys)</span>
        {
<span class="nc" id="L1144">            sstables.addAll(sstablesWithKey(cfs, decoratedKey));</span>
<span class="nc" id="L1145">        }</span>

<span class="nc" id="L1147">        return sstables;</span>
    }

    public void forceUserDefinedCompaction(String dataFiles)
    {
<span class="fc" id="L1152">        String[] filenames = dataFiles.split(&quot;,&quot;);</span>
<span class="fc" id="L1153">        Multimap&lt;ColumnFamilyStore, Descriptor&gt; descriptors = ArrayListMultimap.create();</span>

<span class="fc bfc" id="L1155" title="All 2 branches covered.">        for (String filename : filenames)</span>
        {
            // extract keyspace and columnfamily name from filename
<span class="fc" id="L1158">            Descriptor desc = Descriptor.fromFileWithComponent(new File(filename.trim()), false).left;</span>
<span class="pc bpc" id="L1159" title="1 of 2 branches missed.">            if (Schema.instance.getTableMetadataRef(desc) == null)</span>
            {
<span class="nc" id="L1161">                logger.warn(&quot;Schema does not exist for file {}. Skipping.&quot;, filename);</span>
<span class="nc" id="L1162">                continue;</span>
            }
            // group by keyspace/columnfamily
<span class="fc" id="L1165">            ColumnFamilyStore cfs = Keyspace.open(desc.ksname).getColumnFamilyStore(desc.cfname);</span>
<span class="fc" id="L1166">            descriptors.put(cfs, cfs.getDirectories().find(new File(filename.trim()).name()));</span>
        }

<span class="fc" id="L1169">        List&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;(descriptors.size());</span>
<span class="fc" id="L1170">        long nowInSec = FBUtilities.nowInSeconds();</span>
<span class="fc bfc" id="L1171" title="All 2 branches covered.">        for (ColumnFamilyStore cfs : descriptors.keySet())</span>
<span class="fc" id="L1172">            futures.add(submitUserDefined(cfs, descriptors.get(cfs), getDefaultGcBefore(cfs, nowInSec)));</span>
<span class="fc" id="L1173">        FBUtilities.waitOnFutures(futures);</span>
<span class="fc" id="L1174">    }</span>

    public void forceUserDefinedCleanup(String dataFiles)
    {
<span class="nc" id="L1178">        String[] filenames = dataFiles.split(&quot;,&quot;);</span>
<span class="nc" id="L1179">        HashMap&lt;ColumnFamilyStore, Descriptor&gt; descriptors = Maps.newHashMap();</span>

<span class="nc bnc" id="L1181" title="All 2 branches missed.">        for (String filename : filenames)</span>
        {
            // extract keyspace and columnfamily name from filename
<span class="nc" id="L1184">            Descriptor desc = Descriptor.fromFileWithComponent(new File(filename.trim()), false).left;</span>
<span class="nc bnc" id="L1185" title="All 2 branches missed.">            if (Schema.instance.getTableMetadataRef(desc) == null)</span>
            {
<span class="nc" id="L1187">                logger.warn(&quot;Schema does not exist for file {}. Skipping.&quot;, filename);</span>
<span class="nc" id="L1188">                continue;</span>
            }
            // group by keyspace/columnfamily
<span class="nc" id="L1191">            ColumnFamilyStore cfs = Keyspace.open(desc.ksname).getColumnFamilyStore(desc.cfname);</span>
<span class="nc" id="L1192">            desc = cfs.getDirectories().find(new File(filename.trim()).name());</span>
<span class="nc bnc" id="L1193" title="All 2 branches missed.">            if (desc != null)</span>
<span class="nc" id="L1194">                descriptors.put(cfs, desc);</span>
        }

<span class="nc bnc" id="L1197" title="All 2 branches missed.">        if (!StorageService.instance.isJoined())</span>
        {
<span class="nc" id="L1199">            logger.error(&quot;Cleanup cannot run before a node has joined the ring&quot;);</span>
<span class="nc" id="L1200">            return;</span>
        }

<span class="nc bnc" id="L1203" title="All 2 branches missed.">        for (Map.Entry&lt;ColumnFamilyStore,Descriptor&gt; entry : descriptors.entrySet())</span>
        {
<span class="nc" id="L1205">            ColumnFamilyStore cfs = entry.getKey();</span>
<span class="nc" id="L1206">            Keyspace keyspace = cfs.keyspace;</span>
<span class="nc" id="L1207">            final RangesAtEndpoint replicas = StorageService.instance.getLocalReplicas(keyspace.getName());</span>
<span class="nc" id="L1208">            final Set&lt;Range&lt;Token&gt;&gt; allRanges = replicas.ranges();</span>
<span class="nc" id="L1209">            final Set&lt;Range&lt;Token&gt;&gt; transientRanges = replicas.onlyTransient().ranges();</span>
<span class="nc" id="L1210">            boolean hasIndexes = cfs.indexManager.hasIndexes();</span>
<span class="nc" id="L1211">            SSTableReader sstable = lookupSSTable(cfs, entry.getValue());</span>

<span class="nc bnc" id="L1213" title="All 2 branches missed.">            if (sstable == null)</span>
            {
<span class="nc" id="L1215">                logger.warn(&quot;Will not clean {}, it is not an active sstable&quot;, entry.getValue());</span>
            }
            else
            {
<span class="nc" id="L1219">                CleanupStrategy cleanupStrategy = CleanupStrategy.get(cfs, allRanges, transientRanges, sstable.isRepaired(), FBUtilities.nowInSeconds());</span>
<span class="nc" id="L1220">                try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstable, OperationType.CLEANUP))</span>
                {
<span class="nc" id="L1222">                    doCleanupOne(cfs, txn, cleanupStrategy, allRanges, hasIndexes);</span>
                }
<span class="nc" id="L1224">                catch (IOException e)</span>
                {
<span class="nc" id="L1226">                    logger.error(&quot;forceUserDefinedCleanup failed: {}&quot;, e.getLocalizedMessage());</span>
<span class="nc" id="L1227">                }</span>
            }
<span class="nc" id="L1229">        }</span>
<span class="nc" id="L1230">    }</span>


    public Future&lt;?&gt; submitUserDefined(final ColumnFamilyStore cfs, final Collection&lt;Descriptor&gt; dataFiles, final long gcBefore)
    {
<span class="fc" id="L1235">        Runnable runnable = new WrappedRunnable()</span>
<span class="fc" id="L1236">        {</span>
            protected void runMayThrow() throws Exception
            {
                // look up the sstables now that we're on the compaction executor, so we don't try to re-compact
                // something that was already being compacted earlier.
<span class="fc" id="L1241">                Collection&lt;SSTableReader&gt; sstables = new ArrayList&lt;&gt;(dataFiles.size());</span>
<span class="fc bfc" id="L1242" title="All 2 branches covered.">                for (Descriptor desc : dataFiles)</span>
                {
                    // inefficient but not in a performance sensitive path
<span class="fc" id="L1245">                    SSTableReader sstable = lookupSSTable(cfs, desc);</span>
<span class="pc bpc" id="L1246" title="1 of 2 branches missed.">                    if (sstable == null)</span>
                    {
<span class="nc" id="L1248">                        logger.info(&quot;Will not compact {}: it is not an active sstable&quot;, desc);</span>
                    }
                    else
                    {
<span class="fc" id="L1252">                        sstables.add(sstable);</span>
                    }
<span class="fc" id="L1254">                }</span>

<span class="pc bpc" id="L1256" title="1 of 2 branches missed.">                if (sstables.isEmpty())</span>
                {
<span class="nc" id="L1258">                    logger.info(&quot;No files to compact for user defined compaction&quot;);</span>
                }
                else
                {
<span class="fc" id="L1262">                    try (CompactionTasks tasks = cfs.getCompactionStrategyManager().getUserDefinedTasks(sstables, gcBefore))</span>
                    {
<span class="fc bfc" id="L1264" title="All 2 branches covered.">                        for (AbstractCompactionTask task : tasks)</span>
                        {
<span class="pc bpc" id="L1266" title="1 of 2 branches missed.">                            if (task != null)</span>
<span class="fc" id="L1267">                                task.execute(active);</span>
<span class="fc" id="L1268">                        }</span>
                    }
                }
<span class="fc" id="L1271">            }</span>
        };

<span class="fc" id="L1274">        return executor.submitIfRunning(runnable, &quot;user defined task&quot;);</span>
    }

    // This acquire a reference on the sstable
    // This is not efficient, do not use in any critical path
    private SSTableReader lookupSSTable(final ColumnFamilyStore cfs, Descriptor descriptor)
    {
<span class="pc bpc" id="L1281" title="1 of 2 branches missed.">        for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))</span>
        {
<span class="fc bfc" id="L1283" title="All 2 branches covered.">            if (sstable.descriptor.equals(descriptor))</span>
<span class="fc" id="L1284">                return sstable;</span>
<span class="fc" id="L1285">        }</span>
<span class="nc" id="L1286">        return null;</span>
    }

    public Future&lt;?&gt; submitValidation(Callable&lt;Object&gt; validation)
    {
<span class="fc" id="L1291">        return validationExecutor.submitIfRunning(validation, &quot;validation&quot;);</span>
    }

    /* Used in tests. */
    public void disableAutoCompaction()
    {
<span class="nc bnc" id="L1297" title="All 2 branches missed.">        for (String ksname : Schema.instance.getNonSystemKeyspaces().names())</span>
        {
<span class="nc bnc" id="L1299" title="All 2 branches missed.">            for (ColumnFamilyStore cfs : Keyspace.open(ksname).getColumnFamilyStores())</span>
<span class="nc" id="L1300">                cfs.disableAutoCompaction();</span>
<span class="nc" id="L1301">        }</span>
<span class="nc" id="L1302">    }</span>

    @VisibleForTesting
    void scrubOne(ColumnFamilyStore cfs, LifecycleTransaction modifier, IScrubber.Options options, ActiveCompactionsTracker activeCompactions)
    {
<span class="fc" id="L1307">        CompactionInfo.Holder scrubInfo = null;</span>
<span class="fc" id="L1308">        SSTableFormat format = modifier.onlyOne().descriptor.getFormat();</span>
<span class="fc" id="L1309">        try (IScrubber scrubber = format.getScrubber(cfs, modifier, new OutputHandler.LogOutput(), options))</span>
        {
<span class="fc" id="L1311">            scrubInfo = scrubber.getScrubInfo();</span>
<span class="fc" id="L1312">            activeCompactions.beginCompaction(scrubInfo);</span>
<span class="fc" id="L1313">            scrubber.scrub();</span>
        }
        finally
        {
<span class="pc bpc" id="L1317" title="1 of 2 branches missed.">            if (scrubInfo != null)</span>
<span class="fc" id="L1318">                activeCompactions.finishCompaction(scrubInfo);</span>
        }
<span class="fc" id="L1320">    }</span>

    @VisibleForTesting
    void verifyOne(ColumnFamilyStore cfs, SSTableReader sstable, IVerifier.Options options, ActiveCompactionsTracker activeCompactions)
    {
<span class="nc" id="L1325">        CompactionInfo.Holder verifyInfo = null;</span>
<span class="nc" id="L1326">        try (IVerifier verifier = sstable.getVerifier(cfs, new OutputHandler.LogOutput(), false, options))</span>
        {
<span class="nc" id="L1328">            verifyInfo = verifier.getVerifyInfo();</span>
<span class="nc" id="L1329">            activeCompactions.beginCompaction(verifyInfo);</span>
<span class="nc" id="L1330">            verifier.verify();</span>
        }
        finally
        {
<span class="nc bnc" id="L1334" title="All 2 branches missed.">            if (verifyInfo != null)</span>
<span class="nc" id="L1335">                activeCompactions.finishCompaction(verifyInfo);</span>
        }
<span class="nc" id="L1337">    }</span>

    /**
     * Determines if a cleanup would actually remove any data in this SSTable based
     * on a set of owned ranges.
     */
    @VisibleForTesting
    public static boolean needsCleanup(SSTableReader sstable, Collection&lt;Range&lt;Token&gt;&gt; ownedRanges)
    {
<span class="fc bfc" id="L1346" title="All 2 branches covered.">        if (ownedRanges.isEmpty())</span>
        {
<span class="fc" id="L1348">            return true; // all data will be cleaned</span>
        }

        // unwrap and sort the ranges by LHS token
<span class="fc" id="L1352">        List&lt;Range&lt;Token&gt;&gt; sortedRanges = Range.normalize(ownedRanges);</span>

        // see if there are any keys LTE the token for the start of the first range
        // (token range ownership is exclusive on the LHS.)
<span class="fc" id="L1356">        Range&lt;Token&gt; firstRange = sortedRanges.get(0);</span>
<span class="fc bfc" id="L1357" title="All 2 branches covered.">        if (sstable.getFirst().getToken().compareTo(firstRange.left) &lt;= 0)</span>
<span class="fc" id="L1358">            return true;</span>

        // then, iterate over all owned ranges and see if the next key beyond the end of the owned
        // range falls before the start of the next range
<span class="pc bpc" id="L1362" title="1 of 2 branches missed.">        for (int i = 0; i &lt; sortedRanges.size(); i++)</span>
        {
<span class="fc" id="L1364">            Range&lt;Token&gt; range = sortedRanges.get(i);</span>
<span class="fc bfc" id="L1365" title="All 2 branches covered.">            if (range.right.isMinimum())</span>
            {
                // we split a wrapping range and this is the second half.
                // there can't be any keys beyond this (and this is the last range)
<span class="fc" id="L1369">                return false;</span>
            }

<span class="fc" id="L1372">            DecoratedKey firstBeyondRange = sstable.firstKeyBeyond(range.right.maxKeyBound());</span>
<span class="fc bfc" id="L1373" title="All 2 branches covered.">            if (firstBeyondRange == null)</span>
            {
                // we ran off the end of the sstable looking for the next key; we don't need to check any more ranges
<span class="fc" id="L1376">                return false;</span>
            }

<span class="pc bpc" id="L1379" title="1 of 2 branches missed.">            if (i == (sortedRanges.size() - 1))</span>
            {
                // we're at the last range and we found a key beyond the end of the range
<span class="nc" id="L1382">                return true;</span>
            }

<span class="fc" id="L1385">            Range&lt;Token&gt; nextRange = sortedRanges.get(i + 1);</span>
<span class="fc bfc" id="L1386" title="All 2 branches covered.">            if (firstBeyondRange.getToken().compareTo(nextRange.left) &lt;= 0)</span>
            {
                // we found a key in between the owned ranges
<span class="fc" id="L1389">                return true;</span>
            }
        }

<span class="nc" id="L1393">        return false;</span>
    }

    /**
     * This function goes over a file and removes the keys that the node is not responsible for
     * and only keeps keys that this node is responsible for.
     *
     * @throws IOException
     */
    private void doCleanupOne(final ColumnFamilyStore cfs,
                              LifecycleTransaction txn,
                              CleanupStrategy cleanupStrategy,
                              Collection&lt;Range&lt;Token&gt;&gt; allRanges,
                              boolean hasIndexes) throws IOException
    {
<span class="pc bpc" id="L1408" title="1 of 2 branches missed.">        assert !cfs.isIndex();</span>

<span class="fc" id="L1410">        SSTableReader sstable = txn.onlyOne();</span>

        // if ranges is empty and no index, entire sstable is discarded
<span class="fc bfc" id="L1413" title="All 4 branches covered.">        if (!hasIndexes &amp;&amp; !sstable.getBounds().intersects(allRanges))</span>
        {
<span class="fc" id="L1415">            txn.obsoleteOriginals();</span>
<span class="fc" id="L1416">            txn.finish();</span>
<span class="fc" id="L1417">            logger.info(&quot;SSTable {} ([{}, {}]) does not intersect the owned ranges ({}), dropping it&quot;, sstable, sstable.getFirst().getToken(), sstable.getLast().getToken(), allRanges);</span>
<span class="fc" id="L1418">            return;</span>
        }

<span class="fc" id="L1421">        long start = nanoTime();</span>

<span class="fc" id="L1423">        long totalkeysWritten = 0;</span>

<span class="fc" id="L1425">        long expectedBloomFilterSize = Math.max(cfs.metadata().params.minIndexInterval,</span>
<span class="fc" id="L1426">                                               SSTableReader.getApproximateKeyCount(txn.originals()));</span>
<span class="pc bpc" id="L1427" title="1 of 2 branches missed.">        if (logger.isTraceEnabled())</span>
<span class="nc" id="L1428">            logger.trace(&quot;Expected bloom filter size : {}&quot;, expectedBloomFilterSize);</span>

<span class="fc" id="L1430">        logger.info(&quot;Cleaning up {}&quot;, sstable);</span>

<span class="fc" id="L1432">        File compactionFileLocation = sstable.descriptor.directory;</span>
<span class="fc" id="L1433">        RateLimiter limiter = getRateLimiter();</span>
<span class="fc" id="L1434">        double compressionRatio = sstable.getCompressionRatio();</span>
<span class="fc bfc" id="L1435" title="All 2 branches covered.">        if (compressionRatio == MetadataCollector.NO_COMPRESSION_RATIO)</span>
<span class="fc" id="L1436">            compressionRatio = 1.0;</span>

        List&lt;SSTableReader&gt; finished;

<span class="fc" id="L1440">        long nowInSec = FBUtilities.nowInSeconds();</span>
<span class="fc" id="L1441">        try (SSTableRewriter writer = SSTableRewriter.construct(cfs, txn, false, sstable.maxDataAge);</span>
<span class="fc" id="L1442">             ISSTableScanner scanner = cleanupStrategy.getScanner(sstable);</span>
<span class="fc" id="L1443">             CompactionController controller = new CompactionController(cfs, txn.originals(), getDefaultGcBefore(cfs, nowInSec));</span>
<span class="fc" id="L1444">             Refs&lt;SSTableReader&gt; refs = Refs.ref(Collections.singleton(sstable));</span>
<span class="fc" id="L1445">             CompactionIterator ci = new CompactionIterator(OperationType.CLEANUP, Collections.singletonList(scanner), controller, nowInSec, nextTimeUUID(), active, null))</span>
        {
<span class="fc" id="L1447">            StatsMetadata metadata = sstable.getSSTableMetadata();</span>
<span class="fc" id="L1448">            writer.switchWriter(createWriter(cfs, compactionFileLocation, expectedBloomFilterSize, metadata.repairedAt, metadata.pendingRepair, metadata.isTransient, sstable, txn));</span>
<span class="fc" id="L1449">            long lastBytesScanned = 0;</span>

<span class="fc bfc" id="L1451" title="All 2 branches covered.">            while (ci.hasNext())</span>
            {
<span class="fc" id="L1453">                ci.setTargetDirectory(writer.currentWriter().getFilename());</span>
<span class="fc" id="L1454">                try (UnfilteredRowIterator partition = ci.next();</span>
<span class="fc" id="L1455">                     UnfilteredRowIterator notCleaned = cleanupStrategy.cleanup(partition))</span>
                {
<span class="fc bfc" id="L1457" title="All 2 branches covered.">                    if (notCleaned == null)</span>
                        continue;

<span class="pc bpc" id="L1460" title="1 of 2 branches missed.">                    if (writer.append(notCleaned) != null)</span>
<span class="fc" id="L1461">                        totalkeysWritten++;</span>

<span class="fc" id="L1463">                    long bytesScanned = scanner.getBytesScanned();</span>

<span class="fc" id="L1465">                    compactionRateLimiterAcquire(limiter, bytesScanned, lastBytesScanned, compressionRatio);</span>

<span class="fc" id="L1467">                    lastBytesScanned = bytesScanned;</span>
<span class="pc bpc" id="L1468" title="2 of 4 branches missed.">                }</span>
            }

            // flush to ensure we don't lose the tombstones on a restart, since they are not commitlog'd
<span class="fc" id="L1472">            cfs.indexManager.flushAllIndexesBlocking();</span>

<span class="fc" id="L1474">            finished = writer.finish();</span>
        }

<span class="fc bfc" id="L1477" title="All 2 branches covered.">        if (!finished.isEmpty())</span>
        {
<span class="fc" id="L1479">            String format = &quot;Cleaned up to %s.  %s to %s (~%d%% of original) for %,d keys.  Time: %,dms.&quot;;</span>
<span class="fc" id="L1480">            long dTime = TimeUnit.NANOSECONDS.toMillis(nanoTime() - start);</span>
<span class="fc" id="L1481">            long startsize = sstable.onDiskLength();</span>
<span class="fc" id="L1482">            long endsize = 0;</span>
<span class="fc bfc" id="L1483" title="All 2 branches covered.">            for (SSTableReader newSstable : finished)</span>
<span class="fc" id="L1484">                endsize += newSstable.onDiskLength();</span>
<span class="fc" id="L1485">            double ratio = (double) endsize / (double) startsize;</span>
<span class="fc" id="L1486">            logger.info(String.format(format, finished.get(0).getFilename(), FBUtilities.prettyPrintMemory(startsize),</span>
<span class="fc" id="L1487">                                      FBUtilities.prettyPrintMemory(endsize), (int) (ratio * 100), totalkeysWritten, dTime));</span>
        }

<span class="fc" id="L1490">    }</span>

    static void compactionRateLimiterAcquire(RateLimiter limiter, long bytesScanned, long lastBytesScanned, double compressionRatio)
    {
<span class="fc" id="L1494">        long lengthRead = (long) ((bytesScanned - lastBytesScanned) * compressionRatio) + 1;</span>
<span class="pc bpc" id="L1495" title="1 of 2 branches missed.">        while (lengthRead &gt;= Integer.MAX_VALUE)</span>
        {
<span class="nc" id="L1497">            limiter.acquire(Integer.MAX_VALUE);</span>
<span class="nc" id="L1498">            lengthRead -= Integer.MAX_VALUE;</span>
        }
<span class="pc bpc" id="L1500" title="1 of 2 branches missed.">        if (lengthRead &gt; 0)</span>
        {
<span class="fc" id="L1502">            limiter.acquire((int) lengthRead);</span>
        }
<span class="fc" id="L1504">    }</span>

    private static abstract class CleanupStrategy
    {
        protected final Collection&lt;Range&lt;Token&gt;&gt; ranges;
        protected final long nowInSec;

        protected CleanupStrategy(Collection&lt;Range&lt;Token&gt;&gt; ranges, long nowInSec)
<span class="fc" id="L1512">        {</span>
<span class="fc" id="L1513">            this.ranges = ranges;</span>
<span class="fc" id="L1514">            this.nowInSec = nowInSec;</span>
<span class="fc" id="L1515">        }</span>

        public static CleanupStrategy get(ColumnFamilyStore cfs, Collection&lt;Range&lt;Token&gt;&gt; ranges, Collection&lt;Range&lt;Token&gt;&gt; transientRanges, boolean isRepaired, long nowInSec)
        {
<span class="fc bfc" id="L1519" title="All 2 branches covered.">            if (cfs.indexManager.hasIndexes())</span>
            {
<span class="pc bpc" id="L1521" title="1 of 2 branches missed.">                if (!transientRanges.isEmpty())</span>
                {
                    //Shouldn't have been possible to create this situation
<span class="nc" id="L1524">                    throw new AssertionError(&quot;Can't have indexes and transient ranges&quot;);</span>
                }
<span class="fc" id="L1526">                return new Full(cfs, ranges, nowInSec);</span>
            }
<span class="fc" id="L1528">            return new Bounded(cfs, ranges, transientRanges, isRepaired, nowInSec);</span>
        }

        public abstract ISSTableScanner getScanner(SSTableReader sstable);
        public abstract UnfilteredRowIterator cleanup(UnfilteredRowIterator partition);

        private static final class Bounded extends CleanupStrategy
        {
            private final Collection&lt;Range&lt;Token&gt;&gt; transientRanges;
            private final boolean isRepaired;

            public Bounded(final ColumnFamilyStore cfs, Collection&lt;Range&lt;Token&gt;&gt; ranges, Collection&lt;Range&lt;Token&gt;&gt; transientRanges, boolean isRepaired, long nowInSec)
            {
<span class="fc" id="L1541">                super(ranges, nowInSec);</span>
<span class="fc" id="L1542">                instance.cacheCleanupExecutor.submit(new Runnable()</span>
<span class="fc" id="L1543">                {</span>
                    @Override
                    public void run()
                    {
<span class="fc" id="L1547">                        cfs.cleanupCache();</span>
<span class="fc" id="L1548">                    }</span>
                });
<span class="fc" id="L1550">                this.transientRanges = transientRanges;</span>
<span class="fc" id="L1551">                this.isRepaired = isRepaired;</span>
<span class="fc" id="L1552">            }</span>

            @Override
            public ISSTableScanner getScanner(SSTableReader sstable)
            {
                //If transient replication is enabled and there are transient ranges
                //then cleanup should remove any partitions that are repaired and in the transient range
                //as they should already be synchronized at other full replicas.
                //So just don't scan the portion of the table containing the repaired transient ranges
<span class="fc" id="L1561">                Collection&lt;Range&lt;Token&gt;&gt; rangesToScan = ranges;</span>
<span class="pc bpc" id="L1562" title="1 of 2 branches missed.">                if (isRepaired)</span>
                {
<span class="nc bnc" id="L1564" title="All 2 branches missed.">                    rangesToScan = Collections2.filter(ranges, range -&gt; !transientRanges.contains(range));</span>
                }
<span class="fc" id="L1566">                return sstable.getScanner(rangesToScan);</span>
            }

            @Override
            public UnfilteredRowIterator cleanup(UnfilteredRowIterator partition)
            {
<span class="fc" id="L1572">                return partition;</span>
            }
        }

        private static final class Full extends CleanupStrategy
        {
            private final ColumnFamilyStore cfs;

            public Full(ColumnFamilyStore cfs, Collection&lt;Range&lt;Token&gt;&gt; ranges, long nowInSec)
            {
<span class="fc" id="L1582">                super(ranges, nowInSec);</span>
<span class="fc" id="L1583">                this.cfs = cfs;</span>
<span class="fc" id="L1584">            }</span>

            @Override
            public ISSTableScanner getScanner(SSTableReader sstable)
            {
<span class="fc" id="L1589">                return sstable.getScanner();</span>
            }

            @Override
            public UnfilteredRowIterator cleanup(UnfilteredRowIterator partition)
            {
<span class="pc bpc" id="L1595" title="1 of 2 branches missed.">                if (Range.isInRanges(partition.partitionKey().getToken(), ranges))</span>
<span class="nc" id="L1596">                    return partition;</span>

<span class="fc" id="L1598">                cfs.invalidateCachedPartition(partition.partitionKey());</span>

<span class="fc" id="L1600">                cfs.indexManager.deletePartition(partition, nowInSec);</span>
<span class="fc" id="L1601">                return null;</span>
            }
        }
    }

    public static SSTableWriter createWriter(ColumnFamilyStore cfs,
                                             File compactionFileLocation,
                                             long expectedBloomFilterSize,
                                             long repairedAt,
                                             TimeUUID pendingRepair,
                                             boolean isTransient,
                                             SSTableReader sstable,
                                             LifecycleTransaction txn)
    {
<span class="fc" id="L1615">        FileUtils.createDirectory(compactionFileLocation);</span>

<span class="fc" id="L1617">        Descriptor descriptor = cfs.newSSTableDescriptor(compactionFileLocation);</span>
<span class="fc" id="L1618">        return descriptor.getFormat().getWriterFactory().builder(descriptor)</span>
<span class="fc" id="L1619">                         .setKeyCount(expectedBloomFilterSize)</span>
<span class="fc" id="L1620">                         .setRepairedAt(repairedAt)</span>
<span class="fc" id="L1621">                         .setPendingRepair(pendingRepair)</span>
<span class="fc" id="L1622">                         .setTransientSSTable(isTransient)</span>
<span class="fc" id="L1623">                         .setTableMetadataRef(cfs.metadata)</span>
<span class="fc" id="L1624">                         .setMetadataCollector(new MetadataCollector(cfs.metadata().comparator).sstableLevel(sstable.getSSTableLevel()))</span>
<span class="fc" id="L1625">                         .setSerializationHeader(sstable.header)</span>
<span class="fc" id="L1626">                         .addDefaultComponents(cfs.indexManager.listIndexGroups())</span>
<span class="fc" id="L1627">                         .setSecondaryIndexGroups(cfs.indexManager.listIndexGroups())</span>
<span class="fc" id="L1628">                         .build(txn, cfs);</span>
    }

    public static SSTableWriter createWriterForAntiCompaction(ColumnFamilyStore cfs,
                                                              File compactionFileLocation,
                                                              int expectedBloomFilterSize,
                                                              long repairedAt,
                                                              TimeUUID pendingRepair,
                                                              boolean isTransient,
                                                              Collection&lt;SSTableReader&gt; sstables,
                                                              ILifecycleTransaction txn)
    {
<span class="fc" id="L1640">        FileUtils.createDirectory(compactionFileLocation);</span>
<span class="fc" id="L1641">        int minLevel = Integer.MAX_VALUE;</span>
        // if all sstables have the same level, we can compact them together without creating overlap during anticompaction
        // note that we only anticompact from unrepaired sstables, which is not leveled, but we still keep original level
        // after first migration to be able to drop the sstables back in their original place in the repaired sstable manifest
<span class="fc bfc" id="L1645" title="All 2 branches covered.">        for (SSTableReader sstable : sstables)</span>
        {
<span class="pc bpc" id="L1647" title="1 of 2 branches missed.">            if (minLevel == Integer.MAX_VALUE)</span>
<span class="fc" id="L1648">                minLevel = sstable.getSSTableLevel();</span>

<span class="pc bpc" id="L1650" title="1 of 2 branches missed.">            if (minLevel != sstable.getSSTableLevel())</span>
            {
<span class="nc" id="L1652">                minLevel = 0;</span>
<span class="nc" id="L1653">                break;</span>
            }
<span class="fc" id="L1655">        }</span>

<span class="fc" id="L1657">        Descriptor descriptor = cfs.newSSTableDescriptor(compactionFileLocation);</span>
<span class="fc" id="L1658">        return descriptor.getFormat().getWriterFactory().builder(descriptor)</span>
<span class="fc" id="L1659">                         .setKeyCount(expectedBloomFilterSize)</span>
<span class="fc" id="L1660">                         .setRepairedAt(repairedAt)</span>
<span class="fc" id="L1661">                         .setPendingRepair(pendingRepair)</span>
<span class="fc" id="L1662">                         .setTransientSSTable(isTransient)</span>
<span class="fc" id="L1663">                         .setTableMetadataRef(cfs.metadata)</span>
<span class="fc" id="L1664">                         .setMetadataCollector(new MetadataCollector(sstables, cfs.metadata().comparator).sstableLevel(minLevel))</span>
<span class="fc" id="L1665">                         .setSerializationHeader(SerializationHeader.make(cfs.metadata(), sstables))</span>
<span class="fc" id="L1666">                         .addDefaultComponents(cfs.indexManager.listIndexGroups())</span>
<span class="fc" id="L1667">                         .setSecondaryIndexGroups(cfs.indexManager.listIndexGroups())</span>
<span class="fc" id="L1668">                         .build(txn, cfs);</span>
    }

    /**
     * Splits up an sstable into two new sstables. The first of the new tables will store repaired ranges, the second
     * will store the non-repaired ranges. Once anticompation is completed, the original sstable is marked as compacted
     * and subsequently deleted.
     * @param cfs
     * @param txn a transaction over the repaired sstables to anticompact
     * @param ranges full and transient ranges to be placed into one of the new sstables. The repaired table will be tracked via
     *   the {@link org.apache.cassandra.io.sstable.metadata.StatsMetadata#pendingRepair} field.
     * @param pendingRepair the repair session we're anti-compacting for
     * @param isCancelled function that indicates if active anti-compaction should be canceled
     */
    private void doAntiCompaction(ColumnFamilyStore cfs,
                                  RangesAtEndpoint ranges,
                                  LifecycleTransaction txn,
                                  TimeUUID pendingRepair,
                                  BooleanSupplier isCancelled)
    {
<span class="fc" id="L1688">        int originalCount = txn.originals().size();</span>
<span class="fc" id="L1689">        logger.info(&quot;Performing anticompaction on {} sstables for {}&quot;, originalCount, pendingRepair);</span>

        //Group SSTables
<span class="fc" id="L1692">        Set&lt;SSTableReader&gt; sstables = txn.originals();</span>

        // Repairs can take place on both unrepaired (incremental + full) and repaired (full) data.
        // Although anti-compaction could work on repaired sstables as well and would result in having more accurate
        // repairedAt values for these, we still avoid anti-compacting already repaired sstables, as we currently don't
        // make use of any actual repairedAt value and splitting up sstables just for that is not worth it at this point.
<span class="pc bpc" id="L1698" title="1 of 2 branches missed.">        Set&lt;SSTableReader&gt; unrepairedSSTables = sstables.stream().filter((s) -&gt; !s.isRepaired()).collect(Collectors.toSet());</span>
<span class="fc" id="L1699">        cfs.metric.bytesAnticompacted.inc(SSTableReader.getTotalBytes(unrepairedSSTables));</span>
<span class="fc" id="L1700">        Collection&lt;Collection&lt;SSTableReader&gt;&gt; groupedSSTables = cfs.getCompactionStrategyManager().groupSSTablesForAntiCompaction(unrepairedSSTables);</span>

        // iterate over sstables to check if the full / transient / unrepaired ranges intersect them.
<span class="fc" id="L1703">        int antiCompactedSSTableCount = 0;</span>
<span class="fc bfc" id="L1704" title="All 2 branches covered.">        for (Collection&lt;SSTableReader&gt; sstableGroup : groupedSSTables)</span>
        {
<span class="fc" id="L1706">            try (LifecycleTransaction groupTxn = txn.split(sstableGroup))</span>
            {
<span class="fc" id="L1708">                int antiCompacted = antiCompactGroup(cfs, ranges, groupTxn, pendingRepair, isCancelled);</span>
<span class="fc" id="L1709">                antiCompactedSSTableCount += antiCompacted;</span>
            }
<span class="fc" id="L1711">        }</span>
<span class="fc" id="L1712">        String format = &quot;Anticompaction completed successfully, anticompacted from {} to {} sstable(s) for {}.&quot;;</span>
<span class="fc" id="L1713">        logger.info(format, originalCount, antiCompactedSSTableCount, pendingRepair);</span>
<span class="fc" id="L1714">    }</span>

    @VisibleForTesting
    int antiCompactGroup(ColumnFamilyStore cfs,
                         RangesAtEndpoint ranges,
                         LifecycleTransaction txn,
                         TimeUUID pendingRepair,
                         BooleanSupplier isCancelled)
    {
<span class="pc bpc" id="L1723" title="1 of 2 branches missed.">        Preconditions.checkArgument(!ranges.isEmpty(), &quot;need at least one full or transient range&quot;);</span>
<span class="fc" id="L1724">        long groupMaxDataAge = -1;</span>

<span class="fc bfc" id="L1726" title="All 2 branches covered.">        for (Iterator&lt;SSTableReader&gt; i = txn.originals().iterator(); i.hasNext();)</span>
        {
<span class="fc" id="L1728">            SSTableReader sstable = i.next();</span>
<span class="pc bpc" id="L1729" title="1 of 2 branches missed.">            if (groupMaxDataAge &lt; sstable.maxDataAge)</span>
<span class="fc" id="L1730">                groupMaxDataAge = sstable.maxDataAge;</span>
<span class="fc" id="L1731">        }</span>

<span class="pc bpc" id="L1733" title="1 of 2 branches missed.">        if (txn.originals().size() == 0)</span>
        {
<span class="nc" id="L1735">            logger.info(&quot;No valid anticompactions for this group, All sstables were compacted and are no longer available&quot;);</span>
<span class="nc" id="L1736">            return 0;</span>
        }

<span class="fc" id="L1739">        logger.info(&quot;Anticompacting {} in {}.{} for {}&quot;, txn.originals(), cfs.getKeyspaceName(), cfs.getTableName(), pendingRepair);</span>
<span class="fc" id="L1740">        Set&lt;SSTableReader&gt; sstableAsSet = txn.originals();</span>

<span class="fc" id="L1742">        File destination = cfs.getDirectories().getWriteableLocationAsFile(cfs.getExpectedCompactedFileSize(sstableAsSet, OperationType.ANTICOMPACTION));</span>
<span class="fc" id="L1743">        long nowInSec = FBUtilities.nowInSeconds();</span>
<span class="fc" id="L1744">        RateLimiter limiter = getRateLimiter();</span>

        /**
         * HACK WARNING
         *
         * We have multiple writers operating over the same Transaction, producing different sets of sstables that all
         * logically replace the transaction's originals.  The SSTableRewriter assumes it has exclusive control over
         * the transaction state, and this will lead to temporarily inconsistent sstable/tracker state if we do not
         * take special measures to avoid it.
         *
         * Specifically, if a number of rewriter have prepareToCommit() invoked in sequence, then two problematic things happen:
         *   1. The obsoleteOriginals() call of the first rewriter immediately remove the originals from the tracker, despite
         *      their having been only partially replaced.  To avoid this, we must either avoid obsoleteOriginals() or checkpoint()
         *   2. The LifecycleTransaction may only have prepareToCommit() invoked once, and this will checkpoint() also.
         *
         * Similarly commit() would finalise partially complete on-disk state.
         *
         * To avoid these problems, we introduce a SharedTxn that proxies all calls onto the underlying transaction
         * except prepareToCommit(), checkpoint(), obsoleteOriginals(), and commit().
         * We then invoke these methods directly once each of the rewriter has updated the transaction
         * with their share of replacements.
         *
         * Note that for the same essential reason we also explicitly disable early open.
         * By noop-ing checkpoint we avoid any of the problems with early open, but by continuing to explicitly
         * disable it we also prevent any of the extra associated work from being performed.
         */
        class SharedTxn extends WrappedLifecycleTransaction
        {
<span class="fc" id="L1772">            public SharedTxn(ILifecycleTransaction delegate) { super(delegate); }</span>
<span class="fc" id="L1773">            public Throwable commit(Throwable accumulate) { return accumulate; }</span>
<span class="fc" id="L1774">            public void prepareToCommit() {}</span>
<span class="fc" id="L1775">            public void checkpoint() {}</span>
<span class="fc" id="L1776">            public void obsoleteOriginals() {}</span>
<span class="fc" id="L1777">            public void close() {}</span>
        }

<span class="fc" id="L1780">        CompactionStrategyManager strategy = cfs.getCompactionStrategyManager();</span>
<span class="fc" id="L1781">        try (SharedTxn sharedTxn = new SharedTxn(txn);</span>
<span class="fc" id="L1782">             SSTableRewriter fullWriter = SSTableRewriter.constructWithoutEarlyOpening(sharedTxn, false, groupMaxDataAge);</span>
<span class="fc" id="L1783">             SSTableRewriter transWriter = SSTableRewriter.constructWithoutEarlyOpening(sharedTxn, false, groupMaxDataAge);</span>
<span class="fc" id="L1784">             SSTableRewriter unrepairedWriter = SSTableRewriter.constructWithoutEarlyOpening(sharedTxn, false, groupMaxDataAge);</span>

<span class="fc" id="L1786">             AbstractCompactionStrategy.ScannerList scanners = strategy.getScanners(txn.originals());</span>
<span class="fc" id="L1787">             CompactionController controller = new CompactionController(cfs, sstableAsSet, getDefaultGcBefore(cfs, nowInSec));</span>
<span class="fc" id="L1788">             CompactionIterator ci = getAntiCompactionIterator(scanners.scanners, controller, nowInSec, nextTimeUUID(), active, isCancelled))</span>
        {
<span class="fc" id="L1790">            int expectedBloomFilterSize = Math.max(cfs.metadata().params.minIndexInterval, (int)(SSTableReader.getApproximateKeyCount(sstableAsSet)));</span>

<span class="fc" id="L1792">            fullWriter.switchWriter(CompactionManager.createWriterForAntiCompaction(cfs, destination, expectedBloomFilterSize, UNREPAIRED_SSTABLE, pendingRepair, false, sstableAsSet, txn));</span>
<span class="fc" id="L1793">            transWriter.switchWriter(CompactionManager.createWriterForAntiCompaction(cfs, destination, expectedBloomFilterSize, UNREPAIRED_SSTABLE, pendingRepair, true, sstableAsSet, txn));</span>
<span class="fc" id="L1794">            unrepairedWriter.switchWriter(CompactionManager.createWriterForAntiCompaction(cfs, destination, expectedBloomFilterSize, UNREPAIRED_SSTABLE, NO_PENDING_REPAIR, false, sstableAsSet, txn));</span>

<span class="pc bpc" id="L1796" title="1 of 2 branches missed.">            Predicate&lt;Token&gt; fullChecker = !ranges.onlyFull().isEmpty() ? new Range.OrderedRangeContainmentChecker(ranges.onlyFull().ranges()) : t -&gt; false;</span>
<span class="pc bpc" id="L1797" title="1 of 2 branches missed.">            Predicate&lt;Token&gt; transChecker = !ranges.onlyTransient().isEmpty() ? new Range.OrderedRangeContainmentChecker(ranges.onlyTransient().ranges()) : t -&gt; false;</span>
<span class="fc" id="L1798">            double compressionRatio = scanners.getCompressionRatio();</span>
<span class="fc bfc" id="L1799" title="All 2 branches covered.">            if (compressionRatio == MetadataCollector.NO_COMPRESSION_RATIO)</span>
<span class="fc" id="L1800">                compressionRatio = 1.0;</span>

<span class="fc" id="L1802">            long lastBytesScanned = 0;</span>

<span class="fc bfc" id="L1804" title="All 2 branches covered.">            while (ci.hasNext())</span>
            {
<span class="fc" id="L1806">                try (UnfilteredRowIterator partition = ci.next())</span>
                {
<span class="fc" id="L1808">                    Token token = partition.partitionKey().getToken();</span>
                    // if this row is contained in the full or transient ranges, append it to the appropriate sstable
<span class="fc bfc" id="L1810" title="All 2 branches covered.">                    if (fullChecker.test(token))</span>
                    {
<span class="fc" id="L1812">                        fullWriter.append(partition);</span>
<span class="fc" id="L1813">                        ci.setTargetDirectory(fullWriter.currentWriter().getFilename());</span>
                    }
<span class="pc bpc" id="L1815" title="1 of 2 branches missed.">                    else if (transChecker.test(token))</span>
                    {
<span class="nc" id="L1817">                        transWriter.append(partition);</span>
<span class="nc" id="L1818">                        ci.setTargetDirectory(transWriter.currentWriter().getFilename());</span>
                    }
                    else
                    {
                        // otherwise, append it to the unrepaired sstable
<span class="fc" id="L1823">                        unrepairedWriter.append(partition);</span>
<span class="fc" id="L1824">                        ci.setTargetDirectory(unrepairedWriter.currentWriter().getFilename());</span>
                    }
<span class="fc" id="L1826">                    long bytesScanned = scanners.getTotalBytesScanned();</span>
<span class="fc" id="L1827">                    compactionRateLimiterAcquire(limiter, bytesScanned, lastBytesScanned, compressionRatio);</span>
<span class="fc" id="L1828">                    lastBytesScanned = bytesScanned;</span>
                }
            }

<span class="fc" id="L1832">            fullWriter.prepareToCommit();</span>
<span class="fc" id="L1833">            transWriter.prepareToCommit();</span>
<span class="fc" id="L1834">            unrepairedWriter.prepareToCommit();</span>
<span class="fc" id="L1835">            txn.checkpoint();</span>
<span class="fc" id="L1836">            txn.obsoleteOriginals();</span>
<span class="fc" id="L1837">            txn.prepareToCommit();</span>

<span class="fc" id="L1839">            List&lt;SSTableReader&gt; fullSSTables = new ArrayList&lt;&gt;(fullWriter.finished());</span>
<span class="fc" id="L1840">            List&lt;SSTableReader&gt; transSSTables = new ArrayList&lt;&gt;(transWriter.finished());</span>
<span class="fc" id="L1841">            List&lt;SSTableReader&gt; unrepairedSSTables = new ArrayList&lt;&gt;(unrepairedWriter.finished());</span>

<span class="fc" id="L1843">            fullWriter.commit();</span>
<span class="fc" id="L1844">            transWriter.commit();</span>
<span class="fc" id="L1845">            unrepairedWriter.commit();</span>
<span class="fc" id="L1846">            txn.commit();</span>
<span class="fc" id="L1847">            logger.info(&quot;Anticompacted {} in {}.{} to full = {}, transient = {}, unrepaired = {} for {}&quot;,</span>
                        sstableAsSet,
<span class="fc" id="L1849">                        cfs.getKeyspaceName(),</span>
<span class="fc" id="L1850">                        cfs.getTableName(),</span>
                        fullSSTables,
                        transSSTables,
                        unrepairedSSTables,
                        pendingRepair);
<span class="fc" id="L1855">            return fullSSTables.size() + transSSTables.size() + unrepairedSSTables.size();</span>
        }
<span class="nc" id="L1857">        catch (Throwable e)</span>
        {
<span class="nc bnc" id="L1859" title="All 2 branches missed.">            if (e instanceof CompactionInterruptedException)</span>
            {
<span class="nc bnc" id="L1861" title="All 2 branches missed.">                if (isCancelled.getAsBoolean())</span>
                {
<span class="nc" id="L1863">                    logger.info(&quot;Anticompaction has been canceled for session {}&quot;, pendingRepair);</span>
<span class="nc" id="L1864">                    logger.trace(e.getMessage(), e);</span>
                }
                else
                {
<span class="nc" id="L1868">                    logger.info(&quot;Anticompaction for session {} has been stopped by request.&quot;, pendingRepair);</span>
                }
            }
            else
            {
<span class="nc" id="L1873">                JVMStabilityInspector.inspectThrowable(e);</span>
<span class="nc" id="L1874">                logger.error(&quot;Error anticompacting &quot; + txn + &quot; for &quot; + pendingRepair, e);</span>
            }
<span class="nc" id="L1876">            throw e;</span>
        }
    }

    @VisibleForTesting
    public static CompactionIterator getAntiCompactionIterator(List&lt;ISSTableScanner&gt; scanners, CompactionController controller, long nowInSec, TimeUUID timeUUID, ActiveCompactionsTracker activeCompactions, BooleanSupplier isCancelled)
    {
<span class="fc" id="L1883">        return new CompactionIterator(OperationType.ANTICOMPACTION, scanners, controller, nowInSec, timeUUID, activeCompactions, null)</span>
<span class="fc" id="L1884">        {</span>
            public boolean isStopRequested()
            {
<span class="pc bpc" id="L1887" title="2 of 4 branches missed.">                return super.isStopRequested() || isCancelled.getAsBoolean();</span>
            }
        };
    }

    @VisibleForTesting
    Future&lt;?&gt; submitIndexBuild(final SecondaryIndexBuilder builder, ActiveCompactionsTracker activeCompactions)
    {
<span class="fc" id="L1895">        Runnable runnable = new Runnable()</span>
<span class="fc" id="L1896">        {</span>
            public void run()
            {
<span class="fc" id="L1899">                activeCompactions.beginCompaction(builder);</span>
                try
                {
<span class="fc" id="L1902">                    builder.build();</span>
                }
                finally
                {
<span class="fc" id="L1906">                    activeCompactions.finishCompaction(builder);</span>
                }
<span class="fc" id="L1908">            }</span>
        };

<span class="fc" id="L1911">        return secondaryIndexExecutor.submitIfRunning(runnable, &quot;index build&quot;);</span>
    }

    /**
     * Is not scheduled, because it is performing disjoint work from sstable compaction.
     */
    public Future&lt;?&gt; submitIndexBuild(final SecondaryIndexBuilder builder)
    {
<span class="fc" id="L1919">        return submitIndexBuild(builder, active);</span>
    }

    public Future&lt;?&gt; submitCacheWrite(final AutoSavingCache.Writer writer)
    {
<span class="fc" id="L1924">        return submitCacheWrite(writer, active);</span>
    }

    Future&lt;?&gt; submitCacheWrite(final AutoSavingCache.Writer writer, ActiveCompactionsTracker activeCompactions)
    {
<span class="fc" id="L1929">        Runnable runnable = new Runnable()</span>
<span class="fc" id="L1930">        {</span>
            public void run()
            {
<span class="pc bpc" id="L1933" title="1 of 2 branches missed.">                if (!AutoSavingCache.flushInProgress.add(writer.cacheType()))</span>
                {
<span class="nc" id="L1935">                    logger.trace(&quot;Cache flushing was already in progress: skipping {}&quot;, writer.getCompactionInfo());</span>
<span class="nc" id="L1936">                    return;</span>
                }
                try
                {
<span class="fc" id="L1940">                    activeCompactions.beginCompaction(writer);</span>
                    try
                    {
<span class="fc" id="L1943">                        writer.saveCache();</span>
                    }
                    finally
                    {
<span class="fc" id="L1947">                        activeCompactions.finishCompaction(writer);</span>
                    }
                }
                finally
                {
<span class="fc" id="L1952">                    AutoSavingCache.flushInProgress.remove(writer.cacheType());</span>
                }
<span class="fc" id="L1954">            }</span>
        };

<span class="fc" id="L1957">        return executor.submitIfRunning(runnable, &quot;cache write&quot;);</span>
    }

    public &lt;T, E extends Throwable&gt; T runAsActiveCompaction(Holder activeCompactionInfo, ThrowingSupplier&lt;T, E&gt; callable) throws E
    {
<span class="nc" id="L1962">        active.beginCompaction(activeCompactionInfo);</span>
        try
        {
<span class="nc" id="L1965">            return callable.get();</span>
        }
        finally
        {
<span class="nc" id="L1969">            active.finishCompaction(activeCompactionInfo);</span>
        }
    }

    public static long getDefaultGcBefore(ColumnFamilyStore cfs, long nowInSec)
    {
        // 2ndary indexes have ExpiringColumns too, so we need to purge tombstones deleted before now. We do not need to
        // add any GcGrace however since 2ndary indexes are local to a node.
<span class="fc bfc" id="L1977" title="All 2 branches covered.">        return cfs.isIndex() ? nowInSec : cfs.gcBefore(nowInSec);</span>
    }

    public Future&lt;Long&gt; submitViewBuilder(final ViewBuilderTask task)
    {
<span class="fc" id="L1982">        return submitViewBuilder(task, active);</span>
    }

    @VisibleForTesting
    Future&lt;Long&gt; submitViewBuilder(final ViewBuilderTask task, ActiveCompactionsTracker activeCompactions)
    {
<span class="fc" id="L1988">        return viewBuildExecutor.submitIfRunning(() -&gt; {</span>
<span class="fc" id="L1989">            activeCompactions.beginCompaction(task);</span>
            try
            {
<span class="fc" id="L1992">                return task.call();</span>
            }
            finally
            {
<span class="fc" id="L1996">                activeCompactions.finishCompaction(task);</span>
            }
        }, &quot;view build&quot;);
    }

    public int getActiveCompactions()
    {
<span class="fc" id="L2003">        return active.getCompactions().size();</span>
    }

    public static boolean isCompactor(Thread thread)
    {
<span class="nc bnc" id="L2008" title="All 2 branches missed.">        return thread.getThreadGroup().getParent() == compactionThreadGroup;</span>
    }

    // TODO: this is a bit ugly, but no uglier than it was
    static class CompactionExecutor extends WrappedExecutorPlus
    {
<span class="fc" id="L2014">        static final ThreadGroup compactionThreadGroup = executorFactory().newThreadGroup(&quot;compaction&quot;);</span>

        public CompactionExecutor()
        {
<span class="fc" id="L2018">            this(executorFactory(), getConcurrentCompactors(), &quot;CompactionExecutor&quot;, Integer.MAX_VALUE);</span>
<span class="fc" id="L2019">        }</span>

        public CompactionExecutor(int threads, String name, int queueSize)
        {
<span class="fc" id="L2023">            this(executorFactory(), threads, name, queueSize);</span>
<span class="fc" id="L2024">        }</span>

        protected CompactionExecutor(ExecutorFactory executorFactory, int threads, String name, int queueSize)
        {
<span class="fc" id="L2028">            super(executorFactory</span>
<span class="fc" id="L2029">                    .withJmxInternal()</span>
<span class="fc" id="L2030">                    .configurePooled(name, threads)</span>
<span class="fc" id="L2031">                    .withThreadGroup(compactionThreadGroup)</span>
<span class="fc" id="L2032">                    .withQueueLimit(queueSize).build());</span>
<span class="fc" id="L2033">        }</span>

        public Future&lt;Void&gt; submitIfRunning(Runnable task, String name)
        {
<span class="fc" id="L2037">            return submitIfRunning(callable(name, task), name);</span>
        }

        /**
         * Submit the task but only if the executor has not been shutdown.If the executor has
         * been shutdown, or in case of a rejected execution exception return a cancelled future.
         *
         * @param task - the task to submit
         * @param name - the task name to use in log messages
         *
         * @return the future that will deliver the task result, or a future that has already been
         *         cancelled if the task could not be submitted.
         */
        public &lt;T&gt; Future&lt;T&gt; submitIfRunning(Callable&lt;T&gt; task, String name)
        {
            try
            {
<span class="fc" id="L2054">                return submit(task);</span>
            }
<span class="nc" id="L2056">            catch (RejectedExecutionException ex)</span>
            {
<span class="nc bnc" id="L2058" title="All 2 branches missed.">                if (isShutdown())</span>
<span class="nc" id="L2059">                    logger.info(&quot;Executor has shut down, could not submit {}&quot;, name);</span>
                else
<span class="nc" id="L2061">                    logger.error(&quot;Failed to submit {}&quot;, name, ex);</span>

<span class="nc" id="L2063">                return ImmediateFuture.cancelled();</span>
            }
        }

        public void execute(Runnable command)
        {
<span class="nc" id="L2069">            executor.execute(command);</span>
<span class="nc" id="L2070">        }</span>

        public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)
        {
<span class="fc" id="L2074">            return executor.submit(task);</span>
        }

        public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)
        {
<span class="fc" id="L2079">            return submit(callable(task, result));</span>
        }

        public Future&lt;?&gt; submit(Runnable task)
        {
<span class="fc" id="L2084">            return submit(task, null);</span>
        }
    }

    // TODO: pull out relevant parts of CompactionExecutor and move to ValidationManager
    public static class ValidationExecutor extends CompactionExecutor
    {
        // CompactionExecutor, and by extension ValidationExecutor, use ExecutorPlus's
        // default RejectedExecutionHandler which blocks the submitting thread when the work queue is
        // full. The calling thread in this case is AntiEntropyStage, so in most cases we don't actually
        // want to block when the ValidationExecutor is saturated as this prevents progress on all
        // repair tasks and may cause repair sessions to time out. Also, it can lead to references to
        // heavyweight validation responses containing merkle trees being held for extended periods which
        // increases GC pressure. Using LinkedBlockingQueue instead of the default SynchronousQueue allows
        // tasks to be submitted without blocking the caller, but will always prefer queueing to creating
        // new threads if the pool already has at least `corePoolSize` threads already running. For this
        // reason we set corePoolSize to the maximum desired concurrency, but allow idle core threads to
        // be terminated.

        public ValidationExecutor()
        {
<span class="fc" id="L2105">            super(DatabaseDescriptor.getConcurrentValidations(),</span>
                  &quot;ValidationExecutor&quot;,
                  Integer.MAX_VALUE);
<span class="fc" id="L2108">        }</span>

        public void adjustPoolSize()
        {
<span class="nc" id="L2112">            setMaximumPoolSize(DatabaseDescriptor.getConcurrentValidations());</span>
<span class="nc" id="L2113">            setCorePoolSize(DatabaseDescriptor.getConcurrentValidations());</span>
<span class="nc" id="L2114">        }</span>
    }

    private static class ViewBuildExecutor extends CompactionExecutor
    {
        public ViewBuildExecutor()
        {
<span class="fc" id="L2121">            super(DatabaseDescriptor.getConcurrentViewBuilders(), &quot;ViewBuildExecutor&quot;, Integer.MAX_VALUE);</span>
<span class="fc" id="L2122">        }</span>
    }

    private static class CacheCleanupExecutor extends CompactionExecutor
    {
        public CacheCleanupExecutor()
        {
<span class="fc" id="L2129">            super(1, &quot;CacheCleanupExecutor&quot;, Integer.MAX_VALUE);</span>
<span class="fc" id="L2130">        }</span>
    }

    public void incrementAborted()
    {
<span class="nc" id="L2135">        metrics.compactionsAborted.inc();</span>
<span class="nc" id="L2136">    }</span>

    public void incrementCompactionsReduced()
    {
<span class="nc" id="L2140">        metrics.compactionsReduced.inc();</span>
<span class="nc" id="L2141">    }</span>

    public void incrementSstablesDropppedFromCompactions(long num)
    {
<span class="nc" id="L2145">        metrics.sstablesDropppedFromCompactions.inc(num);</span>
<span class="nc" id="L2146">    }</span>

    private static class SecondaryIndexExecutor extends CompactionExecutor
    {
        public SecondaryIndexExecutor()
        {
<span class="fc" id="L2152">            super(DatabaseDescriptor.getConcurrentIndexBuilders(), &quot;SecondaryIndexExecutor&quot;, Integer.MAX_VALUE);</span>
<span class="fc" id="L2153">        }</span>
    }

    public List&lt;Map&lt;String, String&gt;&gt; getCompactions()
    {
<span class="fc" id="L2158">        List&lt;Holder&gt; compactionHolders = active.getCompactions();</span>
<span class="fc" id="L2159">        List&lt;Map&lt;String, String&gt;&gt; out = new ArrayList&lt;Map&lt;String, String&gt;&gt;(compactionHolders.size());</span>
<span class="fc bfc" id="L2160" title="All 2 branches covered.">        for (CompactionInfo.Holder ci : compactionHolders)</span>
<span class="fc" id="L2161">            out.add(ci.getCompactionInfo().asMap());</span>
<span class="fc" id="L2162">        return out;</span>
    }

    public List&lt;String&gt; getCompactionSummary()
    {
<span class="fc" id="L2167">        List&lt;Holder&gt; compactionHolders = active.getCompactions();</span>
<span class="fc" id="L2168">        List&lt;String&gt; out = new ArrayList&lt;String&gt;(compactionHolders.size());</span>
<span class="fc bfc" id="L2169" title="All 2 branches covered.">        for (CompactionInfo.Holder ci : compactionHolders)</span>
<span class="fc" id="L2170">            out.add(ci.getCompactionInfo().toString());</span>
<span class="fc" id="L2171">        return out;</span>
    }

    public TabularData getCompactionHistory()
    {
        try
        {
<span class="nc" id="L2178">            return SystemKeyspace.getCompactionHistory();</span>
        }
<span class="nc" id="L2180">        catch (OpenDataException e)</span>
        {
<span class="nc" id="L2182">            throw new RuntimeException(e);</span>
        }
    }

    public long getTotalBytesCompacted()
    {
<span class="nc" id="L2188">        return metrics.bytesCompacted.getCount();</span>
    }

    public long getTotalCompactionsCompleted()
    {
<span class="nc" id="L2193">        return metrics.totalCompactionsCompleted.getCount();</span>
    }

    @Override
    public int getPendingTasks()
    {
<span class="fc" id="L2199">        return metrics.pendingTasks.getValue();</span>
    }

    public long getCompletedTasks()
    {
<span class="nc" id="L2204">        return metrics.completedTasks.getValue();</span>
    }

    public void stopCompaction(String type)
    {
<span class="fc" id="L2209">        OperationType operation = OperationType.valueOf(type);</span>
<span class="fc bfc" id="L2210" title="All 2 branches covered.">        for (Holder holder : active.getCompactions())</span>
        {
<span class="pc bpc" id="L2212" title="1 of 2 branches missed.">            if (holder.getCompactionInfo().getTaskType() == operation)</span>
<span class="fc" id="L2213">                holder.stop();</span>
<span class="fc" id="L2214">        }</span>
<span class="fc" id="L2215">    }</span>

    public void stopCompactionById(String compactionId)
    {
<span class="nc bnc" id="L2219" title="All 2 branches missed.">        for (Holder holder : active.getCompactions())</span>
        {
<span class="nc" id="L2221">            TimeUUID holderId = holder.getCompactionInfo().getTaskId();</span>
<span class="nc bnc" id="L2222" title="All 4 branches missed.">            if (holderId != null &amp;&amp; holderId.equals(TimeUUID.fromString(compactionId)))</span>
<span class="nc" id="L2223">                holder.stop();</span>
<span class="nc" id="L2224">        }</span>
<span class="nc" id="L2225">    }</span>

    public void setConcurrentCompactors(int value)
    {
<span class="nc bnc" id="L2229" title="All 2 branches missed.">        if (value &gt; executor.getCorePoolSize())</span>
        {
            // we are increasing the value
<span class="nc" id="L2232">            executor.setMaximumPoolSize(value);</span>
<span class="nc" id="L2233">            executor.setCorePoolSize(value);</span>
        }
<span class="nc bnc" id="L2235" title="All 2 branches missed.">        else if (value &lt; executor.getCorePoolSize())</span>
        {
            // we are reducing the value
<span class="nc" id="L2238">            executor.setCorePoolSize(value);</span>
<span class="nc" id="L2239">            executor.setMaximumPoolSize(value);</span>
        }
<span class="nc" id="L2241">    }</span>

    public void setConcurrentValidations()
    {
<span class="nc" id="L2245">        validationExecutor.adjustPoolSize();</span>
<span class="nc" id="L2246">    }</span>

    public void setConcurrentViewBuilders(int value)
    {
<span class="pc bpc" id="L2250" title="1 of 2 branches missed.">        if (value &gt; viewBuildExecutor.getCorePoolSize())</span>
        {
            // we are increasing the value
<span class="fc" id="L2253">            viewBuildExecutor.setMaximumPoolSize(value);</span>
<span class="fc" id="L2254">            viewBuildExecutor.setCorePoolSize(value);</span>
        }
<span class="nc bnc" id="L2256" title="All 2 branches missed.">        else if (value &lt; viewBuildExecutor.getCorePoolSize())</span>
        {
            // we are reducing the value
<span class="nc" id="L2259">            viewBuildExecutor.setCorePoolSize(value);</span>
<span class="nc" id="L2260">            viewBuildExecutor.setMaximumPoolSize(value);</span>
        }
<span class="fc" id="L2262">    }</span>

    public int getCoreCompactorThreads()
    {
<span class="nc" id="L2266">        return executor.getCorePoolSize();</span>
    }

    public void setCoreCompactorThreads(int number)
    {
<span class="nc" id="L2271">        executor.setCorePoolSize(number);</span>
<span class="nc" id="L2272">    }</span>

    public int getMaximumCompactorThreads()
    {
<span class="nc" id="L2276">        return executor.getMaximumPoolSize();</span>
    }

    public void setMaximumCompactorThreads(int number)
    {
<span class="nc" id="L2281">        executor.setMaximumPoolSize(number);</span>
<span class="nc" id="L2282">    }</span>

    public int getCoreValidationThreads()
    {
<span class="nc" id="L2286">        return validationExecutor.getCorePoolSize();</span>
    }

    public void setCoreValidationThreads(int number)
    {
<span class="nc" id="L2291">        validationExecutor.setCorePoolSize(number);</span>
<span class="nc" id="L2292">    }</span>

    public int getMaximumValidatorThreads()
    {
<span class="nc" id="L2296">        return validationExecutor.getMaximumPoolSize();</span>
    }

    public void setMaximumValidatorThreads(int number)
    {
<span class="nc" id="L2301">        validationExecutor.setMaximumPoolSize(number);</span>
<span class="nc" id="L2302">    }</span>

    public boolean getDisableSTCSInL0()
    {
<span class="nc" id="L2306">        return DatabaseDescriptor.getDisableSTCSInL0();</span>
    }

    public void setDisableSTCSInL0(boolean disabled)
    {
<span class="nc bnc" id="L2311" title="All 2 branches missed.">        if (disabled != DatabaseDescriptor.getDisableSTCSInL0())</span>
<span class="nc" id="L2312">            logger.info(&quot;Changing STCS in L0 disabled from {} to {}&quot;, DatabaseDescriptor.getDisableSTCSInL0(), disabled);</span>
<span class="nc" id="L2313">        DatabaseDescriptor.setDisableSTCSInL0(disabled);</span>
<span class="nc" id="L2314">    }</span>

    public int getCoreViewBuildThreads()
    {
<span class="nc" id="L2318">        return viewBuildExecutor.getCorePoolSize();</span>
    }

    public void setCoreViewBuildThreads(int number)
    {
<span class="nc" id="L2323">        viewBuildExecutor.setCorePoolSize(number);</span>
<span class="nc" id="L2324">    }</span>

    public int getMaximumViewBuildThreads()
    {
<span class="nc" id="L2328">        return viewBuildExecutor.getMaximumPoolSize();</span>
    }

    public void setMaximumViewBuildThreads(int number)
    {
<span class="nc" id="L2333">        viewBuildExecutor.setMaximumPoolSize(number);</span>
<span class="nc" id="L2334">    }</span>

    public boolean getAutomaticSSTableUpgradeEnabled()
    {
<span class="nc" id="L2338">        return DatabaseDescriptor.automaticSSTableUpgrade();</span>
    }

    public void setAutomaticSSTableUpgradeEnabled(boolean enabled)
    {
<span class="nc" id="L2343">        DatabaseDescriptor.setAutomaticSSTableUpgradeEnabled(enabled);</span>
<span class="nc" id="L2344">    }</span>

    public int getMaxConcurrentAutoUpgradeTasks()
    {
<span class="nc" id="L2348">        return DatabaseDescriptor.maxConcurrentAutoUpgradeTasks();</span>
    }

    public void setMaxConcurrentAutoUpgradeTasks(int value)
    {
        try
        {
<span class="nc" id="L2355">            DatabaseDescriptor.setMaxConcurrentAutoUpgradeTasks(value);</span>
        }
<span class="nc" id="L2357">        catch (ConfigurationException e)</span>
        {
<span class="nc" id="L2359">            throw new RuntimeException(e.getMessage());</span>
<span class="nc" id="L2360">        }</span>
<span class="nc" id="L2361">    }</span>

    public List&lt;Holder&gt; getCompactionsMatching(Iterable&lt;TableMetadata&gt; columnFamilies, Predicate&lt;CompactionInfo&gt; predicate)
    {
<span class="pc bpc" id="L2365" title="1 of 2 branches missed.">        Preconditions.checkArgument(columnFamilies != null, &quot;Attempted to getCompactionsMatching in CompactionManager with no columnFamilies specified.&quot;);</span>

<span class="fc" id="L2367">        List&lt;Holder&gt; matched = new ArrayList&lt;&gt;();</span>
        // consider all in-progress compactions
<span class="fc bfc" id="L2369" title="All 2 branches covered.">        for (Holder holder : active.getCompactions())</span>
        {
<span class="fc" id="L2371">            CompactionInfo info = holder.getCompactionInfo();</span>
<span class="pc bpc" id="L2372" title="2 of 4 branches missed.">            if (info.getTableMetadata() == null || Iterables.contains(columnFamilies, info.getTableMetadata()))</span>
            {
<span class="nc bnc" id="L2374" title="All 2 branches missed.">                if (predicate.test(info))</span>
<span class="nc" id="L2375">                    matched.add(holder);</span>
            }
<span class="fc" id="L2377">        }</span>
<span class="fc" id="L2378">        return matched;</span>
    }

    /**
     * Try to stop all of the compactions for given ColumnFamilies.
     *
     * Note that this method does not wait for all compactions to finish; you'll need to loop against
     * isCompacting if you want that behavior.
     *
     * @param columnFamilies The ColumnFamilies to try to stop compaction upon.
     * @param sstablePredicate the sstable predicate to match on
     * @param interruptValidation true if validation operations for repair should also be interrupted
     */
    public void interruptCompactionFor(Iterable&lt;TableMetadata&gt; columnFamilies, Predicate&lt;SSTableReader&gt; sstablePredicate, boolean interruptValidation)
    {
<span class="pc bpc" id="L2393" title="1 of 2 branches missed.">        assert columnFamilies != null;</span>

        // interrupt in-progress compactions
<span class="fc bfc" id="L2396" title="All 2 branches covered.">        for (Holder compactionHolder : active.getCompactions())</span>
        {
<span class="fc" id="L2398">            CompactionInfo info = compactionHolder.getCompactionInfo();</span>
<span class="pc bpc" id="L2399" title="3 of 4 branches missed.">            if ((info.getTaskType() == OperationType.VALIDATION) &amp;&amp; !interruptValidation)</span>
<span class="nc" id="L2400">                continue;</span>

<span class="pc bpc" id="L2402" title="2 of 4 branches missed.">            if (info.getTableMetadata() == null || Iterables.contains(columnFamilies, info.getTableMetadata()))</span>
            {
<span class="nc bnc" id="L2404" title="All 2 branches missed.">                if (info.shouldStop(sstablePredicate))</span>
<span class="nc" id="L2405">                    compactionHolder.stop();</span>
            }
<span class="fc" id="L2407">        }</span>
<span class="fc" id="L2408">    }</span>

    public void interruptCompactionForCFs(Iterable&lt;ColumnFamilyStore&gt; cfss, Predicate&lt;SSTableReader&gt; sstablePredicate, boolean interruptValidation)
    {
<span class="fc" id="L2412">        List&lt;TableMetadata&gt; metadata = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2413" title="All 2 branches covered.">        for (ColumnFamilyStore cfs : cfss)</span>
<span class="fc" id="L2414">            metadata.add(cfs.metadata());</span>

<span class="fc" id="L2416">        interruptCompactionFor(metadata, sstablePredicate, interruptValidation);</span>
<span class="fc" id="L2417">    }</span>

    public void waitForCessation(Iterable&lt;ColumnFamilyStore&gt; cfss, Predicate&lt;SSTableReader&gt; sstablePredicate)
    {
<span class="fc" id="L2421">        long start = nanoTime();</span>
<span class="fc" id="L2422">        long delay = TimeUnit.MINUTES.toNanos(1);</span>

<span class="pc bpc" id="L2424" title="1 of 2 branches missed.">        while (nanoTime() - start &lt; delay)</span>
        {
<span class="fc bfc" id="L2426" title="All 2 branches covered.">            if (CompactionManager.instance.isCompacting(cfss, sstablePredicate))</span>
<span class="fc" id="L2427">                Uninterruptibles.sleepUninterruptibly(1, TimeUnit.MILLISECONDS);</span>
            else
                break;
        }
<span class="fc" id="L2431">    }</span>


    public List&lt;CompactionInfo&gt; getSSTableTasks()
    {
<span class="nc" id="L2436">        return active.getCompactions()</span>
<span class="nc" id="L2437">                     .stream()</span>
<span class="nc" id="L2438">                     .map(CompactionInfo.Holder::getCompactionInfo)</span>
<span class="nc bnc" id="L2439" title="All 2 branches missed.">                     .filter(task -&gt; task.getTaskType() != OperationType.COUNTER_CACHE_SAVE</span>
<span class="nc bnc" id="L2440" title="All 2 branches missed.">                                     &amp;&amp; task.getTaskType() != OperationType.KEY_CACHE_SAVE</span>
<span class="nc bnc" id="L2441" title="All 2 branches missed.">                                     &amp;&amp; task.getTaskType() != OperationType.ROW_CACHE_SAVE)</span>
<span class="nc" id="L2442">                     .collect(Collectors.toList());</span>
    }

    /**
     * Return whether &quot;global&quot; compactions should be paused, used by ColumnFamilyStore#runWithCompactionsDisabled
     *
     * a global compaction is one that includes several/all tables, currently only IndexSummaryBuilder
     */
    public boolean isGlobalCompactionPaused()
    {
<span class="nc bnc" id="L2452" title="All 2 branches missed.">        return globalCompactionPauseCount.get() &gt; 0;</span>
    }

    public CompactionPauser pauseGlobalCompaction()
    {
<span class="fc" id="L2457">        CompactionPauser pauser = globalCompactionPauseCount::decrementAndGet;</span>
<span class="fc" id="L2458">        globalCompactionPauseCount.incrementAndGet();</span>
<span class="fc" id="L2459">        return pauser;</span>
    }

    public interface CompactionPauser extends AutoCloseable
    {
        public void close();
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>