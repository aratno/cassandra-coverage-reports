<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InboundConnectionInitiator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.net</a> &gt; <span class="el_source">InboundConnectionInitiator.java</span></div><h1>InboundConnectionInitiator.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.net;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.security.cert.Certificate;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.concurrent.Future;
import java.util.function.Consumer;

import com.google.common.annotations.VisibleForTesting;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.group.ChannelGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.handler.codec.ByteToMessageDecoder;
import io.netty.handler.logging.LogLevel;
import io.netty.handler.logging.LoggingHandler;
import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslHandler;
import org.apache.cassandra.auth.IInternodeAuthenticator;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.config.EncryptionOptions;
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.net.OutboundConnectionSettings.Framing;
import org.apache.cassandra.security.ISslContextFactory;
import org.apache.cassandra.security.SSLFactory;
import org.apache.cassandra.streaming.StreamDeserializingTask;
import org.apache.cassandra.streaming.StreamingChannel;
import org.apache.cassandra.streaming.async.NettyStreamingChannel;
import org.apache.cassandra.utils.memory.BufferPools;

import static java.lang.Math.*;
import static java.util.concurrent.TimeUnit.MILLISECONDS;
import static org.apache.cassandra.auth.IInternodeAuthenticator.InternodeConnectionDirection.INBOUND;
import static org.apache.cassandra.concurrent.ExecutorFactory.Global.executorFactory;
import static org.apache.cassandra.net.InternodeConnectionUtils.DISCARD_HANDLER_NAME;
import static org.apache.cassandra.net.InternodeConnectionUtils.SSL_FACTORY_CONTEXT_DESCRIPTION;
import static org.apache.cassandra.net.InternodeConnectionUtils.SSL_HANDLER_NAME;
import static org.apache.cassandra.net.InternodeConnectionUtils.certificates;
import static org.apache.cassandra.net.MessagingService.*;
import static org.apache.cassandra.net.SocketFactory.WIRETRACE;
import static org.apache.cassandra.net.SocketFactory.newSslHandler;

<span class="nc" id="L75">public class InboundConnectionInitiator</span>
{
<span class="fc" id="L77">    private static final Logger logger = LoggerFactory.getLogger(InboundConnectionInitiator.class);</span>

    private static class Initializer extends ChannelInitializer&lt;SocketChannel&gt;
    {
        private static final String PIPELINE_INTERNODE_ERROR_EXCLUSIONS = &quot;Internode Error Exclusions&quot;;

        private final InboundConnectionSettings settings;
        private final ChannelGroup channelGroup;
        private final Consumer&lt;ChannelPipeline&gt; pipelineInjector;

        Initializer(InboundConnectionSettings settings, ChannelGroup channelGroup,
                    Consumer&lt;ChannelPipeline&gt; pipelineInjector)
<span class="fc" id="L89">        {</span>
<span class="fc" id="L90">            this.settings = settings;</span>
<span class="fc" id="L91">            this.channelGroup = channelGroup;</span>
<span class="fc" id="L92">            this.pipelineInjector = pipelineInjector;</span>
<span class="fc" id="L93">        }</span>

        @Override
        public void initChannel(SocketChannel channel) throws Exception
        {
            // if any of the handlers added fail they will send the error to the &quot;head&quot;, so this needs to be first
<span class="fc" id="L99">            channel.pipeline().addFirst(PIPELINE_INTERNODE_ERROR_EXCLUSIONS, new InternodeErrorExclusionsHandler());</span>

<span class="fc" id="L101">            channelGroup.add(channel);</span>

<span class="fc" id="L103">            channel.config().setOption(ChannelOption.ALLOCATOR, GlobalBufferPoolAllocator.instance);</span>
<span class="fc" id="L104">            channel.config().setOption(ChannelOption.SO_KEEPALIVE, true);</span>
<span class="fc" id="L105">            channel.config().setOption(ChannelOption.SO_REUSEADDR, true);</span>
<span class="fc" id="L106">            channel.config().setOption(ChannelOption.TCP_NODELAY, true); // we only send handshake messages; no point ever delaying</span>

<span class="fc" id="L108">            ChannelPipeline pipeline = channel.pipeline();</span>

<span class="fc" id="L110">            pipelineInjector.accept(pipeline);</span>

            // order of handlers: ssl -&gt; client-authentication -&gt; logger -&gt; handshakeHandler
            // For either unencrypted or transitional modes, allow Ssl optionally.
<span class="pc bpc" id="L114" title="1 of 4 branches missed.">            switch(settings.encryption.tlsEncryptionPolicy())</span>
            {
                case UNENCRYPTED:
                    // Handler checks for SSL connection attempts and cleanly rejects them if encryption is disabled
<span class="fc" id="L118">                    pipeline.addAfter(PIPELINE_INTERNODE_ERROR_EXCLUSIONS, &quot;rejectssl&quot;, new RejectSslHandler());</span>
<span class="fc" id="L119">                    break;</span>
                case OPTIONAL:
<span class="fc" id="L121">                    pipeline.addAfter(PIPELINE_INTERNODE_ERROR_EXCLUSIONS, SSL_HANDLER_NAME, new OptionalSslHandler(settings.encryption));</span>
<span class="fc" id="L122">                    break;</span>
                case ENCRYPTED:
<span class="fc" id="L124">                    SslHandler sslHandler = getSslHandler(&quot;creating&quot;, channel, settings.encryption);</span>
<span class="fc" id="L125">                    pipeline.addAfter(PIPELINE_INTERNODE_ERROR_EXCLUSIONS, SSL_HANDLER_NAME, sslHandler);</span>
                    break;
            }

            // Pipeline for performing client authentication
<span class="fc" id="L130">            pipeline.addLast(&quot;client-authentication&quot;, new ClientAuthenticationHandler(settings.authenticator));</span>

            if (WIRETRACE)
                pipeline.addLast(&quot;logger&quot;, new LoggingHandler(LogLevel.INFO));

<span class="fc" id="L135">            channel.pipeline().addLast(&quot;handshake&quot;, new Handler(settings));</span>
<span class="fc" id="L136">        }</span>
    }

    private static class InternodeErrorExclusionsHandler extends ChannelInboundHandlerAdapter
    {
        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception
        {
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">            if (DatabaseDescriptor.getInternodeErrorReportingExclusions().contains(ctx.channel().remoteAddress()))</span>
            {
<span class="nc" id="L146">                logger.debug(&quot;Excluding internode exception for {}; address contained in internode_error_reporting_exclusions&quot;, ctx.channel().remoteAddress(), cause);</span>
<span class="nc" id="L147">                return;</span>
            }
<span class="fc" id="L149">            super.exceptionCaught(ctx, cause);</span>
<span class="fc" id="L150">        }</span>
    }

    /**
     * Create a {@link Channel} that listens on the {@code localAddr}. This method will block while trying to bind to the address,
     * but it does not make a remote call.
     */
    private static ChannelFuture bind(Initializer initializer) throws ConfigurationException
    {
<span class="fc" id="L159">        logger.info(&quot;Listening on {}&quot;, initializer.settings);</span>

<span class="fc" id="L161">        ServerBootstrap bootstrap = initializer.settings.socketFactory</span>
<span class="fc" id="L162">                                    .newServerBootstrap()</span>
<span class="fc" id="L163">                                    .option(ChannelOption.SO_BACKLOG, 1 &lt;&lt; 9)</span>
<span class="fc" id="L164">                                    .option(ChannelOption.ALLOCATOR, GlobalBufferPoolAllocator.instance)</span>
<span class="fc" id="L165">                                    .option(ChannelOption.SO_REUSEADDR, true)</span>
<span class="fc" id="L166">                                    .childHandler(initializer);</span>

<span class="fc" id="L168">        int socketReceiveBufferSizeInBytes = initializer.settings.socketReceiveBufferSizeInBytes;</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">        if (socketReceiveBufferSizeInBytes &gt; 0)</span>
<span class="nc" id="L170">            bootstrap.childOption(ChannelOption.SO_RCVBUF, socketReceiveBufferSizeInBytes);</span>

<span class="fc" id="L172">        InetAddressAndPort bind = initializer.settings.bindAddress;</span>
<span class="fc" id="L173">        ChannelFuture channelFuture = bootstrap.bind(new InetSocketAddress(bind.getAddress(), bind.getPort()));</span>

<span class="pc bpc" id="L175" title="1 of 2 branches missed.">        if (!channelFuture.awaitUninterruptibly().isSuccess())</span>
        {
<span class="nc bnc" id="L177" title="All 2 branches missed.">            if (channelFuture.channel().isOpen())</span>
<span class="nc" id="L178">                channelFuture.channel().close();</span>

<span class="nc" id="L180">            Throwable failedChannelCause = channelFuture.cause();</span>

<span class="nc" id="L182">            String causeString = &quot;&quot;;</span>
<span class="nc bnc" id="L183" title="All 4 branches missed.">            if (failedChannelCause != null &amp;&amp; failedChannelCause.getMessage() != null)</span>
<span class="nc" id="L184">                causeString = failedChannelCause.getMessage();</span>

<span class="nc bnc" id="L186" title="All 2 branches missed.">            if (causeString.contains(&quot;in use&quot;))</span>
            {
<span class="nc" id="L188">                throw new ConfigurationException(bind + &quot; is in use by another process.  Change listen_address:storage_port &quot; +</span>
                                                 &quot;in cassandra.yaml to values that do not conflict with other services&quot;);
            }
<span class="nc bnc" id="L191" title="All 2 branches missed.">            else if (causeString.contains(&quot;cannot assign requested address&quot;))</span>
            {
<span class="nc" id="L193">                throw new ConfigurationException(&quot;Unable to bind to address &quot; + bind</span>
                                                 + &quot;. Set listen_address in cassandra.yaml to an interface you can bind to, e.g., your private IP address on EC2&quot;);
            }
            else
            {
<span class="nc" id="L198">                throw new ConfigurationException(&quot;failed to bind to: &quot; + bind, failedChannelCause);</span>
            }
        }

<span class="fc" id="L202">        return channelFuture;</span>
    }

    public static ChannelFuture bind(InboundConnectionSettings settings, ChannelGroup channelGroup,
                                     Consumer&lt;ChannelPipeline&gt; pipelineInjector)
    {
<span class="fc" id="L208">        return bind(new Initializer(settings, channelGroup, pipelineInjector));</span>
    }

    /**
     * Handler to perform authentication for internode inbound connections.
     * This handler is called even before messaging handshake starts.
     */
    private static class ClientAuthenticationHandler extends ByteToMessageDecoder
    {
        private final IInternodeAuthenticator authenticator;

        public ClientAuthenticationHandler(IInternodeAuthenticator authenticator)
<span class="fc" id="L220">        {</span>
<span class="fc" id="L221">            this.authenticator = authenticator;</span>
<span class="fc" id="L222">        }</span>

        @Override
        protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list) throws Exception
        {
            // Extract certificates from SSL handler(handler with name &quot;ssl&quot;).
<span class="fc" id="L228">            final Certificate[] certificates = certificates(channelHandlerContext.channel());</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">            if (!authenticate(channelHandlerContext.channel().remoteAddress(), certificates))</span>
            {
<span class="nc" id="L231">                logger.error(&quot;Unable to authenticate peer {} for internode authentication&quot;, channelHandlerContext.channel());</span>

                // To release all the pending buffered data, replace authentication handler with discard handler.
                // This avoids pending inbound data to be fired through the pipeline
<span class="nc" id="L235">                channelHandlerContext.pipeline().replace(this, DISCARD_HANDLER_NAME, new InternodeConnectionUtils.ByteBufDiscardHandler());</span>
<span class="nc" id="L236">                channelHandlerContext.pipeline().close();</span>
            }
            else
            {
<span class="fc" id="L240">                channelHandlerContext.pipeline().remove(this);</span>
            }
<span class="fc" id="L242">        }</span>

        private boolean authenticate(SocketAddress socketAddress, final Certificate[] certificates) throws IOException
        {
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">            if (socketAddress.getClass().getSimpleName().equals(&quot;EmbeddedSocketAddress&quot;))</span>
<span class="nc" id="L247">                return true;</span>

<span class="pc bpc" id="L249" title="1 of 2 branches missed.">            if (!(socketAddress instanceof InetSocketAddress))</span>
<span class="nc" id="L250">                throw new IOException(String.format(&quot;Unexpected SocketAddress type: %s, %s&quot;, socketAddress.getClass(), socketAddress));</span>

<span class="fc" id="L252">            InetSocketAddress addr = (InetSocketAddress) socketAddress;</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">            if (!authenticator.authenticate(addr.getAddress(), addr.getPort(), certificates, INBOUND))</span>
            {
                // Log at info level as anything that can reach the inbound port could hit this
                // and trigger a log of noise.  Failed outbound connections to known cluster endpoints
                // still fail with an ERROR message and exception to alert operators that aren't watching logs closely.
<span class="nc" id="L258">                logger.info(&quot;Authenticate rejected inbound internode connection from {}&quot;, addr);</span>
<span class="nc" id="L259">                return false;</span>
            }
<span class="fc" id="L261">            return true;</span>
        }

    }

    /**
     * 'Server-side' component that negotiates the internode handshake when establishing a new connection.
     * This handler will be the first in the netty channel for each incoming connection (secure socket (TLS) notwithstanding),
     * and once the handshake is successful, it will configure the proper handlers ({@link InboundMessageHandler}
     * or {@link StreamingInboundHandler}) and remove itself from the working pipeline.
     */
<span class="fc" id="L272">    static class Handler extends ByteToMessageDecoder</span>
    {
        private final InboundConnectionSettings settings;

        private HandshakeProtocol.Initiate initiate;

        /**
         * A future the essentially places a timeout on how long we'll wait for the peer
         * to complete the next step of the handshake.
         */
        private Future&lt;?&gt; handshakeTimeout;

        Handler(InboundConnectionSettings settings)
<span class="fc" id="L285">        {</span>
<span class="fc" id="L286">            this.settings = settings;</span>
<span class="fc" id="L287">        }</span>

        /**
         * On registration, immediately schedule a timeout to kill this connection if it does not handshake promptly.
         */
        public void handlerAdded(ChannelHandlerContext ctx) throws Exception
        {
<span class="fc" id="L294">            handshakeTimeout = ctx.executor().schedule(() -&gt; {</span>
<span class="nc" id="L295">                logger.error(&quot;Timeout handshaking with {} (on {})&quot;, SocketFactory.addressId(initiate.from, (InetSocketAddress) ctx.channel().remoteAddress()), settings.bindAddress);</span>
<span class="nc" id="L296">                failHandshake(ctx);</span>
<span class="nc" id="L297">            }, HandshakeProtocol.TIMEOUT_MILLIS, MILLISECONDS);</span>
<span class="fc" id="L298">        }</span>

        @Override
        protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception
        {
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">            if (initiate == null) initiate(ctx, in);</span>
<span class="nc" id="L304">            else throw new IllegalStateException(&quot;Should no longer be on pipeline&quot;);</span>
<span class="fc" id="L305">        }</span>

        void initiate(ChannelHandlerContext ctx, ByteBuf in) throws IOException
        {
<span class="fc" id="L309">            initiate = HandshakeProtocol.Initiate.maybeDecode(in);</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">            if (initiate == null)</span>
<span class="nc" id="L311">                return;</span>

<span class="fc" id="L313">            logger.trace(&quot;Received handshake initiation message from peer {}, message = {}&quot;, ctx.channel().remoteAddress(), initiate);</span>

<span class="pc bpc" id="L315" title="1 of 4 branches missed.">            if (isEncryptionRequired(initiate.from) &amp;&amp; !isChannelEncrypted(ctx))</span>
            {
<span class="nc" id="L317">                logger.warn(&quot;peer {} attempted to establish an unencrypted connection (broadcast address {})&quot;,</span>
<span class="nc" id="L318">                            ctx.channel().remoteAddress(), initiate.from);</span>
<span class="nc" id="L319">                failHandshake(ctx);</span>
<span class="nc" id="L320">                return;</span>
            }

<span class="pc bpc" id="L323" title="1 of 2 branches missed.">            assert initiate.acceptVersions != null;</span>
<span class="fc" id="L324">            logger.trace(&quot;Connection version {} (min {}) from {}&quot;, initiate.acceptVersions.max, initiate.acceptVersions.min, initiate.from);</span>

            final AcceptVersions accept;

<span class="fc bfc" id="L328" title="All 2 branches covered.">            if (initiate.type.isStreaming())</span>
<span class="fc" id="L329">                accept = settings.acceptStreaming;</span>
            else
<span class="fc" id="L331">                accept = settings.acceptMessaging;</span>

<span class="fc" id="L333">            int useMessagingVersion = max(accept.min, min(accept.max, initiate.acceptVersions.max));</span>
<span class="fc" id="L334">            ByteBuf flush = new HandshakeProtocol.Accept(useMessagingVersion, accept.max).encode(ctx.alloc());</span>

<span class="fc" id="L336">            AsyncChannelPromise.writeAndFlush(ctx, flush, (ChannelFutureListener) future -&gt; {</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">                if (!future.isSuccess())</span>
<span class="nc" id="L338">                    exceptionCaught(future.channel(), future.cause());</span>
<span class="fc" id="L339">            });</span>

<span class="pc bpc" id="L341" title="1 of 2 branches missed.">            if (initiate.acceptVersions.min &gt; accept.max)</span>
            {
<span class="nc" id="L343">                logger.info(&quot;peer {} only supports messaging versions higher ({}) than this node supports ({})&quot;, ctx.channel().remoteAddress(), initiate.acceptVersions.min, current_version);</span>
<span class="nc" id="L344">                failHandshake(ctx);</span>
            }
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">            else if (initiate.acceptVersions.max &lt; accept.min)</span>
            {
<span class="nc" id="L348">                logger.info(&quot;peer {} only supports messaging versions lower ({}) than this node supports ({})&quot;, ctx.channel().remoteAddress(), initiate.acceptVersions.max, minimum_version);</span>
<span class="nc" id="L349">                failHandshake(ctx);</span>
            }
            else
            {
<span class="fc bfc" id="L353" title="All 2 branches covered.">                if (initiate.type.isStreaming())</span>
<span class="fc" id="L354">                    setupStreamingPipeline(initiate.from, ctx);</span>
                else
<span class="fc" id="L356">                    setupMessagingPipeline(initiate.from, useMessagingVersion, initiate.acceptVersions.max, ctx.pipeline());</span>
            }
<span class="fc" id="L358">        }</span>

        private boolean isEncryptionRequired(InetAddressAndPort peer)
        {
<span class="fc bfc" id="L362" title="All 4 branches covered.">            return !settings.encryption.isExplicitlyOptional() &amp;&amp; settings.encryption.shouldEncrypt(peer);</span>
        }

        private boolean isChannelEncrypted(ChannelHandlerContext ctx)
        {
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">            return ctx.pipeline().get(SslHandler.class) != null;</span>
        }

        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)
        {
<span class="fc" id="L373">            exceptionCaught(ctx.channel(), cause);</span>
<span class="fc" id="L374">        }</span>

        private void exceptionCaught(Channel channel, Throwable cause)
        {
<span class="fc" id="L378">            final SocketAddress remoteAddress = channel.remoteAddress();</span>
<span class="fc" id="L379">            boolean reportingExclusion = DatabaseDescriptor.getInternodeErrorReportingExclusions().contains(remoteAddress);</span>

<span class="pc bpc" id="L381" title="1 of 2 branches missed.">            if (reportingExclusion)</span>
<span class="nc" id="L382">                logger.debug(&quot;Excluding internode exception for {}; address contained in internode_error_reporting_exclusions&quot;, remoteAddress, cause);</span>
            else
<span class="fc" id="L384">                logger.error(&quot;Failed to properly handshake with peer {}. Closing the channel.&quot;, remoteAddress, cause);</span>

            try
            {
<span class="fc" id="L388">                failHandshake(channel);</span>
            }
<span class="nc" id="L390">            catch (Throwable t)</span>
            {
<span class="nc bnc" id="L392" title="All 2 branches missed.">                if (!reportingExclusion)</span>
<span class="nc" id="L393">                    logger.error(&quot;Unexpected exception in {}.exceptionCaught&quot;, this.getClass().getSimpleName(), t);</span>
<span class="fc" id="L394">            }</span>
<span class="fc" id="L395">        }</span>

        private void failHandshake(ChannelHandlerContext ctx)
        {
<span class="nc" id="L399">            failHandshake(ctx.channel());</span>
<span class="nc" id="L400">        }</span>

        private void failHandshake(Channel channel)
        {
            // Cancel the handshake timeout as early as possible as it calls this method
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">            if (handshakeTimeout != null)</span>
<span class="fc" id="L406">                handshakeTimeout.cancel(true);</span>

            // prevent further decoding of buffered data by removing this handler before closing
            // otherwise the pending bytes will be decoded again on close, throwing further exceptions.
            try
            {
<span class="fc" id="L412">                channel.pipeline().remove(this);</span>
            }
<span class="nc" id="L414">            catch (NoSuchElementException ex)</span>
            {
                // possible race with the handshake timeout firing and removing this handler already
            }
            finally
            {
<span class="fc" id="L420">                channel.close();</span>
            }
<span class="fc" id="L422">        }</span>

        private void setupStreamingPipeline(InetAddressAndPort from, ChannelHandlerContext ctx)
        {
<span class="fc" id="L426">            handshakeTimeout.cancel(true);</span>
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">            assert initiate.framing == Framing.UNPROTECTED;</span>

<span class="fc" id="L429">            ChannelPipeline pipeline = ctx.pipeline();</span>
<span class="fc" id="L430">            Channel channel = ctx.channel();</span>

<span class="pc bpc" id="L432" title="1 of 2 branches missed.">            if (from == null)</span>
            {
<span class="nc" id="L434">                InetSocketAddress address = (InetSocketAddress) channel.remoteAddress();</span>
<span class="nc" id="L435">                from = InetAddressAndPort.getByAddressOverrideDefaults(address.getAddress(), address.getPort());</span>
            }

<span class="fc" id="L438">            BufferPools.forNetworking().setRecycleWhenFreeForCurrentThread(false);</span>

            // we can't infer the type of streaming connection at this point,
            // so we use CONTROL unconditionally; it's ugly but does what we want
            // (establishes an AsyncStreamingInputPlus)
<span class="fc" id="L443">            NettyStreamingChannel streamingChannel = new NettyStreamingChannel(channel, StreamingChannel.Kind.CONTROL);</span>
<span class="fc" id="L444">            pipeline.replace(this, &quot;streamInbound&quot;, streamingChannel);</span>
<span class="fc" id="L445">            executorFactory().startThread(String.format(&quot;Stream-Deserializer-%s-%s&quot;, from, channel.id()),</span>
                                          new StreamDeserializingTask(null, streamingChannel, current_version));

<span class="fc" id="L448">            logger.info(&quot;{} streaming connection established, version = {}, framing = {}, encryption = {}&quot;,</span>
<span class="fc" id="L449">                        SocketFactory.channelId(from,</span>
<span class="fc" id="L450">                                                (InetSocketAddress) channel.remoteAddress(),</span>
                                                settings.bindAddress,
<span class="fc" id="L452">                                                (InetSocketAddress) channel.localAddress(),</span>
                                                ConnectionType.STREAMING,
<span class="fc" id="L454">                                                channel.id().asShortText()),</span>
<span class="fc" id="L455">                        current_version,</span>
                        initiate.framing,
<span class="fc" id="L457">                        SocketFactory.encryptionConnectionSummary(pipeline.channel()));</span>
<span class="fc" id="L458">        }</span>

        @VisibleForTesting
        void setupMessagingPipeline(InetAddressAndPort from, int useMessagingVersion, int maxMessagingVersion, ChannelPipeline pipeline)
        {
<span class="fc" id="L463">            handshakeTimeout.cancel(true);</span>
            // record the &quot;true&quot; endpoint, i.e. the one the peer is identified with, as opposed to the socket it connected over
<span class="fc" id="L465">            instance().versions.set(from, maxMessagingVersion);</span>

<span class="fc" id="L467">            BufferPools.forNetworking().setRecycleWhenFreeForCurrentThread(false);</span>
<span class="fc" id="L468">            BufferPoolAllocator allocator = GlobalBufferPoolAllocator.instance;</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">            if (initiate.type == ConnectionType.LARGE_MESSAGES)</span>
            {
                // for large messages, swap the global pool allocator for a local one, to optimise utilisation of chunks
<span class="fc" id="L472">                allocator = new LocalBufferPoolAllocator(pipeline.channel().eventLoop());</span>
<span class="fc" id="L473">                pipeline.channel().config().setAllocator(allocator);</span>
            }

            FrameDecoder frameDecoder;
<span class="pc bpc" id="L477" title="2 of 4 branches missed.">            switch (initiate.framing)</span>
            {
                case LZ4:
                {
<span class="fc" id="L481">                    frameDecoder = FrameDecoderLZ4.fast(allocator);</span>
<span class="fc" id="L482">                    break;</span>
                }
                case CRC:
                {
<span class="fc" id="L486">                    frameDecoder = FrameDecoderCrc.create(allocator);</span>
<span class="fc" id="L487">                    break;</span>
                }
                case UNPROTECTED:
                {
<span class="nc" id="L491">                    frameDecoder = new FrameDecoderUnprotected(allocator);</span>
<span class="nc" id="L492">                    break;</span>
                }
                default:
<span class="nc" id="L495">                    throw new AssertionError();</span>
            }

<span class="fc" id="L498">            frameDecoder.addLastTo(pipeline);</span>

<span class="fc" id="L500">            InboundMessageHandler handler =</span>
<span class="fc" id="L501">                settings.handlers.apply(from).createHandler(frameDecoder, initiate.type, pipeline.channel(), useMessagingVersion);</span>

<span class="fc" id="L503">            logger.info(&quot;{} messaging connection established, version = {}, framing = {}, encryption = {}&quot;,</span>
<span class="fc" id="L504">                        handler.id(true),</span>
<span class="fc" id="L505">                        useMessagingVersion,</span>
                        initiate.framing,
<span class="fc" id="L507">                        SocketFactory.encryptionConnectionSummary(pipeline.channel()));</span>

<span class="fc" id="L509">            pipeline.addLast(&quot;deserialize&quot;, handler);</span>

            try
            {
<span class="fc" id="L513">                pipeline.remove(this);</span>
            }
<span class="nc" id="L515">            catch (NoSuchElementException ex)</span>
            {
                // possible race with the handshake timeout firing and removing this handler already
<span class="fc" id="L518">            }</span>
<span class="fc" id="L519">        }</span>
    }

    private static SslHandler getSslHandler(String description, Channel channel, EncryptionOptions.ServerEncryptionOptions encryptionOptions) throws IOException
    {
<span class="fc" id="L524">        final boolean verifyPeerCertificate = true;</span>
<span class="fc" id="L525">        SslContext sslContext = SSLFactory.getOrCreateSslContext(encryptionOptions, verifyPeerCertificate,</span>
                                                                 ISslContextFactory.SocketType.SERVER,
                                                                 SSL_FACTORY_CONTEXT_DESCRIPTION);
<span class="fc bfc" id="L528" title="All 2 branches covered.">        InetSocketAddress peer = encryptionOptions.require_endpoint_verification ? (InetSocketAddress) channel.remoteAddress() : null;</span>
<span class="fc" id="L529">        SslHandler sslHandler = newSslHandler(channel, sslContext, peer);</span>
<span class="fc" id="L530">        logger.trace(&quot;{} inbound netty SslContext: context={}, engine={}&quot;, description, sslContext.getClass().getName(), sslHandler.engine().getClass().getName());</span>
<span class="fc" id="L531">        return sslHandler;</span>
    }

    private static class OptionalSslHandler extends ByteToMessageDecoder
    {
        private final EncryptionOptions.ServerEncryptionOptions encryptionOptions;

        OptionalSslHandler(EncryptionOptions.ServerEncryptionOptions encryptionOptions)
<span class="fc" id="L539">        {</span>
<span class="fc" id="L540">            this.encryptionOptions = encryptionOptions;</span>
<span class="fc" id="L541">        }</span>

        protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception
        {
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">            if (in.readableBytes() &lt; 5)</span>
            {
                // To detect if SSL must be used we need to have at least 5 bytes, so return here and try again
                // once more bytes a ready.
<span class="nc" id="L549">                return;</span>
            }

<span class="fc bfc" id="L552" title="All 2 branches covered.">            if (SslHandler.isEncrypted(in))</span>
            {
                // Connection uses SSL/TLS, replace the detection handler with a SslHandler and so use encryption.
<span class="fc" id="L555">                SslHandler sslHandler = getSslHandler(&quot;replacing optional&quot;, ctx.channel(), encryptionOptions);</span>
<span class="fc" id="L556">                ctx.pipeline().replace(this, SSL_HANDLER_NAME, sslHandler);</span>
<span class="fc" id="L557">            }</span>
            else
            {
                // Connection use no TLS/SSL encryption, just remove the detection handler and continue without
                // SslHandler in the pipeline.
<span class="fc" id="L562">                ctx.pipeline().remove(this);</span>
            }
<span class="fc" id="L564">        }</span>
    }

    private static class RejectSslHandler extends ByteToMessageDecoder
    {
        protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)
        {
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">            if (in.readableBytes() &lt; 5)</span>
            {
                // To detect if SSL must be used we need to have at least 5 bytes, so return here and try again
                // once more bytes a ready.
<span class="nc" id="L575">                return;</span>
            }

<span class="pc bpc" id="L578" title="1 of 2 branches missed.">            if (SslHandler.isEncrypted(in))</span>
            {
<span class="nc" id="L580">                logger.info(&quot;Rejected incoming TLS connection before negotiating from {} to {}. TLS is explicitly disabled by configuration.&quot;,</span>
<span class="nc" id="L581">                            ctx.channel().remoteAddress(), ctx.channel().localAddress());</span>
<span class="nc" id="L582">                in.readBytes(in.readableBytes()); // discard the readable bytes so not called again</span>
<span class="nc" id="L583">                ctx.close();</span>
            }
            else
            {
                // Incoming connection did not attempt TLS/SSL encryption, just remove the detection handler and continue without
                // SslHandler in the pipeline.
<span class="fc" id="L589">                ctx.pipeline().remove(this);</span>
            }
<span class="fc" id="L591">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>