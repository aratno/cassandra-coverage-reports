<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Splitter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.dht</a> &gt; <span class="el_source">Splitter.java</span></div><h1>Splitter.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.dht;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Sets;

import static java.util.stream.Collectors.toSet;

/**
 * Partition splitter.
 */
<span class="fc" id="L39">public abstract class Splitter</span>
{
    private final IPartitioner partitioner;

    protected Splitter(IPartitioner partitioner)
<span class="fc" id="L44">    {</span>
<span class="fc" id="L45">        this.partitioner = partitioner;</span>
<span class="fc" id="L46">    }</span>

    @VisibleForTesting
    protected abstract Token tokenForValue(BigInteger value);

    @VisibleForTesting
    protected abstract BigInteger valueForToken(Token token);

    @VisibleForTesting
    protected BigInteger tokensInRange(Range&lt;Token&gt; range)
    {
        //full range case
<span class="pc bpc" id="L58" title="1 of 2 branches missed.">        if (range.left.equals(range.right))</span>
<span class="nc" id="L59">            return tokensInRange(new Range(partitioner.getMinimumToken(), partitioner.getMaximumToken()));</span>

<span class="fc" id="L61">        BigInteger totalTokens = BigInteger.ZERO;</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">        for (Range&lt;Token&gt; unwrapped : range.unwrap())</span>
        {
<span class="fc" id="L64">            totalTokens = totalTokens.add(valueForToken(token(unwrapped.right)).subtract(valueForToken(unwrapped.left))).abs();</span>
<span class="fc" id="L65">        }</span>
<span class="fc" id="L66">        return totalTokens;</span>
    }

    /**
     * Computes the number of elapsed tokens from the range start until this token
     * @return the number of tokens from the range start to the token
     */
    @VisibleForTesting
    protected BigInteger elapsedTokens(Token token, Range&lt;Token&gt; range)
    {
        // No token elapsed since range does not contain token
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">        if (!range.contains(token))</span>
<span class="nc" id="L78">            return BigInteger.ZERO;</span>

<span class="fc" id="L80">        BigInteger elapsedTokens = BigInteger.ZERO;</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">        for (Range&lt;Token&gt; unwrapped : range.unwrap())</span>
        {
<span class="fc bfc" id="L83" title="All 2 branches covered.">            if (unwrapped.contains(token))</span>
            {
<span class="fc" id="L85">                elapsedTokens = elapsedTokens.add(tokensInRange(new Range&lt;&gt;(unwrapped.left, token)));</span>
            }
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">            else if (token.compareTo(unwrapped.left) &lt; 0)</span>
            {
<span class="nc" id="L89">                elapsedTokens = elapsedTokens.add(tokensInRange(unwrapped));</span>
            }
<span class="fc" id="L91">        }</span>
<span class="fc" id="L92">        return elapsedTokens;</span>
    }

    /**
     * Computes the normalized position of this token relative to this range
     * @return A number between 0.0 and 1.0 representing this token's position
     * in this range or -1.0 if this range doesn't contain this token.
     */
    public double positionInRange(Token token, Range&lt;Token&gt; range)
    {
        //full range case
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">        if (range.left.equals(range.right))</span>
<span class="nc" id="L104">            return positionInRange(token, new Range(partitioner.getMinimumToken(), partitioner.getMaximumToken()));</span>

        // leftmost token means we are on position 0.0
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">        if (token.equals(range.left))</span>
<span class="nc" id="L108">            return 0.0;</span>

        // rightmost token means we are on position 1.0
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">        if (token.equals(range.right))</span>
<span class="nc" id="L112">            return 1.0;</span>

        // Impossible to find position when token is not contained in range
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">        if (!range.contains(token))</span>
<span class="nc" id="L116">            return -1.0;</span>

<span class="fc" id="L118">        return new BigDecimal(elapsedTokens(token, range)).divide(new BigDecimal(tokensInRange(range)), 3, BigDecimal.ROUND_HALF_EVEN).doubleValue();</span>
    }

    public List&lt;Token&gt; splitOwnedRanges(int parts, List&lt;WeightedRange&gt; weightedRanges, boolean dontSplitRanges)
    {
<span class="pc bpc" id="L123" title="1 of 4 branches missed.">        if (weightedRanges.isEmpty() || parts == 1)</span>
<span class="fc" id="L124">            return Collections.singletonList(partitioner.getMaximumToken());</span>

<span class="fc" id="L126">        BigInteger totalTokens = BigInteger.ZERO;</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">        for (WeightedRange weightedRange : weightedRanges)</span>
        {
<span class="fc" id="L129">            totalTokens = totalTokens.add(weightedRange.totalTokens(this));</span>
<span class="fc" id="L130">        }</span>

<span class="fc" id="L132">        BigInteger perPart = totalTokens.divide(BigInteger.valueOf(parts));</span>
        // the range owned is so tiny we can't split it:
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (perPart.equals(BigInteger.ZERO))</span>
<span class="nc" id="L135">            return Collections.singletonList(partitioner.getMaximumToken());</span>

<span class="fc bfc" id="L137" title="All 2 branches covered.">        if (dontSplitRanges)</span>
<span class="fc" id="L138">            return splitOwnedRangesNoPartialRanges(weightedRanges, perPart, parts);</span>

<span class="fc" id="L140">        List&lt;Token&gt; boundaries = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L141">        BigInteger sum = BigInteger.ZERO;</span>
<span class="fc" id="L142">        BigInteger tokensLeft = totalTokens;</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">        for (WeightedRange weightedRange : weightedRanges)</span>
        {
<span class="fc" id="L145">            BigInteger currentRangeWidth = weightedRange.totalTokens(this);</span>
<span class="fc" id="L146">            BigInteger left = valueForToken(weightedRange.left());</span>
<span class="fc" id="L147">            BigInteger currentRangeFactor = BigInteger.valueOf(Math.max(1, (long) (1 / weightedRange.weight)));</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">            while (sum.add(currentRangeWidth).compareTo(perPart) &gt;= 0)</span>
            {
<span class="fc" id="L150">                BigInteger withinRangeBoundary = perPart.subtract(sum);</span>
<span class="fc" id="L151">                left = left.add(withinRangeBoundary.multiply(currentRangeFactor));</span>
<span class="fc" id="L152">                boundaries.add(tokenForValue(left));</span>
<span class="fc" id="L153">                tokensLeft = tokensLeft.subtract(perPart);</span>
<span class="fc" id="L154">                currentRangeWidth = currentRangeWidth.subtract(withinRangeBoundary);</span>
<span class="fc" id="L155">                sum = BigInteger.ZERO;</span>
<span class="fc" id="L156">                int partsLeft = parts - boundaries.size();</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">                if (partsLeft == 0)</span>
<span class="fc" id="L158">                    break;</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">                else if (partsLeft == 1)</span>
<span class="fc" id="L160">                    perPart = tokensLeft;</span>
<span class="fc" id="L161">            }</span>
<span class="fc" id="L162">            sum = sum.add(currentRangeWidth);</span>
<span class="fc" id="L163">        }</span>
<span class="fc" id="L164">        boundaries.set(boundaries.size() - 1, partitioner.getMaximumToken());</span>

<span class="pc bpc" id="L166" title="1 of 2 branches missed.">        assert boundaries.size() == parts : boundaries.size() + &quot;!=&quot; + parts + &quot; &quot; + boundaries + &quot;:&quot; + weightedRanges;</span>
<span class="fc" id="L167">        return boundaries;</span>
    }

    private List&lt;Token&gt; splitOwnedRangesNoPartialRanges(List&lt;WeightedRange&gt; weightedRanges, BigInteger perPart, int parts)
    {
<span class="fc" id="L172">        List&lt;Token&gt; boundaries = new ArrayList&lt;&gt;(parts);</span>
<span class="fc" id="L173">        BigInteger sum = BigInteger.ZERO;</span>

<span class="fc" id="L175">        int i = 0;</span>
<span class="fc" id="L176">        final int rangesCount = weightedRanges.size();</span>
<span class="fc bfc" id="L177" title="All 4 branches covered.">        while (boundaries.size() &lt; parts - 1 &amp;&amp; i &lt; rangesCount - 1)</span>
        {
<span class="fc" id="L179">            WeightedRange r = weightedRanges.get(i);</span>
<span class="fc" id="L180">            WeightedRange nextRange = weightedRanges.get(i + 1);</span>

<span class="fc" id="L182">            BigInteger currentRangeWidth = r.totalTokens(this);</span>
<span class="fc" id="L183">            BigInteger nextRangeWidth = nextRange.totalTokens(this);</span>
<span class="fc" id="L184">            sum = sum.add(currentRangeWidth);</span>

            // does this or next range take us beyond the per part limit?
<span class="fc bfc" id="L187" title="All 4 branches covered.">            if (sum.compareTo(perPart) &gt; 0 || sum.add(nextRangeWidth).compareTo(perPart) &gt; 0)</span>
            {
                // Either this or the next range will take us beyond the perPart limit. Will stopping now or
                // adding the next range create the smallest difference to perPart?
<span class="fc" id="L191">                BigInteger diffCurrent = sum.subtract(perPart).abs();</span>
<span class="fc" id="L192">                BigInteger diffNext = sum.add(nextRangeWidth).subtract(perPart).abs();</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">                if (diffNext.compareTo(diffCurrent) &gt;= 0)</span>
                {
<span class="fc" id="L195">                    sum = BigInteger.ZERO;</span>
<span class="fc" id="L196">                    boundaries.add(token(r.right()));</span>
                }
            }
<span class="fc" id="L199">            i++;</span>
<span class="fc" id="L200">        }</span>
<span class="fc" id="L201">        boundaries.add(partitioner.getMaximumToken());</span>
<span class="fc" id="L202">        return boundaries;</span>
    }

    /**
     * We avoid calculating for wrap around ranges, instead we use the actual max token, and then, when translating
     * to PartitionPositions, we include tokens from .minKeyBound to .maxKeyBound to make sure we include all tokens.
     */
    private Token token(Token t)
    {
<span class="fc bfc" id="L211" title="All 2 branches covered.">        return t.equals(partitioner.getMinimumToken()) ? partitioner.getMaximumToken() : t;</span>
    }

    /**
     * Splits the specified token ranges in at least {@code parts} subranges.
     * &lt;p&gt;
     * Each returned subrange will be contained in exactly one of the specified ranges.
     *
     * @param ranges a collection of token ranges to be split
     * @param parts the minimum number of returned ranges
     * @return at least {@code minParts} token ranges covering {@code ranges}
     */
    public Set&lt;Range&lt;Token&gt;&gt; split(Collection&lt;Range&lt;Token&gt;&gt; ranges, int parts)
    {
<span class="fc" id="L225">        int numRanges = ranges.size();</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">        if (numRanges &gt;= parts)</span>
        {
<span class="fc" id="L228">            return Sets.newHashSet(ranges);</span>
        }
        else
        {
<span class="fc" id="L232">            int partsPerRange = (int) Math.ceil((double) parts / numRanges);</span>
<span class="fc" id="L233">            return ranges.stream()</span>
<span class="fc" id="L234">                         .map(range -&gt; split(range, partsPerRange))</span>
<span class="fc" id="L235">                         .flatMap(Collection::stream)</span>
<span class="fc" id="L236">                         .collect(toSet());</span>
        }
    }

    /**
     * Splits the specified token range in at least {@code minParts} subranges, unless the range has not enough tokens
     * in which case the range will be returned without splitting.
     *
     * @param range a token range
     * @param parts the number of subranges
     * @return {@code parts} even subranges of {@code range}
     */
    private Set&lt;Range&lt;Token&gt;&gt; split(Range&lt;Token&gt; range, int parts)
    {
        // the range might not have enough tokens to split
<span class="fc" id="L251">        BigInteger numTokens = tokensInRange(range);</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">        if (BigInteger.valueOf(parts).compareTo(numTokens) &gt; 0)</span>
<span class="nc" id="L253">            return Collections.singleton(range);</span>

<span class="fc" id="L255">        Token left = range.left;</span>
<span class="fc" id="L256">        Set&lt;Range&lt;Token&gt;&gt; subranges = new HashSet&lt;&gt;(parts);</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">        for (double i = 1; i &lt;= parts; i++)</span>
        {
<span class="fc" id="L259">            Token right = partitioner.split(range.left, range.right, i / parts);</span>
<span class="fc" id="L260">            subranges.add(new Range&lt;&gt;(left, right));</span>
<span class="fc" id="L261">            left = right;</span>
        }
<span class="fc" id="L263">        return subranges;</span>
    }

    public static class WeightedRange
    {
        private final double weight;
        private final Range&lt;Token&gt; range;

        public WeightedRange(double weight, Range&lt;Token&gt; range)
<span class="fc" id="L272">        {</span>
<span class="fc" id="L273">            this.weight = weight;</span>
<span class="fc" id="L274">            this.range = range;</span>
<span class="fc" id="L275">        }</span>

        public BigInteger totalTokens(Splitter splitter)
        {
<span class="fc" id="L279">            BigInteger right = splitter.valueForToken(splitter.token(range.right));</span>
<span class="fc" id="L280">            BigInteger left = splitter.valueForToken(range.left);</span>
<span class="fc" id="L281">            BigInteger factor = BigInteger.valueOf(Math.max(1, (long) (1 / weight)));</span>
<span class="fc" id="L282">            BigInteger size = right.subtract(left);</span>
<span class="fc" id="L283">            return size.abs().divide(factor);</span>
        }

        /**
         * A less precise version of the above, returning the size of the span as a double approximation.
         */
        public double size()
        {
<span class="nc" id="L291">            return left().size(right()) * weight;</span>
        }

        public Token left()
        {
<span class="fc" id="L296">            return range.left;</span>
        }

        public Token right()
        {
<span class="fc" id="L301">            return range.right;</span>
        }

        public Range&lt;Token&gt; range()
        {
<span class="nc" id="L306">            return range;</span>
        }

        public double weight()
        {
<span class="nc" id="L311">            return weight;</span>
        }

        public String toString()
        {
<span class="nc" id="L316">            return &quot;WeightedRange{&quot; +</span>
                   &quot;weight=&quot; + weight +
                   &quot;, range=&quot; + range +
                   '}';
        }

        public boolean equals(Object o)
        {
<span class="nc bnc" id="L324" title="All 2 branches missed.">            if (this == o) return true;</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">            if (!(o instanceof WeightedRange)) return false;</span>
<span class="nc" id="L326">            WeightedRange that = (WeightedRange) o;</span>
<span class="nc" id="L327">            return Objects.equals(range, that.range);</span>
        }

        public int hashCode()
        {
<span class="nc" id="L332">            return Objects.hash(weight, range);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>