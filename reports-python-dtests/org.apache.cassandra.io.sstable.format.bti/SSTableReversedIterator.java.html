<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SSTableReversedIterator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.io.sstable.format.bti</a> &gt; <span class="el_source">SSTableReversedIterator.java</span></div><h1>SSTableReversedIterator.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.io.sstable.format.bti;

import java.io.IOException;
import java.util.NoSuchElementException;

import com.carrotsearch.hppc.LongStack;
import org.apache.cassandra.db.ClusteringBound;
import org.apache.cassandra.db.ClusteringComparator;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.Slice;
import org.apache.cassandra.db.Slices;
import org.apache.cassandra.db.UnfilteredValidation;
import org.apache.cassandra.db.filter.ColumnFilter;
import org.apache.cassandra.db.rows.RangeTombstoneBoundMarker;
import org.apache.cassandra.db.rows.RangeTombstoneMarker;
import org.apache.cassandra.db.rows.Unfiltered;
import org.apache.cassandra.io.sstable.AbstractRowIndexEntry;
import org.apache.cassandra.io.sstable.AbstractSSTableIterator;
import org.apache.cassandra.io.sstable.format.Version;
import org.apache.cassandra.io.sstable.format.bti.RowIndexReader.IndexInfo;
import org.apache.cassandra.io.util.FileDataInput;
import org.apache.cassandra.io.util.FileHandle;

/**
 * Unfiltered row iterator over a BTI SSTable that returns rows in reverse order.
 */
class SSTableReversedIterator extends AbstractSSTableIterator&lt;TrieIndexEntry&gt;
{
    /**
     * The index of the slice being processed.
     */
    private int slice;

    public SSTableReversedIterator(BtiTableReader sstable,
                                   FileDataInput file,
                                   DecoratedKey key,
                                   TrieIndexEntry indexEntry,
                                   Slices slices,
                                   ColumnFilter columns,
                                   FileHandle ifile)
    {
<span class="nc" id="L59">        super(sstable, file, key, indexEntry, slices, columns, ifile);</span>
<span class="nc" id="L60">    }</span>

    protected Reader createReaderInternal(TrieIndexEntry indexEntry, FileDataInput file, boolean shouldCloseFile, Version version)
    {
<span class="nc bnc" id="L64" title="All 2 branches missed.">        if (indexEntry.isIndexed())</span>
<span class="nc" id="L65">            return new ReverseIndexedReader(indexEntry, file, shouldCloseFile);</span>
        else
<span class="nc" id="L67">            return new ReverseReader(file, shouldCloseFile);</span>
    }

    public boolean isReverseOrder()
    {
<span class="nc" id="L72">        return true;</span>
    }

    protected int nextSliceIndex()
    {
<span class="nc" id="L77">        int next = slice;</span>
<span class="nc" id="L78">        slice++;</span>
<span class="nc" id="L79">        return slices.size() - (next + 1);</span>
    }

    protected boolean hasMoreSlices()
    {
<span class="nc bnc" id="L84" title="All 2 branches missed.">        return slice &lt; slices.size();</span>
    }

    /**
     * Reverse iteration is performed by going through an index block (or the whole partition if not indexed) forwards
     * and storing the positions of each entry that falls within the slice in a stack. Reverse iteration then pops out
     * positions and reads the entries.
     * &lt;p&gt;
     * Note: The earlier version of this was constructing an in-memory view of the block instead, which gives better
     * performance on bigger queries and index blocks (due to not having to read disk again). With the lower
     * granularity of the tries it makes better sense to store as little as possible as the beginning of the block
     * should very rarely be in other page/chunk cache locations. This has the benefit of being able to answer small
     * queries (esp. LIMIT 1) faster and with less GC churn.
     */
<span class="nc" id="L98">    private class ReverseReader extends AbstractReader</span>
    {
<span class="nc" id="L100">        final LongStack rowOffsets = new LongStack();</span>
        RangeTombstoneMarker blockOpenMarker, blockCloseMarker;
<span class="nc" id="L102">        private Unfiltered next = null;</span>
        private boolean foundLessThan;
<span class="nc" id="L104">        private long startPos = -1;</span>

        private ReverseReader(FileDataInput file, boolean shouldCloseFile)
<span class="nc" id="L107">        {</span>
<span class="nc" id="L108">            super(file, shouldCloseFile);</span>
<span class="nc" id="L109">        }</span>

        @Override
        public void setForSlice(Slice slice) throws IOException
        {
            // read full row and filter
<span class="nc bnc" id="L115" title="All 2 branches missed.">            if (startPos == -1)</span>
<span class="nc" id="L116">                startPos = file.getFilePointer();</span>
            else
<span class="nc" id="L118">                seekToPosition(startPos);</span>

<span class="nc" id="L120">            fillOffsets(slice, true, true, Long.MAX_VALUE);</span>
<span class="nc" id="L121">        }</span>

        @Override
        protected boolean hasNextInternal() throws IOException
        {
<span class="nc bnc" id="L126" title="All 2 branches missed.">            if (next != null)</span>
<span class="nc" id="L127">                return true;</span>
<span class="nc" id="L128">            next = computeNext();</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">            return next != null;</span>
        }

        @Override
        protected Unfiltered nextInternal() throws IOException
        {
<span class="nc bnc" id="L135" title="All 2 branches missed.">            if (!hasNextInternal())</span>
<span class="nc" id="L136">                throw new NoSuchElementException();</span>

<span class="nc" id="L138">            Unfiltered toReturn = next;</span>
<span class="nc" id="L139">            next = null;</span>
<span class="nc" id="L140">            return toReturn;</span>
        }

        private Unfiltered computeNext() throws IOException
        {
            Unfiltered toReturn;
            do
            {
<span class="nc bnc" id="L148" title="All 2 branches missed.">                if (blockCloseMarker != null)</span>
                {
<span class="nc" id="L150">                    toReturn = blockCloseMarker;</span>
<span class="nc" id="L151">                    blockCloseMarker = null;</span>
<span class="nc" id="L152">                    return toReturn;</span>
                }
<span class="nc bnc" id="L154" title="All 2 branches missed.">                while (!rowOffsets.isEmpty())</span>
                {
<span class="nc" id="L156">                    seekToPosition(rowOffsets.pop());</span>
<span class="nc" id="L157">                    boolean hasNext = deserializer.hasNext();</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">                    assert hasNext : &quot;Data file changed after offset collection pass&quot;;</span>
<span class="nc" id="L159">                    toReturn = deserializer.readNext();</span>
<span class="nc" id="L160">                    UnfilteredValidation.maybeValidateUnfiltered(toReturn, metadata(), key, sstable);</span>
                    // We may get empty row for the same reason expressed on UnfilteredSerializer.deserializeOne.
<span class="nc bnc" id="L162" title="All 2 branches missed.">                    if (!toReturn.isEmpty())</span>
<span class="nc" id="L163">                        return toReturn;</span>
<span class="nc" id="L164">                }</span>
            }
<span class="nc bnc" id="L166" title="All 4 branches missed.">            while (!foundLessThan &amp;&amp; advanceIndexBlock());</span>

            // open marker to be output only as slice is finished
<span class="nc bnc" id="L169" title="All 2 branches missed.">            if (blockOpenMarker != null)</span>
            {
<span class="nc" id="L171">                toReturn = blockOpenMarker;</span>
<span class="nc" id="L172">                blockOpenMarker = null;</span>
<span class="nc" id="L173">                return toReturn;</span>
            }
<span class="nc" id="L175">            return null;</span>
        }

        protected boolean advanceIndexBlock() throws IOException
        {
<span class="nc" id="L180">            return false;</span>
        }

        void fillOffsets(Slice slice, boolean filterStart, boolean filterEnd, long stopPosition) throws IOException
        {
<span class="nc bnc" id="L185" title="All 2 branches missed.">            filterStart &amp;= !slice.start().equals(ClusteringBound.BOTTOM);</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">            filterEnd &amp;= !slice.end().equals(ClusteringBound.TOP);</span>

<span class="nc" id="L188">            ClusteringBound&lt;?&gt; start = slice.start();</span>
<span class="nc" id="L189">            long currentPosition = file.getFilePointer();</span>
<span class="nc" id="L190">            foundLessThan = false;</span>
            // This is a copy of handlePreSliceData which also checks currentPosition &lt; stopPosition.
            // Not extracted to method as we need both marker and currentPosition.
<span class="nc bnc" id="L193" title="All 2 branches missed.">            if (filterStart)</span>
            {
<span class="nc bnc" id="L195" title="All 6 branches missed.">                while (currentPosition &lt; stopPosition &amp;&amp; deserializer.hasNext() &amp;&amp; deserializer.compareNextTo(start) &lt;= 0)</span>
                {
<span class="nc bnc" id="L197" title="All 2 branches missed.">                    if (deserializer.nextIsRow())</span>
<span class="nc" id="L198">                        deserializer.skipNext();</span>
                    else
<span class="nc" id="L200">                        updateOpenMarker((RangeTombstoneMarker) deserializer.readNext());</span>

<span class="nc" id="L202">                    currentPosition = file.getFilePointer();</span>
<span class="nc" id="L203">                    foundLessThan = true;</span>
                }
            }

            // We've reached the beginning of our queried slice. If we have an open marker
            // we should return that at the end of the slice to close the deletion.
<span class="nc bnc" id="L209" title="All 2 branches missed.">            if (openMarker != null)</span>
<span class="nc" id="L210">                blockOpenMarker = new RangeTombstoneBoundMarker(start, openMarker);</span>


            // Now deserialize everything until we reach our requested end (if we have one)
            // See SSTableIterator.ForwardRead.computeNext() for why this is a strict inequality below: this is the same
            // reasoning here.
<span class="nc bnc" id="L216" title="All 6 branches missed.">            while (currentPosition &lt; stopPosition &amp;&amp; deserializer.hasNext()</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">                   &amp;&amp; (!filterEnd || deserializer.compareNextTo(slice.end()) &lt; 0))</span>
            {
<span class="nc" id="L219">                rowOffsets.push(currentPosition);</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">                if (deserializer.nextIsRow())</span>
<span class="nc" id="L221">                    deserializer.skipNext();</span>
                else
<span class="nc" id="L223">                    updateOpenMarker((RangeTombstoneMarker) deserializer.readNext());</span>

<span class="nc" id="L225">                currentPosition = file.getFilePointer();</span>
            }

            // If we have an open marker, we should output that first, unless end is not being filtered
            // (i.e. it's either top (where a marker can't be open) or we placed that marker during previous block).
<span class="nc bnc" id="L230" title="All 4 branches missed.">            if (openMarker != null &amp;&amp; filterEnd)</span>
            {
                // If we have no end and still an openMarker, this means we're indexed and the marker is closed in a following block.
<span class="nc" id="L233">                blockCloseMarker = new RangeTombstoneBoundMarker(slice.end(), openMarker);</span>
<span class="nc" id="L234">                openMarker = null;</span>
            }
<span class="nc" id="L236">        }</span>
    }

    private class ReverseIndexedReader extends ReverseReader
    {
        private RowIndexReverseIterator indexReader;
        private final TrieIndexEntry indexEntry;
        private final long basePosition;
        private Slice currentSlice;
        private long currentBlockStart;

        public ReverseIndexedReader(AbstractRowIndexEntry indexEntry, FileDataInput file, boolean shouldCloseFile)
<span class="nc" id="L248">        {</span>
<span class="nc" id="L249">            super(file, shouldCloseFile);</span>
<span class="nc" id="L250">            basePosition = indexEntry.position;</span>
<span class="nc" id="L251">            this.indexEntry = (TrieIndexEntry) indexEntry;</span>
<span class="nc" id="L252">        }</span>

        @Override
        public void close() throws IOException
        {
<span class="nc bnc" id="L257" title="All 2 branches missed.">            if (indexReader != null)</span>
<span class="nc" id="L258">                indexReader.close();</span>
<span class="nc" id="L259">            super.close();</span>
<span class="nc" id="L260">        }</span>

        @Override
        public void setForSlice(Slice slice) throws IOException
        {
<span class="nc" id="L265">            currentSlice = slice;</span>
<span class="nc" id="L266">            ClusteringComparator comparator = metadata.comparator;</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">            if (indexReader != null)</span>
<span class="nc" id="L268">                indexReader.close();</span>
<span class="nc" id="L269">            indexReader = new RowIndexReverseIterator(ifile,</span>
                                                      indexEntry,
<span class="nc" id="L271">                                                      comparator.asByteComparable(slice.end()),</span>
<span class="nc" id="L272">                                                      sstable.descriptor.version);</span>
<span class="nc" id="L273">            gotoBlock(indexReader.nextIndexInfo(), true, Long.MAX_VALUE);</span>
<span class="nc" id="L274">        }</span>

        boolean gotoBlock(IndexInfo indexInfo, boolean filterEnd, long blockEnd) throws IOException
        {
<span class="nc" id="L278">            blockOpenMarker = null;</span>
<span class="nc" id="L279">            blockCloseMarker = null;</span>
<span class="nc" id="L280">            rowOffsets.clear();</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">            if (indexInfo == null)</span>
<span class="nc" id="L282">                return false;</span>
<span class="nc" id="L283">            currentBlockStart = basePosition + indexInfo.offset;</span>
<span class="nc" id="L284">            openMarker = indexInfo.openDeletion;</span>

<span class="nc" id="L286">            seekToPosition(currentBlockStart);</span>
<span class="nc" id="L287">            fillOffsets(currentSlice, true, filterEnd, blockEnd);</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">            return !rowOffsets.isEmpty();</span>
        }

        @Override
        protected boolean advanceIndexBlock() throws IOException
        {
<span class="nc" id="L294">            return gotoBlock(indexReader.nextIndexInfo(), false, currentBlockStart);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>