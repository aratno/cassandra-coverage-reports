<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Cells.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.rows</a> &gt; <span class="el_source">Cells.java</span></div><h1>Cells.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.db.rows;

import java.nio.ByteBuffer;
import java.util.Comparator;
import java.util.Iterator;

import org.apache.cassandra.db.context.CounterContext;
import org.apache.cassandra.db.marshal.AbstractType;
import org.apache.cassandra.db.marshal.ValueAccessor;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.db.DeletionTime;
import org.apache.cassandra.db.partitions.PartitionStatisticsCollector;

/**
 * Static methods to work on cells.
 */
<span class="fc" id="L34">public abstract class Cells</span>
{
    private Cells() {}

    /**
     * Collect statistics ont a given cell.
     *
     * @param cell the cell for which to collect stats.
     * @param collector the stats collector.
     */
    public static void collectStats(Cell&lt;?&gt; cell, PartitionStatisticsCollector collector)
    {
<span class="fc" id="L46">        collector.update(cell);</span>

<span class="fc bfc" id="L48" title="All 2 branches covered.">        if (cell.isCounterCell())</span>
<span class="fc" id="L49">            collector.updateHasLegacyCounterShards(CounterCells.hasLegacyShards(cell));</span>
<span class="fc" id="L50">    }</span>

    /**
     * Reconciles/merge two cells.
     * &lt;p&gt;
     * Note that this method assumes that the provided cells can meaningfully
     * be reconciled together, that is that cell are for the same row and same
     * column (and same cell path if the column is complex).
     * &lt;p&gt;
     * This method is commutative over it's cells arguments: {@code reconcile(a, b, n) == reconcile(b, a, n)}.
     *
     * @param c1 the first cell participating in the reconciliation.
     * @param c2 the second cell participating in the reconciliation.
     *
     * @return a cell corresponding to the reconciliation of {@code c1} and {@code c2}.
     * For non-counter cells, this will always be either {@code c1} or {@code c2}, but for
     * counter cells this can be a newly allocated cell.
     */
    public static Cell&lt;?&gt; reconcile(Cell&lt;?&gt; c1, Cell&lt;?&gt; c2)
    {
<span class="pc bpc" id="L70" title="2 of 4 branches missed.">        if (c1 == null || c2 == null)</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">            return c2 == null ? c1 : c2;</span>

<span class="pc bpc" id="L73" title="1 of 4 branches missed.">        if (c1.isCounterCell() || c2.isCounterCell())</span>
<span class="fc" id="L74">            return resolveCounter(c1, c2);</span>

<span class="fc" id="L76">        return resolveRegular(c1, c2);</span>
    }

    private static Cell&lt;?&gt; resolveRegular(Cell&lt;?&gt; left, Cell&lt;?&gt; right)
    {
<span class="fc" id="L81">        long leftTimestamp = left.timestamp();</span>
<span class="fc" id="L82">        long rightTimestamp = right.timestamp();</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">        if (leftTimestamp != rightTimestamp)</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">            return leftTimestamp &gt; rightTimestamp ? left : right;</span>

<span class="fc" id="L86">        long leftLocalDeletionTime = left.localDeletionTime();</span>
<span class="fc" id="L87">        long rightLocalDeletionTime = right.localDeletionTime();</span>

<span class="fc bfc" id="L89" title="All 2 branches covered.">        boolean leftIsExpiringOrTombstone = leftLocalDeletionTime != Cell.NO_DELETION_TIME;</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">        boolean rightIsExpiringOrTombstone = rightLocalDeletionTime != Cell.NO_DELETION_TIME;</span>

<span class="fc bfc" id="L92" title="All 2 branches covered.">        if (leftIsExpiringOrTombstone | rightIsExpiringOrTombstone)</span>
        {
            // Tombstones always win reconciliation with live cells of the same timstamp
            // CASSANDRA-14592: for consistency of reconciliation, regardless of system clock at time of reconciliation
            // this requires us to treat expiring cells (which will become tombstones at some future date) the same wrt regular cells
<span class="fc bfc" id="L97" title="All 2 branches covered.">            if (leftIsExpiringOrTombstone != rightIsExpiringOrTombstone)</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">                return leftIsExpiringOrTombstone ? left : right;</span>

            // for most historical consistency, we still prefer tombstones over expiring cells.
            // While this leads to the an inconsistency over which is chosen
            // (i.e. before expiry, the pure tombstone; after expiry, whichever is more recent)
            // this inconsistency has no user-visible distinction, as at this point they are both logically tombstones
            // (the only possible difference is the time at which the cells become purgeable)
<span class="fc bfc" id="L105" title="All 2 branches covered.">            boolean leftIsTombstone = !left.isExpiring(); // !isExpiring() == isTombstone(), but does not need to consider localDeletionTime()</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">            boolean rightIsTombstone = !right.isExpiring();</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">            if (leftIsTombstone != rightIsTombstone)</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">                return leftIsTombstone ? left : right;</span>

            // ==&gt; (leftIsExpiring &amp;&amp; rightIsExpiring) or (leftIsTombstone &amp;&amp; rightIsTombstone)
            // if both are expiring, we do not want to consult the value bytes if we can avoid it, as like with C-14592
            // the value bytes implicitly depend on the system time at reconciliation, as a
            // would otherwise always win (unless it had an empty value), until it expired and was translated to a tombstone
<span class="fc bfc" id="L114" title="All 2 branches covered.">            if (leftLocalDeletionTime != rightLocalDeletionTime)</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">                return leftLocalDeletionTime &gt; rightLocalDeletionTime ? left : right;</span>
        }

<span class="fc bfc" id="L118" title="All 2 branches covered.">        return compareValues(left, right) &gt;= 0 ? left : right;</span>
    }

    private static Cell&lt;?&gt; resolveCounter(Cell&lt;?&gt; left, Cell&lt;?&gt; right)
    {
<span class="fc" id="L123">        long leftTimestamp = left.timestamp();</span>
<span class="fc" id="L124">        long rightTimestamp = right.timestamp();</span>

<span class="fc" id="L126">        boolean leftIsTombstone = left.isTombstone();</span>
<span class="fc" id="L127">        boolean rightIsTombstone = right.isTombstone();</span>

<span class="pc bpc" id="L129" title="1 of 2 branches missed.">        if (leftIsTombstone | rightIsTombstone)</span>
        {
            // No matter what the counter cell's timestamp is, a tombstone always takes precedence. See CASSANDRA-7346.
<span class="nc bnc" id="L132" title="All 2 branches missed.">            assert leftIsTombstone != rightIsTombstone;</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">            return leftIsTombstone ? left : right;</span>
        }

<span class="fc" id="L136">        ByteBuffer leftValue = left.buffer();</span>
<span class="fc" id="L137">        ByteBuffer rightValue = right.buffer();</span>

        // Handle empty values. Counters can't truly have empty values, but we can have a counter cell that temporarily
        // has one on read if the column for the cell is not queried by the user due to the optimization of #10657. We
        // thus need to handle this (see #11726 too).
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">        boolean leftIsEmpty = !leftValue.hasRemaining();</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">        boolean rightIsEmpty = !rightValue.hasRemaining();</span>
<span class="pc bpc" id="L144" title="2 of 4 branches missed.">        if (leftIsEmpty || rightIsEmpty)</span>
        {
<span class="nc bnc" id="L146" title="All 2 branches missed.">            if (leftIsEmpty != rightIsEmpty)</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">                return leftIsEmpty ? left : right;</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">            return leftTimestamp &gt; rightTimestamp ? left : right;</span>
        }

<span class="fc" id="L151">        ByteBuffer merged = CounterContext.instance().merge(leftValue, rightValue);</span>
<span class="fc" id="L152">        long timestamp = Math.max(leftTimestamp, rightTimestamp);</span>

        // We save allocating a new cell object if it turns out that one cell was
        // a complete superset of the other
<span class="pc bpc" id="L156" title="1 of 4 branches missed.">        if (merged == leftValue &amp;&amp; timestamp == leftTimestamp)</span>
<span class="fc" id="L157">            return left;</span>
<span class="pc bpc" id="L158" title="1 of 4 branches missed.">        else if (merged == rightValue &amp;&amp; timestamp == rightTimestamp)</span>
<span class="fc" id="L159">            return right;</span>
        else // merge clocks and timestamps.
<span class="fc" id="L161">            return new BufferCell(left.column(), timestamp, Cell.NO_TTL, Cell.NO_DELETION_TIME, merged, left.path());</span>
    }

    /**
     * Adds to the builder a representation of the given existing cell that, when merged/reconciled with the given
     * update cell, produces the same result as merging the original with the update.
     * &lt;p&gt;
     * For simple cells that is either the original cell (if still live), or nothing (if shadowed).
     *
     * @param existing the pre-existing cell, the one that is updated.
     * @param update the newly added cell, the update. This can be {@code null} out
     * of convenience, in which case this function simply copy {@code existing} to
     * {@code writer}.
     * @param deletion the deletion time that applies to the cells being considered.
     * This deletion time may delete both {@code existing} or {@code update}.
     * @param builder the row builder to which the result of the filtering is written.
     */
    public static void addNonShadowed(Cell&lt;?&gt; existing,
                                      Cell&lt;?&gt; update,
                                      DeletionTime deletion,
                                      Row.Builder builder)
    {
<span class="nc bnc" id="L183" title="All 2 branches missed.">        if (deletion.deletes(existing))</span>
<span class="nc" id="L184">            return;</span>

<span class="nc" id="L186">        Cell&lt;?&gt; reconciled = reconcile(existing, update);</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">        if (reconciled != update)</span>
<span class="nc" id="L188">            builder.addCell(existing);</span>
<span class="nc" id="L189">    }</span>

    /**
     * Adds to the builder a representation of the given existing cell that, when merged/reconciled with the given
     * update cell, produces the same result as merging the original with the update.
     * &lt;p&gt;
     * For simple cells that is either the original cell (if still live), or nothing (if shadowed).
     *
     * @param column the complex column the cells are for.
     * @param existing the pre-existing cells, the ones that are updated.
     * @param update the newly added cells, the update. This can be {@code null} out
     * of convenience, in which case this function simply copy the cells from
     * {@code existing} to {@code writer}.
     * @param deletion the deletion time that applies to the cells being considered.
     * This deletion time may delete both {@code existing} or {@code update}.
     * @param builder the row builder to which the result of the filtering is written.
     */
    public static void addNonShadowedComplex(ColumnMetadata column,
                                             Iterator&lt;Cell&lt;?&gt;&gt; existing,
                                             Iterator&lt;Cell&lt;?&gt;&gt; update,
                                             DeletionTime deletion,
                                             Row.Builder builder)
    {
<span class="nc" id="L212">        Comparator&lt;CellPath&gt; comparator = column.cellPathComparator();</span>
<span class="nc" id="L213">        Cell&lt;?&gt; nextExisting = getNext(existing);</span>
<span class="nc" id="L214">        Cell&lt;?&gt; nextUpdate = getNext(update);</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">        while (nextExisting != null)</span>
        {
<span class="nc bnc" id="L217" title="All 2 branches missed.">            int cmp = nextUpdate == null ? -1 : comparator.compare(nextExisting.path(), nextUpdate.path());</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">            if (cmp &lt; 0)</span>
            {
<span class="nc" id="L220">                addNonShadowed(nextExisting, null, deletion, builder);</span>
<span class="nc" id="L221">                nextExisting = getNext(existing);</span>
            }
<span class="nc bnc" id="L223" title="All 2 branches missed.">            else if (cmp == 0)</span>
            {
<span class="nc" id="L225">                addNonShadowed(nextExisting, nextUpdate, deletion, builder);</span>
<span class="nc" id="L226">                nextExisting = getNext(existing);</span>
<span class="nc" id="L227">                nextUpdate = getNext(update);</span>
            }
            else
            {
<span class="nc" id="L231">                nextUpdate = getNext(update);</span>
            }
<span class="nc" id="L233">        }</span>
<span class="nc" id="L234">    }</span>

    private static Cell&lt;?&gt; getNext(Iterator&lt;Cell&lt;?&gt;&gt; iterator)
    {
<span class="nc bnc" id="L238" title="All 4 branches missed.">        return iterator == null || !iterator.hasNext() ? null : iterator.next();</span>
    }

    private static &lt;L, R&gt; int compareValues(Cell&lt;L&gt; left, Cell&lt;R&gt; right)
    {
<span class="fc" id="L243">        return ValueAccessor.compare(left.value(), left.accessor(), right.value(), right.accessor());</span>
    }

    public static &lt;L, R&gt; boolean valueEqual(Cell&lt;L&gt; left, Cell&lt;R&gt; right)
    {
<span class="fc" id="L248">        return ValueAccessor.equals(left.value(), left.accessor(), right.value(), right.accessor());</span>
    }

    public static &lt;T, V&gt; T composeValue(Cell&lt;V&gt; cell, AbstractType&lt;T&gt; type)
    {
<span class="nc" id="L253">        return type.compose(cell.value(), cell.accessor());</span>
    }

    public static &lt;V&gt; String valueString(Cell&lt;V&gt; cell, AbstractType&lt;?&gt; type)
    {
<span class="fc" id="L258">        return type.getString(cell.value(), cell.accessor());</span>
    }

    public static &lt;V&gt; String valueString(Cell&lt;V&gt; cell)
    {
<span class="fc" id="L263">        return valueString(cell, cell.column().type);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>