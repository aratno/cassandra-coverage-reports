<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LogbackLoggingSupport.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.utils.logging</a> &gt; <span class="el_source">LogbackLoggingSupport.java</span></div><h1>LogbackLoggingSupport.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.utils.logging;

import java.lang.management.ManagementFactory;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import javax.management.JMX;
import javax.management.ObjectName;

import org.apache.cassandra.security.ThreadAwareSecurityManager;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.LoggerFactory;

import com.google.common.collect.Maps;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.Logger;
import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.jmx.JMXConfiguratorMBean;
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.classic.spi.TurboFilterList;
import ch.qos.logback.classic.turbo.ReconfigureOnChangeFilter;
import ch.qos.logback.classic.turbo.TurboFilter;
import ch.qos.logback.core.Appender;
import ch.qos.logback.core.hook.DelayingShutdownHook;

/**
 * Encapsulates all logback-specific implementations in a central place.
 * Generally, the Cassandra code-base should be logging-backend agnostic and only use slf4j-api.
 * This class MUST NOT be used directly, but only via {@link LoggingSupportFactory} which dynamically loads and
 * instantiates an appropriate implementation according to the used slf4j binding.
 */
<span class="fc" id="L55">public class LogbackLoggingSupport implements LoggingSupport</span>
{

<span class="fc" id="L58">    private static final org.slf4j.Logger logger = LoggerFactory.getLogger(LogbackLoggingSupport.class);</span>

    @Override
    public void onStartup()
    {
<span class="fc" id="L63">        checkOnlyOneVirtualTableAppender();</span>

        // The default logback configuration in conf/logback.xml allows reloading the
        // configuration when the configuration file has changed (every 60 seconds by default).
        // This requires logback to use file I/O APIs. But file I/O is not allowed from UDFs.
        // I.e. if logback decides to check for a modification of the config file while
        // executing a sandbox thread, the UDF execution and therefore the whole request
        // execution will fail with an AccessControlException.
        // To work around this, a custom ReconfigureOnChangeFilter is installed, that simply
        // prevents this configuration file check and possible reload of the configuration,
        // while executing sandboxed UDF code.
        //
        // NOTE: this is obsolte with logback versions (at least since 1.2.3)
<span class="fc" id="L76">        Logger logbackLogger = (Logger) LoggerFactory.getLogger(ThreadAwareSecurityManager.class);</span>
<span class="fc" id="L77">        LoggerContext ctx = logbackLogger.getLoggerContext();</span>

<span class="fc" id="L79">        TurboFilterList turboFilterList = ctx.getTurboFilterList();</span>
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">        for (int i = 0; i &lt; turboFilterList.size(); i++)</span>
        {
<span class="nc" id="L82">            TurboFilter turboFilter = turboFilterList.get(i);</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">            if (turboFilter instanceof ReconfigureOnChangeFilter)</span>
            {
<span class="nc" id="L85">                ReconfigureOnChangeFilter reconfigureOnChangeFilter = (ReconfigureOnChangeFilter) turboFilter;</span>
<span class="nc" id="L86">                turboFilterList.set(i, new SMAwareReconfigureOnChangeFilter(reconfigureOnChangeFilter));</span>
<span class="nc" id="L87">                break;</span>
            }
        }
<span class="fc" id="L90">    }</span>

    @Override
    public void onShutdown()
    {
<span class="fc" id="L95">        DelayingShutdownHook logbackHook = new DelayingShutdownHook();</span>
<span class="fc" id="L96">        logbackHook.setContext((LoggerContext) LoggerFactory.getILoggerFactory());</span>
<span class="nc" id="L97">        logbackHook.run();</span>
<span class="nc" id="L98">    }</span>

    @Override
    public void setLoggingLevel(String classQualifier, String rawLevel) throws Exception
    {
<span class="nc" id="L103">        Logger logBackLogger = (Logger) LoggerFactory.getLogger(classQualifier);</span>

        // if both classQualifier and rawLevel are empty, reload from configuration
<span class="nc bnc" id="L106" title="All 4 branches missed.">        if (StringUtils.isBlank(classQualifier) &amp;&amp; StringUtils.isBlank(rawLevel))</span>
        {
<span class="nc" id="L108">            JMXConfiguratorMBean jmxConfiguratorMBean = JMX.newMBeanProxy(ManagementFactory.getPlatformMBeanServer(),</span>
                                                                          new ObjectName(&quot;ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator&quot;),
                                                                          JMXConfiguratorMBean.class);
<span class="nc" id="L111">            jmxConfiguratorMBean.reloadDefaultConfiguration();</span>
<span class="nc" id="L112">            return;</span>
        }
        // classQualifier is set, but blank level given
<span class="nc bnc" id="L115" title="All 4 branches missed.">        else if (StringUtils.isNotBlank(classQualifier) &amp;&amp; StringUtils.isBlank(rawLevel))</span>
        {
<span class="nc bnc" id="L117" title="All 4 branches missed.">            if (logBackLogger.getLevel() != null || hasAppenders(logBackLogger))</span>
<span class="nc" id="L118">                logBackLogger.setLevel(null);</span>
<span class="nc" id="L119">            return;</span>
        }

<span class="nc" id="L122">        Level level = Level.toLevel(rawLevel);</span>
<span class="nc" id="L123">        logBackLogger.setLevel(level);</span>
<span class="nc" id="L124">        logger.info(&quot;set log level to {} for classes under '{}' (if the level doesn't look like '{}' then the logger couldn't parse '{}')&quot;, level, classQualifier, rawLevel, rawLevel);</span>
<span class="nc" id="L125">    }</span>

    @Override
    public Map&lt;String, String&gt; getLoggingLevels()
    {
<span class="nc" id="L130">        Map&lt;String, String&gt; logLevelMaps = Maps.newLinkedHashMap();</span>
<span class="nc" id="L131">        LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">        for (Logger logBackLogger : lc.getLoggerList())</span>
        {
<span class="nc bnc" id="L134" title="All 4 branches missed.">            if (logBackLogger.getLevel() != null || hasAppenders(logBackLogger))</span>
<span class="nc" id="L135">                logLevelMaps.put(logBackLogger.getName(), logBackLogger.getLevel().toString());</span>
<span class="nc" id="L136">        }</span>
<span class="nc" id="L137">        return logLevelMaps;</span>
    }

    @Override
    public Optional&lt;Appender&lt;?&gt;&gt; getAppender(Class&lt;?&gt; appenderClass, String name)
    {
<span class="fc" id="L143">        LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">        for (Logger logBackLogger : lc.getLoggerList())</span>
        {
<span class="fc bfc" id="L146" title="All 2 branches covered.">            for (Iterator&lt;Appender&lt;ILoggingEvent&gt;&gt; iterator = logBackLogger.iteratorForAppenders(); iterator.hasNext();)</span>
            {
<span class="fc" id="L148">                Appender&lt;ILoggingEvent&gt; appender = iterator.next();</span>
<span class="pc bpc" id="L149" title="3 of 4 branches missed.">                if (appender.getClass() == appenderClass &amp;&amp; appender.getName().equals(name))</span>
<span class="nc" id="L150">                    return Optional.of(appender);</span>
<span class="fc" id="L151">            }</span>
<span class="fc" id="L152">        }</span>

<span class="fc" id="L154">        return Optional.empty();</span>
    }

    private void checkOnlyOneVirtualTableAppender()
    {
<span class="fc" id="L159">        int count = 0;</span>
<span class="fc" id="L160">        LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();</span>
<span class="fc" id="L161">        List&lt;String&gt; virtualAppenderNames = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">        for (Logger logBackLogger : lc.getLoggerList())</span>
        {
<span class="fc bfc" id="L164" title="All 2 branches covered.">            for (Iterator&lt;Appender&lt;ILoggingEvent&gt;&gt; iterator = logBackLogger.iteratorForAppenders(); iterator.hasNext();)</span>
            {
<span class="fc" id="L166">                Appender&lt;?&gt; appender = iterator.next();</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">                if (appender instanceof VirtualTableAppender)</span>
                {
<span class="nc" id="L169">                    virtualAppenderNames.add(appender.getName());</span>
<span class="nc" id="L170">                    count += 1;</span>
                }
<span class="fc" id="L172">            }</span>
<span class="fc" id="L173">        }</span>

<span class="pc bpc" id="L175" title="1 of 2 branches missed.">        if (count &gt; 1)</span>
<span class="nc" id="L176">            throw new IllegalStateException(String.format(&quot;There are multiple appenders of class %s of names %s. There is only one appender of such class allowed.&quot;,</span>
<span class="nc" id="L177">                                                          VirtualTableAppender.class.getName(), String.join(&quot;,&quot;, virtualAppenderNames)));</span>
<span class="fc" id="L178">    }</span>

    private boolean hasAppenders(Logger logBackLogger)
    {
<span class="nc" id="L182">        Iterator&lt;Appender&lt;ILoggingEvent&gt;&gt; it = logBackLogger.iteratorForAppenders();</span>
<span class="nc" id="L183">        return it.hasNext();</span>
    }

    /**
     * The purpose of this class is to prevent logback from checking for config file change,
     * if the current thread is executing a sandboxed thread to avoid {@link AccessControlException}s.
     *
     * This is obsolete with logback versions that replaced {@link ReconfigureOnChangeFilter}
     * with {@link ch.qos.logback.classic.joran.ReconfigureOnChangeTask} (at least logback since 1.2.3).
     */
    private static class SMAwareReconfigureOnChangeFilter extends ReconfigureOnChangeFilter
    {
        SMAwareReconfigureOnChangeFilter(ReconfigureOnChangeFilter reconfigureOnChangeFilter)
<span class="nc" id="L196">        {</span>
<span class="nc" id="L197">            setRefreshPeriod(reconfigureOnChangeFilter.getRefreshPeriod());</span>
<span class="nc" id="L198">            setName(reconfigureOnChangeFilter.getName());</span>
<span class="nc" id="L199">            setContext(reconfigureOnChangeFilter.getContext());</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">            if (reconfigureOnChangeFilter.isStarted())</span>
            {
<span class="nc" id="L202">                reconfigureOnChangeFilter.stop();</span>
<span class="nc" id="L203">                start();</span>
            }
<span class="nc" id="L205">        }</span>

        protected boolean changeDetected(long now)
        {
<span class="nc bnc" id="L209" title="All 2 branches missed.">            if (ThreadAwareSecurityManager.isSecuredThread())</span>
<span class="nc" id="L210">                return false;</span>
<span class="nc" id="L211">            return super.changeDetected(now);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>