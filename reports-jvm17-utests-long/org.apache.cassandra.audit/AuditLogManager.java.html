<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AuditLogManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.audit</a> &gt; <span class="el_source">AuditLogManager.java</span></div><h1>AuditLogManager.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.audit;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.UUID;

import javax.annotation.Nullable;
import javax.management.openmbean.CompositeData;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableList;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.auth.AuthEvents;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.config.ParameterizedClass;
import org.apache.cassandra.cql3.CQLStatement;
import org.apache.cassandra.cql3.PasswordObfuscator;
import org.apache.cassandra.cql3.QueryEvents;
import org.apache.cassandra.cql3.QueryOptions;
import org.apache.cassandra.cql3.statements.BatchStatement;
import org.apache.cassandra.exceptions.AuthenticationException;
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.exceptions.PreparedQueryNotFoundException;
import org.apache.cassandra.exceptions.SyntaxException;
import org.apache.cassandra.exceptions.UnauthorizedException;
import org.apache.cassandra.service.QueryState;
import org.apache.cassandra.transport.Message;
import org.apache.cassandra.transport.messages.ResultMessage;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.MBeanWrapper;

/**
 * Central location for managing the logging of client/user-initated actions (like queries, log in commands, and so on).
 *
 */
public class AuditLogManager implements QueryEvents.Listener, AuthEvents.Listener, AuditLogManagerMBean
{
<span class="fc" id="L61">    private static final Logger logger = LoggerFactory.getLogger(AuditLogManager.class);</span>

    public static final String MBEAN_NAME = &quot;org.apache.cassandra.db:type=AuditLogManager&quot;;
<span class="fc" id="L64">    public static final AuditLogManager instance = new AuditLogManager();</span>

    // auditLogger can write anywhere, as it's pluggable (logback, BinLog, DiagnosticEvents, etc ...)
    private volatile IAuditLogger auditLogger;
    private volatile AuditLogFilter filter;
    private volatile AuditLogOptions auditLogOptions;

    private AuditLogManager()
<span class="fc" id="L72">    {</span>
<span class="fc" id="L73">        auditLogOptions = DatabaseDescriptor.getAuditLoggingOptions();</span>

<span class="pc bpc" id="L75" title="1 of 2 branches missed.">        if (auditLogOptions.enabled)</span>
        {
<span class="nc" id="L77">            logger.info(&quot;Audit logging is enabled.&quot;);</span>
<span class="nc" id="L78">            auditLogger = getAuditLogger(auditLogOptions);</span>
        }
        else
        {
<span class="fc" id="L82">            logger.debug(&quot;Audit logging is disabled.&quot;);</span>
<span class="fc" id="L83">            auditLogger = new NoOpAuditLogger(Collections.emptyMap());</span>
        }

<span class="fc" id="L86">        filter = AuditLogFilter.create(auditLogOptions);</span>
<span class="fc" id="L87">    }</span>

    public void initialize()
    {
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">        if (DatabaseDescriptor.getAuditLoggingOptions().enabled)</span>
<span class="nc" id="L92">            registerAsListener();</span>

<span class="pc bpc" id="L94" title="1 of 2 branches missed.">        if (!MBeanWrapper.instance.isRegistered(MBEAN_NAME))</span>
<span class="fc" id="L95">            MBeanWrapper.instance.registerMBean(this, MBEAN_NAME);</span>
<span class="fc" id="L96">    }</span>

    private IAuditLogger getAuditLogger(AuditLogOptions options) throws ConfigurationException
    {
<span class="nc" id="L100">        final ParameterizedClass logger = options.logger;</span>

<span class="nc bnc" id="L102" title="All 4 branches missed.">        if (logger != null &amp;&amp; logger.class_name != null)</span>
        {
<span class="nc bnc" id="L104" title="All 2 branches missed.">            return FBUtilities.newAuditLogger(logger.class_name, logger.parameters == null ? Collections.emptyMap() : logger.parameters);</span>
        }

<span class="nc" id="L107">        return new BinAuditLogger(options);</span>
    }

    @VisibleForTesting
    public IAuditLogger getLogger()
    {
<span class="nc" id="L113">        return auditLogger;</span>
    }

    public boolean isEnabled()
    {
<span class="nc" id="L118">        return auditLogger.isEnabled();</span>
    }

    public AuditLogOptions getAuditLogOptions()
    {
<span class="nc bnc" id="L123" title="All 2 branches missed.">        return auditLogger.isEnabled() ? auditLogOptions : DatabaseDescriptor.getAuditLoggingOptions();</span>
    }

    @Override
    public CompositeData getAuditLogOptionsData()
    {
<span class="nc" id="L129">        return AuditLogOptionsCompositeData.toCompositeData(AuditLogManager.instance.getAuditLogOptions());</span>
    }

    /**
     * Logs AudigLogEntry to standard audit logger
     * @param logEntry AuditLogEntry to be logged
     */
    private void log(AuditLogEntry logEntry)
    {
<span class="nc bnc" id="L138" title="All 2 branches missed.">        if (!filter.isFiltered(logEntry))</span>
        {
<span class="nc" id="L140">            auditLogger.log(logEntry);</span>
        }
<span class="nc" id="L142">    }</span>

    private void log(AuditLogEntry logEntry, Exception e)
    {
<span class="nc" id="L146">        log(logEntry, e, null);</span>
<span class="nc" id="L147">    }</span>

    private void log(AuditLogEntry logEntry, Exception e, List&lt;String&gt; queries)
    {
<span class="nc" id="L151">        AuditLogEntry.Builder builder = new AuditLogEntry.Builder(logEntry);</span>

<span class="nc bnc" id="L153" title="All 2 branches missed.">        if (e instanceof UnauthorizedException)</span>
        {
<span class="nc" id="L155">            builder.setType(AuditLogEntryType.UNAUTHORIZED_ATTEMPT);</span>
        }
<span class="nc bnc" id="L157" title="All 2 branches missed.">        else if (e instanceof AuthenticationException)</span>
        {
<span class="nc" id="L159">            builder.setType(AuditLogEntryType.LOGIN_ERROR);</span>
        }
        else
        {
<span class="nc" id="L163">            builder.setType(AuditLogEntryType.REQUEST_FAILURE);</span>
        }

<span class="nc" id="L166">        builder.appendToOperation(obfuscatePasswordInformation(e, queries));</span>

<span class="nc" id="L168">        log(builder.build());</span>
<span class="nc" id="L169">    }</span>

    /**
     * Disables AuditLog, designed to be invoked only via JMX/ Nodetool, not from anywhere else in the codepath.
     */
    public synchronized void disableAuditLog()
    {
<span class="nc" id="L176">        unregisterAsListener();</span>
<span class="nc" id="L177">        IAuditLogger oldLogger = auditLogger;</span>
<span class="nc" id="L178">        auditLogger = new NoOpAuditLogger(Collections.emptyMap());</span>
<span class="nc" id="L179">        oldLogger.stop();</span>
<span class="nc" id="L180">    }</span>

    /**
     * Enables AuditLog, designed to be invoked only via JMX/ Nodetool, not from anywhere else in the codepath.
     * @param auditLogOptions AuditLogOptions to be used for enabling AuditLog
     * @throws ConfigurationException It can throw configuration exception when provided logger class does not exist in the classpath
     */
    public synchronized void enable(AuditLogOptions auditLogOptions) throws ConfigurationException
    {
<span class="nc" id="L189">        IAuditLogger oldLogger = auditLogger;</span>

        try
        {
            // next, check to see if we're changing the logging implementation; if not, keep the same instance and bail.
            // note: auditLogger should never be null
<span class="nc bnc" id="L195" title="All 2 branches missed.">            if (oldLogger.getClass().getSimpleName().equals(auditLogOptions.logger.class_name))</span>
<span class="nc" id="L196">                return;</span>

<span class="nc" id="L198">            auditLogger = getAuditLogger(auditLogOptions);</span>
            // switch to these audit log options after getAuditLogger() has not thrown
            // otherwise we might stay with new options but with old logger if it failed
<span class="nc" id="L201">            this.auditLogOptions = auditLogOptions;</span>
        }
        finally
        {
            // always reload the filters
<span class="nc" id="L206">            filter = AuditLogFilter.create(auditLogOptions);</span>
            // update options so the changed filters are reflected in options,
            // for example upon nodetool's getauditlog command
<span class="nc" id="L209">            updateAuditLogOptions(this.auditLogOptions, filter);</span>
        }

        // note that we might already be registered here and we rely on the fact that Query/AuthEvents have a Set of listeners
<span class="nc" id="L213">        registerAsListener();</span>

        // ensure oldLogger's stop() is called after we swap it with new logger,
        // otherwise, we might be calling log() on the stopped logger.
<span class="nc" id="L217">        oldLogger.stop();</span>
<span class="nc" id="L218">    }</span>

    private void updateAuditLogOptions(final AuditLogOptions options, final AuditLogFilter filter)
    {
<span class="nc" id="L222">        options.included_keyspaces = String.join(&quot;,&quot;, filter.includedKeyspaces.asList());</span>
<span class="nc" id="L223">        options.excluded_keyspaces = String.join(&quot;,&quot;, filter.excludedKeyspaces.asList());</span>
<span class="nc" id="L224">        options.included_categories = String.join(&quot;,&quot;, filter.includedCategories.asList());</span>
<span class="nc" id="L225">        options.excluded_categories = String.join(&quot;,&quot;, filter.excludedCategories.asList());</span>
<span class="nc" id="L226">        options.included_users = String.join(&quot;,&quot;, filter.includedUsers.asList());</span>
<span class="nc" id="L227">        options.excluded_users = String.join(&quot;,&quot;, filter.excludedUsers.asList());</span>
<span class="nc" id="L228">    }</span>

    private void registerAsListener()
    {
<span class="nc" id="L232">        QueryEvents.instance.registerListener(this);</span>
<span class="nc" id="L233">        AuthEvents.instance.registerListener(this);</span>
<span class="nc" id="L234">    }</span>

    private void unregisterAsListener()
    {
<span class="nc" id="L238">        QueryEvents.instance.unregisterListener(this);</span>
<span class="nc" id="L239">        AuthEvents.instance.unregisterListener(this);</span>
<span class="nc" id="L240">    }</span>

    public void querySuccess(CQLStatement statement, String query, QueryOptions options, QueryState state, long queryTime, Message.Response response)
    {
<span class="nc" id="L244">        AuditLogEntry entry = new AuditLogEntry.Builder(state).setType(statement.getAuditLogContext().auditLogEntryType)</span>
<span class="nc" id="L245">                                                              .setOperation(query)</span>
<span class="nc" id="L246">                                                              .setTimestamp(queryTime)</span>
<span class="nc" id="L247">                                                              .setScope(statement)</span>
<span class="nc" id="L248">                                                              .setKeyspace(state, statement)</span>
<span class="nc" id="L249">                                                              .setOptions(options)</span>
<span class="nc" id="L250">                                                              .build();</span>
<span class="nc" id="L251">        log(entry);</span>
<span class="nc" id="L252">    }</span>

    public void queryFailure(CQLStatement stmt, String query, QueryOptions options, QueryState state, Exception cause)
    {
<span class="nc" id="L256">        AuditLogEntry entry = new AuditLogEntry.Builder(state).setOperation(query)</span>
<span class="nc" id="L257">                                                              .setOptions(options)</span>
<span class="nc" id="L258">                                                              .build();</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">        log(entry, cause, query == null ? null : ImmutableList.of(query));</span>
<span class="nc" id="L260">    }</span>

    public void executeSuccess(CQLStatement statement, String query, QueryOptions options, QueryState state, long queryTime, Message.Response response)
    {
<span class="nc" id="L264">        AuditLogEntry entry = new AuditLogEntry.Builder(state).setType(statement.getAuditLogContext().auditLogEntryType)</span>
<span class="nc" id="L265">                                                              .setOperation(query)</span>
<span class="nc" id="L266">                                                              .setTimestamp(queryTime)</span>
<span class="nc" id="L267">                                                              .setScope(statement)</span>
<span class="nc" id="L268">                                                              .setKeyspace(state, statement)</span>
<span class="nc" id="L269">                                                              .setOptions(options)</span>
<span class="nc" id="L270">                                                              .build();</span>
<span class="nc" id="L271">        log(entry);</span>
<span class="nc" id="L272">    }</span>

    public void executeFailure(CQLStatement statement, String query, QueryOptions options, QueryState state, Exception cause)
    {
<span class="nc" id="L276">        AuditLogEntry entry = null;</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">        if (cause instanceof PreparedQueryNotFoundException)</span>
        {
<span class="nc bnc" id="L279" title="All 2 branches missed.">            entry = new AuditLogEntry.Builder(state).setOperation(query == null ? &quot;null&quot; : query)</span>
<span class="nc" id="L280">                                                                  .setOptions(options)</span>
<span class="nc" id="L281">                                                                  .build();</span>
        }
<span class="nc bnc" id="L283" title="All 2 branches missed.">        else if (statement != null)</span>
        {
<span class="nc bnc" id="L285" title="All 2 branches missed.">            entry = new AuditLogEntry.Builder(state).setOperation(query == null ? statement.toString() : query)</span>
<span class="nc" id="L286">                                                                  .setType(statement.getAuditLogContext().auditLogEntryType)</span>
<span class="nc" id="L287">                                                                  .setScope(statement)</span>
<span class="nc" id="L288">                                                                  .setKeyspace(state, statement)</span>
<span class="nc" id="L289">                                                                  .setOptions(options)</span>
<span class="nc" id="L290">                                                                  .build();</span>
        }
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (entry != null)</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">            log(entry, cause, query == null ? null : ImmutableList.of(query));</span>
<span class="nc" id="L294">    }</span>

    public void batchSuccess(BatchStatement.Type batchType, List&lt;? extends CQLStatement&gt; statements, List&lt;String&gt; queries, List&lt;List&lt;ByteBuffer&gt;&gt; values, QueryOptions options, QueryState state, long queryTime, Message.Response response)
    {
<span class="nc" id="L298">        List&lt;AuditLogEntry&gt; entries = buildEntriesForBatch(statements, queries, state, options, queryTime);</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        for (AuditLogEntry auditLogEntry : entries)</span>
        {
<span class="nc" id="L301">            log(auditLogEntry);</span>
<span class="nc" id="L302">        }</span>
<span class="nc" id="L303">    }</span>

    public void batchFailure(BatchStatement.Type batchType, List&lt;? extends CQLStatement&gt; statements, List&lt;String&gt; queries, List&lt;List&lt;ByteBuffer&gt;&gt; values, QueryOptions options, QueryState state, Exception cause)
    {
<span class="nc" id="L307">        String auditMessage = String.format(&quot;BATCH of %d statements at consistency %s&quot;, statements.size(), options.getConsistency());</span>
<span class="nc" id="L308">        AuditLogEntry entry = new AuditLogEntry.Builder(state).setOperation(auditMessage)</span>
<span class="nc" id="L309">                                                              .setOptions(options)</span>
<span class="nc" id="L310">                                                              .setType(AuditLogEntryType.BATCH)</span>
<span class="nc" id="L311">                                                              .build();</span>
<span class="nc" id="L312">        log(entry, cause, queries);</span>
<span class="nc" id="L313">    }</span>

    private static List&lt;AuditLogEntry&gt; buildEntriesForBatch(List&lt;? extends CQLStatement&gt; statements, List&lt;String&gt; queries, QueryState state, QueryOptions options, long queryStartTimeMillis)
    {
<span class="nc" id="L317">        List&lt;AuditLogEntry&gt; auditLogEntries = new ArrayList&lt;&gt;(statements.size() + 1);</span>
<span class="nc" id="L318">        UUID batchId = UUID.randomUUID();</span>
<span class="nc" id="L319">        String queryString = String.format(&quot;BatchId:[%s] - BATCH of [%d] statements&quot;, batchId, statements.size());</span>
<span class="nc" id="L320">        AuditLogEntry entry = new AuditLogEntry.Builder(state)</span>
<span class="nc" id="L321">                              .setOperation(queryString)</span>
<span class="nc" id="L322">                              .setOptions(options)</span>
<span class="nc" id="L323">                              .setTimestamp(queryStartTimeMillis)</span>
<span class="nc" id="L324">                              .setBatch(batchId)</span>
<span class="nc" id="L325">                              .setType(AuditLogEntryType.BATCH)</span>
<span class="nc" id="L326">                              .build();</span>
<span class="nc" id="L327">        auditLogEntries.add(entry);</span>

<span class="nc bnc" id="L329" title="All 2 branches missed.">        for (int i = 0; i &lt; statements.size(); i++)</span>
        {
<span class="nc" id="L331">            CQLStatement statement = statements.get(i);</span>
<span class="nc" id="L332">            entry = new AuditLogEntry.Builder(state)</span>
<span class="nc" id="L333">                    .setType(statement.getAuditLogContext().auditLogEntryType)</span>
<span class="nc" id="L334">                    .setOperation(queries.get(i))</span>
<span class="nc" id="L335">                    .setTimestamp(queryStartTimeMillis)</span>
<span class="nc" id="L336">                    .setScope(statement)</span>
<span class="nc" id="L337">                    .setKeyspace(state, statement)</span>
<span class="nc" id="L338">                    .setOptions(options)</span>
<span class="nc" id="L339">                    .setBatch(batchId)</span>
<span class="nc" id="L340">                    .build();</span>
<span class="nc" id="L341">            auditLogEntries.add(entry);</span>
        }

<span class="nc" id="L344">        return auditLogEntries;</span>
    }

    public void prepareSuccess(CQLStatement statement, String query, QueryState state, long queryTime, ResultMessage.Prepared response)
    {
<span class="nc" id="L349">        AuditLogEntry entry = new AuditLogEntry.Builder(state).setOperation(query)</span>
<span class="nc" id="L350">                                                              .setType(AuditLogEntryType.PREPARE_STATEMENT)</span>
<span class="nc" id="L351">                                                              .setScope(statement)</span>
<span class="nc" id="L352">                                                              .setKeyspace(statement)</span>
<span class="nc" id="L353">                                                              .build();</span>
<span class="nc" id="L354">        log(entry);</span>
<span class="nc" id="L355">    }</span>

    public void prepareFailure(@Nullable CQLStatement stmt, @Nullable String query, QueryState state, Exception cause)
    {
<span class="nc" id="L359">        AuditLogEntry entry = new AuditLogEntry.Builder(state).setOperation(query)</span>
//                                                              .setKeyspace(keyspace) // todo: do we need this? very much special case compared to the others
<span class="nc" id="L361">                                                              .setType(AuditLogEntryType.PREPARE_STATEMENT)</span>
<span class="nc" id="L362">                                                              .build();</span>
<span class="nc" id="L363">        log(entry, cause);</span>
<span class="nc" id="L364">    }</span>

    public void authSuccess(QueryState state)
    {
<span class="nc" id="L368">        AuditLogEntry entry = new AuditLogEntry.Builder(state).setOperation(&quot;LOGIN SUCCESSFUL&quot;)</span>
<span class="nc" id="L369">                                                              .setType(AuditLogEntryType.LOGIN_SUCCESS)</span>
<span class="nc" id="L370">                                                              .build();</span>
<span class="nc" id="L371">        log(entry);</span>
<span class="nc" id="L372">    }</span>

    public void authFailure(QueryState state, Exception cause)
    {
<span class="nc" id="L376">        AuditLogEntry entry = new AuditLogEntry.Builder(state).setOperation(&quot;LOGIN FAILURE&quot;)</span>
<span class="nc" id="L377">                                                              .setType(AuditLogEntryType.LOGIN_ERROR)</span>
<span class="nc" id="L378">                                                              .build();</span>
<span class="nc" id="L379">        log(entry, cause);</span>
<span class="nc" id="L380">    }</span>

    private String obfuscatePasswordInformation(Exception e, List&lt;String&gt; queries)
    {
        // A syntax error may reveal the password in the form of 'line 1:33 mismatched input 'secret_password''
<span class="nc bnc" id="L385" title="All 6 branches missed.">        if (e instanceof SyntaxException &amp;&amp; queries != null &amp;&amp; !queries.isEmpty())</span>
        {
<span class="nc bnc" id="L387" title="All 2 branches missed.">            for (String query : queries)</span>
            {
<span class="nc bnc" id="L389" title="All 2 branches missed.">                if (query.toLowerCase().contains(PasswordObfuscator.PASSWORD_TOKEN))</span>
<span class="nc" id="L390">                    return &quot;Syntax Exception. Obscured for security reasons.&quot;;</span>
<span class="nc" id="L391">            }</span>
        }

<span class="nc" id="L394">        return PasswordObfuscator.obfuscate(e.getMessage());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>