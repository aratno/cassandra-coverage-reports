<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReplicaCollection.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.locator</a> &gt; <span class="el_source">ReplicaCollection.java</span></div><h1>ReplicaCollection.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.locator;

import java.util.Comparator;
import java.util.Iterator;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Stream;

/**
 * A collection like class for Replica objects. Represents both a well defined order on the contained Replica objects,
 * and efficient methods for accessing the contained Replicas, directly and as a projection onto their endpoints and ranges.
 */
public interface ReplicaCollection&lt;C extends ReplicaCollection&lt;C&gt;&gt; extends Iterable&lt;Replica&gt;
{
    /**
     * @return a Set of the endpoints of the contained Replicas.
     * Iteration order is maintained where there is a 1:1 relationship between endpoint and Replica
     * Typically this collection offers O(1) access methods, and this is true for all but ReplicaList.
     */
    public abstract Set&lt;InetAddressAndPort&gt; endpoints();

    /**
     * @param i a value in the range [0..size())
     * @return the i'th Replica, in our iteration order
     */
    public abstract Replica get(int i);

    /**
     * @return the number of Replica contained
     */
    public abstract int size();

    /**
     * @return true iff size() == 0
     */
    public abstract boolean isEmpty();

    /**
     * @return true iff a Replica in this collection is equal to the provided Replica.
     * Typically this method is expected to take O(1) time, and this is true for all but ReplicaList.
     */
    public abstract boolean contains(Replica replica);

    /**
     * @return the number of replicas that match the predicate
     */
    public abstract int count(Predicate&lt;? super Replica&gt; predicate);

    /**
     * @return a *eagerly constructed* copy of this collection containing the Replica that match the provided predicate.
     * An effort will be made to either return ourself, or a subList, where possible.
     * It is guaranteed that no changes to any upstream Builder will affect the state of the result.
     */
    public abstract C filter(Predicate&lt;? super Replica&gt; predicate);

    /**
     * @return a *eagerly constructed* copy of this collection containing the Replica that match the provided predicate.
     * An effort will be made to either return ourself, or a subList, where possible.
     * It is guaranteed that no changes to any upstream Builder will affect the state of the result.
     * Only the first maxSize items will be returned.
     */
    public abstract C filter(Predicate&lt;? super Replica&gt; predicate, int maxSize);

    /**
     * @return a *lazily constructed* Iterable over this collection, containing the Replica that match the provided predicate.
     */
    public abstract Iterable&lt;Replica&gt; filterLazily(Predicate&lt;? super Replica&gt; predicate);

    /**
     * @return a *lazily constructed* Iterable over this collection, containing the Replica that match the provided predicate.
     * Only the first maxSize matching items will be returned.
     */
    public abstract Iterable&lt;Replica&gt; filterLazily(Predicate&lt;? super Replica&gt; predicate, int maxSize);

    /**
     * @return an *eagerly constructed* copy of this collection containing the Replica at positions [start..end);
     * An effort will be made to either return ourself, or a subList, where possible.
     * It is guaranteed that no changes to any upstream Builder will affect the state of the result.
     */
    public abstract C subList(int start, int end);

    /**
     * @return an *eagerly constructed* copy of this collection containing the Replica re-ordered according to this comparator
     * It is guaranteed that no changes to any upstream Builder will affect the state of the result.
     */
    public abstract C sorted(Comparator&lt;? super Replica&gt; comparator);

    public abstract Iterator&lt;Replica&gt; iterator();
    public abstract Stream&lt;Replica&gt; stream();

    public abstract boolean equals(Object o);
    public abstract int hashCode();
    public abstract String toString();

    /**
     * A mutable (append-only) extension of a ReplicaCollection.
     * All methods besides add() will return an immutable snapshot of the collection, or the matching items.
     */
    public interface Builder&lt;C extends ReplicaCollection&lt;C&gt;&gt; extends ReplicaCollection&lt;C&gt;
    {
        /**
         * @return an Immutable clone that assumes this Builder will never be modified again,
         * so its contents can be reused.
         *
         * This Builder should enforce that it is no longer modified.
         */
        public C build();

        /**
         * @return an Immutable clone that assumes this Builder will be modified again
         */
        public C snapshot();

        /**
         * Passed to add() and addAll() as ignoreConflicts parameter. The meaning of conflict varies by collection type
         * (for Endpoints, it is a duplicate InetAddressAndPort; for RangesAtEndpoint it is a duplicate Range).
         */
<span class="fc" id="L136">        enum Conflict</span>
        {
            /** fail on addition of any such conflict */
<span class="fc" id="L139">            NONE,</span>
            /** fail on addition of any such conflict where the contents differ (first occurrence and position wins) */
<span class="fc" id="L141">            DUPLICATE,</span>
            /** ignore all conflicts (the first occurrence and position wins) */
<span class="fc" id="L143">            ALL</span>
        }

        /**
         * @param replica add this replica to the end of the collection
         * @param ignoreConflict conflicts to ignore, see {@link Conflict}
         */
        Builder&lt;C&gt; add(Replica replica, Conflict ignoreConflict);

        default public Builder&lt;C&gt; add(Replica replica)
        {
<span class="fc" id="L154">            return add(replica, Conflict.NONE);</span>
        }

        default public Builder&lt;C&gt; addAll(Iterable&lt;Replica&gt; replicas, Conflict ignoreConflicts)
        {
<span class="nc bnc" id="L159" title="All 2 branches missed.">            for (Replica replica : replicas)</span>
<span class="nc" id="L160">                add(replica, ignoreConflicts);</span>
<span class="nc" id="L161">            return this;</span>
        }

        default public Builder&lt;C&gt; addAll(Iterable&lt;Replica&gt; replicas)
        {
<span class="nc" id="L166">            return addAll(replicas, Conflict.NONE);</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>