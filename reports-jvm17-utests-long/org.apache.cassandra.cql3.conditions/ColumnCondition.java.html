<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ColumnCondition.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.cql3.conditions</a> &gt; <span class="el_source">ColumnCondition.java</span></div><h1>ColumnCondition.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.cql3.conditions;

import java.nio.ByteBuffer;
import java.util.*;

import com.google.common.collect.Iterators;

import org.apache.cassandra.cql3.*;
import org.apache.cassandra.cql3.Term.Terminal;
import org.apache.cassandra.cql3.functions.Function;
import org.apache.cassandra.db.rows.*;
import org.apache.cassandra.db.marshal.*;
import org.apache.cassandra.schema.ColumnMetadata;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.transport.ProtocolVersion;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;

import static org.apache.cassandra.cql3.statements.RequestValidations.*;

/**
 * A CQL3 condition on the value of a column or collection element.  For example, &quot;UPDATE .. IF a = 0&quot;.
 */
public abstract class ColumnCondition
{
    public final ColumnMetadata column;
    public final Operator operator;
    private final Terms terms;

    private ColumnCondition(ColumnMetadata column, Operator op, Terms terms)
<span class="nc" id="L49">    {</span>
<span class="nc" id="L50">        this.column = column;</span>
<span class="nc" id="L51">        this.operator = op;</span>
<span class="nc" id="L52">        this.terms = terms;</span>
<span class="nc" id="L53">    }</span>

    /**
     * Adds functions for the bind variables of this operation.
     *
     * @param functions the list of functions to get add
     */
    public void addFunctionsTo(List&lt;Function&gt; functions)
    {
<span class="nc" id="L62">        terms.addFunctionsTo(functions);</span>
<span class="nc" id="L63">    }</span>

    /**
     * Collects the column specification for the bind variables of this operation.
     *
     * @param boundNames the list of column specification where to collect the
     * bind variables of this term in.
     */
    public void collectMarkerSpecification(VariableSpecifications boundNames)
    {
<span class="nc" id="L73">        terms.collectMarkerSpecification(boundNames);</span>
<span class="nc" id="L74">    }</span>

    public abstract ColumnCondition.Bound bind(QueryOptions options);

    protected final List&lt;ByteBuffer&gt; bindAndGetTerms(QueryOptions options)
    {
<span class="nc" id="L80">        return filterUnsetValuesIfNeeded(checkValues(terms.bindAndGet(options)));</span>
    }

    protected final List&lt;Terminal&gt; bindTerms(QueryOptions options)
    {
<span class="nc" id="L85">        return filterUnsetValuesIfNeeded(checkValues(terms.bind(options)));</span>
    }

    /**
     * Checks that the output of a bind operations on {@code Terms} is a valid one.
     * @param values the list to check
     * @return the input list
     */
    private &lt;T&gt; List&lt;T&gt; checkValues(List&lt;T&gt; values)
    {
<span class="nc bnc" id="L95" title="All 4 branches missed.">        checkFalse(values == null &amp;&amp; operator.isIN(), &quot;Invalid null list in IN condition&quot;);</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">        checkFalse(values == Terms.UNSET_LIST, &quot;Invalid 'unset' value in condition&quot;);</span>
<span class="nc" id="L97">        return values;</span>
    }

    private &lt;T&gt; List&lt;T&gt; filterUnsetValuesIfNeeded(List&lt;T&gt; values)
    {
<span class="nc bnc" id="L102" title="All 2 branches missed.">        if (!operator.isIN())</span>
<span class="nc" id="L103">            return values;</span>

<span class="nc" id="L105">        List&lt;T&gt; filtered = new ArrayList&lt;&gt;(values.size());</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">        for (int i = 0, m = values.size(); i &lt; m; i++)</span>
        {
<span class="nc" id="L108">            T value = values.get(i);</span>
            // The value can be ByteBuffer or Constants.Value so we need to check the 2 type of UNSET
<span class="nc bnc" id="L110" title="All 4 branches missed.">            if (value != ByteBufferUtil.UNSET_BYTE_BUFFER &amp;&amp; value != Constants.UNSET_VALUE)</span>
<span class="nc" id="L111">                filtered.add(value);</span>
        }
<span class="nc" id="L113">        return filtered;</span>
    }

    /**
     * Simple condition (e.g. &lt;pre&gt;IF v = 1&lt;/pre&gt;).
     */
    private static final class SimpleColumnCondition extends ColumnCondition
    {
        public SimpleColumnCondition(ColumnMetadata column, Operator op, Terms values)
        {
            super(column, op, values);
        }

        public Bound bind(QueryOptions options)
        {
            if (column.type.isCollection() &amp;&amp; column.type.isMultiCell())
                return new MultiCellCollectionBound(column, operator, bindTerms(options));

            if (column.type.isUDT() &amp;&amp; column.type.isMultiCell())
                return new MultiCellUdtBound(column, operator, bindAndGetTerms(options), options.getProtocolVersion());

            return new SimpleBound(column, operator, bindAndGetTerms(options));
        }
    }

    /**
     * A condition on a collection element (e.g. &lt;pre&gt;IF l[1] = 1&lt;/pre&gt;).
     */
    private static class CollectionElementCondition extends ColumnCondition
    {
        private final Term collectionElement;

        public CollectionElementCondition(ColumnMetadata column, Term collectionElement, Operator op, Terms values)
        {
            super(column, op, values);
            this.collectionElement = collectionElement;
        }

        public void addFunctionsTo(List&lt;Function&gt; functions)
        {
            collectionElement.addFunctionsTo(functions);
            super.addFunctionsTo(functions);
        }

        public void collectMarkerSpecification(VariableSpecifications boundNames)
        {
            collectionElement.collectMarkerSpecification(boundNames);
            super.collectMarkerSpecification(boundNames);
        }

        public Bound bind(QueryOptions options)
        {
            return new ElementAccessBound(column, collectionElement.bindAndGet(options), operator, bindAndGetTerms(options));
        }
    }

    /**
     *  A condition on a UDT field (e.g. &lt;pre&gt;IF v.a = 1&lt;/pre&gt;).
     */
    private final static class UDTFieldCondition extends ColumnCondition
    {
        private final FieldIdentifier udtField;

        public UDTFieldCondition(ColumnMetadata column, FieldIdentifier udtField, Operator op, Terms values)
        {
            super(column, op, values);
            assert udtField != null;
            this.udtField = udtField;
        }

        public Bound bind(QueryOptions options)
        {
            return new UDTFieldAccessBound(column, udtField, operator, bindAndGetTerms(options));
        }
    }

    /**
     *  A regular column, simple condition.
     */
    public static ColumnCondition condition(ColumnMetadata column, Operator op, Terms terms)
    {
<span class="nc" id="L194">        return new SimpleColumnCondition(column, op, terms);</span>
    }

    /**
     * A collection column, simple condition.
     */
    public static ColumnCondition condition(ColumnMetadata column, Term collectionElement, Operator op, Terms terms)
    {
<span class="nc" id="L202">        return new CollectionElementCondition(column, collectionElement, op, terms);</span>
    }

    /**
     * A UDT column, simple condition.
     */
    public static ColumnCondition condition(ColumnMetadata column, FieldIdentifier udtField, Operator op, Terms terms)
    {
<span class="nc" id="L210">        return new UDTFieldCondition(column, udtField, op, terms);</span>
    }

    public static abstract class Bound
    {
        public final ColumnMetadata column;
        public final Operator comparisonOperator;

        protected Bound(ColumnMetadata column, Operator operator)
        {
            this.column = column;
            // If the operator is an IN we want to compare the value using an EQ.
            this.comparisonOperator = operator.isIN() ? Operator.EQ : operator;
        }

        /**
         * Validates whether this condition applies to {@code current}.
         */
        public abstract boolean appliesTo(Row row);

        public ByteBuffer getCollectionElementValue()
        {
            return null;
        }

        /** Returns true if the operator is satisfied (i.e. &quot;otherValue operator value == true&quot;), false otherwise. */
        protected static boolean compareWithOperator(Operator operator, AbstractType&lt;?&gt; type, ByteBuffer value, ByteBuffer otherValue)
        {
            if (value == ByteBufferUtil.UNSET_BYTE_BUFFER)
                throw invalidRequest(&quot;Invalid 'unset' value in condition&quot;);

            if (value == null)
            {
                switch (operator)
                {
                    case EQ:
                        return otherValue == null;
                    case NEQ:
                        return otherValue != null;
                    default:
                        throw invalidRequest(&quot;Invalid comparison with null for operator \&quot;%s\&quot;&quot;, operator);
                }
            }
            else if (otherValue == null)
            {
                // the condition value is not null, so only NEQ can return true
                return operator == Operator.NEQ;
            }
            return operator.isSatisfiedBy(type, otherValue, value);
        }
    }

    protected static final Cell&lt;?&gt; getCell(Row row, ColumnMetadata column)
    {
        // If we're asking for a given cell, and we didn't got any row from our read, it's
        // the same as not having said cell.
<span class="nc bnc" id="L266" title="All 2 branches missed.">        return row == null ? null : row.getCell(column);</span>
    }

    protected static final Cell&lt;?&gt; getCell(Row row, ColumnMetadata column, CellPath path)
    {
        // If we're asking for a given cell, and we didn't got any row from our read, it's
        // the same as not having said cell.
<span class="nc bnc" id="L273" title="All 2 branches missed.">        return row == null ? null : row.getCell(column, path);</span>
    }

    protected static final Iterator&lt;Cell&lt;?&gt;&gt; getCells(Row row, ColumnMetadata column)
    {
        // If we're asking for a complex cells, and we didn't got any row from our read, it's
        // the same as not having any cells for that column.
<span class="nc bnc" id="L280" title="All 2 branches missed.">        if (row == null)</span>
<span class="nc" id="L281">            return Collections.emptyIterator();</span>

<span class="nc" id="L283">        ComplexColumnData complexData = row.getComplexColumnData(column);</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">        return complexData == null ? Collections.&lt;Cell&lt;?&gt;&gt;emptyIterator() : complexData.iterator();</span>
    }

    protected static final boolean evaluateComparisonWithOperator(int comparison, Operator operator)
    {
        // called when comparison != 0
<span class="nc bnc" id="L290" title="All 5 branches missed.">        switch (operator)</span>
        {
            case EQ:
<span class="nc" id="L293">                return false;</span>
            case LT:
            case LTE:
<span class="nc bnc" id="L296" title="All 2 branches missed.">                return comparison &lt; 0;</span>
            case GT:
            case GTE:
<span class="nc bnc" id="L299" title="All 2 branches missed.">                return comparison &gt; 0;</span>
            case NEQ:
<span class="nc" id="L301">                return true;</span>
            default:
<span class="nc" id="L303">                throw new AssertionError();</span>
        }
    }

    /**
     * A condition on a single non-collection column.
     */
    private static final class SimpleBound extends Bound
    {
        /**
         * The condition values
         */
        private final List&lt;ByteBuffer&gt; values;

        private SimpleBound(ColumnMetadata column, Operator operator, List&lt;ByteBuffer&gt; values)
        {
            super(column, operator);
            this.values = values;
        }

        @Override
        public boolean appliesTo(Row row)
        {
            return isSatisfiedBy(rowValue(row));
        }

        private ByteBuffer rowValue(Row row)
        {
            Cell&lt;?&gt; c = getCell(row, column);
            return c == null ? null : c.buffer();
        }

        private boolean isSatisfiedBy(ByteBuffer rowValue)
        {
            for (ByteBuffer value : values)
            {
                if (compareWithOperator(comparisonOperator, column.type, value, rowValue))
                    return true;
            }
            return false;
        }
    }

    /**
     * A condition on an element of a collection column.
     */
    private static final class ElementAccessBound extends Bound
    {
        /**
         * The collection element
         */
        private final ByteBuffer collectionElement;

        /**
         * The conditions values.
         */
        private final List&lt;ByteBuffer&gt; values;

        private ElementAccessBound(ColumnMetadata column,
                                   ByteBuffer collectionElement,
                                   Operator operator,
                                   List&lt;ByteBuffer&gt; values)
        {
            super(column, operator);

            this.collectionElement = collectionElement;
            this.values = values;
        }

        @Override
        public boolean appliesTo(Row row)
        {
            boolean isMap = column.type instanceof MapType;

            if (collectionElement == null)
                throw invalidRequest(&quot;Invalid null value for %s element access&quot;, isMap ? &quot;map&quot; : &quot;list&quot;);

            if (isMap)
            {
                MapType&lt;?, ?&gt; mapType = (MapType&lt;?, ?&gt;) column.type;
                ByteBuffer rowValue = rowMapValue(mapType, row);
                return isSatisfiedBy(mapType.getKeysType(), rowValue);
            }

            ListType&lt;?&gt; listType = (ListType&lt;?&gt;) column.type;
            ByteBuffer rowValue = rowListValue(listType, row);
            return isSatisfiedBy(listType.getElementsType(), rowValue);
        }

        private ByteBuffer rowMapValue(MapType&lt;?, ?&gt; type, Row row)
        {
            if (column.type.isMultiCell())
            {
                Cell&lt;?&gt; cell = getCell(row, column, CellPath.create(collectionElement));
                return cell == null ? null : cell.buffer();
            }

            Cell&lt;?&gt; cell = getCell(row, column);
            return cell == null
                    ? null
                    : type.getSerializer().getSerializedValue(cell.buffer(), collectionElement, type.getKeysType());
        }

        private ByteBuffer rowListValue(ListType&lt;?&gt; type, Row row)
        {
            if (column.type.isMultiCell())
                return cellValueAtIndex(getCells(row, column), getListIndex(collectionElement));

            Cell&lt;?&gt; cell = getCell(row, column);
            return cell == null
                    ? null
                    : type.getSerializer().getElement(cell.buffer(), getListIndex(collectionElement));
        }

        private static ByteBuffer cellValueAtIndex(Iterator&lt;Cell&lt;?&gt;&gt; iter, int index)
        {
            int adv = Iterators.advance(iter, index);
            if (adv == index &amp;&amp; iter.hasNext())
                return iter.next().buffer();

            return null;
        }

        private boolean isSatisfiedBy(AbstractType&lt;?&gt; valueType, ByteBuffer rowValue)
        {
            for (ByteBuffer value : values)
            {
                if (compareWithOperator(comparisonOperator, valueType, value, rowValue))
                    return true;
            }
            return false;
        }

        @Override
        public ByteBuffer getCollectionElementValue()
        {
            return collectionElement;
        }

        private static int getListIndex(ByteBuffer collectionElement)
        {
            int idx = ByteBufferUtil.toInt(collectionElement);
            checkFalse(idx &lt; 0, &quot;Invalid negative list index %d&quot;, idx);
            return idx;
        }
    }

    /**
     * A condition on an entire collection column.
     */
    private static final class MultiCellCollectionBound extends Bound
    {
        private final List&lt;Term.Terminal&gt; values;

        public MultiCellCollectionBound(ColumnMetadata column, Operator operator, List&lt;Term.Terminal&gt; values)
        {
            super(column, operator);
            assert column.type.isMultiCell();
            this.values = values;
        }

        public boolean appliesTo(Row row)
        {
            CollectionType&lt;?&gt; type = (CollectionType&lt;?&gt;)column.type;

            // copy iterator contents so that we can properly reuse them for each comparison with an IN value
            for (Term.Terminal value : values)
            {
                Iterator&lt;Cell&lt;?&gt;&gt; iter = getCells(row, column);
                if (value == null)
                {
                    if (comparisonOperator == Operator.EQ)
                    {
                        if (!iter.hasNext())
                            return true;
                        continue;
                    }

                    if (comparisonOperator == Operator.NEQ)
                        return iter.hasNext();

                    throw invalidRequest(&quot;Invalid comparison with null for operator \&quot;%s\&quot;&quot;, comparisonOperator);
                }

                if (valueAppliesTo(type, iter, value, comparisonOperator))
                    return true;
            }
            return false;
        }

        private static boolean valueAppliesTo(CollectionType&lt;?&gt; type, Iterator&lt;Cell&lt;?&gt;&gt; iter, Term.Terminal value, Operator operator)
        {
            if (value == null)
                return !iter.hasNext();

            if(operator.isContains() || operator.isContainsKey())
                return containsAppliesTo(type, iter, value.get(ProtocolVersion.CURRENT), operator);

            switch (type.kind)
            {
                case LIST:
                    List&lt;ByteBuffer&gt; valueList = ((Lists.Value) value).elements;
                    return listAppliesTo((ListType&lt;?&gt;)type, iter, valueList, operator);
                case SET:
                    Set&lt;ByteBuffer&gt; valueSet = ((Sets.Value) value).elements;
                    return setAppliesTo((SetType&lt;?&gt;)type, iter, valueSet, operator);
                case MAP:
                    Map&lt;ByteBuffer, ByteBuffer&gt; valueMap = ((Maps.Value) value).map;
                    return mapAppliesTo((MapType&lt;?, ?&gt;)type, iter, valueMap, operator);
            }
            throw new AssertionError();
        }

        private static boolean setOrListAppliesTo(AbstractType&lt;?&gt; type, Iterator&lt;Cell&lt;?&gt;&gt; iter, Iterator&lt;ByteBuffer&gt; conditionIter, Operator operator, boolean isSet)
        {
            while(iter.hasNext())
            {
                if (!conditionIter.hasNext())
                    return (operator == Operator.GT) || (operator == Operator.GTE) || (operator == Operator.NEQ);

                // for lists we use the cell value; for sets we use the cell name
                ByteBuffer cellValue = isSet ? iter.next().path().get(0) : iter.next().buffer();
                int comparison = type.compare(cellValue, conditionIter.next());
                if (comparison != 0)
                    return evaluateComparisonWithOperator(comparison, operator);
            }

            if (conditionIter.hasNext())
                return (operator == Operator.LT) || (operator == Operator.LTE) || (operator == Operator.NEQ);

            // they're equal
            return operator == Operator.EQ || operator == Operator.LTE || operator == Operator.GTE;
        }

        private static boolean listAppliesTo(ListType&lt;?&gt; type, Iterator&lt;Cell&lt;?&gt;&gt; iter, List&lt;ByteBuffer&gt; elements, Operator operator)
        {
            return setOrListAppliesTo(type.getElementsType(), iter, elements.iterator(), operator, false);
        }

        private static boolean setAppliesTo(SetType&lt;?&gt; type, Iterator&lt;Cell&lt;?&gt;&gt; iter, Set&lt;ByteBuffer&gt; elements, Operator operator)
        {
            ArrayList&lt;ByteBuffer&gt; sortedElements = new ArrayList&lt;&gt;(elements);
            Collections.sort(sortedElements, type.getElementsType());
            return setOrListAppliesTo(type.getElementsType(), iter, sortedElements.iterator(), operator, true);
        }

        private static boolean mapAppliesTo(MapType&lt;?, ?&gt; type, Iterator&lt;Cell&lt;?&gt;&gt; iter, Map&lt;ByteBuffer, ByteBuffer&gt; elements, Operator operator)
        {
            Iterator&lt;Map.Entry&lt;ByteBuffer, ByteBuffer&gt;&gt; conditionIter = elements.entrySet().iterator();
            while(iter.hasNext())
            {
                if (!conditionIter.hasNext())
                    return (operator == Operator.GT) || (operator == Operator.GTE) || (operator == Operator.NEQ);

                Map.Entry&lt;ByteBuffer, ByteBuffer&gt; conditionEntry = conditionIter.next();
                Cell&lt;?&gt; c = iter.next();

                // compare the keys
                int comparison = type.getKeysType().compare(c.path().get(0), conditionEntry.getKey());
                if (comparison != 0)
                    return evaluateComparisonWithOperator(comparison, operator);

                // compare the values
                comparison = type.getValuesType().compare(c.buffer(), conditionEntry.getValue());
                if (comparison != 0)
                    return evaluateComparisonWithOperator(comparison, operator);
            }

            if (conditionIter.hasNext())
                return (operator == Operator.LT) || (operator == Operator.LTE) || (operator == Operator.NEQ);

            // they're equal
            return operator == Operator.EQ || operator == Operator.LTE || operator == Operator.GTE;
        }
    }

    private static boolean containsAppliesTo(CollectionType&lt;?&gt; type, Iterator&lt;Cell&lt;?&gt;&gt; iter, ByteBuffer value, Operator operator)
    {
        AbstractType&lt;?&gt; compareType;
<span class="nc bnc" id="L582" title="All 4 branches missed.">        switch (type.kind)</span>
        {
            case LIST:
<span class="nc" id="L585">                compareType = ((ListType&lt;?&gt;)type).getElementsType();</span>
<span class="nc" id="L586">                break;</span>
            case SET:
<span class="nc" id="L588">                compareType = ((SetType&lt;?&gt;)type).getElementsType();</span>
<span class="nc" id="L589">                break;</span>
            case MAP:
<span class="nc bnc" id="L591" title="All 2 branches missed.">                compareType = operator.isContainsKey() ? ((MapType&lt;?, ?&gt;)type).getKeysType() : ((MapType&lt;?, ?&gt;)type).getValuesType();</span>
<span class="nc" id="L592">                break;</span>
            default:
<span class="nc" id="L594">                throw new AssertionError();</span>
        }
<span class="nc bnc" id="L596" title="All 6 branches missed.">        boolean appliesToSetOrMapKeys = (type.kind == CollectionType.Kind.SET || type.kind == CollectionType.Kind.MAP &amp;&amp; operator.isContainsKey());</span>
<span class="nc" id="L597">        return containsAppliesTo(compareType, iter, value, appliesToSetOrMapKeys);</span>
    }

    private static boolean containsAppliesTo(AbstractType&lt;?&gt; type, Iterator&lt;Cell&lt;?&gt;&gt; iter, ByteBuffer value, Boolean appliesToSetOrMapKeys)
    {
<span class="nc bnc" id="L602" title="All 2 branches missed.">        while(iter.hasNext())</span>
        {
            // for lists and map values we use the cell value; for sets and map keys we use the cell name
<span class="nc bnc" id="L605" title="All 2 branches missed.">            ByteBuffer cellValue = appliesToSetOrMapKeys ? iter.next().path().get(0) : iter.next().buffer();</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">            if(type.compare(cellValue, value) == 0)</span>
<span class="nc" id="L607">                return true;</span>
<span class="nc" id="L608">        }</span>
<span class="nc" id="L609">        return false;</span>
    }

    /**
     * A condition on a UDT field
     */
    private static final class UDTFieldAccessBound extends Bound
    {
        /**
         * The UDT field.
         */
        private final FieldIdentifier field;

        /**
         * The conditions values.
         */
        private final List&lt;ByteBuffer&gt; values;

        private UDTFieldAccessBound(ColumnMetadata column, FieldIdentifier field, Operator operator, List&lt;ByteBuffer&gt; values)
        {
            super(column, operator);
            assert column.type.isUDT() &amp;&amp; field != null;
            this.field = field;
            this.values = values;
        }

        @Override
        public boolean appliesTo(Row row)
        {
            return isSatisfiedBy(rowValue(row));
        }

        private ByteBuffer rowValue(Row row)
        {
            UserType userType = (UserType) column.type;

            if (column.type.isMultiCell())
            {
                Cell&lt;?&gt; cell = getCell(row, column, userType.cellPathForField(field));
                return cell == null ? null : cell.buffer();
            }

            Cell&lt;?&gt; cell = getCell(row, column);
            return cell == null
                   ? null
                   : userType.split(ByteBufferAccessor.instance, cell.buffer())[userType.fieldPosition(field)];
        }

        private boolean isSatisfiedBy(ByteBuffer rowValue)
        {
            UserType userType = (UserType) column.type;
            int fieldPosition = userType.fieldPosition(field);
            AbstractType&lt;?&gt; valueType = userType.fieldType(fieldPosition);
            for (ByteBuffer value : values)
            {
                if (compareWithOperator(comparisonOperator, valueType, value, rowValue))
                    return true;
            }
            return false;
        }
        
        @Override
        public String toString()
        {
            return ToStringBuilder.reflectionToString(this, ToStringStyle.SHORT_PREFIX_STYLE);
        }
    }

    /**
     * A condition on an entire UDT.
     */
    private static final class MultiCellUdtBound extends Bound
    {
        /**
         * The conditions values.
         */
        private final List&lt;ByteBuffer&gt; values;

        /**
         * The protocol version
         */
        private final ProtocolVersion protocolVersion;

        private MultiCellUdtBound(ColumnMetadata column, Operator op, List&lt;ByteBuffer&gt; values, ProtocolVersion protocolVersion)
        {
            super(column, op);
            assert column.type.isMultiCell();
            this.values = values;
            this.protocolVersion = protocolVersion;
        }

        @Override
        public boolean appliesTo(Row row)
        {
            return isSatisfiedBy(rowValue(row));
        }

        private final ByteBuffer rowValue(Row row)
        {
            UserType userType = (UserType) column.type;
            Iterator&lt;Cell&lt;?&gt;&gt; iter = getCells(row, column);
            return iter.hasNext() ? userType.serializeForNativeProtocol(iter, protocolVersion) : null;
        }

        private boolean isSatisfiedBy(ByteBuffer rowValue)
        {
            for (ByteBuffer value : values)
            {
                if (compareWithOperator(comparisonOperator, column.type, value, rowValue))
                    return true;
            }
            return false;
        }
        
        @Override
        public String toString()
        {
            return ToStringBuilder.reflectionToString(this, ToStringStyle.SHORT_PREFIX_STYLE);
        }
    }

    public static class Raw
    {
        private final Term.Raw value;
        private final List&lt;Term.Raw&gt; inValues;
        private final AbstractMarker.INRaw inMarker;

        // Can be null, only used with the syntax &quot;IF m[e] = ...&quot; (in which case it's 'e')
        private final Term.Raw collectionElement;

        // Can be null, only used with the syntax &quot;IF udt.field = ...&quot; (in which case it's 'field')
        private final FieldIdentifier udtField;

        private final Operator operator;

        private Raw(Term.Raw value, List&lt;Term.Raw&gt; inValues, AbstractMarker.INRaw inMarker, Term.Raw collectionElement,
                    FieldIdentifier udtField, Operator op)
        {
            this.value = value;
            this.inValues = inValues;
            this.inMarker = inMarker;
            this.collectionElement = collectionElement;
            this.udtField = udtField;
            this.operator = op;
        }

        /** A condition on a column. For example: &quot;IF col = 'foo'&quot; */
        public static Raw simpleCondition(Term.Raw value, Operator op)
        {
            return new Raw(value, null, null, null, null, op);
        }

        /** An IN condition on a column. For example: &quot;IF col IN ('foo', 'bar', ...)&quot; */
        public static Raw simpleInCondition(List&lt;Term.Raw&gt; inValues)
        {
            return new Raw(null, inValues, null, null, null, Operator.IN);
        }

        /** An IN condition on a column with a single marker. For example: &quot;IF col IN ?&quot; */
        public static Raw simpleInCondition(AbstractMarker.INRaw inMarker)
        {
            return new Raw(null, null, inMarker, null, null, Operator.IN);
        }

        /** A condition on a collection element. For example: &quot;IF col['key'] = 'foo'&quot; */
        public static Raw collectionCondition(Term.Raw value, Term.Raw collectionElement, Operator op)
        {
            return new Raw(value, null, null, collectionElement, null, op);
        }

        /** An IN condition on a collection element. For example: &quot;IF col['key'] IN ('foo', 'bar', ...)&quot; */
        public static Raw collectionInCondition(Term.Raw collectionElement, List&lt;Term.Raw&gt; inValues)
        {
            return new Raw(null, inValues, null, collectionElement, null, Operator.IN);
        }

        /** An IN condition on a collection element with a single marker. For example: &quot;IF col['key'] IN ?&quot; */
        public static Raw collectionInCondition(Term.Raw collectionElement, AbstractMarker.INRaw inMarker)
        {
            return new Raw(null, null, inMarker, collectionElement, null, Operator.IN);
        }

        /** A condition on a UDT field. For example: &quot;IF col.field = 'foo'&quot; */
        public static Raw udtFieldCondition(Term.Raw value, FieldIdentifier udtField, Operator op)
        {
            return new Raw(value, null, null, null, udtField, op);
        }

        /** An IN condition on a collection element. For example: &quot;IF col.field IN ('foo', 'bar', ...)&quot; */
        public static Raw udtFieldInCondition(FieldIdentifier udtField, List&lt;Term.Raw&gt; inValues)
        {
            return new Raw(null, inValues, null, null, udtField, Operator.IN);
        }

        /** An IN condition on a collection element with a single marker. For example: &quot;IF col.field IN ?&quot; */
        public static Raw udtFieldInCondition(FieldIdentifier udtField, AbstractMarker.INRaw inMarker)
        {
            return new Raw(null, null, inMarker, null, udtField, Operator.IN);
        }

        public ColumnCondition prepare(String keyspace, ColumnMetadata receiver, TableMetadata cfm)
        {
            if (receiver.type instanceof CounterColumnType)
                throw invalidRequest(&quot;Conditions on counters are not supported&quot;);

            if (collectionElement != null)
            {
                if (!(receiver.type.isCollection()))
                    throw invalidRequest(&quot;Invalid element access syntax for non-collection column %s&quot;, receiver.name);

                ColumnSpecification elementSpec, valueSpec;
                switch ((((CollectionType&lt;?&gt;) receiver.type).kind))
                {
                    case LIST:
                        elementSpec = Lists.indexSpecOf(receiver);
                        valueSpec = Lists.valueSpecOf(receiver);
                        break;
                    case MAP:
                        elementSpec = Maps.keySpecOf(receiver);
                        valueSpec = Maps.valueSpecOf(receiver);
                        break;
                    case SET:
                        throw invalidRequest(&quot;Invalid element access syntax for set column %s&quot;, receiver.name);
                    default:
                        throw new AssertionError();
                }

                validateOperationOnDurations(valueSpec.type);
                return condition(receiver, collectionElement.prepare(keyspace, elementSpec), operator, prepareTerms(keyspace, valueSpec));
            }

            if (udtField != null)
            {
                UserType userType = (UserType) receiver.type;
                int fieldPosition = userType.fieldPosition(udtField);
                if (fieldPosition == -1)
                    throw invalidRequest(&quot;Unknown field %s for column %s&quot;, udtField, receiver.name);

                ColumnSpecification fieldReceiver = UserTypes.fieldSpecOf(receiver, fieldPosition);
                validateOperationOnDurations(fieldReceiver.type);
                return condition(receiver, udtField, operator, prepareTerms(keyspace, fieldReceiver));
            }

            validateOperationOnDurations(receiver.type);
            return condition(receiver, operator, prepareTerms(keyspace, receiver));
        }

        private Terms prepareTerms(String keyspace, ColumnSpecification receiver)
        {
            checkFalse(operator.isContainsKey() &amp;&amp; !(receiver.type instanceof MapType), &quot;Cannot use CONTAINS KEY on non-map column %s&quot;, receiver.name);
            checkFalse(operator.isContains() &amp;&amp; !(receiver.type.isCollection()), &quot;Cannot use CONTAINS on non-collection column %s&quot;, receiver.name);

            if (operator.isIN())
            {
                return inValues == null ? Terms.ofListMarker(inMarker.prepare(keyspace, receiver), receiver.type)
                                        : Terms.of(prepareTerms(keyspace, receiver, inValues));
            }

            if (operator.isContains() || operator.isContainsKey())
                receiver = ((CollectionType&lt;?&gt;) receiver.type).makeCollectionReceiver(receiver, operator.isContainsKey());

            return Terms.of(value.prepare(keyspace, receiver));
        }

        private static List&lt;Term&gt; prepareTerms(String keyspace, ColumnSpecification receiver, List&lt;Term.Raw&gt; raws)
        {
            List&lt;Term&gt; terms = new ArrayList&lt;&gt;(raws.size());
            for (int i = 0, m = raws.size(); i &lt; m; i++)
            {
                Term.Raw raw = raws.get(i);
                terms.add(raw.prepare(keyspace, receiver));
            }
            return terms;
        }

        private void validateOperationOnDurations(AbstractType&lt;?&gt; type)
        {
            if (type.referencesDuration() &amp;&amp; operator.isSlice())
            {
                checkFalse(type.isCollection(), &quot;Slice conditions are not supported on collections containing durations&quot;);
                checkFalse(type.isTuple(), &quot;Slice conditions are not supported on tuples containing durations&quot;);
                checkFalse(type.isUDT(), &quot;Slice conditions are not supported on UDTs containing durations&quot;);
                throw invalidRequest(&quot;Slice conditions ( %s ) are not supported on durations&quot;, operator);
            }
        }

        public Term.Raw getValue()
        {
            return value;
        }

        @Override
        public String toString()
        {
            return ToStringBuilder.reflectionToString(this, ToStringStyle.SHORT_PREFIX_STYLE);
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>