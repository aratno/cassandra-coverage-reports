<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AggregationQueryPager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.service.pager</a> &gt; <span class="el_source">AggregationQueryPager.java</span></div><h1>AggregationQueryPager.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.service.pager;

import java.nio.ByteBuffer;
import java.util.NoSuchElementException;

import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.db.*;
import org.apache.cassandra.db.aggregation.GroupingState;
import org.apache.cassandra.db.filter.DataLimits;
import org.apache.cassandra.db.partitions.PartitionIterator;
import org.apache.cassandra.db.rows.Row;
import org.apache.cassandra.db.rows.RowIterator;
import org.apache.cassandra.service.ClientState;

import static org.apache.cassandra.utils.Clock.Global.nanoTime;

/**
 * {@code QueryPager} that takes care of fetching the pages for aggregation queries.
 * &lt;p&gt;
 * For aggregation/group by queries, the user page size is in number of groups. But each group could be composed of very
 * many rows so to avoid running into OOMs, this pager will page internal queries into sub-pages. So each call to
 * {@link fetchPage} may (transparently) yield multiple internal queries (sub-pages).
 */
public final class AggregationQueryPager implements QueryPager
{
    private final DataLimits limits;

    // The sub-pager, used to retrieve the next sub-page.
    private QueryPager subPager;

    public AggregationQueryPager(QueryPager subPager, DataLimits limits)
<span class="fc" id="L49">    {</span>
<span class="fc" id="L50">        this.subPager = subPager;</span>
<span class="fc" id="L51">        this.limits = limits;</span>
<span class="fc" id="L52">    }</span>

    @Override
    public PartitionIterator fetchPage(int pageSize,
                                       ConsistencyLevel consistency,
                                       ClientState clientState,
                                       long queryStartNanoTime)
    {
<span class="pc bpc" id="L60" title="1 of 2 branches missed.">        if (limits.isGroupByLimit())</span>
<span class="nc" id="L61">            return new GroupByPartitionIterator(pageSize, consistency, clientState, queryStartNanoTime);</span>

<span class="fc" id="L63">        return new AggregationPartitionIterator(pageSize, consistency, clientState, queryStartNanoTime);</span>
    }

    @Override
    public ReadExecutionController executionController()
    {
<span class="nc" id="L69">        return subPager.executionController();</span>
    }

    @Override
    public PartitionIterator fetchPageInternal(int pageSize, ReadExecutionController executionController)
    {
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">        if (limits.isGroupByLimit())</span>
<span class="nc" id="L76">            return new GroupByPartitionIterator(pageSize, executionController, nanoTime());</span>

<span class="fc" id="L78">        return new AggregationPartitionIterator(pageSize, executionController, nanoTime());</span>
    }

    @Override
    public boolean isExhausted()
    {
<span class="fc" id="L84">        return subPager.isExhausted();</span>
    }

    @Override
    public int maxRemaining()
    {
<span class="nc" id="L90">        return subPager.maxRemaining();</span>
    }

    @Override
    public PagingState state()
    {
<span class="nc" id="L96">        return subPager.state();</span>
    }

    @Override
    public QueryPager withUpdatedLimit(DataLimits newLimits)
    {
<span class="nc" id="L102">        throw new UnsupportedOperationException();</span>
    }

    /**
     * &lt;code&gt;PartitionIterator&lt;/code&gt; that automatically fetch a new sub-page of data if needed when the current iterator is
     * exhausted.
     */
    public class GroupByPartitionIterator implements PartitionIterator
    {
        /**
         * The top-level page size in number of groups.
         */
        private final int pageSize;

        // For &quot;normal&quot; queries
        private final ConsistencyLevel consistency;
        private final ClientState clientState;

        // For internal queries
        private final ReadExecutionController executionController;

        /**
         * The &lt;code&gt;PartitionIterator&lt;/code&gt; over the last page retrieved.
         */
        private PartitionIterator partitionIterator;

        /**
         * The next &lt;code&gt;RowIterator&lt;/code&gt; to be returned.
         */
        private RowIterator next;

        /**
         * Specify if all the data have been returned.
         */
        private boolean endOfData;

        /**
         * Keeps track if the partitionIterator has been closed or not.
         */
        private boolean closed;

        /**
         * The key of the last partition processed.
         */
        private ByteBuffer lastPartitionKey;

        /**
         * The clustering of the last row processed
         */
        private Clustering&lt;?&gt; lastClustering;

        /**
         * The initial amount of row remaining
         */
        private int initialMaxRemaining;

        private long queryStartNanoTime;

        public GroupByPartitionIterator(int pageSize,
                                         ConsistencyLevel consistency,
                                         ClientState clientState,
                                        long queryStartNanoTime)
        {
<span class="fc" id="L165">            this(pageSize, consistency, clientState, null, queryStartNanoTime);</span>
<span class="fc" id="L166">        }</span>

        public GroupByPartitionIterator(int pageSize,
                                        ReadExecutionController executionController,
                                        long queryStartNanoTime)
       {
<span class="fc" id="L172">           this(pageSize, null, null, executionController, queryStartNanoTime);</span>
<span class="fc" id="L173">       }</span>

        private GroupByPartitionIterator(int pageSize,
                                         ConsistencyLevel consistency,
                                         ClientState clientState,
                                         ReadExecutionController executionController,
                                         long queryStartNanoTime)
<span class="fc" id="L180">        {</span>
<span class="fc" id="L181">            this.pageSize = handlePagingOff(pageSize);</span>
<span class="fc" id="L182">            this.consistency = consistency;</span>
<span class="fc" id="L183">            this.clientState = clientState;</span>
<span class="fc" id="L184">            this.executionController = executionController;</span>
<span class="fc" id="L185">            this.queryStartNanoTime = queryStartNanoTime;</span>
<span class="fc" id="L186">        }</span>

        private int handlePagingOff(int pageSize)
        {
            // If the paging is off, the pageSize will be &lt;= 0. So we need to replace
            // it by DataLimits.NO_LIMIT
<span class="fc bfc" id="L192" title="All 2 branches covered.">            return pageSize &lt;= 0 ? DataLimits.NO_LIMIT : pageSize;</span>
        }

        public final void close()
        {
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">            if (!closed)</span>
            {
<span class="nc" id="L199">                closed = true;</span>
<span class="nc" id="L200">                partitionIterator.close();</span>
            }
<span class="fc" id="L202">        }</span>

        public final boolean hasNext()
        {
<span class="fc bfc" id="L206" title="All 2 branches covered.">            if (endOfData)</span>
<span class="fc" id="L207">                return false;</span>

<span class="fc bfc" id="L209" title="All 2 branches covered.">            if (next != null)</span>
<span class="fc" id="L210">                return true;</span>

<span class="fc" id="L212">            fetchNextRowIterator();</span>

<span class="fc bfc" id="L214" title="All 2 branches covered.">            return next != null;</span>
        }

        /**
         * Loads the next &lt;code&gt;RowIterator&lt;/code&gt; to be returned.
         */
        private void fetchNextRowIterator()
        {
<span class="fc bfc" id="L222" title="All 2 branches covered.">            if (partitionIterator == null)</span>
            {
<span class="fc" id="L224">                initialMaxRemaining = subPager.maxRemaining();</span>
<span class="fc" id="L225">                partitionIterator = fetchSubPage(pageSize);</span>
            }

<span class="fc bfc" id="L228" title="All 2 branches covered.">            while (!partitionIterator.hasNext())</span>
            {
<span class="fc" id="L230">                partitionIterator.close();</span>

<span class="fc" id="L232">                int counted = initialMaxRemaining - subPager.maxRemaining();</span>

<span class="pc bpc" id="L234" title="2 of 4 branches missed.">                if (isDone(pageSize, counted) || subPager.isExhausted())</span>
                {
<span class="fc" id="L236">                    endOfData = true;</span>
<span class="fc" id="L237">                    closed = true;</span>
<span class="fc" id="L238">                    return;</span>
                }

<span class="nc" id="L241">                subPager = updatePagerLimit(subPager, limits, lastPartitionKey, lastClustering);</span>
<span class="nc" id="L242">                partitionIterator = fetchSubPage(computeSubPageSize(pageSize, counted));</span>
<span class="nc" id="L243">            }</span>

<span class="fc" id="L245">            next = partitionIterator.next();</span>
<span class="fc" id="L246">        }</span>

        protected boolean isDone(int pageSize, int counted)
        {
<span class="nc bnc" id="L250" title="All 2 branches missed.">            return counted == pageSize;</span>
        }

        /**
         * Updates the pager with the new limits if needed.
         *
         * @param pager the pager previoulsy used
         * @param limits the DataLimits
         * @param lastPartitionKey the partition key of the last row returned
         * @param lastClustering the clustering of the last row returned
         * @return the pager to use to query the next page of data
         */
        protected QueryPager updatePagerLimit(QueryPager pager,
                                              DataLimits limits,
                                              ByteBuffer lastPartitionKey,
                                              Clustering&lt;?&gt; lastClustering)
        {
<span class="nc" id="L267">            GroupingState state = new GroupingState(lastPartitionKey, lastClustering);</span>
<span class="nc" id="L268">            DataLimits newLimits = limits.forGroupByInternalPaging(state);</span>
<span class="nc" id="L269">            return pager.withUpdatedLimit(newLimits);</span>
        }

        /**
         * Computes the size of the next sub-page to retrieve.
         *
         * @param pageSize the top-level page size
         * @param counted the number of result returned so far by the previous sub-pages
         * @return the size of the next sub-page to retrieve
         */
        protected int computeSubPageSize(int pageSize, int counted)
        {
<span class="nc" id="L281">            return pageSize - counted;</span>
        }

        /**
         * Fetchs the next sub-page.
         *
         * @param subPageSize the sub-page size in number of groups
         * @return the next sub-page
         */
        private final PartitionIterator fetchSubPage(int subPageSize)
        {
<span class="fc bfc" id="L292" title="All 2 branches covered.">            return consistency != null ? subPager.fetchPage(subPageSize, consistency, clientState, queryStartNanoTime)</span>
<span class="fc" id="L293">                                       : subPager.fetchPageInternal(subPageSize, executionController);</span>
        }

        public final RowIterator next()
        {
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">            if (!hasNext())</span>
<span class="nc" id="L299">                throw new NoSuchElementException();</span>

<span class="fc" id="L301">            RowIterator iterator = new GroupByRowIterator(next);</span>
<span class="fc" id="L302">            lastPartitionKey = iterator.partitionKey().getKey();</span>
<span class="fc" id="L303">            next = null;</span>
<span class="fc" id="L304">            return iterator;</span>
        }

        private class GroupByRowIterator implements RowIterator
        {
            /**
             * The decorated &lt;code&gt;RowIterator&lt;/code&gt;.
             */
            private RowIterator rowIterator;

            /**
             * Keeps track if the decorated iterator has been closed or not.
             */
            private boolean closed;

            public GroupByRowIterator(RowIterator delegate)
<span class="fc" id="L320">            {</span>
<span class="fc" id="L321">                this.rowIterator = delegate;</span>
<span class="fc" id="L322">            }</span>

            public TableMetadata metadata()
            {
<span class="nc" id="L326">                return rowIterator.metadata();</span>
            }

            public boolean isReverseOrder()
            {
<span class="nc" id="L331">                return rowIterator.isReverseOrder();</span>
            }

            public RegularAndStaticColumns columns()
            {
<span class="nc" id="L336">                return rowIterator.columns();</span>
            }

            public DecoratedKey partitionKey()
            {
<span class="fc" id="L341">                return rowIterator.partitionKey();</span>
            }

            public Row staticRow()
            {
<span class="fc" id="L346">                Row row = rowIterator.staticRow();</span>
<span class="fc" id="L347">                lastClustering = null;</span>
<span class="fc" id="L348">                return row;</span>
            }

            public boolean isEmpty()
            {
<span class="nc bnc" id="L353" title="All 4 branches missed.">                return this.rowIterator.isEmpty() &amp;&amp; !hasNext();</span>
            }

            public void close()
            {
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">                if (!closed)</span>
<span class="nc" id="L359">                    rowIterator.close();</span>
<span class="fc" id="L360">            }</span>

            public boolean hasNext()
            {
<span class="fc bfc" id="L364" title="All 2 branches covered.">                if (rowIterator.hasNext())</span>
<span class="fc" id="L365">                    return true;</span>

<span class="fc" id="L367">                DecoratedKey partitionKey = rowIterator.partitionKey();</span>

<span class="fc" id="L369">                rowIterator.close();</span>

                // Fetch the next RowIterator
<span class="fc" id="L372">                GroupByPartitionIterator.this.hasNext();</span>

                // if the previous page was ending within the partition the
                // next RowIterator is the continuation of this one
<span class="pc bpc" id="L376" title="1 of 4 branches missed.">                if (next != null &amp;&amp; partitionKey.equals(next.partitionKey()))</span>
                {
<span class="nc" id="L378">                    rowIterator = next;</span>
<span class="nc" id="L379">                    next = null;</span>
<span class="nc" id="L380">                    return rowIterator.hasNext();</span>
                }

<span class="fc" id="L383">                closed = true;</span>
<span class="fc" id="L384">                return false;</span>
            }

            public Row next()
            {
<span class="fc" id="L389">                Row row = this.rowIterator.next();</span>
<span class="fc" id="L390">                lastClustering = row.clustering();</span>
<span class="fc" id="L391">                return row;</span>
            }
        }
    }

    /**
     * &lt;code&gt;PartitionIterator&lt;/code&gt; for queries without Group By but with aggregates.
     * &lt;p&gt;For maintaining backward compatibility we are forced to use the {@link org.apache.cassandra.db.filter.DataLimits.CQLLimits} instead of the
     * {@link org.apache.cassandra.db.filter.DataLimits.CQLGroupByLimits}. Due to that pages need to be fetched in a different way.&lt;/p&gt;
     */
    public final class AggregationPartitionIterator extends GroupByPartitionIterator
    {
        public AggregationPartitionIterator(int pageSize,
                                            ConsistencyLevel consistency,
                                            ClientState clientState,
                                            long queryStartNanoTime)
<span class="fc" id="L407">        {</span>
<span class="fc" id="L408">            super(pageSize, consistency, clientState, queryStartNanoTime);</span>
<span class="fc" id="L409">        }</span>

        public AggregationPartitionIterator(int pageSize,
                                            ReadExecutionController executionController,
                                            long queryStartNanoTime)
<span class="fc" id="L414">        {</span>
<span class="fc" id="L415">            super(pageSize, executionController, queryStartNanoTime);</span>
<span class="fc" id="L416">        }</span>

        @Override
        protected QueryPager updatePagerLimit(QueryPager pager,
                                              DataLimits limits,
                                              ByteBuffer lastPartitionKey,
                                              Clustering&lt;?&gt; lastClustering)
        {
<span class="nc" id="L424">            return pager;</span>
        }

        @Override
        protected boolean isDone(int pageSize, int counted)
        {
<span class="fc" id="L430">            return false;</span>
        }

        @Override
        protected int computeSubPageSize(int pageSize, int counted)
        {
<span class="nc" id="L436">            return pageSize;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>