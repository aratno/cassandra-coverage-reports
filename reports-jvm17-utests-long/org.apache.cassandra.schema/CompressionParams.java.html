<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CompressionParams.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.schema</a> &gt; <span class="el_source">CompressionParams.java</span></div><h1>CompressionParams.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.schema;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ThreadLocalRandom;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Objects;
import com.google.common.collect.ImmutableMap;

import org.apache.commons.lang3.builder.HashCodeBuilder;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.config.CassandraRelevantProperties;
import org.apache.cassandra.config.ParameterizedClass;
import org.apache.cassandra.db.TypeSizes;
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.io.IVersionedSerializer;
import org.apache.cassandra.io.compress.*;
import org.apache.cassandra.io.util.DataInputPlus;
import org.apache.cassandra.io.util.DataOutputPlus;
import org.apache.cassandra.net.MessagingService;

import static java.lang.String.format;

public final class CompressionParams
{
<span class="fc" id="L51">    private static final Logger logger = LoggerFactory.getLogger(CompressionParams.class);</span>

    private static volatile boolean hasLoggedCrcCheckChanceWarning;

    public static final int DEFAULT_CHUNK_LENGTH = 1024 * 16;
    public static final double DEFAULT_MIN_COMPRESS_RATIO = 0.0;        // Since pre-4.0 versions do not understand the
                                                                        // new compression parameter we can't use a
                                                                        // different default value.
<span class="fc" id="L59">    public static final IVersionedSerializer&lt;CompressionParams&gt; serializer = new Serializer();</span>

    public static final String CLASS = &quot;class&quot;;
    public static final String CHUNK_LENGTH_IN_KB = &quot;chunk_length_in_kb&quot;;
    public static final String ENABLED = &quot;enabled&quot;;
    public static final String MIN_COMPRESS_RATIO = &quot;min_compress_ratio&quot;;

<span class="pc bpc" id="L66" title="1 of 2 branches missed.">    public static final CompressionParams DEFAULT = !CassandraRelevantProperties.DETERMINISM_SSTABLE_COMPRESSION_DEFAULT.getBoolean()</span>
<span class="nc" id="L67">                                                    ? noCompression()</span>
<span class="fc" id="L68">                                                    : new CompressionParams(LZ4Compressor.create(Collections.emptyMap()),</span>
                                                                            DEFAULT_CHUNK_LENGTH,
<span class="fc" id="L70">                                                                            calcMaxCompressedLength(DEFAULT_CHUNK_LENGTH, DEFAULT_MIN_COMPRESS_RATIO),</span>
                                                                            DEFAULT_MIN_COMPRESS_RATIO,
<span class="fc" id="L72">                                                                            Collections.emptyMap());</span>

<span class="fc" id="L74">    public static final CompressionParams NOOP = new CompressionParams(NoopCompressor.create(Collections.emptyMap()),</span>
                                                                       // 4 KiB is often the underlying disk block size
                                                                       1024 * 4,
                                                                       Integer.MAX_VALUE,
                                                                       DEFAULT_MIN_COMPRESS_RATIO,
<span class="fc" id="L79">                                                                       Collections.emptyMap());</span>

    private static final String CRC_CHECK_CHANCE_WARNING = &quot;The option crc_check_chance was deprecated as a compression option. &quot; +
                                                           &quot;You should specify it as a top-level table option instead&quot;;

    @Deprecated public static final String CRC_CHECK_CHANCE = &quot;crc_check_chance&quot;;

    private final ICompressor sstableCompressor;
    private final int chunkLength;
    private final int maxCompressedLength;  // In content we store max length to avoid rounding errors causing compress/decompress mismatch.
    private final double minCompressRatio;  // In configuration we store min ratio, the input parameter.
    private final ImmutableMap&lt;String, String&gt; otherOptions; // Unrecognized options, can be used by the compressor

    // TODO: deprecated, should now be carefully removed. Doesn't affect schema code as it isn't included in equals() and hashCode()
<span class="fc" id="L93">    private volatile double crcCheckChance = 1.0;</span>

    public static CompressionParams fromMap(Map&lt;String, String&gt; opts)
    {
<span class="fc" id="L97">        Map&lt;String, String&gt; options = copyOptions(opts);</span>

        String sstableCompressionClass;

<span class="pc bpc" id="L101" title="2 of 6 branches missed.">        if (!opts.isEmpty() &amp;&amp; isEnabled(opts) &amp;&amp; !options.containsKey(CLASS))</span>
<span class="nc" id="L102">            throw new ConfigurationException(format(&quot;Missing sub-option '%s' for the 'compression' option.&quot;, CLASS));</span>

<span class="pc bpc" id="L104" title="3 of 4 branches missed.">        if (!removeEnabled(options) &amp;&amp; !options.isEmpty())</span>
<span class="nc" id="L105">            throw new ConfigurationException(format(&quot;If the '%s' option is set to false no other options must be specified&quot;, ENABLED));</span>
        else
<span class="fc" id="L107">            sstableCompressionClass = removeSSTableCompressionClass(options);</span>

<span class="fc" id="L109">        int chunkLength = removeChunkLength(options);</span>
<span class="fc" id="L110">        double minCompressRatio = removeMinCompressRatio(options);</span>

<span class="fc" id="L112">        CompressionParams cp = new CompressionParams(sstableCompressionClass, options, chunkLength, minCompressRatio);</span>
<span class="fc" id="L113">        cp.validate();</span>

<span class="fc" id="L115">        return cp;</span>
    }

    public Class&lt;? extends ICompressor&gt; klass()
    {
<span class="nc" id="L120">        return sstableCompressor.getClass();</span>
    }

    public static CompressionParams noCompression()
    {
<span class="fc" id="L125">        return new CompressionParams(null, DEFAULT_CHUNK_LENGTH, Integer.MAX_VALUE, 0.0, Collections.emptyMap());</span>
    }

    // The shorthand methods below are only used for tests. They are a little inconsistent in their choice of
    // parameters -- this is done on purpose to test out various compression parameter combinations.

    @VisibleForTesting
    public static CompressionParams snappy()
    {
<span class="nc" id="L134">        return snappy(DEFAULT_CHUNK_LENGTH);</span>
    }

    @VisibleForTesting
    public static CompressionParams snappy(int chunkLength)
    {
<span class="nc" id="L140">        return snappy(chunkLength, 1.1);</span>
    }

    @VisibleForTesting
    public static CompressionParams snappy(int chunkLength, double minCompressRatio)
    {
<span class="nc" id="L146">        return new CompressionParams(SnappyCompressor.instance, chunkLength, calcMaxCompressedLength(chunkLength, minCompressRatio), minCompressRatio, Collections.emptyMap());</span>
    }

    @VisibleForTesting
    public static CompressionParams deflate()
    {
<span class="nc" id="L152">        return deflate(DEFAULT_CHUNK_LENGTH);</span>
    }

    @VisibleForTesting
    public static CompressionParams deflate(int chunkLength)
    {
<span class="nc" id="L158">        return new CompressionParams(DeflateCompressor.instance, chunkLength, Integer.MAX_VALUE, 0.0, Collections.emptyMap());</span>
    }

    @VisibleForTesting
    public static CompressionParams lz4()
    {
<span class="nc" id="L164">        return lz4(DEFAULT_CHUNK_LENGTH);</span>
    }

    @VisibleForTesting
    public static CompressionParams lz4(int chunkLength)
    {
<span class="nc" id="L170">        return lz4(chunkLength, chunkLength);</span>
    }

    @VisibleForTesting
    public static CompressionParams lz4(int chunkLength, int maxCompressedLength)
    {
<span class="nc" id="L176">        return new CompressionParams(LZ4Compressor.create(Collections.emptyMap()), chunkLength, maxCompressedLength, calcMinCompressRatio(chunkLength, maxCompressedLength), Collections.emptyMap());</span>
    }

    public static CompressionParams zstd()
    {
<span class="nc" id="L181">        return zstd(DEFAULT_CHUNK_LENGTH);</span>
    }

    public static CompressionParams zstd(Integer chunkLength)
    {
<span class="nc" id="L186">        ZstdCompressor compressor = ZstdCompressor.create(Collections.emptyMap());</span>
<span class="nc" id="L187">        return new CompressionParams(compressor, chunkLength, Integer.MAX_VALUE, DEFAULT_MIN_COMPRESS_RATIO, Collections.emptyMap());</span>
    }

    @VisibleForTesting
    public static CompressionParams noop()
    {
<span class="nc" id="L193">        NoopCompressor compressor = NoopCompressor.create(Collections.emptyMap());</span>
<span class="nc" id="L194">        return new CompressionParams(compressor, DEFAULT_CHUNK_LENGTH, Integer.MAX_VALUE, DEFAULT_MIN_COMPRESS_RATIO, Collections.emptyMap());</span>
    }

    public CompressionParams(String sstableCompressorClass, Map&lt;String, String&gt; otherOptions, int chunkLength, double minCompressRatio) throws ConfigurationException
    {
<span class="fc" id="L199">        this(createCompressor(parseCompressorClass(sstableCompressorClass), otherOptions), chunkLength, calcMaxCompressedLength(chunkLength, minCompressRatio), minCompressRatio, otherOptions);</span>
<span class="fc" id="L200">    }</span>

    static int calcMaxCompressedLength(int chunkLength, double minCompressRatio)
    {
<span class="fc" id="L204">        return (int) Math.ceil(Math.min(chunkLength / minCompressRatio, Integer.MAX_VALUE));</span>
    }

    public CompressionParams(String sstableCompressorClass, int chunkLength, int maxCompressedLength, Map&lt;String, String&gt; otherOptions) throws ConfigurationException
    {
<span class="fc" id="L209">        this(createCompressor(parseCompressorClass(sstableCompressorClass), otherOptions), chunkLength, maxCompressedLength, calcMinCompressRatio(chunkLength, maxCompressedLength), otherOptions);</span>
<span class="fc" id="L210">    }</span>

    static double calcMinCompressRatio(int chunkLength, int maxCompressedLength)
    {
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">        if (maxCompressedLength == Integer.MAX_VALUE)</span>
<span class="fc" id="L215">            return 0;</span>
<span class="nc" id="L216">        return chunkLength * 1.0 / maxCompressedLength;</span>
    }

    private CompressionParams(ICompressor sstableCompressor, int chunkLength, int maxCompressedLength, double minCompressRatio, Map&lt;String, String&gt; otherOptions) throws ConfigurationException
<span class="fc" id="L220">    {</span>
<span class="fc" id="L221">        this.sstableCompressor = sstableCompressor;</span>
<span class="fc" id="L222">        this.chunkLength = chunkLength;</span>
<span class="fc" id="L223">        this.otherOptions = ImmutableMap.copyOf(otherOptions);</span>
<span class="fc" id="L224">        this.minCompressRatio = minCompressRatio;</span>
<span class="fc" id="L225">        this.maxCompressedLength = maxCompressedLength;</span>
<span class="fc" id="L226">    }</span>

    public CompressionParams copy()
    {
<span class="nc" id="L230">        return new CompressionParams(sstableCompressor, chunkLength, maxCompressedLength, minCompressRatio, otherOptions);</span>
    }

    /**
     * Checks if compression is enabled.
     * @return {@code true} if compression is enabled, {@code false} otherwise.
     */
    public boolean isEnabled()
    {
<span class="fc bfc" id="L239" title="All 2 branches covered.">        return sstableCompressor != null;</span>
    }

    /**
     * Returns the SSTable compressor.
     * @return the SSTable compressor or {@code null} if compression is disabled.
     */
    public ICompressor getSstableCompressor()
    {
<span class="fc" id="L248">        return sstableCompressor;</span>
    }

    public ImmutableMap&lt;String, String&gt; getOtherOptions()
    {
<span class="fc" id="L253">        return otherOptions;</span>
    }

    public int chunkLength()
    {
<span class="fc" id="L258">        return chunkLength;</span>
    }

    public int maxCompressedLength()
    {
<span class="fc" id="L263">        return maxCompressedLength;</span>
    }

    private static Class&lt;?&gt; parseCompressorClass(String className) throws ConfigurationException
    {
<span class="pc bpc" id="L268" title="1 of 4 branches missed.">        if (className == null || className.isEmpty())</span>
<span class="fc" id="L269">            return null;</span>

<span class="fc bfc" id="L271" title="All 2 branches covered.">        className = className.contains(&quot;.&quot;) ? className : &quot;org.apache.cassandra.io.compress.&quot; + className;</span>
        try
        {
<span class="fc" id="L274">            return Class.forName(className);</span>
        }
<span class="nc" id="L276">        catch (Exception e)</span>
        {
<span class="nc" id="L278">            throw new ConfigurationException(&quot;Could not create Compression for type &quot; + className, e);</span>
        }
    }

    private static ICompressor createCompressor(Class&lt;?&gt; compressorClass, Map&lt;String, String&gt; compressionOptions) throws ConfigurationException
    {
<span class="fc bfc" id="L284" title="All 2 branches covered.">        if (compressorClass == null)</span>
        {
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">            if (!compressionOptions.isEmpty())</span>
<span class="nc" id="L287">                throw new ConfigurationException(&quot;Unknown compression options (&quot; + compressionOptions.keySet() + &quot;) since no compression class found&quot;);</span>
<span class="fc" id="L288">            return null;</span>
        }

<span class="pc bpc" id="L291" title="1 of 2 branches missed.">        if (compressionOptions.containsKey(CRC_CHECK_CHANCE))</span>
        {
<span class="nc bnc" id="L293" title="All 2 branches missed.">            if (!hasLoggedCrcCheckChanceWarning)</span>
            {
<span class="nc" id="L295">                logger.warn(CRC_CHECK_CHANCE_WARNING);</span>
<span class="nc" id="L296">                hasLoggedCrcCheckChanceWarning = true;</span>
            }
<span class="nc" id="L298">            compressionOptions.remove(CRC_CHECK_CHANCE);</span>
        }

        try
        {
<span class="fc" id="L303">            Method method = compressorClass.getMethod(&quot;create&quot;, Map.class);</span>
<span class="fc" id="L304">            ICompressor compressor = (ICompressor)method.invoke(null, compressionOptions);</span>
            // Check for unknown options
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">            for (String provided : compressionOptions.keySet())</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">                if (!compressor.supportedOptions().contains(provided))</span>
<span class="nc" id="L308">                    throw new ConfigurationException(&quot;Unknown compression options &quot; + provided);</span>
<span class="fc" id="L309">            return compressor;</span>
        }
<span class="nc" id="L311">        catch (NoSuchMethodException e)</span>
        {
<span class="nc" id="L313">            throw new ConfigurationException(&quot;create method not found&quot;, e);</span>
        }
<span class="nc" id="L315">        catch (SecurityException e)</span>
        {
<span class="nc" id="L317">            throw new ConfigurationException(&quot;Access forbiden&quot;, e);</span>
        }
<span class="nc" id="L319">        catch (IllegalAccessException e)</span>
        {
<span class="nc" id="L321">            throw new ConfigurationException(&quot;Cannot access method create in &quot; + compressorClass.getName(), e);</span>
        }
<span class="nc" id="L323">        catch (InvocationTargetException e)</span>
        {
<span class="nc bnc" id="L325" title="All 2 branches missed.">            if (e.getTargetException() instanceof ConfigurationException)</span>
<span class="nc" id="L326">                throw (ConfigurationException) e.getTargetException();</span>

<span class="nc bnc" id="L328" title="All 2 branches missed.">            Throwable cause = e.getCause() == null</span>
<span class="nc" id="L329">                            ? e</span>
<span class="nc" id="L330">                            : e.getCause();</span>

<span class="nc" id="L332">            throw new ConfigurationException(format(&quot;%s.create() threw an error: %s %s&quot;,</span>
<span class="nc" id="L333">                                                    compressorClass.getSimpleName(),</span>
<span class="nc" id="L334">                                                    cause.getClass().getName(),</span>
<span class="nc" id="L335">                                                    cause.getMessage()),</span>
                                             e);
        }
<span class="nc" id="L338">        catch (ExceptionInInitializerError e)</span>
        {
<span class="nc" id="L340">            throw new ConfigurationException(&quot;Cannot initialize class &quot; + compressorClass.getName());</span>
        }
    }

    public static ICompressor createCompressor(ParameterizedClass compression) throws ConfigurationException
    {
<span class="fc" id="L346">        return createCompressor(parseCompressorClass(compression.class_name), copyOptions(compression.parameters));</span>
    }

    private static Map&lt;String, String&gt; copyOptions(Map&lt;? extends CharSequence, ? extends CharSequence&gt; co)
    {
<span class="pc bpc" id="L351" title="1 of 4 branches missed.">        if (co == null || co.isEmpty())</span>
<span class="fc" id="L352">            return Collections.emptyMap();</span>

<span class="fc" id="L354">        Map&lt;String, String&gt; compressionOptions = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">        for (Map.Entry&lt;? extends CharSequence, ? extends CharSequence&gt; entry : co.entrySet())</span>
<span class="fc" id="L356">            compressionOptions.put(entry.getKey().toString(), entry.getValue().toString());</span>
<span class="fc" id="L357">        return compressionOptions;</span>
    }

    /**
     * Parse the chunk length (in KiB) and returns it as bytes.
     *
     * @param chLengthKB the length of the chunk to parse
     * @return the chunk length in bytes
     * @throws ConfigurationException if the chunk size is too large
     */
    private static Integer parseChunkLength(String chLengthKB) throws ConfigurationException
    {
<span class="nc bnc" id="L369" title="All 2 branches missed.">        if (chLengthKB == null)</span>
<span class="nc" id="L370">            return null;</span>

        try
        {
<span class="nc" id="L374">            int parsed = Integer.parseInt(chLengthKB);</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">            if (parsed &gt; Integer.MAX_VALUE / 1024)</span>
<span class="nc" id="L376">                throw new ConfigurationException(format(&quot;Value of %s is too large (%s)&quot;, CHUNK_LENGTH_IN_KB,parsed));</span>
<span class="nc" id="L377">            return 1024 * parsed;</span>
        }
<span class="nc" id="L379">        catch (NumberFormatException e)</span>
        {
<span class="nc" id="L381">            throw new ConfigurationException(&quot;Invalid value for &quot; + CHUNK_LENGTH_IN_KB, e);</span>
        }
    }

    /**
     * Removes the chunk length option from the specified set of option.
     *
     * @param options the options
     * @return the chunk length value
     */
    private static int removeChunkLength(Map&lt;String, String&gt; options)
    {
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">        if (options.containsKey(CHUNK_LENGTH_IN_KB))</span>
        {
<span class="nc" id="L395">            return parseChunkLength(options.remove(CHUNK_LENGTH_IN_KB));</span>
        }

<span class="fc" id="L398">        return DEFAULT_CHUNK_LENGTH;</span>
    }

    /**
     * Removes the min compress ratio option from the specified set of option.
     *
     * @param options the options
     * @return the min compress ratio, used to calculate max chunk size to write compressed
     */
    private static double removeMinCompressRatio(Map&lt;String, String&gt; options)
    {
<span class="fc" id="L409">        String ratio = options.remove(MIN_COMPRESS_RATIO);</span>
<span class="pc bpc" id="L410" title="1 of 2 branches missed.">        if (ratio != null)</span>
        {
<span class="nc" id="L412">            return Double.parseDouble(ratio);</span>
        }
<span class="fc" id="L414">        return DEFAULT_MIN_COMPRESS_RATIO;</span>
    }

    /**
     * Removes the option specifying the name of the compression class
     *
     * @param options the options
     * @return the name of the compression class
     */
    private static String removeSSTableCompressionClass(Map&lt;String, String&gt; options)
    {
<span class="fc bfc" id="L425" title="All 2 branches covered.">        if (options.containsKey(CLASS))</span>
        {
<span class="fc" id="L427">            String clazz = options.remove(CLASS);</span>

<span class="pc bpc" id="L429" title="2 of 4 branches missed.">            if (clazz == null || clazz.isEmpty())</span>
<span class="nc" id="L430">                throw new ConfigurationException(format(&quot;The '%s' option must not be empty. To disable compression use 'enabled' : false&quot;, CLASS));</span>

<span class="fc" id="L432">            return clazz;</span>
        }

<span class="fc" id="L435">        return null;</span>
    }

    /**
     * Returns {@code true} if the options contains the {@code enabled} option and that its value is
     * {@code true}, otherwise returns {@code false}.
     *
     * @param options the options
     * @return {@code true} if the options contains the {@code enabled} option and that its value is
     * {@code true}, otherwise returns {@code false}.
     */
    public static boolean isEnabled(Map&lt;String, String&gt; options)
    {
<span class="fc" id="L448">        String enabled = options.get(ENABLED);</span>
<span class="pc bpc" id="L449" title="3 of 4 branches missed.">        return enabled == null || Boolean.parseBoolean(enabled);</span>
    }

    /**
     * Removes the {@code enabled} option from the specified options.
     *
     * @param options the options
     * @return the value of the {@code enabled} option
     */
    private static boolean removeEnabled(Map&lt;String, String&gt; options)
    {
<span class="fc" id="L460">        String enabled = options.remove(ENABLED);</span>
<span class="pc bpc" id="L461" title="3 of 4 branches missed.">        return enabled == null || Boolean.parseBoolean(enabled);</span>
    }

    // chunkLength must be a power of 2 because we assume so when
    // computing the chunk number from an uncompressed file offset (see
    // CompressedRandomAccessReader.decompresseChunk())
    public void validate() throws ConfigurationException
    {
        // if chunk length was not set (chunkLength == null), this is fine, default will be used
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">        if (chunkLength &lt;= 0)</span>
<span class="nc" id="L471">            throw new ConfigurationException(&quot;Invalid negative or null &quot; + CHUNK_LENGTH_IN_KB);</span>

<span class="pc bpc" id="L473" title="1 of 2 branches missed.">        if ((chunkLength &amp; (chunkLength - 1)) != 0)</span>
<span class="nc" id="L474">            throw new ConfigurationException(CHUNK_LENGTH_IN_KB + &quot; must be a power of 2&quot;);</span>

<span class="pc bpc" id="L476" title="1 of 2 branches missed.">        if (maxCompressedLength &lt; 0)</span>
<span class="nc" id="L477">            throw new ConfigurationException(&quot;Invalid negative &quot; + MIN_COMPRESS_RATIO);</span>

<span class="pc bpc" id="L479" title="2 of 4 branches missed.">        if (maxCompressedLength &gt; chunkLength &amp;&amp; maxCompressedLength &lt; Integer.MAX_VALUE)</span>
<span class="nc" id="L480">            throw new ConfigurationException(MIN_COMPRESS_RATIO + &quot; can either be 0 or greater than or equal to 1&quot;);</span>
<span class="fc" id="L481">    }</span>

    public Map&lt;String, String&gt; asMap()
    {
<span class="fc bfc" id="L485" title="All 2 branches covered.">        if (!isEnabled())</span>
<span class="fc" id="L486">            return Collections.singletonMap(ENABLED, &quot;false&quot;);</span>

<span class="fc" id="L488">        Map&lt;String, String&gt; options = new HashMap&lt;&gt;(otherOptions);</span>
<span class="fc" id="L489">        options.put(CLASS, sstableCompressor.getClass().getName());</span>
<span class="fc" id="L490">        options.put(CHUNK_LENGTH_IN_KB, chunkLengthInKB());</span>
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">        if (minCompressRatio != DEFAULT_MIN_COMPRESS_RATIO)</span>
<span class="nc" id="L492">            options.put(MIN_COMPRESS_RATIO, String.valueOf(minCompressRatio));</span>

<span class="fc" id="L494">        return options;</span>
    }

    public String chunkLengthInKB()
    {
<span class="fc" id="L499">        return String.valueOf(chunkLength() / 1024);</span>
    }

    public void setCrcCheckChance(double crcCheckChance)
    {
<span class="fc" id="L504">        this.crcCheckChance = crcCheckChance;</span>
<span class="fc" id="L505">    }</span>

    public double getCrcCheckChance()
    {
<span class="fc" id="L509">        return crcCheckChance;</span>
    }

    public boolean shouldCheckCrc()
    {
<span class="fc" id="L514">        double checkChance = getCrcCheckChance();</span>
<span class="pc bpc" id="L515" title="3 of 4 branches missed.">        return checkChance &gt;= 1d ||</span>
<span class="pc bnc" id="L516" title="All 2 branches missed.">               (checkChance &gt; 0d &amp;&amp; checkChance &gt; ThreadLocalRandom.current().nextDouble());</span>
    }

    @Override
    public boolean equals(Object obj)
    {
<span class="nc bnc" id="L522" title="All 2 branches missed.">        if (obj == this)</span>
<span class="nc" id="L523">            return true;</span>

<span class="nc bnc" id="L525" title="All 2 branches missed.">        if (!(obj instanceof CompressionParams))</span>
<span class="nc" id="L526">            return false;</span>

<span class="nc" id="L528">        CompressionParams cp = (CompressionParams) obj;</span>

<span class="nc bnc" id="L530" title="All 4 branches missed.">        return Objects.equal(sstableCompressor, cp.sstableCompressor)</span>
            &amp;&amp; chunkLength == cp.chunkLength
<span class="nc bnc" id="L532" title="All 4 branches missed.">            &amp;&amp; otherOptions.equals(cp.otherOptions)</span>
            &amp;&amp; minCompressRatio == cp.minCompressRatio;
    }

    @Override
    public int hashCode()
    {
<span class="fc" id="L539">        return new HashCodeBuilder(29, 1597)</span>
<span class="fc" id="L540">            .append(sstableCompressor)</span>
<span class="fc" id="L541">            .append(chunkLength)</span>
<span class="fc" id="L542">            .append(otherOptions)</span>
<span class="fc" id="L543">            .append(minCompressRatio)</span>
<span class="fc" id="L544">            .toHashCode();</span>
    }

<span class="fc" id="L547">    static class Serializer implements IVersionedSerializer&lt;CompressionParams&gt;</span>
    {
        public void serialize(CompressionParams parameters, DataOutputPlus out, int version) throws IOException
        {
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">            assert version &gt;= MessagingService.VERSION_40;</span>
<span class="fc" id="L552">            out.writeUTF(parameters.sstableCompressor.getClass().getSimpleName());</span>
<span class="fc" id="L553">            out.writeInt(parameters.otherOptions.size());</span>
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">            for (Map.Entry&lt;String, String&gt; entry : parameters.otherOptions.entrySet())</span>
            {
<span class="nc" id="L556">                out.writeUTF(entry.getKey());</span>
<span class="nc" id="L557">                out.writeUTF(entry.getValue());</span>
<span class="nc" id="L558">            }</span>
<span class="fc" id="L559">            out.writeInt(parameters.chunkLength());</span>
<span class="fc" id="L560">            out.writeInt(parameters.maxCompressedLength);</span>
<span class="fc" id="L561">        }</span>

        public CompressionParams deserialize(DataInputPlus in, int version) throws IOException
        {
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">            assert version &gt;= MessagingService.VERSION_40;</span>
<span class="fc" id="L566">            String compressorName = in.readUTF();</span>
<span class="fc" id="L567">            int optionCount = in.readInt();</span>
<span class="fc" id="L568">            Map&lt;String, String&gt; options = new HashMap&lt;&gt;();</span>
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">            for (int i = 0; i &lt; optionCount; ++i)</span>
            {
<span class="nc" id="L571">                String key = in.readUTF();</span>
<span class="nc" id="L572">                String value = in.readUTF();</span>
<span class="nc" id="L573">                options.put(key, value);</span>
            }
<span class="fc" id="L575">            int chunkLength = in.readInt();</span>
<span class="fc" id="L576">            int minCompressRatio = in.readInt();</span>

            CompressionParams parameters;
            try
            {
<span class="fc" id="L581">                parameters = new CompressionParams(compressorName, chunkLength, minCompressRatio, options);</span>
            }
<span class="nc" id="L583">            catch (ConfigurationException e)</span>
            {
<span class="nc" id="L585">                throw new RuntimeException(&quot;Cannot create CompressionParams for parameters&quot;, e);</span>
<span class="fc" id="L586">            }</span>
<span class="fc" id="L587">            return parameters;</span>
        }

        public long serializedSize(CompressionParams parameters, int version)
        {
<span class="nc bnc" id="L592" title="All 2 branches missed.">            assert version &gt;= MessagingService.VERSION_40;</span>
<span class="nc" id="L593">            long size = TypeSizes.sizeof(parameters.sstableCompressor.getClass().getSimpleName());</span>
<span class="nc" id="L594">            size += TypeSizes.sizeof(parameters.otherOptions.size());</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">            for (Map.Entry&lt;String, String&gt; entry : parameters.otherOptions.entrySet())</span>
            {
<span class="nc" id="L597">                size += TypeSizes.sizeof(entry.getKey());</span>
<span class="nc" id="L598">                size += TypeSizes.sizeof(entry.getValue());</span>
<span class="nc" id="L599">            }</span>
<span class="nc" id="L600">            size += TypeSizes.sizeof(parameters.chunkLength());</span>
<span class="nc" id="L601">            size += TypeSizes.sizeof(parameters.maxCompressedLength());</span>
<span class="nc" id="L602">            return size;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>