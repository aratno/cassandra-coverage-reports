<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UnfilteredRowIteratorWithLowerBound.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.db.rows</a> &gt; <span class="el_source">UnfilteredRowIteratorWithLowerBound.java</span></div><h1>UnfilteredRowIteratorWithLowerBound.java</h1><pre class="source lang-java linenums">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.cassandra.db.rows;

import java.util.Comparator;
import java.util.Optional;

import com.google.common.annotations.VisibleForTesting;

import org.apache.cassandra.db.Clusterable;
import org.apache.cassandra.db.ClusteringBound;
import org.apache.cassandra.db.ClusteringPrefix;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.DeletionTime;
import org.apache.cassandra.db.RegularAndStaticColumns;
import org.apache.cassandra.db.Slices;
import org.apache.cassandra.db.filter.ClusteringIndexFilter;
import org.apache.cassandra.db.filter.ColumnFilter;
import org.apache.cassandra.db.transform.RTBoundValidator;
import org.apache.cassandra.io.sstable.SSTable;
import org.apache.cassandra.io.sstable.SSTableReadsListener;
import org.apache.cassandra.io.sstable.format.SSTableReader;
import org.apache.cassandra.io.sstable.keycache.KeyCacheSupport;
import org.apache.cassandra.io.sstable.metadata.StatsMetadata;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.utils.IteratorWithLowerBound;

/**
 * An unfiltered row iterator with a lower bound retrieved from either the global
 * sstable statistics or the row index lower bounds (if available in the cache).
 * Before initializing the sstable unfiltered row iterator, we return an empty row
 * with the clustering set to the lower bound. The empty row will be filtered out and
 * the result is that if we don't need to access this sstable, i.e. due to the LIMIT conditon,
 * then we will not. See CASSANDRA-8180 for examples of why this is useful.
 */
<span class="fc" id="L54">public class UnfilteredRowIteratorWithLowerBound extends LazilyInitializedUnfilteredRowIterator implements IteratorWithLowerBound&lt;Unfiltered&gt;</span>
{
    private final SSTableReader sstable;
    private final Slices slices;
    private final boolean isReverseOrder;
    private final ColumnFilter selectedColumns;
    private final SSTableReadsListener listener;
    private Optional&lt;Unfiltered&gt; lowerBoundMarker;
    private boolean firstItemRetrieved;

    public UnfilteredRowIteratorWithLowerBound(DecoratedKey partitionKey,
                                               SSTableReader sstable,
                                               ClusteringIndexFilter filter,
                                               ColumnFilter selectedColumns,
                                               SSTableReadsListener listener)
    {
<span class="fc" id="L70">        this(partitionKey, sstable, filter.getSlices(sstable.metadata()), filter.isReversed(), selectedColumns, listener);</span>
<span class="fc" id="L71">    }</span>

    @VisibleForTesting
    public UnfilteredRowIteratorWithLowerBound(DecoratedKey partitionKey,
                                               SSTableReader sstable,
                                               Slices slices,
                                               boolean isReverseOrder,
                                               ColumnFilter selectedColumns,
                                               SSTableReadsListener listener)
    {
<span class="fc" id="L81">        super(partitionKey);</span>
<span class="fc" id="L82">        this.sstable = sstable;</span>
<span class="fc" id="L83">        this.slices = slices;</span>
<span class="fc" id="L84">        this.isReverseOrder = isReverseOrder;</span>
<span class="fc" id="L85">        this.selectedColumns = selectedColumns;</span>
<span class="fc" id="L86">        this.listener = listener;</span>
<span class="fc" id="L87">        this.firstItemRetrieved = false;</span>
<span class="fc" id="L88">    }</span>

    public Unfiltered lowerBound()
    {
<span class="fc bfc" id="L92" title="All 2 branches covered.">        if (lowerBoundMarker != null)</span>
<span class="fc" id="L93">            return lowerBoundMarker.orElse(null);</span>

        // lower bound from cache may be more accurate as it stores information about clusterings range for that exact
        // row, so we try it first (without initializing iterator)
<span class="fc" id="L97">        ClusteringBound&lt;?&gt; lowerBound = maybeGetLowerBoundFromKeyCache();</span>
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">        if (lowerBound == null)</span>
            // If we couldn't get the lower bound from cache, we try with metadata
<span class="fc" id="L100">            lowerBound = maybeGetLowerBoundFromMetadata();</span>

<span class="fc bfc" id="L102" title="All 2 branches covered.">        if (lowerBound != null)</span>
<span class="fc" id="L103">            lowerBoundMarker = Optional.of(makeBound(lowerBound));</span>
        else
<span class="fc" id="L105">            lowerBoundMarker = Optional.empty();</span>

<span class="fc" id="L107">        return lowerBoundMarker.orElse(null);</span>
    }

    private Unfiltered makeBound(ClusteringBound&lt;?&gt; bound)
    {
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">        if (bound == null)</span>
<span class="nc" id="L113">            return null;</span>

<span class="fc" id="L115">        return new ArtificialBoundMarker(bound);</span>
    }

    @Override
    protected UnfilteredRowIterator initializeIterator()
    {
        @SuppressWarnings(&quot;resource&quot;) // 'iter' is added to iterators which is closed on exception, or through the closing of the final merged iterator
<span class="fc" id="L122">        UnfilteredRowIterator iter = RTBoundValidator.validate(sstable.rowIterator(partitionKey(), slices, selectedColumns, isReverseOrder, listener),</span>
                                                               RTBoundValidator.Stage.SSTABLE, false);
<span class="fc" id="L124">        return iter;</span>
    }

    @Override
    protected Unfiltered computeNext()
    {
<span class="fc" id="L130">        Unfiltered ret = super.computeNext();</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">        if (firstItemRetrieved)</span>
<span class="fc" id="L132">            return ret;</span>

        // Check that the lower bound is not bigger than the first item retrieved
<span class="fc" id="L135">        firstItemRetrieved = true;</span>
<span class="fc" id="L136">        Unfiltered lowerBound = lowerBound();</span>
<span class="fc bfc" id="L137" title="All 4 branches covered.">        if (lowerBound != null &amp;&amp; ret != null)</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">            assert comparator().compare(lowerBound.clustering(), ret.clustering()) &lt;= 0</span>
<span class="nc" id="L139">            : String.format(&quot;Lower bound [%s ]is bigger than first returned value [%s] for sstable %s&quot;,</span>
<span class="nc" id="L140">                            lowerBound.clustering().toString(metadata()),</span>
<span class="nc" id="L141">                            ret.toString(metadata()),</span>
<span class="nc" id="L142">                            sstable.getFilename());</span>

<span class="fc" id="L144">        return ret;</span>
    }

    private Comparator&lt;Clusterable&gt; comparator()
    {
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        return isReverseOrder ? metadata().comparator.reversed() : metadata().comparator;</span>
    }

    @Override
    public TableMetadata metadata()
    {
<span class="fc" id="L155">        return sstable.metadata();</span>
    }

    @Override
    public boolean isReverseOrder()
    {
<span class="fc" id="L161">        return isReverseOrder;</span>
    }

    @Override
    public RegularAndStaticColumns columns()
    {
<span class="fc" id="L167">        return selectedColumns.fetchedColumns();</span>
    }

    @Override
    public EncodingStats stats()
    {
<span class="fc" id="L173">        return sstable.stats();</span>
    }

    @Override
    public DeletionTime partitionLevelDeletion()
    {
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (!sstable.getSSTableMetadata().hasPartitionLevelDeletions)</span>
<span class="fc" id="L180">            return DeletionTime.LIVE;</span>

<span class="fc" id="L182">        return super.partitionLevelDeletion();</span>
    }

    @Override
    public Row staticRow()
    {
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">        if (columns().statics.isEmpty())</span>
<span class="fc" id="L189">            return Rows.EMPTY_STATIC_ROW;</span>

<span class="nc" id="L191">        return super.staticRow();</span>
    }

    /**
     * @return the lower bound stored on the index entry for this partition, if available.
     */
    private ClusteringBound&lt;?&gt; maybeGetLowerBoundFromKeyCache()
    {
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">        if (sstable instanceof KeyCacheSupport&lt;?&gt;)</span>
<span class="fc" id="L200">            return ((KeyCacheSupport&lt;?&gt;) sstable).getLowerBoundPrefixFromCache(partitionKey(), isReverseOrder);</span>

<span class="nc" id="L202">        return null;</span>
    }

    /**
     * Whether we can use the clustering values in the stats of the sstable to build the lower bound.
     */
    private boolean canUseMetadataLowerBound()
    {
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">        if (sstable.metadata().isCompactTable())</span>
<span class="nc" id="L211">            return false;</span>

<span class="fc" id="L213">        Slices requestedSlices = slices;</span>

<span class="pc bpc" id="L215" title="1 of 2 branches missed.">        if (requestedSlices.isEmpty())</span>
<span class="nc" id="L216">            return true;</span>

        // Simply exclude the cases where lower bound would not be used anyway, that is, the start of covered range of
        // clusterings in sstable is lower than the requested slice. In such case, we need to access that sstable's
        // iterator anyway so there is no need to use a lower bound optimization extra complexity.
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">        if (!isReverseOrder())</span>
        {
<span class="fc bfc" id="L223" title="All 2 branches covered.">            return !requestedSlices.hasLowerBound() ||</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">                   metadata().comparator.compare(requestedSlices.start(), sstable.getSSTableMetadata().coveredClustering.start()) &lt; 0;</span>
        }
        else
        {
<span class="nc bnc" id="L228" title="All 2 branches missed.">            return !requestedSlices.hasUpperBound() ||</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">                   metadata().comparator.compare(requestedSlices.end(), sstable.getSSTableMetadata().coveredClustering.end()) &gt; 0;</span>
        }
    }

    /**
     * @return a global lower bound made from the clustering values stored in the sstable metadata, note that
     * this currently does not correctly compare tombstone bounds, especially ranges.
     */
    private ClusteringBound&lt;?&gt; maybeGetLowerBoundFromMetadata()
    {
<span class="fc bfc" id="L239" title="All 2 branches covered.">        if (!canUseMetadataLowerBound())</span>
<span class="fc" id="L240">            return null;</span>

<span class="fc" id="L242">        final StatsMetadata m = sstable.getSSTableMetadata();</span>
<span class="fc" id="L243">        ClusteringBound&lt;?&gt; bound = m.coveredClustering.open(isReverseOrder);</span>
<span class="fc" id="L244">        assertBoundSize(bound, sstable);</span>
<span class="fc" id="L245">        return bound.artificialLowerBound(isReverseOrder);</span>
    }

    public static void assertBoundSize(ClusteringPrefix&lt;?&gt; lowerBound, SSTable sstable)
    {
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        assert lowerBound.size() &lt;= sstable.metadata().comparator.size() :</span>
<span class="nc" id="L251">        String.format(&quot;Unexpected number of clustering values %d, expected %d or fewer for %s&quot;,</span>
<span class="nc" id="L252">                      lowerBound.size(),</span>
<span class="nc" id="L253">                      sstable.metadata().comparator.size(),</span>
<span class="nc" id="L254">                      sstable.getFilename());</span>
<span class="fc" id="L255">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>