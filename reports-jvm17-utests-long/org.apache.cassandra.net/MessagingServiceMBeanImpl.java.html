<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MessagingServiceMBeanImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.net</a> &gt; <span class="el_source">MessagingServiceMBeanImpl.java</span></div><h1>MessagingServiceMBeanImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.net;

import java.net.UnknownHostException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

import org.apache.cassandra.locator.InetAddressAndPort;
import org.apache.cassandra.metrics.InternodeOutboundMetrics;
import org.apache.cassandra.metrics.MessagingMetrics;
import org.apache.cassandra.security.SSLFactory;
import org.apache.cassandra.utils.MBeanWrapper;

public class MessagingServiceMBeanImpl implements MessagingServiceMBean
{
    public static final String MBEAN_NAME = &quot;org.apache.cassandra.net:type=MessagingService&quot;;

    // we use CHM deliberately instead of NBHM, as both are non-blocking for readers (which this map mostly is used for)
    // and CHM permits prompter GC
<span class="fc" id="L38">    public final ConcurrentMap&lt;InetAddressAndPort, OutboundConnections&gt; channelManagers = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L39">    public final ConcurrentMap&lt;InetAddressAndPort, InboundMessageHandlers&gt; messageHandlers = new ConcurrentHashMap&lt;&gt;();</span>

    public final EndpointMessagingVersions versions;
    public final MessagingMetrics metrics;

    public MessagingServiceMBeanImpl(boolean testOnly, EndpointMessagingVersions versions, MessagingMetrics metrics)
<span class="fc" id="L45">    {</span>
<span class="fc" id="L46">        this.versions = versions;</span>
<span class="fc" id="L47">        this.metrics = metrics;</span>
<span class="pc bpc" id="L48" title="1 of 2 branches missed.">        if (!testOnly)</span>
        {
<span class="fc" id="L50">            MBeanWrapper.instance.registerMBean(this, MBEAN_NAME);</span>
<span class="fc" id="L51">            metrics.scheduleLogging();</span>
        }
<span class="fc" id="L53">    }</span>

    @Override
    public Map&lt;String, Integer&gt; getLargeMessagePendingTasks()
    {
<span class="fc" id="L58">        Map&lt;String, Integer&gt; pendingTasks = new HashMap&lt;&gt;(channelManagers.size());</span>
<span class="pc bpc" id="L59" title="1 of 2 branches missed.">        for (Map.Entry&lt;InetAddressAndPort, OutboundConnections&gt; entry : channelManagers.entrySet())</span>
<span class="nc" id="L60">            pendingTasks.put(entry.getKey().toString(false), entry.getValue().large.pendingCount());</span>
<span class="fc" id="L61">        return pendingTasks;</span>
    }

    @Override
    public Map&lt;String, Long&gt; getLargeMessageCompletedTasks()
    {
<span class="nc" id="L67">        Map&lt;String, Long&gt; completedTasks = new HashMap&lt;&gt;(channelManagers.size());</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddressAndPort, OutboundConnections&gt; entry : channelManagers.entrySet())</span>
<span class="nc" id="L69">            completedTasks.put(entry.getKey().toString(false), entry.getValue().large.sentCount());</span>
<span class="nc" id="L70">        return completedTasks;</span>
    }

    @Override
    public Map&lt;String, Long&gt; getLargeMessageDroppedTasks()
    {
<span class="nc" id="L76">        Map&lt;String, Long&gt; droppedTasks = new HashMap&lt;&gt;(channelManagers.size());</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddressAndPort, OutboundConnections&gt; entry : channelManagers.entrySet())</span>
<span class="nc" id="L78">            droppedTasks.put(entry.getKey().toString(false), entry.getValue().large.dropped());</span>
<span class="nc" id="L79">        return droppedTasks;</span>
    }

    @Override
    public Map&lt;String, Integer&gt; getSmallMessagePendingTasks()
    {
<span class="fc" id="L85">        Map&lt;String, Integer&gt; pendingTasks = new HashMap&lt;&gt;(channelManagers.size());</span>
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">        for (Map.Entry&lt;InetAddressAndPort, OutboundConnections&gt; entry : channelManagers.entrySet())</span>
<span class="nc" id="L87">            pendingTasks.put(entry.getKey().toString(false), entry.getValue().small.pendingCount());</span>
<span class="fc" id="L88">        return pendingTasks;</span>
    }

    @Override
    public Map&lt;String, Long&gt; getSmallMessageCompletedTasks()
    {
<span class="nc" id="L94">        Map&lt;String, Long&gt; completedTasks = new HashMap&lt;&gt;(channelManagers.size());</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddressAndPort, OutboundConnections&gt; entry : channelManagers.entrySet())</span>
<span class="nc" id="L96">            completedTasks.put(entry.getKey().toString(false), entry.getValue().small.sentCount());</span>
<span class="nc" id="L97">        return completedTasks;</span>
    }

    @Override
    public Map&lt;String, Long&gt; getSmallMessageDroppedTasks()
    {
<span class="nc" id="L103">        Map&lt;String, Long&gt; droppedTasks = new HashMap&lt;&gt;(channelManagers.size());</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddressAndPort, OutboundConnections&gt; entry : channelManagers.entrySet())</span>
<span class="nc" id="L105">            droppedTasks.put(entry.getKey().toString(false), entry.getValue().small.dropped());</span>
<span class="nc" id="L106">        return droppedTasks;</span>
    }

    @Override
    public Map&lt;String, Integer&gt; getGossipMessagePendingTasks()
    {
<span class="nc" id="L112">        Map&lt;String, Integer&gt; pendingTasks = new HashMap&lt;&gt;(channelManagers.size());</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddressAndPort, OutboundConnections&gt; entry : channelManagers.entrySet())</span>
<span class="nc" id="L114">            pendingTasks.put(entry.getKey().toString(false), entry.getValue().urgent.pendingCount());</span>
<span class="nc" id="L115">        return pendingTasks;</span>
    }

    @Override
    public Map&lt;String, Long&gt; getGossipMessageCompletedTasks()
    {
<span class="nc" id="L121">        Map&lt;String, Long&gt; completedTasks = new HashMap&lt;&gt;(channelManagers.size());</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddressAndPort, OutboundConnections&gt; entry : channelManagers.entrySet())</span>
<span class="nc" id="L123">            completedTasks.put(entry.getKey().toString(false), entry.getValue().urgent.sentCount());</span>
<span class="nc" id="L124">        return completedTasks;</span>
    }

    @Override
    public Map&lt;String, Long&gt; getGossipMessageDroppedTasks()
    {
<span class="nc" id="L130">        Map&lt;String, Long&gt; droppedTasks = new HashMap&lt;&gt;(channelManagers.size());</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddressAndPort, OutboundConnections&gt; entry : channelManagers.entrySet())</span>
<span class="nc" id="L132">            droppedTasks.put(entry.getKey().toString(false), entry.getValue().urgent.dropped());</span>
<span class="nc" id="L133">        return droppedTasks;</span>
    }

    @Override
    public Map&lt;String, Integer&gt; getLargeMessagePendingTasksWithPort()
    {
<span class="nc" id="L139">        Map&lt;String, Integer&gt; pendingTasks = new HashMap&lt;&gt;(channelManagers.size());</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddressAndPort, OutboundConnections&gt; entry : channelManagers.entrySet())</span>
<span class="nc" id="L141">            pendingTasks.put(entry.getKey().toString(), entry.getValue().large.pendingCount());</span>
<span class="nc" id="L142">        return pendingTasks;</span>
    }

    @Override
    public Map&lt;String, Long&gt; getLargeMessageCompletedTasksWithPort()
    {
<span class="nc" id="L148">        Map&lt;String, Long&gt; completedTasks = new HashMap&lt;&gt;(channelManagers.size());</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddressAndPort, OutboundConnections&gt; entry : channelManagers.entrySet())</span>
<span class="nc" id="L150">            completedTasks.put(entry.getKey().toString(), entry.getValue().large.sentCount());</span>
<span class="nc" id="L151">        return completedTasks;</span>
    }

    @Override
    public Map&lt;String, Long&gt; getLargeMessageDroppedTasksWithPort()
    {
<span class="nc" id="L157">        Map&lt;String, Long&gt; droppedTasks = new HashMap&lt;&gt;(channelManagers.size());</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddressAndPort, OutboundConnections&gt; entry : channelManagers.entrySet())</span>
<span class="nc" id="L159">            droppedTasks.put(entry.getKey().toString(), entry.getValue().large.dropped());</span>
<span class="nc" id="L160">        return droppedTasks;</span>
    }

    @Override
    public Map&lt;String, Integer&gt; getSmallMessagePendingTasksWithPort()
    {
<span class="nc" id="L166">        Map&lt;String, Integer&gt; pendingTasks = new HashMap&lt;&gt;(channelManagers.size());</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddressAndPort, OutboundConnections&gt; entry : channelManagers.entrySet())</span>
<span class="nc" id="L168">            pendingTasks.put(entry.getKey().toString(), entry.getValue().small.pendingCount());</span>
<span class="nc" id="L169">        return pendingTasks;</span>
    }

    @Override
    public Map&lt;String, Long&gt; getSmallMessageCompletedTasksWithPort()
    {
<span class="nc" id="L175">        Map&lt;String, Long&gt; completedTasks = new HashMap&lt;&gt;(channelManagers.size());</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddressAndPort, OutboundConnections&gt; entry : channelManagers.entrySet())</span>
<span class="nc" id="L177">            completedTasks.put(entry.getKey().toString(), entry.getValue().small.sentCount());</span>
<span class="nc" id="L178">        return completedTasks;</span>
    }

    @Override
    public Map&lt;String, Long&gt; getSmallMessageDroppedTasksWithPort()
    {
<span class="nc" id="L184">        Map&lt;String, Long&gt; droppedTasks = new HashMap&lt;&gt;(channelManagers.size());</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddressAndPort, OutboundConnections&gt; entry : channelManagers.entrySet())</span>
<span class="nc" id="L186">            droppedTasks.put(entry.getKey().toString(), entry.getValue().small.dropped());</span>
<span class="nc" id="L187">        return droppedTasks;</span>
    }

    @Override
    public Map&lt;String, Integer&gt; getGossipMessagePendingTasksWithPort()
    {
<span class="nc" id="L193">        Map&lt;String, Integer&gt; pendingTasks = new HashMap&lt;&gt;(channelManagers.size());</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddressAndPort, OutboundConnections&gt; entry : channelManagers.entrySet())</span>
<span class="nc" id="L195">            pendingTasks.put(entry.getKey().toString(), entry.getValue().urgent.pendingCount());</span>
<span class="nc" id="L196">        return pendingTasks;</span>
    }

    @Override
    public Map&lt;String, Long&gt; getGossipMessageCompletedTasksWithPort()
    {
<span class="nc" id="L202">        Map&lt;String, Long&gt; completedTasks = new HashMap&lt;&gt;(channelManagers.size());</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddressAndPort, OutboundConnections&gt; entry : channelManagers.entrySet())</span>
<span class="nc" id="L204">            completedTasks.put(entry.getKey().toString(), entry.getValue().urgent.sentCount());</span>
<span class="nc" id="L205">        return completedTasks;</span>
    }

    @Override
    public Map&lt;String, Long&gt; getGossipMessageDroppedTasksWithPort()
    {
<span class="nc" id="L211">        Map&lt;String, Long&gt; droppedTasks = new HashMap&lt;&gt;(channelManagers.size());</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddressAndPort, OutboundConnections&gt; entry : channelManagers.entrySet())</span>
<span class="nc" id="L213">            droppedTasks.put(entry.getKey().toString(), entry.getValue().urgent.dropped());</span>
<span class="nc" id="L214">        return droppedTasks;</span>
    }

    @Override
    public Map&lt;String, Integer&gt; getDroppedMessages()
    {
<span class="nc" id="L220">        return metrics.getDroppedMessages();</span>
    }

    @Override
    public long getTotalTimeouts()
    {
<span class="nc" id="L226">        return InternodeOutboundMetrics.totalExpiredCallbacks.getCount();</span>
    }

    // these are not messages that time out on sending, but callbacks that timedout without receiving a response
    @Override
    public Map&lt;String, Long&gt; getTimeoutsPerHost()
    {
<span class="nc" id="L233">        Map&lt;String, Long&gt; result = new HashMap&lt;&gt;(channelManagers.size());</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddressAndPort, OutboundConnections&gt; entry : channelManagers.entrySet())</span>
        {
<span class="nc" id="L236">            String ip = entry.getKey().toString(false);</span>
<span class="nc" id="L237">            long recent = entry.getValue().expiredCallbacks();</span>
<span class="nc" id="L238">            result.put(ip, recent);</span>
<span class="nc" id="L239">        }</span>
<span class="nc" id="L240">        return result;</span>
    }

    // these are not messages that time out on sending, but callbacks that timedout without receiving a response
    @Override
    public Map&lt;String, Long&gt; getTimeoutsPerHostWithPort()
    {
<span class="nc" id="L247">        Map&lt;String, Long&gt; result = new HashMap&lt;&gt;(channelManagers.size());</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">        for (Map.Entry&lt;InetAddressAndPort, OutboundConnections&gt; entry : channelManagers.entrySet())</span>
        {
<span class="nc" id="L250">            String ip = entry.getKey().toString();</span>
<span class="nc" id="L251">            long recent = entry.getValue().expiredCallbacks();</span>
<span class="nc" id="L252">            result.put(ip, recent);</span>
<span class="nc" id="L253">        }</span>
<span class="nc" id="L254">        return result;</span>
    }

    @Override
    public Map&lt;String, Double&gt; getBackPressurePerHost()
    {
<span class="nc" id="L260">        throw new UnsupportedOperationException(&quot;This feature has been removed&quot;);</span>
    }

    @Override
    public void setBackPressureEnabled(boolean enabled)
    {
<span class="nc" id="L266">        throw new UnsupportedOperationException(&quot;This feature has been removed&quot;);</span>
    }

    @Override
    public boolean isBackPressureEnabled()
    {
<span class="nc" id="L272">        return false;</span>
    }

    @Override
    public void reloadSslCertificates()
    {
<span class="nc" id="L278">        SSLFactory.forceCheckCertFiles();</span>
<span class="nc" id="L279">    }</span>

    @Override
    public int getVersion(String address) throws UnknownHostException
    {
<span class="nc" id="L284">        return versions.get(address);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>