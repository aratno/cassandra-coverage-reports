<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MonotonicClock.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Cassandara Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.cassandra.utils</a> &gt; <span class="el_source">MonotonicClock.java</span></div><h1>MonotonicClock.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cassandra.utils;

import java.lang.reflect.Constructor;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.function.LongSupplier;

import com.google.common.annotations.VisibleForTesting;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.concurrent.ScheduledExecutors;

import static java.util.concurrent.TimeUnit.MILLISECONDS;
import static org.apache.cassandra.config.CassandraRelevantProperties.APPROXIMATE_TIME_PRECISION_MS;
import static org.apache.cassandra.config.CassandraRelevantProperties.CLOCK_MONOTONIC_APPROX;
import static org.apache.cassandra.config.CassandraRelevantProperties.CLOCK_MONOTONIC_PRECISE;
import static org.apache.cassandra.config.CassandraRelevantProperties.NANOTIMETOMILLIS_TIMESTAMP_UPDATE_INTERVAL;
import static org.apache.cassandra.utils.Clock.Global.nanoTime;
import static org.apache.cassandra.utils.Shared.Scope.SIMULATION;

/**
 * Wrapper around time related functions that are either implemented by using the default JVM calls
 * or by using a custom implementation for testing purposes.
 *
 * See {@link Global#preciseTime} for how to use a custom implementation.
 *
 * Please note that {@link java.time.Clock} wasn't used, as it would not be possible to provide an
 * implementation for {@link #now()} with the exact same properties of {@link System#nanoTime()}.
 *
 * TODO better rationalise MonotonicClock/Clock
 */
@Shared(scope = SIMULATION)
public interface MonotonicClock
{

    /**
     * @see System#nanoTime()
     *
     * Provides a monotonic time that can be compared with any other such value produced by the same clock
     * since the application started only; these times cannot be persisted or serialized to other nodes.
     *
     * Nanosecond precision.
     */
    public long now();

    /**
     * @return nanoseconds of potential error
     */
    public long error();

    public MonotonicClockTranslation translate();

    public boolean isAfter(long instant);
    public boolean isAfter(long now, long instant);

<span class="nc" id="L74">    public static class Global</span>
    {
<span class="fc" id="L76">        private static final Logger logger = LoggerFactory.getLogger(MonotonicClock.class);</span>

        /**
         * Static singleton object that will be instantiated by default with a system clock
         * implementation. Set &lt;code&gt;cassandra.clock&lt;/code&gt; system property to a FQCN to use a
         * different implementation instead.
         */
<span class="fc" id="L83">        public static final MonotonicClock preciseTime = precise();</span>
<span class="fc" id="L84">        public static final MonotonicClock approxTime = approx(preciseTime);</span>

        private static MonotonicClock precise()
        {
<span class="fc" id="L88">            String sclock = CLOCK_MONOTONIC_PRECISE.getString();</span>

<span class="pc bpc" id="L90" title="1 of 2 branches missed.">            if (sclock != null)</span>
            {
                try
                {
<span class="nc" id="L94">                    logger.debug(&quot;Using custom clock implementation: {}&quot;, sclock);</span>
<span class="nc" id="L95">                    return (MonotonicClock) Class.forName(sclock).newInstance();</span>
                }
<span class="nc" id="L97">                catch (Exception e)</span>
                {
<span class="nc" id="L99">                    logger.error(e.getMessage(), e);</span>
                }
            }

<span class="fc" id="L103">            return new SystemClock();</span>
        }

        private static MonotonicClock approx(MonotonicClock precise)
        {
<span class="fc" id="L108">            String sclock = CLOCK_MONOTONIC_APPROX.getString();</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">            if (sclock != null)</span>
            {
                try
                {
<span class="nc" id="L113">                    logger.debug(&quot;Using custom clock implementation: {}&quot;, sclock);</span>
<span class="nc" id="L114">                    Class&lt;? extends MonotonicClock&gt; clazz = (Class&lt;? extends MonotonicClock&gt;) Class.forName(sclock);</span>

<span class="nc bnc" id="L116" title="All 4 branches missed.">                    if (SystemClock.class.equals(clazz) &amp;&amp; SystemClock.class.equals(precise.getClass()))</span>
<span class="nc" id="L117">                        return precise;</span>

                    try
                    {
<span class="nc" id="L121">                        Constructor&lt;? extends MonotonicClock&gt; withPrecise = clazz.getConstructor(MonotonicClock.class);</span>
<span class="nc" id="L122">                        return withPrecise.newInstance(precise);</span>
                    }
<span class="nc" id="L124">                    catch (NoSuchMethodException nme)</span>
                    {
                    }

<span class="nc" id="L128">                    return clazz.newInstance();</span>
                }
<span class="nc" id="L130">                catch (Exception e)</span>
                {
<span class="nc" id="L132">                    logger.error(e.getMessage(), e);</span>
                }
            }

<span class="fc" id="L136">            return new SampledClock(precise);</span>
        }
    }

    static abstract class AbstractEpochSamplingClock implements MonotonicClock
    {
<span class="fc" id="L142">        private static final Logger logger = LoggerFactory.getLogger(AbstractEpochSamplingClock.class);</span>
<span class="fc" id="L143">        private static final long UPDATE_INTERVAL_MS = NANOTIMETOMILLIS_TIMESTAMP_UPDATE_INTERVAL.getLong();</span>

        @VisibleForTesting
        public static class AlmostSameTime implements MonotonicClockTranslation
        {
            final long millisSinceEpoch;
            final long monotonicNanos;
            final long error; // maximum error of millis measurement (in nanos)

            @VisibleForTesting
            public AlmostSameTime(long millisSinceEpoch, long monotonicNanos, long errorNanos)
<span class="fc" id="L154">            {</span>
<span class="fc" id="L155">                this.millisSinceEpoch = millisSinceEpoch;</span>
<span class="fc" id="L156">                this.monotonicNanos = monotonicNanos;</span>
<span class="fc" id="L157">                this.error = errorNanos;</span>
<span class="fc" id="L158">            }</span>

            public long fromMillisSinceEpoch(long currentTimeMillis)
            {
<span class="nc" id="L162">                return monotonicNanos + MILLISECONDS.toNanos(currentTimeMillis - millisSinceEpoch);</span>
            }

            public long toMillisSinceEpoch(long nanoTime)
            {
<span class="nc" id="L167">                return millisSinceEpoch + TimeUnit.NANOSECONDS.toMillis(nanoTime - monotonicNanos);</span>
            }

            public long error()
            {
<span class="nc" id="L172">                return error;</span>
            }
        }

        final LongSupplier millisSinceEpoch;

<span class="fc" id="L178">        private volatile AlmostSameTime almostSameTime = new AlmostSameTime(0L, 0L, Long.MAX_VALUE);</span>
        private Future&lt;?&gt; almostSameTimeUpdater;
<span class="fc" id="L180">        private static double failedAlmostSameTimeUpdateModifier = 1.0;</span>

        AbstractEpochSamplingClock(LongSupplier millisSinceEpoch)
<span class="fc" id="L183">        {</span>
<span class="fc" id="L184">            this.millisSinceEpoch = millisSinceEpoch;</span>
<span class="fc" id="L185">            resumeEpochSampling();</span>
<span class="fc" id="L186">        }</span>

        public MonotonicClockTranslation translate()
        {
<span class="nc" id="L190">            return almostSameTime;</span>
        }

        public synchronized void pauseEpochSampling()
        {
<span class="nc bnc" id="L195" title="All 2 branches missed.">            if (almostSameTimeUpdater == null)</span>
<span class="nc" id="L196">                return;</span>

<span class="nc" id="L198">            almostSameTimeUpdater.cancel(true);</span>
<span class="nc" id="L199">            try { almostSameTimeUpdater.get(); } catch (Throwable t) { }</span>
<span class="nc" id="L200">            almostSameTimeUpdater = null;</span>
<span class="nc" id="L201">        }</span>

        public synchronized void resumeEpochSampling()
        {
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">            if (almostSameTimeUpdater != null)</span>
<span class="nc" id="L206">                throw new IllegalStateException(&quot;Already running&quot;);</span>
<span class="fc" id="L207">            updateAlmostSameTime();</span>
<span class="fc" id="L208">            logger.info(&quot;Scheduling approximate time conversion task with an interval of {} milliseconds&quot;, UPDATE_INTERVAL_MS);</span>
<span class="fc" id="L209">            almostSameTimeUpdater = ScheduledExecutors.scheduledFastTasks.scheduleWithFixedDelay(this::updateAlmostSameTime, UPDATE_INTERVAL_MS, UPDATE_INTERVAL_MS, MILLISECONDS);</span>
<span class="fc" id="L210">        }</span>

        private void updateAlmostSameTime()
        {
<span class="fc" id="L214">            final int tries = 3;</span>
<span class="fc" id="L215">            long[] samples = new long[2 * tries + 1];</span>
<span class="fc" id="L216">            samples[0] = nanoTime();</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">            for (int i = 1 ; i &lt; samples.length ; i += 2)</span>
            {
<span class="fc" id="L219">                samples[i] = millisSinceEpoch.getAsLong();</span>
<span class="fc" id="L220">                samples[i + 1] = now();</span>
            }

<span class="fc" id="L223">            int best = 1;</span>
            // take sample with minimum delta between calls
<span class="fc bfc" id="L225" title="All 2 branches covered.">            for (int i = 3 ; i &lt; samples.length - 1 ; i += 2)</span>
            {
<span class="fc bfc" id="L227" title="All 2 branches covered.">                if ((samples[i+1] - samples[i-1]) &lt; (samples[best+1]-samples[best-1]))</span>
<span class="fc" id="L228">                    best = i;</span>
            }

<span class="fc" id="L231">            long millis = samples[best];</span>
<span class="fc" id="L232">            long nanos = (samples[best+1] / 2) + (samples[best-1] / 2);</span>
<span class="fc" id="L233">            long error = (samples[best+1] / 2) - (samples[best-1] / 2);</span>

<span class="fc" id="L235">            AlmostSameTime prev = almostSameTime;</span>
<span class="fc" id="L236">            AlmostSameTime next = new AlmostSameTime(millis, nanos, error);</span>

<span class="fc bfc" id="L238" title="All 4 branches covered.">            if (next.error &gt; prev.error &amp;&amp; next.error &gt; prev.error * failedAlmostSameTimeUpdateModifier)</span>
            {
<span class="fc" id="L240">                failedAlmostSameTimeUpdateModifier *= 1.1;</span>
<span class="fc" id="L241">                return;</span>
            }

<span class="fc" id="L244">            failedAlmostSameTimeUpdateModifier = 1.0;</span>
<span class="fc" id="L245">            almostSameTime = next;</span>
<span class="fc" id="L246">        }</span>
    }

    public static class SystemClock extends AbstractEpochSamplingClock
    {
        private SystemClock()
        {
<span class="fc" id="L253">            super(Clock.Global::currentTimeMillis);</span>
<span class="fc" id="L254">        }</span>

        @Override
        public long now()
        {
<span class="fc" id="L259">            return nanoTime();</span>
        }

        @Override
        public long error()
        {
<span class="nc" id="L265">            return 1;</span>
        }

        @Override
        public boolean isAfter(long instant)
        {
<span class="nc bnc" id="L271" title="All 2 branches missed.">            return now() &gt; instant;</span>
        }

        @Override
        public boolean isAfter(long now, long instant)
        {
<span class="nc bnc" id="L277" title="All 2 branches missed.">            return now &gt; instant;</span>
        }
    }

    public static class SampledClock implements MonotonicClock
    {
<span class="fc" id="L283">        private static final Logger logger = LoggerFactory.getLogger(SampledClock.class);</span>
<span class="fc" id="L284">        private static final int UPDATE_INTERVAL_MS = Math.max(1, APPROXIMATE_TIME_PRECISION_MS.getInt());</span>
<span class="fc" id="L285">        private static final long ERROR_NANOS = MILLISECONDS.toNanos(UPDATE_INTERVAL_MS);</span>

        private final MonotonicClock precise;

        private volatile long almostNow;
        private Future&lt;?&gt; almostNowUpdater;

        public SampledClock(MonotonicClock precise)
<span class="fc" id="L293">        {</span>
<span class="fc" id="L294">            this.precise = precise;</span>
<span class="fc" id="L295">            resumeNowSampling();</span>
<span class="fc" id="L296">        }</span>

        @Override
        public long now()
        {
<span class="fc" id="L301">            return almostNow;</span>
        }

        @Override
        public long error()
        {
<span class="fc" id="L307">            return ERROR_NANOS;</span>
        }

        @Override
        public MonotonicClockTranslation translate()
        {
<span class="nc" id="L313">            return precise.translate();</span>
        }

        @Override
        public boolean isAfter(long instant)
        {
<span class="fc" id="L319">            return isAfter(almostNow, instant);</span>
        }

        @Override
        public boolean isAfter(long now, long instant)
        {
<span class="fc bfc" id="L325" title="All 2 branches covered.">            return now - ERROR_NANOS &gt; instant;</span>
        }

        public synchronized void pauseNowSampling()
        {
<span class="nc bnc" id="L330" title="All 2 branches missed.">            if (almostNowUpdater == null)</span>
<span class="nc" id="L331">                return;</span>

<span class="nc" id="L333">            almostNowUpdater.cancel(true);</span>
<span class="nc" id="L334">            try { almostNowUpdater.get(); } catch (Throwable t) { }</span>
<span class="nc" id="L335">            almostNowUpdater = null;</span>
<span class="nc" id="L336">        }</span>

        public synchronized void resumeNowSampling()
        {
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">            if (almostNowUpdater != null)</span>
<span class="nc" id="L341">                throw new IllegalStateException(&quot;Already running&quot;);</span>

<span class="fc" id="L343">            almostNow = precise.now();</span>
<span class="fc" id="L344">            logger.info(&quot;Scheduling approximate time-check task with a precision of {} milliseconds&quot;, UPDATE_INTERVAL_MS);</span>
<span class="fc" id="L345">            almostNowUpdater = ScheduledExecutors.scheduledFastTasks.scheduleWithFixedDelay(() -&gt; almostNow = precise.now(), UPDATE_INTERVAL_MS, UPDATE_INTERVAL_MS, MILLISECONDS);</span>
<span class="fc" id="L346">        }</span>

        public synchronized void refreshNow()
        {
<span class="nc" id="L350">            pauseNowSampling();</span>
<span class="nc" id="L351">            resumeNowSampling();</span>
<span class="nc" id="L352">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>